{"snippet": "linalg.eigvals(a)", "intent": "Compute the eigenvalues of `a` general matrix .", "question_id": 0},
{"snippet": "numpy.fromfunction(function, shape, **kwargs)", "intent": "Construct an array by executing a `function` over each coordinate . With arguments `shape`, `**kwargs`.", "question_id": 1},
{"snippet": "numpy.fromfunction(function, shape, **kwargs, dtype=<class 'float'>)", "intent": "Construct an array by executing a `function` over each coordinate . Keywords other than `dtype` are passed to function . With arguments `shape`, `**kwargs`.", "question_id": 2},
{"snippet": "numpy.fromfunction(function, shape, **kwargs, like=None)", "intent": "Construct an array by executing a `function` over each coordinate . With arguments `shape`, `**kwargs`, `like`.", "question_id": 3},
{"snippet": "numpy.fromfunction(function, shape, **kwargs, dtype=<class 'float'>, like=None)", "intent": "Construct an array by executing a `function` over each coordinate . Keywords other than `dtype` are passed to function . With arguments `shape`, `**kwargs`, `like`.", "question_id": 4},
{"snippet": "numpy.greater_equal(x1, x2, /, signature, extobj)", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`.", "question_id": 5},
{"snippet": "numpy.greater_equal(x1, x2, /, signature, extobj, out=None)", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 6},
{"snippet": "numpy.greater_equal(x1, x2, /, signature, extobj, where=True)", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 7},
{"snippet": "numpy.greater_equal(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 8},
{"snippet": "numpy.greater_equal(x1, x2, /, signature, extobj, order='K')", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 9},
{"snippet": "numpy.greater_equal(x1, x2, /, signature, extobj, dtype=None)", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 10},
{"snippet": "numpy.greater_equal(x1, x2, /, signature, extobj, subok=True)", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 11},
{"snippet": "numpy.greater_equal(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 12},
{"snippet": "numpy.greater_equal(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 13},
{"snippet": "numpy.greater_equal(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 14},
{"snippet": "numpy.greater_equal(x1, x2, /, signature)", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`.", "question_id": 15},
{"snippet": "numpy.greater_equal(x1, x2, /, signature, out=None)", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `out`.", "question_id": 16},
{"snippet": "numpy.greater_equal(x1, x2, /, signature, where=True)", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `where`.", "question_id": 17},
{"snippet": "numpy.greater_equal(x1, x2, /, signature, casting='same_kind')", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `casting`.", "question_id": 18},
{"snippet": "numpy.greater_equal(x1, x2, /, signature, order='K')", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `order`.", "question_id": 19},
{"snippet": "numpy.greater_equal(x1, x2, /, signature, dtype=None)", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `dtype`.", "question_id": 20},
{"snippet": "numpy.greater_equal(x1, x2, /, signature, subok=True)", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `subok`.", "question_id": 21},
{"snippet": "numpy.greater_equal(x1, x2, /, signature, out=None, where=True)", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `out`, `where`.", "question_id": 22},
{"snippet": "numpy.greater_equal(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 23},
{"snippet": "numpy.greater_equal(x1, x2, /, signature, out=None, order='K')", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `out`, `order`.", "question_id": 24},
{"snippet": "polynomial.polynomial.Polynomial.trim()", "intent": "Remove trailing coefficients", "question_id": 25},
{"snippet": "polynomial.polynomial.Polynomial.trim(tol=0)", "intent": "Remove trailing coefficients Remove trailing coefficients until a coefficient is reached whose absolute value greater than `tol` or the beginning of the series is reached .", "question_id": 26},
{"snippet": "memmap.itemset(*args)", "intent": "Insert scalar into an array ( scalar is cast to array \u2019 s dtype , if possible ) With arguments `*args`.", "question_id": 27},
{"snippet": "ndarray.size", "intent": "Number of elements in the array.", "question_id": 28},
{"snippet": "polynomial.polynomial.polyroots(c)", "intent": "Compute the roots of a polynomial . With arguments `c`.", "question_id": 29},
{"snippet": "generic.__array_priority__", "intent": "Array priority.", "question_id": 30},
{"snippet": "polynomial.polynomial.polyline(off, scl)", "intent": "Returns an array representing a linear polynomial . With arguments `off`, `scl`.", "question_id": 31},
{"snippet": "numpy.getbufsize()", "intent": "Return the size of the buffer used in ufuncs .", "question_id": 32},
{"snippet": "chararray.squeeze()", "intent": "Remove axes of length one from a .", "question_id": 33},
{"snippet": "chararray.squeeze(axis=None)", "intent": "Remove axes of length one from a . With arguments `axis`.", "question_id": 34},
{"snippet": "ma.MaskType.itemsize", "intent": "The length of one element in bytes.", "question_id": 35},
{"snippet": "char.isdecimal(a)", "intent": "For each element , return True if there are only decimal characters in the element . With arguments `a`.", "question_id": 36},
{"snippet": "polynomial.legendre.Legendre.fromroots(roots)", "intent": "Return series instance that has the specified `roots` .", "question_id": 37},
{"snippet": "polynomial.legendre.Legendre.fromroots(roots, domain=)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`.", "question_id": 38},
{"snippet": "polynomial.legendre.Legendre.fromroots(roots, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `window`.", "question_id": 39},
{"snippet": "polynomial.legendre.Legendre.fromroots(roots, domain=, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`, `window`.", "question_id": 40},
{"snippet": "polynomial.legendre.Legendre.fromroots()", "intent": "Return series instance that has the specified `roots` .", "question_id": 41},
{"snippet": "polynomial.legendre.Legendre.fromroots(domain=)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`.", "question_id": 42},
{"snippet": "polynomial.legendre.Legendre.fromroots(window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `window`.", "question_id": 43},
{"snippet": "polynomial.legendre.Legendre.fromroots(domain=, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`, `window`.", "question_id": 44},
{"snippet": "polynomial.hermite_e.hermepow(c, pow)", "intent": "Raise a Hermite series to a power . Returns the Hermite series `c` raised to the power `pow` .", "question_id": 45},
{"snippet": "polynomial.hermite_e.hermepow(c, pow, maxpower=16)", "intent": "Raise a Hermite series to a power . Returns the Hermite series `c` raised to the power `pow` . With arguments `maxpower`.", "question_id": 46},
{"snippet": "numpy.genfromtxt(fname)", "intent": "Load data from a text file , with missing values handled as specified . With arguments `fname`.", "question_id": 47},
{"snippet": "numpy.genfromtxt(fname, dtype=<class 'float'>)", "intent": "Load data from a text file , with missing values handled as specified . Comma delimited file with mixed `dtype` With arguments `fname`.", "question_id": 48},
{"snippet": "numpy.genfromtxt(fname, comments='#')", "intent": "Load data from a text file , with missing values handled as specified . Each line past the first `skip_header` lines is split at the `delimiter` character , and characters following the `comments` character are discarded . With arguments `fname`.", "question_id": 49},
{"snippet": "numpy.genfromtxt(fname, delimiter=None)", "intent": "Load data from a text file , with missing values handled as specified . Each line past the first `skip_header` lines is split at the `delimiter` character , and characters following the `comments` character are discarded . With arguments `fname`.", "question_id": 50},
{"snippet": "numpy.genfromtxt(fname, skip_header=0)", "intent": "Load data from a text file , with missing values handled as specified . Each line past the first `skip_header` lines is split at the `delimiter` character , and characters following the `comments` character are discarded . With arguments `fname`.", "question_id": 51},
{"snippet": "numpy.genfromtxt(fname, skip_footer=0)", "intent": "Load data from a text file , with missing values handled as specified . With arguments `fname`, `skip_footer`.", "question_id": 52},
{"snippet": "numpy.genfromtxt(fname, converters=None)", "intent": "Load data from a text file , with missing values handled as specified . With arguments `fname`, `converters`.", "question_id": 53},
{"snippet": "numpy.genfromtxt(fname, missing_values=None)", "intent": "Load data from a text file , with missing values handled as specified . With arguments `fname`, `missing_values`.", "question_id": 54},
{"snippet": "numpy.genfromtxt(fname, filling_values=None)", "intent": "Load data from a text file , with missing values handled as specified . With arguments `fname`, `filling_values`.", "question_id": 55},
{"snippet": "numpy.genfromtxt(fname, usecols=None)", "intent": "Load data from a text file , with missing values handled as specified . With arguments `fname`, `usecols`.", "question_id": 56},
{"snippet": "numpy.genfromtxt()", "intent": "Load data from a text file , with missing values handled as specified .", "question_id": 57},
{"snippet": "numpy.genfromtxt(dtype=<class 'float'>)", "intent": "Load data from a text file , with missing values handled as specified . Comma delimited file with mixed `dtype`", "question_id": 58},
{"snippet": "numpy.genfromtxt(comments='#')", "intent": "Load data from a text file , with missing values handled as specified . Each line past the first `skip_header` lines is split at the `delimiter` character , and characters following the `comments` character are discarded .", "question_id": 59},
{"snippet": "numpy.genfromtxt(delimiter=None)", "intent": "Load data from a text file , with missing values handled as specified . Each line past the first `skip_header` lines is split at the `delimiter` character , and characters following the `comments` character are discarded .", "question_id": 60},
{"snippet": "numpy.genfromtxt(skip_header=0)", "intent": "Load data from a text file , with missing values handled as specified . Each line past the first `skip_header` lines is split at the `delimiter` character , and characters following the `comments` character are discarded .", "question_id": 61},
{"snippet": "numpy.genfromtxt(skip_footer=0)", "intent": "Load data from a text file , with missing values handled as specified . With arguments `skip_footer`.", "question_id": 62},
{"snippet": "numpy.genfromtxt(converters=None)", "intent": "Load data from a text file , with missing values handled as specified . With arguments `converters`.", "question_id": 63},
{"snippet": "numpy.genfromtxt(missing_values=None)", "intent": "Load data from a text file , with missing values handled as specified . With arguments `missing_values`.", "question_id": 64},
{"snippet": "numpy.genfromtxt(filling_values=None)", "intent": "Load data from a text file , with missing values handled as specified . With arguments `filling_values`.", "question_id": 65},
{"snippet": "numpy.genfromtxt(usecols=None)", "intent": "Load data from a text file , with missing values handled as specified . With arguments `usecols`.", "question_id": 66},
{"snippet": "chararray.sum()", "intent": "Return the sum of the array elements over the given `axis` .", "question_id": 67},
{"snippet": "chararray.sum(axis=None)", "intent": "Return the sum of the array elements over the given `axis` .", "question_id": 68},
{"snippet": "chararray.sum(dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 69},
{"snippet": "chararray.sum(out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`.", "question_id": 70},
{"snippet": "chararray.sum(keepdims=False)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`.", "question_id": 71},
{"snippet": "chararray.sum(initial=0)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `initial`.", "question_id": 72},
{"snippet": "chararray.sum(where=True)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `where`.", "question_id": 73},
{"snippet": "chararray.sum(axis=None, dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 74},
{"snippet": "chararray.sum(axis=None, out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`.", "question_id": 75},
{"snippet": "chararray.sum(axis=None, keepdims=False)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`.", "question_id": 76},
{"snippet": "char.find(a, sub)", "intent": "For each element , return the lowest index in the string where substring `sub` is found . With arguments `a`.", "question_id": 77},
{"snippet": "char.find(a, sub, start=0)", "intent": "For each element , return the lowest index in the string where substring `sub` is found . For each element , return the lowest index in the string where substring sub is found , such that sub is contained in the range [ `start` , `end` ] . With arguments `a`.", "question_id": 78},
{"snippet": "char.find(a, sub, end=None)", "intent": "For each element , return the lowest index in the string where substring `sub` is found . For each element , return the lowest index in the string where substring sub is found , such that sub is contained in the range [ `start` , `end` ] . With arguments `a`.", "question_id": 79},
{"snippet": "char.find(a, sub, start=0, end=None)", "intent": "For each element , return the lowest index in the string where substring `sub` is found . For each element , return the lowest index in the string where substring sub is found , such that sub is contained in the range [ `start` , `end` ] . With arguments `a`.", "question_id": 80},
{"snippet": "ufunc.outer(A, B, /, **kwargs)", "intent": "Apply the ufunc op to all pairs ( a , b ) with a in `A` and b in `B` . With arguments `/`, `**kwargs`.", "question_id": 81},
{"snippet": "polynomial.hermite.herm2poly(c)", "intent": "Convert a Hermite series to a polynomial . With arguments `c`.", "question_id": 82},
{"snippet": "random.RandomState.rayleigh()", "intent": "Draw samples from a Rayleigh distribution .", "question_id": 83},
{"snippet": "random.RandomState.rayleigh(scale=1.0)", "intent": "Draw samples from a Rayleigh distribution . With arguments `scale`.", "question_id": 84},
{"snippet": "random.RandomState.rayleigh(size=None)", "intent": "Draw samples from a Rayleigh distribution . With arguments `size`.", "question_id": 85},
{"snippet": "random.RandomState.rayleigh(scale=1.0, size=None)", "intent": "Draw samples from a Rayleigh distribution . With arguments `scale`, `size`.", "question_id": 86},
{"snippet": "ma.MaskType.conjugate()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 87},
{"snippet": "recarray.itemset(*args)", "intent": "Insert scalar into an array ( scalar is cast to array \u2019 s dtype , if possible ) With arguments `*args`.", "question_id": 88},
{"snippet": "polynomial.hermite.Hermite.truncate(size)", "intent": "Truncate series to length `size` .", "question_id": 89},
{"snippet": "random.Generator.power(a)", "intent": "Draws samples in [ 0 , 1 ] from `a` power distribution with positive exponent a - 1 .", "question_id": 90},
{"snippet": "random.Generator.power(a, size=None)", "intent": "Draws samples in [ 0 , 1 ] from `a` power distribution with positive exponent a - 1 . With arguments `size`.", "question_id": 91},
{"snippet": "ndarray.__divmod__(value, /)", "intent": "Return divmod ( self , `value` ) . With arguments `/`.", "question_id": 92},
{"snippet": "ma.argmax(self)", "intent": "Returns array of indices of the maximum values along the given `axis` . With arguments `self`.", "question_id": 93},
{"snippet": "ma.argmax(self, axis=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . With arguments `self`.", "question_id": 94},
{"snippet": "ma.argmax(self, fill_value=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . Masked values are treated as if they had the value `fill_value` . With arguments `self`.", "question_id": 95},
{"snippet": "ma.argmax(self, out=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . With arguments `self`, `out`.", "question_id": 96},
{"snippet": "ma.argmax(self, axis=None, fill_value=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . Masked values are treated as if they had the value `fill_value` . With arguments `self`.", "question_id": 97},
{"snippet": "ma.argmax(self, axis=None, out=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . With arguments `self`, `out`.", "question_id": 98},
{"snippet": "ma.argmax(self, fill_value=None, out=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . Masked values are treated as if they had the value `fill_value` . With arguments `self`, `out`.", "question_id": 99},
{"snippet": "ma.argmax(self, axis=None, fill_value=None, out=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . Masked values are treated as if they had the value `fill_value` . With arguments `self`, `out`.", "question_id": 100},
{"snippet": "numpy.empty_like(prototype)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`.", "question_id": 101},
{"snippet": "numpy.empty_like(prototype, dtype=None)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `dtype`.", "question_id": 102},
{"snippet": "numpy.empty_like(prototype, order='K')", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `order`.", "question_id": 103},
{"snippet": "numpy.empty_like(prototype, subok=True)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `subok`.", "question_id": 104},
{"snippet": "numpy.empty_like(prototype, shape=None)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`.", "question_id": 105},
{"snippet": "numpy.empty_like(prototype, dtype=None, order='K')", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `dtype`, `order`.", "question_id": 106},
{"snippet": "numpy.empty_like(prototype, dtype=None, subok=True)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `dtype`, `subok`.", "question_id": 107},
{"snippet": "numpy.empty_like(prototype, dtype=None, shape=None)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `dtype`.", "question_id": 108},
{"snippet": "numpy.empty_like(prototype, order='K', subok=True)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `order`, `subok`.", "question_id": 109},
{"snippet": "numpy.empty_like(prototype, order='K', shape=None)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `order`.", "question_id": 110},
{"snippet": "numpy.busdaycalendar()", "intent": "A business day calendar object that efficiently stores information defining valid days for the busday family of functions .", "question_id": 111},
{"snippet": "numpy.busdaycalendar(weekmask='1111100')", "intent": "A business day calendar object that efficiently stores information defining valid days for the busday family of functions . Once a busdaycalendar object is created , the `weekmask` and `holidays` can not be modified .", "question_id": 112},
{"snippet": "numpy.busdaycalendar(holidays=None)", "intent": "A business day calendar object that efficiently stores information defining valid days for the busday family of functions . Once a busdaycalendar object is created , the `weekmask` and `holidays` can not be modified .", "question_id": 113},
{"snippet": "numpy.busdaycalendar(weekmask='1111100', holidays=None)", "intent": "A business day calendar object that efficiently stores information defining valid days for the busday family of functions . Once a busdaycalendar object is created , the `weekmask` and `holidays` can not be modified .", "question_id": 114},
{"snippet": "char.chararray.view(dtype, type)", "intent": "New view of array with the same data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) Viewing array data using a different `type` and dtype :", "question_id": 115},
{"snippet": "char.chararray.view(dtype)", "intent": "New view of array with the same data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . )", "question_id": 116},
{"snippet": "char.chararray.view()", "intent": "New view of array with the same data .", "question_id": 117},
{"snippet": "random.logistic()", "intent": "Draw samples from a logistic distribution .", "question_id": 118},
{"snippet": "random.logistic(loc=0.0)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) .", "question_id": 119},
{"snippet": "random.logistic(scale=1.0)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) .", "question_id": 120},
{"snippet": "random.logistic(size=None)", "intent": "Draw samples from a logistic distribution . With arguments `size`.", "question_id": 121},
{"snippet": "random.logistic(loc=0.0, scale=1.0)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) .", "question_id": 122},
{"snippet": "random.logistic(loc=0.0, size=None)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . With arguments `size`.", "question_id": 123},
{"snippet": "random.logistic(scale=1.0, size=None)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . With arguments `size`.", "question_id": 124},
{"snippet": "random.logistic(loc=0.0, scale=1.0, size=None)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . With arguments `size`.", "question_id": 125},
{"snippet": "ma.shape(obj)", "intent": "Return the shape of an array . With arguments `obj`.", "question_id": 126},
{"snippet": "memmap.shape", "intent": "Tuple of array dimensions.", "question_id": 127},
{"snippet": "numpy.flipud(m)", "intent": "Reverse the order of elements along axis 0 ( up/down ) . Equivalent to `m` [ : :-1 , ... ] or np.flip ( m , axis=0 ) .", "question_id": 128},
{"snippet": "random.power(a)", "intent": "Draws samples in [ 0 , 1 ] from `a` power distribution with positive exponent a - 1 .", "question_id": 129},
{"snippet": "random.power(a, size=None)", "intent": "Draws samples in [ 0 , 1 ] from `a` power distribution with positive exponent a - 1 . With arguments `size`.", "question_id": 130},
{"snippet": "ndarray.__eq__(value, /)", "intent": "Return self==value . With arguments `value`, `/`.", "question_id": 131},
{"snippet": "matrix.searchsorted(v)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order .", "question_id": 132},
{"snippet": "matrix.searchsorted(v, side='left')", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`.", "question_id": 133},
{"snippet": "matrix.searchsorted(v, sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `sorter`.", "question_id": 134},
{"snippet": "matrix.searchsorted(v, side='left', sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`, `sorter`.", "question_id": 135},
{"snippet": "record.max()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 136},
{"snippet": "polynomial.legendre.leggrid2d(x, y, c)", "intent": "Evaluate a 2-D Legendre series on the Cartesian product of `x` and `y` . In either case , either x and y or their elements must support multiplication and addition both with themselves and with the elements of `c` .", "question_id": 137},
{"snippet": "ma.masked_array.nbytes", "intent": "Total bytes consumed by the elements of the array.", "question_id": 138},
{"snippet": "ma.nonzero(self)", "intent": "Return the indices of unmasked elements that are not zero . With arguments `self`.", "question_id": 139},
{"snippet": "memmap.reshape(shape)", "intent": "Returns an array containing the same data with a new `shape` .", "question_id": 140},
{"snippet": "memmap.reshape(shape, order='C')", "intent": "Returns an array containing the same data with a new `shape` . With arguments `order`.", "question_id": 141},
{"snippet": "ma.masked_outside(x, v1, v2)", "intent": "Mask an array outside a given interval . Shortcut to masked_where , where condition is True for `x` outside the interval [ `v1` , `v2` ] ( x < v1 ) | ( x > v2 ) .", "question_id": 142},
{"snippet": "ma.masked_outside(x, v1, v2, copy=True)", "intent": "Mask an array outside a given interval . Shortcut to masked_where , where condition is True for `x` outside the interval [ `v1` , `v2` ] ( x < v1 ) | ( x > v2 ) . With arguments `copy`.", "question_id": 143},
{"snippet": "numpy.nanquantile(a, q)", "intent": "Compute the qth quantile of the data along the specified `axis` , while ignoring nan values . With arguments `a`, `q`.", "question_id": 144},
{"snippet": "numpy.nanquantile(a, q, axis=None)", "intent": "Compute the qth quantile of the data along the specified `axis` , while ignoring nan values . With arguments `a`, `q`.", "question_id": 145},
{"snippet": "numpy.nanquantile(a, q, out=None)", "intent": "Compute the qth quantile of the data along the specified `axis` , while ignoring nan values . With arguments `a`, `q`, `out`.", "question_id": 146},
{"snippet": "numpy.nanquantile(a, q, overwrite_input=False)", "intent": "Compute the qth quantile of the data along the specified `axis` , while ignoring nan values . With arguments `a`, `q`, `overwrite_input`.", "question_id": 147},
{"snippet": "numpy.nanquantile(a, q, interpolation='linear')", "intent": "Compute the qth quantile of the data along the specified `axis` , while ignoring nan values . With arguments `a`, `q`, `interpolation`.", "question_id": 148},
{"snippet": "numpy.nanquantile(a, q, keepdims=<no value>)", "intent": "Compute the qth quantile of the data along the specified `axis` , while ignoring nan values . With arguments `a`, `q`, `keepdims`.", "question_id": 149},
{"snippet": "numpy.nanquantile(a, q, axis=None, out=None)", "intent": "Compute the qth quantile of the data along the specified `axis` , while ignoring nan values . With arguments `a`, `q`, `out`.", "question_id": 150},
{"snippet": "numpy.nanquantile(a, q, axis=None, overwrite_input=False)", "intent": "Compute the qth quantile of the data along the specified `axis` , while ignoring nan values . With arguments `a`, `q`, `overwrite_input`.", "question_id": 151},
{"snippet": "numpy.nanquantile(a, q, axis=None, interpolation='linear')", "intent": "Compute the qth quantile of the data along the specified `axis` , while ignoring nan values . With arguments `a`, `q`, `interpolation`.", "question_id": 152},
{"snippet": "numpy.nanquantile(a, q, axis=None, keepdims=<no value>)", "intent": "Compute the qth quantile of the data along the specified `axis` , while ignoring nan values . With arguments `a`, `q`, `keepdims`.", "question_id": 153},
{"snippet": "numpy.source(object)", "intent": "Print or write to a file the source code for a NumPy `object` .", "question_id": 154},
{"snippet": "numpy.source(object, output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>)", "intent": "Print or write to a file the source code for a NumPy `object` . With arguments `output`.", "question_id": 155},
{"snippet": "ma.masked_array.var()", "intent": "Compute the variance along the specified `axis` .", "question_id": 156},
{"snippet": "ma.masked_array.var(axis=None)", "intent": "Compute the variance along the specified `axis` .", "question_id": 157},
{"snippet": "ma.masked_array.var(dtype=None)", "intent": "Compute the variance along the specified `axis` . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue .", "question_id": 158},
{"snippet": "ma.masked_array.var(out=None)", "intent": "Compute the variance along the specified `axis` . With arguments `out`.", "question_id": 159},
{"snippet": "ma.masked_array.var(ddof=0)", "intent": "Compute the variance along the specified `axis` . If , however , `ddof` is specified , the divisor N - ddof is used instead .", "question_id": 160},
{"snippet": "ma.masked_array.var(keepdims=<no value>)", "intent": "Compute the variance along the specified `axis` . With arguments `keepdims`.", "question_id": 161},
{"snippet": "ma.masked_array.var(axis=None, dtype=None)", "intent": "Compute the variance along the specified `axis` . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue .", "question_id": 162},
{"snippet": "ma.masked_array.var(axis=None, out=None)", "intent": "Compute the variance along the specified `axis` . With arguments `out`.", "question_id": 163},
{"snippet": "ma.masked_array.var(axis=None, ddof=0)", "intent": "Compute the variance along the specified `axis` . If , however , `ddof` is specified , the divisor N - ddof is used instead .", "question_id": 164},
{"snippet": "ma.masked_array.var(axis=None, keepdims=<no value>)", "intent": "Compute the variance along the specified `axis` . With arguments `keepdims`.", "question_id": 165},
{"snippet": "ma.MaskType.cumprod()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 166},
{"snippet": "dtype.flags", "intent": "Bit-flags describing how this data type is to be interpreted.", "question_id": 167},
{"snippet": "linalg.norm(x)", "intent": "Matrix or vector norm . With arguments `x`.", "question_id": 168},
{"snippet": "linalg.norm(x, ord=None)", "intent": "Matrix or vector norm . This function is able to return one of eight different matrix norms , or one of an infinite number of vector norms ( described below ) , depending on the value of the `ord` parameter . With arguments `x`.", "question_id": 169},
{"snippet": "linalg.norm(x, axis=None)", "intent": "Matrix or vector norm . Using the `axis` argument to compute vector norms : With arguments `x`.", "question_id": 170},
{"snippet": "linalg.norm(x, keepdims=False)", "intent": "Matrix or vector norm . With arguments `x`, `keepdims`.", "question_id": 171},
{"snippet": "linalg.norm(x, ord=None, axis=None)", "intent": "Matrix or vector norm . This function is able to return one of eight different matrix norms , or one of an infinite number of vector norms ( described below ) , depending on the value of the `ord` parameter . Using the `axis` argument to compute vector norms : With arguments `x`.", "question_id": 172},
{"snippet": "linalg.norm(x, ord=None, keepdims=False)", "intent": "Matrix or vector norm . This function is able to return one of eight different matrix norms , or one of an infinite number of vector norms ( described below ) , depending on the value of the `ord` parameter . With arguments `x`, `keepdims`.", "question_id": 173},
{"snippet": "linalg.norm(x, axis=None, keepdims=False)", "intent": "Matrix or vector norm . Using the `axis` argument to compute vector norms : With arguments `x`, `keepdims`.", "question_id": 174},
{"snippet": "linalg.norm(x, ord=None, axis=None, keepdims=False)", "intent": "Matrix or vector norm . This function is able to return one of eight different matrix norms , or one of an infinite number of vector norms ( described below ) , depending on the value of the `ord` parameter . Using the `axis` argument to compute vector norms : With arguments `x`, `keepdims`.", "question_id": 175},
{"snippet": "char.chararray.imag", "intent": "The imaginary part of the array.", "question_id": 176},
{"snippet": "numpy.ndindex(*shape)", "intent": "An N-dimensional iterator object to index arrays . With arguments `*shape`.", "question_id": 177},
{"snippet": "memmap.argmax()", "intent": "Return indices of the maximum values along the given `axis` .", "question_id": 178},
{"snippet": "memmap.argmax(axis=None)", "intent": "Return indices of the maximum values along the given `axis` .", "question_id": 179},
{"snippet": "memmap.argmax(out=None)", "intent": "Return indices of the maximum values along the given `axis` . With arguments `out`.", "question_id": 180},
{"snippet": "memmap.argmax(axis=None, out=None)", "intent": "Return indices of the maximum values along the given `axis` . With arguments `out`.", "question_id": 181},
{"snippet": "numpy.cos(x, /, signature, extobj)", "intent": "Cosine element-wise . With arguments `x`, `/`, `signature`, `extobj`.", "question_id": 182},
{"snippet": "numpy.cos(x, /, signature, extobj, out=None)", "intent": "Cosine element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `x`, `/`, `signature`, `extobj`.", "question_id": 183},
{"snippet": "numpy.cos(x, /, signature, extobj, where=True)", "intent": "Cosine element-wise . With arguments `x`, `/`, `signature`, `extobj`, `where`.", "question_id": 184},
{"snippet": "numpy.cos(x, /, signature, extobj, casting='same_kind')", "intent": "Cosine element-wise . With arguments `x`, `/`, `signature`, `extobj`, `casting`.", "question_id": 185},
{"snippet": "numpy.cos(x, /, signature, extobj, order='K')", "intent": "Cosine element-wise . With arguments `x`, `/`, `signature`, `extobj`, `order`.", "question_id": 186},
{"snippet": "numpy.cos(x, /, signature, extobj, dtype=None)", "intent": "Cosine element-wise . With arguments `x`, `/`, `signature`, `extobj`, `dtype`.", "question_id": 187},
{"snippet": "numpy.cos(x, /, signature, extobj, subok=True)", "intent": "Cosine element-wise . With arguments `x`, `/`, `signature`, `extobj`, `subok`.", "question_id": 188},
{"snippet": "numpy.cos(x, /, signature, extobj, out=None, where=True)", "intent": "Cosine element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `x`, `/`, `signature`, `extobj`, `where`.", "question_id": 189},
{"snippet": "numpy.cos(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Cosine element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `x`, `/`, `signature`, `extobj`, `casting`.", "question_id": 190},
{"snippet": "numpy.cos(x, /, signature, extobj, out=None, order='K')", "intent": "Cosine element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `x`, `/`, `signature`, `extobj`, `order`.", "question_id": 191},
{"snippet": "numpy.cos(x, /, signature)", "intent": "Cosine element-wise . With arguments `x`, `/`, `signature`.", "question_id": 192},
{"snippet": "numpy.cos(x, /, signature, out=None)", "intent": "Cosine element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `x`, `/`, `signature`.", "question_id": 193},
{"snippet": "numpy.cos(x, /, signature, where=True)", "intent": "Cosine element-wise . With arguments `x`, `/`, `signature`, `where`.", "question_id": 194},
{"snippet": "numpy.cos(x, /, signature, casting='same_kind')", "intent": "Cosine element-wise . With arguments `x`, `/`, `signature`, `casting`.", "question_id": 195},
{"snippet": "numpy.cos(x, /, signature, order='K')", "intent": "Cosine element-wise . With arguments `x`, `/`, `signature`, `order`.", "question_id": 196},
{"snippet": "numpy.cos(x, /, signature, dtype=None)", "intent": "Cosine element-wise . With arguments `x`, `/`, `signature`, `dtype`.", "question_id": 197},
{"snippet": "numpy.cos(x, /, signature, subok=True)", "intent": "Cosine element-wise . With arguments `x`, `/`, `signature`, `subok`.", "question_id": 198},
{"snippet": "numpy.cos(x, /, signature, out=None, where=True)", "intent": "Cosine element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `x`, `/`, `signature`, `where`.", "question_id": 199},
{"snippet": "numpy.cos(x, /, signature, out=None, casting='same_kind')", "intent": "Cosine element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `x`, `/`, `signature`, `casting`.", "question_id": 200},
{"snippet": "numpy.cos(x, /, signature, out=None, order='K')", "intent": "Cosine element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `x`, `/`, `signature`, `order`.", "question_id": 201},
{"snippet": "ma.corrcoef(x)", "intent": "Return Pearson product-moment correlation coefficients . With arguments `x`.", "question_id": 202},
{"snippet": "ma.corrcoef(x, y=None)", "intent": "Return Pearson product-moment correlation coefficients . With arguments `x`, `y`.", "question_id": 203},
{"snippet": "ma.corrcoef(x, rowvar=True)", "intent": "Return Pearson product-moment correlation coefficients . With arguments `x`, `rowvar`.", "question_id": 204},
{"snippet": "ma.corrcoef(x, bias=<no value>)", "intent": "Return Pearson product-moment correlation coefficients . This function accepts but discards arguments `bias` and `ddof` . With arguments `x`.", "question_id": 205},
{"snippet": "ma.corrcoef(x, allow_masked=True)", "intent": "Return Pearson product-moment correlation coefficients . With arguments `x`, `allow_masked`.", "question_id": 206},
{"snippet": "ma.corrcoef(x, ddof=<no value>)", "intent": "Return Pearson product-moment correlation coefficients . This function accepts but discards arguments `bias` and `ddof` . With arguments `x`.", "question_id": 207},
{"snippet": "ma.corrcoef(x, y=None, rowvar=True)", "intent": "Return Pearson product-moment correlation coefficients . With arguments `x`, `y`, `rowvar`.", "question_id": 208},
{"snippet": "ma.corrcoef(x, y=None, bias=<no value>)", "intent": "Return Pearson product-moment correlation coefficients . This function accepts but discards arguments `bias` and `ddof` . With arguments `x`, `y`.", "question_id": 209},
{"snippet": "ma.corrcoef(x, y=None, allow_masked=True)", "intent": "Return Pearson product-moment correlation coefficients . With arguments `x`, `y`, `allow_masked`.", "question_id": 210},
{"snippet": "ma.corrcoef(x, y=None, ddof=<no value>)", "intent": "Return Pearson product-moment correlation coefficients . This function accepts but discards arguments `bias` and `ddof` . With arguments `x`, `y`.", "question_id": 211},
{"snippet": "ma.is_masked(x)", "intent": "Determine whether input has masked values . Always returns False if `x` isn \u2019 t a MaskedArray .", "question_id": 212},
{"snippet": "ndarray.strides", "intent": "Tuple of bytes to step in each dimension when traversing an array.", "question_id": 213},
{"snippet": "numpy.fromfile(file)", "intent": "Construct an array from data in a text or binary `file` .", "question_id": 214},
{"snippet": "numpy.fromfile(file, dtype=float)", "intent": "Construct an array from data in a text or binary `file` . With arguments `dtype`.", "question_id": 215},
{"snippet": "numpy.fromfile(file, count=- 1)", "intent": "Construct an array from data in a text or binary `file` . With arguments `count`.", "question_id": 216},
{"snippet": "numpy.fromfile(file, sep='')", "intent": "Construct an array from data in a text or binary `file` . With arguments `sep`.", "question_id": 217},
{"snippet": "numpy.fromfile(file, offset=0)", "intent": "Construct an array from data in a text or binary `file` . With arguments `offset`.", "question_id": 218},
{"snippet": "numpy.fromfile(file, like=None)", "intent": "Construct an array from data in a text or binary `file` . With arguments `like`.", "question_id": 219},
{"snippet": "numpy.fromfile(file, dtype=float, count=- 1)", "intent": "Construct an array from data in a text or binary `file` . With arguments `dtype`, `count`.", "question_id": 220},
{"snippet": "numpy.fromfile(file, dtype=float, sep='')", "intent": "Construct an array from data in a text or binary `file` . With arguments `dtype`, `sep`.", "question_id": 221},
{"snippet": "numpy.fromfile(file, dtype=float, offset=0)", "intent": "Construct an array from data in a text or binary `file` . With arguments `dtype`, `offset`.", "question_id": 222},
{"snippet": "numpy.fromfile(file, dtype=float, like=None)", "intent": "Construct an array from data in a text or binary `file` . With arguments `dtype`, `like`.", "question_id": 223},
{"snippet": "testing.assert_array_almost_equal_nulp(x, y)", "intent": "Compare two arrays relatively to their spacing . With arguments `x`, `y`.", "question_id": 224},
{"snippet": "testing.assert_array_almost_equal_nulp(x, y, nulp=1)", "intent": "Compare two arrays relatively to their spacing . With arguments `x`, `y`, `nulp`.", "question_id": 225},
{"snippet": "ma.var(self)", "intent": "Compute the variance along the specified `axis` . With arguments `self`.", "question_id": 226},
{"snippet": "ma.var(self, axis=None)", "intent": "Compute the variance along the specified `axis` . With arguments `self`.", "question_id": 227},
{"snippet": "ma.var(self, dtype=None)", "intent": "Compute the variance along the specified `axis` . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue . With arguments `self`.", "question_id": 228},
{"snippet": "ma.var(self, out=None)", "intent": "Compute the variance along the specified `axis` . With arguments `self`, `out`.", "question_id": 229},
{"snippet": "ma.var(self, ddof=0)", "intent": "Compute the variance along the specified `axis` . If , however , `ddof` is specified , the divisor N - ddof is used instead . With arguments `self`.", "question_id": 230},
{"snippet": "ma.var(self, keepdims=<no value>)", "intent": "Compute the variance along the specified `axis` . With arguments `self`, `keepdims`.", "question_id": 231},
{"snippet": "ma.var(self, axis=None, dtype=None)", "intent": "Compute the variance along the specified `axis` . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue . With arguments `self`.", "question_id": 232},
{"snippet": "ma.var(self, axis=None, out=None)", "intent": "Compute the variance along the specified `axis` . With arguments `self`, `out`.", "question_id": 233},
{"snippet": "ma.var(self, axis=None, ddof=0)", "intent": "Compute the variance along the specified `axis` . If , however , `ddof` is specified , the divisor N - ddof is used instead . With arguments `self`.", "question_id": 234},
{"snippet": "ma.var(self, axis=None, keepdims=<no value>)", "intent": "Compute the variance along the specified `axis` . With arguments `self`, `keepdims`.", "question_id": 235},
{"snippet": "polynomial.hermite_e.hermevander2d(x, y, deg)", "intent": "Pseudo-Vandermonde matrix of given degrees . Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points ( `x` , `y` ) .", "question_id": 236},
{"snippet": "numpy.hypot(x1, x2, /, signature, extobj)", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `extobj`.", "question_id": 237},
{"snippet": "numpy.hypot(x1, x2, /, signature, extobj, out=None)", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 238},
{"snippet": "numpy.hypot(x1, x2, /, signature, extobj, where=True)", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 239},
{"snippet": "numpy.hypot(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 240},
{"snippet": "numpy.hypot(x1, x2, /, signature, extobj, order='K')", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 241},
{"snippet": "numpy.hypot(x1, x2, /, signature, extobj, dtype=None)", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 242},
{"snippet": "numpy.hypot(x1, x2, /, signature, extobj, subok=True)", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 243},
{"snippet": "numpy.hypot(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 244},
{"snippet": "numpy.hypot(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 245},
{"snippet": "numpy.hypot(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 246},
{"snippet": "numpy.hypot(x1, x2, /, signature)", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`.", "question_id": 247},
{"snippet": "numpy.hypot(x1, x2, /, signature, out=None)", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `out`.", "question_id": 248},
{"snippet": "numpy.hypot(x1, x2, /, signature, where=True)", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `where`.", "question_id": 249},
{"snippet": "numpy.hypot(x1, x2, /, signature, casting='same_kind')", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `casting`.", "question_id": 250},
{"snippet": "numpy.hypot(x1, x2, /, signature, order='K')", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `order`.", "question_id": 251},
{"snippet": "numpy.hypot(x1, x2, /, signature, dtype=None)", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `dtype`.", "question_id": 252},
{"snippet": "numpy.hypot(x1, x2, /, signature, subok=True)", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `subok`.", "question_id": 253},
{"snippet": "numpy.hypot(x1, x2, /, signature, out=None, where=True)", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `out`, `where`.", "question_id": 254},
{"snippet": "numpy.hypot(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 255},
{"snippet": "numpy.hypot(x1, x2, /, signature, out=None, order='K')", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `out`, `order`.", "question_id": 256},
{"snippet": "polynomial.legendre.legval2d(x, y, c)", "intent": "Evaluate a 2-D Legendre series at points ( `x` , `y` ) . In either case , either x and y or their elements must support multiplication and addition both with themselves and with the elements of `c` .", "question_id": 257},
{"snippet": "generic.byteswap()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 258},
{"snippet": "ma.cov(x)", "intent": "Estimate the covariance matrix . If `x` and `y` have the same shape , a common mask is allocated : if x [ i , j ] is masked , then y [ i , j ] will also be masked .", "question_id": 259},
{"snippet": "ma.cov(x, y=None)", "intent": "Estimate the covariance matrix . If `x` and `y` have the same shape , a common mask is allocated : if x [ i , j ] is masked , then y [ i , j ] will also be masked .", "question_id": 260},
{"snippet": "ma.cov(x, rowvar=True)", "intent": "Estimate the covariance matrix . If `x` and `y` have the same shape , a common mask is allocated : if x [ i , j ] is masked , then y [ i , j ] will also be masked . With arguments `rowvar`.", "question_id": 261},
{"snippet": "ma.cov(x, bias=False)", "intent": "Estimate the covariance matrix . If `x` and `y` have the same shape , a common mask is allocated : if x [ i , j ] is masked , then y [ i , j ] will also be masked . With arguments `bias`.", "question_id": 262},
{"snippet": "ma.cov(x, allow_masked=True)", "intent": "Estimate the covariance matrix . If `x` and `y` have the same shape , a common mask is allocated : if x [ i , j ] is masked , then y [ i , j ] will also be masked . Setting `allow_masked` to False will raise an exception if values are missing in either of the input arrays .", "question_id": 263},
{"snippet": "ma.cov(x, ddof=None)", "intent": "Estimate the covariance matrix . If `x` and `y` have the same shape , a common mask is allocated : if x [ i , j ] is masked , then y [ i , j ] will also be masked . With arguments `ddof`.", "question_id": 264},
{"snippet": "ma.cov(x, y=None, rowvar=True)", "intent": "Estimate the covariance matrix . If `x` and `y` have the same shape , a common mask is allocated : if x [ i , j ] is masked , then y [ i , j ] will also be masked . With arguments `rowvar`.", "question_id": 265},
{"snippet": "ma.cov(x, y=None, bias=False)", "intent": "Estimate the covariance matrix . If `x` and `y` have the same shape , a common mask is allocated : if x [ i , j ] is masked , then y [ i , j ] will also be masked . With arguments `bias`.", "question_id": 266},
{"snippet": "ma.cov(x, y=None, allow_masked=True)", "intent": "Estimate the covariance matrix . If `x` and `y` have the same shape , a common mask is allocated : if x [ i , j ] is masked , then y [ i , j ] will also be masked . Setting `allow_masked` to False will raise an exception if values are missing in either of the input arrays .", "question_id": 267},
{"snippet": "ma.cov(x, y=None, ddof=None)", "intent": "Estimate the covariance matrix . If `x` and `y` have the same shape , a common mask is allocated : if x [ i , j ] is masked , then y [ i , j ] will also be masked . With arguments `ddof`.", "question_id": 268},
{"snippet": "random.randn(d0, d1, dn)", "intent": "Return a sample ( or samples ) from the \u201c standard normal \u201d distribution . If positive int_like arguments are provided , randn generates an array of shape ( `d0` , `d1` , ... , `dn` ) , filled with random floats sampled from a univariate \u201c normal \u201d ( Gaussian ) distribution of mean 0 and variance 1 .", "question_id": 269},
{"snippet": "ma.vstack(*args, **kwargs)", "intent": "Stack arrays in sequence vertically ( row wise ) . With arguments `*args`, `**kwargs`.", "question_id": 270},
{"snippet": "broadcast.nd", "intent": "Number of dimensions of broadcasted result.", "question_id": 271},
{"snippet": "ma.count(self)", "intent": "Count the non-masked elements of the array along the given `axis` . With arguments `self`.", "question_id": 272},
{"snippet": "ma.count(self, axis=None)", "intent": "Count the non-masked elements of the array along the given `axis` . With arguments `self`.", "question_id": 273},
{"snippet": "ma.count(self, keepdims=<no value>)", "intent": "Count the non-masked elements of the array along the given `axis` . With arguments `self`, `keepdims`.", "question_id": 274},
{"snippet": "ma.count(self, axis=None, keepdims=<no value>)", "intent": "Count the non-masked elements of the array along the given `axis` . With arguments `self`, `keepdims`.", "question_id": 275},
{"snippet": "chararray.argsort()", "intent": "Returns the indices that would sort this array .", "question_id": 276},
{"snippet": "chararray.argsort(axis=- 1)", "intent": "Returns the indices that would sort this array . With arguments `axis`.", "question_id": 277},
{"snippet": "chararray.argsort(kind=None)", "intent": "Returns the indices that would sort this array . With arguments `kind`.", "question_id": 278},
{"snippet": "chararray.argsort(order=None)", "intent": "Returns the indices that would sort this array . With arguments `order`.", "question_id": 279},
{"snippet": "chararray.argsort(axis=- 1, kind=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `kind`.", "question_id": 280},
{"snippet": "chararray.argsort(axis=- 1, order=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `order`.", "question_id": 281},
{"snippet": "chararray.argsort(kind=None, order=None)", "intent": "Returns the indices that would sort this array . With arguments `kind`, `order`.", "question_id": 282},
{"snippet": "chararray.argsort(axis=- 1, kind=None, order=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `kind`, `order`.", "question_id": 283},
{"snippet": "polynomial.hermite.Hermite.integ()", "intent": "Integrate .", "question_id": 284},
{"snippet": "polynomial.hermite.Hermite.integ(m=1)", "intent": "Integrate . With arguments `m`.", "question_id": 285},
{"snippet": "polynomial.hermite.Hermite.integ(k=)", "intent": "Integrate . With arguments `k`.", "question_id": 286},
{"snippet": "polynomial.hermite.Hermite.integ(lbnd=None)", "intent": "Integrate . With arguments `lbnd`.", "question_id": 287},
{"snippet": "polynomial.hermite.Hermite.integ(m=1, k=)", "intent": "Integrate . With arguments `m`, `k`.", "question_id": 288},
{"snippet": "polynomial.hermite.Hermite.integ(m=1, lbnd=None)", "intent": "Integrate . With arguments `m`, `lbnd`.", "question_id": 289},
{"snippet": "polynomial.hermite.Hermite.integ(k=, lbnd=None)", "intent": "Integrate . With arguments `k`, `lbnd`.", "question_id": 290},
{"snippet": "polynomial.hermite.Hermite.integ(m=1, k=, lbnd=None)", "intent": "Integrate . With arguments `m`, `k`, `lbnd`.", "question_id": 291},
{"snippet": "polynomial.hermite.Hermite.integ()", "intent": "Integrate .", "question_id": 292},
{"snippet": "polynomial.hermite.Hermite.integ(m=1)", "intent": "Integrate . With arguments `m`.", "question_id": 293},
{"snippet": "polynomial.hermite.Hermite.integ(k=)", "intent": "Integrate . With arguments `k`.", "question_id": 294},
{"snippet": "polynomial.hermite.Hermite.integ(lbnd=None)", "intent": "Integrate . With arguments `lbnd`.", "question_id": 295},
{"snippet": "polynomial.hermite.Hermite.integ(m=1, k=)", "intent": "Integrate . With arguments `m`, `k`.", "question_id": 296},
{"snippet": "polynomial.hermite.Hermite.integ(m=1, lbnd=None)", "intent": "Integrate . With arguments `m`, `lbnd`.", "question_id": 297},
{"snippet": "polynomial.hermite.Hermite.integ(k=, lbnd=None)", "intent": "Integrate . With arguments `k`, `lbnd`.", "question_id": 298},
{"snippet": "polynomial.hermite.Hermite.integ(m=1, k=, lbnd=None)", "intent": "Integrate . With arguments `m`, `k`, `lbnd`.", "question_id": 299},
{"snippet": "chararray.flat", "intent": "A 1-D iterator over the array.", "question_id": 300},
{"snippet": "char.chararray.any()", "intent": "Returns True if any of the elements of a evaluate to True .", "question_id": 301},
{"snippet": "char.chararray.any(axis=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`.", "question_id": 302},
{"snippet": "char.chararray.any(out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`.", "question_id": 303},
{"snippet": "char.chararray.any(keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `keepdims`.", "question_id": 304},
{"snippet": "char.chararray.any(where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `where`.", "question_id": 305},
{"snippet": "char.chararray.any(axis=None, out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `out`.", "question_id": 306},
{"snippet": "char.chararray.any(axis=None, keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `keepdims`.", "question_id": 307},
{"snippet": "char.chararray.any(axis=None, where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `where`.", "question_id": 308},
{"snippet": "char.chararray.any(out=None, keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`, `keepdims`.", "question_id": 309},
{"snippet": "char.chararray.any(out=None, where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`, `where`.", "question_id": 310},
{"snippet": "ma.MaskedArray.compress(condition)", "intent": "Return a where `condition` is True .", "question_id": 311},
{"snippet": "ma.MaskedArray.compress(condition, axis=None)", "intent": "Return a where `condition` is True . With arguments `axis`.", "question_id": 312},
{"snippet": "ma.MaskedArray.compress(condition, out=None)", "intent": "Return a where `condition` is True . With arguments `out`.", "question_id": 313},
{"snippet": "ma.MaskedArray.compress(condition, axis=None, out=None)", "intent": "Return a where `condition` is True . With arguments `axis`, `out`.", "question_id": 314},
{"snippet": "record.nbytes", "intent": "The length of the scalar in bytes.", "question_id": 315},
{"snippet": "matrix.compress(condition)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`.", "question_id": 316},
{"snippet": "matrix.compress(condition, axis=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`.", "question_id": 317},
{"snippet": "matrix.compress(condition, out=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`, `out`.", "question_id": 318},
{"snippet": "matrix.compress(condition, axis=None, out=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`, `out`.", "question_id": 319},
{"snippet": "ma.mean(self)", "intent": "Returns the average of the array elements along given `axis` . With arguments `self`.", "question_id": 320},
{"snippet": "ma.mean(self, axis=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `self`.", "question_id": 321},
{"snippet": "ma.mean(self, dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `self`, `dtype`.", "question_id": 322},
{"snippet": "ma.mean(self, out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `self`, `out`.", "question_id": 323},
{"snippet": "ma.mean(self, keepdims=<no value>)", "intent": "Returns the average of the array elements along given `axis` . With arguments `self`, `keepdims`.", "question_id": 324},
{"snippet": "ma.mean(self, axis=None, dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `self`, `dtype`.", "question_id": 325},
{"snippet": "ma.mean(self, axis=None, out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `self`, `out`.", "question_id": 326},
{"snippet": "ma.mean(self, axis=None, keepdims=<no value>)", "intent": "Returns the average of the array elements along given `axis` . With arguments `self`, `keepdims`.", "question_id": 327},
{"snippet": "ma.mean(self, dtype=None, out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `self`, `dtype`, `out`.", "question_id": 328},
{"snippet": "ma.mean(self, dtype=None, keepdims=<no value>)", "intent": "Returns the average of the array elements along given `axis` . With arguments `self`, `dtype`, `keepdims`.", "question_id": 329},
{"snippet": "recarray.ctypes", "intent": "An object to simplify the interaction of the array with the ctypes module.", "question_id": 330},
{"snippet": "_ctypes.data", "intent": "A pointer to the memory area of the array as a Python integer.", "question_id": 331},
{"snippet": "_ctypes.shape", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the C-integer corresponding to dtype('p') on this platform.", "question_id": 332},
{"snippet": "_ctypes.strides", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the same as for the shape attribute.", "question_id": 333},
{"snippet": "_ctypes.data_as(obj)", "intent": "Return the data pointer cast to a particular c-types object . With arguments `obj`.", "question_id": 334},
{"snippet": "_ctypes.shape_as(obj)", "intent": "Return the shape tuple as an array of some other c-types type . With arguments `obj`.", "question_id": 335},
{"snippet": "_ctypes.strides_as(obj)", "intent": "Return the strides tuple as an array of some other c-types type . With arguments `obj`.", "question_id": 336},
{"snippet": "numpy.polynomial.hermite_e.HermiteE(coef)", "intent": "An HermiteE series class . With arguments `coef`.", "question_id": 337},
{"snippet": "numpy.polynomial.hermite_e.HermiteE(coef, domain=None)", "intent": "An HermiteE series class . With arguments `coef`, `domain`.", "question_id": 338},
{"snippet": "numpy.polynomial.hermite_e.HermiteE(coef, window=None)", "intent": "An HermiteE series class . With arguments `coef`, `window`.", "question_id": 339},
{"snippet": "numpy.polynomial.hermite_e.HermiteE(coef, domain=None, window=None)", "intent": "An HermiteE series class . With arguments `coef`, `domain`, `window`.", "question_id": 340},
{"snippet": "random.Generator.multivariate_hypergeometric(colors, nsample)", "intent": "Generate variates from a multivariate hypergeometric distribution . N is the length of `colors` , and the values in colors are the number of occurrences of that type in the collection . Choose `nsample` items at random without replacement from a collection with N distinct types .", "question_id": 341},
{"snippet": "random.Generator.multivariate_hypergeometric(colors, nsample, size=None)", "intent": "Generate variates from a multivariate hypergeometric distribution . N is the length of `colors` , and the values in colors are the number of occurrences of that type in the collection . Choose `nsample` items at random without replacement from a collection with N distinct types . With arguments `size`.", "question_id": 342},
{"snippet": "random.Generator.multivariate_hypergeometric(colors, nsample, method='marginals')", "intent": "Generate variates from a multivariate hypergeometric distribution . N is the length of `colors` , and the values in colors are the number of occurrences of that type in the collection . Choose `nsample` items at random without replacement from a collection with N distinct types . The default `method` is \u201c marginals \u201d .", "question_id": 343},
{"snippet": "random.Generator.multivariate_hypergeometric(colors, nsample, size=None, method='marginals')", "intent": "Generate variates from a multivariate hypergeometric distribution . N is the length of `colors` , and the values in colors are the number of occurrences of that type in the collection . Choose `nsample` items at random without replacement from a collection with N distinct types . The default `method` is \u201c marginals \u201d . With arguments `size`.", "question_id": 344},
{"snippet": "memmap.any()", "intent": "Returns True if any of the elements of a evaluate to True .", "question_id": 345},
{"snippet": "memmap.any(axis=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`.", "question_id": 346},
{"snippet": "memmap.any(out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`.", "question_id": 347},
{"snippet": "memmap.any(keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `keepdims`.", "question_id": 348},
{"snippet": "memmap.any(where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `where`.", "question_id": 349},
{"snippet": "memmap.any(axis=None, out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `out`.", "question_id": 350},
{"snippet": "memmap.any(axis=None, keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `keepdims`.", "question_id": 351},
{"snippet": "memmap.any(axis=None, where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `where`.", "question_id": 352},
{"snippet": "memmap.any(out=None, keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`, `keepdims`.", "question_id": 353},
{"snippet": "memmap.any(out=None, where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`, `where`.", "question_id": 354},
{"snippet": "record.squeeze()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 355},
{"snippet": "ma.masked_array.soften_mask()", "intent": "Force the mask to soft .", "question_id": 356},
{"snippet": "record.tofile()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 357},
{"snippet": "ma.MaskType.repeat()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 358},
{"snippet": "random.triangular(left, mode, right)", "intent": "Draw samples from the triangular distribution over the interval [ `left` , `right` ] . The triangular distribution is a continuous probability distribution with lower limit left , peak at `mode` , and upper limit right .", "question_id": 359},
{"snippet": "random.triangular(left, mode, right, size=None)", "intent": "Draw samples from the triangular distribution over the interval [ `left` , `right` ] . The triangular distribution is a continuous probability distribution with lower limit left , peak at `mode` , and upper limit right . With arguments `size`.", "question_id": 360},
{"snippet": "polynomial.hermite_e.hermegauss(deg)", "intent": "Gauss-HermiteE quadrature . These sample points and weights will correctly integrate polynomials of degree \\ ( 2 * `deg` - 1\\ ) or less over the interval \\ ( [ -\\inf , \\inf ] \\ ) with the weight function \\ ( f ( x ) = \\exp ( -x^2/2 ) \\ ) .", "question_id": 361},
{"snippet": "ma.MaskedArray.__setstate__(state)", "intent": "Restore the internal `state` of the masked array , for pickling purposes .", "question_id": 362},
{"snippet": "polynomial.laguerre.Laguerre.has_sametype(other)", "intent": "Check if types match . With arguments `other`.", "question_id": 363},
{"snippet": "numpy.amin(a)", "intent": "Return the minimum of an array or minimum along an `axis` . Don \u2019 t use amin for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , minimum ( `a` [ 0 ] , a [ 1 ] ) is faster than amin ( a , axis=0 ) .", "question_id": 364},
{"snippet": "numpy.amin(a, axis=None)", "intent": "Return the minimum of an array or minimum along an `axis` . Don \u2019 t use amin for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , minimum ( `a` [ 0 ] , a [ 1 ] ) is faster than amin ( a , axis=0 ) .", "question_id": 365},
{"snippet": "numpy.amin(a, out=None)", "intent": "Return the minimum of an array or minimum along an `axis` . Don \u2019 t use amin for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , minimum ( `a` [ 0 ] , a [ 1 ] ) is faster than amin ( a , axis=0 ) . With arguments `out`.", "question_id": 366},
{"snippet": "numpy.amin(a, keepdims=<no value>)", "intent": "Return the minimum of an array or minimum along an `axis` . Don \u2019 t use amin for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , minimum ( `a` [ 0 ] , a [ 1 ] ) is faster than amin ( a , axis=0 ) . With arguments `keepdims`.", "question_id": 367},
{"snippet": "numpy.amin(a, initial=<no value>)", "intent": "Return the minimum of an array or minimum along an `axis` . Don \u2019 t use amin for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , minimum ( `a` [ 0 ] , a [ 1 ] ) is faster than amin ( a , axis=0 ) . Notice that the `initial` value is used as one of the elements for which the minimum is determined , unlike for the default argument Python \u2019 s max function , which is only used for empty iterables .", "question_id": 368},
{"snippet": "numpy.amin(a, where=<no value>)", "intent": "Return the minimum of an array or minimum along an `axis` . Don \u2019 t use amin for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , minimum ( `a` [ 0 ] , a [ 1 ] ) is faster than amin ( a , axis=0 ) . With arguments `where`.", "question_id": 369},
{"snippet": "numpy.amin(a, axis=None, out=None)", "intent": "Return the minimum of an array or minimum along an `axis` . Don \u2019 t use amin for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , minimum ( `a` [ 0 ] , a [ 1 ] ) is faster than amin ( a , axis=0 ) . With arguments `out`.", "question_id": 370},
{"snippet": "numpy.amin(a, axis=None, keepdims=<no value>)", "intent": "Return the minimum of an array or minimum along an `axis` . Don \u2019 t use amin for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , minimum ( `a` [ 0 ] , a [ 1 ] ) is faster than amin ( a , axis=0 ) . With arguments `keepdims`.", "question_id": 371},
{"snippet": "numpy.amin(a, axis=None, initial=<no value>)", "intent": "Return the minimum of an array or minimum along an `axis` . Don \u2019 t use amin for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , minimum ( `a` [ 0 ] , a [ 1 ] ) is faster than amin ( a , axis=0 ) . Notice that the `initial` value is used as one of the elements for which the minimum is determined , unlike for the default argument Python \u2019 s max function , which is only used for empty iterables .", "question_id": 372},
{"snippet": "numpy.amin(a, axis=None, where=<no value>)", "intent": "Return the minimum of an array or minimum along an `axis` . Don \u2019 t use amin for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , minimum ( `a` [ 0 ] , a [ 1 ] ) is faster than amin ( a , axis=0 ) . With arguments `where`.", "question_id": 373},
{"snippet": "random.Generator.dirichlet(alpha)", "intent": "Draw samples from the Dirichlet distribution . With arguments `alpha`.", "question_id": 374},
{"snippet": "random.Generator.dirichlet(alpha, size=None)", "intent": "Draw samples from the Dirichlet distribution . Draw `size` samples of dimension k from a Dirichlet distribution . With arguments `alpha`.", "question_id": 375},
{"snippet": "polynomial.polynomial.polygrid2d(x, y, c)", "intent": "Evaluate a 2-D polynomial on the Cartesian product of `x` and `y` . In either case , either x and y or their elements must support multiplication and addition both with themselves and with the elements of `c` .", "question_id": 376},
{"snippet": "polynomial.hermite_e.hermemul(c1, c2)", "intent": "Multiply one Hermite series by another . Returns the product of two Hermite series `c1` * `c2` .", "question_id": 377},
{"snippet": "chararray.newbyteorder(/)", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`.", "question_id": 378},
{"snippet": "chararray.newbyteorder(/, new_order='S')", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`, `new_order`.", "question_id": 379},
{"snippet": "polynomial.polynomial.Polynomial.has_samecoef(other)", "intent": "Check if coefficients match . With arguments `other`.", "question_id": 380},
{"snippet": "numpy.mgrid", "intent": "nd_grid instance which returns a dense multi-dimensional \u201cmeshgrid\u201d.", "question_id": 381},
{"snippet": "polynomial.polynomial.Polynomial.identity()", "intent": "Identity function .", "question_id": 382},
{"snippet": "polynomial.polynomial.Polynomial.identity(domain=None)", "intent": "Identity function . With arguments `domain`.", "question_id": 383},
{"snippet": "polynomial.polynomial.Polynomial.identity(window=None)", "intent": "Identity function . With arguments `window`.", "question_id": 384},
{"snippet": "polynomial.polynomial.Polynomial.identity(domain=None, window=None)", "intent": "Identity function . With arguments `domain`, `window`.", "question_id": 385},
{"snippet": "random.randint(low)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) .", "question_id": 386},
{"snippet": "random.randint(low, high=None)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) .", "question_id": 387},
{"snippet": "random.randint(low, size=None)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . With arguments `size`.", "question_id": 388},
{"snippet": "random.randint(low, dtype=int)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . Return random integers from the \u201c discrete uniform \u201d distribution of the specified `dtype` in the \u201c half-open \u201d interval [ low , high ) .", "question_id": 389},
{"snippet": "random.randint(low, high=None, size=None)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . With arguments `size`.", "question_id": 390},
{"snippet": "random.randint(low, high=None, dtype=int)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . Return random integers from the \u201c discrete uniform \u201d distribution of the specified `dtype` in the \u201c half-open \u201d interval [ low , high ) .", "question_id": 391},
{"snippet": "random.randint(low, size=None, dtype=int)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . Return random integers from the \u201c discrete uniform \u201d distribution of the specified `dtype` in the \u201c half-open \u201d interval [ low , high ) . With arguments `size`.", "question_id": 392},
{"snippet": "random.randint(low, high=None, size=None, dtype=int)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . Return random integers from the \u201c discrete uniform \u201d distribution of the specified `dtype` in the \u201c half-open \u201d interval [ low , high ) . With arguments `size`.", "question_id": 393},
{"snippet": "flatiter.index", "intent": "Current flat index into the array.", "question_id": 394},
{"snippet": "ma.MaskedArray.astype(dtype)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`.", "question_id": 395},
{"snippet": "ma.MaskedArray.astype(dtype, order='K')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`.", "question_id": 396},
{"snippet": "ma.MaskedArray.astype(dtype, casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`.", "question_id": 397},
{"snippet": "ma.MaskedArray.astype(dtype, subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `subok`.", "question_id": 398},
{"snippet": "ma.MaskedArray.astype(dtype, copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `copy`.", "question_id": 399},
{"snippet": "ma.MaskedArray.astype(dtype, order='K', casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `casting`.", "question_id": 400},
{"snippet": "ma.MaskedArray.astype(dtype, order='K', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `subok`.", "question_id": 401},
{"snippet": "ma.MaskedArray.astype(dtype, order='K', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `copy`.", "question_id": 402},
{"snippet": "ma.MaskedArray.astype(dtype, casting='unsafe', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `subok`.", "question_id": 403},
{"snippet": "ma.MaskedArray.astype(dtype, casting='unsafe', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `copy`.", "question_id": 404},
{"snippet": "numpy.allclose(a, b)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b .", "question_id": 405},
{"snippet": "numpy.allclose(a, b, rtol=1e-05)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b .", "question_id": 406},
{"snippet": "numpy.allclose(a, b, atol=1e-08)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b .", "question_id": 407},
{"snippet": "numpy.allclose(a, b, equal_nan=False)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b . With arguments `equal_nan`.", "question_id": 408},
{"snippet": "numpy.allclose(a, b, rtol=1e-05, atol=1e-08)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b .", "question_id": 409},
{"snippet": "numpy.allclose(a, b, rtol=1e-05, equal_nan=False)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b . With arguments `equal_nan`.", "question_id": 410},
{"snippet": "numpy.allclose(a, b, atol=1e-08, equal_nan=False)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b . With arguments `equal_nan`.", "question_id": 411},
{"snippet": "numpy.allclose(a, b, rtol=1e-05, atol=1e-08, equal_nan=False)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b . With arguments `equal_nan`.", "question_id": 412},
{"snippet": "numpy.savez(file, *args, **kwds)", "intent": "Save several arrays into a single `file` in uncompressed .npz format . With arguments `*args`, `**kwds`.", "question_id": 413},
{"snippet": "random.Generator.exponential()", "intent": "Draw samples from an exponential distribution .", "question_id": 414},
{"snippet": "random.Generator.exponential(scale=1.0)", "intent": "Draw samples from an exponential distribution . \\ ( \\beta\\ ) is the `scale` parameter , which is the inverse of the rate parameter \\ ( \\lambda = 1/\\beta\\ ) .", "question_id": 415},
{"snippet": "random.Generator.exponential(size=None)", "intent": "Draw samples from an exponential distribution . It describes many common situations , such as the `size` of raindrops measured over many rainstorms [ 1 ] , or the time between page requests to Wikipedia [ 2 ] .", "question_id": 416},
{"snippet": "random.Generator.exponential(scale=1.0, size=None)", "intent": "Draw samples from an exponential distribution . \\ ( \\beta\\ ) is the `scale` parameter , which is the inverse of the rate parameter \\ ( \\lambda = 1/\\beta\\ ) . It describes many common situations , such as the `size` of raindrops measured over many rainstorms [ 1 ] , or the time between page requests to Wikipedia [ 2 ] .", "question_id": 417},
{"snippet": "ndarray.__getitem__(key, /)", "intent": "Return self [ `key` ] . With arguments `/`.", "question_id": 418},
{"snippet": "polynomial.chebyshev.Chebyshev.cast(series)", "intent": "Convert `series` to series of this class .", "question_id": 419},
{"snippet": "polynomial.chebyshev.Chebyshev.cast(series, domain=None)", "intent": "Convert `series` to series of this class . With arguments `domain`.", "question_id": 420},
{"snippet": "polynomial.chebyshev.Chebyshev.cast(series, window=None)", "intent": "Convert `series` to series of this class . With arguments `window`.", "question_id": 421},
{"snippet": "polynomial.chebyshev.Chebyshev.cast(series, domain=None, window=None)", "intent": "Convert `series` to series of this class . With arguments `domain`, `window`.", "question_id": 422},
{"snippet": "polynomial.legendre.legvander(x, deg)", "intent": "Pseudo-Vandermonde matrix of given degree . Returns the pseudo-Vandermonde matrix of degree `deg` and sample points `x` .", "question_id": 423},
{"snippet": "ndarray.flags", "intent": "Information about the memory layout of the array.", "question_id": 424},
{"snippet": "memmap.dtype", "intent": "Data-type of the array\u2019s elements.", "question_id": 425},
{"snippet": "random.RandomState.pareto(a)", "intent": "Draw samples from `a` Pareto II or Lomax distribution with specified shape .", "question_id": 426},
{"snippet": "random.RandomState.pareto(a, size=None)", "intent": "Draw samples from `a` Pareto II or Lomax distribution with specified shape . With arguments `size`.", "question_id": 427},
{"snippet": "numpy.equal(x1, x2, /, signature, extobj)", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `extobj`.", "question_id": 428},
{"snippet": "numpy.equal(x1, x2, /, signature, extobj, out=None)", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 429},
{"snippet": "numpy.equal(x1, x2, /, signature, extobj, where=True)", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 430},
{"snippet": "numpy.equal(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 431},
{"snippet": "numpy.equal(x1, x2, /, signature, extobj, order='K')", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 432},
{"snippet": "numpy.equal(x1, x2, /, signature, extobj, dtype=None)", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 433},
{"snippet": "numpy.equal(x1, x2, /, signature, extobj, subok=True)", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 434},
{"snippet": "numpy.equal(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 435},
{"snippet": "numpy.equal(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 436},
{"snippet": "numpy.equal(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 437},
{"snippet": "numpy.equal(x1, x2, /, signature)", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`.", "question_id": 438},
{"snippet": "numpy.equal(x1, x2, /, signature, out=None)", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `out`.", "question_id": 439},
{"snippet": "numpy.equal(x1, x2, /, signature, where=True)", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `where`.", "question_id": 440},
{"snippet": "numpy.equal(x1, x2, /, signature, casting='same_kind')", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `casting`.", "question_id": 441},
{"snippet": "numpy.equal(x1, x2, /, signature, order='K')", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `order`.", "question_id": 442},
{"snippet": "numpy.equal(x1, x2, /, signature, dtype=None)", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `dtype`.", "question_id": 443},
{"snippet": "numpy.equal(x1, x2, /, signature, subok=True)", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `subok`.", "question_id": 444},
{"snippet": "numpy.equal(x1, x2, /, signature, out=None, where=True)", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `out`, `where`.", "question_id": 445},
{"snippet": "numpy.equal(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 446},
{"snippet": "numpy.equal(x1, x2, /, signature, out=None, order='K')", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `out`, `order`.", "question_id": 447},
{"snippet": "ma.masked_array.itemsize", "intent": "Length of one array element in bytes.", "question_id": 448},
{"snippet": "fft.irfftn(a)", "intent": "Computes the inverse of rfftn . In other words , irfftn ( rfftn ( `a` ) , a.shape ) == a to within numerical accuracy .", "question_id": 449},
{"snippet": "fft.irfftn(a, s=None)", "intent": "Computes the inverse of rfftn . In other words , irfftn ( rfftn ( `a` ) , a.shape ) == a to within numerical accuracy . With arguments `s`.", "question_id": 450},
{"snippet": "fft.irfftn(a, axes=None)", "intent": "Computes the inverse of rfftn . In other words , irfftn ( rfftn ( `a` ) , a.shape ) == a to within numerical accuracy . This function computes the inverse of the N-dimensional discrete Fourier Transform for real input over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) .", "question_id": 451},
{"snippet": "fft.irfftn(a, norm=None)", "intent": "Computes the inverse of rfftn . In other words , irfftn ( rfftn ( `a` ) , a.shape ) == a to within numerical accuracy . With arguments `norm`.", "question_id": 452},
{"snippet": "fft.irfftn(a, s=None, axes=None)", "intent": "Computes the inverse of rfftn . In other words , irfftn ( rfftn ( `a` ) , a.shape ) == a to within numerical accuracy . This function computes the inverse of the N-dimensional discrete Fourier Transform for real input over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `s`.", "question_id": 453},
{"snippet": "fft.irfftn(a, s=None, norm=None)", "intent": "Computes the inverse of rfftn . In other words , irfftn ( rfftn ( `a` ) , a.shape ) == a to within numerical accuracy . With arguments `s`, `norm`.", "question_id": 454},
{"snippet": "fft.irfftn(a, axes=None, norm=None)", "intent": "Computes the inverse of rfftn . In other words , irfftn ( rfftn ( `a` ) , a.shape ) == a to within numerical accuracy . This function computes the inverse of the N-dimensional discrete Fourier Transform for real input over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `norm`.", "question_id": 455},
{"snippet": "fft.irfftn(a, s=None, axes=None, norm=None)", "intent": "Computes the inverse of rfftn . In other words , irfftn ( rfftn ( `a` ) , a.shape ) == a to within numerical accuracy . This function computes the inverse of the N-dimensional discrete Fourier Transform for real input over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `s`, `norm`.", "question_id": 456},
{"snippet": "numpy.median(a)", "intent": "Compute the median along the specified `axis` . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i e. , V_sorted [ ( N-1 ) /2 ] , when N is odd , and the average of the two middle values of V_sorted when N is even .", "question_id": 457},
{"snippet": "numpy.median(a, axis=None)", "intent": "Compute the median along the specified `axis` . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i e. , V_sorted [ ( N-1 ) /2 ] , when N is odd , and the average of the two middle values of V_sorted when N is even .", "question_id": 458},
{"snippet": "numpy.median(a, out=None)", "intent": "Compute the median along the specified `axis` . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i e. , V_sorted [ ( N-1 ) /2 ] , when N is odd , and the average of the two middle values of V_sorted when N is even . With arguments `out`.", "question_id": 459},
{"snippet": "numpy.median(a, overwrite_input=False)", "intent": "Compute the median along the specified `axis` . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i e. , V_sorted [ ( N-1 ) /2 ] , when N is odd , and the average of the two middle values of V_sorted when N is even . With arguments `overwrite_input`.", "question_id": 460},
{"snippet": "numpy.median(a, keepdims=False)", "intent": "Compute the median along the specified `axis` . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i e. , V_sorted [ ( N-1 ) /2 ] , when N is odd , and the average of the two middle values of V_sorted when N is even . With arguments `keepdims`.", "question_id": 461},
{"snippet": "numpy.median(a, axis=None, out=None)", "intent": "Compute the median along the specified `axis` . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i e. , V_sorted [ ( N-1 ) /2 ] , when N is odd , and the average of the two middle values of V_sorted when N is even . With arguments `out`.", "question_id": 462},
{"snippet": "numpy.median(a, axis=None, overwrite_input=False)", "intent": "Compute the median along the specified `axis` . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i e. , V_sorted [ ( N-1 ) /2 ] , when N is odd , and the average of the two middle values of V_sorted when N is even . With arguments `overwrite_input`.", "question_id": 463},
{"snippet": "numpy.median(a, axis=None, keepdims=False)", "intent": "Compute the median along the specified `axis` . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i e. , V_sorted [ ( N-1 ) /2 ] , when N is odd , and the average of the two middle values of V_sorted when N is even . With arguments `keepdims`.", "question_id": 464},
{"snippet": "numpy.median(a, out=None, overwrite_input=False)", "intent": "Compute the median along the specified `axis` . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i e. , V_sorted [ ( N-1 ) /2 ] , when N is odd , and the average of the two middle values of V_sorted when N is even . With arguments `out`, `overwrite_input`.", "question_id": 465},
{"snippet": "numpy.median(a, out=None, keepdims=False)", "intent": "Compute the median along the specified `axis` . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i e. , V_sorted [ ( N-1 ) /2 ] , when N is odd , and the average of the two middle values of V_sorted when N is even . With arguments `out`, `keepdims`.", "question_id": 466},
{"snippet": "random.poisson()", "intent": "Draw samples from a Poisson distribution .", "question_id": 467},
{"snippet": "random.poisson(lam=1.0)", "intent": "Draw samples from a Poisson distribution . Because the output is limited to the range of the C int64 type , a ValueError is raised when `lam` is within 10 sigma of the maximum representable value .", "question_id": 468},
{"snippet": "random.poisson(size=None)", "intent": "Draw samples from a Poisson distribution . With arguments `size`.", "question_id": 469},
{"snippet": "random.poisson(lam=1.0, size=None)", "intent": "Draw samples from a Poisson distribution . Because the output is limited to the range of the C int64 type , a ValueError is raised when `lam` is within 10 sigma of the maximum representable value . With arguments `size`.", "question_id": 470},
{"snippet": "polynomial.chebyshev.chebgrid2d(x, y, c)", "intent": "Evaluate a 2-D Chebyshev series on the Cartesian product of `x` and `y` . In either case , either x and y or their elements must support multiplication and addition both with themselves and with the elements of `c` .", "question_id": 471},
{"snippet": "numpy.piecewise(x, condlist, funclist, *args, **kw)", "intent": "Evaluate a piecewise-defined function . This is similar to choose or select , except that functions are evaluated on elements of `x` that satisfy the corresponding condition from `condlist` . With arguments `funclist`, `*args`, `**kw`.", "question_id": 472},
{"snippet": "ma.masked_array.ravel()", "intent": "Returns a 1D version of self , as a view .", "question_id": 473},
{"snippet": "ma.masked_array.ravel(order='C')", "intent": "Returns a 1D version of self , as a view . With arguments `order`.", "question_id": 474},
{"snippet": "numpy.fix(x)", "intent": "Round to nearest integer towards zero . With arguments `x`.", "question_id": 475},
{"snippet": "numpy.fix(x, out=None)", "intent": "Round to nearest integer towards zero . With arguments `x`, `out`.", "question_id": 476},
{"snippet": "numpy.logical_and(x1, x2, /, signature, extobj)", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `extobj`.", "question_id": 477},
{"snippet": "numpy.logical_and(x1, x2, /, signature, extobj, out=None)", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 478},
{"snippet": "numpy.logical_and(x1, x2, /, signature, extobj, where=True)", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 479},
{"snippet": "numpy.logical_and(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 480},
{"snippet": "numpy.logical_and(x1, x2, /, signature, extobj, order='K')", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 481},
{"snippet": "numpy.logical_and(x1, x2, /, signature, extobj, dtype=None)", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 482},
{"snippet": "numpy.logical_and(x1, x2, /, signature, extobj, subok=True)", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 483},
{"snippet": "numpy.logical_and(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 484},
{"snippet": "numpy.logical_and(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 485},
{"snippet": "numpy.logical_and(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 486},
{"snippet": "numpy.logical_and(x1, x2, /, signature)", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`.", "question_id": 487},
{"snippet": "numpy.logical_and(x1, x2, /, signature, out=None)", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `out`.", "question_id": 488},
{"snippet": "numpy.logical_and(x1, x2, /, signature, where=True)", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `where`.", "question_id": 489},
{"snippet": "numpy.logical_and(x1, x2, /, signature, casting='same_kind')", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `casting`.", "question_id": 490},
{"snippet": "numpy.logical_and(x1, x2, /, signature, order='K')", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `order`.", "question_id": 491},
{"snippet": "numpy.logical_and(x1, x2, /, signature, dtype=None)", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `dtype`.", "question_id": 492},
{"snippet": "numpy.logical_and(x1, x2, /, signature, subok=True)", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `subok`.", "question_id": 493},
{"snippet": "numpy.logical_and(x1, x2, /, signature, out=None, where=True)", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `out`, `where`.", "question_id": 494},
{"snippet": "numpy.logical_and(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 495},
{"snippet": "numpy.logical_and(x1, x2, /, signature, out=None, order='K')", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `out`, `order`.", "question_id": 496},
{"snippet": "ma.conjugate(x, /, signature, extobj)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`.", "question_id": 497},
{"snippet": "ma.conjugate(x, /, signature, extobj, out=None)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`.", "question_id": 498},
{"snippet": "ma.conjugate(x, /, signature, extobj, where=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `where`.", "question_id": 499},
{"snippet": "ma.conjugate(x, /, signature, extobj, casting='same_kind')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `casting`.", "question_id": 500},
{"snippet": "ma.conjugate(x, /, signature, extobj, order='K')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `order`.", "question_id": 501},
{"snippet": "ma.conjugate(x, /, signature, extobj, dtype=None)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `dtype`.", "question_id": 502},
{"snippet": "ma.conjugate(x, /, signature, extobj, subok=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `subok`.", "question_id": 503},
{"snippet": "ma.conjugate(x, /, signature, extobj, out=None, where=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 504},
{"snippet": "ma.conjugate(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 505},
{"snippet": "ma.conjugate(x, /, signature, extobj, out=None, order='K')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 506},
{"snippet": "ma.conjugate(x, /, signature)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`.", "question_id": 507},
{"snippet": "ma.conjugate(x, /, signature, out=None)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `out`.", "question_id": 508},
{"snippet": "ma.conjugate(x, /, signature, where=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `where`.", "question_id": 509},
{"snippet": "ma.conjugate(x, /, signature, casting='same_kind')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `casting`.", "question_id": 510},
{"snippet": "ma.conjugate(x, /, signature, order='K')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `order`.", "question_id": 511},
{"snippet": "ma.conjugate(x, /, signature, dtype=None)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `dtype`.", "question_id": 512},
{"snippet": "ma.conjugate(x, /, signature, subok=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `subok`.", "question_id": 513},
{"snippet": "ma.conjugate(x, /, signature, out=None, where=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `out`, `where`.", "question_id": 514},
{"snippet": "ma.conjugate(x, /, signature, out=None, casting='same_kind')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `out`, `casting`.", "question_id": 515},
{"snippet": "ma.conjugate(x, /, signature, out=None, order='K')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `out`, `order`.", "question_id": 516},
{"snippet": "testing.assert_raises(exception_class, callable, *args, **kwargs) assert_raises(exception_class)", "intent": "Fail unless an exception of class `exception_class` is thrown by `callable` when invoked with arguments args and keyword arguments kwargs . With arguments `*args`, `**kwargs) assert_raises(exception_class`.", "question_id": 517},
{"snippet": "testing.assert_raises(exception_class)", "intent": "Fail unless an exception of class `exception_class` is thrown by callable when invoked with arguments args and keyword arguments kwargs .", "question_id": 518},
{"snippet": "numpy.isneginf(x)", "intent": "Test element-wise for negative infinity , return result as bool array . Errors result if the second argument is also supplied when `x` is a scalar input , if first and second arguments have different shapes , or if the first argument has complex values .", "question_id": 519},
{"snippet": "numpy.isneginf(x, out=None)", "intent": "Test element-wise for negative infinity , return result as bool array . Errors result if the second argument is also supplied when `x` is a scalar input , if first and second arguments have different shapes , or if the first argument has complex values . With arguments `out`.", "question_id": 520},
{"snippet": "numpy.distutils.ccompiler_opt.CCompilerOpt(ccompiler)", "intent": "A helper class for CCompiler aims to provide extra build options to effectively control of compiler optimizations that are directly related to CPU features . With arguments `ccompiler`.", "question_id": 521},
{"snippet": "numpy.distutils.ccompiler_opt.CCompilerOpt(ccompiler, cpu_baseline='min')", "intent": "A helper class for CCompiler aims to provide extra build options to effectively control of compiler optimizations that are directly related to CPU features . With arguments `ccompiler`, `cpu_baseline`.", "question_id": 522},
{"snippet": "numpy.distutils.ccompiler_opt.CCompilerOpt(ccompiler, cpu_dispatch='max')", "intent": "A helper class for CCompiler aims to provide extra build options to effectively control of compiler optimizations that are directly related to CPU features . With arguments `ccompiler`, `cpu_dispatch`.", "question_id": 523},
{"snippet": "numpy.distutils.ccompiler_opt.CCompilerOpt(ccompiler, cache_path=None)", "intent": "A helper class for CCompiler aims to provide extra build options to effectively control of compiler optimizations that are directly related to CPU features . With arguments `ccompiler`, `cache_path`.", "question_id": 524},
{"snippet": "numpy.distutils.ccompiler_opt.CCompilerOpt(ccompiler, cpu_baseline='min', cpu_dispatch='max')", "intent": "A helper class for CCompiler aims to provide extra build options to effectively control of compiler optimizations that are directly related to CPU features . With arguments `ccompiler`, `cpu_baseline`, `cpu_dispatch`.", "question_id": 525},
{"snippet": "numpy.distutils.ccompiler_opt.CCompilerOpt(ccompiler, cpu_baseline='min', cache_path=None)", "intent": "A helper class for CCompiler aims to provide extra build options to effectively control of compiler optimizations that are directly related to CPU features . With arguments `ccompiler`, `cpu_baseline`, `cache_path`.", "question_id": 526},
{"snippet": "numpy.distutils.ccompiler_opt.CCompilerOpt(ccompiler, cpu_dispatch='max', cache_path=None)", "intent": "A helper class for CCompiler aims to provide extra build options to effectively control of compiler optimizations that are directly related to CPU features . With arguments `ccompiler`, `cpu_dispatch`, `cache_path`.", "question_id": 527},
{"snippet": "numpy.distutils.ccompiler_opt.CCompilerOpt(ccompiler, cpu_baseline='min', cpu_dispatch='max', cache_path=None)", "intent": "A helper class for CCompiler aims to provide extra build options to effectively control of compiler optimizations that are directly related to CPU features . With arguments `ccompiler`, `cpu_baseline`, `cpu_dispatch`, `cache_path`.", "question_id": 528},
{"snippet": "ma.masked_values(x, value)", "intent": "Mask using floating point equality . Return a MaskedArray , masked where the data in array `x` are approximately equal to `value` , determined using isclose .", "question_id": 529},
{"snippet": "ma.masked_values(x, value, rtol=1e-05)", "intent": "Mask using floating point equality . Return a MaskedArray , masked where the data in array `x` are approximately equal to `value` , determined using isclose . With arguments `rtol`.", "question_id": 530},
{"snippet": "ma.masked_values(x, value, atol=1e-08)", "intent": "Mask using floating point equality . Return a MaskedArray , masked where the data in array `x` are approximately equal to `value` , determined using isclose . With arguments `atol`.", "question_id": 531},
{"snippet": "ma.masked_values(x, value, copy=True)", "intent": "Mask using floating point equality . Return a MaskedArray , masked where the data in array `x` are approximately equal to `value` , determined using isclose . With arguments `copy`.", "question_id": 532},
{"snippet": "ma.masked_values(x, value, shrink=True)", "intent": "Mask using floating point equality . Return a MaskedArray , masked where the data in array `x` are approximately equal to `value` , determined using isclose . With arguments `shrink`.", "question_id": 533},
{"snippet": "ma.masked_values(x, value, rtol=1e-05, atol=1e-08)", "intent": "Mask using floating point equality . Return a MaskedArray , masked where the data in array `x` are approximately equal to `value` , determined using isclose . With arguments `rtol`, `atol`.", "question_id": 534},
{"snippet": "ma.masked_values(x, value, rtol=1e-05, copy=True)", "intent": "Mask using floating point equality . Return a MaskedArray , masked where the data in array `x` are approximately equal to `value` , determined using isclose . With arguments `rtol`, `copy`.", "question_id": 535},
{"snippet": "ma.masked_values(x, value, rtol=1e-05, shrink=True)", "intent": "Mask using floating point equality . Return a MaskedArray , masked where the data in array `x` are approximately equal to `value` , determined using isclose . With arguments `rtol`, `shrink`.", "question_id": 536},
{"snippet": "ma.masked_values(x, value, atol=1e-08, copy=True)", "intent": "Mask using floating point equality . Return a MaskedArray , masked where the data in array `x` are approximately equal to `value` , determined using isclose . With arguments `atol`, `copy`.", "question_id": 537},
{"snippet": "ma.masked_values(x, value, atol=1e-08, shrink=True)", "intent": "Mask using floating point equality . Return a MaskedArray , masked where the data in array `x` are approximately equal to `value` , determined using isclose . With arguments `atol`, `shrink`.", "question_id": 538},
{"snippet": "record.copy()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 539},
{"snippet": "polynomial.chebyshev.Chebyshev.roots()", "intent": "Return the roots of the series polynomial .", "question_id": 540},
{"snippet": "linalg.eigh(a)", "intent": "Return the eigenvalues and eigenvectors of `a` complex Hermitian ( conjugate symmetric ) or a real symmetric matrix .", "question_id": 541},
{"snippet": "linalg.eigh(a, UPLO='L')", "intent": "Return the eigenvalues and eigenvectors of `a` complex Hermitian ( conjugate symmetric ) or a real symmetric matrix . With arguments `UPLO`.", "question_id": 542},
{"snippet": "ma.MaskedArray.argmax()", "intent": "Returns array of indices of the maximum values along the given `axis` .", "question_id": 543},
{"snippet": "ma.MaskedArray.argmax(axis=None)", "intent": "Returns array of indices of the maximum values along the given `axis` .", "question_id": 544},
{"snippet": "ma.MaskedArray.argmax(fill_value=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . Masked values are treated as if they had the value `fill_value` .", "question_id": 545},
{"snippet": "ma.MaskedArray.argmax(out=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . With arguments `out`.", "question_id": 546},
{"snippet": "ma.MaskedArray.argmax(axis=None, fill_value=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . Masked values are treated as if they had the value `fill_value` .", "question_id": 547},
{"snippet": "ma.MaskedArray.argmax(axis=None, out=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . With arguments `out`.", "question_id": 548},
{"snippet": "ma.MaskedArray.argmax(fill_value=None, out=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . Masked values are treated as if they had the value `fill_value` . With arguments `out`.", "question_id": 549},
{"snippet": "ma.MaskedArray.argmax(axis=None, fill_value=None, out=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . Masked values are treated as if they had the value `fill_value` . With arguments `out`.", "question_id": 550},
{"snippet": "random.RandomState.beta(a, b)", "intent": "Draw samples from `a` Beta distribution . With arguments `b`.", "question_id": 551},
{"snippet": "random.RandomState.beta(a, b, size=None)", "intent": "Draw samples from `a` Beta distribution . With arguments `b`, `size`.", "question_id": 552},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.cache_flush()", "intent": "Force update the cache .", "question_id": 553},
{"snippet": "ma.MaskedArray.product()", "intent": "Return the product of the array elements over the given `axis` .", "question_id": 554},
{"snippet": "ma.MaskedArray.product(axis=None)", "intent": "Return the product of the array elements over the given `axis` .", "question_id": 555},
{"snippet": "ma.MaskedArray.product(dtype=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 556},
{"snippet": "ma.MaskedArray.product(out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `out`.", "question_id": 557},
{"snippet": "ma.MaskedArray.product(keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `keepdims`.", "question_id": 558},
{"snippet": "ma.MaskedArray.product(axis=None, dtype=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 559},
{"snippet": "ma.MaskedArray.product(axis=None, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `out`.", "question_id": 560},
{"snippet": "ma.MaskedArray.product(axis=None, keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `keepdims`.", "question_id": 561},
{"snippet": "ma.MaskedArray.product(dtype=None, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`, `out`.", "question_id": 562},
{"snippet": "ma.MaskedArray.product(dtype=None, keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`, `keepdims`.", "question_id": 563},
{"snippet": "ma.masked_array.shrink_mask()", "intent": "Reduce a mask to nomask when possible .", "question_id": 564},
{"snippet": "memmap.flatten()", "intent": "Return a copy of the array collapsed into one dimension .", "question_id": 565},
{"snippet": "memmap.flatten(order='C')", "intent": "Return a copy of the array collapsed into one dimension . With arguments `order`.", "question_id": 566},
{"snippet": "ma.MaskedArray.compressed()", "intent": "Return all the non-masked data as a 1-D array .", "question_id": 567},
{"snippet": "polynomial.hermite_e.hermetrim(c)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . With arguments `c`.", "question_id": 568},
{"snippet": "polynomial.hermite_e.hermetrim(c, tol=0)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . \u201c Small \u201d means \u201c small in absolute value \u201d and is controlled by the parameter `tol` ; \u201c trailing \u201d means highest order coefficient ( s ) , e.g. , in [ 0 , 1 , 1 , 0 , 0 ] ( which represents 0 + x + x * * 2 + 0 * x * * 3 + 0 * x * * 4 ) both the 3-rd and 4-th order coefficients would be \u201c trimmed . \u201d With arguments `c`.", "question_id": 569},
{"snippet": "random.RandomState.uniform()", "intent": "Draw samples from a uniform distribution .", "question_id": 570},
{"snippet": "random.RandomState.uniform(low=0.0)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) .", "question_id": 571},
{"snippet": "random.RandomState.uniform(high=1.0)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) .", "question_id": 572},
{"snippet": "random.RandomState.uniform(size=None)", "intent": "Draw samples from a uniform distribution . With arguments `size`.", "question_id": 573},
{"snippet": "random.RandomState.uniform(low=0.0, high=1.0)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) .", "question_id": 574},
{"snippet": "random.RandomState.uniform(low=0.0, size=None)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . With arguments `size`.", "question_id": 575},
{"snippet": "random.RandomState.uniform(high=1.0, size=None)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . With arguments `size`.", "question_id": 576},
{"snippet": "random.RandomState.uniform(low=0.0, high=1.0, size=None)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . With arguments `size`.", "question_id": 577},
{"snippet": "ma.MaskedArray.__divmod__(value, /)", "intent": "Return divmod ( self , `value` ) . With arguments `/`.", "question_id": 578},
{"snippet": "chararray.tobytes()", "intent": "Construct Python bytes containing the raw data bytes in the array .", "question_id": 579},
{"snippet": "chararray.tobytes(order='C')", "intent": "Construct Python bytes containing the raw data bytes in the array . This behavior is controlled by the `order` parameter .", "question_id": 580},
{"snippet": "record.searchsorted()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 581},
{"snippet": "matrix.partition(kth)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array .", "question_id": 582},
{"snippet": "matrix.partition(kth, axis=- 1)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`.", "question_id": 583},
{"snippet": "matrix.partition(kth, kind='introselect')", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `kind`.", "question_id": 584},
{"snippet": "matrix.partition(kth, order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `order`.", "question_id": 585},
{"snippet": "matrix.partition(kth, axis=- 1, kind='introselect')", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `kind`.", "question_id": 586},
{"snippet": "matrix.partition(kth, axis=- 1, order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `order`.", "question_id": 587},
{"snippet": "matrix.partition(kth, kind='introselect', order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `kind`, `order`.", "question_id": 588},
{"snippet": "matrix.partition(kth, axis=- 1, kind='introselect', order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `kind`, `order`.", "question_id": 589},
{"snippet": "polynomial.legendre.legval3d(x, y, z, c)", "intent": "Evaluate a 3-D Legendre series at points ( `x` , `y` , `z` ) . In either case , either x , y , and z or their elements must support multiplication and addition both with themselves and with the elements of `c` .", "question_id": 590},
{"snippet": "lib.format.open_memmap(filename)", "intent": "Open a .npy file as a memory-mapped array . With arguments `filename`.", "question_id": 591},
{"snippet": "lib.format.open_memmap(filename, mode='r+')", "intent": "Open a .npy file as a memory-mapped array . With arguments `filename`, `mode`.", "question_id": 592},
{"snippet": "lib.format.open_memmap(filename, dtype=None)", "intent": "Open a .npy file as a memory-mapped array . With arguments `filename`, `dtype`.", "question_id": 593},
{"snippet": "lib.format.open_memmap(filename, shape=None)", "intent": "Open a .npy file as a memory-mapped array . With arguments `filename`, `shape`.", "question_id": 594},
{"snippet": "lib.format.open_memmap(filename, fortran_order=False)", "intent": "Open a .npy file as a memory-mapped array . With arguments `filename`, `fortran_order`.", "question_id": 595},
{"snippet": "lib.format.open_memmap(filename, version=None)", "intent": "Open a .npy file as a memory-mapped array . With arguments `filename`, `version`.", "question_id": 596},
{"snippet": "lib.format.open_memmap(filename, mode='r+', dtype=None)", "intent": "Open a .npy file as a memory-mapped array . With arguments `filename`, `mode`, `dtype`.", "question_id": 597},
{"snippet": "lib.format.open_memmap(filename, mode='r+', shape=None)", "intent": "Open a .npy file as a memory-mapped array . With arguments `filename`, `mode`, `shape`.", "question_id": 598},
{"snippet": "lib.format.open_memmap(filename, mode='r+', fortran_order=False)", "intent": "Open a .npy file as a memory-mapped array . With arguments `filename`, `mode`, `fortran_order`.", "question_id": 599},
{"snippet": "lib.format.open_memmap(filename, mode='r+', version=None)", "intent": "Open a .npy file as a memory-mapped array . With arguments `filename`, `mode`, `version`.", "question_id": 600},
{"snippet": "ma.notmasked_edges(a)", "intent": "Find the indices of the first and last unmasked values along an `axis` . Otherwise , return `a` list of two tuples , corresponding to the indices of the first and last unmasked values respectively .", "question_id": 601},
{"snippet": "ma.notmasked_edges(a, axis=None)", "intent": "Find the indices of the first and last unmasked values along an `axis` . Otherwise , return `a` list of two tuples , corresponding to the indices of the first and last unmasked values respectively .", "question_id": 602},
{"snippet": "dtype.isalignedstruct", "intent": "Boolean indicating whether the dtype is a struct which maintains field alignment.", "question_id": 603},
{"snippet": "memmap.swapaxes(axis1, axis2)", "intent": "Return a view of the array with `axis1` and `axis2` interchanged .", "question_id": 604},
{"snippet": "ma.polyfit(x, y, deg)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) .", "question_id": 605},
{"snippet": "ma.polyfit(x, y, deg, rcond=None)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious : including contributions from the small singular values can add numerical noise to the result .", "question_id": 606},
{"snippet": "ma.polyfit(x, y, deg, full=False)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . With arguments `full`.", "question_id": 607},
{"snippet": "ma.polyfit(x, y, deg, w=None)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . With arguments `w`.", "question_id": 608},
{"snippet": "ma.polyfit(x, y, deg, cov=False)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . With arguments `cov`.", "question_id": 609},
{"snippet": "ma.polyfit(x, y, deg, rcond=None, full=False)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious : including contributions from the small singular values can add numerical noise to the result . With arguments `full`.", "question_id": 610},
{"snippet": "ma.polyfit(x, y, deg, rcond=None, w=None)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious : including contributions from the small singular values can add numerical noise to the result . With arguments `w`.", "question_id": 611},
{"snippet": "ma.polyfit(x, y, deg, rcond=None, cov=False)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious : including contributions from the small singular values can add numerical noise to the result . With arguments `cov`.", "question_id": 612},
{"snippet": "ma.polyfit(x, y, deg, full=False, w=None)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . With arguments `full`, `w`.", "question_id": 613},
{"snippet": "ma.polyfit(x, y, deg, full=False, cov=False)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . With arguments `full`, `cov`.", "question_id": 614},
{"snippet": "ma.MaskedArray.conj()", "intent": "Complex-conjugate all elements .", "question_id": 615},
{"snippet": "polynomial.laguerre.Laguerre.fromroots(roots)", "intent": "Return series instance that has the specified `roots` .", "question_id": 616},
{"snippet": "polynomial.laguerre.Laguerre.fromroots(roots, domain=)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`.", "question_id": 617},
{"snippet": "polynomial.laguerre.Laguerre.fromroots(roots, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `window`.", "question_id": 618},
{"snippet": "polynomial.laguerre.Laguerre.fromroots(roots, domain=, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`, `window`.", "question_id": 619},
{"snippet": "polynomial.laguerre.Laguerre.fromroots()", "intent": "Return series instance that has the specified `roots` .", "question_id": 620},
{"snippet": "polynomial.laguerre.Laguerre.fromroots(domain=)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`.", "question_id": 621},
{"snippet": "polynomial.laguerre.Laguerre.fromroots(window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `window`.", "question_id": 622},
{"snippet": "polynomial.laguerre.Laguerre.fromroots(domain=, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`, `window`.", "question_id": 623},
{"snippet": "numpy.square(x, /, signature, extobj)", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `extobj`.", "question_id": 624},
{"snippet": "numpy.square(x, /, signature, extobj, out=None)", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `extobj`, `out`.", "question_id": 625},
{"snippet": "numpy.square(x, /, signature, extobj, where=True)", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `extobj`, `where`.", "question_id": 626},
{"snippet": "numpy.square(x, /, signature, extobj, casting='same_kind')", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `extobj`, `casting`.", "question_id": 627},
{"snippet": "numpy.square(x, /, signature, extobj, order='K')", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `extobj`, `order`.", "question_id": 628},
{"snippet": "numpy.square(x, /, signature, extobj, dtype=None)", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `extobj`, `dtype`.", "question_id": 629},
{"snippet": "numpy.square(x, /, signature, extobj, subok=True)", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `extobj`, `subok`.", "question_id": 630},
{"snippet": "numpy.square(x, /, signature, extobj, out=None, where=True)", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 631},
{"snippet": "numpy.square(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 632},
{"snippet": "numpy.square(x, /, signature, extobj, out=None, order='K')", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 633},
{"snippet": "numpy.square(x, /, signature)", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`.", "question_id": 634},
{"snippet": "numpy.square(x, /, signature, out=None)", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `out`.", "question_id": 635},
{"snippet": "numpy.square(x, /, signature, where=True)", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `where`.", "question_id": 636},
{"snippet": "numpy.square(x, /, signature, casting='same_kind')", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `casting`.", "question_id": 637},
{"snippet": "numpy.square(x, /, signature, order='K')", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `order`.", "question_id": 638},
{"snippet": "numpy.square(x, /, signature, dtype=None)", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `dtype`.", "question_id": 639},
{"snippet": "numpy.square(x, /, signature, subok=True)", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `subok`.", "question_id": 640},
{"snippet": "numpy.square(x, /, signature, out=None, where=True)", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `out`, `where`.", "question_id": 641},
{"snippet": "numpy.square(x, /, signature, out=None, casting='same_kind')", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `out`, `casting`.", "question_id": 642},
{"snippet": "numpy.square(x, /, signature, out=None, order='K')", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `out`, `order`.", "question_id": 643},
{"snippet": "chararray.fill(value)", "intent": "Fill the array with a scalar `value` .", "question_id": 644},
{"snippet": "ma.MaskedArray.iscontiguous()", "intent": "Return a boolean indicating whether the data is contiguous .", "question_id": 645},
{"snippet": "distutils.ccompiler.CCompiler_show_customization(self)", "intent": "Print the compiler customizations to stdout . With arguments `self`.", "question_id": 646},
{"snippet": "random.RandomState.random_sample()", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) .", "question_id": 647},
{"snippet": "random.RandomState.random_sample(size=None)", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) . With arguments `size`.", "question_id": 648},
{"snippet": "ma.MaskType.dump()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 649},
{"snippet": "ndarray.mean()", "intent": "Returns the average of the array elements along given `axis` .", "question_id": 650},
{"snippet": "ndarray.mean(axis=None)", "intent": "Returns the average of the array elements along given `axis` .", "question_id": 651},
{"snippet": "ndarray.mean(dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`.", "question_id": 652},
{"snippet": "ndarray.mean(out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`.", "question_id": 653},
{"snippet": "ndarray.mean(keepdims=False)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`.", "question_id": 654},
{"snippet": "ndarray.mean(where=True)", "intent": "Returns the average of the array elements along given `axis` . With arguments `where`.", "question_id": 655},
{"snippet": "ndarray.mean(axis=None, dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`.", "question_id": 656},
{"snippet": "ndarray.mean(axis=None, out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`.", "question_id": 657},
{"snippet": "ndarray.mean(axis=None, keepdims=False)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`.", "question_id": 658},
{"snippet": "ndarray.mean(axis=None, where=True)", "intent": "Returns the average of the array elements along given `axis` . With arguments `where`.", "question_id": 659},
{"snippet": "linalg.LinAlgError", "intent": "Generic Python-exception-derived object raised by linalg functions.", "question_id": 660},
{"snippet": "char.chararray.ndim", "intent": "Number of array dimensions.", "question_id": 661},
{"snippet": "numpy.is_busday(dates)", "intent": "Calculates which of the given `dates` are valid days , and which are not .", "question_id": 662},
{"snippet": "numpy.is_busday(dates, weekmask='1111100')", "intent": "Calculates which of the given `dates` are valid days , and which are not . With arguments `weekmask`.", "question_id": 663},
{"snippet": "numpy.is_busday(dates, holidays=None)", "intent": "Calculates which of the given `dates` are valid days , and which are not . With arguments `holidays`.", "question_id": 664},
{"snippet": "numpy.is_busday(dates, busdaycal=None)", "intent": "Calculates which of the given `dates` are valid days , and which are not . With arguments `busdaycal`.", "question_id": 665},
{"snippet": "numpy.is_busday(dates, out=None)", "intent": "Calculates which of the given `dates` are valid days , and which are not . With arguments `out`.", "question_id": 666},
{"snippet": "numpy.is_busday(dates, weekmask='1111100', holidays=None)", "intent": "Calculates which of the given `dates` are valid days , and which are not . With arguments `weekmask`, `holidays`.", "question_id": 667},
{"snippet": "numpy.is_busday(dates, weekmask='1111100', busdaycal=None)", "intent": "Calculates which of the given `dates` are valid days , and which are not . With arguments `weekmask`, `busdaycal`.", "question_id": 668},
{"snippet": "numpy.is_busday(dates, weekmask='1111100', out=None)", "intent": "Calculates which of the given `dates` are valid days , and which are not . With arguments `weekmask`, `out`.", "question_id": 669},
{"snippet": "numpy.is_busday(dates, holidays=None, busdaycal=None)", "intent": "Calculates which of the given `dates` are valid days , and which are not . With arguments `holidays`, `busdaycal`.", "question_id": 670},
{"snippet": "numpy.is_busday(dates, holidays=None, out=None)", "intent": "Calculates which of the given `dates` are valid days , and which are not . With arguments `holidays`, `out`.", "question_id": 671},
{"snippet": "chararray.nonzero()", "intent": "Return the indices of the elements that are non-zero .", "question_id": 672},
{"snippet": "ma.masked_array.iscontiguous()", "intent": "Return a boolean indicating whether the data is contiguous .", "question_id": 673},
{"snippet": "polynomial.legendre.legvander2d(x, y, deg)", "intent": "Pseudo-Vandermonde matrix of given degrees . Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points ( `x` , `y` ) .", "question_id": 674},
{"snippet": "numpy.savez_compressed(file, *args, **kwds)", "intent": "Save several arrays into a single `file` in compressed .npz format . With arguments `*args`, `**kwds`.", "question_id": 675},
{"snippet": "ma.MaskedArray.__sub__(other)", "intent": "Subtract `other` from self , and return a new masked array .", "question_id": 676},
{"snippet": "polynomial.legendre.Legendre.linspace()", "intent": "Return x , y values at equally spaced points in `domain` .", "question_id": 677},
{"snippet": "polynomial.legendre.Legendre.linspace(n=100)", "intent": "Return x , y values at equally spaced points in `domain` . Returns the x , y values at `n` linearly spaced points across the domain .", "question_id": 678},
{"snippet": "polynomial.legendre.Legendre.linspace(domain=None)", "intent": "Return x , y values at equally spaced points in `domain` .", "question_id": 679},
{"snippet": "polynomial.legendre.Legendre.linspace(n=100, domain=None)", "intent": "Return x , y values at equally spaced points in `domain` . Returns the x , y values at `n` linearly spaced points across the domain .", "question_id": 680},
{"snippet": "memmap.flush()", "intent": "Write any changes in the array to the file on disk .", "question_id": 681},
{"snippet": "char.chararray.nonzero()", "intent": "Return the indices of the elements that are non-zero .", "question_id": 682},
{"snippet": "record.sum()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 683},
{"snippet": "char.chararray.isupper()", "intent": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character , false otherwise .", "question_id": 684},
{"snippet": "ma.masked_array.round()", "intent": "Return each element rounded to the given number of `decimals` .", "question_id": 685},
{"snippet": "ma.masked_array.round(decimals=0)", "intent": "Return each element rounded to the given number of `decimals` .", "question_id": 686},
{"snippet": "ma.masked_array.round(out=None)", "intent": "Return each element rounded to the given number of `decimals` . With arguments `out`.", "question_id": 687},
{"snippet": "ma.masked_array.round(decimals=0, out=None)", "intent": "Return each element rounded to the given number of `decimals` . With arguments `out`.", "question_id": 688},
{"snippet": "ma.masked_array.item(*args)", "intent": "Copy an element of an array to a standard Python scalar and return it . With arguments `*args`.", "question_id": 689},
{"snippet": "ma.MaskedArray.__lshift__(value, /)", "intent": "Return self < < `value` . With arguments `/`.", "question_id": 690},
{"snippet": "matrix.getH()", "intent": "Returns the ( complex ) conjugate transpose of self .", "question_id": 691},
{"snippet": "random.RandomState.seed(self)", "intent": "Reseed a legacy MT19937 BitGenerator With arguments `self`.", "question_id": 692},
{"snippet": "random.RandomState.seed(self, seed=None)", "intent": "Reseed a legacy MT19937 BitGenerator With arguments `self`, `seed`.", "question_id": 693},
{"snippet": "polynomial.hermite.Hermite.deriv()", "intent": "Differentiate .", "question_id": 694},
{"snippet": "polynomial.hermite.Hermite.deriv(m=1)", "intent": "Differentiate . With arguments `m`.", "question_id": 695},
{"snippet": "polynomial.polynomial.Polynomial.roots()", "intent": "Return the roots of the series polynomial .", "question_id": 696},
{"snippet": "ndarray.__setstate__(state, /)", "intent": "For unpickling . The `state` argument must be a sequence that contains the following elements : With arguments `/`.", "question_id": 697},
{"snippet": "recarray.take(indices)", "intent": "Return an array formed from the elements of a at the given `indices` .", "question_id": 698},
{"snippet": "recarray.take(indices, axis=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`.", "question_id": 699},
{"snippet": "recarray.take(indices, out=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `out`.", "question_id": 700},
{"snippet": "recarray.take(indices, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `mode`.", "question_id": 701},
{"snippet": "recarray.take(indices, axis=None, out=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `out`.", "question_id": 702},
{"snippet": "recarray.take(indices, axis=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `mode`.", "question_id": 703},
{"snippet": "recarray.take(indices, out=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `out`, `mode`.", "question_id": 704},
{"snippet": "recarray.take(indices, axis=None, out=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `out`, `mode`.", "question_id": 705},
{"snippet": "ndarray.__contains__(key, /)", "intent": "Return `key` in self . With arguments `/`.", "question_id": 706},
{"snippet": "ma.MaskedArray.item(*args)", "intent": "Copy an element of an array to a standard Python scalar and return it . With arguments `*args`.", "question_id": 707},
{"snippet": "numpy.atleast_2d(*arys)", "intent": "View inputs as arrays with at least two dimensions . With arguments `*arys`.", "question_id": 708},
{"snippet": "char.chararray.sort()", "intent": "Sort an array in-place .", "question_id": 709},
{"snippet": "char.chararray.sort(axis=- 1)", "intent": "Sort an array in-place . With arguments `axis`.", "question_id": 710},
{"snippet": "char.chararray.sort(kind=None)", "intent": "Sort an array in-place . With arguments `kind`.", "question_id": 711},
{"snippet": "char.chararray.sort(order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array :", "question_id": 712},
{"snippet": "char.chararray.sort(axis=- 1, kind=None)", "intent": "Sort an array in-place . With arguments `axis`, `kind`.", "question_id": 713},
{"snippet": "char.chararray.sort(axis=- 1, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `axis`.", "question_id": 714},
{"snippet": "char.chararray.sort(kind=None, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `kind`.", "question_id": 715},
{"snippet": "char.chararray.sort(axis=- 1, kind=None, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `axis`, `kind`.", "question_id": 716},
{"snippet": "ma.MaskedArray.swapaxes(axis1, axis2)", "intent": "Return a view of the array with `axis1` and `axis2` interchanged .", "question_id": 717},
{"snippet": "char.chararray.capitalize()", "intent": "Return a copy of self with only the first character of each element capitalized .", "question_id": 718},
{"snippet": "ma.apply_along_axis(func1d, axis, arr, *args, **kwargs)", "intent": "Apply a function to 1-D slices along the given `axis` . Execute `func1d` ( a , * args , * * kwargs ) where func1d operates on 1-D arrays and a is a 1-D slice of `arr` along axis . With arguments `*args`, `**kwargs`.", "question_id": 719},
{"snippet": "numpy.tensordot(a, b)", "intent": "Compute tensor dot product along specified `axes` . Given two tensors , `a` and `b` , and an array_like object containing two array_like objects , ( a_axes , b_axes ) , sum the products of a \u2019 s and b \u2019 s elements ( components ) over the axes specified by a_axes and b_axes .", "question_id": 720},
{"snippet": "numpy.tensordot(a, b, axes=2)", "intent": "Compute tensor dot product along specified `axes` . Given two tensors , `a` and `b` , and an array_like object containing two array_like objects , ( a_axes , b_axes ) , sum the products of a \u2019 s and b \u2019 s elements ( components ) over the axes specified by a_axes and b_axes .", "question_id": 721},
{"snippet": "numpy.lib.mixins.NDArrayOperatorsMixin", "intent": "Mixin defining all operator special methods using __array_ufunc__.", "question_id": 722},
{"snippet": "matrix.data", "intent": "Python buffer object pointing to the start of the array\u2019s data.", "question_id": 723},
{"snippet": "ndarray.resize(new_shape)", "intent": "Change shape and size of array in-place . With arguments `new_shape`.", "question_id": 724},
{"snippet": "ndarray.resize(new_shape, refcheck=True)", "intent": "Change shape and size of array in-place . However , reference counts can increase in other ways so if you are sure that you have not shared the memory for this array with another Python object , then you may safely set `refcheck` to False . With arguments `new_shape`.", "question_id": 725},
{"snippet": "matrix.repeat(repeats)", "intent": "Repeat elements of an array . With arguments `repeats`.", "question_id": 726},
{"snippet": "matrix.repeat(repeats, axis=None)", "intent": "Repeat elements of an array . With arguments `repeats`, `axis`.", "question_id": 727},
{"snippet": "ma.MaskedArray.shrink_mask()", "intent": "Reduce a mask to nomask when possible .", "question_id": 728},
{"snippet": "ma.compress_cols(a)", "intent": "Suppress whole columns of `a` 2-D array that contain masked values .", "question_id": 729},
{"snippet": "matrix.shape", "intent": "Tuple of array dimensions.", "question_id": 730},
{"snippet": "random.RandomState.hypergeometric(ngood, nbad, nsample)", "intent": "Draw samples from a Hypergeometric distribution . Samples are drawn from a hypergeometric distribution with specified parameters , `ngood` ( ways to make a good selection ) , `nbad` ( ways to make a bad selection ) , and `nsample` ( number of items sampled , which is less than or equal to the sum ngood + nbad ) .", "question_id": 731},
{"snippet": "random.RandomState.hypergeometric(ngood, nbad, nsample, size=None)", "intent": "Draw samples from a Hypergeometric distribution . Samples are drawn from a hypergeometric distribution with specified parameters , `ngood` ( ways to make a good selection ) , `nbad` ( ways to make a bad selection ) , and `nsample` ( number of items sampled , which is less than or equal to the sum ngood + nbad ) . With arguments `size`.", "question_id": 732},
{"snippet": "recarray.sort()", "intent": "Sort an array in-place .", "question_id": 733},
{"snippet": "recarray.sort(axis=- 1)", "intent": "Sort an array in-place . With arguments `axis`.", "question_id": 734},
{"snippet": "recarray.sort(kind=None)", "intent": "Sort an array in-place . With arguments `kind`.", "question_id": 735},
{"snippet": "recarray.sort(order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array :", "question_id": 736},
{"snippet": "recarray.sort(axis=- 1, kind=None)", "intent": "Sort an array in-place . With arguments `axis`, `kind`.", "question_id": 737},
{"snippet": "recarray.sort(axis=- 1, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `axis`.", "question_id": 738},
{"snippet": "recarray.sort(kind=None, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `kind`.", "question_id": 739},
{"snippet": "recarray.sort(axis=- 1, kind=None, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `axis`, `kind`.", "question_id": 740},
{"snippet": "numpy.add(x1, x2, /, signature, extobj)", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`.", "question_id": 741},
{"snippet": "numpy.add(x1, x2, /, signature, extobj, out=None)", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 742},
{"snippet": "numpy.add(x1, x2, /, signature, extobj, where=True)", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 743},
{"snippet": "numpy.add(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 744},
{"snippet": "numpy.add(x1, x2, /, signature, extobj, order='K')", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 745},
{"snippet": "numpy.add(x1, x2, /, signature, extobj, dtype=None)", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 746},
{"snippet": "numpy.add(x1, x2, /, signature, extobj, subok=True)", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 747},
{"snippet": "numpy.add(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 748},
{"snippet": "numpy.add(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 749},
{"snippet": "numpy.add(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 750},
{"snippet": "numpy.add(x1, x2, /, signature)", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`.", "question_id": 751},
{"snippet": "numpy.add(x1, x2, /, signature, out=None)", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `out`.", "question_id": 752},
{"snippet": "numpy.add(x1, x2, /, signature, where=True)", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `where`.", "question_id": 753},
{"snippet": "numpy.add(x1, x2, /, signature, casting='same_kind')", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `casting`.", "question_id": 754},
{"snippet": "numpy.add(x1, x2, /, signature, order='K')", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `order`.", "question_id": 755},
{"snippet": "numpy.add(x1, x2, /, signature, dtype=None)", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `dtype`.", "question_id": 756},
{"snippet": "numpy.add(x1, x2, /, signature, subok=True)", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `subok`.", "question_id": 757},
{"snippet": "numpy.add(x1, x2, /, signature, out=None, where=True)", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `out`, `where`.", "question_id": 758},
{"snippet": "numpy.add(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 759},
{"snippet": "numpy.add(x1, x2, /, signature, out=None, order='K')", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `out`, `order`.", "question_id": 760},
{"snippet": "ndarray.__xor__(value, /)", "intent": "Return self^value . With arguments `value`, `/`.", "question_id": 761},
{"snippet": "chararray.upper()", "intent": "Return an array with the elements of self converted to uppercase .", "question_id": 762},
{"snippet": "ma.anom(self)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . With arguments `self`.", "question_id": 763},
{"snippet": "ma.anom(self, axis=None)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . With arguments `self`.", "question_id": 764},
{"snippet": "ma.anom(self, dtype=None)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . With arguments `self`, `dtype`.", "question_id": 765},
{"snippet": "ma.anom(self, axis=None, dtype=None)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . With arguments `self`, `dtype`.", "question_id": 766},
{"snippet": "ma.masked_array.get_real()", "intent": "The real part of the masked array .", "question_id": 767},
{"snippet": "random.RandomState.standard_normal()", "intent": "Draw samples from a standard Normal distribution ( mean=0 , stdev=1 ) .", "question_id": 768},
{"snippet": "random.RandomState.standard_normal(size=None)", "intent": "Draw samples from a standard Normal distribution ( mean=0 , stdev=1 ) . With arguments `size`.", "question_id": 769},
{"snippet": "ma.masked_less_equal(x, value)", "intent": "Mask an array where less than or equal to a given `value` . This function is a shortcut to masked_where , with condition = ( `x` < = value ) .", "question_id": 770},
{"snippet": "ma.masked_less_equal(x, value, copy=True)", "intent": "Mask an array where less than or equal to a given `value` . This function is a shortcut to masked_where , with condition = ( `x` < = value ) . With arguments `copy`.", "question_id": 771},
{"snippet": "numpy.nanmax(a)", "intent": "Return the maximum of an array or maximum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and NaN is returned for that slice .", "question_id": 772},
{"snippet": "numpy.nanmax(a, axis=None)", "intent": "Return the maximum of an array or maximum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and NaN is returned for that slice .", "question_id": 773},
{"snippet": "numpy.nanmax(a, out=None)", "intent": "Return the maximum of an array or maximum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and NaN is returned for that slice . With arguments `out`.", "question_id": 774},
{"snippet": "numpy.nanmax(a, keepdims=<no value>)", "intent": "Return the maximum of an array or maximum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and NaN is returned for that slice . With arguments `keepdims`.", "question_id": 775},
{"snippet": "numpy.nanmax(a, axis=None, out=None)", "intent": "Return the maximum of an array or maximum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and NaN is returned for that slice . With arguments `out`.", "question_id": 776},
{"snippet": "numpy.nanmax(a, axis=None, keepdims=<no value>)", "intent": "Return the maximum of an array or maximum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and NaN is returned for that slice . With arguments `keepdims`.", "question_id": 777},
{"snippet": "numpy.nanmax(a, out=None, keepdims=<no value>)", "intent": "Return the maximum of an array or maximum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and NaN is returned for that slice . With arguments `out`, `keepdims`.", "question_id": 778},
{"snippet": "numpy.nanmax(a, axis=None, out=None, keepdims=<no value>)", "intent": "Return the maximum of an array or maximum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and NaN is returned for that slice . With arguments `out`, `keepdims`.", "question_id": 779},
{"snippet": "chararray.size", "intent": "Number of elements in the array.", "question_id": 780},
{"snippet": "numpy.tan(x, /, signature, extobj)", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . With arguments `/`, `signature`, `extobj`.", "question_id": 781},
{"snippet": "numpy.tan(x, /, signature, extobj, out=None)", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `extobj`.", "question_id": 782},
{"snippet": "numpy.tan(x, /, signature, extobj, where=True)", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 783},
{"snippet": "numpy.tan(x, /, signature, extobj, casting='same_kind')", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 784},
{"snippet": "numpy.tan(x, /, signature, extobj, order='K')", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 785},
{"snippet": "numpy.tan(x, /, signature, extobj, dtype=None)", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 786},
{"snippet": "numpy.tan(x, /, signature, extobj, subok=True)", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 787},
{"snippet": "numpy.tan(x, /, signature, extobj, out=None, where=True)", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 788},
{"snippet": "numpy.tan(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 789},
{"snippet": "numpy.tan(x, /, signature, extobj, out=None, order='K')", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 790},
{"snippet": "numpy.tan(x, /, signature)", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . With arguments `/`, `signature`.", "question_id": 791},
{"snippet": "numpy.tan(x, /, signature, out=None)", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`.", "question_id": 792},
{"snippet": "numpy.tan(x, /, signature, where=True)", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . With arguments `/`, `signature`, `where`.", "question_id": 793},
{"snippet": "numpy.tan(x, /, signature, casting='same_kind')", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . With arguments `/`, `signature`, `casting`.", "question_id": 794},
{"snippet": "numpy.tan(x, /, signature, order='K')", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . With arguments `/`, `signature`, `order`.", "question_id": 795},
{"snippet": "numpy.tan(x, /, signature, dtype=None)", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . With arguments `/`, `signature`, `dtype`.", "question_id": 796},
{"snippet": "numpy.tan(x, /, signature, subok=True)", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . With arguments `/`, `signature`, `subok`.", "question_id": 797},
{"snippet": "numpy.tan(x, /, signature, out=None, where=True)", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `where`.", "question_id": 798},
{"snippet": "numpy.tan(x, /, signature, out=None, casting='same_kind')", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `casting`.", "question_id": 799},
{"snippet": "numpy.tan(x, /, signature, out=None, order='K')", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `order`.", "question_id": 800},
{"snippet": "random.Generator.multinomial(n, pvals)", "intent": "Draw samples from a multinomial distribution . Each sample drawn from the distribution represents `n` such experiments . With arguments `pvals`.", "question_id": 801},
{"snippet": "random.Generator.multinomial(n, pvals, size=None)", "intent": "Draw samples from a multinomial distribution . Each sample drawn from the distribution represents `n` such experiments . With arguments `pvals`, `size`.", "question_id": 802},
{"snippet": "memmap.round()", "intent": "Return a with each element rounded to the given number of `decimals` .", "question_id": 803},
{"snippet": "memmap.round(decimals=0)", "intent": "Return a with each element rounded to the given number of `decimals` .", "question_id": 804},
{"snippet": "memmap.round(out=None)", "intent": "Return a with each element rounded to the given number of `decimals` . With arguments `out`.", "question_id": 805},
{"snippet": "memmap.round(decimals=0, out=None)", "intent": "Return a with each element rounded to the given number of `decimals` . With arguments `out`.", "question_id": 806},
{"snippet": "char.chararray.item(*args)", "intent": "Copy an element of an array to a standard Python scalar and return it . With arguments `*args`.", "question_id": 807},
{"snippet": "testing.dec.knownfailureif(fail_condition)", "intent": "Make function raise KnownFailureException exception if given condition is true . With arguments `fail_condition`.", "question_id": 808},
{"snippet": "testing.dec.knownfailureif(fail_condition, msg=None)", "intent": "Make function raise KnownFailureException exception if given condition is true . With arguments `fail_condition`, `msg`.", "question_id": 809},
{"snippet": "ma.compress_rows(a)", "intent": "Suppress whole rows of `a` 2-D array that contain masked values .", "question_id": 810},
{"snippet": "chararray.find(sub)", "intent": "For each element , return the lowest index in the string where substring `sub` is found .", "question_id": 811},
{"snippet": "chararray.find(sub, start=0)", "intent": "For each element , return the lowest index in the string where substring `sub` is found . With arguments `start`.", "question_id": 812},
{"snippet": "chararray.find(sub, end=None)", "intent": "For each element , return the lowest index in the string where substring `sub` is found . With arguments `end`.", "question_id": 813},
{"snippet": "chararray.find(sub, start=0, end=None)", "intent": "For each element , return the lowest index in the string where substring `sub` is found . With arguments `start`, `end`.", "question_id": 814},
{"snippet": "record.repeat()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 815},
{"snippet": "lib.format.header_data_from_array_1_0(array)", "intent": "Get the dictionary of header metadata from a numpy.ndarray . With arguments `array`.", "question_id": 816},
{"snippet": "matrix.getI()", "intent": "Returns the ( multiplicative ) inverse of invertible self .", "question_id": 817},
{"snippet": "numpy.s_", "intent": "A nicer way to build up index tuples for arrays.", "question_id": 818},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, extobj)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`.", "question_id": 819},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, extobj, out=(None)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `out`.", "question_id": 820},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, extobj, where=True)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `where`.", "question_id": 821},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, extobj, casting='same_kind')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `casting`.", "question_id": 822},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, extobj, order='K')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `order`.", "question_id": 823},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, extobj, dtype=None)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `dtype`.", "question_id": 824},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, extobj, subok=True)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `subok`.", "question_id": 825},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, extobj, out=(None, where=True)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `out`, `where`.", "question_id": 826},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, extobj, out=(None, casting='same_kind')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `out`, `casting`.", "question_id": 827},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, extobj, out=(None, order='K')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `out`, `order`.", "question_id": 828},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`.", "question_id": 829},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, out=(None)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `out`.", "question_id": 830},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, where=True)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `where`.", "question_id": 831},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, casting='same_kind')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `casting`.", "question_id": 832},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, order='K')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `order`.", "question_id": 833},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, dtype=None)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `dtype`.", "question_id": 834},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, subok=True)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `subok`.", "question_id": 835},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, out=(None, where=True)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `out`, `where`.", "question_id": 836},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, out=(None, casting='same_kind')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `out`, `casting`.", "question_id": 837},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, out=(None, order='K')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `out`, `order`.", "question_id": 838},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None))", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`.", "question_id": 839},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), out=(None)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `out`.", "question_id": 840},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), where=True)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `where`.", "question_id": 841},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), casting='same_kind')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `casting`.", "question_id": 842},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), order='K')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `order`.", "question_id": 843},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), dtype=None)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `dtype`.", "question_id": 844},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), subok=True)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `subok`.", "question_id": 845},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), out=(None, where=True)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `out`, `where`.", "question_id": 846},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), out=(None, casting='same_kind')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `out`, `casting`.", "question_id": 847},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), out=(None, order='K')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `out`, `order`.", "question_id": 848},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`.", "question_id": 849},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, out=(None)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `out`.", "question_id": 850},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, where=True)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `where`.", "question_id": 851},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, casting='same_kind')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `casting`.", "question_id": 852},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, order='K')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `order`.", "question_id": 853},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, dtype=None)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `dtype`.", "question_id": 854},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, subok=True)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `subok`.", "question_id": 855},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, out=(None, where=True)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `out`, `where`.", "question_id": 856},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, out=(None, casting='same_kind')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `out`, `casting`.", "question_id": 857},
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, out=(None, order='K')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `out`, `order`.", "question_id": 858},
{"snippet": "numpy.seterr()", "intent": "Set how floating-point errors are handled .", "question_id": 859},
{"snippet": "numpy.seterr(all=None)", "intent": "Set how floating-point errors are handled . With arguments `all`.", "question_id": 860},
{"snippet": "numpy.seterr(divide=None)", "intent": "Set how floating-point errors are handled . With arguments `divide`.", "question_id": 861},
{"snippet": "numpy.seterr(over=None)", "intent": "Set how floating-point errors are handled . With arguments `over`.", "question_id": 862},
{"snippet": "numpy.seterr(under=None)", "intent": "Set how floating-point errors are handled . With arguments `under`.", "question_id": 863},
{"snippet": "numpy.seterr(invalid=None)", "intent": "Set how floating-point errors are handled . With arguments `invalid`.", "question_id": 864},
{"snippet": "numpy.seterr(all=None, divide=None)", "intent": "Set how floating-point errors are handled . With arguments `all`, `divide`.", "question_id": 865},
{"snippet": "numpy.seterr(all=None, over=None)", "intent": "Set how floating-point errors are handled . With arguments `all`, `over`.", "question_id": 866},
{"snippet": "numpy.seterr(all=None, under=None)", "intent": "Set how floating-point errors are handled . With arguments `all`, `under`.", "question_id": 867},
{"snippet": "numpy.seterr(all=None, invalid=None)", "intent": "Set how floating-point errors are handled . With arguments `all`, `invalid`.", "question_id": 868},
{"snippet": "ma.average(a)", "intent": "Return the weighted average of array over the given `axis` . With arguments `a`.", "question_id": 869},
{"snippet": "ma.average(a, axis=None)", "intent": "Return the weighted average of array over the given `axis` . With arguments `a`.", "question_id": 870},
{"snippet": "ma.average(a, weights=None)", "intent": "Return the weighted average of array over the given `axis` . With arguments `a`, `weights`.", "question_id": 871},
{"snippet": "ma.average(a, returned=False)", "intent": "Return the weighted average of array over the given `axis` . With arguments `a`, `returned`.", "question_id": 872},
{"snippet": "ma.average(a, axis=None, weights=None)", "intent": "Return the weighted average of array over the given `axis` . With arguments `a`, `weights`.", "question_id": 873},
{"snippet": "ma.average(a, axis=None, returned=False)", "intent": "Return the weighted average of array over the given `axis` . With arguments `a`, `returned`.", "question_id": 874},
{"snippet": "ma.average(a, weights=None, returned=False)", "intent": "Return the weighted average of array over the given `axis` . With arguments `a`, `weights`, `returned`.", "question_id": 875},
{"snippet": "ma.average(a, axis=None, weights=None, returned=False)", "intent": "Return the weighted average of array over the given `axis` . With arguments `a`, `weights`, `returned`.", "question_id": 876},
{"snippet": "numpy.arccosh(x, /, signature, extobj)", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `extobj`.", "question_id": 877},
{"snippet": "numpy.arccosh(x, /, signature, extobj, out=None)", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 878},
{"snippet": "numpy.arccosh(x, /, signature, extobj, where=True)", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 879},
{"snippet": "numpy.arccosh(x, /, signature, extobj, casting='same_kind')", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 880},
{"snippet": "numpy.arccosh(x, /, signature, extobj, order='K')", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 881},
{"snippet": "numpy.arccosh(x, /, signature, extobj, dtype=None)", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 882},
{"snippet": "numpy.arccosh(x, /, signature, extobj, subok=True)", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 883},
{"snippet": "numpy.arccosh(x, /, signature, extobj, out=None, where=True)", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 884},
{"snippet": "numpy.arccosh(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 885},
{"snippet": "numpy.arccosh(x, /, signature, extobj, out=None, order='K')", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 886},
{"snippet": "numpy.arccosh(x, /, signature)", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`.", "question_id": 887},
{"snippet": "numpy.arccosh(x, /, signature, out=None)", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `out`.", "question_id": 888},
{"snippet": "numpy.arccosh(x, /, signature, where=True)", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `where`.", "question_id": 889},
{"snippet": "numpy.arccosh(x, /, signature, casting='same_kind')", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `casting`.", "question_id": 890},
{"snippet": "numpy.arccosh(x, /, signature, order='K')", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `order`.", "question_id": 891},
{"snippet": "numpy.arccosh(x, /, signature, dtype=None)", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `dtype`.", "question_id": 892},
{"snippet": "numpy.arccosh(x, /, signature, subok=True)", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `subok`.", "question_id": 893},
{"snippet": "numpy.arccosh(x, /, signature, out=None, where=True)", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `out`, `where`.", "question_id": 894},
{"snippet": "numpy.arccosh(x, /, signature, out=None, casting='same_kind')", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 895},
{"snippet": "numpy.arccosh(x, /, signature, out=None, order='K')", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `out`, `order`.", "question_id": 896},
{"snippet": "ma.anomalies(self)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . With arguments `self`.", "question_id": 897},
{"snippet": "ma.anomalies(self, axis=None)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . With arguments `self`.", "question_id": 898},
{"snippet": "ma.anomalies(self, dtype=None)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . With arguments `self`, `dtype`.", "question_id": 899},
{"snippet": "ma.anomalies(self, axis=None, dtype=None)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . With arguments `self`, `dtype`.", "question_id": 900},
{"snippet": "memmap.dump(file)", "intent": "Dump a pickle of the array to the specified `file` .", "question_id": 901},
{"snippet": "recarray.tofile(fid)", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method .", "question_id": 902},
{"snippet": "recarray.tofile(fid, sep='')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `sep`.", "question_id": 903},
{"snippet": "recarray.tofile(fid, format='%s')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `format`.", "question_id": 904},
{"snippet": "recarray.tofile(fid, sep='', format='%s')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `sep`, `format`.", "question_id": 905},
{"snippet": "polynomial.chebyshev.chebpts1(npts)", "intent": "Chebyshev points of the first kind . The Chebyshev points of the first kind are the points cos ( x ) , where x = [ pi * ( k + .5 ) /npts for k in range ( `npts` ) ] .", "question_id": 906},
{"snippet": "chararray.cumsum()", "intent": "Return the cumulative sum of the elements along the given `axis` .", "question_id": 907},
{"snippet": "chararray.cumsum(axis=None)", "intent": "Return the cumulative sum of the elements along the given `axis` .", "question_id": 908},
{"snippet": "chararray.cumsum(dtype=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`.", "question_id": 909},
{"snippet": "chararray.cumsum(out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `out`.", "question_id": 910},
{"snippet": "chararray.cumsum(axis=None, dtype=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`.", "question_id": 911},
{"snippet": "chararray.cumsum(axis=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `out`.", "question_id": 912},
{"snippet": "chararray.cumsum(dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 913},
{"snippet": "chararray.cumsum(axis=None, dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 914},
{"snippet": "ndarray.__str__(/)", "intent": "Return str ( self ) . With arguments `/`.", "question_id": 915},
{"snippet": "char.encode(a)", "intent": "Calls str.encode element-wise . With arguments `a`.", "question_id": 916},
{"snippet": "char.encode(a, encoding=None)", "intent": "Calls str.encode element-wise . The type of the result will depend on the `encoding` specified . With arguments `a`.", "question_id": 917},
{"snippet": "char.encode(a, errors=None)", "intent": "Calls str.encode element-wise . With arguments `a`, `errors`.", "question_id": 918},
{"snippet": "char.encode(a, encoding=None, errors=None)", "intent": "Calls str.encode element-wise . The type of the result will depend on the `encoding` specified . With arguments `a`, `errors`.", "question_id": 919},
{"snippet": "matrix.take(indices)", "intent": "Return an array formed from the elements of a at the given `indices` .", "question_id": 920},
{"snippet": "matrix.take(indices, axis=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`.", "question_id": 921},
{"snippet": "matrix.take(indices, out=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `out`.", "question_id": 922},
{"snippet": "matrix.take(indices, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `mode`.", "question_id": 923},
{"snippet": "matrix.take(indices, axis=None, out=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `out`.", "question_id": 924},
{"snippet": "matrix.take(indices, axis=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `mode`.", "question_id": 925},
{"snippet": "matrix.take(indices, out=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `out`, `mode`.", "question_id": 926},
{"snippet": "matrix.take(indices, axis=None, out=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `out`, `mode`.", "question_id": 927},
{"snippet": "testing.assert_allclose(actual, desired)", "intent": "Raises an AssertionError if two objects are not equal up to `desired` tolerance . The test is equivalent to allclose ( `actual` , desired , `rtol` , `atol` ) ( note that allclose has different default values ) .", "question_id": 928},
{"snippet": "testing.assert_allclose(actual, desired, rtol=1e-07)", "intent": "Raises an AssertionError if two objects are not equal up to `desired` tolerance . The test is equivalent to allclose ( `actual` , desired , `rtol` , `atol` ) ( note that allclose has different default values ) .", "question_id": 929},
{"snippet": "testing.assert_allclose(actual, desired, atol=0)", "intent": "Raises an AssertionError if two objects are not equal up to `desired` tolerance . The test is equivalent to allclose ( `actual` , desired , `rtol` , `atol` ) ( note that allclose has different default values ) .", "question_id": 930},
{"snippet": "testing.assert_allclose(actual, desired, equal_nan=True)", "intent": "Raises an AssertionError if two objects are not equal up to `desired` tolerance . The test is equivalent to allclose ( `actual` , desired , `rtol` , `atol` ) ( note that allclose has different default values ) . With arguments `equal_nan`.", "question_id": 931},
{"snippet": "testing.assert_allclose(actual, desired, err_msg='')", "intent": "Raises an AssertionError if two objects are not equal up to `desired` tolerance . The test is equivalent to allclose ( `actual` , desired , `rtol` , `atol` ) ( note that allclose has different default values ) . With arguments `err_msg`.", "question_id": 932},
{"snippet": "testing.assert_allclose(actual, desired, verbose=True)", "intent": "Raises an AssertionError if two objects are not equal up to `desired` tolerance . The test is equivalent to allclose ( `actual` , desired , `rtol` , `atol` ) ( note that allclose has different default values ) . With arguments `verbose`.", "question_id": 933},
{"snippet": "testing.assert_allclose(actual, desired, rtol=1e-07, atol=0)", "intent": "Raises an AssertionError if two objects are not equal up to `desired` tolerance . The test is equivalent to allclose ( `actual` , desired , `rtol` , `atol` ) ( note that allclose has different default values ) .", "question_id": 934},
{"snippet": "testing.assert_allclose(actual, desired, rtol=1e-07, equal_nan=True)", "intent": "Raises an AssertionError if two objects are not equal up to `desired` tolerance . The test is equivalent to allclose ( `actual` , desired , `rtol` , `atol` ) ( note that allclose has different default values ) . With arguments `equal_nan`.", "question_id": 935},
{"snippet": "testing.assert_allclose(actual, desired, rtol=1e-07, err_msg='')", "intent": "Raises an AssertionError if two objects are not equal up to `desired` tolerance . The test is equivalent to allclose ( `actual` , desired , `rtol` , `atol` ) ( note that allclose has different default values ) . With arguments `err_msg`.", "question_id": 936},
{"snippet": "testing.assert_allclose(actual, desired, rtol=1e-07, verbose=True)", "intent": "Raises an AssertionError if two objects are not equal up to `desired` tolerance . The test is equivalent to allclose ( `actual` , desired , `rtol` , `atol` ) ( note that allclose has different default values ) . With arguments `verbose`.", "question_id": 937},
{"snippet": "distutils.ccompiler_opt.new_ccompiler_opt(compiler, dispatch_hpath, **kwargs)", "intent": "Create a new instance of \u2018 CCompilerOpt \u2019 and generate the dispatch header which contains the # definitions and headers of platform-specific instruction-sets for the enabled CPU baseline and dispatch-able features . With arguments `compiler`, `dispatch_hpath`, `**kwargs`.", "question_id": 938},
{"snippet": "ma.set_fill_value(a, fill_value)", "intent": "Set the filling value of `a` , if a is a masked array . With arguments `fill_value`.", "question_id": 939},
{"snippet": "char.chararray.std()", "intent": "Returns the standard deviation of the array elements along given `axis` .", "question_id": 940},
{"snippet": "char.chararray.std(axis=None)", "intent": "Returns the standard deviation of the array elements along given `axis` .", "question_id": 941},
{"snippet": "char.chararray.std(dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`.", "question_id": 942},
{"snippet": "char.chararray.std(out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`.", "question_id": 943},
{"snippet": "char.chararray.std(ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`.", "question_id": 944},
{"snippet": "char.chararray.std(keepdims=False)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `keepdims`.", "question_id": 945},
{"snippet": "char.chararray.std(where=True)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `where`.", "question_id": 946},
{"snippet": "char.chararray.std(axis=None, dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`.", "question_id": 947},
{"snippet": "char.chararray.std(axis=None, out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`.", "question_id": 948},
{"snippet": "char.chararray.std(axis=None, ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`.", "question_id": 949},
{"snippet": "ma.MaskedArray.__lt__(value, /)", "intent": "Return self < `value` . With arguments `/`.", "question_id": 950},
{"snippet": "ma.MaskedArray.any()", "intent": "Returns True if any of the elements of a evaluate to True .", "question_id": 951},
{"snippet": "ma.MaskedArray.any(axis=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`.", "question_id": 952},
{"snippet": "ma.MaskedArray.any(out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`.", "question_id": 953},
{"snippet": "ma.MaskedArray.any(keepdims=<no value>)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `keepdims`.", "question_id": 954},
{"snippet": "ma.MaskedArray.any(axis=None, out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `out`.", "question_id": 955},
{"snippet": "ma.MaskedArray.any(axis=None, keepdims=<no value>)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `keepdims`.", "question_id": 956},
{"snippet": "ma.MaskedArray.any(out=None, keepdims=<no value>)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`, `keepdims`.", "question_id": 957},
{"snippet": "ma.MaskedArray.any(axis=None, out=None, keepdims=<no value>)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `out`, `keepdims`.", "question_id": 958},
{"snippet": "testing.assert_array_almost_equal(x, y)", "intent": "Raises an AssertionError if two objects are not equal up to desired precision . With arguments `x`, `y`.", "question_id": 959},
{"snippet": "testing.assert_array_almost_equal(x, y, decimal=6)", "intent": "Raises an AssertionError if two objects are not equal up to desired precision . With arguments `x`, `y`, `decimal`.", "question_id": 960},
{"snippet": "testing.assert_array_almost_equal(x, y, err_msg='')", "intent": "Raises an AssertionError if two objects are not equal up to desired precision . With arguments `x`, `y`, `err_msg`.", "question_id": 961},
{"snippet": "testing.assert_array_almost_equal(x, y, verbose=True)", "intent": "Raises an AssertionError if two objects are not equal up to desired precision . With arguments `x`, `y`, `verbose`.", "question_id": 962},
{"snippet": "testing.assert_array_almost_equal(x, y, decimal=6, err_msg='')", "intent": "Raises an AssertionError if two objects are not equal up to desired precision . With arguments `x`, `y`, `decimal`, `err_msg`.", "question_id": 963},
{"snippet": "testing.assert_array_almost_equal(x, y, decimal=6, verbose=True)", "intent": "Raises an AssertionError if two objects are not equal up to desired precision . With arguments `x`, `y`, `decimal`, `verbose`.", "question_id": 964},
{"snippet": "testing.assert_array_almost_equal(x, y, err_msg='', verbose=True)", "intent": "Raises an AssertionError if two objects are not equal up to desired precision . With arguments `x`, `y`, `err_msg`, `verbose`.", "question_id": 965},
{"snippet": "testing.assert_array_almost_equal(x, y, decimal=6, err_msg='', verbose=True)", "intent": "Raises an AssertionError if two objects are not equal up to desired precision . With arguments `x`, `y`, `decimal`, `err_msg`, `verbose`.", "question_id": 966},
{"snippet": "ma.MaskedArray.view()", "intent": "Return a view of the MaskedArray data .", "question_id": 967},
{"snippet": "ma.MaskedArray.view(dtype=None)", "intent": "Return a view of the MaskedArray data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . )", "question_id": 968},
{"snippet": "ma.MaskedArray.view(type=None)", "intent": "Return a view of the MaskedArray data . With arguments `type`.", "question_id": 969},
{"snippet": "ma.MaskedArray.view(fill_value=None)", "intent": "Return a view of the MaskedArray data . If `fill_value` is not specified , but dtype is specified ( and is not an ndarray sub-class ) , the fill_value of the MaskedArray will be reset .", "question_id": 970},
{"snippet": "ma.MaskedArray.view(dtype=None, type=None)", "intent": "Return a view of the MaskedArray data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) With arguments `type`.", "question_id": 971},
{"snippet": "ma.MaskedArray.view(dtype=None, fill_value=None)", "intent": "Return a view of the MaskedArray data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) If `fill_value` is not specified , but dtype is specified ( and is not an ndarray sub-class ) , the fill_value of the MaskedArray will be reset .", "question_id": 972},
{"snippet": "ma.MaskedArray.view(type=None, fill_value=None)", "intent": "Return a view of the MaskedArray data . If `fill_value` is not specified , but dtype is specified ( and is not an ndarray sub-class ) , the fill_value of the MaskedArray will be reset . With arguments `type`.", "question_id": 973},
{"snippet": "ma.MaskedArray.view(dtype=None, type=None, fill_value=None)", "intent": "Return a view of the MaskedArray data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) If `fill_value` is not specified , but dtype is specified ( and is not an ndarray sub-class ) , the fill_value of the MaskedArray will be reset . With arguments `type`.", "question_id": 974},
{"snippet": "ma.masked_array.ptp()", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e .", "question_id": 975},
{"snippet": "ma.masked_array.ptp(axis=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `axis`.", "question_id": 976},
{"snippet": "ma.masked_array.ptp(out=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `out`.", "question_id": 977},
{"snippet": "ma.masked_array.ptp(fill_value=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `fill_value`.", "question_id": 978},
{"snippet": "ma.masked_array.ptp(keepdims=False)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `keepdims`.", "question_id": 979},
{"snippet": "ma.masked_array.ptp(axis=None, out=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `axis`, `out`.", "question_id": 980},
{"snippet": "ma.masked_array.ptp(axis=None, fill_value=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `axis`, `fill_value`.", "question_id": 981},
{"snippet": "ma.masked_array.ptp(axis=None, keepdims=False)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `axis`, `keepdims`.", "question_id": 982},
{"snippet": "ma.masked_array.ptp(out=None, fill_value=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `out`, `fill_value`.", "question_id": 983},
{"snippet": "ma.masked_array.ptp(out=None, keepdims=False)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `out`, `keepdims`.", "question_id": 984},
{"snippet": "vectorize.__call__(*args, **kwargs)", "intent": "Return arrays with the results of pyfunc broadcast ( vectorized ) over args and kwargs not in excluded . With arguments `*args`, `**kwargs`.", "question_id": 985},
{"snippet": "polynomial.hermite_e.hermediv(c1, c2)", "intent": "Divide one Hermite series by another . Returns the quotient-with-remainder of two Hermite series `c1` / `c2` .", "question_id": 986},
{"snippet": "ma.MaskedArray.var()", "intent": "Compute the variance along the specified `axis` .", "question_id": 987},
{"snippet": "ma.MaskedArray.var(axis=None)", "intent": "Compute the variance along the specified `axis` .", "question_id": 988},
{"snippet": "ma.MaskedArray.var(dtype=None)", "intent": "Compute the variance along the specified `axis` . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue .", "question_id": 989},
{"snippet": "ma.MaskedArray.var(out=None)", "intent": "Compute the variance along the specified `axis` . With arguments `out`.", "question_id": 990},
{"snippet": "ma.MaskedArray.var(ddof=0)", "intent": "Compute the variance along the specified `axis` . If , however , `ddof` is specified , the divisor N - ddof is used instead .", "question_id": 991},
{"snippet": "ma.MaskedArray.var(keepdims=<no value>)", "intent": "Compute the variance along the specified `axis` . With arguments `keepdims`.", "question_id": 992},
{"snippet": "ma.MaskedArray.var(axis=None, dtype=None)", "intent": "Compute the variance along the specified `axis` . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue .", "question_id": 993},
{"snippet": "ma.MaskedArray.var(axis=None, out=None)", "intent": "Compute the variance along the specified `axis` . With arguments `out`.", "question_id": 994},
{"snippet": "ma.MaskedArray.var(axis=None, ddof=0)", "intent": "Compute the variance along the specified `axis` . If , however , `ddof` is specified , the divisor N - ddof is used instead .", "question_id": 995},
{"snippet": "ma.MaskedArray.var(axis=None, keepdims=<no value>)", "intent": "Compute the variance along the specified `axis` . With arguments `keepdims`.", "question_id": 996},
{"snippet": "random.Generator.geometric(p)", "intent": "Draw samples from the geometric distribution . where `p` is the probability of success of an individual trial .", "question_id": 997},
{"snippet": "random.Generator.geometric(p, size=None)", "intent": "Draw samples from the geometric distribution . where `p` is the probability of success of an individual trial . With arguments `size`.", "question_id": 998},
{"snippet": "random.RandomState.standard_gamma(shape)", "intent": "Draw samples from a standard Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and scale=1 .", "question_id": 999},
{"snippet": "random.RandomState.standard_gamma(shape, size=None)", "intent": "Draw samples from a standard Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and scale=1 . With arguments `size`.", "question_id": 1000},
{"snippet": "ma.clump_unmasked(a)", "intent": "Return list of slices corresponding to the unmasked clumps of `a` 1-D array .", "question_id": 1001},
{"snippet": "recarray.std()", "intent": "Returns the standard deviation of the array elements along given `axis` .", "question_id": 1002},
{"snippet": "recarray.std(axis=None)", "intent": "Returns the standard deviation of the array elements along given `axis` .", "question_id": 1003},
{"snippet": "recarray.std(dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`.", "question_id": 1004},
{"snippet": "recarray.std(out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`.", "question_id": 1005},
{"snippet": "recarray.std(ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`.", "question_id": 1006},
{"snippet": "recarray.std(keepdims=False)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `keepdims`.", "question_id": 1007},
{"snippet": "recarray.std(where=True)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `where`.", "question_id": 1008},
{"snippet": "recarray.std(axis=None, dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`.", "question_id": 1009},
{"snippet": "recarray.std(axis=None, out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`.", "question_id": 1010},
{"snippet": "recarray.std(axis=None, ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`.", "question_id": 1011},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_ahead(names)", "intent": "Return list of features in \u2018 `names` \u2019 after remove any implied features and keep the origins .", "question_id": 1012},
{"snippet": "matrix.tolist()", "intent": "Return the matrix as a ( possibly nested ) list .", "question_id": 1013},
{"snippet": "testing.dec.slow(t)", "intent": "Label a test as \u2018 slow \u2019 . With arguments `t`.", "question_id": 1014},
{"snippet": "numpy.frombuffer(buffer)", "intent": "Interpret a `buffer` as a 1-dimensional array .", "question_id": 1015},
{"snippet": "numpy.frombuffer(buffer, dtype=float)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `dtype`.", "question_id": 1016},
{"snippet": "numpy.frombuffer(buffer, count=- 1)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `count`.", "question_id": 1017},
{"snippet": "numpy.frombuffer(buffer, offset=0)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `offset`.", "question_id": 1018},
{"snippet": "numpy.frombuffer(buffer, like=None)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `like`.", "question_id": 1019},
{"snippet": "numpy.frombuffer(buffer, dtype=float, count=- 1)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `dtype`, `count`.", "question_id": 1020},
{"snippet": "numpy.frombuffer(buffer, dtype=float, offset=0)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `dtype`, `offset`.", "question_id": 1021},
{"snippet": "numpy.frombuffer(buffer, dtype=float, like=None)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `dtype`, `like`.", "question_id": 1022},
{"snippet": "numpy.frombuffer(buffer, count=- 1, offset=0)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `count`, `offset`.", "question_id": 1023},
{"snippet": "numpy.frombuffer(buffer, count=- 1, like=None)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `count`, `like`.", "question_id": 1024},
{"snippet": "random.binomial(n, p)", "intent": "Draw samples from a binomial distribution . Samples are drawn from a binomial distribution with specified parameters , `n` trials and `p` probability of success where n an integer > = 0 and p is in the interval [ 0,1 ] .", "question_id": 1025},
{"snippet": "random.binomial(n, p, size=None)", "intent": "Draw samples from a binomial distribution . Samples are drawn from a binomial distribution with specified parameters , `n` trials and `p` probability of success where n an integer > = 0 and p is in the interval [ 0,1 ] . With arguments `size`.", "question_id": 1026},
{"snippet": "numpy.quantile(a, q)", "intent": "Compute the q-th quantile of the data along the specified `axis` . Given `a` vector V of length N , the q-th quantile of V is the value `q` of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the quantile if the normalized ranking does not match the location of q exactly .", "question_id": 1027},
{"snippet": "numpy.quantile(a, q, axis=None)", "intent": "Compute the q-th quantile of the data along the specified `axis` . Given `a` vector V of length N , the q-th quantile of V is the value `q` of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the quantile if the normalized ranking does not match the location of q exactly .", "question_id": 1028},
{"snippet": "numpy.quantile(a, q, out=None)", "intent": "Compute the q-th quantile of the data along the specified `axis` . Given `a` vector V of length N , the q-th quantile of V is the value `q` of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the quantile if the normalized ranking does not match the location of q exactly . With arguments `out`.", "question_id": 1029},
{"snippet": "numpy.quantile(a, q, overwrite_input=False)", "intent": "Compute the q-th quantile of the data along the specified `axis` . Given `a` vector V of length N , the q-th quantile of V is the value `q` of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the quantile if the normalized ranking does not match the location of q exactly . With arguments `overwrite_input`.", "question_id": 1030},
{"snippet": "numpy.quantile(a, q, interpolation='linear')", "intent": "Compute the q-th quantile of the data along the specified `axis` . Given `a` vector V of length N , the q-th quantile of V is the value `q` of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the quantile if the normalized ranking does not match the location of q exactly .", "question_id": 1031},
{"snippet": "numpy.quantile(a, q, keepdims=False)", "intent": "Compute the q-th quantile of the data along the specified `axis` . Given `a` vector V of length N , the q-th quantile of V is the value `q` of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the quantile if the normalized ranking does not match the location of q exactly . With arguments `keepdims`.", "question_id": 1032},
{"snippet": "numpy.quantile(a, q, axis=None, out=None)", "intent": "Compute the q-th quantile of the data along the specified `axis` . Given `a` vector V of length N , the q-th quantile of V is the value `q` of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the quantile if the normalized ranking does not match the location of q exactly . With arguments `out`.", "question_id": 1033},
{"snippet": "numpy.quantile(a, q, axis=None, overwrite_input=False)", "intent": "Compute the q-th quantile of the data along the specified `axis` . Given `a` vector V of length N , the q-th quantile of V is the value `q` of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the quantile if the normalized ranking does not match the location of q exactly . With arguments `overwrite_input`.", "question_id": 1034},
{"snippet": "numpy.quantile(a, q, axis=None, interpolation='linear')", "intent": "Compute the q-th quantile of the data along the specified `axis` . Given `a` vector V of length N , the q-th quantile of V is the value `q` of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the quantile if the normalized ranking does not match the location of q exactly .", "question_id": 1035},
{"snippet": "numpy.quantile(a, q, axis=None, keepdims=False)", "intent": "Compute the q-th quantile of the data along the specified `axis` . Given `a` vector V of length N , the q-th quantile of V is the value `q` of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the quantile if the normalized ranking does not match the location of q exactly . With arguments `keepdims`.", "question_id": 1036},
{"snippet": "numpy.vander(x)", "intent": "Generate a Vandermonde matrix . With arguments `x`.", "question_id": 1037},
{"snippet": "numpy.vander(x, N=None)", "intent": "Generate a Vandermonde matrix . Specifically , when increasing is False , the i-th output column is the input vector raised element-wise to the power of `N` - i - 1 . With arguments `x`.", "question_id": 1038},
{"snippet": "numpy.vander(x, increasing=False)", "intent": "Generate a Vandermonde matrix . The order of the powers is determined by the `increasing` boolean argument . With arguments `x`.", "question_id": 1039},
{"snippet": "numpy.vander(x, N=None, increasing=False)", "intent": "Generate a Vandermonde matrix . Specifically , when increasing is False , the i-th output column is the input vector raised element-wise to the power of `N` - i - 1 . The order of the powers is determined by the `increasing` boolean argument . With arguments `x`.", "question_id": 1040},
{"snippet": "polynomial.laguerre.Laguerre.cutdeg(deg)", "intent": "Truncate series to the given degree . Reduce the degree of the series to `deg` by discarding the high order terms .", "question_id": 1041},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.dist_log(*args)", "intent": "Print a console message With arguments `*args`.", "question_id": 1042},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.dist_log(*args, stderr=False)", "intent": "Print a console message With arguments `*args`, `stderr`.", "question_id": 1043},
{"snippet": "ma.MaskType.tofile()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 1044},
{"snippet": "ndarray.setfield(val, dtype)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field .", "question_id": 1045},
{"snippet": "ndarray.setfield(val, dtype, offset=0)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field .", "question_id": 1046},
{"snippet": "ndarray.itemsize", "intent": "Length of one array element in bytes.", "question_id": 1047},
{"snippet": "recarray.imag", "intent": "The imaginary part of the array.", "question_id": 1048},
{"snippet": "char.chararray.trace()", "intent": "Return the sum along diagonals of the array .", "question_id": 1049},
{"snippet": "char.chararray.trace(offset=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`.", "question_id": 1050},
{"snippet": "char.chararray.trace(axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `axis1`.", "question_id": 1051},
{"snippet": "char.chararray.trace(axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `axis2`.", "question_id": 1052},
{"snippet": "char.chararray.trace(dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `dtype`.", "question_id": 1053},
{"snippet": "char.chararray.trace(out=None)", "intent": "Return the sum along diagonals of the array . With arguments `out`.", "question_id": 1054},
{"snippet": "char.chararray.trace(offset=0, axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis1`.", "question_id": 1055},
{"snippet": "char.chararray.trace(offset=0, axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis2`.", "question_id": 1056},
{"snippet": "char.chararray.trace(offset=0, dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `dtype`.", "question_id": 1057},
{"snippet": "char.chararray.trace(offset=0, out=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `out`.", "question_id": 1058},
{"snippet": "numpy.broadcast_arrays(*args)", "intent": "Broadcast any number of arrays against each other . With arguments `*args`.", "question_id": 1059},
{"snippet": "numpy.broadcast_arrays(*args, subok=False)", "intent": "Broadcast any number of arrays against each other . With arguments `*args`, `subok`.", "question_id": 1060},
{"snippet": "char.chararray.title()", "intent": "For each element in self , return a titlecased version of the string : words start with uppercase characters , all remaining cased characters are lowercase .", "question_id": 1061},
{"snippet": "record.ravel()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 1062},
{"snippet": "ma.outer(a, b)", "intent": "Compute the outer product of two vectors . Given two vectors , `a` = [ a0 , a1 , ... , aM ] and `b` = [ b0 , b1 , ... , bN ] , the outer product [ 1 ] is :", "question_id": 1063},
{"snippet": "polynomial.polynomial.Polynomial.deriv()", "intent": "Differentiate .", "question_id": 1064},
{"snippet": "polynomial.polynomial.Polynomial.deriv(m=1)", "intent": "Differentiate . With arguments `m`.", "question_id": 1065},
{"snippet": "random.RandomState.gumbel()", "intent": "Draw samples from a Gumbel distribution .", "question_id": 1066},
{"snippet": "random.RandomState.gumbel(loc=0.0)", "intent": "Draw samples from a Gumbel distribution . With arguments `loc`.", "question_id": 1067},
{"snippet": "random.RandomState.gumbel(scale=1.0)", "intent": "Draw samples from a Gumbel distribution . Draw samples from a Gumbel distribution with specified location and `scale` .", "question_id": 1068},
{"snippet": "random.RandomState.gumbel(size=None)", "intent": "Draw samples from a Gumbel distribution . With arguments `size`.", "question_id": 1069},
{"snippet": "random.RandomState.gumbel(loc=0.0, scale=1.0)", "intent": "Draw samples from a Gumbel distribution . Draw samples from a Gumbel distribution with specified location and `scale` . With arguments `loc`.", "question_id": 1070},
{"snippet": "random.RandomState.gumbel(loc=0.0, size=None)", "intent": "Draw samples from a Gumbel distribution . With arguments `loc`, `size`.", "question_id": 1071},
{"snippet": "random.RandomState.gumbel(scale=1.0, size=None)", "intent": "Draw samples from a Gumbel distribution . Draw samples from a Gumbel distribution with specified location and `scale` . With arguments `size`.", "question_id": 1072},
{"snippet": "random.RandomState.gumbel(loc=0.0, scale=1.0, size=None)", "intent": "Draw samples from a Gumbel distribution . Draw samples from a Gumbel distribution with specified location and `scale` . With arguments `loc`, `size`.", "question_id": 1073},
{"snippet": "busdaycalendar.weekmask", "intent": "A copy of the seven-element boolean mask indicating valid days.", "question_id": 1074},
{"snippet": "numpy.load(file)", "intent": "Load arrays or pickled objects from .npy , .npz or pickled files . With arguments `file`.", "question_id": 1075},
{"snippet": "numpy.load(file, mmap_mode=None)", "intent": "Load arrays or pickled objects from .npy , .npz or pickled files . With arguments `file`, `mmap_mode`.", "question_id": 1076},
{"snippet": "numpy.load(file, allow_pickle=False)", "intent": "Load arrays or pickled objects from .npy , .npz or pickled files . With arguments `file`, `allow_pickle`.", "question_id": 1077},
{"snippet": "numpy.load(file, fix_imports=True)", "intent": "Load arrays or pickled objects from .npy , .npz or pickled files . With arguments `file`, `fix_imports`.", "question_id": 1078},
{"snippet": "numpy.load(file, encoding='ASCII')", "intent": "Load arrays or pickled objects from .npy , .npz or pickled files . With arguments `file`, `encoding`.", "question_id": 1079},
{"snippet": "numpy.load(file, mmap_mode=None, allow_pickle=False)", "intent": "Load arrays or pickled objects from .npy , .npz or pickled files . With arguments `file`, `mmap_mode`, `allow_pickle`.", "question_id": 1080},
{"snippet": "numpy.load(file, mmap_mode=None, fix_imports=True)", "intent": "Load arrays or pickled objects from .npy , .npz or pickled files . With arguments `file`, `mmap_mode`, `fix_imports`.", "question_id": 1081},
{"snippet": "numpy.load(file, mmap_mode=None, encoding='ASCII')", "intent": "Load arrays or pickled objects from .npy , .npz or pickled files . With arguments `file`, `mmap_mode`, `encoding`.", "question_id": 1082},
{"snippet": "numpy.load(file, allow_pickle=False, fix_imports=True)", "intent": "Load arrays or pickled objects from .npy , .npz or pickled files . With arguments `file`, `allow_pickle`, `fix_imports`.", "question_id": 1083},
{"snippet": "numpy.load(file, allow_pickle=False, encoding='ASCII')", "intent": "Load arrays or pickled objects from .npy , .npz or pickled files . With arguments `file`, `allow_pickle`, `encoding`.", "question_id": 1084},
{"snippet": "testing.decorate_methods(cls, decorator)", "intent": "Apply a `decorator` to all methods in a class matching a regular expression . The given decorator is applied to all public methods of `cls` that are matched by the regular expression `testmatch` ( testmatch.search ( methodname ) ) .", "question_id": 1085},
{"snippet": "testing.decorate_methods(cls, decorator, testmatch=None)", "intent": "Apply a `decorator` to all methods in a class matching a regular expression . The given decorator is applied to all public methods of `cls` that are matched by the regular expression `testmatch` ( testmatch.search ( methodname ) ) .", "question_id": 1086},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_c_preprocessor(feature_name)", "intent": "Generate C preprocessor definitions and include headers of a CPU feature . With arguments `feature_name`.", "question_id": 1087},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_c_preprocessor(feature_name, tabs=0)", "intent": "Generate C preprocessor definitions and include headers of a CPU feature . With arguments `feature_name`, `tabs`.", "question_id": 1088},
{"snippet": "matlib.identity(n)", "intent": "Returns the square identity matrix of given size . With arguments `n`.", "question_id": 1089},
{"snippet": "matlib.identity(n, dtype=None)", "intent": "Returns the square identity matrix of given size . With arguments `n`, `dtype`.", "question_id": 1090},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.dist_info()", "intent": "Return a tuple containing info about ( platform , compiler , extra_args ) , required by the abstract class \u2018 _CCompiler \u2019 for discovering the platform environment .", "question_id": 1091},
{"snippet": "memmap.copy()", "intent": "Return a copy of the array .", "question_id": 1092},
{"snippet": "memmap.copy(order='C')", "intent": "Return a copy of the array . The function numpy.copy is similar , but it defaults to using `order` \u2018 K \u2019 , and will not pass sub-classes through by default .", "question_id": 1093},
{"snippet": "numpy.average(a)", "intent": "Compute the weighted average along the specified `axis` . With arguments `a`.", "question_id": 1094},
{"snippet": "numpy.average(a, axis=None)", "intent": "Compute the weighted average along the specified `axis` . With arguments `a`.", "question_id": 1095},
{"snippet": "numpy.average(a, weights=None)", "intent": "Compute the weighted average along the specified `axis` . With arguments `a`, `weights`.", "question_id": 1096},
{"snippet": "numpy.average(a, returned=False)", "intent": "Compute the weighted average along the specified `axis` . With arguments `a`, `returned`.", "question_id": 1097},
{"snippet": "numpy.average(a, axis=None, weights=None)", "intent": "Compute the weighted average along the specified `axis` . With arguments `a`, `weights`.", "question_id": 1098},
{"snippet": "numpy.average(a, axis=None, returned=False)", "intent": "Compute the weighted average along the specified `axis` . With arguments `a`, `returned`.", "question_id": 1099},
{"snippet": "numpy.average(a, weights=None, returned=False)", "intent": "Compute the weighted average along the specified `axis` . With arguments `a`, `weights`, `returned`.", "question_id": 1100},
{"snippet": "numpy.average(a, axis=None, weights=None, returned=False)", "intent": "Compute the weighted average along the specified `axis` . With arguments `a`, `weights`, `returned`.", "question_id": 1101},
{"snippet": "random.noncentral_chisquare(df, nonc)", "intent": "Draw samples from a noncentral chi-square distribution . With arguments `df`, `nonc`.", "question_id": 1102},
{"snippet": "random.noncentral_chisquare(df, nonc, size=None)", "intent": "Draw samples from a noncentral chi-square distribution . With arguments `df`, `nonc`, `size`.", "question_id": 1103},
{"snippet": "ma.compressed(x)", "intent": "Return all the non-masked data as a 1-D array . With arguments `x`.", "question_id": 1104},
{"snippet": "nditer.close()", "intent": "Resolve all writeback semantics in writeable operands .", "question_id": 1105},
{"snippet": "ndarray.dot(b)", "intent": "Dot product of two arrays . With arguments `b`.", "question_id": 1106},
{"snippet": "ndarray.dot(b, out=None)", "intent": "Dot product of two arrays . With arguments `b`, `out`.", "question_id": 1107},
{"snippet": "ma.vander(x)", "intent": "Generate a Vandermonde matrix . With arguments `x`.", "question_id": 1108},
{"snippet": "ma.vander(x, n=None)", "intent": "Generate a Vandermonde matrix . With arguments `x`, `n`.", "question_id": 1109},
{"snippet": "memmap.dumps()", "intent": "Returns the pickle of the array as a string .", "question_id": 1110},
{"snippet": "numpy.RankWarning", "intent": "Issued by polyfit when the Vandermonde matrix is rank deficient.", "question_id": 1111},
{"snippet": "ma.masked_array.diagonal()", "intent": "Return specified diagonals .", "question_id": 1112},
{"snippet": "ma.masked_array.diagonal(offset=0)", "intent": "Return specified diagonals . With arguments `offset`.", "question_id": 1113},
{"snippet": "ma.masked_array.diagonal(axis1=0)", "intent": "Return specified diagonals . With arguments `axis1`.", "question_id": 1114},
{"snippet": "ma.masked_array.diagonal(axis2=1)", "intent": "Return specified diagonals . With arguments `axis2`.", "question_id": 1115},
{"snippet": "ma.masked_array.diagonal(offset=0, axis1=0)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`.", "question_id": 1116},
{"snippet": "ma.masked_array.diagonal(offset=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis2`.", "question_id": 1117},
{"snippet": "ma.masked_array.diagonal(axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `axis1`, `axis2`.", "question_id": 1118},
{"snippet": "ma.masked_array.diagonal(offset=0, axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`, `axis2`.", "question_id": 1119},
{"snippet": "polynomial.legendre.Legendre.has_samedomain(other)", "intent": "Check if domains match . With arguments `other`.", "question_id": 1120},
{"snippet": "record.min()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 1121},
{"snippet": "generic.itemsize", "intent": "The length of one element in bytes.", "question_id": 1122},
{"snippet": "numpy.polynomial.laguerre.Laguerre(coef)", "intent": "A Laguerre series class . With arguments `coef`.", "question_id": 1123},
{"snippet": "numpy.polynomial.laguerre.Laguerre(coef, domain=None)", "intent": "A Laguerre series class . With arguments `coef`, `domain`.", "question_id": 1124},
{"snippet": "numpy.polynomial.laguerre.Laguerre(coef, window=None)", "intent": "A Laguerre series class . With arguments `coef`, `window`.", "question_id": 1125},
{"snippet": "numpy.polynomial.laguerre.Laguerre(coef, domain=None, window=None)", "intent": "A Laguerre series class . With arguments `coef`, `domain`, `window`.", "question_id": 1126},
{"snippet": "memmap.partition(kth)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array .", "question_id": 1127},
{"snippet": "memmap.partition(kth, axis=- 1)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`.", "question_id": 1128},
{"snippet": "memmap.partition(kth, kind='introselect')", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `kind`.", "question_id": 1129},
{"snippet": "memmap.partition(kth, order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `order`.", "question_id": 1130},
{"snippet": "memmap.partition(kth, axis=- 1, kind='introselect')", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `kind`.", "question_id": 1131},
{"snippet": "memmap.partition(kth, axis=- 1, order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `order`.", "question_id": 1132},
{"snippet": "memmap.partition(kth, kind='introselect', order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `kind`, `order`.", "question_id": 1133},
{"snippet": "memmap.partition(kth, axis=- 1, kind='introselect', order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `kind`, `order`.", "question_id": 1134},
{"snippet": "record.round()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 1135},
{"snippet": "ma.MaskedArray.sum()", "intent": "Return the sum of the array elements over the given `axis` .", "question_id": 1136},
{"snippet": "ma.MaskedArray.sum(axis=None)", "intent": "Return the sum of the array elements over the given `axis` .", "question_id": 1137},
{"snippet": "ma.MaskedArray.sum(dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 1138},
{"snippet": "ma.MaskedArray.sum(out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`.", "question_id": 1139},
{"snippet": "ma.MaskedArray.sum(keepdims=<no value>)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`.", "question_id": 1140},
{"snippet": "ma.MaskedArray.sum(axis=None, dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 1141},
{"snippet": "ma.MaskedArray.sum(axis=None, out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`.", "question_id": 1142},
{"snippet": "ma.MaskedArray.sum(axis=None, keepdims=<no value>)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`.", "question_id": 1143},
{"snippet": "ma.MaskedArray.sum(dtype=None, out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`, `out`.", "question_id": 1144},
{"snippet": "ma.MaskedArray.sum(dtype=None, keepdims=<no value>)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`, `keepdims`.", "question_id": 1145},
{"snippet": "record.getfield()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 1146},
{"snippet": "numpy.get_printoptions()", "intent": "Return the current print options .", "question_id": 1147},
{"snippet": "polynomial.chebyshev.Chebyshev.deriv()", "intent": "Differentiate .", "question_id": 1148},
{"snippet": "polynomial.chebyshev.Chebyshev.deriv(m=1)", "intent": "Differentiate . With arguments `m`.", "question_id": 1149},
{"snippet": "numpy.polydiv(u, v)", "intent": "Returns the quotient and remainder of polynomial division . Both `u` and `v` must be 0-d or 1-d ( ndim = 0 or 1 ) , but u.ndim need not equal v.ndim .", "question_id": 1150},
{"snippet": "polynomial.legendre.leggauss(deg)", "intent": "Gauss-Legendre quadrature . These sample points and weights will correctly integrate polynomials of degree \\ ( 2 * `deg` - 1\\ ) or less over the interval \\ ( [ -1 , 1 ] \\ ) with the weight function \\ ( f ( x ) = 1\\ ) .", "question_id": 1151},
{"snippet": "chararray.repeat(repeats)", "intent": "Repeat elements of an array . With arguments `repeats`.", "question_id": 1152},
{"snippet": "chararray.repeat(repeats, axis=None)", "intent": "Repeat elements of an array . With arguments `repeats`, `axis`.", "question_id": 1153},
{"snippet": "numpy.argpartition(a, kth)", "intent": "Perform an indirect partition along the given `axis` using the algorithm specified by the `kind` keyword . It returns an array of indices of the same shape as `a` that index data along the given axis in partitioned `order` . With arguments `kth`.", "question_id": 1154},
{"snippet": "numpy.argpartition(a, kth, axis=- 1)", "intent": "Perform an indirect partition along the given `axis` using the algorithm specified by the `kind` keyword . It returns an array of indices of the same shape as `a` that index data along the given axis in partitioned `order` . With arguments `kth`.", "question_id": 1155},
{"snippet": "numpy.argpartition(a, kth, kind='introselect')", "intent": "Perform an indirect partition along the given `axis` using the algorithm specified by the `kind` keyword . It returns an array of indices of the same shape as `a` that index data along the given axis in partitioned `order` . With arguments `kth`.", "question_id": 1156},
{"snippet": "numpy.argpartition(a, kth, order=None)", "intent": "Perform an indirect partition along the given `axis` using the algorithm specified by the `kind` keyword . It returns an array of indices of the same shape as `a` that index data along the given axis in partitioned `order` . With arguments `kth`.", "question_id": 1157},
{"snippet": "numpy.argpartition(a, kth, axis=- 1, kind='introselect')", "intent": "Perform an indirect partition along the given `axis` using the algorithm specified by the `kind` keyword . It returns an array of indices of the same shape as `a` that index data along the given axis in partitioned `order` . With arguments `kth`.", "question_id": 1158},
{"snippet": "numpy.argpartition(a, kth, axis=- 1, order=None)", "intent": "Perform an indirect partition along the given `axis` using the algorithm specified by the `kind` keyword . It returns an array of indices of the same shape as `a` that index data along the given axis in partitioned `order` . With arguments `kth`.", "question_id": 1159},
{"snippet": "numpy.argpartition(a, kth, kind='introselect', order=None)", "intent": "Perform an indirect partition along the given `axis` using the algorithm specified by the `kind` keyword . It returns an array of indices of the same shape as `a` that index data along the given axis in partitioned `order` . With arguments `kth`.", "question_id": 1160},
{"snippet": "numpy.argpartition(a, kth, axis=- 1, kind='introselect', order=None)", "intent": "Perform an indirect partition along the given `axis` using the algorithm specified by the `kind` keyword . It returns an array of indices of the same shape as `a` that index data along the given axis in partitioned `order` . With arguments `kth`.", "question_id": 1161},
{"snippet": "ma.MaskedArray.__str__()", "intent": "Return str ( self ) .", "question_id": 1162},
{"snippet": "polynomial.hermite_e.HermiteE.has_samecoef(other)", "intent": "Check if coefficients match . With arguments `other`.", "question_id": 1163},
{"snippet": "fft.fftn(a)", "intent": "Compute the N-dimensional discrete Fourier Transform . With arguments `a`.", "question_id": 1164},
{"snippet": "fft.fftn(a, s=None)", "intent": "Compute the N-dimensional discrete Fourier Transform . With arguments `a`, `s`.", "question_id": 1165},
{"snippet": "fft.fftn(a, axes=None)", "intent": "Compute the N-dimensional discrete Fourier Transform . This function computes the N-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `a`.", "question_id": 1166},
{"snippet": "fft.fftn(a, norm=None)", "intent": "Compute the N-dimensional discrete Fourier Transform . With arguments `a`, `norm`.", "question_id": 1167},
{"snippet": "fft.fftn(a, s=None, axes=None)", "intent": "Compute the N-dimensional discrete Fourier Transform . This function computes the N-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `a`, `s`.", "question_id": 1168},
{"snippet": "fft.fftn(a, s=None, norm=None)", "intent": "Compute the N-dimensional discrete Fourier Transform . With arguments `a`, `s`, `norm`.", "question_id": 1169},
{"snippet": "fft.fftn(a, axes=None, norm=None)", "intent": "Compute the N-dimensional discrete Fourier Transform . This function computes the N-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `a`, `norm`.", "question_id": 1170},
{"snippet": "fft.fftn(a, s=None, axes=None, norm=None)", "intent": "Compute the N-dimensional discrete Fourier Transform . This function computes the N-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `a`, `s`, `norm`.", "question_id": 1171},
{"snippet": "random.RandomState.multinomial(n, pvals)", "intent": "Draw samples from a multinomial distribution . Each sample drawn from the distribution represents `n` such experiments . With arguments `pvals`.", "question_id": 1172},
{"snippet": "random.RandomState.multinomial(n, pvals, size=None)", "intent": "Draw samples from a multinomial distribution . Each sample drawn from the distribution represents `n` such experiments . With arguments `pvals`, `size`.", "question_id": 1173},
{"snippet": "random.Generator.zipf(a)", "intent": "Draw samples from `a` Zipf distribution .", "question_id": 1174},
{"snippet": "random.Generator.zipf(a, size=None)", "intent": "Draw samples from `a` Zipf distribution . With arguments `size`.", "question_id": 1175},
{"snippet": "numpy.datetime_data(dtype, /)", "intent": "Get information about the step size of a date or time type . With arguments `dtype`, `/`.", "question_id": 1176},
{"snippet": "numpy.atleast_1d(*arys)", "intent": "Convert inputs to arrays with at least one dimension . With arguments `*arys`.", "question_id": 1177},
{"snippet": "char.swapcase(a)", "intent": "Return element-wise `a` copy of the string with uppercase characters converted to lowercase and vice versa .", "question_id": 1178},
{"snippet": "char.chararray.itemset(*args)", "intent": "Insert scalar into an array ( scalar is cast to array \u2019 s dtype , if possible ) With arguments `*args`.", "question_id": 1179},
{"snippet": "ndarray.fill(value)", "intent": "Fill the array with a scalar `value` .", "question_id": 1180},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.dist_test(source, flags)", "intent": "Return True if \u2018 CCompiler.compile ( ) \u2019 able to compile a `source` file with certain `flags` .", "question_id": 1181},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.dist_test(source, flags, macros=)", "intent": "Return True if \u2018 CCompiler.compile ( ) \u2019 able to compile a `source` file with certain `flags` . With arguments `macros`.", "question_id": 1182},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.dist_test(source)", "intent": "Return True if \u2018 CCompiler.compile ( ) \u2019 able to compile a `source` file with certain `flags` .", "question_id": 1183},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.dist_test(source, macros=)", "intent": "Return True if \u2018 CCompiler.compile ( ) \u2019 able to compile a `source` file with certain `flags` . With arguments `macros`.", "question_id": 1184},
{"snippet": "polynomial.polynomial.Polynomial.has_samedomain(other)", "intent": "Check if domains match . With arguments `other`.", "question_id": 1185},
{"snippet": "polynomial.hermite_e.hermeroots(c)", "intent": "Compute the roots of a HermiteE series . With arguments `c`.", "question_id": 1186},
{"snippet": "chararray.rstrip()", "intent": "For each element in self , return a copy with the trailing characters removed .", "question_id": 1187},
{"snippet": "chararray.rstrip(chars=None)", "intent": "For each element in self , return a copy with the trailing characters removed . With arguments `chars`.", "question_id": 1188},
{"snippet": "ma.masked_less(x, value)", "intent": "Mask an array where less than a given `value` . This function is a shortcut to masked_where , with condition = ( `x` < value ) .", "question_id": 1189},
{"snippet": "ma.masked_less(x, value, copy=True)", "intent": "Mask an array where less than a given `value` . This function is a shortcut to masked_where , with condition = ( `x` < value ) . With arguments `copy`.", "question_id": 1190},
{"snippet": "record.setfield()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 1191},
{"snippet": "memmap.argsort()", "intent": "Returns the indices that would sort this array .", "question_id": 1192},
{"snippet": "memmap.argsort(axis=- 1)", "intent": "Returns the indices that would sort this array . With arguments `axis`.", "question_id": 1193},
{"snippet": "memmap.argsort(kind=None)", "intent": "Returns the indices that would sort this array . With arguments `kind`.", "question_id": 1194},
{"snippet": "memmap.argsort(order=None)", "intent": "Returns the indices that would sort this array . With arguments `order`.", "question_id": 1195},
{"snippet": "memmap.argsort(axis=- 1, kind=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `kind`.", "question_id": 1196},
{"snippet": "memmap.argsort(axis=- 1, order=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `order`.", "question_id": 1197},
{"snippet": "memmap.argsort(kind=None, order=None)", "intent": "Returns the indices that would sort this array . With arguments `kind`, `order`.", "question_id": 1198},
{"snippet": "memmap.argsort(axis=- 1, kind=None, order=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `kind`, `order`.", "question_id": 1199},
{"snippet": "ma.MaskedArray.byteswap()", "intent": "Swap the bytes of the array elements", "question_id": 1200},
{"snippet": "ma.MaskedArray.byteswap(inplace=False)", "intent": "Swap the bytes of the array elements With arguments `inplace`.", "question_id": 1201},
{"snippet": "polynomial.polynomial.Polynomial.cast(series)", "intent": "Convert `series` to series of this class .", "question_id": 1202},
{"snippet": "polynomial.polynomial.Polynomial.cast(series, domain=None)", "intent": "Convert `series` to series of this class . With arguments `domain`.", "question_id": 1203},
{"snippet": "polynomial.polynomial.Polynomial.cast(series, window=None)", "intent": "Convert `series` to series of this class . With arguments `window`.", "question_id": 1204},
{"snippet": "polynomial.polynomial.Polynomial.cast(series, domain=None, window=None)", "intent": "Convert `series` to series of this class . With arguments `domain`, `window`.", "question_id": 1205},
{"snippet": "char.rindex(a, sub)", "intent": "Like rfind , but raises ValueError when the substring `sub` is not found . With arguments `a`.", "question_id": 1206},
{"snippet": "char.rindex(a, sub, start=0)", "intent": "Like rfind , but raises ValueError when the substring `sub` is not found . With arguments `a`, `start`.", "question_id": 1207},
{"snippet": "char.rindex(a, sub, end=None)", "intent": "Like rfind , but raises ValueError when the substring `sub` is not found . With arguments `a`, `end`.", "question_id": 1208},
{"snippet": "char.rindex(a, sub, start=0, end=None)", "intent": "Like rfind , but raises ValueError when the substring `sub` is not found . With arguments `a`, `start`, `end`.", "question_id": 1209},
{"snippet": "numpy.isin(element, test_elements)", "intent": "Calculates `element` in `test_elements` , broadcasting over element only .", "question_id": 1210},
{"snippet": "numpy.isin(element, test_elements, assume_unique=False)", "intent": "Calculates `element` in `test_elements` , broadcasting over element only . With arguments `assume_unique`.", "question_id": 1211},
{"snippet": "numpy.isin(element, test_elements, invert=False)", "intent": "Calculates `element` in `test_elements` , broadcasting over element only . With arguments `invert`.", "question_id": 1212},
{"snippet": "numpy.isin(element, test_elements, assume_unique=False, invert=False)", "intent": "Calculates `element` in `test_elements` , broadcasting over element only . With arguments `assume_unique`, `invert`.", "question_id": 1213},
{"snippet": "polynomial.hermite_e.hermeweight(x)", "intent": "Weight function of the Hermite_e polynomials . With arguments `x`.", "question_id": 1214},
{"snippet": "chararray.base", "intent": "Base object if memory is from some other object.", "question_id": 1215},
{"snippet": "char.chararray.isalnum()", "intent": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character , false otherwise .", "question_id": 1216},
{"snippet": "matrix.base", "intent": "Base object if memory is from some other object.", "question_id": 1217},
{"snippet": "nditer.debug_print()", "intent": "Print the current state of the nditer instance and debug info to stdout .", "question_id": 1218},
{"snippet": "chararray.argpartition(kth)", "intent": "Returns the indices that would partition this array . With arguments `kth`.", "question_id": 1219},
{"snippet": "chararray.argpartition(kth, axis=- 1)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`.", "question_id": 1220},
{"snippet": "chararray.argpartition(kth, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`.", "question_id": 1221},
{"snippet": "chararray.argpartition(kth, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `order`.", "question_id": 1222},
{"snippet": "chararray.argpartition(kth, axis=- 1, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`.", "question_id": 1223},
{"snippet": "chararray.argpartition(kth, axis=- 1, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `order`.", "question_id": 1224},
{"snippet": "chararray.argpartition(kth, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`, `order`.", "question_id": 1225},
{"snippet": "chararray.argpartition(kth, axis=- 1, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`, `order`.", "question_id": 1226},
{"snippet": "numpy.percentile(a, q)", "intent": "Compute the q-th percentile of the data along the specified `axis` . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly .", "question_id": 1227},
{"snippet": "numpy.percentile(a, q, axis=None)", "intent": "Compute the q-th percentile of the data along the specified `axis` . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly .", "question_id": 1228},
{"snippet": "numpy.percentile(a, q, out=None)", "intent": "Compute the q-th percentile of the data along the specified `axis` . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . With arguments `out`.", "question_id": 1229},
{"snippet": "numpy.percentile(a, q, overwrite_input=False)", "intent": "Compute the q-th percentile of the data along the specified `axis` . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . With arguments `overwrite_input`.", "question_id": 1230},
{"snippet": "numpy.percentile(a, q, interpolation='linear')", "intent": "Compute the q-th percentile of the data along the specified `axis` . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly .", "question_id": 1231},
{"snippet": "numpy.percentile(a, q, keepdims=False)", "intent": "Compute the q-th percentile of the data along the specified `axis` . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . With arguments `keepdims`.", "question_id": 1232},
{"snippet": "numpy.percentile(a, q, axis=None, out=None)", "intent": "Compute the q-th percentile of the data along the specified `axis` . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . With arguments `out`.", "question_id": 1233},
{"snippet": "numpy.percentile(a, q, axis=None, overwrite_input=False)", "intent": "Compute the q-th percentile of the data along the specified `axis` . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . With arguments `overwrite_input`.", "question_id": 1234},
{"snippet": "numpy.percentile(a, q, axis=None, interpolation='linear')", "intent": "Compute the q-th percentile of the data along the specified `axis` . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly .", "question_id": 1235},
{"snippet": "numpy.percentile(a, q, axis=None, keepdims=False)", "intent": "Compute the q-th percentile of the data along the specified `axis` . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . With arguments `keepdims`.", "question_id": 1236},
{"snippet": "numpy.flatiter", "intent": "Flat iterator object to iterate over arrays.", "question_id": 1237},
{"snippet": "testing.Tester.prepare_test_args()", "intent": "Run tests for module using nose .", "question_id": 1238},
{"snippet": "testing.Tester.prepare_test_args(label='fast')", "intent": "Run tests for module using nose . With arguments `label`.", "question_id": 1239},
{"snippet": "testing.Tester.prepare_test_args(verbose=1)", "intent": "Run tests for module using nose . With arguments `verbose`.", "question_id": 1240},
{"snippet": "testing.Tester.prepare_test_args(extra_argv=None)", "intent": "Run tests for module using nose . With arguments `extra_argv`.", "question_id": 1241},
{"snippet": "testing.Tester.prepare_test_args(doctests=False)", "intent": "Run tests for module using nose . With arguments `doctests`.", "question_id": 1242},
{"snippet": "testing.Tester.prepare_test_args(coverage=False)", "intent": "Run tests for module using nose . With arguments `coverage`.", "question_id": 1243},
{"snippet": "testing.Tester.prepare_test_args(timer=False)", "intent": "Run tests for module using nose . With arguments `timer`.", "question_id": 1244},
{"snippet": "testing.Tester.prepare_test_args(label='fast', verbose=1)", "intent": "Run tests for module using nose . With arguments `label`, `verbose`.", "question_id": 1245},
{"snippet": "testing.Tester.prepare_test_args(label='fast', extra_argv=None)", "intent": "Run tests for module using nose . With arguments `label`, `extra_argv`.", "question_id": 1246},
{"snippet": "testing.Tester.prepare_test_args(label='fast', doctests=False)", "intent": "Run tests for module using nose . With arguments `label`, `doctests`.", "question_id": 1247},
{"snippet": "distutils.ccompiler.CCompiler_find_executables(self)", "intent": "Does nothing here , but is called by the get_version method and can be overridden by subclasses . With arguments `self`.", "question_id": 1248},
{"snippet": "ma.compress_rowcols(x)", "intent": "Suppress the rows and/or columns of a 2-D array that contain masked values . With arguments `x`.", "question_id": 1249},
{"snippet": "ma.compress_rowcols(x, axis=None)", "intent": "Suppress the rows and/or columns of a 2-D array that contain masked values . The suppression behavior is selected with the `axis` parameter . With arguments `x`.", "question_id": 1250},
{"snippet": "ma.argsort(a)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `a`.", "question_id": 1251},
{"snippet": "ma.argsort(a, axis=<no value>)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `a`.", "question_id": 1252},
{"snippet": "ma.argsort(a, kind=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `a`, `kind`.", "question_id": 1253},
{"snippet": "ma.argsort(a, order=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `a`, `order`.", "question_id": 1254},
{"snippet": "ma.argsort(a, endwith=True)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `a`, `endwith`.", "question_id": 1255},
{"snippet": "ma.argsort(a, fill_value=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . Masked values are filled beforehand to `fill_value` . With arguments `a`.", "question_id": 1256},
{"snippet": "ma.argsort(a, axis=<no value>, kind=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `a`, `kind`.", "question_id": 1257},
{"snippet": "ma.argsort(a, axis=<no value>, order=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `a`, `order`.", "question_id": 1258},
{"snippet": "ma.argsort(a, axis=<no value>, endwith=True)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `a`, `endwith`.", "question_id": 1259},
{"snippet": "ma.argsort(a, axis=<no value>, fill_value=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . Masked values are filled beforehand to `fill_value` . With arguments `a`.", "question_id": 1260},
{"snippet": "char.chararray.cumprod()", "intent": "Return the cumulative product of the elements along the given `axis` .", "question_id": 1261},
{"snippet": "char.chararray.cumprod(axis=None)", "intent": "Return the cumulative product of the elements along the given `axis` .", "question_id": 1262},
{"snippet": "char.chararray.cumprod(dtype=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`.", "question_id": 1263},
{"snippet": "char.chararray.cumprod(out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `out`.", "question_id": 1264},
{"snippet": "char.chararray.cumprod(axis=None, dtype=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`.", "question_id": 1265},
{"snippet": "char.chararray.cumprod(axis=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `out`.", "question_id": 1266},
{"snippet": "char.chararray.cumprod(dtype=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 1267},
{"snippet": "char.chararray.cumprod(axis=None, dtype=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 1268},
{"snippet": "recarray.sum()", "intent": "Return the sum of the array elements over the given `axis` .", "question_id": 1269},
{"snippet": "recarray.sum(axis=None)", "intent": "Return the sum of the array elements over the given `axis` .", "question_id": 1270},
{"snippet": "recarray.sum(dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 1271},
{"snippet": "recarray.sum(out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`.", "question_id": 1272},
{"snippet": "recarray.sum(keepdims=False)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`.", "question_id": 1273},
{"snippet": "recarray.sum(initial=0)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `initial`.", "question_id": 1274},
{"snippet": "recarray.sum(where=True)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `where`.", "question_id": 1275},
{"snippet": "recarray.sum(axis=None, dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 1276},
{"snippet": "recarray.sum(axis=None, out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`.", "question_id": 1277},
{"snippet": "recarray.sum(axis=None, keepdims=False)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`.", "question_id": 1278},
{"snippet": "ma.MaskedArray.cumprod()", "intent": "Return the cumulative product of the array elements over the given `axis` .", "question_id": 1279},
{"snippet": "ma.MaskedArray.cumprod(axis=None)", "intent": "Return the cumulative product of the array elements over the given `axis` .", "question_id": 1280},
{"snippet": "ma.MaskedArray.cumprod(dtype=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 1281},
{"snippet": "ma.MaskedArray.cumprod(out=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . The mask is lost if `out` is not a valid MaskedArray !", "question_id": 1282},
{"snippet": "ma.MaskedArray.cumprod(axis=None, dtype=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 1283},
{"snippet": "ma.MaskedArray.cumprod(axis=None, out=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . The mask is lost if `out` is not a valid MaskedArray !", "question_id": 1284},
{"snippet": "ma.MaskedArray.cumprod(dtype=None, out=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . The mask is lost if `out` is not a valid MaskedArray ! With arguments `dtype`.", "question_id": 1285},
{"snippet": "ma.MaskedArray.cumprod(axis=None, dtype=None, out=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . The mask is lost if `out` is not a valid MaskedArray ! With arguments `dtype`.", "question_id": 1286},
{"snippet": "polynomial.polynomial.polyfit(x, y, deg)", "intent": "Least-squares fit of a polynomial to data . Return the coefficients of a polynomial of degree `deg` that is the least squares fit to the data values `y` given at points `x` .", "question_id": 1287},
{"snippet": "polynomial.polynomial.polyfit(x, y, deg, rcond=None)", "intent": "Least-squares fit of a polynomial to data . Return the coefficients of a polynomial of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error .", "question_id": 1288},
{"snippet": "polynomial.polynomial.polyfit(x, y, deg, full=False)", "intent": "Least-squares fit of a polynomial to data . Return the coefficients of a polynomial of degree `deg` that is the least squares fit to the data values `y` given at points `x` . If some of the singular values of V are so small that they are neglected ( and `full` == False ) , a RankWarning will be raised .", "question_id": 1289},
{"snippet": "polynomial.polynomial.polyfit(x, y, deg, w=None)", "intent": "Least-squares fit of a polynomial to data . Return the coefficients of a polynomial of degree `deg` that is the least squares fit to the data values `y` given at points `x` . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values .", "question_id": 1290},
{"snippet": "polynomial.polynomial.polyfit(x, y, deg, rcond=None, full=False)", "intent": "Least-squares fit of a polynomial to data . Return the coefficients of a polynomial of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . If some of the singular values of V are so small that they are neglected ( and `full` == False ) , a RankWarning will be raised .", "question_id": 1291},
{"snippet": "polynomial.polynomial.polyfit(x, y, deg, rcond=None, w=None)", "intent": "Least-squares fit of a polynomial to data . Return the coefficients of a polynomial of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values .", "question_id": 1292},
{"snippet": "polynomial.polynomial.polyfit(x, y, deg, full=False, w=None)", "intent": "Least-squares fit of a polynomial to data . Return the coefficients of a polynomial of degree `deg` that is the least squares fit to the data values `y` given at points `x` . If some of the singular values of V are so small that they are neglected ( and `full` == False ) , a RankWarning will be raised . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values .", "question_id": 1293},
{"snippet": "polynomial.polynomial.polyfit(x, y, deg, rcond=None, full=False, w=None)", "intent": "Least-squares fit of a polynomial to data . Return the coefficients of a polynomial of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . If some of the singular values of V are so small that they are neglected ( and `full` == False ) , a RankWarning will be raised . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values .", "question_id": 1294},
{"snippet": "char.chararray.lstrip()", "intent": "For each element in self , return a copy with the leading characters removed .", "question_id": 1295},
{"snippet": "char.chararray.lstrip(chars=None)", "intent": "For each element in self , return a copy with the leading characters removed . With arguments `chars`.", "question_id": 1296},
{"snippet": "numpy.lib.user_array.container(data)", "intent": "Standard container-class for easy multiple-inheritance . With arguments `data`.", "question_id": 1297},
{"snippet": "numpy.lib.user_array.container(data, dtype=None)", "intent": "Standard container-class for easy multiple-inheritance . With arguments `data`, `dtype`.", "question_id": 1298},
{"snippet": "numpy.lib.user_array.container(data, copy=True)", "intent": "Standard container-class for easy multiple-inheritance . With arguments `data`, `copy`.", "question_id": 1299},
{"snippet": "numpy.lib.user_array.container(data, dtype=None, copy=True)", "intent": "Standard container-class for easy multiple-inheritance . With arguments `data`, `dtype`, `copy`.", "question_id": 1300},
{"snippet": "numpy.tri(N)", "intent": "An array with ones at and below the given diagonal and zeros elsewhere . With arguments `N`.", "question_id": 1301},
{"snippet": "numpy.tri(N, M=None)", "intent": "An array with ones at and below the given diagonal and zeros elsewhere . With arguments `N`, `M`.", "question_id": 1302},
{"snippet": "numpy.tri(N, k=0)", "intent": "An array with ones at and below the given diagonal and zeros elsewhere . With arguments `N`, `k`.", "question_id": 1303},
{"snippet": "numpy.tri(N, dtype=<class 'float'>)", "intent": "An array with ones at and below the given diagonal and zeros elsewhere . With arguments `N`, `dtype`.", "question_id": 1304},
{"snippet": "numpy.tri(N, like=None)", "intent": "An array with ones at and below the given diagonal and zeros elsewhere . With arguments `N`, `like`.", "question_id": 1305},
{"snippet": "numpy.tri(N, M=None, k=0)", "intent": "An array with ones at and below the given diagonal and zeros elsewhere . With arguments `N`, `M`, `k`.", "question_id": 1306},
{"snippet": "numpy.tri(N, M=None, dtype=<class 'float'>)", "intent": "An array with ones at and below the given diagonal and zeros elsewhere . With arguments `N`, `M`, `dtype`.", "question_id": 1307},
{"snippet": "numpy.tri(N, M=None, like=None)", "intent": "An array with ones at and below the given diagonal and zeros elsewhere . With arguments `N`, `M`, `like`.", "question_id": 1308},
{"snippet": "numpy.tri(N, k=0, dtype=<class 'float'>)", "intent": "An array with ones at and below the given diagonal and zeros elsewhere . With arguments `N`, `k`, `dtype`.", "question_id": 1309},
{"snippet": "numpy.tri(N, k=0, like=None)", "intent": "An array with ones at and below the given diagonal and zeros elsewhere . With arguments `N`, `k`, `like`.", "question_id": 1310},
{"snippet": "ma.MaskedArray.__ior__(value, /)", "intent": "Return self|=value . With arguments `value`, `/`.", "question_id": 1311},
{"snippet": "numpy.copy(a)", "intent": "Return an array copy of the given object . Create an array x , with `a` reference y and a copy z :", "question_id": 1312},
{"snippet": "numpy.copy(a, order='K')", "intent": "Return an array copy of the given object . Create an array x , with `a` reference y and a copy z : With arguments `order`.", "question_id": 1313},
{"snippet": "numpy.copy(a, subok=False)", "intent": "Return an array copy of the given object . Create an array x , with `a` reference y and a copy z : With arguments `subok`.", "question_id": 1314},
{"snippet": "numpy.copy(a, order='K', subok=False)", "intent": "Return an array copy of the given object . Create an array x , with `a` reference y and a copy z : With arguments `order`, `subok`.", "question_id": 1315},
{"snippet": "random.standard_normal()", "intent": "Draw samples from a standard Normal distribution ( mean=0 , stdev=1 ) .", "question_id": 1316},
{"snippet": "random.standard_normal(size=None)", "intent": "Draw samples from a standard Normal distribution ( mean=0 , stdev=1 ) . With arguments `size`.", "question_id": 1317},
{"snippet": "char.multiply(a, i)", "intent": "Return ( `a` * `i` ) , that is string multiple concatenation , element-wise .", "question_id": 1318},
{"snippet": "ma.MaskedArray.min()", "intent": "Return the minimum along a given `axis` .", "question_id": 1319},
{"snippet": "ma.MaskedArray.min(axis=None)", "intent": "Return the minimum along a given `axis` .", "question_id": 1320},
{"snippet": "ma.MaskedArray.min(out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`.", "question_id": 1321},
{"snippet": "ma.MaskedArray.min(fill_value=None)", "intent": "Return the minimum along a given `axis` . With arguments `fill_value`.", "question_id": 1322},
{"snippet": "ma.MaskedArray.min(keepdims=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`.", "question_id": 1323},
{"snippet": "ma.MaskedArray.min(axis=None, out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`.", "question_id": 1324},
{"snippet": "ma.MaskedArray.min(axis=None, fill_value=None)", "intent": "Return the minimum along a given `axis` . With arguments `fill_value`.", "question_id": 1325},
{"snippet": "ma.MaskedArray.min(axis=None, keepdims=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`.", "question_id": 1326},
{"snippet": "ma.MaskedArray.min(out=None, fill_value=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`, `fill_value`.", "question_id": 1327},
{"snippet": "ma.MaskedArray.min(out=None, keepdims=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `out`, `keepdims`.", "question_id": 1328},
{"snippet": "polynomial.chebyshev.chebdiv(c1, c2)", "intent": "Divide one Chebyshev series by another . Returns the quotient-with-remainder of two Chebyshev series `c1` / `c2` .", "question_id": 1329},
{"snippet": "nditer.remove_multi_index()", "intent": "When the \u201c multi_index \u201d flag was specified , this removes it , allowing the internal iteration structure to be optimized further .", "question_id": 1330},
{"snippet": "polynomial.hermite.hermint(c)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 1331},
{"snippet": "polynomial.hermite.hermint(c, m=1)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 1332},
{"snippet": "polynomial.hermite.hermint(c, k=)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 1333},
{"snippet": "polynomial.hermite.hermint(c, lbnd=0)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 1334},
{"snippet": "polynomial.hermite.hermint(c, scl=1)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 1335},
{"snippet": "polynomial.hermite.hermint(c, axis=0)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 1336},
{"snippet": "polynomial.hermite.hermint(c, m=1, k=)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 1337},
{"snippet": "polynomial.hermite.hermint(c, m=1, lbnd=0)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 1338},
{"snippet": "polynomial.hermite.hermint(c, m=1, scl=1)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 1339},
{"snippet": "polynomial.hermite.hermint(c, m=1, axis=0)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 1340},
{"snippet": "polynomial.hermite.hermint()", "intent": "Integrate a Hermite series .", "question_id": 1341},
{"snippet": "polynomial.hermite.hermint(m=1)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 1342},
{"snippet": "polynomial.hermite.hermint(k=)", "intent": "Integrate a Hermite series . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 1343},
{"snippet": "polynomial.hermite.hermint(lbnd=0)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 1344},
{"snippet": "polynomial.hermite.hermint(scl=1)", "intent": "Integrate a Hermite series . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 1345},
{"snippet": "polynomial.hermite.hermint(axis=0)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 1346},
{"snippet": "polynomial.hermite.hermint(m=1, k=)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 1347},
{"snippet": "polynomial.hermite.hermint(m=1, lbnd=0)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 1348},
{"snippet": "polynomial.hermite.hermint(m=1, scl=1)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 1349},
{"snippet": "polynomial.hermite.hermint(m=1, axis=0)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 1350},
{"snippet": "linalg.eigvalsh(a)", "intent": "Compute the eigenvalues of `a` complex Hermitian or real symmetric matrix .", "question_id": 1351},
{"snippet": "linalg.eigvalsh(a, UPLO='L')", "intent": "Compute the eigenvalues of `a` complex Hermitian or real symmetric matrix . With arguments `UPLO`.", "question_id": 1352},
{"snippet": "char.istitle(a)", "intent": "Returns true for each element if the element is `a` titlecased string and there is at least one character , false otherwise .", "question_id": 1353},
{"snippet": "ma.common_fill_value(a, b)", "intent": "Return the common filling value of two masked arrays , if any . With arguments `a`, `b`.", "question_id": 1354},
{"snippet": "polynomial.polynomial.polymul(c1, c2)", "intent": "Multiply one polynomial by another . Returns the product of two polynomials `c1` * `c2` .", "question_id": 1355},
{"snippet": "polynomial.chebyshev.chebroots(c)", "intent": "Compute the roots of a Chebyshev series . With arguments `c`.", "question_id": 1356},
{"snippet": "generic.ndim", "intent": "The number of array dimensions.", "question_id": 1357},
{"snippet": "polynomial.laguerre.Laguerre.degree()", "intent": "The degree of the series .", "question_id": 1358},
{"snippet": "ma.MaskedArray.strides", "intent": "Tuple of bytes to step in each dimension when traversing an array.", "question_id": 1359},
{"snippet": "ma.all(self)", "intent": "Returns True if all elements evaluate to True . With arguments `self`.", "question_id": 1360},
{"snippet": "ma.all(self, axis=None)", "intent": "Returns True if all elements evaluate to True . The output array is masked where all the values along the given `axis` are masked : if the output would have been a scalar and that all the values are masked , then the output is masked . With arguments `self`.", "question_id": 1361},
{"snippet": "ma.all(self, out=None)", "intent": "Returns True if all elements evaluate to True . With arguments `self`, `out`.", "question_id": 1362},
{"snippet": "ma.all(self, keepdims=<no value>)", "intent": "Returns True if all elements evaluate to True . With arguments `self`, `keepdims`.", "question_id": 1363},
{"snippet": "ma.all(self, axis=None, out=None)", "intent": "Returns True if all elements evaluate to True . The output array is masked where all the values along the given `axis` are masked : if the output would have been a scalar and that all the values are masked , then the output is masked . With arguments `self`, `out`.", "question_id": 1364},
{"snippet": "ma.all(self, axis=None, keepdims=<no value>)", "intent": "Returns True if all elements evaluate to True . The output array is masked where all the values along the given `axis` are masked : if the output would have been a scalar and that all the values are masked , then the output is masked . With arguments `self`, `keepdims`.", "question_id": 1365},
{"snippet": "ma.all(self, out=None, keepdims=<no value>)", "intent": "Returns True if all elements evaluate to True . With arguments `self`, `out`, `keepdims`.", "question_id": 1366},
{"snippet": "ma.all(self, axis=None, out=None, keepdims=<no value>)", "intent": "Returns True if all elements evaluate to True . The output array is masked where all the values along the given `axis` are masked : if the output would have been a scalar and that all the values are masked , then the output is masked . With arguments `self`, `out`, `keepdims`.", "question_id": 1367},
{"snippet": "numpy.divide(x1, x2, /, signature, extobj)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`.", "question_id": 1368},
{"snippet": "numpy.divide(x1, x2, /, signature, extobj, out=None)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `out`.", "question_id": 1369},
{"snippet": "numpy.divide(x1, x2, /, signature, extobj, where=True)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `where`.", "question_id": 1370},
{"snippet": "numpy.divide(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `casting`.", "question_id": 1371},
{"snippet": "numpy.divide(x1, x2, /, signature, extobj, order='K')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `order`.", "question_id": 1372},
{"snippet": "numpy.divide(x1, x2, /, signature, extobj, dtype=None)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `dtype`.", "question_id": 1373},
{"snippet": "numpy.divide(x1, x2, /, signature, extobj, subok=True)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `subok`.", "question_id": 1374},
{"snippet": "numpy.divide(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `out`, `where`.", "question_id": 1375},
{"snippet": "numpy.divide(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `out`, `casting`.", "question_id": 1376},
{"snippet": "numpy.divide(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `out`, `order`.", "question_id": 1377},
{"snippet": "numpy.divide(x1, x2, /, signature)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`.", "question_id": 1378},
{"snippet": "numpy.divide(x1, x2, /, signature, out=None)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `out`.", "question_id": 1379},
{"snippet": "numpy.divide(x1, x2, /, signature, where=True)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `where`.", "question_id": 1380},
{"snippet": "numpy.divide(x1, x2, /, signature, casting='same_kind')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `casting`.", "question_id": 1381},
{"snippet": "numpy.divide(x1, x2, /, signature, order='K')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `order`.", "question_id": 1382},
{"snippet": "numpy.divide(x1, x2, /, signature, dtype=None)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `dtype`.", "question_id": 1383},
{"snippet": "numpy.divide(x1, x2, /, signature, subok=True)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `subok`.", "question_id": 1384},
{"snippet": "numpy.divide(x1, x2, /, signature, out=None, where=True)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `out`, `where`.", "question_id": 1385},
{"snippet": "numpy.divide(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `out`, `casting`.", "question_id": 1386},
{"snippet": "numpy.divide(x1, x2, /, signature, out=None, order='K')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `out`, `order`.", "question_id": 1387},
{"snippet": "chararray.index(sub)", "intent": "Like find , but raises ValueError when the substring is not found . With arguments `sub`.", "question_id": 1388},
{"snippet": "chararray.index(sub, start=0)", "intent": "Like find , but raises ValueError when the substring is not found . With arguments `sub`, `start`.", "question_id": 1389},
{"snippet": "chararray.index(sub, end=None)", "intent": "Like find , but raises ValueError when the substring is not found . With arguments `sub`, `end`.", "question_id": 1390},
{"snippet": "chararray.index(sub, start=0, end=None)", "intent": "Like find , but raises ValueError when the substring is not found . With arguments `sub`, `start`, `end`.", "question_id": 1391},
{"snippet": "memmap.min()", "intent": "Return the minimum along a given `axis` .", "question_id": 1392},
{"snippet": "memmap.min(axis=None)", "intent": "Return the minimum along a given `axis` .", "question_id": 1393},
{"snippet": "memmap.min(out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`.", "question_id": 1394},
{"snippet": "memmap.min(keepdims=False)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`.", "question_id": 1395},
{"snippet": "memmap.min(initial=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `initial`.", "question_id": 1396},
{"snippet": "memmap.min(where=True)", "intent": "Return the minimum along a given `axis` . With arguments `where`.", "question_id": 1397},
{"snippet": "memmap.min(axis=None, out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`.", "question_id": 1398},
{"snippet": "memmap.min(axis=None, keepdims=False)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`.", "question_id": 1399},
{"snippet": "memmap.min(axis=None, initial=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `initial`.", "question_id": 1400},
{"snippet": "memmap.min(axis=None, where=True)", "intent": "Return the minimum along a given `axis` . With arguments `where`.", "question_id": 1401},
{"snippet": "matrix.ndim", "intent": "Number of array dimensions.", "question_id": 1402},
{"snippet": "random.Generator.bytes(length)", "intent": "Return random bytes . With arguments `length`.", "question_id": 1403},
{"snippet": "chararray.put(indices, values)", "intent": "Set a.flat [ n ] = `values` [ n ] for all n in `indices` .", "question_id": 1404},
{"snippet": "chararray.put(indices, values, mode='raise')", "intent": "Set a.flat [ n ] = `values` [ n ] for all n in `indices` . With arguments `mode`.", "question_id": 1405},
{"snippet": "ndarray.__array__(dtype, /)", "intent": "Returns either a new reference to self if `dtype` is not given or a new array of provided data type if dtype is different from the current dtype of the array . With arguments `/`.", "question_id": 1406},
{"snippet": "ndarray.__array__(dtype)", "intent": "Returns either a new reference to self if `dtype` is not given or a new array of provided data type if dtype is different from the current dtype of the array .", "question_id": 1407},
{"snippet": "testing.assert_almost_equal(actual, desired)", "intent": "Raises an AssertionError if two items are not equal up to `desired` precision . The test verifies that the elements of `actual` and desired satisfy .", "question_id": 1408},
{"snippet": "testing.assert_almost_equal(actual, desired, decimal=7)", "intent": "Raises an AssertionError if two items are not equal up to `desired` precision . The test verifies that the elements of `actual` and desired satisfy . With arguments `decimal`.", "question_id": 1409},
{"snippet": "testing.assert_almost_equal(actual, desired, err_msg='')", "intent": "Raises an AssertionError if two items are not equal up to `desired` precision . The test verifies that the elements of `actual` and desired satisfy . With arguments `err_msg`.", "question_id": 1410},
{"snippet": "testing.assert_almost_equal(actual, desired, verbose=True)", "intent": "Raises an AssertionError if two items are not equal up to `desired` precision . The test verifies that the elements of `actual` and desired satisfy . With arguments `verbose`.", "question_id": 1411},
{"snippet": "testing.assert_almost_equal(actual, desired, decimal=7, err_msg='')", "intent": "Raises an AssertionError if two items are not equal up to `desired` precision . The test verifies that the elements of `actual` and desired satisfy . With arguments `decimal`, `err_msg`.", "question_id": 1412},
{"snippet": "testing.assert_almost_equal(actual, desired, decimal=7, verbose=True)", "intent": "Raises an AssertionError if two items are not equal up to `desired` precision . The test verifies that the elements of `actual` and desired satisfy . With arguments `decimal`, `verbose`.", "question_id": 1413},
{"snippet": "testing.assert_almost_equal(actual, desired, err_msg='', verbose=True)", "intent": "Raises an AssertionError if two items are not equal up to `desired` precision . The test verifies that the elements of `actual` and desired satisfy . With arguments `err_msg`, `verbose`.", "question_id": 1414},
{"snippet": "testing.assert_almost_equal(actual, desired, decimal=7, err_msg='', verbose=True)", "intent": "Raises an AssertionError if two items are not equal up to `desired` precision . The test verifies that the elements of `actual` and desired satisfy . With arguments `decimal`, `err_msg`, `verbose`.", "question_id": 1415},
{"snippet": "ma.MaskType.strides", "intent": "Tuple of bytes steps in each dimension.", "question_id": 1416},
{"snippet": "polynomial.legendre.legdiv(c1, c2)", "intent": "Divide one Legendre series by another . Returns the quotient-with-remainder of two Legendre series `c1` / `c2` .", "question_id": 1417},
{"snippet": "random.RandomState.permutation(x)", "intent": "Randomly permute a sequence , or return a permuted range . If `x` is a multi-dimensional array , it is only shuffled along its first index .", "question_id": 1418},
{"snippet": "chararray.argmax()", "intent": "Return indices of the maximum values along the given `axis` .", "question_id": 1419},
{"snippet": "chararray.argmax(axis=None)", "intent": "Return indices of the maximum values along the given `axis` .", "question_id": 1420},
{"snippet": "chararray.argmax(out=None)", "intent": "Return indices of the maximum values along the given `axis` . With arguments `out`.", "question_id": 1421},
{"snippet": "chararray.argmax(axis=None, out=None)", "intent": "Return indices of the maximum values along the given `axis` . With arguments `out`.", "question_id": 1422},
{"snippet": "ndarray.__ior__(value, /)", "intent": "Return self|=value . With arguments `value`, `/`.", "question_id": 1423},
{"snippet": "char.chararray.isalpha()", "intent": "Returns true for each element if all characters in the string are alphabetic and there is at least one character , false otherwise .", "question_id": 1424},
{"snippet": "polynomial.hermite_e.HermiteE.cast(series)", "intent": "Convert `series` to series of this class .", "question_id": 1425},
{"snippet": "polynomial.hermite_e.HermiteE.cast(series, domain=None)", "intent": "Convert `series` to series of this class . With arguments `domain`.", "question_id": 1426},
{"snippet": "polynomial.hermite_e.HermiteE.cast(series, window=None)", "intent": "Convert `series` to series of this class . With arguments `window`.", "question_id": 1427},
{"snippet": "polynomial.hermite_e.HermiteE.cast(series, domain=None, window=None)", "intent": "Convert `series` to series of this class . With arguments `domain`, `window`.", "question_id": 1428},
{"snippet": "linalg.slogdet(a)", "intent": "Compute the sign and ( natural ) logarithm of the determinant of an array . If an array has `a` very small or very large determinant , then a call to det may overflow or underflow .", "question_id": 1429},
{"snippet": "random.gumbel()", "intent": "Draw samples from a Gumbel distribution .", "question_id": 1430},
{"snippet": "random.gumbel(loc=0.0)", "intent": "Draw samples from a Gumbel distribution . With arguments `loc`.", "question_id": 1431},
{"snippet": "random.gumbel(scale=1.0)", "intent": "Draw samples from a Gumbel distribution . Draw samples from a Gumbel distribution with specified location and `scale` .", "question_id": 1432},
{"snippet": "random.gumbel(size=None)", "intent": "Draw samples from a Gumbel distribution . With arguments `size`.", "question_id": 1433},
{"snippet": "random.gumbel(loc=0.0, scale=1.0)", "intent": "Draw samples from a Gumbel distribution . Draw samples from a Gumbel distribution with specified location and `scale` . With arguments `loc`.", "question_id": 1434},
{"snippet": "random.gumbel(loc=0.0, size=None)", "intent": "Draw samples from a Gumbel distribution . With arguments `loc`, `size`.", "question_id": 1435},
{"snippet": "random.gumbel(scale=1.0, size=None)", "intent": "Draw samples from a Gumbel distribution . Draw samples from a Gumbel distribution with specified location and `scale` . With arguments `size`.", "question_id": 1436},
{"snippet": "random.gumbel(loc=0.0, scale=1.0, size=None)", "intent": "Draw samples from a Gumbel distribution . Draw samples from a Gumbel distribution with specified location and `scale` . With arguments `loc`, `size`.", "question_id": 1437},
{"snippet": "numpy.gradient(f, *varargs)", "intent": "Return the gradient of an N-dimensional array . By substituting \\ ( `f` ( x_ { i } + h_ { d } ) \\ ) and \\ ( f ( x_ { i } - h_ { s } ) \\ ) with their Taylor series expansion , this translates into solving the following the linear system : With arguments `*varargs`.", "question_id": 1438},
{"snippet": "numpy.gradient(f, *varargs, axis=None)", "intent": "Return the gradient of an N-dimensional array . By substituting \\ ( `f` ( x_ { i } + h_ { d } ) \\ ) and \\ ( f ( x_ { i } - h_ { s } ) \\ ) with their Taylor series expansion , this translates into solving the following the linear system : For two dimensional arrays , the return will be two arrays ordered by `axis` . With arguments `*varargs`.", "question_id": 1439},
{"snippet": "numpy.gradient(f, *varargs, edge_order=1)", "intent": "Return the gradient of an N-dimensional array . By substituting \\ ( `f` ( x_ { i } + h_ { d } ) \\ ) and \\ ( f ( x_ { i } - h_ { s } ) \\ ) with their Taylor series expansion , this translates into solving the following the linear system : It is possible to specify how boundaries are treated using `edge_order` With arguments `*varargs`.", "question_id": 1440},
{"snippet": "numpy.gradient(f, *varargs, axis=None, edge_order=1)", "intent": "Return the gradient of an N-dimensional array . By substituting \\ ( `f` ( x_ { i } + h_ { d } ) \\ ) and \\ ( f ( x_ { i } - h_ { s } ) \\ ) with their Taylor series expansion , this translates into solving the following the linear system : For two dimensional arrays , the return will be two arrays ordered by `axis` . It is possible to specify how boundaries are treated using `edge_order` With arguments `*varargs`.", "question_id": 1441},
{"snippet": "numpy.vectorize(pyfunc)", "intent": "Generalized function class . The vectorized function evaluates `pyfunc` over successive tuples of the input arrays like the python map function , except it uses the broadcasting rules of numpy .", "question_id": 1442},
{"snippet": "numpy.vectorize(pyfunc, otypes=None)", "intent": "Generalized function class . The vectorized function evaluates `pyfunc` over successive tuples of the input arrays like the python map function , except it uses the broadcasting rules of numpy . This can be avoided by specifying the `otypes` argument .", "question_id": 1443},
{"snippet": "numpy.vectorize(pyfunc, doc=None)", "intent": "Generalized function class . The vectorized function evaluates `pyfunc` over successive tuples of the input arrays like the python map function , except it uses the broadcasting rules of numpy . With arguments `doc`.", "question_id": 1444},
{"snippet": "numpy.vectorize(pyfunc, excluded=None)", "intent": "Generalized function class . The vectorized function evaluates `pyfunc` over successive tuples of the input arrays like the python map function , except it uses the broadcasting rules of numpy . The new keyword argument interface and `excluded` argument support further degrades performance .", "question_id": 1445},
{"snippet": "numpy.vectorize(pyfunc, cache=False)", "intent": "Generalized function class . The vectorized function evaluates `pyfunc` over successive tuples of the input arrays like the python map function , except it uses the broadcasting rules of numpy . The results of this call will be cached if `cache` is True to prevent calling the function twice .", "question_id": 1446},
{"snippet": "numpy.vectorize(pyfunc, signature=None)", "intent": "Generalized function class . The vectorized function evaluates `pyfunc` over successive tuples of the input arrays like the python map function , except it uses the broadcasting rules of numpy . The `signature` argument allows for vectorizing functions that act on non-scalar arrays of fixed length .", "question_id": 1447},
{"snippet": "numpy.vectorize(pyfunc, otypes=None, doc=None)", "intent": "Generalized function class . The vectorized function evaluates `pyfunc` over successive tuples of the input arrays like the python map function , except it uses the broadcasting rules of numpy . This can be avoided by specifying the `otypes` argument . With arguments `doc`.", "question_id": 1448},
{"snippet": "numpy.vectorize(pyfunc, otypes=None, excluded=None)", "intent": "Generalized function class . The vectorized function evaluates `pyfunc` over successive tuples of the input arrays like the python map function , except it uses the broadcasting rules of numpy . This can be avoided by specifying the `otypes` argument . The new keyword argument interface and `excluded` argument support further degrades performance .", "question_id": 1449},
{"snippet": "numpy.vectorize(pyfunc, otypes=None, cache=False)", "intent": "Generalized function class . The vectorized function evaluates `pyfunc` over successive tuples of the input arrays like the python map function , except it uses the broadcasting rules of numpy . This can be avoided by specifying the `otypes` argument . The results of this call will be cached if `cache` is True to prevent calling the function twice .", "question_id": 1450},
{"snippet": "numpy.vectorize(pyfunc, otypes=None, signature=None)", "intent": "Generalized function class . The vectorized function evaluates `pyfunc` over successive tuples of the input arrays like the python map function , except it uses the broadcasting rules of numpy . This can be avoided by specifying the `otypes` argument . The `signature` argument allows for vectorizing functions that act on non-scalar arrays of fixed length .", "question_id": 1451},
{"snippet": "ma.MaskedArray.std()", "intent": "Returns the standard deviation of the array elements along given `axis` .", "question_id": 1452},
{"snippet": "ma.MaskedArray.std(axis=None)", "intent": "Returns the standard deviation of the array elements along given `axis` .", "question_id": 1453},
{"snippet": "ma.MaskedArray.std(dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`.", "question_id": 1454},
{"snippet": "ma.MaskedArray.std(out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`.", "question_id": 1455},
{"snippet": "ma.MaskedArray.std(ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`.", "question_id": 1456},
{"snippet": "ma.MaskedArray.std(keepdims=<no value>)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `keepdims`.", "question_id": 1457},
{"snippet": "ma.MaskedArray.std(axis=None, dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`.", "question_id": 1458},
{"snippet": "ma.MaskedArray.std(axis=None, out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`.", "question_id": 1459},
{"snippet": "ma.MaskedArray.std(axis=None, ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`.", "question_id": 1460},
{"snippet": "ma.MaskedArray.std(axis=None, keepdims=<no value>)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `keepdims`.", "question_id": 1461},
{"snippet": "chararray.sort()", "intent": "Sort an array in-place .", "question_id": 1462},
{"snippet": "chararray.sort(axis=- 1)", "intent": "Sort an array in-place . With arguments `axis`.", "question_id": 1463},
{"snippet": "chararray.sort(kind=None)", "intent": "Sort an array in-place . With arguments `kind`.", "question_id": 1464},
{"snippet": "chararray.sort(order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array :", "question_id": 1465},
{"snippet": "chararray.sort(axis=- 1, kind=None)", "intent": "Sort an array in-place . With arguments `axis`, `kind`.", "question_id": 1466},
{"snippet": "chararray.sort(axis=- 1, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `axis`.", "question_id": 1467},
{"snippet": "chararray.sort(kind=None, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `kind`.", "question_id": 1468},
{"snippet": "chararray.sort(axis=- 1, kind=None, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `axis`, `kind`.", "question_id": 1469},
{"snippet": "polynomial.hermite_e.HermiteE.has_samedomain(other)", "intent": "Check if domains match . With arguments `other`.", "question_id": 1470},
{"snippet": "char.chararray.rindex(sub)", "intent": "Like rfind , but raises ValueError when the substring `sub` is not found .", "question_id": 1471},
{"snippet": "char.chararray.rindex(sub, start=0)", "intent": "Like rfind , but raises ValueError when the substring `sub` is not found . With arguments `start`.", "question_id": 1472},
{"snippet": "char.chararray.rindex(sub, end=None)", "intent": "Like rfind , but raises ValueError when the substring `sub` is not found . With arguments `end`.", "question_id": 1473},
{"snippet": "char.chararray.rindex(sub, start=0, end=None)", "intent": "Like rfind , but raises ValueError when the substring `sub` is not found . With arguments `start`, `end`.", "question_id": 1474},
{"snippet": "numpy.deg2rad(x, /, signature, extobj)", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `extobj`.", "question_id": 1475},
{"snippet": "numpy.deg2rad(x, /, signature, extobj, out=None)", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `extobj`, `out`.", "question_id": 1476},
{"snippet": "numpy.deg2rad(x, /, signature, extobj, where=True)", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `extobj`, `where`.", "question_id": 1477},
{"snippet": "numpy.deg2rad(x, /, signature, extobj, casting='same_kind')", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `extobj`, `casting`.", "question_id": 1478},
{"snippet": "numpy.deg2rad(x, /, signature, extobj, order='K')", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `extobj`, `order`.", "question_id": 1479},
{"snippet": "numpy.deg2rad(x, /, signature, extobj, dtype=None)", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `extobj`, `dtype`.", "question_id": 1480},
{"snippet": "numpy.deg2rad(x, /, signature, extobj, subok=True)", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `extobj`, `subok`.", "question_id": 1481},
{"snippet": "numpy.deg2rad(x, /, signature, extobj, out=None, where=True)", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `extobj`, `out`, `where`.", "question_id": 1482},
{"snippet": "numpy.deg2rad(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `extobj`, `out`, `casting`.", "question_id": 1483},
{"snippet": "numpy.deg2rad(x, /, signature, extobj, out=None, order='K')", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `extobj`, `out`, `order`.", "question_id": 1484},
{"snippet": "numpy.deg2rad(x, /, signature)", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`.", "question_id": 1485},
{"snippet": "numpy.deg2rad(x, /, signature, out=None)", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `out`.", "question_id": 1486},
{"snippet": "numpy.deg2rad(x, /, signature, where=True)", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `where`.", "question_id": 1487},
{"snippet": "numpy.deg2rad(x, /, signature, casting='same_kind')", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `casting`.", "question_id": 1488},
{"snippet": "numpy.deg2rad(x, /, signature, order='K')", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `order`.", "question_id": 1489},
{"snippet": "numpy.deg2rad(x, /, signature, dtype=None)", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `dtype`.", "question_id": 1490},
{"snippet": "numpy.deg2rad(x, /, signature, subok=True)", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `subok`.", "question_id": 1491},
{"snippet": "numpy.deg2rad(x, /, signature, out=None, where=True)", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `out`, `where`.", "question_id": 1492},
{"snippet": "numpy.deg2rad(x, /, signature, out=None, casting='same_kind')", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `out`, `casting`.", "question_id": 1493},
{"snippet": "numpy.deg2rad(x, /, signature, out=None, order='K')", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `out`, `order`.", "question_id": 1494},
{"snippet": "numpy.hamming(M)", "intent": "Return the Hamming window . With arguments `M`.", "question_id": 1495},
{"snippet": "recarray.T", "intent": "The transposed array.", "question_id": 1496},
{"snippet": "ndarray.__ge__(value, /)", "intent": "Return self > =value . With arguments `value`, `/`.", "question_id": 1497},
{"snippet": "ma.MaskedArray.__getstate__()", "intent": "Return the internal state of the masked array , for pickling purposes .", "question_id": 1498},
{"snippet": "char.chararray.flatten()", "intent": "Return a copy of the array collapsed into one dimension .", "question_id": 1499},
{"snippet": "char.chararray.flatten(order='C')", "intent": "Return a copy of the array collapsed into one dimension . With arguments `order`.", "question_id": 1500},
{"snippet": "polynomial.legendre.legfromroots(roots)", "intent": "Generate a Legendre series with given `roots` .", "question_id": 1501},
{"snippet": "ma.masked_array.squeeze()", "intent": "Remove axes of length one from a .", "question_id": 1502},
{"snippet": "ma.masked_array.squeeze(axis=None)", "intent": "Remove axes of length one from a . With arguments `axis`.", "question_id": 1503},
{"snippet": "numpy.format_float_positional(x)", "intent": "Format a floating-point scalar as a decimal string in positional notation . With arguments `x`.", "question_id": 1504},
{"snippet": "numpy.format_float_positional(x, precision=None)", "intent": "Format a floating-point scalar as a decimal string in positional notation . With arguments `x`, `precision`.", "question_id": 1505},
{"snippet": "numpy.format_float_positional(x, unique=True)", "intent": "Format a floating-point scalar as a decimal string in positional notation . With arguments `x`, `unique`.", "question_id": 1506},
{"snippet": "numpy.format_float_positional(x, fractional=True)", "intent": "Format a floating-point scalar as a decimal string in positional notation . With arguments `x`, `fractional`.", "question_id": 1507},
{"snippet": "numpy.format_float_positional(x, trim='k')", "intent": "Format a floating-point scalar as a decimal string in positional notation . With arguments `x`, `trim`.", "question_id": 1508},
{"snippet": "numpy.format_float_positional(x, sign=False)", "intent": "Format a floating-point scalar as a decimal string in positional notation . With arguments `x`, `sign`.", "question_id": 1509},
{"snippet": "numpy.format_float_positional(x, pad_left=None)", "intent": "Format a floating-point scalar as a decimal string in positional notation . With arguments `x`, `pad_left`.", "question_id": 1510},
{"snippet": "numpy.format_float_positional(x, pad_right=None)", "intent": "Format a floating-point scalar as a decimal string in positional notation . With arguments `x`, `pad_right`.", "question_id": 1511},
{"snippet": "numpy.format_float_positional(x, min_digits=None)", "intent": "Format a floating-point scalar as a decimal string in positional notation . With arguments `x`, `min_digits`.", "question_id": 1512},
{"snippet": "numpy.format_float_positional(x, precision=None, unique=True)", "intent": "Format a floating-point scalar as a decimal string in positional notation . With arguments `x`, `precision`, `unique`.", "question_id": 1513},
{"snippet": "recarray.tostring()", "intent": "A compatibility alias for tobytes , with exactly the same behavior .", "question_id": 1514},
{"snippet": "recarray.tostring(order='C')", "intent": "A compatibility alias for tobytes , with exactly the same behavior . With arguments `order`.", "question_id": 1515},
{"snippet": "numpy.isfortran(a)", "intent": "Check if the array is Fortran contiguous but not C contiguous . The transpose of `a` C-ordered array is a FORTRAN-ordered array .", "question_id": 1516},
{"snippet": "random.Generator.poisson()", "intent": "Draw samples from a Poisson distribution .", "question_id": 1517},
{"snippet": "random.Generator.poisson(lam=1.0)", "intent": "Draw samples from a Poisson distribution . Because the output is limited to the range of the C int64 type , a ValueError is raised when `lam` is within 10 sigma of the maximum representable value .", "question_id": 1518},
{"snippet": "random.Generator.poisson(size=None)", "intent": "Draw samples from a Poisson distribution . With arguments `size`.", "question_id": 1519},
{"snippet": "random.Generator.poisson(lam=1.0, size=None)", "intent": "Draw samples from a Poisson distribution . Because the output is limited to the range of the C int64 type , a ValueError is raised when `lam` is within 10 sigma of the maximum representable value . With arguments `size`.", "question_id": 1520},
{"snippet": "ma.masked_array.prod()", "intent": "Return the product of the array elements over the given `axis` .", "question_id": 1521},
{"snippet": "ma.masked_array.prod(axis=None)", "intent": "Return the product of the array elements over the given `axis` .", "question_id": 1522},
{"snippet": "ma.masked_array.prod(dtype=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 1523},
{"snippet": "ma.masked_array.prod(out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `out`.", "question_id": 1524},
{"snippet": "ma.masked_array.prod(keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `keepdims`.", "question_id": 1525},
{"snippet": "ma.masked_array.prod(axis=None, dtype=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 1526},
{"snippet": "ma.masked_array.prod(axis=None, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `out`.", "question_id": 1527},
{"snippet": "ma.masked_array.prod(axis=None, keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `keepdims`.", "question_id": 1528},
{"snippet": "ma.masked_array.prod(dtype=None, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`, `out`.", "question_id": 1529},
{"snippet": "ma.masked_array.prod(dtype=None, keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`, `keepdims`.", "question_id": 1530},
{"snippet": "matrix.tostring()", "intent": "A compatibility alias for tobytes , with exactly the same behavior .", "question_id": 1531},
{"snippet": "matrix.tostring(order='C')", "intent": "A compatibility alias for tobytes , with exactly the same behavior . With arguments `order`.", "question_id": 1532},
{"snippet": "record.put()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 1533},
{"snippet": "chararray.isdecimal()", "intent": "For each element in self , return True if there are only decimal characters in the element .", "question_id": 1534},
{"snippet": "numpy.diagflat(v)", "intent": "Create a two-dimensional array with the flattened input as a diagonal . With arguments `v`.", "question_id": 1535},
{"snippet": "numpy.diagflat(v, k=0)", "intent": "Create a two-dimensional array with the flattened input as a diagonal . With arguments `v`, `k`.", "question_id": 1536},
{"snippet": "char.chararray.ptp()", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` .", "question_id": 1537},
{"snippet": "char.chararray.ptp(axis=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` .", "question_id": 1538},
{"snippet": "char.chararray.ptp(out=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`.", "question_id": 1539},
{"snippet": "char.chararray.ptp(keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `keepdims`.", "question_id": 1540},
{"snippet": "char.chararray.ptp(axis=None, out=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`.", "question_id": 1541},
{"snippet": "char.chararray.ptp(axis=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `keepdims`.", "question_id": 1542},
{"snippet": "char.chararray.ptp(out=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`, `keepdims`.", "question_id": 1543},
{"snippet": "char.chararray.ptp(axis=None, out=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`, `keepdims`.", "question_id": 1544},
{"snippet": "dtype.__reduce__()", "intent": "Helper for pickle .", "question_id": 1545},
{"snippet": "numpy.arctan2(x1, x2, /, signature, extobj)", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `extobj`.", "question_id": 1546},
{"snippet": "numpy.arctan2(x1, x2, /, signature, extobj, out=None)", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 1547},
{"snippet": "numpy.arctan2(x1, x2, /, signature, extobj, where=True)", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 1548},
{"snippet": "numpy.arctan2(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 1549},
{"snippet": "numpy.arctan2(x1, x2, /, signature, extobj, order='K')", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . Note the `order` of the parameters . With arguments `/`, `signature`, `extobj`.", "question_id": 1550},
{"snippet": "numpy.arctan2(x1, x2, /, signature, extobj, dtype=None)", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 1551},
{"snippet": "numpy.arctan2(x1, x2, /, signature, extobj, subok=True)", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 1552},
{"snippet": "numpy.arctan2(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 1553},
{"snippet": "numpy.arctan2(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 1554},
{"snippet": "numpy.arctan2(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . Note the `order` of the parameters . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 1555},
{"snippet": "numpy.arctan2(x1, x2, /, signature)", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`.", "question_id": 1556},
{"snippet": "numpy.arctan2(x1, x2, /, signature, out=None)", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `out`.", "question_id": 1557},
{"snippet": "numpy.arctan2(x1, x2, /, signature, where=True)", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `where`.", "question_id": 1558},
{"snippet": "numpy.arctan2(x1, x2, /, signature, casting='same_kind')", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `casting`.", "question_id": 1559},
{"snippet": "numpy.arctan2(x1, x2, /, signature, order='K')", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . Note the `order` of the parameters . With arguments `/`, `signature`.", "question_id": 1560},
{"snippet": "numpy.arctan2(x1, x2, /, signature, dtype=None)", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `dtype`.", "question_id": 1561},
{"snippet": "numpy.arctan2(x1, x2, /, signature, subok=True)", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `subok`.", "question_id": 1562},
{"snippet": "numpy.arctan2(x1, x2, /, signature, out=None, where=True)", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `out`, `where`.", "question_id": 1563},
{"snippet": "numpy.arctan2(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 1564},
{"snippet": "numpy.arctan2(x1, x2, /, signature, out=None, order='K')", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . Note the `order` of the parameters . With arguments `/`, `signature`, `out`.", "question_id": 1565},
{"snippet": "polynomial.hermite.hermval2d(x, y, c)", "intent": "Evaluate a 2-D Hermite series at points ( `x` , `y` ) . In either case , either x and y or their elements must support multiplication and addition both with themselves and with the elements of `c` .", "question_id": 1566},
{"snippet": "ndarray.__matmul__(value, /)", "intent": "Return self @ `value` . With arguments `/`.", "question_id": 1567},
{"snippet": "numpy.remainder(x1, x2, /, signature, extobj)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`.", "question_id": 1568},
{"snippet": "numpy.remainder(x1, x2, /, signature, extobj, out=None)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 1569},
{"snippet": "numpy.remainder(x1, x2, /, signature, extobj, where=True)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 1570},
{"snippet": "numpy.remainder(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 1571},
{"snippet": "numpy.remainder(x1, x2, /, signature, extobj, order='K')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 1572},
{"snippet": "numpy.remainder(x1, x2, /, signature, extobj, dtype=None)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 1573},
{"snippet": "numpy.remainder(x1, x2, /, signature, extobj, subok=True)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 1574},
{"snippet": "numpy.remainder(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 1575},
{"snippet": "numpy.remainder(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 1576},
{"snippet": "numpy.remainder(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 1577},
{"snippet": "numpy.remainder(x1, x2, /, signature)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`.", "question_id": 1578},
{"snippet": "numpy.remainder(x1, x2, /, signature, out=None)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `out`.", "question_id": 1579},
{"snippet": "numpy.remainder(x1, x2, /, signature, where=True)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `where`.", "question_id": 1580},
{"snippet": "numpy.remainder(x1, x2, /, signature, casting='same_kind')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `casting`.", "question_id": 1581},
{"snippet": "numpy.remainder(x1, x2, /, signature, order='K')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `order`.", "question_id": 1582},
{"snippet": "numpy.remainder(x1, x2, /, signature, dtype=None)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `dtype`.", "question_id": 1583},
{"snippet": "numpy.remainder(x1, x2, /, signature, subok=True)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `subok`.", "question_id": 1584},
{"snippet": "numpy.remainder(x1, x2, /, signature, out=None, where=True)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `out`, `where`.", "question_id": 1585},
{"snippet": "numpy.remainder(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 1586},
{"snippet": "numpy.remainder(x1, x2, /, signature, out=None, order='K')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `out`, `order`.", "question_id": 1587},
{"snippet": "ma.MaskedArray.__gt__(value, /)", "intent": "Return self > `value` . With arguments `/`.", "question_id": 1588},
{"snippet": "polynomial.polynomial.polyvander(x, deg)", "intent": "Vandermonde matrix of given degree . Returns the Vandermonde matrix of degree `deg` and sample points `x` .", "question_id": 1589},
{"snippet": "lib.format.read_magic(fp)", "intent": "Read the magic string to get the version of the file format . With arguments `fp`.", "question_id": 1590},
{"snippet": "char.array(obj)", "intent": "Create a chararray . With arguments `obj`.", "question_id": 1591},
{"snippet": "char.array(obj, itemsize=None)", "intent": "Create a chararray . With arguments `obj`, `itemsize`.", "question_id": 1592},
{"snippet": "char.array(obj, copy=True)", "intent": "Create a chararray . With arguments `obj`, `copy`.", "question_id": 1593},
{"snippet": "char.array(obj, unicode=None)", "intent": "Create a chararray . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`.", "question_id": 1594},
{"snippet": "char.array(obj, order=None)", "intent": "Create a chararray . With arguments `obj`, `order`.", "question_id": 1595},
{"snippet": "char.array(obj, itemsize=None, copy=True)", "intent": "Create a chararray . With arguments `obj`, `itemsize`, `copy`.", "question_id": 1596},
{"snippet": "char.array(obj, itemsize=None, unicode=None)", "intent": "Create a chararray . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`, `itemsize`.", "question_id": 1597},
{"snippet": "char.array(obj, itemsize=None, order=None)", "intent": "Create a chararray . With arguments `obj`, `itemsize`, `order`.", "question_id": 1598},
{"snippet": "char.array(obj, copy=True, unicode=None)", "intent": "Create a chararray . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`, `copy`.", "question_id": 1599},
{"snippet": "char.array(obj, copy=True, order=None)", "intent": "Create a chararray . With arguments `obj`, `copy`, `order`.", "question_id": 1600},
{"snippet": "broadcast.size", "intent": "Total size of broadcasted result.", "question_id": 1601},
{"snippet": "numpy.select(condlist, choicelist)", "intent": "Return an array drawn from elements in `choicelist` , depending on conditions . With arguments `condlist`.", "question_id": 1602},
{"snippet": "numpy.select(condlist, choicelist, default=0)", "intent": "Return an array drawn from elements in `choicelist` , depending on conditions . With arguments `condlist`, `default`.", "question_id": 1603},
{"snippet": "ndarray.sum()", "intent": "Return the sum of the array elements over the given `axis` .", "question_id": 1604},
{"snippet": "ndarray.sum(axis=None)", "intent": "Return the sum of the array elements over the given `axis` .", "question_id": 1605},
{"snippet": "ndarray.sum(dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 1606},
{"snippet": "ndarray.sum(out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`.", "question_id": 1607},
{"snippet": "ndarray.sum(keepdims=False)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`.", "question_id": 1608},
{"snippet": "ndarray.sum(initial=0)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `initial`.", "question_id": 1609},
{"snippet": "ndarray.sum(where=True)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `where`.", "question_id": 1610},
{"snippet": "ndarray.sum(axis=None, dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 1611},
{"snippet": "ndarray.sum(axis=None, out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`.", "question_id": 1612},
{"snippet": "ndarray.sum(axis=None, keepdims=False)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`.", "question_id": 1613},
{"snippet": "nditer.enable_external_loop()", "intent": "When the \u201c external_loop \u201d was not used during construction , but is desired , this modifies the iterator to behave as if the flag was specified .", "question_id": 1614},
{"snippet": "char.join(sep, seq)", "intent": "Return a string which is the concatenation of the strings in the sequence `seq` . With arguments `sep`.", "question_id": 1615},
{"snippet": "ma.MaskType.flatten()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 1616},
{"snippet": "ma.MaskType.setfield()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 1617},
{"snippet": "numpy.arange(start, stop, step)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . When using a non-integer `step` , such as 0.1 , the results will often not be consistent .", "question_id": 1618},
{"snippet": "numpy.arange(start, stop, step, dtype=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . When using a non-integer `step` , such as 0.1 , the results will often not be consistent . With arguments `dtype`.", "question_id": 1619},
{"snippet": "numpy.arange(start, stop, step, like=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . When using a non-integer `step` , such as 0.1 , the results will often not be consistent . With arguments `like`.", "question_id": 1620},
{"snippet": "numpy.arange(start, stop, step, dtype=None, like=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . When using a non-integer `step` , such as 0.1 , the results will often not be consistent . With arguments `dtype`, `like`.", "question_id": 1621},
{"snippet": "numpy.arange(start, stop)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) .", "question_id": 1622},
{"snippet": "numpy.arange(start, stop, dtype=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . With arguments `dtype`.", "question_id": 1623},
{"snippet": "numpy.arange(start, stop, like=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . With arguments `like`.", "question_id": 1624},
{"snippet": "numpy.arange(start, stop, dtype=None, like=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . With arguments `dtype`, `like`.", "question_id": 1625},
{"snippet": "numpy.arange(start)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) .", "question_id": 1626},
{"snippet": "numpy.arange(start, dtype=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . With arguments `dtype`.", "question_id": 1627},
{"snippet": "numpy.arange(start, like=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . With arguments `like`.", "question_id": 1628},
{"snippet": "numpy.arange(start, dtype=None, like=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . With arguments `dtype`, `like`.", "question_id": 1629},
{"snippet": "ma.MaskedArray.tobytes()", "intent": "Return the array data as a string containing the raw bytes in the array .", "question_id": 1630},
{"snippet": "ma.MaskedArray.tobytes(fill_value=None)", "intent": "Return the array data as a string containing the raw bytes in the array . As for ndarray.tobytes , information about the shape , dtype , etc. , but also about `fill_value` , will be lost .", "question_id": 1631},
{"snippet": "ma.MaskedArray.tobytes(order='C')", "intent": "Return the array data as a string containing the raw bytes in the array . With arguments `order`.", "question_id": 1632},
{"snippet": "ma.MaskedArray.tobytes(fill_value=None, order='C')", "intent": "Return the array data as a string containing the raw bytes in the array . As for ndarray.tobytes , information about the shape , dtype , etc. , but also about `fill_value` , will be lost . With arguments `order`.", "question_id": 1633},
{"snippet": "numpy.mean(a)", "intent": "Compute the arithmetic mean along the specified `axis` . Specifying `a` higher-precision accumulator using the `dtype` keyword can alleviate this issue .", "question_id": 1634},
{"snippet": "numpy.mean(a, axis=None)", "intent": "Compute the arithmetic mean along the specified `axis` . Specifying `a` higher-precision accumulator using the `dtype` keyword can alleviate this issue .", "question_id": 1635},
{"snippet": "numpy.mean(a, dtype=None)", "intent": "Compute the arithmetic mean along the specified `axis` . Specifying `a` higher-precision accumulator using the `dtype` keyword can alleviate this issue .", "question_id": 1636},
{"snippet": "numpy.mean(a, out=None)", "intent": "Compute the arithmetic mean along the specified `axis` . Specifying `a` higher-precision accumulator using the `dtype` keyword can alleviate this issue . With arguments `out`.", "question_id": 1637},
{"snippet": "numpy.mean(a, keepdims=<no value>)", "intent": "Compute the arithmetic mean along the specified `axis` . Specifying `a` higher-precision accumulator using the `dtype` keyword can alleviate this issue . With arguments `keepdims`.", "question_id": 1638},
{"snippet": "numpy.mean(a, where=<no value>)", "intent": "Compute the arithmetic mean along the specified `axis` . Specifying `a` higher-precision accumulator using the `dtype` keyword can alleviate this issue . Specifying a `where` argument : > > > a = np.array ( [ [ 5 , 9 , 13 ] , [ 14 , 10 , 12 ] , [ 11 , 15 , 19 ] ] ) > > > np.mean ( a ) 12.0 > > > np.mean ( a , where= [ [ True ] , [ False ] , [ False ] ] ) 9.0", "question_id": 1639},
{"snippet": "numpy.mean(a, axis=None, dtype=None)", "intent": "Compute the arithmetic mean along the specified `axis` . Specifying `a` higher-precision accumulator using the `dtype` keyword can alleviate this issue .", "question_id": 1640},
{"snippet": "numpy.mean(a, axis=None, out=None)", "intent": "Compute the arithmetic mean along the specified `axis` . Specifying `a` higher-precision accumulator using the `dtype` keyword can alleviate this issue . With arguments `out`.", "question_id": 1641},
{"snippet": "numpy.mean(a, axis=None, keepdims=<no value>)", "intent": "Compute the arithmetic mean along the specified `axis` . Specifying `a` higher-precision accumulator using the `dtype` keyword can alleviate this issue . With arguments `keepdims`.", "question_id": 1642},
{"snippet": "numpy.mean(a, axis=None, where=<no value>)", "intent": "Compute the arithmetic mean along the specified `axis` . Specifying `a` higher-precision accumulator using the `dtype` keyword can alleviate this issue . Specifying a `where` argument : > > > a = np.array ( [ [ 5 , 9 , 13 ] , [ 14 , 10 , 12 ] , [ 11 , 15 , 19 ] ] ) > > > np.mean ( a ) 12.0 > > > np.mean ( a , where= [ [ True ] , [ False ] , [ False ] ] ) 9.0", "question_id": 1643},
{"snippet": "ndarray.take(indices)", "intent": "Return an array formed from the elements of a at the given `indices` .", "question_id": 1644},
{"snippet": "ndarray.take(indices, axis=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`.", "question_id": 1645},
{"snippet": "ndarray.take(indices, out=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `out`.", "question_id": 1646},
{"snippet": "ndarray.take(indices, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `mode`.", "question_id": 1647},
{"snippet": "ndarray.take(indices, axis=None, out=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `out`.", "question_id": 1648},
{"snippet": "ndarray.take(indices, axis=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `mode`.", "question_id": 1649},
{"snippet": "ndarray.take(indices, out=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `out`, `mode`.", "question_id": 1650},
{"snippet": "ndarray.take(indices, axis=None, out=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `out`, `mode`.", "question_id": 1651},
{"snippet": "ma.identity(n)", "intent": "Return the identity array . With arguments `n`.", "question_id": 1652},
{"snippet": "ma.identity(n, dtype=None)", "intent": "Return the identity array . With arguments `n`, `dtype`.", "question_id": 1653},
{"snippet": "chararray.choose(choices)", "intent": "Use an index array to construct a new array from a set of `choices` .", "question_id": 1654},
{"snippet": "chararray.choose(choices, out=None)", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`.", "question_id": 1655},
{"snippet": "chararray.choose(choices, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `mode`.", "question_id": 1656},
{"snippet": "chararray.choose(choices, out=None, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`, `mode`.", "question_id": 1657},
{"snippet": "distutils.exec_command.filepath_from_subprocess_output(output)", "intent": "Convert bytes in the encoding used by a subprocess into a filesystem-appropriate str . With arguments `output`.", "question_id": 1658},
{"snippet": "ma.MaskedArray.__new__(cls)", "intent": "Create a new masked array from scratch . With arguments `cls`.", "question_id": 1659},
{"snippet": "ma.MaskedArray.__new__(cls, data=None)", "intent": "Create a new masked array from scratch . With arguments `cls`, `data`.", "question_id": 1660},
{"snippet": "ma.MaskedArray.__new__(cls, mask=False)", "intent": "Create a new masked array from scratch . With arguments `cls`, `mask`.", "question_id": 1661},
{"snippet": "ma.MaskedArray.__new__(cls, dtype=None)", "intent": "Create a new masked array from scratch . With arguments `cls`, `dtype`.", "question_id": 1662},
{"snippet": "ma.MaskedArray.__new__(cls, copy=False)", "intent": "Create a new masked array from scratch . With arguments `cls`, `copy`.", "question_id": 1663},
{"snippet": "ma.MaskedArray.__new__(cls, subok=True)", "intent": "Create a new masked array from scratch . With arguments `cls`, `subok`.", "question_id": 1664},
{"snippet": "ma.MaskedArray.__new__(cls, ndmin=0)", "intent": "Create a new masked array from scratch . With arguments `cls`, `ndmin`.", "question_id": 1665},
{"snippet": "ma.MaskedArray.__new__(cls, fill_value=None)", "intent": "Create a new masked array from scratch . With arguments `cls`, `fill_value`.", "question_id": 1666},
{"snippet": "ma.MaskedArray.__new__(cls, keep_mask=True)", "intent": "Create a new masked array from scratch . With arguments `cls`, `keep_mask`.", "question_id": 1667},
{"snippet": "ma.MaskedArray.__new__(cls, hard_mask=None)", "intent": "Create a new masked array from scratch . With arguments `cls`, `hard_mask`.", "question_id": 1668},
{"snippet": "ma.masked_array.conjugate()", "intent": "Return the complex conjugate , element-wise .", "question_id": 1669},
{"snippet": "testing.assert_warns(warning_class, *args, **kwargs)", "intent": "Fail unless the given callable throws the specified warning . A warning of class `warning_class` should be thrown by the callable when invoked with arguments args and keyword arguments kwargs . With arguments `*args`, `**kwargs`.", "question_id": 1670},
{"snippet": "recarray.repeat(repeats)", "intent": "Repeat elements of an array . With arguments `repeats`.", "question_id": 1671},
{"snippet": "recarray.repeat(repeats, axis=None)", "intent": "Repeat elements of an array . With arguments `repeats`, `axis`.", "question_id": 1672},
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, extobj)", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `extobj`.", "question_id": 1673},
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, extobj, out=None)", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 1674},
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, extobj, where=True)", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 1675},
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 1676},
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, extobj, order='K')", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 1677},
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, extobj, dtype=None)", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 1678},
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, extobj, subok=True)", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 1679},
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 1680},
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 1681},
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 1682},
{"snippet": "numpy.logaddexp2(x1, x2, /, signature)", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`.", "question_id": 1683},
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, out=None)", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `out`.", "question_id": 1684},
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, where=True)", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `where`.", "question_id": 1685},
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, casting='same_kind')", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `casting`.", "question_id": 1686},
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, order='K')", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `order`.", "question_id": 1687},
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, dtype=None)", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `dtype`.", "question_id": 1688},
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, subok=True)", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `subok`.", "question_id": 1689},
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, out=None, where=True)", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `out`, `where`.", "question_id": 1690},
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 1691},
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, out=None, order='K')", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `out`, `order`.", "question_id": 1692},
{"snippet": "chararray.data", "intent": "Python buffer object pointing to the start of the array\u2019s data.", "question_id": 1693},
{"snippet": "numpy.positive(x, /, signature, extobj)", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `extobj`.", "question_id": 1694},
{"snippet": "numpy.positive(x, /, signature, extobj, out=None)", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`.", "question_id": 1695},
{"snippet": "numpy.positive(x, /, signature, extobj, where=True)", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `where`.", "question_id": 1696},
{"snippet": "numpy.positive(x, /, signature, extobj, casting='same_kind')", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `casting`.", "question_id": 1697},
{"snippet": "numpy.positive(x, /, signature, extobj, order='K')", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `order`.", "question_id": 1698},
{"snippet": "numpy.positive(x, /, signature, extobj, dtype=None)", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `dtype`.", "question_id": 1699},
{"snippet": "numpy.positive(x, /, signature, extobj, subok=True)", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `subok`.", "question_id": 1700},
{"snippet": "numpy.positive(x, /, signature, extobj, out=None, where=True)", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 1701},
{"snippet": "numpy.positive(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 1702},
{"snippet": "numpy.positive(x, /, signature, extobj, out=None, order='K')", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 1703},
{"snippet": "numpy.positive(x, /, signature)", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`.", "question_id": 1704},
{"snippet": "numpy.positive(x, /, signature, out=None)", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `out`.", "question_id": 1705},
{"snippet": "numpy.positive(x, /, signature, where=True)", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `where`.", "question_id": 1706},
{"snippet": "numpy.positive(x, /, signature, casting='same_kind')", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `casting`.", "question_id": 1707},
{"snippet": "numpy.positive(x, /, signature, order='K')", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `order`.", "question_id": 1708},
{"snippet": "numpy.positive(x, /, signature, dtype=None)", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `dtype`.", "question_id": 1709},
{"snippet": "numpy.positive(x, /, signature, subok=True)", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `subok`.", "question_id": 1710},
{"snippet": "numpy.positive(x, /, signature, out=None, where=True)", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `out`, `where`.", "question_id": 1711},
{"snippet": "numpy.positive(x, /, signature, out=None, casting='same_kind')", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `out`, `casting`.", "question_id": 1712},
{"snippet": "numpy.positive(x, /, signature, out=None, order='K')", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `out`, `order`.", "question_id": 1713},
{"snippet": "chararray.imag", "intent": "The imaginary part of the array.", "question_id": 1714},
{"snippet": "polynomial.laguerre.Laguerre.trim()", "intent": "Remove trailing coefficients", "question_id": 1715},
{"snippet": "polynomial.laguerre.Laguerre.trim(tol=0)", "intent": "Remove trailing coefficients Remove trailing coefficients until a coefficient is reached whose absolute value greater than `tol` or the beginning of the series is reached .", "question_id": 1716},
{"snippet": "memmap.size", "intent": "Number of elements in the array.", "question_id": 1717},
{"snippet": "ma.masked_array.setflags()", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively .", "question_id": 1718},
{"snippet": "ma.masked_array.setflags(write=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`.", "question_id": 1719},
{"snippet": "ma.masked_array.setflags(align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`.", "question_id": 1720},
{"snippet": "ma.masked_array.setflags(uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `uic`.", "question_id": 1721},
{"snippet": "ma.masked_array.setflags(write=None, align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`.", "question_id": 1722},
{"snippet": "ma.masked_array.setflags(write=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `uic`.", "question_id": 1723},
{"snippet": "ma.masked_array.setflags(align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`, `uic`.", "question_id": 1724},
{"snippet": "ma.masked_array.setflags(write=None, align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`, `uic`.", "question_id": 1725},
{"snippet": "chararray.rindex(sub)", "intent": "Like rfind , but raises ValueError when the substring `sub` is not found .", "question_id": 1726},
{"snippet": "chararray.rindex(sub, start=0)", "intent": "Like rfind , but raises ValueError when the substring `sub` is not found . With arguments `start`.", "question_id": 1727},
{"snippet": "chararray.rindex(sub, end=None)", "intent": "Like rfind , but raises ValueError when the substring `sub` is not found . With arguments `end`.", "question_id": 1728},
{"snippet": "chararray.rindex(sub, start=0, end=None)", "intent": "Like rfind , but raises ValueError when the substring `sub` is not found . With arguments `start`, `end`.", "question_id": 1729},
{"snippet": "ndarray.__repr__(/)", "intent": "Return repr ( self ) . With arguments `/`.", "question_id": 1730},
{"snippet": "ma.MaskedArray.ptp()", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e .", "question_id": 1731},
{"snippet": "ma.MaskedArray.ptp(axis=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `axis`.", "question_id": 1732},
{"snippet": "ma.MaskedArray.ptp(out=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `out`.", "question_id": 1733},
{"snippet": "ma.MaskedArray.ptp(fill_value=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `fill_value`.", "question_id": 1734},
{"snippet": "ma.MaskedArray.ptp(keepdims=False)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `keepdims`.", "question_id": 1735},
{"snippet": "ma.MaskedArray.ptp(axis=None, out=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `axis`, `out`.", "question_id": 1736},
{"snippet": "ma.MaskedArray.ptp(axis=None, fill_value=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `axis`, `fill_value`.", "question_id": 1737},
{"snippet": "ma.MaskedArray.ptp(axis=None, keepdims=False)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `axis`, `keepdims`.", "question_id": 1738},
{"snippet": "ma.MaskedArray.ptp(out=None, fill_value=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `out`, `fill_value`.", "question_id": 1739},
{"snippet": "ma.MaskedArray.ptp(out=None, keepdims=False)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `out`, `keepdims`.", "question_id": 1740},
{"snippet": "polynomial.polyutils.RankWarning", "intent": "Issued by chebfit when the design matrix is rank deficient.", "question_id": 1741},
{"snippet": "random.random_integers(low)", "intent": "Random integers of type np.int_ between `low` and `high` , inclusive .", "question_id": 1742},
{"snippet": "random.random_integers(low, high=None)", "intent": "Random integers of type np.int_ between `low` and `high` , inclusive .", "question_id": 1743},
{"snippet": "random.random_integers(low, size=None)", "intent": "Random integers of type np.int_ between `low` and `high` , inclusive . With arguments `size`.", "question_id": 1744},
{"snippet": "random.random_integers(low, high=None, size=None)", "intent": "Random integers of type np.int_ between `low` and `high` , inclusive . With arguments `size`.", "question_id": 1745},
{"snippet": "matrix.sort()", "intent": "Sort an array in-place .", "question_id": 1746},
{"snippet": "matrix.sort(axis=- 1)", "intent": "Sort an array in-place . With arguments `axis`.", "question_id": 1747},
{"snippet": "matrix.sort(kind=None)", "intent": "Sort an array in-place . With arguments `kind`.", "question_id": 1748},
{"snippet": "matrix.sort(order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array :", "question_id": 1749},
{"snippet": "matrix.sort(axis=- 1, kind=None)", "intent": "Sort an array in-place . With arguments `axis`, `kind`.", "question_id": 1750},
{"snippet": "matrix.sort(axis=- 1, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `axis`.", "question_id": 1751},
{"snippet": "matrix.sort(kind=None, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `kind`.", "question_id": 1752},
{"snippet": "matrix.sort(axis=- 1, kind=None, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `axis`, `kind`.", "question_id": 1753},
{"snippet": "ma.MaskType.put()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 1754},
{"snippet": "recarray.base", "intent": "Base object if memory is from some other object.", "question_id": 1755},
{"snippet": "numpy.full_like(a, fill_value)", "intent": "Return `a` full array with the same `shape` and type as a given array . With arguments `fill_value`.", "question_id": 1756},
{"snippet": "numpy.full_like(a, fill_value, dtype=None)", "intent": "Return `a` full array with the same `shape` and type as a given array . With arguments `fill_value`, `dtype`.", "question_id": 1757},
{"snippet": "numpy.full_like(a, fill_value, order='K')", "intent": "Return `a` full array with the same `shape` and type as a given array . With arguments `fill_value`, `order`.", "question_id": 1758},
{"snippet": "numpy.full_like(a, fill_value, subok=True)", "intent": "Return `a` full array with the same `shape` and type as a given array . With arguments `fill_value`, `subok`.", "question_id": 1759},
{"snippet": "numpy.full_like(a, fill_value, shape=None)", "intent": "Return `a` full array with the same `shape` and type as a given array . With arguments `fill_value`.", "question_id": 1760},
{"snippet": "numpy.full_like(a, fill_value, dtype=None, order='K')", "intent": "Return `a` full array with the same `shape` and type as a given array . With arguments `fill_value`, `dtype`, `order`.", "question_id": 1761},
{"snippet": "numpy.full_like(a, fill_value, dtype=None, subok=True)", "intent": "Return `a` full array with the same `shape` and type as a given array . With arguments `fill_value`, `dtype`, `subok`.", "question_id": 1762},
{"snippet": "numpy.full_like(a, fill_value, dtype=None, shape=None)", "intent": "Return `a` full array with the same `shape` and type as a given array . With arguments `fill_value`, `dtype`.", "question_id": 1763},
{"snippet": "numpy.full_like(a, fill_value, order='K', subok=True)", "intent": "Return `a` full array with the same `shape` and type as a given array . With arguments `fill_value`, `order`, `subok`.", "question_id": 1764},
{"snippet": "numpy.full_like(a, fill_value, order='K', shape=None)", "intent": "Return `a` full array with the same `shape` and type as a given array . With arguments `fill_value`, `order`.", "question_id": 1765},
{"snippet": "polynomial.hermite.Hermite.__call__(arg)", "intent": "Call self as a function . With arguments `arg`.", "question_id": 1766},
{"snippet": "generic.data", "intent": "Pointer to start of data.", "question_id": 1767},
{"snippet": "char.isdigit(a)", "intent": "Returns true for each element if all characters in the string are digits and there is at least one character , false otherwise . With arguments `a`.", "question_id": 1768},
{"snippet": "polynomial.polynomial.polyval(x, c)", "intent": "Evaluate a polynomial at points `x` . If `c` is of length n + 1 , this function returns the value", "question_id": 1769},
{"snippet": "polynomial.polynomial.polyval(x, c, tensor=True)", "intent": "Evaluate a polynomial at points `x` . If `c` is of length n + 1 , this function returns the value If c is multidimensional , then the shape of the result depends on the value of `tensor` .", "question_id": 1770},
{"snippet": "char.chararray.real", "intent": "The real part of the array.", "question_id": 1771},
{"snippet": "ma.masked_array.trace()", "intent": "Return the sum along diagonals of the array .", "question_id": 1772},
{"snippet": "ma.masked_array.trace(offset=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`.", "question_id": 1773},
{"snippet": "ma.masked_array.trace(axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `axis1`.", "question_id": 1774},
{"snippet": "ma.masked_array.trace(axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `axis2`.", "question_id": 1775},
{"snippet": "ma.masked_array.trace(dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `dtype`.", "question_id": 1776},
{"snippet": "ma.masked_array.trace(out=None)", "intent": "Return the sum along diagonals of the array . With arguments `out`.", "question_id": 1777},
{"snippet": "ma.masked_array.trace(offset=0, axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis1`.", "question_id": 1778},
{"snippet": "ma.masked_array.trace(offset=0, axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis2`.", "question_id": 1779},
{"snippet": "ma.masked_array.trace(offset=0, dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `dtype`.", "question_id": 1780},
{"snippet": "ma.masked_array.trace(offset=0, out=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `out`.", "question_id": 1781},
{"snippet": "ma.masked_array.dot(b)", "intent": "Masked dot product of two arrays . With arguments `b`.", "question_id": 1782},
{"snippet": "ma.masked_array.dot(b, out=None)", "intent": "Masked dot product of two arrays . Note that `out` and strict are located in different positions than in ma.dot . With arguments `b`.", "question_id": 1783},
{"snippet": "numpy.geterr()", "intent": "Get the current way of handling floating-point errors .", "question_id": 1784},
{"snippet": "random.Generator.normal()", "intent": "Draw random samples from a normal ( Gaussian ) distribution .", "question_id": 1785},
{"snippet": "random.Generator.normal(loc=0.0)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `loc`.", "question_id": 1786},
{"snippet": "random.Generator.normal(scale=1.0)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `scale`.", "question_id": 1787},
{"snippet": "random.Generator.normal(size=None)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `size`.", "question_id": 1788},
{"snippet": "random.Generator.normal(loc=0.0, scale=1.0)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `loc`, `scale`.", "question_id": 1789},
{"snippet": "random.Generator.normal(loc=0.0, size=None)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `loc`, `size`.", "question_id": 1790},
{"snippet": "random.Generator.normal(scale=1.0, size=None)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `scale`, `size`.", "question_id": 1791},
{"snippet": "random.Generator.normal(loc=0.0, scale=1.0, size=None)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `loc`, `scale`, `size`.", "question_id": 1792},
{"snippet": "recarray.view(dtype, type)", "intent": "New view of array with the same data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) Viewing array data using a different `type` and dtype :", "question_id": 1793},
{"snippet": "recarray.view(dtype)", "intent": "New view of array with the same data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . )", "question_id": 1794},
{"snippet": "recarray.view()", "intent": "New view of array with the same data .", "question_id": 1795},
{"snippet": "numpy.nextafter(x1, x2, /, signature, extobj)", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `extobj`.", "question_id": 1796},
{"snippet": "numpy.nextafter(x1, x2, /, signature, extobj, out=None)", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 1797},
{"snippet": "numpy.nextafter(x1, x2, /, signature, extobj, where=True)", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 1798},
{"snippet": "numpy.nextafter(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 1799},
{"snippet": "numpy.nextafter(x1, x2, /, signature, extobj, order='K')", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 1800},
{"snippet": "numpy.nextafter(x1, x2, /, signature, extobj, dtype=None)", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 1801},
{"snippet": "numpy.nextafter(x1, x2, /, signature, extobj, subok=True)", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 1802},
{"snippet": "numpy.nextafter(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 1803},
{"snippet": "numpy.nextafter(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 1804},
{"snippet": "numpy.nextafter(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 1805},
{"snippet": "numpy.nextafter(x1, x2, /, signature)", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`.", "question_id": 1806},
{"snippet": "numpy.nextafter(x1, x2, /, signature, out=None)", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `out`.", "question_id": 1807},
{"snippet": "numpy.nextafter(x1, x2, /, signature, where=True)", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `where`.", "question_id": 1808},
{"snippet": "numpy.nextafter(x1, x2, /, signature, casting='same_kind')", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `casting`.", "question_id": 1809},
{"snippet": "numpy.nextafter(x1, x2, /, signature, order='K')", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `order`.", "question_id": 1810},
{"snippet": "numpy.nextafter(x1, x2, /, signature, dtype=None)", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `dtype`.", "question_id": 1811},
{"snippet": "numpy.nextafter(x1, x2, /, signature, subok=True)", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `subok`.", "question_id": 1812},
{"snippet": "numpy.nextafter(x1, x2, /, signature, out=None, where=True)", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `out`, `where`.", "question_id": 1813},
{"snippet": "numpy.nextafter(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 1814},
{"snippet": "numpy.nextafter(x1, x2, /, signature, out=None, order='K')", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `out`, `order`.", "question_id": 1815},
{"snippet": "numpy.invert(x, /, signature, extobj)", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `extobj`.", "question_id": 1816},
{"snippet": "numpy.invert(x, /, signature, extobj, out=None)", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`.", "question_id": 1817},
{"snippet": "numpy.invert(x, /, signature, extobj, where=True)", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `where`.", "question_id": 1818},
{"snippet": "numpy.invert(x, /, signature, extobj, casting='same_kind')", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `casting`.", "question_id": 1819},
{"snippet": "numpy.invert(x, /, signature, extobj, order='K')", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `order`.", "question_id": 1820},
{"snippet": "numpy.invert(x, /, signature, extobj, dtype=None)", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `dtype`.", "question_id": 1821},
{"snippet": "numpy.invert(x, /, signature, extobj, subok=True)", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `subok`.", "question_id": 1822},
{"snippet": "numpy.invert(x, /, signature, extobj, out=None, where=True)", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 1823},
{"snippet": "numpy.invert(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 1824},
{"snippet": "numpy.invert(x, /, signature, extobj, out=None, order='K')", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 1825},
{"snippet": "numpy.invert(x, /, signature)", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`.", "question_id": 1826},
{"snippet": "numpy.invert(x, /, signature, out=None)", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `out`.", "question_id": 1827},
{"snippet": "numpy.invert(x, /, signature, where=True)", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `where`.", "question_id": 1828},
{"snippet": "numpy.invert(x, /, signature, casting='same_kind')", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `casting`.", "question_id": 1829},
{"snippet": "numpy.invert(x, /, signature, order='K')", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `order`.", "question_id": 1830},
{"snippet": "numpy.invert(x, /, signature, dtype=None)", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `dtype`.", "question_id": 1831},
{"snippet": "numpy.invert(x, /, signature, subok=True)", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `subok`.", "question_id": 1832},
{"snippet": "numpy.invert(x, /, signature, out=None, where=True)", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `out`, `where`.", "question_id": 1833},
{"snippet": "numpy.invert(x, /, signature, out=None, casting='same_kind')", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `out`, `casting`.", "question_id": 1834},
{"snippet": "numpy.invert(x, /, signature, out=None, order='K')", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `out`, `order`.", "question_id": 1835},
{"snippet": "ma.masked_array.byteswap()", "intent": "Swap the bytes of the array elements", "question_id": 1836},
{"snippet": "ma.masked_array.byteswap(inplace=False)", "intent": "Swap the bytes of the array elements With arguments `inplace`.", "question_id": 1837},
{"snippet": "polynomial.chebyshev.chebadd(c1, c2)", "intent": "Add one Chebyshev series to another . Returns the sum of two Chebyshev series `c1` + `c2` .", "question_id": 1838},
{"snippet": "numpy.packbits(a)", "intent": "Packs the elements of `a` binary-valued array into bits in a uint8 array .", "question_id": 1839},
{"snippet": "numpy.packbits(a, axis=None)", "intent": "Packs the elements of `a` binary-valued array into bits in a uint8 array . With arguments `axis`.", "question_id": 1840},
{"snippet": "numpy.packbits(a, bitorder='big')", "intent": "Packs the elements of `a` binary-valued array into bits in a uint8 array . With arguments `bitorder`.", "question_id": 1841},
{"snippet": "numpy.packbits(a, axis=None, bitorder='big')", "intent": "Packs the elements of `a` binary-valued array into bits in a uint8 array . With arguments `axis`, `bitorder`.", "question_id": 1842},
{"snippet": "record.setflags()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 1843},
{"snippet": "polynomial.chebyshev.chebgrid3d(x, y, z, c)", "intent": "Evaluate a 3-D Chebyshev series on the Cartesian product of `x` , `y` , and `z` . where the points ( a , b , `c` ) consist of all triples formed by taking a from x , b from y , and c from z .", "question_id": 1844},
{"snippet": "matrix.flatten()", "intent": "Return a flattened copy of the matrix .", "question_id": 1845},
{"snippet": "matrix.flatten(order='C')", "intent": "Return a flattened copy of the matrix . With arguments `order`.", "question_id": 1846},
{"snippet": "random.RandomState.randint(low)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) .", "question_id": 1847},
{"snippet": "random.RandomState.randint(low, high=None)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) .", "question_id": 1848},
{"snippet": "random.RandomState.randint(low, size=None)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . With arguments `size`.", "question_id": 1849},
{"snippet": "random.RandomState.randint(low, dtype=int)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . Return random integers from the \u201c discrete uniform \u201d distribution of the specified `dtype` in the \u201c half-open \u201d interval [ low , high ) .", "question_id": 1850},
{"snippet": "random.RandomState.randint(low, high=None, size=None)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . With arguments `size`.", "question_id": 1851},
{"snippet": "random.RandomState.randint(low, high=None, dtype=int)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . Return random integers from the \u201c discrete uniform \u201d distribution of the specified `dtype` in the \u201c half-open \u201d interval [ low , high ) .", "question_id": 1852},
{"snippet": "random.RandomState.randint(low, size=None, dtype=int)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . Return random integers from the \u201c discrete uniform \u201d distribution of the specified `dtype` in the \u201c half-open \u201d interval [ low , high ) . With arguments `size`.", "question_id": 1853},
{"snippet": "random.RandomState.randint(low, high=None, size=None, dtype=int)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . Return random integers from the \u201c discrete uniform \u201d distribution of the specified `dtype` in the \u201c half-open \u201d interval [ low , high ) . With arguments `size`.", "question_id": 1854},
{"snippet": "recarray.round()", "intent": "Return a with each element rounded to the given number of `decimals` .", "question_id": 1855},
{"snippet": "recarray.round(decimals=0)", "intent": "Return a with each element rounded to the given number of `decimals` .", "question_id": 1856},
{"snippet": "recarray.round(out=None)", "intent": "Return a with each element rounded to the given number of `decimals` . With arguments `out`.", "question_id": 1857},
{"snippet": "recarray.round(decimals=0, out=None)", "intent": "Return a with each element rounded to the given number of `decimals` . With arguments `out`.", "question_id": 1858},
{"snippet": "numpy.place(arr, mask, vals)", "intent": "Change elements of an array based on conditional and input values . Similar to np.copyto ( `arr` , `vals` , where=mask ) , the difference is that place uses the first N elements of vals , where N is the number of True values in `mask` , while copyto uses the elements where mask is True .", "question_id": 1859},
{"snippet": "numpy.geterrobj()", "intent": "Return the current object that defines floating-point error handling .", "question_id": 1860},
{"snippet": "dtype.itemsize", "intent": "The element size of this data-type object.", "question_id": 1861},
{"snippet": "char.rsplit(a)", "intent": "For each element in `a` , return a list of the words in the string , using `sep` as the delimiter string .", "question_id": 1862},
{"snippet": "char.rsplit(a, sep=None)", "intent": "For each element in `a` , return a list of the words in the string , using `sep` as the delimiter string .", "question_id": 1863},
{"snippet": "char.rsplit(a, maxsplit=None)", "intent": "For each element in `a` , return a list of the words in the string , using `sep` as the delimiter string . With arguments `maxsplit`.", "question_id": 1864},
{"snippet": "char.rsplit(a, sep=None, maxsplit=None)", "intent": "For each element in `a` , return a list of the words in the string , using `sep` as the delimiter string . With arguments `maxsplit`.", "question_id": 1865},
{"snippet": "random.multinomial(n, pvals)", "intent": "Draw samples from a multinomial distribution . Each sample drawn from the distribution represents `n` such experiments . With arguments `pvals`.", "question_id": 1866},
{"snippet": "random.multinomial(n, pvals, size=None)", "intent": "Draw samples from a multinomial distribution . Each sample drawn from the distribution represents `n` such experiments . With arguments `pvals`, `size`.", "question_id": 1867},
{"snippet": "char.chararray.upper()", "intent": "Return an array with the elements of self converted to uppercase .", "question_id": 1868},
{"snippet": "ma.MaskedArray.__rtruediv__(other)", "intent": "Divide self into `other` , and return a new masked array .", "question_id": 1869},
{"snippet": "numpy.round_(a)", "intent": "Round an array to the given number of `decimals` . With arguments `a`.", "question_id": 1870},
{"snippet": "numpy.round_(a, decimals=0)", "intent": "Round an array to the given number of `decimals` . With arguments `a`.", "question_id": 1871},
{"snippet": "numpy.round_(a, out=None)", "intent": "Round an array to the given number of `decimals` . With arguments `a`, `out`.", "question_id": 1872},
{"snippet": "numpy.round_(a, decimals=0, out=None)", "intent": "Round an array to the given number of `decimals` . With arguments `a`, `out`.", "question_id": 1873},
{"snippet": "ma.MaskedArray.unshare_mask()", "intent": "Copy the mask and set the sharedmask flag to False .", "question_id": 1874},
{"snippet": "char.upper(a)", "intent": "Return an array with the elements converted to uppercase . With arguments `a`.", "question_id": 1875},
{"snippet": "random.ranf()", "intent": "This is an alias of random_sample .", "question_id": 1876},
{"snippet": "ndarray.imag", "intent": "The imaginary part of the array.", "question_id": 1877},
{"snippet": "numpy.concatenate((a1, a2, ...))", "intent": "Join a sequence of arrays along an existing `axis` . With arguments `(a1`, `a2`, `...)`.", "question_id": 1878},
{"snippet": "numpy.concatenate((a1, a2, ...), axis=0)", "intent": "Join a sequence of arrays along an existing `axis` . With arguments `(a1`, `a2`, `...)`.", "question_id": 1879},
{"snippet": "numpy.concatenate((a1, a2, ...), out=None)", "intent": "Join a sequence of arrays along an existing `axis` . With arguments `(a1`, `a2`, `...)`, `out`.", "question_id": 1880},
{"snippet": "numpy.concatenate((a1, a2, ...), dtype=None)", "intent": "Join a sequence of arrays along an existing `axis` . With arguments `(a1`, `a2`, `...)`, `dtype`.", "question_id": 1881},
{"snippet": "numpy.concatenate((a1, a2, ...), casting=\"same_kind\")", "intent": "Join a sequence of arrays along an existing `axis` . With arguments `(a1`, `a2`, `...)`, `casting`.", "question_id": 1882},
{"snippet": "numpy.concatenate((a1, a2, ...), axis=0, out=None)", "intent": "Join a sequence of arrays along an existing `axis` . With arguments `(a1`, `a2`, `...)`, `out`.", "question_id": 1883},
{"snippet": "numpy.concatenate((a1, a2, ...), axis=0, dtype=None)", "intent": "Join a sequence of arrays along an existing `axis` . With arguments `(a1`, `a2`, `...)`, `dtype`.", "question_id": 1884},
{"snippet": "numpy.concatenate((a1, a2, ...), axis=0, casting=\"same_kind\")", "intent": "Join a sequence of arrays along an existing `axis` . With arguments `(a1`, `a2`, `...)`, `casting`.", "question_id": 1885},
{"snippet": "numpy.concatenate((a1, a2, ...), out=None, dtype=None)", "intent": "Join a sequence of arrays along an existing `axis` . With arguments `(a1`, `a2`, `...)`, `out`, `dtype`.", "question_id": 1886},
{"snippet": "numpy.concatenate((a1, a2, ...), out=None, casting=\"same_kind\")", "intent": "Join a sequence of arrays along an existing `axis` . With arguments `(a1`, `a2`, `...)`, `out`, `casting`.", "question_id": 1887},
{"snippet": "numpy.tril(m)", "intent": "Lower triangle of an array . With arguments `m`.", "question_id": 1888},
{"snippet": "numpy.tril(m, k=0)", "intent": "Lower triangle of an array . With arguments `m`, `k`.", "question_id": 1889},
{"snippet": "polynomial.polynomial.polypow(c, pow)", "intent": "Raise a polynomial to a power . Returns the polynomial `c` raised to the power `pow` .", "question_id": 1890},
{"snippet": "polynomial.polynomial.polypow(c, pow, maxpower=None)", "intent": "Raise a polynomial to a power . Returns the polynomial `c` raised to the power `pow` . With arguments `maxpower`.", "question_id": 1891},
{"snippet": "matrix.flags", "intent": "Information about the memory layout of the array.", "question_id": 1892},
{"snippet": "char.chararray.dumps()", "intent": "Returns the pickle of the array as a string .", "question_id": 1893},
{"snippet": "char.chararray.tofile(fid)", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method .", "question_id": 1894},
{"snippet": "char.chararray.tofile(fid, sep='')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `sep`.", "question_id": 1895},
{"snippet": "char.chararray.tofile(fid, format='%s')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `format`.", "question_id": 1896},
{"snippet": "char.chararray.tofile(fid, sep='', format='%s')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `sep`, `format`.", "question_id": 1897},
{"snippet": "ndarray.setflags()", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively .", "question_id": 1898},
{"snippet": "ndarray.setflags(write=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`.", "question_id": 1899},
{"snippet": "ndarray.setflags(align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`.", "question_id": 1900},
{"snippet": "ndarray.setflags(uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `uic`.", "question_id": 1901},
{"snippet": "ndarray.setflags(write=None, align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`.", "question_id": 1902},
{"snippet": "ndarray.setflags(write=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `uic`.", "question_id": 1903},
{"snippet": "ndarray.setflags(align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`, `uic`.", "question_id": 1904},
{"snippet": "ndarray.setflags(write=None, align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`, `uic`.", "question_id": 1905},
{"snippet": "linalg.lstsq(a, b)", "intent": "Return the least-squares solution to `a` linear matrix equation . Computes the vector x that approximatively solves the equation a @ x = `b` .", "question_id": 1906},
{"snippet": "linalg.lstsq(a, b, rcond='warn')", "intent": "Return the least-squares solution to `a` linear matrix equation . Computes the vector x that approximatively solves the equation a @ x = `b` . With arguments `rcond`.", "question_id": 1907},
{"snippet": "matrix.reshape(shape)", "intent": "Returns an array containing the same data with a new `shape` .", "question_id": 1908},
{"snippet": "matrix.reshape(shape, order='C')", "intent": "Returns an array containing the same data with a new `shape` . With arguments `order`.", "question_id": 1909},
{"snippet": "polynomial.legendre.Legendre.has_samewindow(other)", "intent": "Check if windows match . With arguments `other`.", "question_id": 1910},
{"snippet": "ndarray.byteswap()", "intent": "Swap the bytes of the array elements", "question_id": 1911},
{"snippet": "ndarray.byteswap(inplace=False)", "intent": "Swap the bytes of the array elements With arguments `inplace`.", "question_id": 1912},
{"snippet": "numpy.maximum(x1, x2, /, signature, extobj)", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`.", "question_id": 1913},
{"snippet": "numpy.maximum(x1, x2, /, signature, extobj, out=None)", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 1914},
{"snippet": "numpy.maximum(x1, x2, /, signature, extobj, where=True)", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 1915},
{"snippet": "numpy.maximum(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 1916},
{"snippet": "numpy.maximum(x1, x2, /, signature, extobj, order='K')", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 1917},
{"snippet": "numpy.maximum(x1, x2, /, signature, extobj, dtype=None)", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 1918},
{"snippet": "numpy.maximum(x1, x2, /, signature, extobj, subok=True)", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 1919},
{"snippet": "numpy.maximum(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 1920},
{"snippet": "numpy.maximum(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 1921},
{"snippet": "numpy.maximum(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 1922},
{"snippet": "numpy.maximum(x1, x2, /, signature)", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`.", "question_id": 1923},
{"snippet": "numpy.maximum(x1, x2, /, signature, out=None)", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`.", "question_id": 1924},
{"snippet": "numpy.maximum(x1, x2, /, signature, where=True)", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `where`.", "question_id": 1925},
{"snippet": "numpy.maximum(x1, x2, /, signature, casting='same_kind')", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `casting`.", "question_id": 1926},
{"snippet": "numpy.maximum(x1, x2, /, signature, order='K')", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `order`.", "question_id": 1927},
{"snippet": "numpy.maximum(x1, x2, /, signature, dtype=None)", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `dtype`.", "question_id": 1928},
{"snippet": "numpy.maximum(x1, x2, /, signature, subok=True)", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `subok`.", "question_id": 1929},
{"snippet": "numpy.maximum(x1, x2, /, signature, out=None, where=True)", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`, `where`.", "question_id": 1930},
{"snippet": "numpy.maximum(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 1931},
{"snippet": "numpy.maximum(x1, x2, /, signature, out=None, order='K')", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`, `order`.", "question_id": 1932},
{"snippet": "ma.notmasked_contiguous(a)", "intent": "Find contiguous unmasked data in `a` masked array along the given `axis` .", "question_id": 1933},
{"snippet": "ma.notmasked_contiguous(a, axis=None)", "intent": "Find contiguous unmasked data in `a` masked array along the given `axis` .", "question_id": 1934},
{"snippet": "ma.masked_array.partition(kth)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array .", "question_id": 1935},
{"snippet": "ma.masked_array.partition(kth, axis=- 1)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`.", "question_id": 1936},
{"snippet": "ma.masked_array.partition(kth, kind='introselect')", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `kind`.", "question_id": 1937},
{"snippet": "ma.masked_array.partition(kth, order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `order`.", "question_id": 1938},
{"snippet": "ma.masked_array.partition(kth, axis=- 1, kind='introselect')", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `kind`.", "question_id": 1939},
{"snippet": "ma.masked_array.partition(kth, axis=- 1, order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `order`.", "question_id": 1940},
{"snippet": "ma.masked_array.partition(kth, kind='introselect', order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `kind`, `order`.", "question_id": 1941},
{"snippet": "ma.masked_array.partition(kth, axis=- 1, kind='introselect', order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `kind`, `order`.", "question_id": 1942},
{"snippet": "ma.dstack(*args, **kwargs)", "intent": "Stack arrays in sequence depth wise ( along third axis ) . With arguments `*args`, `**kwargs`.", "question_id": 1943},
{"snippet": "ma.MaskType.transpose()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 1944},
{"snippet": "memmap.compress(condition)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`.", "question_id": 1945},
{"snippet": "memmap.compress(condition, axis=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`.", "question_id": 1946},
{"snippet": "memmap.compress(condition, out=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`, `out`.", "question_id": 1947},
{"snippet": "memmap.compress(condition, axis=None, out=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`, `out`.", "question_id": 1948},
{"snippet": "numpy.mask_indices(n, mask_func)", "intent": "Return the indices to access ( `n` , n ) arrays , given a masking function . Assume `mask_func` is a function that , for a square array a of size ( n , n ) with a possible offset argument `k` , when called as mask_func ( a , k ) returns a new array with zeros in certain locations ( functions like triu or tril do precisely this ) .", "question_id": 1949},
{"snippet": "numpy.mask_indices(n, mask_func, k=0)", "intent": "Return the indices to access ( `n` , n ) arrays , given a masking function . Assume `mask_func` is a function that , for a square array a of size ( n , n ) with a possible offset argument `k` , when called as mask_func ( a , k ) returns a new array with zeros in certain locations ( functions like triu or tril do precisely this ) .", "question_id": 1950},
{"snippet": "char.lower(a)", "intent": "Return an array with the elements converted to lowercase . With arguments `a`.", "question_id": 1951},
{"snippet": "random.standard_exponential()", "intent": "Draw samples from the standard exponential distribution .", "question_id": 1952},
{"snippet": "random.standard_exponential(size=None)", "intent": "Draw samples from the standard exponential distribution . With arguments `size`.", "question_id": 1953},
{"snippet": "numpy.nested_iters()", "intent": "Create nditers for use in nested loops", "question_id": 1954},
{"snippet": "ma.MaskedArray.tolist()", "intent": "Return the data portion of the masked array as a hierarchical Python list .", "question_id": 1955},
{"snippet": "ma.MaskedArray.tolist(fill_value=None)", "intent": "Return the data portion of the masked array as a hierarchical Python list . Masked values are converted to `fill_value` .", "question_id": 1956},
{"snippet": "numpy.take_along_axis(arr, indices, axis)", "intent": "Take values from the input array by matching 1d index and data slices . Functions returning an index along an axis , like argsort and argpartition , produce suitable `indices` for this function . This iterates over matching 1d slices oriented along the specified `axis` in the index and data arrays , and uses the former to look up values in the latter . With arguments `arr`.", "question_id": 1957},
{"snippet": "ma.MaskedArray.__rshift__(value, /)", "intent": "Return self > > `value` . With arguments `/`.", "question_id": 1958},
{"snippet": "char.chararray.argpartition(kth)", "intent": "Returns the indices that would partition this array . With arguments `kth`.", "question_id": 1959},
{"snippet": "char.chararray.argpartition(kth, axis=- 1)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`.", "question_id": 1960},
{"snippet": "char.chararray.argpartition(kth, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`.", "question_id": 1961},
{"snippet": "char.chararray.argpartition(kth, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `order`.", "question_id": 1962},
{"snippet": "char.chararray.argpartition(kth, axis=- 1, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`.", "question_id": 1963},
{"snippet": "char.chararray.argpartition(kth, axis=- 1, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `order`.", "question_id": 1964},
{"snippet": "char.chararray.argpartition(kth, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`, `order`.", "question_id": 1965},
{"snippet": "char.chararray.argpartition(kth, axis=- 1, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`, `order`.", "question_id": 1966},
{"snippet": "polynomial.polynomial.Polynomial.copy()", "intent": "Return a copy .", "question_id": 1967},
{"snippet": "polynomial.laguerre.Laguerre.has_samecoef(other)", "intent": "Check if coefficients match . With arguments `other`.", "question_id": 1968},
{"snippet": "ma.default_fill_value(obj)", "intent": "Return the default fill value for the argument object . With arguments `obj`.", "question_id": 1969},
{"snippet": "numpy.intersect1d(ar1, ar2)", "intent": "Find the intersection of two arrays . With arguments `ar1`, `ar2`.", "question_id": 1970},
{"snippet": "numpy.intersect1d(ar1, ar2, assume_unique=False)", "intent": "Find the intersection of two arrays . With arguments `ar1`, `ar2`, `assume_unique`.", "question_id": 1971},
{"snippet": "numpy.intersect1d(ar1, ar2, return_indices=False)", "intent": "Find the intersection of two arrays . With arguments `ar1`, `ar2`, `return_indices`.", "question_id": 1972},
{"snippet": "numpy.intersect1d(ar1, ar2, assume_unique=False, return_indices=False)", "intent": "Find the intersection of two arrays . With arguments `ar1`, `ar2`, `assume_unique`, `return_indices`.", "question_id": 1973},
{"snippet": "polynomial.polynomial.polydiv(c1, c2)", "intent": "Divide one polynomial by another . Returns the quotient-with-remainder of two polynomials `c1` / `c2` .", "question_id": 1974},
{"snippet": "numpy.diag_indices_from(arr)", "intent": "Return the indices to access the main diagonal of an n-dimensional array . With arguments `arr`.", "question_id": 1975},
{"snippet": "numpy.polyval(p, x)", "intent": "Evaluate a polynomial at specific values . If `p` is of length N , this function returns the value : If `x` is a sequence , then p ( x ) is returned for each element of x .", "question_id": 1976},
{"snippet": "ma.MaskedArray.clip(**kwargs)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 1977},
{"snippet": "ma.MaskedArray.clip(**kwargs, min=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 1978},
{"snippet": "ma.MaskedArray.clip(**kwargs, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 1979},
{"snippet": "ma.MaskedArray.clip(**kwargs, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 1980},
{"snippet": "ma.MaskedArray.clip(**kwargs, min=None, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 1981},
{"snippet": "ma.MaskedArray.clip(**kwargs, min=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 1982},
{"snippet": "ma.MaskedArray.clip(**kwargs, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 1983},
{"snippet": "ma.MaskedArray.clip(**kwargs, min=None, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 1984},
{"snippet": "broadcast.index", "intent": "current index in broadcasted result", "question_id": 1985},
{"snippet": "chararray.capitalize()", "intent": "Return a copy of self with only the first character of each element capitalized .", "question_id": 1986},
{"snippet": "ma.dot(a, b)", "intent": "Return the dot product of two arrays . With arguments `a`, `b`.", "question_id": 1987},
{"snippet": "ma.dot(a, b, strict=False)", "intent": "Return the dot product of two arrays . Note that `strict` and `out` are in different position than in the method version . With arguments `a`, `b`.", "question_id": 1988},
{"snippet": "ma.dot(a, b, out=None)", "intent": "Return the dot product of two arrays . Note that `strict` and `out` are in different position than in the method version . With arguments `a`, `b`.", "question_id": 1989},
{"snippet": "ma.dot(a, b, strict=False, out=None)", "intent": "Return the dot product of two arrays . Note that `strict` and `out` are in different position than in the method version . With arguments `a`, `b`.", "question_id": 1990},
{"snippet": "ndarray.std()", "intent": "Returns the standard deviation of the array elements along given `axis` .", "question_id": 1991},
{"snippet": "ndarray.std(axis=None)", "intent": "Returns the standard deviation of the array elements along given `axis` .", "question_id": 1992},
{"snippet": "ndarray.std(dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`.", "question_id": 1993},
{"snippet": "ndarray.std(out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`.", "question_id": 1994},
{"snippet": "ndarray.std(ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`.", "question_id": 1995},
{"snippet": "ndarray.std(keepdims=False)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `keepdims`.", "question_id": 1996},
{"snippet": "ndarray.std(where=True)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `where`.", "question_id": 1997},
{"snippet": "ndarray.std(axis=None, dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`.", "question_id": 1998},
{"snippet": "ndarray.std(axis=None, out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`.", "question_id": 1999},
{"snippet": "ndarray.std(axis=None, ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`.", "question_id": 2000},
{"snippet": "recarray.searchsorted(v)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order .", "question_id": 2001},
{"snippet": "recarray.searchsorted(v, side='left')", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`.", "question_id": 2002},
{"snippet": "recarray.searchsorted(v, sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `sorter`.", "question_id": 2003},
{"snippet": "recarray.searchsorted(v, side='left', sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`, `sorter`.", "question_id": 2004},
{"snippet": "matrix.mean()", "intent": "Returns the average of the matrix elements along the given `axis` .", "question_id": 2005},
{"snippet": "matrix.mean(axis=None)", "intent": "Returns the average of the matrix elements along the given `axis` .", "question_id": 2006},
{"snippet": "matrix.mean(dtype=None)", "intent": "Returns the average of the matrix elements along the given `axis` . With arguments `dtype`.", "question_id": 2007},
{"snippet": "matrix.mean(out=None)", "intent": "Returns the average of the matrix elements along the given `axis` . With arguments `out`.", "question_id": 2008},
{"snippet": "matrix.mean(axis=None, dtype=None)", "intent": "Returns the average of the matrix elements along the given `axis` . With arguments `dtype`.", "question_id": 2009},
{"snippet": "matrix.mean(axis=None, out=None)", "intent": "Returns the average of the matrix elements along the given `axis` . With arguments `out`.", "question_id": 2010},
{"snippet": "matrix.mean(dtype=None, out=None)", "intent": "Returns the average of the matrix elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 2011},
{"snippet": "matrix.mean(axis=None, dtype=None, out=None)", "intent": "Returns the average of the matrix elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 2012},
{"snippet": "memmap.std()", "intent": "Returns the standard deviation of the array elements along given `axis` .", "question_id": 2013},
{"snippet": "memmap.std(axis=None)", "intent": "Returns the standard deviation of the array elements along given `axis` .", "question_id": 2014},
{"snippet": "memmap.std(dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`.", "question_id": 2015},
{"snippet": "memmap.std(out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`.", "question_id": 2016},
{"snippet": "memmap.std(ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`.", "question_id": 2017},
{"snippet": "memmap.std(keepdims=False)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `keepdims`.", "question_id": 2018},
{"snippet": "memmap.std(where=True)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `where`.", "question_id": 2019},
{"snippet": "memmap.std(axis=None, dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`.", "question_id": 2020},
{"snippet": "memmap.std(axis=None, out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`.", "question_id": 2021},
{"snippet": "memmap.std(axis=None, ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`.", "question_id": 2022},
{"snippet": "ndarray.data", "intent": "Python buffer object pointing to the start of the array\u2019s data.", "question_id": 2023},
{"snippet": "polynomial.legendre.Legendre.mapparms()", "intent": "Return the mapping parameters .", "question_id": 2024},
{"snippet": "generic.__array_wrap__()", "intent": "sc.__array_wrap__ ( obj ) return scalar from array", "question_id": 2025},
{"snippet": "testing.assert_equal(actual, desired)", "intent": "Raises an AssertionError if two objects are not equal . When one of `actual` and `desired` is a scalar and the other is array_like , the function checks that each element of the array_like object is equal to the scalar .", "question_id": 2026},
{"snippet": "testing.assert_equal(actual, desired, err_msg='')", "intent": "Raises an AssertionError if two objects are not equal . When one of `actual` and `desired` is a scalar and the other is array_like , the function checks that each element of the array_like object is equal to the scalar . With arguments `err_msg`.", "question_id": 2027},
{"snippet": "testing.assert_equal(actual, desired, verbose=True)", "intent": "Raises an AssertionError if two objects are not equal . When one of `actual` and `desired` is a scalar and the other is array_like , the function checks that each element of the array_like object is equal to the scalar . With arguments `verbose`.", "question_id": 2028},
{"snippet": "testing.assert_equal(actual, desired, err_msg='', verbose=True)", "intent": "Raises an AssertionError if two objects are not equal . When one of `actual` and `desired` is a scalar and the other is array_like , the function checks that each element of the array_like object is equal to the scalar . With arguments `err_msg`, `verbose`.", "question_id": 2029},
{"snippet": "matrix.any()", "intent": "Test whether any array element along a given `axis` evaluates to True .", "question_id": 2030},
{"snippet": "matrix.any(axis=None)", "intent": "Test whether any array element along a given `axis` evaluates to True .", "question_id": 2031},
{"snippet": "matrix.any(out=None)", "intent": "Test whether any array element along a given `axis` evaluates to True . With arguments `out`.", "question_id": 2032},
{"snippet": "matrix.any(axis=None, out=None)", "intent": "Test whether any array element along a given `axis` evaluates to True . With arguments `out`.", "question_id": 2033},
{"snippet": "numpy.nanvar(a)", "intent": "Compute the variance along the specified `axis` , while ignoring NaNs . Returns the variance of the array elements , `a` measure of the spread of a distribution .", "question_id": 2034},
{"snippet": "numpy.nanvar(a, axis=None)", "intent": "Compute the variance along the specified `axis` , while ignoring NaNs . Returns the variance of the array elements , `a` measure of the spread of a distribution .", "question_id": 2035},
{"snippet": "numpy.nanvar(a, dtype=None)", "intent": "Compute the variance along the specified `axis` , while ignoring NaNs . Returns the variance of the array elements , `a` measure of the spread of a distribution . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue .", "question_id": 2036},
{"snippet": "numpy.nanvar(a, out=None)", "intent": "Compute the variance along the specified `axis` , while ignoring NaNs . Returns the variance of the array elements , `a` measure of the spread of a distribution . With arguments `out`.", "question_id": 2037},
{"snippet": "numpy.nanvar(a, ddof=0)", "intent": "Compute the variance along the specified `axis` , while ignoring NaNs . Returns the variance of the array elements , `a` measure of the spread of a distribution . If , however , `ddof` is specified , the divisor N - ddof is used instead .", "question_id": 2038},
{"snippet": "numpy.nanvar(a, keepdims=<no value>)", "intent": "Compute the variance along the specified `axis` , while ignoring NaNs . Returns the variance of the array elements , `a` measure of the spread of a distribution . For this function to work on sub-classes of ndarray , they must define sum with the kwarg `keepdims`", "question_id": 2039},
{"snippet": "numpy.nanvar(a, axis=None, dtype=None)", "intent": "Compute the variance along the specified `axis` , while ignoring NaNs . Returns the variance of the array elements , `a` measure of the spread of a distribution . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue .", "question_id": 2040},
{"snippet": "numpy.nanvar(a, axis=None, out=None)", "intent": "Compute the variance along the specified `axis` , while ignoring NaNs . Returns the variance of the array elements , `a` measure of the spread of a distribution . With arguments `out`.", "question_id": 2041},
{"snippet": "numpy.nanvar(a, axis=None, ddof=0)", "intent": "Compute the variance along the specified `axis` , while ignoring NaNs . Returns the variance of the array elements , `a` measure of the spread of a distribution . If , however , `ddof` is specified , the divisor N - ddof is used instead .", "question_id": 2042},
{"snippet": "numpy.nanvar(a, axis=None, keepdims=<no value>)", "intent": "Compute the variance along the specified `axis` , while ignoring NaNs . Returns the variance of the array elements , `a` measure of the spread of a distribution . For this function to work on sub-classes of ndarray , they must define sum with the kwarg `keepdims`", "question_id": 2043},
{"snippet": "numpy.sin(x, /, signature, extobj)", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `extobj`.", "question_id": 2044},
{"snippet": "numpy.sin(x, /, signature, extobj, out=None)", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `extobj`, `out`.", "question_id": 2045},
{"snippet": "numpy.sin(x, /, signature, extobj, where=True)", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `extobj`.", "question_id": 2046},
{"snippet": "numpy.sin(x, /, signature, extobj, casting='same_kind')", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `extobj`, `casting`.", "question_id": 2047},
{"snippet": "numpy.sin(x, /, signature, extobj, order='K')", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `extobj`, `order`.", "question_id": 2048},
{"snippet": "numpy.sin(x, /, signature, extobj, dtype=None)", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `extobj`, `dtype`.", "question_id": 2049},
{"snippet": "numpy.sin(x, /, signature, extobj, subok=True)", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `extobj`, `subok`.", "question_id": 2050},
{"snippet": "numpy.sin(x, /, signature, extobj, out=None, where=True)", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `extobj`, `out`.", "question_id": 2051},
{"snippet": "numpy.sin(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `extobj`, `out`, `casting`.", "question_id": 2052},
{"snippet": "numpy.sin(x, /, signature, extobj, out=None, order='K')", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `extobj`, `out`, `order`.", "question_id": 2053},
{"snippet": "numpy.sin(x, /, signature)", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`.", "question_id": 2054},
{"snippet": "numpy.sin(x, /, signature, out=None)", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `out`.", "question_id": 2055},
{"snippet": "numpy.sin(x, /, signature, where=True)", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`.", "question_id": 2056},
{"snippet": "numpy.sin(x, /, signature, casting='same_kind')", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `casting`.", "question_id": 2057},
{"snippet": "numpy.sin(x, /, signature, order='K')", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `order`.", "question_id": 2058},
{"snippet": "numpy.sin(x, /, signature, dtype=None)", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `dtype`.", "question_id": 2059},
{"snippet": "numpy.sin(x, /, signature, subok=True)", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `subok`.", "question_id": 2060},
{"snippet": "numpy.sin(x, /, signature, out=None, where=True)", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `out`.", "question_id": 2061},
{"snippet": "numpy.sin(x, /, signature, out=None, casting='same_kind')", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `out`, `casting`.", "question_id": 2062},
{"snippet": "numpy.sin(x, /, signature, out=None, order='K')", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `out`, `order`.", "question_id": 2063},
{"snippet": "recarray.item(*args)", "intent": "Copy an element of an array to a standard Python scalar and return it . With arguments `*args`.", "question_id": 2064},
{"snippet": "numpy.expand_dims(a, axis)", "intent": "Expand the shape of an array . Insert `a` new `axis` that will appear at the axis position in the expanded array shape .", "question_id": 2065},
{"snippet": "char.chararray.argmin()", "intent": "Return indices of the minimum values along the given `axis` .", "question_id": 2066},
{"snippet": "char.chararray.argmin(axis=None)", "intent": "Return indices of the minimum values along the given `axis` .", "question_id": 2067},
{"snippet": "char.chararray.argmin(out=None)", "intent": "Return indices of the minimum values along the given `axis` . With arguments `out`.", "question_id": 2068},
{"snippet": "char.chararray.argmin(axis=None, out=None)", "intent": "Return indices of the minimum values along the given `axis` . With arguments `out`.", "question_id": 2069},
{"snippet": "record.clip()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 2070},
{"snippet": "broadcast.reset()", "intent": "Reset the broadcasted result \u2019 s iterator ( s ) .", "question_id": 2071},
{"snippet": "random.RandomState.standard_exponential()", "intent": "Draw samples from the standard exponential distribution .", "question_id": 2072},
{"snippet": "random.RandomState.standard_exponential(size=None)", "intent": "Draw samples from the standard exponential distribution . With arguments `size`.", "question_id": 2073},
{"snippet": "DataSource.abspath(path)", "intent": "Return absolute `path` of file in the DataSource directory .", "question_id": 2074},
{"snippet": "numpy.stack(arrays)", "intent": "Join a sequence of `arrays` along a new `axis` .", "question_id": 2075},
{"snippet": "numpy.stack(arrays, axis=0)", "intent": "Join a sequence of `arrays` along a new `axis` .", "question_id": 2076},
{"snippet": "numpy.stack(arrays, out=None)", "intent": "Join a sequence of `arrays` along a new `axis` . With arguments `out`.", "question_id": 2077},
{"snippet": "numpy.stack(arrays, axis=0, out=None)", "intent": "Join a sequence of `arrays` along a new `axis` . With arguments `out`.", "question_id": 2078},
{"snippet": "ma.MaskedArray.__idiv__(other)", "intent": "Divide self by `other` in-place .", "question_id": 2079},
{"snippet": "numpy.find_common_type(array_types, scalar_types)", "intent": "Determine common type following standard coercion rules . Complex is of a different type , so it up-casts the float in the `array_types` argument : With arguments `scalar_types`.", "question_id": 2080},
{"snippet": "ma.MaskType.trace()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 2081},
{"snippet": "numpy.rad2deg(x, /, signature, extobj)", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `extobj`.", "question_id": 2082},
{"snippet": "numpy.rad2deg(x, /, signature, extobj, out=None)", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `extobj`, `out`.", "question_id": 2083},
{"snippet": "numpy.rad2deg(x, /, signature, extobj, where=True)", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `extobj`, `where`.", "question_id": 2084},
{"snippet": "numpy.rad2deg(x, /, signature, extobj, casting='same_kind')", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `extobj`, `casting`.", "question_id": 2085},
{"snippet": "numpy.rad2deg(x, /, signature, extobj, order='K')", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `extobj`, `order`.", "question_id": 2086},
{"snippet": "numpy.rad2deg(x, /, signature, extobj, dtype=None)", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `extobj`, `dtype`.", "question_id": 2087},
{"snippet": "numpy.rad2deg(x, /, signature, extobj, subok=True)", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `extobj`, `subok`.", "question_id": 2088},
{"snippet": "numpy.rad2deg(x, /, signature, extobj, out=None, where=True)", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `extobj`, `out`, `where`.", "question_id": 2089},
{"snippet": "numpy.rad2deg(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `extobj`, `out`, `casting`.", "question_id": 2090},
{"snippet": "numpy.rad2deg(x, /, signature, extobj, out=None, order='K')", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `extobj`, `out`, `order`.", "question_id": 2091},
{"snippet": "numpy.rad2deg(x, /, signature)", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`.", "question_id": 2092},
{"snippet": "numpy.rad2deg(x, /, signature, out=None)", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `out`.", "question_id": 2093},
{"snippet": "numpy.rad2deg(x, /, signature, where=True)", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `where`.", "question_id": 2094},
{"snippet": "numpy.rad2deg(x, /, signature, casting='same_kind')", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `casting`.", "question_id": 2095},
{"snippet": "numpy.rad2deg(x, /, signature, order='K')", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `order`.", "question_id": 2096},
{"snippet": "numpy.rad2deg(x, /, signature, dtype=None)", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `dtype`.", "question_id": 2097},
{"snippet": "numpy.rad2deg(x, /, signature, subok=True)", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `subok`.", "question_id": 2098},
{"snippet": "numpy.rad2deg(x, /, signature, out=None, where=True)", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `out`, `where`.", "question_id": 2099},
{"snippet": "numpy.rad2deg(x, /, signature, out=None, casting='same_kind')", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `out`, `casting`.", "question_id": 2100},
{"snippet": "numpy.rad2deg(x, /, signature, out=None, order='K')", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `out`, `order`.", "question_id": 2101},
{"snippet": "numpy.digitize(x, bins)", "intent": "Return the indices of the `bins` to which each value in input array belongs . If values in `x` are beyond the bounds of bins , 0 or len ( bins ) is returned as appropriate .", "question_id": 2102},
{"snippet": "numpy.digitize(x, bins, right=False)", "intent": "Return the indices of the `bins` to which each value in input array belongs . If values in `x` are beyond the bounds of bins , 0 or len ( bins ) is returned as appropriate . With arguments `right`.", "question_id": 2103},
{"snippet": "char.isupper(a)", "intent": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character , false otherwise . With arguments `a`.", "question_id": 2104},
{"snippet": "polynomial.hermite.Hermite.has_samewindow(other)", "intent": "Check if windows match . With arguments `other`.", "question_id": 2105},
{"snippet": "fft.fft(a)", "intent": "Compute the one-dimensional discrete Fourier Transform . FFT ( Fast Fourier Transform ) refers to `a` way the discrete Fourier Transform ( DFT ) can be calculated efficiently , by using symmetries in the calculated terms .", "question_id": 2106},
{"snippet": "fft.fft(a, n=None)", "intent": "Compute the one-dimensional discrete Fourier Transform . FFT ( Fast Fourier Transform ) refers to `a` way the discrete Fourier Transform ( DFT ) can be calculated efficiently , by using symmetries in the calculated terms . The symmetry is highest when `n` is a power of 2 , and the transform is therefore most efficient for these sizes .", "question_id": 2107},
{"snippet": "fft.fft(a, axis=- 1)", "intent": "Compute the one-dimensional discrete Fourier Transform . FFT ( Fast Fourier Transform ) refers to `a` way the discrete Fourier Transform ( DFT ) can be calculated efficiently , by using symmetries in the calculated terms . With arguments `axis`.", "question_id": 2108},
{"snippet": "fft.fft(a, norm=None)", "intent": "Compute the one-dimensional discrete Fourier Transform . FFT ( Fast Fourier Transform ) refers to `a` way the discrete Fourier Transform ( DFT ) can be calculated efficiently , by using symmetries in the calculated terms . With arguments `norm`.", "question_id": 2109},
{"snippet": "fft.fft(a, n=None, axis=- 1)", "intent": "Compute the one-dimensional discrete Fourier Transform . FFT ( Fast Fourier Transform ) refers to `a` way the discrete Fourier Transform ( DFT ) can be calculated efficiently , by using symmetries in the calculated terms . The symmetry is highest when `n` is a power of 2 , and the transform is therefore most efficient for these sizes . With arguments `axis`.", "question_id": 2110},
{"snippet": "fft.fft(a, n=None, norm=None)", "intent": "Compute the one-dimensional discrete Fourier Transform . FFT ( Fast Fourier Transform ) refers to `a` way the discrete Fourier Transform ( DFT ) can be calculated efficiently , by using symmetries in the calculated terms . The symmetry is highest when `n` is a power of 2 , and the transform is therefore most efficient for these sizes . With arguments `norm`.", "question_id": 2111},
{"snippet": "fft.fft(a, axis=- 1, norm=None)", "intent": "Compute the one-dimensional discrete Fourier Transform . FFT ( Fast Fourier Transform ) refers to `a` way the discrete Fourier Transform ( DFT ) can be calculated efficiently , by using symmetries in the calculated terms . With arguments `axis`, `norm`.", "question_id": 2112},
{"snippet": "fft.fft(a, n=None, axis=- 1, norm=None)", "intent": "Compute the one-dimensional discrete Fourier Transform . FFT ( Fast Fourier Transform ) refers to `a` way the discrete Fourier Transform ( DFT ) can be calculated efficiently , by using symmetries in the calculated terms . The symmetry is highest when `n` is a power of 2 , and the transform is therefore most efficient for these sizes . With arguments `axis`, `norm`.", "question_id": 2113},
{"snippet": "ma.median(a)", "intent": "Compute the median along the specified `axis` . Given `a` vector V with N non masked values , the median of V is the middle value of a sorted copy of V ( Vs ) - i.e .", "question_id": 2114},
{"snippet": "ma.median(a, axis=None)", "intent": "Compute the median along the specified `axis` . Given `a` vector V with N non masked values , the median of V is the middle value of a sorted copy of V ( Vs ) - i.e .", "question_id": 2115},
{"snippet": "ma.median(a, out=None)", "intent": "Compute the median along the specified `axis` . Given `a` vector V with N non masked values , the median of V is the middle value of a sorted copy of V ( Vs ) - i.e . With arguments `out`.", "question_id": 2116},
{"snippet": "ma.median(a, overwrite_input=False)", "intent": "Compute the median along the specified `axis` . Given `a` vector V with N non masked values , the median of V is the middle value of a sorted copy of V ( Vs ) - i.e . With arguments `overwrite_input`.", "question_id": 2117},
{"snippet": "ma.median(a, keepdims=False)", "intent": "Compute the median along the specified `axis` . Given `a` vector V with N non masked values , the median of V is the middle value of a sorted copy of V ( Vs ) - i.e . With arguments `keepdims`.", "question_id": 2118},
{"snippet": "ma.median(a, axis=None, out=None)", "intent": "Compute the median along the specified `axis` . Given `a` vector V with N non masked values , the median of V is the middle value of a sorted copy of V ( Vs ) - i.e . With arguments `out`.", "question_id": 2119},
{"snippet": "ma.median(a, axis=None, overwrite_input=False)", "intent": "Compute the median along the specified `axis` . Given `a` vector V with N non masked values , the median of V is the middle value of a sorted copy of V ( Vs ) - i.e . With arguments `overwrite_input`.", "question_id": 2120},
{"snippet": "ma.median(a, axis=None, keepdims=False)", "intent": "Compute the median along the specified `axis` . Given `a` vector V with N non masked values , the median of V is the middle value of a sorted copy of V ( Vs ) - i.e . With arguments `keepdims`.", "question_id": 2121},
{"snippet": "ma.median(a, out=None, overwrite_input=False)", "intent": "Compute the median along the specified `axis` . Given `a` vector V with N non masked values , the median of V is the middle value of a sorted copy of V ( Vs ) - i.e . With arguments `out`, `overwrite_input`.", "question_id": 2122},
{"snippet": "ma.median(a, out=None, keepdims=False)", "intent": "Compute the median along the specified `axis` . Given `a` vector V with N non masked values , the median of V is the middle value of a sorted copy of V ( Vs ) - i.e . With arguments `out`, `keepdims`.", "question_id": 2123},
{"snippet": "linalg.eig(a)", "intent": "Compute the eigenvalues and right eigenvectors of `a` square array .", "question_id": 2124},
{"snippet": "numpy.transpose(a)", "intent": "Reverse or permute the `axes` of an array ; returns the modified array . For an array `a` with two axes , transpose ( a ) gives the matrix transpose .", "question_id": 2125},
{"snippet": "numpy.transpose(a, axes=None)", "intent": "Reverse or permute the `axes` of an array ; returns the modified array . For an array `a` with two axes , transpose ( a ) gives the matrix transpose .", "question_id": 2126},
{"snippet": "numpy.lookfor(what)", "intent": "Do a keyword search on docstrings . With arguments `what`.", "question_id": 2127},
{"snippet": "numpy.lookfor(what, module=None)", "intent": "Do a keyword search on docstrings . With arguments `what`, `module`.", "question_id": 2128},
{"snippet": "numpy.lookfor(what, import_modules=True)", "intent": "Do a keyword search on docstrings . With arguments `what`, `import_modules`.", "question_id": 2129},
{"snippet": "numpy.lookfor(what, regenerate=False)", "intent": "Do a keyword search on docstrings . With arguments `what`, `regenerate`.", "question_id": 2130},
{"snippet": "numpy.lookfor(what, output=None)", "intent": "Do a keyword search on docstrings . With arguments `what`, `output`.", "question_id": 2131},
{"snippet": "numpy.lookfor(what, module=None, import_modules=True)", "intent": "Do a keyword search on docstrings . With arguments `what`, `module`, `import_modules`.", "question_id": 2132},
{"snippet": "numpy.lookfor(what, module=None, regenerate=False)", "intent": "Do a keyword search on docstrings . With arguments `what`, `module`, `regenerate`.", "question_id": 2133},
{"snippet": "numpy.lookfor(what, module=None, output=None)", "intent": "Do a keyword search on docstrings . With arguments `what`, `module`, `output`.", "question_id": 2134},
{"snippet": "numpy.lookfor(what, import_modules=True, regenerate=False)", "intent": "Do a keyword search on docstrings . With arguments `what`, `import_modules`, `regenerate`.", "question_id": 2135},
{"snippet": "numpy.lookfor(what, import_modules=True, output=None)", "intent": "Do a keyword search on docstrings . With arguments `what`, `import_modules`, `output`.", "question_id": 2136},
{"snippet": "fft.rfftn(a)", "intent": "Compute the N-dimensional discrete Fourier Transform for real input . With arguments `a`.", "question_id": 2137},
{"snippet": "fft.rfftn(a, s=None)", "intent": "Compute the N-dimensional discrete Fourier Transform for real input . With arguments `a`, `s`.", "question_id": 2138},
{"snippet": "fft.rfftn(a, axes=None)", "intent": "Compute the N-dimensional discrete Fourier Transform for real input . This function computes the N-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional real array by means of the Fast Fourier Transform ( FFT ) . With arguments `a`.", "question_id": 2139},
{"snippet": "fft.rfftn(a, norm=None)", "intent": "Compute the N-dimensional discrete Fourier Transform for real input . With arguments `a`, `norm`.", "question_id": 2140},
{"snippet": "fft.rfftn(a, s=None, axes=None)", "intent": "Compute the N-dimensional discrete Fourier Transform for real input . This function computes the N-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional real array by means of the Fast Fourier Transform ( FFT ) . With arguments `a`, `s`.", "question_id": 2141},
{"snippet": "fft.rfftn(a, s=None, norm=None)", "intent": "Compute the N-dimensional discrete Fourier Transform for real input . With arguments `a`, `s`, `norm`.", "question_id": 2142},
{"snippet": "fft.rfftn(a, axes=None, norm=None)", "intent": "Compute the N-dimensional discrete Fourier Transform for real input . This function computes the N-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional real array by means of the Fast Fourier Transform ( FFT ) . With arguments `a`, `norm`.", "question_id": 2143},
{"snippet": "fft.rfftn(a, s=None, axes=None, norm=None)", "intent": "Compute the N-dimensional discrete Fourier Transform for real input . This function computes the N-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional real array by means of the Fast Fourier Transform ( FFT ) . With arguments `a`, `s`, `norm`.", "question_id": 2144},
{"snippet": "recarray.diagonal()", "intent": "Return specified diagonals .", "question_id": 2145},
{"snippet": "recarray.diagonal(offset=0)", "intent": "Return specified diagonals . With arguments `offset`.", "question_id": 2146},
{"snippet": "recarray.diagonal(axis1=0)", "intent": "Return specified diagonals . With arguments `axis1`.", "question_id": 2147},
{"snippet": "recarray.diagonal(axis2=1)", "intent": "Return specified diagonals . With arguments `axis2`.", "question_id": 2148},
{"snippet": "recarray.diagonal(offset=0, axis1=0)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`.", "question_id": 2149},
{"snippet": "recarray.diagonal(offset=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis2`.", "question_id": 2150},
{"snippet": "recarray.diagonal(axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `axis1`, `axis2`.", "question_id": 2151},
{"snippet": "recarray.diagonal(offset=0, axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`, `axis2`.", "question_id": 2152},
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, axis)", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `axis`.", "question_id": 2153},
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, axis, out=None)", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `axis`, `out`.", "question_id": 2154},
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, axis, casting='same_kind')", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `axis`, `casting`.", "question_id": 2155},
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, axis, order='K')", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `axis`, `order`.", "question_id": 2156},
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, axis, dtype=None)", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `axis`, `dtype`.", "question_id": 2157},
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, axis, subok=True)", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `axis`, `subok`.", "question_id": 2158},
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, axis, out=None, casting='same_kind')", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `axis`, `out`, `casting`.", "question_id": 2159},
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, axis, out=None, order='K')", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `axis`, `out`, `order`.", "question_id": 2160},
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, axis, out=None, dtype=None)", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `axis`, `out`, `dtype`.", "question_id": 2161},
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, axis, out=None, subok=True)", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `axis`, `out`, `subok`.", "question_id": 2162},
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes)", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`.", "question_id": 2163},
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, out=None)", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `out`.", "question_id": 2164},
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, casting='same_kind')", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `casting`.", "question_id": 2165},
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, order='K')", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `order`.", "question_id": 2166},
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, dtype=None)", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `dtype`.", "question_id": 2167},
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, subok=True)", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `subok`.", "question_id": 2168},
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, out=None, casting='same_kind')", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `out`, `casting`.", "question_id": 2169},
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, out=None, order='K')", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `out`, `order`.", "question_id": 2170},
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, out=None, dtype=None)", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `out`, `dtype`.", "question_id": 2171},
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, out=None, subok=True)", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `out`, `subok`.", "question_id": 2172},
{"snippet": "chararray.strides", "intent": "Tuple of bytes to step in each dimension when traversing an array.", "question_id": 2173},
{"snippet": "numpy.histogram2d(x, y)", "intent": "Compute the bi-dimensional histogram of two data samples . Please note that the histogram does not follow the Cartesian convention where `x` values are on the abscissa and `y` values on the ordinate axis .", "question_id": 2174},
{"snippet": "numpy.histogram2d(x, y, bins=10)", "intent": "Compute the bi-dimensional histogram of two data samples . Please note that the histogram does not follow the Cartesian convention where `x` values are on the abscissa and `y` values on the ordinate axis . When `normed` is True , then the returned histogram is the sample `density` , defined such that the sum over `bins` of the product bin_value * bin_area is 1 .", "question_id": 2175},
{"snippet": "numpy.histogram2d(x, y, range=None)", "intent": "Compute the bi-dimensional histogram of two data samples . Please note that the histogram does not follow the Cartesian convention where `x` values are on the abscissa and `y` values on the ordinate axis . With arguments `range`.", "question_id": 2176},
{"snippet": "numpy.histogram2d(x, y, normed=None)", "intent": "Compute the bi-dimensional histogram of two data samples . Please note that the histogram does not follow the Cartesian convention where `x` values are on the abscissa and `y` values on the ordinate axis . When `normed` is True , then the returned histogram is the sample `density` , defined such that the sum over `bins` of the product bin_value * bin_area is 1 .", "question_id": 2177},
{"snippet": "numpy.histogram2d(x, y, weights=None)", "intent": "Compute the bi-dimensional histogram of two data samples . Please note that the histogram does not follow the Cartesian convention where `x` values are on the abscissa and `y` values on the ordinate axis . With arguments `weights`.", "question_id": 2178},
{"snippet": "numpy.histogram2d(x, y, density=None)", "intent": "Compute the bi-dimensional histogram of two data samples . Please note that the histogram does not follow the Cartesian convention where `x` values are on the abscissa and `y` values on the ordinate axis . When `normed` is True , then the returned histogram is the sample `density` , defined such that the sum over `bins` of the product bin_value * bin_area is 1 .", "question_id": 2179},
{"snippet": "numpy.histogram2d(x, y, bins=10, range=None)", "intent": "Compute the bi-dimensional histogram of two data samples . Please note that the histogram does not follow the Cartesian convention where `x` values are on the abscissa and `y` values on the ordinate axis . When `normed` is True , then the returned histogram is the sample `density` , defined such that the sum over `bins` of the product bin_value * bin_area is 1 . With arguments `range`.", "question_id": 2180},
{"snippet": "numpy.histogram2d(x, y, bins=10, normed=None)", "intent": "Compute the bi-dimensional histogram of two data samples . Please note that the histogram does not follow the Cartesian convention where `x` values are on the abscissa and `y` values on the ordinate axis . When `normed` is True , then the returned histogram is the sample `density` , defined such that the sum over `bins` of the product bin_value * bin_area is 1 .", "question_id": 2181},
{"snippet": "numpy.histogram2d(x, y, bins=10, weights=None)", "intent": "Compute the bi-dimensional histogram of two data samples . Please note that the histogram does not follow the Cartesian convention where `x` values are on the abscissa and `y` values on the ordinate axis . When `normed` is True , then the returned histogram is the sample `density` , defined such that the sum over `bins` of the product bin_value * bin_area is 1 . With arguments `weights`.", "question_id": 2182},
{"snippet": "numpy.histogram2d(x, y, bins=10, density=None)", "intent": "Compute the bi-dimensional histogram of two data samples . Please note that the histogram does not follow the Cartesian convention where `x` values are on the abscissa and `y` values on the ordinate axis . When `normed` is True , then the returned histogram is the sample `density` , defined such that the sum over `bins` of the product bin_value * bin_area is 1 .", "question_id": 2183},
{"snippet": "numpy.disp(mesg)", "intent": "Display a message on a `device` . With arguments `mesg`.", "question_id": 2184},
{"snippet": "numpy.disp(mesg, device=None)", "intent": "Display a message on a `device` . With arguments `mesg`.", "question_id": 2185},
{"snippet": "numpy.disp(mesg, linefeed=True)", "intent": "Display a message on a `device` . With arguments `mesg`, `linefeed`.", "question_id": 2186},
{"snippet": "numpy.disp(mesg, device=None, linefeed=True)", "intent": "Display a message on a `device` . With arguments `mesg`, `linefeed`.", "question_id": 2187},
{"snippet": "ndarray.argpartition(kth)", "intent": "Returns the indices that would partition this array . With arguments `kth`.", "question_id": 2188},
{"snippet": "ndarray.argpartition(kth, axis=- 1)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`.", "question_id": 2189},
{"snippet": "ndarray.argpartition(kth, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`.", "question_id": 2190},
{"snippet": "ndarray.argpartition(kth, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `order`.", "question_id": 2191},
{"snippet": "ndarray.argpartition(kth, axis=- 1, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`.", "question_id": 2192},
{"snippet": "ndarray.argpartition(kth, axis=- 1, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `order`.", "question_id": 2193},
{"snippet": "ndarray.argpartition(kth, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`, `order`.", "question_id": 2194},
{"snippet": "ndarray.argpartition(kth, axis=- 1, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`, `order`.", "question_id": 2195},
{"snippet": "char.chararray.conjugate()", "intent": "Return the complex conjugate , element-wise .", "question_id": 2196},
{"snippet": "ma.MaskedArray.get_fill_value()", "intent": "The filling value of the masked array is a scalar .", "question_id": 2197},
{"snippet": "ma.getmask(a)", "intent": "Return the mask of `a` masked array , or nomask .", "question_id": 2198},
{"snippet": "polynomial.polynomial.polycompanion(c)", "intent": "Return the companion matrix of `c` .", "question_id": 2199},
{"snippet": "ma.asanyarray(a)", "intent": "Convert the input to `a` masked array , conserving subclasses .", "question_id": 2200},
{"snippet": "ma.asanyarray(a, dtype=None)", "intent": "Convert the input to `a` masked array , conserving subclasses . With arguments `dtype`.", "question_id": 2201},
{"snippet": "linalg.matrix_power(a, n)", "intent": "Raise `a` square matrix to the ( integer ) power `n` .", "question_id": 2202},
{"snippet": "char.chararray.encode()", "intent": "Calls str.encode element-wise .", "question_id": 2203},
{"snippet": "char.chararray.encode(encoding=None)", "intent": "Calls str.encode element-wise . With arguments `encoding`.", "question_id": 2204},
{"snippet": "char.chararray.encode(errors=None)", "intent": "Calls str.encode element-wise . With arguments `errors`.", "question_id": 2205},
{"snippet": "char.chararray.encode(encoding=None, errors=None)", "intent": "Calls str.encode element-wise . With arguments `encoding`, `errors`.", "question_id": 2206},
{"snippet": "lib.scimath.arccos(x)", "intent": "Compute the inverse cosine of `x` .", "question_id": 2207},
{"snippet": "matrix.diagonal()", "intent": "Return specified diagonals .", "question_id": 2208},
{"snippet": "matrix.diagonal(offset=0)", "intent": "Return specified diagonals . With arguments `offset`.", "question_id": 2209},
{"snippet": "matrix.diagonal(axis1=0)", "intent": "Return specified diagonals . With arguments `axis1`.", "question_id": 2210},
{"snippet": "matrix.diagonal(axis2=1)", "intent": "Return specified diagonals . With arguments `axis2`.", "question_id": 2211},
{"snippet": "matrix.diagonal(offset=0, axis1=0)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`.", "question_id": 2212},
{"snippet": "matrix.diagonal(offset=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis2`.", "question_id": 2213},
{"snippet": "matrix.diagonal(axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `axis1`, `axis2`.", "question_id": 2214},
{"snippet": "matrix.diagonal(offset=0, axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`, `axis2`.", "question_id": 2215},
{"snippet": "ma.MaskType.getfield()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 2216},
{"snippet": "ndarray.__and__(value, /)", "intent": "Return self & `value` . With arguments `/`.", "question_id": 2217},
{"snippet": "memmap.dot(b)", "intent": "Dot product of two arrays . With arguments `b`.", "question_id": 2218},
{"snippet": "memmap.dot(b, out=None)", "intent": "Dot product of two arrays . With arguments `b`, `out`.", "question_id": 2219},
{"snippet": "ma.maximum_fill_value(obj)", "intent": "Return the minimum value that can be represented by the dtype of an object . With arguments `obj`.", "question_id": 2220},
{"snippet": "numpy.sign(x, /, signature, extobj)", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `extobj`.", "question_id": 2221},
{"snippet": "numpy.sign(x, /, signature, extobj, out=None)", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 2222},
{"snippet": "numpy.sign(x, /, signature, extobj, where=True)", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 2223},
{"snippet": "numpy.sign(x, /, signature, extobj, casting='same_kind')", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 2224},
{"snippet": "numpy.sign(x, /, signature, extobj, order='K')", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 2225},
{"snippet": "numpy.sign(x, /, signature, extobj, dtype=None)", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 2226},
{"snippet": "numpy.sign(x, /, signature, extobj, subok=True)", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 2227},
{"snippet": "numpy.sign(x, /, signature, extobj, out=None, where=True)", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 2228},
{"snippet": "numpy.sign(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 2229},
{"snippet": "numpy.sign(x, /, signature, extobj, out=None, order='K')", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 2230},
{"snippet": "numpy.sign(x, /, signature)", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`.", "question_id": 2231},
{"snippet": "numpy.sign(x, /, signature, out=None)", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `out`.", "question_id": 2232},
{"snippet": "numpy.sign(x, /, signature, where=True)", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `where`.", "question_id": 2233},
{"snippet": "numpy.sign(x, /, signature, casting='same_kind')", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `casting`.", "question_id": 2234},
{"snippet": "numpy.sign(x, /, signature, order='K')", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `order`.", "question_id": 2235},
{"snippet": "numpy.sign(x, /, signature, dtype=None)", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `dtype`.", "question_id": 2236},
{"snippet": "numpy.sign(x, /, signature, subok=True)", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `subok`.", "question_id": 2237},
{"snippet": "numpy.sign(x, /, signature, out=None, where=True)", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `out`, `where`.", "question_id": 2238},
{"snippet": "numpy.sign(x, /, signature, out=None, casting='same_kind')", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 2239},
{"snippet": "numpy.sign(x, /, signature, out=None, order='K')", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `out`, `order`.", "question_id": 2240},
{"snippet": "ma.MaskType.take()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 2241},
{"snippet": "ndarray.cumsum()", "intent": "Return the cumulative sum of the elements along the given `axis` .", "question_id": 2242},
{"snippet": "ndarray.cumsum(axis=None)", "intent": "Return the cumulative sum of the elements along the given `axis` .", "question_id": 2243},
{"snippet": "ndarray.cumsum(dtype=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`.", "question_id": 2244},
{"snippet": "ndarray.cumsum(out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `out`.", "question_id": 2245},
{"snippet": "ndarray.cumsum(axis=None, dtype=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`.", "question_id": 2246},
{"snippet": "ndarray.cumsum(axis=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `out`.", "question_id": 2247},
{"snippet": "ndarray.cumsum(dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 2248},
{"snippet": "ndarray.cumsum(axis=None, dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 2249},
{"snippet": "numpy.testing.suppress_warnings()", "intent": "Context manager and decorator doing much the same as warnings.catch_warnings .", "question_id": 2250},
{"snippet": "numpy.testing.suppress_warnings(forwarding_rule='always')", "intent": "Context manager and decorator doing much the same as warnings.catch_warnings . With arguments `forwarding_rule`.", "question_id": 2251},
{"snippet": "numpy.apply_along_axis(func1d, axis, arr, *args, **kwargs)", "intent": "Apply a function to 1-D slices along the given `axis` . Execute `func1d` ( a , * args , * * kwargs ) where func1d operates on 1-D arrays and a is a 1-D slice of `arr` along axis . With arguments `*args`, `**kwargs`.", "question_id": 2252},
{"snippet": "polynomial.laguerre.Laguerre.truncate(size)", "intent": "Truncate series to length `size` .", "question_id": 2253},
{"snippet": "numpy.any(a)", "intent": "Test whether any array element along `a` given `axis` evaluates to True .", "question_id": 2254},
{"snippet": "numpy.any(a, axis=None)", "intent": "Test whether any array element along `a` given `axis` evaluates to True .", "question_id": 2255},
{"snippet": "numpy.any(a, out=None)", "intent": "Test whether any array element along `a` given `axis` evaluates to True . With arguments `out`.", "question_id": 2256},
{"snippet": "numpy.any(a, keepdims=<no value>)", "intent": "Test whether any array element along `a` given `axis` evaluates to True . With arguments `keepdims`.", "question_id": 2257},
{"snippet": "numpy.any(a, where=<no value>)", "intent": "Test whether any array element along `a` given `axis` evaluates to True . With arguments `where`.", "question_id": 2258},
{"snippet": "numpy.any(a, axis=None, out=None)", "intent": "Test whether any array element along `a` given `axis` evaluates to True . With arguments `out`.", "question_id": 2259},
{"snippet": "numpy.any(a, axis=None, keepdims=<no value>)", "intent": "Test whether any array element along `a` given `axis` evaluates to True . With arguments `keepdims`.", "question_id": 2260},
{"snippet": "numpy.any(a, axis=None, where=<no value>)", "intent": "Test whether any array element along `a` given `axis` evaluates to True . With arguments `where`.", "question_id": 2261},
{"snippet": "numpy.any(a, out=None, keepdims=<no value>)", "intent": "Test whether any array element along `a` given `axis` evaluates to True . With arguments `out`, `keepdims`.", "question_id": 2262},
{"snippet": "numpy.any(a, out=None, where=<no value>)", "intent": "Test whether any array element along `a` given `axis` evaluates to True . With arguments `out`, `where`.", "question_id": 2263},
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, extobj)", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`.", "question_id": 2264},
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, extobj, out=None)", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`.", "question_id": 2265},
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, extobj, where=True)", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `where`.", "question_id": 2266},
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `casting`.", "question_id": 2267},
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, extobj, order='K')", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `order`.", "question_id": 2268},
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, extobj, dtype=None)", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `dtype`.", "question_id": 2269},
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, extobj, subok=True)", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `subok`.", "question_id": 2270},
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 2271},
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 2272},
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 2273},
{"snippet": "numpy.bitwise_or(x1, x2, /, signature)", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`.", "question_id": 2274},
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, out=None)", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `out`.", "question_id": 2275},
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, where=True)", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `where`.", "question_id": 2276},
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, casting='same_kind')", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `casting`.", "question_id": 2277},
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, order='K')", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `order`.", "question_id": 2278},
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, dtype=None)", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `dtype`.", "question_id": 2279},
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, subok=True)", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `subok`.", "question_id": 2280},
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, out=None, where=True)", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `out`, `where`.", "question_id": 2281},
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `out`, `casting`.", "question_id": 2282},
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, out=None, order='K')", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `out`, `order`.", "question_id": 2283},
{"snippet": "ma.MaskType.nbytes", "intent": "The length of the scalar in bytes.", "question_id": 2284},
{"snippet": "char.chararray.ravel(order)", "intent": "Return a flattened array . With arguments `order`.", "question_id": 2285},
{"snippet": "char.chararray.ravel()", "intent": "Return a flattened array .", "question_id": 2286},
{"snippet": "random.Generator.binomial(n, p)", "intent": "Draw samples from a binomial distribution . Samples are drawn from a binomial distribution with specified parameters , `n` trials and `p` probability of success where n an integer > = 0 and p is in the interval [ 0,1 ] .", "question_id": 2287},
{"snippet": "random.Generator.binomial(n, p, size=None)", "intent": "Draw samples from a binomial distribution . Samples are drawn from a binomial distribution with specified parameters , `n` trials and `p` probability of success where n an integer > = 0 and p is in the interval [ 0,1 ] . With arguments `size`.", "question_id": 2288},
{"snippet": "ma.flatnotmasked_edges(a)", "intent": "Find the indices of the first and last unmasked values . Expects `a` 1-D MaskedArray , returns None if all values are masked .", "question_id": 2289},
{"snippet": "numpy.einsum_path(subscripts, *operands)", "intent": "Evaluates the lowest cost contraction order for an einsum expression by considering the creation of intermediate arrays . With arguments `subscripts`, `*operands`.", "question_id": 2290},
{"snippet": "numpy.einsum_path(subscripts, *operands, optimize='greedy')", "intent": "Evaluates the lowest cost contraction order for an einsum expression by considering the creation of intermediate arrays . With arguments `subscripts`, `*operands`, `optimize`.", "question_id": 2291},
{"snippet": "polynomial.laguerre.lagsub(c1, c2)", "intent": "Subtract one Laguerre series from another . Returns the difference of two Laguerre series `c1` - `c2` .", "question_id": 2292},
{"snippet": "numpy.geomspace(start, stop)", "intent": "Return numbers spaced evenly on a log scale ( a geometric progression ) . With arguments `start`, `stop`.", "question_id": 2293},
{"snippet": "numpy.geomspace(start, stop, num=50)", "intent": "Return numbers spaced evenly on a log scale ( a geometric progression ) . With arguments `start`, `stop`, `num`.", "question_id": 2294},
{"snippet": "numpy.geomspace(start, stop, endpoint=True)", "intent": "Return numbers spaced evenly on a log scale ( a geometric progression ) . Graphical illustration of `endpoint` parameter : With arguments `start`, `stop`.", "question_id": 2295},
{"snippet": "numpy.geomspace(start, stop, dtype=None)", "intent": "Return numbers spaced evenly on a log scale ( a geometric progression ) . If the inputs or `dtype` are complex , the output will follow a logarithmic spiral in the complex plane . With arguments `start`, `stop`.", "question_id": 2296},
{"snippet": "numpy.geomspace(start, stop, axis=0)", "intent": "Return numbers spaced evenly on a log scale ( a geometric progression ) . With arguments `start`, `stop`, `axis`.", "question_id": 2297},
{"snippet": "numpy.geomspace(start, stop, num=50, endpoint=True)", "intent": "Return numbers spaced evenly on a log scale ( a geometric progression ) . Graphical illustration of `endpoint` parameter : With arguments `start`, `stop`, `num`.", "question_id": 2298},
{"snippet": "numpy.geomspace(start, stop, num=50, dtype=None)", "intent": "Return numbers spaced evenly on a log scale ( a geometric progression ) . If the inputs or `dtype` are complex , the output will follow a logarithmic spiral in the complex plane . With arguments `start`, `stop`, `num`.", "question_id": 2299},
{"snippet": "numpy.geomspace(start, stop, num=50, axis=0)", "intent": "Return numbers spaced evenly on a log scale ( a geometric progression ) . With arguments `start`, `stop`, `num`, `axis`.", "question_id": 2300},
{"snippet": "numpy.geomspace(start, stop, endpoint=True, dtype=None)", "intent": "Return numbers spaced evenly on a log scale ( a geometric progression ) . Graphical illustration of `endpoint` parameter : If the inputs or `dtype` are complex , the output will follow a logarithmic spiral in the complex plane . With arguments `start`, `stop`.", "question_id": 2301},
{"snippet": "numpy.geomspace(start, stop, endpoint=True, axis=0)", "intent": "Return numbers spaced evenly on a log scale ( a geometric progression ) . Graphical illustration of `endpoint` parameter : With arguments `start`, `stop`, `axis`.", "question_id": 2302},
{"snippet": "ma.MaskedArray.__imod__(value, /)", "intent": "Return self % =value . With arguments `value`, `/`.", "question_id": 2303},
{"snippet": "char.chararray.astype(dtype)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`.", "question_id": 2304},
{"snippet": "char.chararray.astype(dtype, order='K')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`.", "question_id": 2305},
{"snippet": "char.chararray.astype(dtype, casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`.", "question_id": 2306},
{"snippet": "char.chararray.astype(dtype, subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `subok`.", "question_id": 2307},
{"snippet": "char.chararray.astype(dtype, copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `copy`.", "question_id": 2308},
{"snippet": "char.chararray.astype(dtype, order='K', casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `casting`.", "question_id": 2309},
{"snippet": "char.chararray.astype(dtype, order='K', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `subok`.", "question_id": 2310},
{"snippet": "char.chararray.astype(dtype, order='K', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `copy`.", "question_id": 2311},
{"snippet": "char.chararray.astype(dtype, casting='unsafe', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `subok`.", "question_id": 2312},
{"snippet": "char.chararray.astype(dtype, casting='unsafe', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `copy`.", "question_id": 2313},
{"snippet": "record.mean()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 2314},
{"snippet": "matrix.byteswap()", "intent": "Swap the bytes of the array elements", "question_id": 2315},
{"snippet": "matrix.byteswap(inplace=False)", "intent": "Swap the bytes of the array elements With arguments `inplace`.", "question_id": 2316},
{"snippet": "char.chararray.newbyteorder(/)", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`.", "question_id": 2317},
{"snippet": "char.chararray.newbyteorder(/, new_order='S')", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`, `new_order`.", "question_id": 2318},
{"snippet": "ma.masked_array.sum()", "intent": "Return the sum of the array elements over the given `axis` .", "question_id": 2319},
{"snippet": "ma.masked_array.sum(axis=None)", "intent": "Return the sum of the array elements over the given `axis` .", "question_id": 2320},
{"snippet": "ma.masked_array.sum(dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 2321},
{"snippet": "ma.masked_array.sum(out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`.", "question_id": 2322},
{"snippet": "ma.masked_array.sum(keepdims=<no value>)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`.", "question_id": 2323},
{"snippet": "ma.masked_array.sum(axis=None, dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 2324},
{"snippet": "ma.masked_array.sum(axis=None, out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`.", "question_id": 2325},
{"snippet": "ma.masked_array.sum(axis=None, keepdims=<no value>)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`.", "question_id": 2326},
{"snippet": "ma.masked_array.sum(dtype=None, out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`, `out`.", "question_id": 2327},
{"snippet": "ma.masked_array.sum(dtype=None, keepdims=<no value>)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`, `keepdims`.", "question_id": 2328},
{"snippet": "ma.MaskedArray.base", "intent": "Base object if memory is from some other object.", "question_id": 2329},
{"snippet": "polynomial.laguerre.lag2poly(c)", "intent": "Convert a Laguerre series to a polynomial . With arguments `c`.", "question_id": 2330},
{"snippet": "nditer.copy()", "intent": "Get a copy of the iterator in its current state .", "question_id": 2331},
{"snippet": "chararray.replace(old, new)", "intent": "For each element in self , return a copy of the string with all occurrences of substring `old` replaced by `new` .", "question_id": 2332},
{"snippet": "chararray.replace(old, new, count=None)", "intent": "For each element in self , return a copy of the string with all occurrences of substring `old` replaced by `new` . With arguments `count`.", "question_id": 2333},
{"snippet": "ma.copy(self, *args)", "intent": "Notes With arguments `self`, `*args`.", "question_id": 2334},
{"snippet": "ma.copy(self, *args, **params) a.copy(order='C')", "intent": "Notes With arguments `self`, `*args`, `**params) a.copy(order`.", "question_id": 2335},
{"snippet": "char.chararray.isspace()", "intent": "Returns true for each element if there are only whitespace characters in the string and there is at least one character , false otherwise .", "question_id": 2336},
{"snippet": "char.chararray.zfill(width)", "intent": "Return the numeric string left-filled with zeros in a string of length `width` .", "question_id": 2337},
{"snippet": "ma.masked_array.swapaxes(axis1, axis2)", "intent": "Return a view of the array with `axis1` and `axis2` interchanged .", "question_id": 2338},
{"snippet": "char.chararray.diagonal()", "intent": "Return specified diagonals .", "question_id": 2339},
{"snippet": "char.chararray.diagonal(offset=0)", "intent": "Return specified diagonals . With arguments `offset`.", "question_id": 2340},
{"snippet": "char.chararray.diagonal(axis1=0)", "intent": "Return specified diagonals . With arguments `axis1`.", "question_id": 2341},
{"snippet": "char.chararray.diagonal(axis2=1)", "intent": "Return specified diagonals . With arguments `axis2`.", "question_id": 2342},
{"snippet": "char.chararray.diagonal(offset=0, axis1=0)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`.", "question_id": 2343},
{"snippet": "char.chararray.diagonal(offset=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis2`.", "question_id": 2344},
{"snippet": "char.chararray.diagonal(axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `axis1`, `axis2`.", "question_id": 2345},
{"snippet": "char.chararray.diagonal(offset=0, axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`, `axis2`.", "question_id": 2346},
{"snippet": "ma.masked_array.std()", "intent": "Returns the standard deviation of the array elements along given `axis` .", "question_id": 2347},
{"snippet": "ma.masked_array.std(axis=None)", "intent": "Returns the standard deviation of the array elements along given `axis` .", "question_id": 2348},
{"snippet": "ma.masked_array.std(dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`.", "question_id": 2349},
{"snippet": "ma.masked_array.std(out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`.", "question_id": 2350},
{"snippet": "ma.masked_array.std(ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`.", "question_id": 2351},
{"snippet": "ma.masked_array.std(keepdims=<no value>)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `keepdims`.", "question_id": 2352},
{"snippet": "ma.masked_array.std(axis=None, dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`.", "question_id": 2353},
{"snippet": "ma.masked_array.std(axis=None, out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`.", "question_id": 2354},
{"snippet": "ma.masked_array.std(axis=None, ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`.", "question_id": 2355},
{"snippet": "ma.masked_array.std(axis=None, keepdims=<no value>)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `keepdims`.", "question_id": 2356},
{"snippet": "random.Generator.multivariate_normal(mean, cov)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . We can use a different method other than the default to factorize `cov` : > > > y = rng.multivariate_normal ( mean , cov , ( 3 , 3 ) , method= \u2019 cholesky \u2019 ) > > > y.shape ( 3 , 3 , 2 )", "question_id": 2357},
{"snippet": "random.Generator.multivariate_normal(mean, cov, size=None)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . We can use a different method other than the default to factorize `cov` : > > > y = rng.multivariate_normal ( mean , cov , ( 3 , 3 ) , method= \u2019 cholesky \u2019 ) > > > y.shape ( 3 , 3 , 2 ) With arguments `size`.", "question_id": 2358},
{"snippet": "random.Generator.multivariate_normal(mean, cov, check_valid='warn')", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . We can use a different method other than the default to factorize `cov` : > > > y = rng.multivariate_normal ( mean , cov , ( 3 , 3 ) , method= \u2019 cholesky \u2019 ) > > > y.shape ( 3 , 3 , 2 ) With arguments `check_valid`.", "question_id": 2359},
{"snippet": "random.Generator.multivariate_normal(mean, cov, tol=1e-8)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . We can use a different method other than the default to factorize `cov` : > > > y = rng.multivariate_normal ( mean , cov , ( 3 , 3 ) , method= \u2019 cholesky \u2019 ) > > > y.shape ( 3 , 3 , 2 ) With arguments `tol`.", "question_id": 2360},
{"snippet": "random.Generator.multivariate_normal(mean, cov, method='svd')", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . We can use a different method other than the default to factorize `cov` : > > > y = rng.multivariate_normal ( mean , cov , ( 3 , 3 ) , method= \u2019 cholesky \u2019 ) > > > y.shape ( 3 , 3 , 2 ) Otherwise , the behavior of this `method` is undefined and backwards compatibility is not guaranteed .", "question_id": 2361},
{"snippet": "random.Generator.multivariate_normal(mean, cov, size=None, check_valid='warn')", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . We can use a different method other than the default to factorize `cov` : > > > y = rng.multivariate_normal ( mean , cov , ( 3 , 3 ) , method= \u2019 cholesky \u2019 ) > > > y.shape ( 3 , 3 , 2 ) With arguments `size`, `check_valid`.", "question_id": 2362},
{"snippet": "random.Generator.multivariate_normal(mean, cov, size=None, tol=1e-8)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . We can use a different method other than the default to factorize `cov` : > > > y = rng.multivariate_normal ( mean , cov , ( 3 , 3 ) , method= \u2019 cholesky \u2019 ) > > > y.shape ( 3 , 3 , 2 ) With arguments `size`, `tol`.", "question_id": 2363},
{"snippet": "random.Generator.multivariate_normal(mean, cov, size=None, method='svd')", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . We can use a different method other than the default to factorize `cov` : > > > y = rng.multivariate_normal ( mean , cov , ( 3 , 3 ) , method= \u2019 cholesky \u2019 ) > > > y.shape ( 3 , 3 , 2 ) Otherwise , the behavior of this `method` is undefined and backwards compatibility is not guaranteed . With arguments `size`.", "question_id": 2364},
{"snippet": "random.Generator.multivariate_normal(mean, cov, check_valid='warn', tol=1e-8)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . We can use a different method other than the default to factorize `cov` : > > > y = rng.multivariate_normal ( mean , cov , ( 3 , 3 ) , method= \u2019 cholesky \u2019 ) > > > y.shape ( 3 , 3 , 2 ) With arguments `check_valid`, `tol`.", "question_id": 2365},
{"snippet": "random.Generator.multivariate_normal(mean, cov, check_valid='warn', method='svd')", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . We can use a different method other than the default to factorize `cov` : > > > y = rng.multivariate_normal ( mean , cov , ( 3 , 3 ) , method= \u2019 cholesky \u2019 ) > > > y.shape ( 3 , 3 , 2 ) Otherwise , the behavior of this `method` is undefined and backwards compatibility is not guaranteed . With arguments `check_valid`.", "question_id": 2366},
{"snippet": "random.Generator.hypergeometric(ngood, nbad, nsample)", "intent": "Draw samples from a Hypergeometric distribution . Samples are drawn from a hypergeometric distribution with specified parameters , `ngood` ( ways to make a good selection ) , `nbad` ( ways to make a bad selection ) , and `nsample` ( number of items sampled , which is less than or equal to the sum ngood + nbad ) .", "question_id": 2367},
{"snippet": "random.Generator.hypergeometric(ngood, nbad, nsample, size=None)", "intent": "Draw samples from a Hypergeometric distribution . Samples are drawn from a hypergeometric distribution with specified parameters , `ngood` ( ways to make a good selection ) , `nbad` ( ways to make a bad selection ) , and `nsample` ( number of items sampled , which is less than or equal to the sum ngood + nbad ) . With arguments `size`.", "question_id": 2368},
{"snippet": "memmap.flags", "intent": "Information about the memory layout of the array.", "question_id": 2369},
{"snippet": "char.chararray.T", "intent": "The transposed array.", "question_id": 2370},
{"snippet": "random.RandomState.get_state()", "intent": "Return a tuple representing the internal state of the generator .", "question_id": 2371},
{"snippet": "record.flags", "intent": "integer value of flags", "question_id": 2372},
{"snippet": "recarray.choose(choices)", "intent": "Use an index array to construct a new array from a set of `choices` .", "question_id": 2373},
{"snippet": "recarray.choose(choices, out=None)", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`.", "question_id": 2374},
{"snippet": "recarray.choose(choices, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `mode`.", "question_id": 2375},
{"snippet": "recarray.choose(choices, out=None, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`, `mode`.", "question_id": 2376},
{"snippet": "ndarray.__ixor__(value, /)", "intent": "Return self^=value . With arguments `value`, `/`.", "question_id": 2377},
{"snippet": "polynomial.laguerre.Laguerre.roots()", "intent": "Return the roots of the series polynomial .", "question_id": 2378},
{"snippet": "polynomial.laguerre.poly2lag(pol)", "intent": "Convert a polynomial to a Laguerre series . With arguments `pol`.", "question_id": 2379},
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, extobj)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `extobj`.", "question_id": 2380},
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, extobj, out=(None)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `out`.", "question_id": 2381},
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, extobj, where=True)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . Returns ( mantissa , exponent ) , `where` x = mantissa * 2 * * exponent ` . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `extobj`.", "question_id": 2382},
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, extobj, casting='same_kind')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `casting`.", "question_id": 2383},
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, extobj, order='K')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `order`.", "question_id": 2384},
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, extobj, dtype=None)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `dtype`.", "question_id": 2385},
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, extobj, subok=True)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `subok`.", "question_id": 2386},
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, extobj, out=(None, where=True)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . Returns ( mantissa , exponent ) , `where` x = mantissa * 2 * * exponent ` . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `out`.", "question_id": 2387},
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, extobj, out=(None, casting='same_kind')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `out`, `casting`.", "question_id": 2388},
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, extobj, out=(None, order='K')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `out`, `order`.", "question_id": 2389},
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`.", "question_id": 2390},
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, out=(None)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `out`.", "question_id": 2391},
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, where=True)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . Returns ( mantissa , exponent ) , `where` x = mantissa * 2 * * exponent ` . With arguments `out1`, `out2`, `/`, `None)`, `signature`.", "question_id": 2392},
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, casting='same_kind')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `casting`.", "question_id": 2393},
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, order='K')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `order`.", "question_id": 2394},
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, dtype=None)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `dtype`.", "question_id": 2395},
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, subok=True)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `subok`.", "question_id": 2396},
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, out=(None, where=True)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . Returns ( mantissa , exponent ) , `where` x = mantissa * 2 * * exponent ` . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `out`.", "question_id": 2397},
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, out=(None, casting='same_kind')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `out`, `casting`.", "question_id": 2398},
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, out=(None, order='K')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `out`, `order`.", "question_id": 2399},
{"snippet": "numpy.frexp(x, out1, out2, /, None))", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`.", "question_id": 2400},
{"snippet": "numpy.frexp(x, out1, out2, /, None), out=(None)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `out`.", "question_id": 2401},
{"snippet": "numpy.frexp(x, out1, out2, /, None), where=True)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . Returns ( mantissa , exponent ) , `where` x = mantissa * 2 * * exponent ` . With arguments `out1`, `out2`, `/`, `None)`.", "question_id": 2402},
{"snippet": "numpy.frexp(x, out1, out2, /, None), casting='same_kind')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `casting`.", "question_id": 2403},
{"snippet": "numpy.frexp(x, out1, out2, /, None), order='K')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `order`.", "question_id": 2404},
{"snippet": "numpy.frexp(x, out1, out2, /, None), dtype=None)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `dtype`.", "question_id": 2405},
{"snippet": "numpy.frexp(x, out1, out2, /, None), subok=True)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `subok`.", "question_id": 2406},
{"snippet": "numpy.frexp(x, out1, out2, /, None), out=(None, where=True)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . Returns ( mantissa , exponent ) , `where` x = mantissa * 2 * * exponent ` . With arguments `out1`, `out2`, `/`, `None)`, `out`.", "question_id": 2407},
{"snippet": "numpy.frexp(x, out1, out2, /, None), out=(None, casting='same_kind')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `out`, `casting`.", "question_id": 2408},
{"snippet": "numpy.frexp(x, out1, out2, /, None), out=(None, order='K')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `out`, `order`.", "question_id": 2409},
{"snippet": "numpy.frexp(x, out1, out2, /)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`.", "question_id": 2410},
{"snippet": "numpy.frexp(x, out1, out2, /, out=(None)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `out`.", "question_id": 2411},
{"snippet": "numpy.frexp(x, out1, out2, /, where=True)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . Returns ( mantissa , exponent ) , `where` x = mantissa * 2 * * exponent ` . With arguments `out1`, `out2`, `/`.", "question_id": 2412},
{"snippet": "numpy.frexp(x, out1, out2, /, casting='same_kind')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `casting`.", "question_id": 2413},
{"snippet": "numpy.frexp(x, out1, out2, /, order='K')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `order`.", "question_id": 2414},
{"snippet": "numpy.frexp(x, out1, out2, /, dtype=None)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `dtype`.", "question_id": 2415},
{"snippet": "numpy.frexp(x, out1, out2, /, subok=True)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `subok`.", "question_id": 2416},
{"snippet": "numpy.frexp(x, out1, out2, /, out=(None, where=True)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . Returns ( mantissa , exponent ) , `where` x = mantissa * 2 * * exponent ` . With arguments `out1`, `out2`, `/`, `out`.", "question_id": 2417},
{"snippet": "numpy.frexp(x, out1, out2, /, out=(None, casting='same_kind')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `out`, `casting`.", "question_id": 2418},
{"snippet": "numpy.frexp(x, out1, out2, /, out=(None, order='K')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `out`, `order`.", "question_id": 2419},
{"snippet": "random.Generator.logseries(p)", "intent": "Draw samples from a logarithmic series distribution . Samples are drawn from a log series distribution with specified shape parameter , 0 < `p` < 1 .", "question_id": 2420},
{"snippet": "random.Generator.logseries(p, size=None)", "intent": "Draw samples from a logarithmic series distribution . Samples are drawn from a log series distribution with specified shape parameter , 0 < `p` < 1 . With arguments `size`.", "question_id": 2421},
{"snippet": "ndarray.__new__(*args, **kwargs)", "intent": "Create and return a new object . With arguments `*args`, `**kwargs`.", "question_id": 2422},
{"snippet": "recarray.ptp()", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` .", "question_id": 2423},
{"snippet": "recarray.ptp(axis=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` .", "question_id": 2424},
{"snippet": "recarray.ptp(out=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`.", "question_id": 2425},
{"snippet": "recarray.ptp(keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `keepdims`.", "question_id": 2426},
{"snippet": "recarray.ptp(axis=None, out=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`.", "question_id": 2427},
{"snippet": "recarray.ptp(axis=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `keepdims`.", "question_id": 2428},
{"snippet": "recarray.ptp(out=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`, `keepdims`.", "question_id": 2429},
{"snippet": "recarray.ptp(axis=None, out=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`, `keepdims`.", "question_id": 2430},
{"snippet": "ma.MaskedArray.__rlshift__(value, /)", "intent": "Return `value` < < self . With arguments `/`.", "question_id": 2431},
{"snippet": "numpy.floor_divide(x1, x2, /, signature, extobj)", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `extobj`.", "question_id": 2432},
{"snippet": "numpy.floor_divide(x1, x2, /, signature, extobj, out=None)", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`.", "question_id": 2433},
{"snippet": "numpy.floor_divide(x1, x2, /, signature, extobj, where=True)", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `where`.", "question_id": 2434},
{"snippet": "numpy.floor_divide(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `casting`.", "question_id": 2435},
{"snippet": "numpy.floor_divide(x1, x2, /, signature, extobj, order='K')", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `order`.", "question_id": 2436},
{"snippet": "numpy.floor_divide(x1, x2, /, signature, extobj, dtype=None)", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `dtype`.", "question_id": 2437},
{"snippet": "numpy.floor_divide(x1, x2, /, signature, extobj, subok=True)", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `subok`.", "question_id": 2438},
{"snippet": "numpy.floor_divide(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 2439},
{"snippet": "numpy.floor_divide(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 2440},
{"snippet": "numpy.floor_divide(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 2441},
{"snippet": "numpy.floor_divide(x1, x2, /, signature)", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`.", "question_id": 2442},
{"snippet": "numpy.floor_divide(x1, x2, /, signature, out=None)", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `out`.", "question_id": 2443},
{"snippet": "numpy.floor_divide(x1, x2, /, signature, where=True)", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `where`.", "question_id": 2444},
{"snippet": "numpy.floor_divide(x1, x2, /, signature, casting='same_kind')", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `casting`.", "question_id": 2445},
{"snippet": "numpy.floor_divide(x1, x2, /, signature, order='K')", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `order`.", "question_id": 2446},
{"snippet": "numpy.floor_divide(x1, x2, /, signature, dtype=None)", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `dtype`.", "question_id": 2447},
{"snippet": "numpy.floor_divide(x1, x2, /, signature, subok=True)", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `subok`.", "question_id": 2448},
{"snippet": "numpy.floor_divide(x1, x2, /, signature, out=None, where=True)", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `out`, `where`.", "question_id": 2449},
{"snippet": "numpy.floor_divide(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `out`, `casting`.", "question_id": 2450},
{"snippet": "numpy.floor_divide(x1, x2, /, signature, out=None, order='K')", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `out`, `order`.", "question_id": 2451},
{"snippet": "ma.MaskedArray.dump(file)", "intent": "Dump a pickle of the array to the specified `file` .", "question_id": 2452},
{"snippet": "polynomial.polynomial.polyvander3d(x, y, z, deg)", "intent": "Pseudo-Vandermonde matrix of given degrees . Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points ( `x` , `y` , `z` ) .", "question_id": 2453},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_untied(names)", "intent": "same as \u2018 feature_ahead ( ) \u2019 but if both features implied each other and keep the highest interest . With arguments `names`.", "question_id": 2454},
{"snippet": "ma.MaskedArray.__rsub__(other)", "intent": "Subtract self from `other` , and return a new masked array .", "question_id": 2455},
{"snippet": "polynomial.chebyshev.chebline(off, scl)", "intent": "Chebyshev series whose graph is a straight line . With arguments `off`, `scl`.", "question_id": 2456},
{"snippet": "ma.MaskedArray.flatten()", "intent": "Return a copy of the array collapsed into one dimension .", "question_id": 2457},
{"snippet": "ma.MaskedArray.flatten(order='C')", "intent": "Return a copy of the array collapsed into one dimension . With arguments `order`.", "question_id": 2458},
{"snippet": "random.RandomState.standard_cauchy()", "intent": "Draw samples from a standard Cauchy distribution with mode = 0 .", "question_id": 2459},
{"snippet": "random.RandomState.standard_cauchy(size=None)", "intent": "Draw samples from a standard Cauchy distribution with mode = 0 . With arguments `size`.", "question_id": 2460},
{"snippet": "dtype.isnative", "intent": "Boolean indicating whether the byte order of this dtype is native to the platform.", "question_id": 2461},
{"snippet": "random.RandomState.wald(mean, scale)", "intent": "Draw samples from a Wald , or inverse Gaussian , distribution . Some references claim that the Wald is an inverse Gaussian with `mean` equal to 1 , but this is by no means universal . As the `scale` approaches infinity , the distribution becomes more like a Gaussian .", "question_id": 2462},
{"snippet": "random.RandomState.wald(mean, scale, size=None)", "intent": "Draw samples from a Wald , or inverse Gaussian , distribution . Some references claim that the Wald is an inverse Gaussian with `mean` equal to 1 , but this is by no means universal . As the `scale` approaches infinity , the distribution becomes more like a Gaussian . With arguments `size`.", "question_id": 2463},
{"snippet": "ma.ones(shape)", "intent": "Return a new array of given `shape` and type , filled with ones .", "question_id": 2464},
{"snippet": "ma.ones(shape, dtype=None)", "intent": "Return a new array of given `shape` and type , filled with ones . With arguments `dtype`.", "question_id": 2465},
{"snippet": "ma.ones(shape, order='C')", "intent": "Return a new array of given `shape` and type , filled with ones . With arguments `order`.", "question_id": 2466},
{"snippet": "ma.ones(shape, dtype=None, order='C')", "intent": "Return a new array of given `shape` and type , filled with ones . With arguments `dtype`, `order`.", "question_id": 2467},
{"snippet": "numpy.unwrap(p)", "intent": "Unwrap by taking the complement of large deltas with respect to the `period` . This unwraps a signal `p` by changing elements which have an absolute difference from their predecessor of more than max ( `discont` , period/2 ) to their period-complementary values .", "question_id": 2468},
{"snippet": "numpy.unwrap(p, discont=None)", "intent": "Unwrap by taking the complement of large deltas with respect to the `period` . This unwraps a signal `p` by changing elements which have an absolute difference from their predecessor of more than max ( `discont` , period/2 ) to their period-complementary values .", "question_id": 2469},
{"snippet": "numpy.unwrap(p, axis=- 1)", "intent": "Unwrap by taking the complement of large deltas with respect to the `period` . This unwraps a signal `p` by changing elements which have an absolute difference from their predecessor of more than max ( `discont` , period/2 ) to their period-complementary values . With arguments `axis`.", "question_id": 2470},
{"snippet": "numpy.unwrap(p, period=6.283185307179586)", "intent": "Unwrap by taking the complement of large deltas with respect to the `period` . This unwraps a signal `p` by changing elements which have an absolute difference from their predecessor of more than max ( `discont` , period/2 ) to their period-complementary values .", "question_id": 2471},
{"snippet": "numpy.unwrap(p, discont=None, axis=- 1)", "intent": "Unwrap by taking the complement of large deltas with respect to the `period` . This unwraps a signal `p` by changing elements which have an absolute difference from their predecessor of more than max ( `discont` , period/2 ) to their period-complementary values . With arguments `axis`.", "question_id": 2472},
{"snippet": "numpy.unwrap(p, discont=None, period=6.283185307179586)", "intent": "Unwrap by taking the complement of large deltas with respect to the `period` . This unwraps a signal `p` by changing elements which have an absolute difference from their predecessor of more than max ( `discont` , period/2 ) to their period-complementary values .", "question_id": 2473},
{"snippet": "numpy.unwrap(p, axis=- 1, period=6.283185307179586)", "intent": "Unwrap by taking the complement of large deltas with respect to the `period` . This unwraps a signal `p` by changing elements which have an absolute difference from their predecessor of more than max ( `discont` , period/2 ) to their period-complementary values . With arguments `axis`.", "question_id": 2474},
{"snippet": "numpy.unwrap(p, discont=None, axis=- 1, period=6.283185307179586)", "intent": "Unwrap by taking the complement of large deltas with respect to the `period` . This unwraps a signal `p` by changing elements which have an absolute difference from their predecessor of more than max ( `discont` , period/2 ) to their period-complementary values . With arguments `axis`.", "question_id": 2475},
{"snippet": "polynomial.legendre.Legendre.cast(series)", "intent": "Convert `series` to series of this class .", "question_id": 2476},
{"snippet": "polynomial.legendre.Legendre.cast(series, domain=None)", "intent": "Convert `series` to series of this class . With arguments `domain`.", "question_id": 2477},
{"snippet": "polynomial.legendre.Legendre.cast(series, window=None)", "intent": "Convert `series` to series of this class . With arguments `window`.", "question_id": 2478},
{"snippet": "polynomial.legendre.Legendre.cast(series, domain=None, window=None)", "intent": "Convert `series` to series of this class . With arguments `domain`, `window`.", "question_id": 2479},
{"snippet": "numpy.argwhere(a)", "intent": "Find the indices of array elements that are non-zero , grouped by element . np.argwhere ( `a` ) is almost the same as np.transpose ( np.nonzero ( a ) ) , but produces a result of the correct shape for a 0D array .", "question_id": 2480},
{"snippet": "ndarray.nonzero()", "intent": "Return the indices of the elements that are non-zero .", "question_id": 2481},
{"snippet": "numpy.roll(a, shift)", "intent": "Roll array elements along `a` given `axis` . With arguments `shift`.", "question_id": 2482},
{"snippet": "numpy.roll(a, shift, axis=None)", "intent": "Roll array elements along `a` given `axis` . With arguments `shift`.", "question_id": 2483},
{"snippet": "numpy.true_divide(x1, x2, /, signature, extobj)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`.", "question_id": 2484},
{"snippet": "numpy.true_divide(x1, x2, /, signature, extobj, out=None)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `out`.", "question_id": 2485},
{"snippet": "numpy.true_divide(x1, x2, /, signature, extobj, where=True)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `where`.", "question_id": 2486},
{"snippet": "numpy.true_divide(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `casting`.", "question_id": 2487},
{"snippet": "numpy.true_divide(x1, x2, /, signature, extobj, order='K')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `order`.", "question_id": 2488},
{"snippet": "numpy.true_divide(x1, x2, /, signature, extobj, dtype=None)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `dtype`.", "question_id": 2489},
{"snippet": "numpy.true_divide(x1, x2, /, signature, extobj, subok=True)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `subok`.", "question_id": 2490},
{"snippet": "numpy.true_divide(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `out`, `where`.", "question_id": 2491},
{"snippet": "numpy.true_divide(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `out`, `casting`.", "question_id": 2492},
{"snippet": "numpy.true_divide(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `out`, `order`.", "question_id": 2493},
{"snippet": "numpy.true_divide(x1, x2, /, signature)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`.", "question_id": 2494},
{"snippet": "numpy.true_divide(x1, x2, /, signature, out=None)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `out`.", "question_id": 2495},
{"snippet": "numpy.true_divide(x1, x2, /, signature, where=True)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `where`.", "question_id": 2496},
{"snippet": "numpy.true_divide(x1, x2, /, signature, casting='same_kind')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `casting`.", "question_id": 2497},
{"snippet": "numpy.true_divide(x1, x2, /, signature, order='K')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `order`.", "question_id": 2498},
{"snippet": "numpy.true_divide(x1, x2, /, signature, dtype=None)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `dtype`.", "question_id": 2499},
{"snippet": "numpy.true_divide(x1, x2, /, signature, subok=True)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `subok`.", "question_id": 2500},
{"snippet": "numpy.true_divide(x1, x2, /, signature, out=None, where=True)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `out`, `where`.", "question_id": 2501},
{"snippet": "numpy.true_divide(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `out`, `casting`.", "question_id": 2502},
{"snippet": "numpy.true_divide(x1, x2, /, signature, out=None, order='K')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `out`, `order`.", "question_id": 2503},
{"snippet": "ma.cumprod(self)", "intent": "Return the cumulative product of the array elements over the given `axis` . With arguments `self`.", "question_id": 2504},
{"snippet": "ma.cumprod(self, axis=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . With arguments `self`.", "question_id": 2505},
{"snippet": "ma.cumprod(self, dtype=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . With arguments `self`, `dtype`.", "question_id": 2506},
{"snippet": "ma.cumprod(self, out=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . The mask is lost if `out` is not a valid MaskedArray ! With arguments `self`.", "question_id": 2507},
{"snippet": "ma.cumprod(self, axis=None, dtype=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . With arguments `self`, `dtype`.", "question_id": 2508},
{"snippet": "ma.cumprod(self, axis=None, out=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . The mask is lost if `out` is not a valid MaskedArray ! With arguments `self`.", "question_id": 2509},
{"snippet": "ma.cumprod(self, dtype=None, out=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . The mask is lost if `out` is not a valid MaskedArray ! With arguments `self`, `dtype`.", "question_id": 2510},
{"snippet": "ma.cumprod(self, axis=None, dtype=None, out=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . The mask is lost if `out` is not a valid MaskedArray ! With arguments `self`, `dtype`.", "question_id": 2511},
{"snippet": "matrix.cumsum()", "intent": "Return the cumulative sum of the elements along the given `axis` .", "question_id": 2512},
{"snippet": "matrix.cumsum(axis=None)", "intent": "Return the cumulative sum of the elements along the given `axis` .", "question_id": 2513},
{"snippet": "matrix.cumsum(dtype=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`.", "question_id": 2514},
{"snippet": "matrix.cumsum(out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `out`.", "question_id": 2515},
{"snippet": "matrix.cumsum(axis=None, dtype=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`.", "question_id": 2516},
{"snippet": "matrix.cumsum(axis=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `out`.", "question_id": 2517},
{"snippet": "matrix.cumsum(dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 2518},
{"snippet": "matrix.cumsum(axis=None, dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 2519},
{"snippet": "ma.MaskType.data", "intent": "Pointer to start of data.", "question_id": 2520},
{"snippet": "ndarray.choose(choices)", "intent": "Use an index array to construct a new array from a set of `choices` .", "question_id": 2521},
{"snippet": "ndarray.choose(choices, out=None)", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`.", "question_id": 2522},
{"snippet": "ndarray.choose(choices, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `mode`.", "question_id": 2523},
{"snippet": "ndarray.choose(choices, out=None, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`, `mode`.", "question_id": 2524},
{"snippet": "memmap.nonzero()", "intent": "Return the indices of the elements that are non-zero .", "question_id": 2525},
{"snippet": "numpy.searchsorted(a, v)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into `a` sorted array a such that , if the corresponding elements in `v` were inserted before the indices , the order of a would be preserved .", "question_id": 2526},
{"snippet": "numpy.searchsorted(a, v, side='left')", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into `a` sorted array a such that , if the corresponding elements in `v` were inserted before the indices , the order of a would be preserved . With arguments `side`.", "question_id": 2527},
{"snippet": "numpy.searchsorted(a, v, sorter=None)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into `a` sorted array a such that , if the corresponding elements in `v` were inserted before the indices , the order of a would be preserved . With arguments `sorter`.", "question_id": 2528},
{"snippet": "numpy.searchsorted(a, v, side='left', sorter=None)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into `a` sorted array a such that , if the corresponding elements in `v` were inserted before the indices , the order of a would be preserved . With arguments `side`, `sorter`.", "question_id": 2529},
{"snippet": "fft.rfft2(a, - 1))", "intent": "Compute the 2-dimensional FFT of `a` real array . With arguments `- 1)`.", "question_id": 2530},
{"snippet": "fft.rfft2(a, - 1), s=None)", "intent": "Compute the 2-dimensional FFT of `a` real array . With arguments `- 1)`, `s`.", "question_id": 2531},
{"snippet": "fft.rfft2(a, - 1), axes=(- 2)", "intent": "Compute the 2-dimensional FFT of `a` real array . With arguments `- 1)`, `axes`.", "question_id": 2532},
{"snippet": "fft.rfft2(a, - 1), norm=None)", "intent": "Compute the 2-dimensional FFT of `a` real array . With arguments `- 1)`, `norm`.", "question_id": 2533},
{"snippet": "fft.rfft2(a, - 1), s=None, axes=(- 2)", "intent": "Compute the 2-dimensional FFT of `a` real array . With arguments `- 1)`, `s`, `axes`.", "question_id": 2534},
{"snippet": "fft.rfft2(a, - 1), s=None, norm=None)", "intent": "Compute the 2-dimensional FFT of `a` real array . With arguments `- 1)`, `s`, `norm`.", "question_id": 2535},
{"snippet": "fft.rfft2(a, - 1), axes=(- 2, norm=None)", "intent": "Compute the 2-dimensional FFT of `a` real array . With arguments `- 1)`, `axes`, `norm`.", "question_id": 2536},
{"snippet": "fft.rfft2(a, - 1), s=None, axes=(- 2, norm=None)", "intent": "Compute the 2-dimensional FFT of `a` real array . With arguments `- 1)`, `s`, `axes`, `norm`.", "question_id": 2537},
{"snippet": "chararray.tolist()", "intent": "Return the array as an a.ndim-levels deep nested list of Python scalars .", "question_id": 2538},
{"snippet": "chararray.ljust(width)", "intent": "Return an array with the elements of self left-justified in a string of length `width` .", "question_id": 2539},
{"snippet": "chararray.ljust(width, fillchar=' ')", "intent": "Return an array with the elements of self left-justified in a string of length `width` . With arguments `fillchar`.", "question_id": 2540},
{"snippet": "random.Generator.shuffle(x)", "intent": "Modify an array or sequence in-place by shuffling its contents . With arguments `x`.", "question_id": 2541},
{"snippet": "random.Generator.shuffle(x, axis=0)", "intent": "Modify an array or sequence in-place by shuffling its contents . With arguments `x`, `axis`.", "question_id": 2542},
{"snippet": "numpy.get_include()", "intent": "Return the directory that contains the NumPy * .h header files .", "question_id": 2543},
{"snippet": "matlib.repmat(a, m, n)", "intent": "Repeat `a` 0-D to 2-D array or matrix MxN times . With arguments `m`, `n`.", "question_id": 2544},
{"snippet": "random.Generator.gamma(shape)", "intent": "Draw samples from a Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and `scale` ( sometimes designated \u201c theta \u201d ) , where both parameters are > 0 .", "question_id": 2545},
{"snippet": "random.Generator.gamma(shape, scale=1.0)", "intent": "Draw samples from a Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and `scale` ( sometimes designated \u201c theta \u201d ) , where both parameters are > 0 .", "question_id": 2546},
{"snippet": "random.Generator.gamma(shape, size=None)", "intent": "Draw samples from a Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and `scale` ( sometimes designated \u201c theta \u201d ) , where both parameters are > 0 . With arguments `size`.", "question_id": 2547},
{"snippet": "random.Generator.gamma(shape, scale=1.0, size=None)", "intent": "Draw samples from a Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and `scale` ( sometimes designated \u201c theta \u201d ) , where both parameters are > 0 . With arguments `size`.", "question_id": 2548},
{"snippet": "char.chararray.max()", "intent": "Return the maximum along a given `axis` .", "question_id": 2549},
{"snippet": "char.chararray.max(axis=None)", "intent": "Return the maximum along a given `axis` .", "question_id": 2550},
{"snippet": "char.chararray.max(out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`.", "question_id": 2551},
{"snippet": "char.chararray.max(keepdims=False)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`.", "question_id": 2552},
{"snippet": "char.chararray.max(initial=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `initial`.", "question_id": 2553},
{"snippet": "char.chararray.max(where=True)", "intent": "Return the maximum along a given `axis` . With arguments `where`.", "question_id": 2554},
{"snippet": "char.chararray.max(axis=None, out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`.", "question_id": 2555},
{"snippet": "char.chararray.max(axis=None, keepdims=False)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`.", "question_id": 2556},
{"snippet": "char.chararray.max(axis=None, initial=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `initial`.", "question_id": 2557},
{"snippet": "char.chararray.max(axis=None, where=True)", "intent": "Return the maximum along a given `axis` . With arguments `where`.", "question_id": 2558},
{"snippet": "polynomial.hermite.hermpow(c, pow)", "intent": "Raise a Hermite series to a power . Returns the Hermite series `c` raised to the power `pow` .", "question_id": 2559},
{"snippet": "polynomial.hermite.hermpow(c, pow, maxpower=16)", "intent": "Raise a Hermite series to a power . Returns the Hermite series `c` raised to the power `pow` . With arguments `maxpower`.", "question_id": 2560},
{"snippet": "char.chararray.replace(old, new)", "intent": "For each element in self , return a copy of the string with all occurrences of substring `old` replaced by `new` .", "question_id": 2561},
{"snippet": "char.chararray.replace(old, new, count=None)", "intent": "For each element in self , return a copy of the string with all occurrences of substring `old` replaced by `new` . With arguments `count`.", "question_id": 2562},
{"snippet": "ma.masked_array.product()", "intent": "Return the product of the array elements over the given `axis` .", "question_id": 2563},
{"snippet": "ma.masked_array.product(axis=None)", "intent": "Return the product of the array elements over the given `axis` .", "question_id": 2564},
{"snippet": "ma.masked_array.product(dtype=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 2565},
{"snippet": "ma.masked_array.product(out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `out`.", "question_id": 2566},
{"snippet": "ma.masked_array.product(keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `keepdims`.", "question_id": 2567},
{"snippet": "ma.masked_array.product(axis=None, dtype=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 2568},
{"snippet": "ma.masked_array.product(axis=None, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `out`.", "question_id": 2569},
{"snippet": "ma.masked_array.product(axis=None, keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `keepdims`.", "question_id": 2570},
{"snippet": "ma.masked_array.product(dtype=None, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`, `out`.", "question_id": 2571},
{"snippet": "ma.masked_array.product(dtype=None, keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`, `keepdims`.", "question_id": 2572},
{"snippet": "polynomial.chebyshev.chebmul(c1, c2)", "intent": "Multiply one Chebyshev series by another . Returns the product of two Chebyshev series `c1` * `c2` .", "question_id": 2573},
{"snippet": "record.pprint()", "intent": "Pretty-print all fields .", "question_id": 2574},
{"snippet": "chararray.astype(dtype)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`.", "question_id": 2575},
{"snippet": "chararray.astype(dtype, order='K')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`.", "question_id": 2576},
{"snippet": "chararray.astype(dtype, casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`.", "question_id": 2577},
{"snippet": "chararray.astype(dtype, subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `subok`.", "question_id": 2578},
{"snippet": "chararray.astype(dtype, copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `copy`.", "question_id": 2579},
{"snippet": "chararray.astype(dtype, order='K', casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `casting`.", "question_id": 2580},
{"snippet": "chararray.astype(dtype, order='K', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `subok`.", "question_id": 2581},
{"snippet": "chararray.astype(dtype, order='K', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `copy`.", "question_id": 2582},
{"snippet": "chararray.astype(dtype, casting='unsafe', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `subok`.", "question_id": 2583},
{"snippet": "chararray.astype(dtype, casting='unsafe', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `copy`.", "question_id": 2584},
{"snippet": "ufunc.types", "intent": "Returns a list with types grouped input->output.", "question_id": 2585},
{"snippet": "ma.MaskedArray.itemsize", "intent": "Length of one array element in bytes.", "question_id": 2586},
{"snippet": "chararray.expandtabs()", "intent": "Return a copy of each string element where all tab characters are replaced by one or more spaces .", "question_id": 2587},
{"snippet": "chararray.expandtabs(tabsize=8)", "intent": "Return a copy of each string element where all tab characters are replaced by one or more spaces . With arguments `tabsize`.", "question_id": 2588},
{"snippet": "record.conjugate()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 2589},
{"snippet": "polynomial.legendre.Legendre.fit(x, y, deg)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`.", "question_id": 2590},
{"snippet": "polynomial.legendre.Legendre.fit(x, y, deg, domain=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`.", "question_id": 2591},
{"snippet": "polynomial.legendre.Legendre.fit(x, y, deg, rcond=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `rcond`.", "question_id": 2592},
{"snippet": "polynomial.legendre.Legendre.fit(x, y, deg, full=False)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `full`.", "question_id": 2593},
{"snippet": "polynomial.legendre.Legendre.fit(x, y, deg, w=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `w`.", "question_id": 2594},
{"snippet": "polynomial.legendre.Legendre.fit(x, y, deg, window=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `window`.", "question_id": 2595},
{"snippet": "polynomial.legendre.Legendre.fit(x, y, deg, domain=None, rcond=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `rcond`.", "question_id": 2596},
{"snippet": "polynomial.legendre.Legendre.fit(x, y, deg, domain=None, full=False)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `full`.", "question_id": 2597},
{"snippet": "polynomial.legendre.Legendre.fit(x, y, deg, domain=None, w=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `w`.", "question_id": 2598},
{"snippet": "polynomial.legendre.Legendre.fit(x, y, deg, domain=None, window=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `window`.", "question_id": 2599},
{"snippet": "numpy.split(ary, indices_or_sections)", "intent": "Split an array into multiple sub-arrays as views into `ary` . With arguments `indices_or_sections`.", "question_id": 2600},
{"snippet": "numpy.split(ary, indices_or_sections, axis=0)", "intent": "Split an array into multiple sub-arrays as views into `ary` . With arguments `indices_or_sections`, `axis`.", "question_id": 2601},
{"snippet": "recarray.put(indices, values)", "intent": "Set a.flat [ n ] = `values` [ n ] for all n in `indices` .", "question_id": 2602},
{"snippet": "recarray.put(indices, values, mode='raise')", "intent": "Set a.flat [ n ] = `values` [ n ] for all n in `indices` . With arguments `mode`.", "question_id": 2603},
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, extobj)", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`.", "question_id": 2604},
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, extobj, out=None)", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`.", "question_id": 2605},
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, extobj, where=True)", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `where`.", "question_id": 2606},
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `casting`.", "question_id": 2607},
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, extobj, order='K')", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `order`.", "question_id": 2608},
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, extobj, dtype=None)", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `dtype`.", "question_id": 2609},
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, extobj, subok=True)", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `subok`.", "question_id": 2610},
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 2611},
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 2612},
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 2613},
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature)", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`.", "question_id": 2614},
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, out=None)", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `out`.", "question_id": 2615},
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, where=True)", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `where`.", "question_id": 2616},
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, casting='same_kind')", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `casting`.", "question_id": 2617},
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, order='K')", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `order`.", "question_id": 2618},
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, dtype=None)", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `dtype`.", "question_id": 2619},
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, subok=True)", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `subok`.", "question_id": 2620},
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, out=None, where=True)", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `out`, `where`.", "question_id": 2621},
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `out`, `casting`.", "question_id": 2622},
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, out=None, order='K')", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `out`, `order`.", "question_id": 2623},
{"snippet": "random.get_state()", "intent": "Return a tuple representing the internal state of the generator .", "question_id": 2624},
{"snippet": "ma.MaskedArray.max()", "intent": "Return the maximum along a given `axis` .", "question_id": 2625},
{"snippet": "ma.MaskedArray.max(axis=None)", "intent": "Return the maximum along a given `axis` .", "question_id": 2626},
{"snippet": "ma.MaskedArray.max(out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`.", "question_id": 2627},
{"snippet": "ma.MaskedArray.max(fill_value=None)", "intent": "Return the maximum along a given `axis` . With arguments `fill_value`.", "question_id": 2628},
{"snippet": "ma.MaskedArray.max(keepdims=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`.", "question_id": 2629},
{"snippet": "ma.MaskedArray.max(axis=None, out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`.", "question_id": 2630},
{"snippet": "ma.MaskedArray.max(axis=None, fill_value=None)", "intent": "Return the maximum along a given `axis` . With arguments `fill_value`.", "question_id": 2631},
{"snippet": "ma.MaskedArray.max(axis=None, keepdims=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`.", "question_id": 2632},
{"snippet": "ma.MaskedArray.max(out=None, fill_value=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`, `fill_value`.", "question_id": 2633},
{"snippet": "ma.MaskedArray.max(out=None, keepdims=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `out`, `keepdims`.", "question_id": 2634},
{"snippet": "random.Generator.uniform()", "intent": "Draw samples from a uniform distribution .", "question_id": 2635},
{"snippet": "random.Generator.uniform(low=0.0)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) .", "question_id": 2636},
{"snippet": "random.Generator.uniform(high=1.0)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) .", "question_id": 2637},
{"snippet": "random.Generator.uniform(size=None)", "intent": "Draw samples from a uniform distribution . With arguments `size`.", "question_id": 2638},
{"snippet": "random.Generator.uniform(low=0.0, high=1.0)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) .", "question_id": 2639},
{"snippet": "random.Generator.uniform(low=0.0, size=None)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . With arguments `size`.", "question_id": 2640},
{"snippet": "random.Generator.uniform(high=1.0, size=None)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . With arguments `size`.", "question_id": 2641},
{"snippet": "random.Generator.uniform(low=0.0, high=1.0, size=None)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . With arguments `size`.", "question_id": 2642},
{"snippet": "poly1d.__call__(val)", "intent": "Call self as a function . With arguments `val`.", "question_id": 2643},
{"snippet": "char.decode(a)", "intent": "Calls str.decode element-wise . With arguments `a`.", "question_id": 2644},
{"snippet": "char.decode(a, encoding=None)", "intent": "Calls str.decode element-wise . The type of the result will depend on the `encoding` specified . With arguments `a`.", "question_id": 2645},
{"snippet": "char.decode(a, errors=None)", "intent": "Calls str.decode element-wise . With arguments `a`, `errors`.", "question_id": 2646},
{"snippet": "char.decode(a, encoding=None, errors=None)", "intent": "Calls str.decode element-wise . The type of the result will depend on the `encoding` specified . With arguments `a`, `errors`.", "question_id": 2647},
{"snippet": "numpy.ones_like(a)", "intent": "Return an array of ones with the same `shape` and type as `a` given array .", "question_id": 2648},
{"snippet": "numpy.ones_like(a, dtype=None)", "intent": "Return an array of ones with the same `shape` and type as `a` given array . With arguments `dtype`.", "question_id": 2649},
{"snippet": "numpy.ones_like(a, order='K')", "intent": "Return an array of ones with the same `shape` and type as `a` given array . With arguments `order`.", "question_id": 2650},
{"snippet": "numpy.ones_like(a, subok=True)", "intent": "Return an array of ones with the same `shape` and type as `a` given array . With arguments `subok`.", "question_id": 2651},
{"snippet": "numpy.ones_like(a, shape=None)", "intent": "Return an array of ones with the same `shape` and type as `a` given array .", "question_id": 2652},
{"snippet": "numpy.ones_like(a, dtype=None, order='K')", "intent": "Return an array of ones with the same `shape` and type as `a` given array . With arguments `dtype`, `order`.", "question_id": 2653},
{"snippet": "numpy.ones_like(a, dtype=None, subok=True)", "intent": "Return an array of ones with the same `shape` and type as `a` given array . With arguments `dtype`, `subok`.", "question_id": 2654},
{"snippet": "numpy.ones_like(a, dtype=None, shape=None)", "intent": "Return an array of ones with the same `shape` and type as `a` given array . With arguments `dtype`.", "question_id": 2655},
{"snippet": "numpy.ones_like(a, order='K', subok=True)", "intent": "Return an array of ones with the same `shape` and type as `a` given array . With arguments `order`, `subok`.", "question_id": 2656},
{"snippet": "numpy.ones_like(a, order='K', shape=None)", "intent": "Return an array of ones with the same `shape` and type as `a` given array . With arguments `order`.", "question_id": 2657},
{"snippet": "ndarray.conj()", "intent": "Complex-conjugate all elements .", "question_id": 2658},
{"snippet": "memmap.ptp()", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` .", "question_id": 2659},
{"snippet": "memmap.ptp(axis=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` .", "question_id": 2660},
{"snippet": "memmap.ptp(out=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`.", "question_id": 2661},
{"snippet": "memmap.ptp(keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `keepdims`.", "question_id": 2662},
{"snippet": "memmap.ptp(axis=None, out=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`.", "question_id": 2663},
{"snippet": "memmap.ptp(axis=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `keepdims`.", "question_id": 2664},
{"snippet": "memmap.ptp(out=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`, `keepdims`.", "question_id": 2665},
{"snippet": "memmap.ptp(axis=None, out=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`, `keepdims`.", "question_id": 2666},
{"snippet": "random.Generator.lognormal()", "intent": "Draw samples from a log-normal distribution .", "question_id": 2667},
{"snippet": "random.Generator.lognormal(mean=0.0)", "intent": "Draw samples from a log-normal distribution . Draw samples from a log-normal distribution with specified `mean` , standard deviation , and array shape .", "question_id": 2668},
{"snippet": "random.Generator.lognormal(sigma=1.0)", "intent": "Draw samples from a log-normal distribution . With arguments `sigma`.", "question_id": 2669},
{"snippet": "random.Generator.lognormal(size=None)", "intent": "Draw samples from a log-normal distribution . With arguments `size`.", "question_id": 2670},
{"snippet": "random.Generator.lognormal(mean=0.0, sigma=1.0)", "intent": "Draw samples from a log-normal distribution . Draw samples from a log-normal distribution with specified `mean` , standard deviation , and array shape . With arguments `sigma`.", "question_id": 2671},
{"snippet": "random.Generator.lognormal(mean=0.0, size=None)", "intent": "Draw samples from a log-normal distribution . Draw samples from a log-normal distribution with specified `mean` , standard deviation , and array shape . With arguments `size`.", "question_id": 2672},
{"snippet": "random.Generator.lognormal(sigma=1.0, size=None)", "intent": "Draw samples from a log-normal distribution . With arguments `sigma`, `size`.", "question_id": 2673},
{"snippet": "random.Generator.lognormal(mean=0.0, sigma=1.0, size=None)", "intent": "Draw samples from a log-normal distribution . Draw samples from a log-normal distribution with specified `mean` , standard deviation , and array shape . With arguments `sigma`, `size`.", "question_id": 2674},
{"snippet": "numpy.dot(a, b)", "intent": "Dot product of two arrays . With arguments `a`, `b`.", "question_id": 2675},
{"snippet": "numpy.dot(a, b, out=None)", "intent": "Dot product of two arrays . With arguments `a`, `b`, `out`.", "question_id": 2676},
{"snippet": "char.isalnum(a)", "intent": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character , false otherwise . With arguments `a`.", "question_id": 2677},
{"snippet": "numpy.printoptions(*args, **kwargs)", "intent": "Context manager for setting print options . With arguments `*args`, `**kwargs`.", "question_id": 2678},
{"snippet": "ndarray.swapaxes(axis1, axis2)", "intent": "Return a view of the array with `axis1` and `axis2` interchanged .", "question_id": 2679},
{"snippet": "chararray.partition(sep)", "intent": "Partition each element in self around `sep` .", "question_id": 2680},
{"snippet": "chararray.endswith(suffix)", "intent": "Returns a boolean array which is True where the string element in self ends with `suffix` , otherwise False .", "question_id": 2681},
{"snippet": "chararray.endswith(suffix, start=0)", "intent": "Returns a boolean array which is True where the string element in self ends with `suffix` , otherwise False . With arguments `start`.", "question_id": 2682},
{"snippet": "chararray.endswith(suffix, end=None)", "intent": "Returns a boolean array which is True where the string element in self ends with `suffix` , otherwise False . With arguments `end`.", "question_id": 2683},
{"snippet": "chararray.endswith(suffix, start=0, end=None)", "intent": "Returns a boolean array which is True where the string element in self ends with `suffix` , otherwise False . With arguments `start`, `end`.", "question_id": 2684},
{"snippet": "numpy.nancumsum(a)", "intent": "Return the cumulative sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero .", "question_id": 2685},
{"snippet": "numpy.nancumsum(a, axis=None)", "intent": "Return the cumulative sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero .", "question_id": 2686},
{"snippet": "numpy.nancumsum(a, dtype=None)", "intent": "Return the cumulative sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `dtype`.", "question_id": 2687},
{"snippet": "numpy.nancumsum(a, out=None)", "intent": "Return the cumulative sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `out`.", "question_id": 2688},
{"snippet": "numpy.nancumsum(a, axis=None, dtype=None)", "intent": "Return the cumulative sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `dtype`.", "question_id": 2689},
{"snippet": "numpy.nancumsum(a, axis=None, out=None)", "intent": "Return the cumulative sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `out`.", "question_id": 2690},
{"snippet": "numpy.nancumsum(a, dtype=None, out=None)", "intent": "Return the cumulative sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `dtype`, `out`.", "question_id": 2691},
{"snippet": "numpy.nancumsum(a, axis=None, dtype=None, out=None)", "intent": "Return the cumulative sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `dtype`, `out`.", "question_id": 2692},
{"snippet": "dtype.num", "intent": "A unique number for each of the 21 different built-in types.", "question_id": 2693},
{"snippet": "char.greater_equal(x1, x2)", "intent": "Return ( `x1` > = `x2` ) element-wise .", "question_id": 2694},
{"snippet": "matrix.all()", "intent": "Test whether all matrix elements along a given `axis` evaluate to True .", "question_id": 2695},
{"snippet": "matrix.all(axis=None)", "intent": "Test whether all matrix elements along a given `axis` evaluate to True .", "question_id": 2696},
{"snippet": "matrix.all(out=None)", "intent": "Test whether all matrix elements along a given `axis` evaluate to True . With arguments `out`.", "question_id": 2697},
{"snippet": "matrix.all(axis=None, out=None)", "intent": "Test whether all matrix elements along a given `axis` evaluate to True . With arguments `out`.", "question_id": 2698},
{"snippet": "random.f(dfnum, dfden)", "intent": "Draw samples from an F distribution . Samples are drawn from an F distribution with specified parameters , `dfnum` ( degrees of freedom in numerator ) and `dfden` ( degrees of freedom in denominator ) , where both parameters must be greater than zero .", "question_id": 2699},
{"snippet": "random.f(dfnum, dfden, size=None)", "intent": "Draw samples from an F distribution . Samples are drawn from an F distribution with specified parameters , `dfnum` ( degrees of freedom in numerator ) and `dfden` ( degrees of freedom in denominator ) , where both parameters must be greater than zero . With arguments `size`.", "question_id": 2700},
{"snippet": "random.normal()", "intent": "Draw random samples from a normal ( Gaussian ) distribution .", "question_id": 2701},
{"snippet": "random.normal(loc=0.0)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `loc`.", "question_id": 2702},
{"snippet": "random.normal(scale=1.0)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `scale`.", "question_id": 2703},
{"snippet": "random.normal(size=None)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `size`.", "question_id": 2704},
{"snippet": "random.normal(loc=0.0, scale=1.0)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `loc`, `scale`.", "question_id": 2705},
{"snippet": "random.normal(loc=0.0, size=None)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `loc`, `size`.", "question_id": 2706},
{"snippet": "random.normal(scale=1.0, size=None)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `scale`, `size`.", "question_id": 2707},
{"snippet": "random.normal(loc=0.0, scale=1.0, size=None)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `loc`, `scale`, `size`.", "question_id": 2708},
{"snippet": "ndarray.argsort()", "intent": "Returns the indices that would sort this array .", "question_id": 2709},
{"snippet": "ndarray.argsort(axis=- 1)", "intent": "Returns the indices that would sort this array . With arguments `axis`.", "question_id": 2710},
{"snippet": "ndarray.argsort(kind=None)", "intent": "Returns the indices that would sort this array . With arguments `kind`.", "question_id": 2711},
{"snippet": "ndarray.argsort(order=None)", "intent": "Returns the indices that would sort this array . With arguments `order`.", "question_id": 2712},
{"snippet": "ndarray.argsort(axis=- 1, kind=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `kind`.", "question_id": 2713},
{"snippet": "ndarray.argsort(axis=- 1, order=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `order`.", "question_id": 2714},
{"snippet": "ndarray.argsort(kind=None, order=None)", "intent": "Returns the indices that would sort this array . With arguments `kind`, `order`.", "question_id": 2715},
{"snippet": "ndarray.argsort(axis=- 1, kind=None, order=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `kind`, `order`.", "question_id": 2716},
{"snippet": "recarray.conjugate()", "intent": "Return the complex conjugate , element-wise .", "question_id": 2717},
{"snippet": "numpy.right_shift(x1, x2, /, signature, extobj)", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `extobj`.", "question_id": 2718},
{"snippet": "numpy.right_shift(x1, x2, /, signature, extobj, out=None)", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 2719},
{"snippet": "numpy.right_shift(x1, x2, /, signature, extobj, where=True)", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 2720},
{"snippet": "numpy.right_shift(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 2721},
{"snippet": "numpy.right_shift(x1, x2, /, signature, extobj, order='K')", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 2722},
{"snippet": "numpy.right_shift(x1, x2, /, signature, extobj, dtype=None)", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 2723},
{"snippet": "numpy.right_shift(x1, x2, /, signature, extobj, subok=True)", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 2724},
{"snippet": "numpy.right_shift(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 2725},
{"snippet": "numpy.right_shift(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 2726},
{"snippet": "numpy.right_shift(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 2727},
{"snippet": "numpy.right_shift(x1, x2, /, signature)", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`.", "question_id": 2728},
{"snippet": "numpy.right_shift(x1, x2, /, signature, out=None)", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `out`.", "question_id": 2729},
{"snippet": "numpy.right_shift(x1, x2, /, signature, where=True)", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `where`.", "question_id": 2730},
{"snippet": "numpy.right_shift(x1, x2, /, signature, casting='same_kind')", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `casting`.", "question_id": 2731},
{"snippet": "numpy.right_shift(x1, x2, /, signature, order='K')", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `order`.", "question_id": 2732},
{"snippet": "numpy.right_shift(x1, x2, /, signature, dtype=None)", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `dtype`.", "question_id": 2733},
{"snippet": "numpy.right_shift(x1, x2, /, signature, subok=True)", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `subok`.", "question_id": 2734},
{"snippet": "numpy.right_shift(x1, x2, /, signature, out=None, where=True)", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `out`, `where`.", "question_id": 2735},
{"snippet": "numpy.right_shift(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 2736},
{"snippet": "numpy.right_shift(x1, x2, /, signature, out=None, order='K')", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `out`, `order`.", "question_id": 2737},
{"snippet": "generic.flat", "intent": "A 1-D view of the scalar.", "question_id": 2738},
{"snippet": "char.ljust(a, width)", "intent": "Return an array with the elements of `a` left-justified in a string of length `width` .", "question_id": 2739},
{"snippet": "char.ljust(a, width, fillchar=' ')", "intent": "Return an array with the elements of `a` left-justified in a string of length `width` . With arguments `fillchar`.", "question_id": 2740},
{"snippet": "numpy.sum(a)", "intent": "Sum of array elements over `a` given `axis` .", "question_id": 2741},
{"snippet": "numpy.sum(a, axis=None)", "intent": "Sum of array elements over `a` given `axis` .", "question_id": 2742},
{"snippet": "numpy.sum(a, dtype=None)", "intent": "Sum of array elements over `a` given `axis` . With arguments `dtype`.", "question_id": 2743},
{"snippet": "numpy.sum(a, out=None)", "intent": "Sum of array elements over `a` given `axis` . With arguments `out`.", "question_id": 2744},
{"snippet": "numpy.sum(a, keepdims=<no value>)", "intent": "Sum of array elements over `a` given `axis` . With arguments `keepdims`.", "question_id": 2745},
{"snippet": "numpy.sum(a, initial=<no value>)", "intent": "Sum of array elements over `a` given `axis` . With arguments `initial`.", "question_id": 2746},
{"snippet": "numpy.sum(a, where=<no value>)", "intent": "Sum of array elements over `a` given `axis` . With arguments `where`.", "question_id": 2747},
{"snippet": "numpy.sum(a, axis=None, dtype=None)", "intent": "Sum of array elements over `a` given `axis` . With arguments `dtype`.", "question_id": 2748},
{"snippet": "numpy.sum(a, axis=None, out=None)", "intent": "Sum of array elements over `a` given `axis` . With arguments `out`.", "question_id": 2749},
{"snippet": "numpy.sum(a, axis=None, keepdims=<no value>)", "intent": "Sum of array elements over `a` given `axis` . With arguments `keepdims`.", "question_id": 2750},
{"snippet": "record.ptp()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 2751},
{"snippet": "ma.masked_array.choose(choices)", "intent": "Use an index array to construct a new array from a set of `choices` .", "question_id": 2752},
{"snippet": "ma.masked_array.choose(choices, out=None)", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`.", "question_id": 2753},
{"snippet": "ma.masked_array.choose(choices, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `mode`.", "question_id": 2754},
{"snippet": "ma.masked_array.choose(choices, out=None, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`, `mode`.", "question_id": 2755},
{"snippet": "ma.outerproduct(a, b)", "intent": "Compute the outer product of two vectors . Given two vectors , `a` = [ a0 , a1 , ... , aM ] and `b` = [ b0 , b1 , ... , bN ] , the outer product [ 1 ] is :", "question_id": 2756},
{"snippet": "ndarray.newbyteorder(/)", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`.", "question_id": 2757},
{"snippet": "ndarray.newbyteorder(/, new_order='S')", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`, `new_order`.", "question_id": 2758},
{"snippet": "ma.masked_array.clip(**kwargs)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 2759},
{"snippet": "ma.masked_array.clip(**kwargs, min=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 2760},
{"snippet": "ma.masked_array.clip(**kwargs, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 2761},
{"snippet": "ma.masked_array.clip(**kwargs, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 2762},
{"snippet": "ma.masked_array.clip(**kwargs, min=None, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 2763},
{"snippet": "ma.masked_array.clip(**kwargs, min=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 2764},
{"snippet": "ma.masked_array.clip(**kwargs, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 2765},
{"snippet": "ma.masked_array.clip(**kwargs, min=None, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 2766},
{"snippet": "matrix.astype(dtype)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`.", "question_id": 2767},
{"snippet": "matrix.astype(dtype, order='K')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`.", "question_id": 2768},
{"snippet": "matrix.astype(dtype, casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`.", "question_id": 2769},
{"snippet": "matrix.astype(dtype, subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `subok`.", "question_id": 2770},
{"snippet": "matrix.astype(dtype, copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `copy`.", "question_id": 2771},
{"snippet": "matrix.astype(dtype, order='K', casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `casting`.", "question_id": 2772},
{"snippet": "matrix.astype(dtype, order='K', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `subok`.", "question_id": 2773},
{"snippet": "matrix.astype(dtype, order='K', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `copy`.", "question_id": 2774},
{"snippet": "matrix.astype(dtype, casting='unsafe', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `subok`.", "question_id": 2775},
{"snippet": "matrix.astype(dtype, casting='unsafe', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `copy`.", "question_id": 2776},
{"snippet": "ufunc.at(a, indices, /)", "intent": "Performs unbuffered in place operation on operand \u2018 `a` \u2019 for elements specified by \u2018 `indices` \u2019 . With arguments `/`.", "question_id": 2777},
{"snippet": "ufunc.at(a, indices, /, b=None)", "intent": "Performs unbuffered in place operation on operand \u2018 `a` \u2019 for elements specified by \u2018 `indices` \u2019 . For addition ufunc , this method is equivalent to a [ indices ] += `b` , except that results are accumulated for elements that are indexed more than once . With arguments `/`.", "question_id": 2778},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.generate_dispatch_header(header_path)", "intent": "Generate the dispatch header which contains the # definitions and headers for platform-specific instruction-sets for the enabled CPU baseline and dispatch-able features . With arguments `header_path`.", "question_id": 2779},
{"snippet": "polynomial.hermite_e.hermefromroots(roots)", "intent": "Generate a HermiteE series with given `roots` .", "question_id": 2780},
{"snippet": "ma.fromfunction(function, shape, **dtype)", "intent": "Construct an array by executing a `function` over each coordinate . With arguments `shape`, `**dtype`.", "question_id": 2781},
{"snippet": "ma.MaskType.size", "intent": "The number of elements in the gentype.", "question_id": 2782},
{"snippet": "polynomial.chebyshev.Chebyshev.cutdeg(deg)", "intent": "Truncate series to the given degree . Reduce the degree of the series to `deg` by discarding the high order terms .", "question_id": 2783},
{"snippet": "numpy.nanmin(a)", "intent": "Return minimum of an array or minimum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and Nan is returned for that slice .", "question_id": 2784},
{"snippet": "numpy.nanmin(a, axis=None)", "intent": "Return minimum of an array or minimum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and Nan is returned for that slice .", "question_id": 2785},
{"snippet": "numpy.nanmin(a, out=None)", "intent": "Return minimum of an array or minimum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and Nan is returned for that slice . With arguments `out`.", "question_id": 2786},
{"snippet": "numpy.nanmin(a, keepdims=<no value>)", "intent": "Return minimum of an array or minimum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and Nan is returned for that slice . With arguments `keepdims`.", "question_id": 2787},
{"snippet": "numpy.nanmin(a, axis=None, out=None)", "intent": "Return minimum of an array or minimum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and Nan is returned for that slice . With arguments `out`.", "question_id": 2788},
{"snippet": "numpy.nanmin(a, axis=None, keepdims=<no value>)", "intent": "Return minimum of an array or minimum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and Nan is returned for that slice . With arguments `keepdims`.", "question_id": 2789},
{"snippet": "numpy.nanmin(a, out=None, keepdims=<no value>)", "intent": "Return minimum of an array or minimum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and Nan is returned for that slice . With arguments `out`, `keepdims`.", "question_id": 2790},
{"snippet": "numpy.nanmin(a, axis=None, out=None, keepdims=<no value>)", "intent": "Return minimum of an array or minimum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and Nan is returned for that slice . With arguments `out`, `keepdims`.", "question_id": 2791},
{"snippet": "random.choice(a)", "intent": "Generates `a` random sample from a given 1-D array", "question_id": 2792},
{"snippet": "random.choice(a, size=None)", "intent": "Generates `a` random sample from a given 1-D array Generate a uniform random sample from np.arange ( 5 ) of `size` 3 :", "question_id": 2793},
{"snippet": "random.choice(a, replace=True)", "intent": "Generates `a` random sample from a given 1-D array With arguments `replace`.", "question_id": 2794},
{"snippet": "random.choice(a, p=None)", "intent": "Generates `a` random sample from a given 1-D array Setting user-specified probabilities through `p` uses a more general but less efficient sampler than the default .", "question_id": 2795},
{"snippet": "random.choice(a, size=None, replace=True)", "intent": "Generates `a` random sample from a given 1-D array Generate a uniform random sample from np.arange ( 5 ) of `size` 3 : With arguments `replace`.", "question_id": 2796},
{"snippet": "random.choice(a, size=None, p=None)", "intent": "Generates `a` random sample from a given 1-D array Generate a uniform random sample from np.arange ( 5 ) of `size` 3 : Setting user-specified probabilities through `p` uses a more general but less efficient sampler than the default .", "question_id": 2797},
{"snippet": "random.choice(a, replace=True, p=None)", "intent": "Generates `a` random sample from a given 1-D array Setting user-specified probabilities through `p` uses a more general but less efficient sampler than the default . With arguments `replace`.", "question_id": 2798},
{"snippet": "random.choice(a, size=None, replace=True, p=None)", "intent": "Generates `a` random sample from a given 1-D array Generate a uniform random sample from np.arange ( 5 ) of `size` 3 : Setting user-specified probabilities through `p` uses a more general but less efficient sampler than the default . With arguments `replace`.", "question_id": 2799},
{"snippet": "numpy.delete(arr, obj)", "intent": "Return a new array with sub-arrays along an `axis` deleted . For a one dimensional array , this returns those entries not returned by `arr` [ `obj` ] .", "question_id": 2800},
{"snippet": "numpy.delete(arr, obj, axis=None)", "intent": "Return a new array with sub-arrays along an `axis` deleted . For a one dimensional array , this returns those entries not returned by `arr` [ `obj` ] .", "question_id": 2801},
{"snippet": "polynomial.legendre.poly2leg(pol)", "intent": "Convert a polynomial to a Legendre series . With arguments `pol`.", "question_id": 2802},
{"snippet": "char.chararray.squeeze()", "intent": "Remove axes of length one from a .", "question_id": 2803},
{"snippet": "char.chararray.squeeze(axis=None)", "intent": "Remove axes of length one from a . With arguments `axis`.", "question_id": 2804},
{"snippet": "memmap.setfield(val, dtype)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field .", "question_id": 2805},
{"snippet": "memmap.setfield(val, dtype, offset=0)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field .", "question_id": 2806},
{"snippet": "matrix.resize(new_shape)", "intent": "Change shape and size of array in-place . With arguments `new_shape`.", "question_id": 2807},
{"snippet": "matrix.resize(new_shape, refcheck=True)", "intent": "Change shape and size of array in-place . However , reference counts can increase in other ways so if you are sure that you have not shared the memory for this array with another Python object , then you may safely set `refcheck` to False . With arguments `new_shape`.", "question_id": 2808},
{"snippet": "ma.MaskedArray.__copy__()", "intent": "Used if copy.copy is called on an array .", "question_id": 2809},
{"snippet": "record.flatten()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 2810},
{"snippet": "random.set_state(state)", "intent": "Set the internal `state` of the generator from a tuple .", "question_id": 2811},
{"snippet": "numpy.correlate(a, v)", "intent": "Cross-correlation of two 1-dimensional sequences . with `a` and `v` sequences being zero-padded where necessary and conj being the conjugate .", "question_id": 2812},
{"snippet": "numpy.correlate(a, v, mode='valid')", "intent": "Cross-correlation of two 1-dimensional sequences . with `a` and `v` sequences being zero-padded where necessary and conj being the conjugate . With arguments `mode`.", "question_id": 2813},
{"snippet": "polynomial.hermite.Hermite.fromroots(roots)", "intent": "Return series instance that has the specified `roots` .", "question_id": 2814},
{"snippet": "polynomial.hermite.Hermite.fromroots(roots, domain=)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`.", "question_id": 2815},
{"snippet": "polynomial.hermite.Hermite.fromroots(roots, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `window`.", "question_id": 2816},
{"snippet": "polynomial.hermite.Hermite.fromroots(roots, domain=, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`, `window`.", "question_id": 2817},
{"snippet": "polynomial.hermite.Hermite.fromroots()", "intent": "Return series instance that has the specified `roots` .", "question_id": 2818},
{"snippet": "polynomial.hermite.Hermite.fromroots(domain=)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`.", "question_id": 2819},
{"snippet": "polynomial.hermite.Hermite.fromroots(window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `window`.", "question_id": 2820},
{"snippet": "polynomial.hermite.Hermite.fromroots(domain=, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`, `window`.", "question_id": 2821},
{"snippet": "numpy.sqrt(x, /, signature, extobj)", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`.", "question_id": 2822},
{"snippet": "numpy.sqrt(x, /, signature, extobj, out=None)", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`.", "question_id": 2823},
{"snippet": "numpy.sqrt(x, /, signature, extobj, where=True)", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `where`.", "question_id": 2824},
{"snippet": "numpy.sqrt(x, /, signature, extobj, casting='same_kind')", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `casting`.", "question_id": 2825},
{"snippet": "numpy.sqrt(x, /, signature, extobj, order='K')", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `order`.", "question_id": 2826},
{"snippet": "numpy.sqrt(x, /, signature, extobj, dtype=None)", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `dtype`.", "question_id": 2827},
{"snippet": "numpy.sqrt(x, /, signature, extobj, subok=True)", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `subok`.", "question_id": 2828},
{"snippet": "numpy.sqrt(x, /, signature, extobj, out=None, where=True)", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 2829},
{"snippet": "numpy.sqrt(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 2830},
{"snippet": "numpy.sqrt(x, /, signature, extobj, out=None, order='K')", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 2831},
{"snippet": "numpy.sqrt(x, /, signature)", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`.", "question_id": 2832},
{"snippet": "numpy.sqrt(x, /, signature, out=None)", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `out`.", "question_id": 2833},
{"snippet": "numpy.sqrt(x, /, signature, where=True)", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `where`.", "question_id": 2834},
{"snippet": "numpy.sqrt(x, /, signature, casting='same_kind')", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `casting`.", "question_id": 2835},
{"snippet": "numpy.sqrt(x, /, signature, order='K')", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `order`.", "question_id": 2836},
{"snippet": "numpy.sqrt(x, /, signature, dtype=None)", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `dtype`.", "question_id": 2837},
{"snippet": "numpy.sqrt(x, /, signature, subok=True)", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `subok`.", "question_id": 2838},
{"snippet": "numpy.sqrt(x, /, signature, out=None, where=True)", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `out`, `where`.", "question_id": 2839},
{"snippet": "numpy.sqrt(x, /, signature, out=None, casting='same_kind')", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `out`, `casting`.", "question_id": 2840},
{"snippet": "numpy.sqrt(x, /, signature, out=None, order='K')", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `out`, `order`.", "question_id": 2841},
{"snippet": "numpy.where(condition, x, y)", "intent": "Return elements chosen from `x` or `y` depending on `condition` .", "question_id": 2842},
{"snippet": "numpy.where(condition, x)", "intent": "Return elements chosen from `x` or `y` depending on `condition` .", "question_id": 2843},
{"snippet": "numpy.linspace(start, stop)", "intent": "Return evenly spaced numbers over a specified interval . Returns `num` evenly spaced samples , calculated over the interval [ `start` , `stop` ] .", "question_id": 2844},
{"snippet": "numpy.linspace(start, stop, num=50)", "intent": "Return evenly spaced numbers over a specified interval . Returns `num` evenly spaced samples , calculated over the interval [ `start` , `stop` ] .", "question_id": 2845},
{"snippet": "numpy.linspace(start, stop, endpoint=True)", "intent": "Return evenly spaced numbers over a specified interval . Returns `num` evenly spaced samples , calculated over the interval [ `start` , `stop` ] . The `endpoint` of the interval can optionally be excluded .", "question_id": 2846},
{"snippet": "numpy.linspace(start, stop, retstep=False)", "intent": "Return evenly spaced numbers over a specified interval . Returns `num` evenly spaced samples , calculated over the interval [ `start` , `stop` ] . With arguments `retstep`.", "question_id": 2847},
{"snippet": "numpy.linspace(start, stop, dtype=None)", "intent": "Return evenly spaced numbers over a specified interval . Returns `num` evenly spaced samples , calculated over the interval [ `start` , `stop` ] . With arguments `dtype`.", "question_id": 2848},
{"snippet": "numpy.linspace(start, stop, axis=0)", "intent": "Return evenly spaced numbers over a specified interval . Returns `num` evenly spaced samples , calculated over the interval [ `start` , `stop` ] . With arguments `axis`.", "question_id": 2849},
{"snippet": "numpy.linspace(start, stop, num=50, endpoint=True)", "intent": "Return evenly spaced numbers over a specified interval . Returns `num` evenly spaced samples , calculated over the interval [ `start` , `stop` ] . The `endpoint` of the interval can optionally be excluded .", "question_id": 2850},
{"snippet": "numpy.linspace(start, stop, num=50, retstep=False)", "intent": "Return evenly spaced numbers over a specified interval . Returns `num` evenly spaced samples , calculated over the interval [ `start` , `stop` ] . With arguments `retstep`.", "question_id": 2851},
{"snippet": "numpy.linspace(start, stop, num=50, dtype=None)", "intent": "Return evenly spaced numbers over a specified interval . Returns `num` evenly spaced samples , calculated over the interval [ `start` , `stop` ] . With arguments `dtype`.", "question_id": 2852},
{"snippet": "numpy.linspace(start, stop, num=50, axis=0)", "intent": "Return evenly spaced numbers over a specified interval . Returns `num` evenly spaced samples , calculated over the interval [ `start` , `stop` ] . With arguments `axis`.", "question_id": 2853},
{"snippet": "polynomial.laguerre.lagmulx(c)", "intent": "Multiply a Laguerre series by x . Multiply the Laguerre series `c` by x , where x is the independent variable .", "question_id": 2854},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.me(cb)", "intent": "A static method that can be treated as a decorator to dynamically cache certain methods . With arguments `cb`.", "question_id": 2855},
{"snippet": "ma.MaskType.flat", "intent": "A 1-D view of the scalar.", "question_id": 2856},
{"snippet": "record.argmin()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 2857},
{"snippet": "lib.scimath.logn(n, x)", "intent": "Take log base `n` of `x` .", "question_id": 2858},
{"snippet": "random.Generator.rayleigh()", "intent": "Draw samples from a Rayleigh distribution .", "question_id": 2859},
{"snippet": "random.Generator.rayleigh(scale=1.0)", "intent": "Draw samples from a Rayleigh distribution . With arguments `scale`.", "question_id": 2860},
{"snippet": "random.Generator.rayleigh(size=None)", "intent": "Draw samples from a Rayleigh distribution . With arguments `size`.", "question_id": 2861},
{"snippet": "random.Generator.rayleigh(scale=1.0, size=None)", "intent": "Draw samples from a Rayleigh distribution . With arguments `scale`, `size`.", "question_id": 2862},
{"snippet": "numpy.bincount(x)", "intent": "Count number of occurrences of each value in array of non-negative ints . The number of bins ( of size 1 ) is one larger than the largest value in `x` .", "question_id": 2863},
{"snippet": "numpy.bincount(x, weights=None)", "intent": "Count number of occurrences of each value in array of non-negative ints . The number of bins ( of size 1 ) is one larger than the largest value in `x` . If `weights` is specified the input array is weighted by it , i.e .", "question_id": 2864},
{"snippet": "numpy.bincount(x, minlength=0)", "intent": "Count number of occurrences of each value in array of non-negative ints . The number of bins ( of size 1 ) is one larger than the largest value in `x` . If `minlength` is specified , there will be at least this number of bins in the output array ( though it will be longer if necessary , depending on the contents of x ) .", "question_id": 2865},
{"snippet": "numpy.bincount(x, weights=None, minlength=0)", "intent": "Count number of occurrences of each value in array of non-negative ints . The number of bins ( of size 1 ) is one larger than the largest value in `x` . If `weights` is specified the input array is weighted by it , i.e . If `minlength` is specified , there will be at least this number of bins in the output array ( though it will be longer if necessary , depending on the contents of x ) .", "question_id": 2866},
{"snippet": "numpy.ndarray(shape)", "intent": "An array object represents a multidimensional , homogeneous array of fixed-size items . With arguments `shape`.", "question_id": 2867},
{"snippet": "numpy.ndarray(shape, dtype=float)", "intent": "An array object represents a multidimensional , homogeneous array of fixed-size items . With arguments `shape`, `dtype`.", "question_id": 2868},
{"snippet": "numpy.ndarray(shape, buffer=None)", "intent": "An array object represents a multidimensional , homogeneous array of fixed-size items . First mode , `buffer` is None : With arguments `shape`.", "question_id": 2869},
{"snippet": "numpy.ndarray(shape, offset=0)", "intent": "An array object represents a multidimensional , homogeneous array of fixed-size items . With arguments `shape`, `offset`.", "question_id": 2870},
{"snippet": "numpy.ndarray(shape, strides=None)", "intent": "An array object represents a multidimensional , homogeneous array of fixed-size items . With arguments `shape`, `strides`.", "question_id": 2871},
{"snippet": "numpy.ndarray(shape, order=None)", "intent": "An array object represents a multidimensional , homogeneous array of fixed-size items . With arguments `shape`, `order`.", "question_id": 2872},
{"snippet": "numpy.ndarray(shape, dtype=float, buffer=None)", "intent": "An array object represents a multidimensional , homogeneous array of fixed-size items . First mode , `buffer` is None : With arguments `shape`, `dtype`.", "question_id": 2873},
{"snippet": "numpy.ndarray(shape, dtype=float, offset=0)", "intent": "An array object represents a multidimensional , homogeneous array of fixed-size items . With arguments `shape`, `dtype`, `offset`.", "question_id": 2874},
{"snippet": "numpy.ndarray(shape, dtype=float, strides=None)", "intent": "An array object represents a multidimensional , homogeneous array of fixed-size items . With arguments `shape`, `dtype`, `strides`.", "question_id": 2875},
{"snippet": "numpy.ndarray(shape, dtype=float, order=None)", "intent": "An array object represents a multidimensional , homogeneous array of fixed-size items . With arguments `shape`, `dtype`, `order`.", "question_id": 2876},
{"snippet": "ma.apply_over_axes(func, a, axes)", "intent": "Apply `a` function repeatedly over multiple `axes` . `func` is called as res = func ( a , axis ) , where axis is the first element of axes .", "question_id": 2877},
{"snippet": "char.chararray.data", "intent": "Python buffer object pointing to the start of the array\u2019s data.", "question_id": 2878},
{"snippet": "numpy.asarray(a)", "intent": "Convert the input to an array . Convert `a` list into an array :", "question_id": 2879},
{"snippet": "numpy.asarray(a, dtype=None)", "intent": "Convert the input to an array . Convert `a` list into an array : If `dtype` is set , array is copied only if dtype does not match :", "question_id": 2880},
{"snippet": "numpy.asarray(a, order=None)", "intent": "Convert the input to an array . Convert `a` list into an array : With arguments `order`.", "question_id": 2881},
{"snippet": "numpy.asarray(a, like=None)", "intent": "Convert the input to an array . Convert `a` list into an array : With arguments `like`.", "question_id": 2882},
{"snippet": "numpy.asarray(a, dtype=None, order=None)", "intent": "Convert the input to an array . Convert `a` list into an array : If `dtype` is set , array is copied only if dtype does not match : With arguments `order`.", "question_id": 2883},
{"snippet": "numpy.asarray(a, dtype=None, like=None)", "intent": "Convert the input to an array . Convert `a` list into an array : If `dtype` is set , array is copied only if dtype does not match : With arguments `like`.", "question_id": 2884},
{"snippet": "numpy.asarray(a, order=None, like=None)", "intent": "Convert the input to an array . Convert `a` list into an array : With arguments `order`, `like`.", "question_id": 2885},
{"snippet": "numpy.asarray(a, dtype=None, order=None, like=None)", "intent": "Convert the input to an array . Convert `a` list into an array : If `dtype` is set , array is copied only if dtype does not match : With arguments `order`, `like`.", "question_id": 2886},
{"snippet": "random.RandomState.power(a)", "intent": "Draws samples in [ 0 , 1 ] from `a` power distribution with positive exponent a - 1 .", "question_id": 2887},
{"snippet": "random.RandomState.power(a, size=None)", "intent": "Draws samples in [ 0 , 1 ] from `a` power distribution with positive exponent a - 1 . With arguments `size`.", "question_id": 2888},
{"snippet": "polynomial.hermite.Hermite.mapparms()", "intent": "Return the mapping parameters .", "question_id": 2889},
{"snippet": "chararray.startswith(prefix)", "intent": "Returns a boolean array which is True where the string element in self starts with `prefix` , otherwise False .", "question_id": 2890},
{"snippet": "chararray.startswith(prefix, start=0)", "intent": "Returns a boolean array which is True where the string element in self starts with `prefix` , otherwise False . With arguments `start`.", "question_id": 2891},
{"snippet": "chararray.startswith(prefix, end=None)", "intent": "Returns a boolean array which is True where the string element in self starts with `prefix` , otherwise False . With arguments `end`.", "question_id": 2892},
{"snippet": "chararray.startswith(prefix, start=0, end=None)", "intent": "Returns a boolean array which is True where the string element in self starts with `prefix` , otherwise False . With arguments `start`, `end`.", "question_id": 2893},
{"snippet": "polynomial.legendre.Legendre.__call__(arg)", "intent": "Call self as a function . With arguments `arg`.", "question_id": 2894},
{"snippet": "polynomial.laguerre.lagvander(x, deg)", "intent": "Pseudo-Vandermonde matrix of given degree . Returns the pseudo-Vandermonde matrix of degree `deg` and sample points `x` .", "question_id": 2895},
{"snippet": "numpy.resize(a, new_shape)", "intent": "Return `a` new array with the specified shape . Note that this behavior is different from a.resize ( `new_shape` ) which fills with zeros instead of repeated copies of a .", "question_id": 2896},
{"snippet": "random.RandomState.random_integers(low)", "intent": "Random integers of type np.int_ between `low` and `high` , inclusive .", "question_id": 2897},
{"snippet": "random.RandomState.random_integers(low, high=None)", "intent": "Random integers of type np.int_ between `low` and `high` , inclusive .", "question_id": 2898},
{"snippet": "random.RandomState.random_integers(low, size=None)", "intent": "Random integers of type np.int_ between `low` and `high` , inclusive . With arguments `size`.", "question_id": 2899},
{"snippet": "random.RandomState.random_integers(low, high=None, size=None)", "intent": "Random integers of type np.int_ between `low` and `high` , inclusive . With arguments `size`.", "question_id": 2900},
{"snippet": "record.trace()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 2901},
{"snippet": "random.RandomState.choice(a)", "intent": "Generates `a` random sample from a given 1-D array", "question_id": 2902},
{"snippet": "random.RandomState.choice(a, size=None)", "intent": "Generates `a` random sample from a given 1-D array Generate a uniform random sample from np.arange ( 5 ) of `size` 3 :", "question_id": 2903},
{"snippet": "random.RandomState.choice(a, replace=True)", "intent": "Generates `a` random sample from a given 1-D array With arguments `replace`.", "question_id": 2904},
{"snippet": "random.RandomState.choice(a, p=None)", "intent": "Generates `a` random sample from a given 1-D array Setting user-specified probabilities through `p` uses a more general but less efficient sampler than the default .", "question_id": 2905},
{"snippet": "random.RandomState.choice(a, size=None, replace=True)", "intent": "Generates `a` random sample from a given 1-D array Generate a uniform random sample from np.arange ( 5 ) of `size` 3 : With arguments `replace`.", "question_id": 2906},
{"snippet": "random.RandomState.choice(a, size=None, p=None)", "intent": "Generates `a` random sample from a given 1-D array Generate a uniform random sample from np.arange ( 5 ) of `size` 3 : Setting user-specified probabilities through `p` uses a more general but less efficient sampler than the default .", "question_id": 2907},
{"snippet": "random.RandomState.choice(a, replace=True, p=None)", "intent": "Generates `a` random sample from a given 1-D array Setting user-specified probabilities through `p` uses a more general but less efficient sampler than the default . With arguments `replace`.", "question_id": 2908},
{"snippet": "random.RandomState.choice(a, size=None, replace=True, p=None)", "intent": "Generates `a` random sample from a given 1-D array Generate a uniform random sample from np.arange ( 5 ) of `size` 3 : Setting user-specified probabilities through `p` uses a more general but less efficient sampler than the default . With arguments `replace`.", "question_id": 2909},
{"snippet": "char.chararray.mean()", "intent": "Returns the average of the array elements along given `axis` .", "question_id": 2910},
{"snippet": "char.chararray.mean(axis=None)", "intent": "Returns the average of the array elements along given `axis` .", "question_id": 2911},
{"snippet": "char.chararray.mean(dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`.", "question_id": 2912},
{"snippet": "char.chararray.mean(out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`.", "question_id": 2913},
{"snippet": "char.chararray.mean(keepdims=False)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`.", "question_id": 2914},
{"snippet": "char.chararray.mean(where=True)", "intent": "Returns the average of the array elements along given `axis` . With arguments `where`.", "question_id": 2915},
{"snippet": "char.chararray.mean(axis=None, dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`.", "question_id": 2916},
{"snippet": "char.chararray.mean(axis=None, out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`.", "question_id": 2917},
{"snippet": "char.chararray.mean(axis=None, keepdims=False)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`.", "question_id": 2918},
{"snippet": "char.chararray.mean(axis=None, where=True)", "intent": "Returns the average of the array elements along given `axis` . With arguments `where`.", "question_id": 2919},
{"snippet": "matrix.nbytes", "intent": "Total bytes consumed by the elements of the array.", "question_id": 2920},
{"snippet": "ma.innerproduct(a, b)", "intent": "Inner product of two arrays . Ordinary inner product of vectors for 1-D arrays ( without complex conjugation ) , in higher dimensions `a` sum product over the last axes . More generally , if ndim ( a ) = r > 0 and ndim ( `b` ) = s > 0 :", "question_id": 2921},
{"snippet": "fft.fftshift(x)", "intent": "Shift the zero-frequency component to the center of the spectrum . Note that y [ 0 ] is the Nyquist component only if len ( `x` ) is even .", "question_id": 2922},
{"snippet": "fft.fftshift(x, axes=None)", "intent": "Shift the zero-frequency component to the center of the spectrum . Note that y [ 0 ] is the Nyquist component only if len ( `x` ) is even . This function swaps half-spaces for all `axes` listed ( defaults to all ) .", "question_id": 2923},
{"snippet": "ndarray.min()", "intent": "Return the minimum along a given `axis` .", "question_id": 2924},
{"snippet": "ndarray.min(axis=None)", "intent": "Return the minimum along a given `axis` .", "question_id": 2925},
{"snippet": "ndarray.min(out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`.", "question_id": 2926},
{"snippet": "ndarray.min(keepdims=False)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`.", "question_id": 2927},
{"snippet": "ndarray.min(initial=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `initial`.", "question_id": 2928},
{"snippet": "ndarray.min(where=True)", "intent": "Return the minimum along a given `axis` . With arguments `where`.", "question_id": 2929},
{"snippet": "ndarray.min(axis=None, out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`.", "question_id": 2930},
{"snippet": "ndarray.min(axis=None, keepdims=False)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`.", "question_id": 2931},
{"snippet": "ndarray.min(axis=None, initial=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `initial`.", "question_id": 2932},
{"snippet": "ndarray.min(axis=None, where=True)", "intent": "Return the minimum along a given `axis` . With arguments `where`.", "question_id": 2933},
{"snippet": "ma.masked_array.argsort()", "intent": "Return an ndarray of indices that sort the array along the specified `axis` .", "question_id": 2934},
{"snippet": "ma.masked_array.argsort(axis=<no value>)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` .", "question_id": 2935},
{"snippet": "ma.masked_array.argsort(kind=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `kind`.", "question_id": 2936},
{"snippet": "ma.masked_array.argsort(order=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `order`.", "question_id": 2937},
{"snippet": "ma.masked_array.argsort(endwith=True)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `endwith`.", "question_id": 2938},
{"snippet": "ma.masked_array.argsort(fill_value=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . Masked values are filled beforehand to `fill_value` .", "question_id": 2939},
{"snippet": "ma.masked_array.argsort(axis=<no value>, kind=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `kind`.", "question_id": 2940},
{"snippet": "ma.masked_array.argsort(axis=<no value>, order=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `order`.", "question_id": 2941},
{"snippet": "ma.masked_array.argsort(axis=<no value>, endwith=True)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `endwith`.", "question_id": 2942},
{"snippet": "ma.masked_array.argsort(axis=<no value>, fill_value=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . Masked values are filled beforehand to `fill_value` .", "question_id": 2943},
{"snippet": "ndarray.__gt__(value, /)", "intent": "Return self > `value` . With arguments `/`.", "question_id": 2944},
{"snippet": "polynomial.legendre.Legendre.copy()", "intent": "Return a copy .", "question_id": 2945},
{"snippet": "ndarray.__isub__(value, /)", "intent": "Return self-=value . With arguments `value`, `/`.", "question_id": 2946},
{"snippet": "lib.scimath.sqrt(x)", "intent": "Compute the square root of `x` .", "question_id": 2947},
{"snippet": "numpy.bartlett(M)", "intent": "Return the Bartlett window . With arguments `M`.", "question_id": 2948},
{"snippet": "ma.MaskedArray.ravel()", "intent": "Returns a 1D version of self , as a view .", "question_id": 2949},
{"snippet": "ma.MaskedArray.ravel(order='C')", "intent": "Returns a 1D version of self , as a view . With arguments `order`.", "question_id": 2950},
{"snippet": "numpy.unravel_index(indices, shape)", "intent": "Converts a flat index or array of flat `indices` into a tuple of coordinate arrays . With arguments `shape`.", "question_id": 2951},
{"snippet": "numpy.unravel_index(indices, shape, order='C')", "intent": "Converts a flat index or array of flat `indices` into a tuple of coordinate arrays . With arguments `shape`, `order`.", "question_id": 2952},
{"snippet": "chararray.getfield(dtype)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements .", "question_id": 2953},
{"snippet": "chararray.getfield(dtype, offset=0)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements . The values in the view are determined by the given type and the `offset` into the current array in bytes .", "question_id": 2954},
{"snippet": "recarray.resize(new_shape)", "intent": "Change shape and size of array in-place . With arguments `new_shape`.", "question_id": 2955},
{"snippet": "recarray.resize(new_shape, refcheck=True)", "intent": "Change shape and size of array in-place . However , reference counts can increase in other ways so if you are sure that you have not shared the memory for this array with another Python object , then you may safely set `refcheck` to False . With arguments `new_shape`.", "question_id": 2956},
{"snippet": "ma.MaskType.T", "intent": "Scalar attribute identical to the corresponding array attribute.", "question_id": 2957},
{"snippet": "ndarray.cumprod()", "intent": "Return the cumulative product of the elements along the given `axis` .", "question_id": 2958},
{"snippet": "ndarray.cumprod(axis=None)", "intent": "Return the cumulative product of the elements along the given `axis` .", "question_id": 2959},
{"snippet": "ndarray.cumprod(dtype=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`.", "question_id": 2960},
{"snippet": "ndarray.cumprod(out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `out`.", "question_id": 2961},
{"snippet": "ndarray.cumprod(axis=None, dtype=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`.", "question_id": 2962},
{"snippet": "ndarray.cumprod(axis=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `out`.", "question_id": 2963},
{"snippet": "ndarray.cumprod(dtype=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 2964},
{"snippet": "ndarray.cumprod(axis=None, dtype=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 2965},
{"snippet": "polynomial.hermite.hermweight(x)", "intent": "Weight function of the Hermite polynomials . With arguments `x`.", "question_id": 2966},
{"snippet": "polynomial.chebyshev.Chebyshev.truncate(size)", "intent": "Truncate series to length `size` .", "question_id": 2967},
{"snippet": "errstate.__call__(func)", "intent": "Call self as a function . With arguments `func`.", "question_id": 2968},
{"snippet": "numpy.minimum(x1, x2, /, signature, extobj)", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`.", "question_id": 2969},
{"snippet": "numpy.minimum(x1, x2, /, signature, extobj, out=None)", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 2970},
{"snippet": "numpy.minimum(x1, x2, /, signature, extobj, where=True)", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 2971},
{"snippet": "numpy.minimum(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 2972},
{"snippet": "numpy.minimum(x1, x2, /, signature, extobj, order='K')", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 2973},
{"snippet": "numpy.minimum(x1, x2, /, signature, extobj, dtype=None)", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 2974},
{"snippet": "numpy.minimum(x1, x2, /, signature, extobj, subok=True)", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 2975},
{"snippet": "numpy.minimum(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 2976},
{"snippet": "numpy.minimum(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 2977},
{"snippet": "numpy.minimum(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 2978},
{"snippet": "numpy.minimum(x1, x2, /, signature)", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`.", "question_id": 2979},
{"snippet": "numpy.minimum(x1, x2, /, signature, out=None)", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`.", "question_id": 2980},
{"snippet": "numpy.minimum(x1, x2, /, signature, where=True)", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `where`.", "question_id": 2981},
{"snippet": "numpy.minimum(x1, x2, /, signature, casting='same_kind')", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `casting`.", "question_id": 2982},
{"snippet": "numpy.minimum(x1, x2, /, signature, order='K')", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `order`.", "question_id": 2983},
{"snippet": "numpy.minimum(x1, x2, /, signature, dtype=None)", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `dtype`.", "question_id": 2984},
{"snippet": "numpy.minimum(x1, x2, /, signature, subok=True)", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `subok`.", "question_id": 2985},
{"snippet": "numpy.minimum(x1, x2, /, signature, out=None, where=True)", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`, `where`.", "question_id": 2986},
{"snippet": "numpy.minimum(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 2987},
{"snippet": "numpy.minimum(x1, x2, /, signature, out=None, order='K')", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`, `order`.", "question_id": 2988},
{"snippet": "numpy.memmap(filename)", "intent": "Create a memory-map to an array stored in a binary file on disk . You would use a \u2018 normal \u2019 `filename` .", "question_id": 2989},
{"snippet": "numpy.memmap(filename, dtype=<class 'numpy.ubyte'>)", "intent": "Create a memory-map to an array stored in a binary file on disk . You would use a \u2018 normal \u2019 `filename` . Create a memmap with `dtype` and `shape` that matches our data :", "question_id": 2990},
{"snippet": "numpy.memmap(filename, mode='r+')", "intent": "Create a memory-map to an array stored in a binary file on disk . You would use a \u2018 normal \u2019 `filename` . With arguments `mode`.", "question_id": 2991},
{"snippet": "numpy.memmap(filename, offset=0)", "intent": "Create a memory-map to an array stored in a binary file on disk . You would use a \u2018 normal \u2019 `filename` . With arguments `offset`.", "question_id": 2992},
{"snippet": "numpy.memmap(filename, shape=None)", "intent": "Create a memory-map to an array stored in a binary file on disk . You would use a \u2018 normal \u2019 `filename` . Create a memmap with `dtype` and `shape` that matches our data :", "question_id": 2993},
{"snippet": "numpy.memmap(filename, order='C')", "intent": "Create a memory-map to an array stored in a binary file on disk . You would use a \u2018 normal \u2019 `filename` . Flushes memory changes to disk in `order` to read them back", "question_id": 2994},
{"snippet": "numpy.memmap(filename, dtype=<class 'numpy.ubyte'>, mode='r+')", "intent": "Create a memory-map to an array stored in a binary file on disk . You would use a \u2018 normal \u2019 `filename` . Create a memmap with `dtype` and `shape` that matches our data : With arguments `mode`.", "question_id": 2995},
{"snippet": "numpy.memmap(filename, dtype=<class 'numpy.ubyte'>, offset=0)", "intent": "Create a memory-map to an array stored in a binary file on disk . You would use a \u2018 normal \u2019 `filename` . Create a memmap with `dtype` and `shape` that matches our data : With arguments `offset`.", "question_id": 2996},
{"snippet": "numpy.memmap(filename, dtype=<class 'numpy.ubyte'>, shape=None)", "intent": "Create a memory-map to an array stored in a binary file on disk . You would use a \u2018 normal \u2019 `filename` . Create a memmap with `dtype` and `shape` that matches our data :", "question_id": 2997},
{"snippet": "numpy.memmap(filename, dtype=<class 'numpy.ubyte'>, order='C')", "intent": "Create a memory-map to an array stored in a binary file on disk . You would use a \u2018 normal \u2019 `filename` . Create a memmap with `dtype` and `shape` that matches our data : Flushes memory changes to disk in `order` to read them back", "question_id": 2998},
{"snippet": "polynomial.legendre.Legendre.cutdeg(deg)", "intent": "Truncate series to the given degree . Reduce the degree of the series to `deg` by discarding the high order terms .", "question_id": 2999},
{"snippet": "memmap.conjugate()", "intent": "Return the complex conjugate , element-wise .", "question_id": 3000},
{"snippet": "chararray.prod()", "intent": "Return the product of the array elements over the given `axis`", "question_id": 3001},
{"snippet": "chararray.prod(axis=None)", "intent": "Return the product of the array elements over the given `axis`", "question_id": 3002},
{"snippet": "chararray.prod(dtype=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `dtype`.", "question_id": 3003},
{"snippet": "chararray.prod(out=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `out`.", "question_id": 3004},
{"snippet": "chararray.prod(keepdims=False)", "intent": "Return the product of the array elements over the given `axis` With arguments `keepdims`.", "question_id": 3005},
{"snippet": "chararray.prod(initial=1)", "intent": "Return the product of the array elements over the given `axis` With arguments `initial`.", "question_id": 3006},
{"snippet": "chararray.prod(where=True)", "intent": "Return the product of the array elements over the given `axis` With arguments `where`.", "question_id": 3007},
{"snippet": "chararray.prod(axis=None, dtype=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `dtype`.", "question_id": 3008},
{"snippet": "chararray.prod(axis=None, out=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `out`.", "question_id": 3009},
{"snippet": "chararray.prod(axis=None, keepdims=False)", "intent": "Return the product of the array elements over the given `axis` With arguments `keepdims`.", "question_id": 3010},
{"snippet": "numpy.ediff1d(ary)", "intent": "The differences between consecutive elements of an array . With arguments `ary`.", "question_id": 3011},
{"snippet": "numpy.ediff1d(ary, to_end=None)", "intent": "The differences between consecutive elements of an array . When applied to masked arrays , this function drops the mask information if the `to_begin` and/or `to_end` parameters are used . With arguments `ary`.", "question_id": 3012},
{"snippet": "numpy.ediff1d(ary, to_begin=None)", "intent": "The differences between consecutive elements of an array . When applied to masked arrays , this function drops the mask information if the `to_begin` and/or `to_end` parameters are used . With arguments `ary`.", "question_id": 3013},
{"snippet": "numpy.ediff1d(ary, to_end=None, to_begin=None)", "intent": "The differences between consecutive elements of an array . When applied to masked arrays , this function drops the mask information if the `to_begin` and/or `to_end` parameters are used . With arguments `ary`.", "question_id": 3014},
{"snippet": "chararray.flatten()", "intent": "Return a copy of the array collapsed into one dimension .", "question_id": 3015},
{"snippet": "chararray.flatten(order='C')", "intent": "Return a copy of the array collapsed into one dimension . With arguments `order`.", "question_id": 3016},
{"snippet": "polynomial.polynomial.Polynomial.cutdeg(deg)", "intent": "Truncate series to the given degree . Reduce the degree of the series to `deg` by discarding the high order terms .", "question_id": 3017},
{"snippet": "ma.masked_array.ctypes", "intent": "An object to simplify the interaction of the array with the ctypes module.", "question_id": 3018},
{"snippet": "_ctypes.data", "intent": "A pointer to the memory area of the array as a Python integer.", "question_id": 3019},
{"snippet": "_ctypes.shape", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the C-integer corresponding to dtype('p') on this platform.", "question_id": 3020},
{"snippet": "_ctypes.strides", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the same as for the shape attribute.", "question_id": 3021},
{"snippet": "_ctypes.data_as(obj)", "intent": "Return the data pointer cast to a particular c-types object . With arguments `obj`.", "question_id": 3022},
{"snippet": "_ctypes.shape_as(obj)", "intent": "Return the shape tuple as an array of some other c-types type . With arguments `obj`.", "question_id": 3023},
{"snippet": "_ctypes.strides_as(obj)", "intent": "Return the strides tuple as an array of some other c-types type . With arguments `obj`.", "question_id": 3024},
{"snippet": "numpy.lib.NumpyVersion(vstring)", "intent": "Parse and compare numpy version strings . With arguments `vstring`.", "question_id": 3025},
{"snippet": "ma.atleast_1d(*args, **kwargs)", "intent": "Convert inputs to arrays with at least one dimension . With arguments `*args`, `**kwargs`.", "question_id": 3026},
{"snippet": "random.RandomState.dirichlet(alpha)", "intent": "Draw samples from the Dirichlet distribution . With arguments `alpha`.", "question_id": 3027},
{"snippet": "random.RandomState.dirichlet(alpha, size=None)", "intent": "Draw samples from the Dirichlet distribution . Draw `size` samples of dimension k from a Dirichlet distribution . With arguments `alpha`.", "question_id": 3028},
{"snippet": "ma.MaskType.dumps()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 3029},
{"snippet": "ma.MaskType.ndim", "intent": "The number of array dimensions.", "question_id": 3030},
{"snippet": "polynomial.laguerre.lagder(c)", "intent": "Differentiate a Laguerre series . Returns the Laguerre series coefficients `c` differentiated `m` times along `axis` .", "question_id": 3031},
{"snippet": "polynomial.laguerre.lagder(c, m=1)", "intent": "Differentiate a Laguerre series . Returns the Laguerre series coefficients `c` differentiated `m` times along `axis` .", "question_id": 3032},
{"snippet": "polynomial.laguerre.lagder(c, scl=1)", "intent": "Differentiate a Laguerre series . Returns the Laguerre series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) .", "question_id": 3033},
{"snippet": "polynomial.laguerre.lagder(c, axis=0)", "intent": "Differentiate a Laguerre series . Returns the Laguerre series coefficients `c` differentiated `m` times along `axis` .", "question_id": 3034},
{"snippet": "polynomial.laguerre.lagder(c, m=1, scl=1)", "intent": "Differentiate a Laguerre series . Returns the Laguerre series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) .", "question_id": 3035},
{"snippet": "polynomial.laguerre.lagder(c, m=1, axis=0)", "intent": "Differentiate a Laguerre series . Returns the Laguerre series coefficients `c` differentiated `m` times along `axis` .", "question_id": 3036},
{"snippet": "polynomial.laguerre.lagder(c, scl=1, axis=0)", "intent": "Differentiate a Laguerre series . Returns the Laguerre series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) .", "question_id": 3037},
{"snippet": "polynomial.laguerre.lagder(c, m=1, scl=1, axis=0)", "intent": "Differentiate a Laguerre series . Returns the Laguerre series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) .", "question_id": 3038},
{"snippet": "char.chararray.isdecimal()", "intent": "For each element in self , return True if there are only decimal characters in the element .", "question_id": 3039},
{"snippet": "numpy.cumprod(a)", "intent": "Return the cumulative product of elements along `a` given `axis` .", "question_id": 3040},
{"snippet": "numpy.cumprod(a, axis=None)", "intent": "Return the cumulative product of elements along `a` given `axis` .", "question_id": 3041},
{"snippet": "numpy.cumprod(a, dtype=None)", "intent": "Return the cumulative product of elements along `a` given `axis` . With arguments `dtype`.", "question_id": 3042},
{"snippet": "numpy.cumprod(a, out=None)", "intent": "Return the cumulative product of elements along `a` given `axis` . With arguments `out`.", "question_id": 3043},
{"snippet": "numpy.cumprod(a, axis=None, dtype=None)", "intent": "Return the cumulative product of elements along `a` given `axis` . With arguments `dtype`.", "question_id": 3044},
{"snippet": "numpy.cumprod(a, axis=None, out=None)", "intent": "Return the cumulative product of elements along `a` given `axis` . With arguments `out`.", "question_id": 3045},
{"snippet": "numpy.cumprod(a, dtype=None, out=None)", "intent": "Return the cumulative product of elements along `a` given `axis` . With arguments `dtype`, `out`.", "question_id": 3046},
{"snippet": "numpy.cumprod(a, axis=None, dtype=None, out=None)", "intent": "Return the cumulative product of elements along `a` given `axis` . With arguments `dtype`, `out`.", "question_id": 3047},
{"snippet": "ma.MaskedArray.__reduce__()", "intent": "Return a 3-tuple for pickling a MaskedArray .", "question_id": 3048},
{"snippet": "numpy.isrealobj(x)", "intent": "Return True if `x` is a not complex type or an array of complex numbers .", "question_id": 3049},
{"snippet": "polynomial.laguerre.lagint(c)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 3050},
{"snippet": "polynomial.laguerre.lagint(c, m=1)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 3051},
{"snippet": "polynomial.laguerre.lagint(c, k=)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 3052},
{"snippet": "polynomial.laguerre.lagint(c, lbnd=0)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 3053},
{"snippet": "polynomial.laguerre.lagint(c, scl=1)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 3054},
{"snippet": "polynomial.laguerre.lagint(c, axis=0)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 3055},
{"snippet": "polynomial.laguerre.lagint(c, m=1, k=)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 3056},
{"snippet": "polynomial.laguerre.lagint(c, m=1, lbnd=0)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 3057},
{"snippet": "polynomial.laguerre.lagint(c, m=1, scl=1)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 3058},
{"snippet": "polynomial.laguerre.lagint(c, m=1, axis=0)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 3059},
{"snippet": "polynomial.laguerre.lagint()", "intent": "Integrate a Laguerre series .", "question_id": 3060},
{"snippet": "polynomial.laguerre.lagint(m=1)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 3061},
{"snippet": "polynomial.laguerre.lagint(k=)", "intent": "Integrate a Laguerre series . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 3062},
{"snippet": "polynomial.laguerre.lagint(lbnd=0)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 3063},
{"snippet": "polynomial.laguerre.lagint(scl=1)", "intent": "Integrate a Laguerre series . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 3064},
{"snippet": "polynomial.laguerre.lagint(axis=0)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 3065},
{"snippet": "polynomial.laguerre.lagint(m=1, k=)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 3066},
{"snippet": "polynomial.laguerre.lagint(m=1, lbnd=0)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 3067},
{"snippet": "polynomial.laguerre.lagint(m=1, scl=1)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 3068},
{"snippet": "polynomial.laguerre.lagint(m=1, axis=0)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 3069},
{"snippet": "random.Generator.f(dfnum, dfden)", "intent": "Draw samples from an F distribution . Samples are drawn from an F distribution with specified parameters , `dfnum` ( degrees of freedom in numerator ) and `dfden` ( degrees of freedom in denominator ) , where both parameters must be greater than zero .", "question_id": 3070},
{"snippet": "random.Generator.f(dfnum, dfden, size=None)", "intent": "Draw samples from an F distribution . Samples are drawn from an F distribution with specified parameters , `dfnum` ( degrees of freedom in numerator ) and `dfden` ( degrees of freedom in denominator ) , where both parameters must be greater than zero . With arguments `size`.", "question_id": 3071},
{"snippet": "polynomial.laguerre.Laguerre.mapparms()", "intent": "Return the mapping parameters .", "question_id": 3072},
{"snippet": "numpy.einsum(subscripts, *operands)", "intent": "Evaluates the Einstein summation convention on the operands . The `subscripts` string is a comma-separated list of subscript labels , where each label refers to a dimension of the corresponding operand . With arguments `*operands`.", "question_id": 3073},
{"snippet": "numpy.einsum(subscripts, *operands, out=None)", "intent": "Evaluates the Einstein summation convention on the operands . The `subscripts` string is a comma-separated list of subscript labels , where each label refers to a dimension of the corresponding operand . With arguments `*operands`, `out`.", "question_id": 3074},
{"snippet": "numpy.einsum(subscripts, *operands, dtype=None)", "intent": "Evaluates the Einstein summation convention on the operands . The `subscripts` string is a comma-separated list of subscript labels , where each label refers to a dimension of the corresponding operand . With arguments `*operands`, `dtype`.", "question_id": 3075},
{"snippet": "numpy.einsum(subscripts, *operands, order='K')", "intent": "Evaluates the Einstein summation convention on the operands . The `subscripts` string is a comma-separated list of subscript labels , where each label refers to a dimension of the corresponding operand . Additionally np.einsum ( 'ij , jh- > ih ' , a , b ) directly specifies the `order` of the output subscript labels and therefore returns matrix multiplication , unlike the example above in implicit mode . With arguments `*operands`.", "question_id": 3076},
{"snippet": "numpy.einsum(subscripts, *operands, casting='safe')", "intent": "Evaluates the Einstein summation convention on the operands . The `subscripts` string is a comma-separated list of subscript labels , where each label refers to a dimension of the corresponding operand . With arguments `*operands`, `casting`.", "question_id": 3077},
{"snippet": "numpy.einsum(subscripts, *operands, optimize=False)", "intent": "Evaluates the Einstein summation convention on the operands . The `subscripts` string is a comma-separated list of subscript labels , where each label refers to a dimension of the corresponding operand . Added the `optimize` argument which will optimize the contraction order of an einsum expression . With arguments `*operands`.", "question_id": 3078},
{"snippet": "numpy.einsum(subscripts, *operands, out=None, dtype=None)", "intent": "Evaluates the Einstein summation convention on the operands . The `subscripts` string is a comma-separated list of subscript labels , where each label refers to a dimension of the corresponding operand . With arguments `*operands`, `out`, `dtype`.", "question_id": 3079},
{"snippet": "numpy.einsum(subscripts, *operands, out=None, order='K')", "intent": "Evaluates the Einstein summation convention on the operands . The `subscripts` string is a comma-separated list of subscript labels , where each label refers to a dimension of the corresponding operand . Additionally np.einsum ( 'ij , jh- > ih ' , a , b ) directly specifies the `order` of the output subscript labels and therefore returns matrix multiplication , unlike the example above in implicit mode . With arguments `*operands`, `out`.", "question_id": 3080},
{"snippet": "numpy.einsum(subscripts, *operands, out=None, casting='safe')", "intent": "Evaluates the Einstein summation convention on the operands . The `subscripts` string is a comma-separated list of subscript labels , where each label refers to a dimension of the corresponding operand . With arguments `*operands`, `out`, `casting`.", "question_id": 3081},
{"snippet": "numpy.einsum(subscripts, *operands, out=None, optimize=False)", "intent": "Evaluates the Einstein summation convention on the operands . The `subscripts` string is a comma-separated list of subscript labels , where each label refers to a dimension of the corresponding operand . Added the `optimize` argument which will optimize the contraction order of an einsum expression . With arguments `*operands`, `out`.", "question_id": 3082},
{"snippet": "chararray.trace()", "intent": "Return the sum along diagonals of the array .", "question_id": 3083},
{"snippet": "chararray.trace(offset=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`.", "question_id": 3084},
{"snippet": "chararray.trace(axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `axis1`.", "question_id": 3085},
{"snippet": "chararray.trace(axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `axis2`.", "question_id": 3086},
{"snippet": "chararray.trace(dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `dtype`.", "question_id": 3087},
{"snippet": "chararray.trace(out=None)", "intent": "Return the sum along diagonals of the array . With arguments `out`.", "question_id": 3088},
{"snippet": "chararray.trace(offset=0, axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis1`.", "question_id": 3089},
{"snippet": "chararray.trace(offset=0, axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis2`.", "question_id": 3090},
{"snippet": "chararray.trace(offset=0, dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `dtype`.", "question_id": 3091},
{"snippet": "chararray.trace(offset=0, out=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `out`.", "question_id": 3092},
{"snippet": "chararray.reshape(shape)", "intent": "Returns an array containing the same data with a new `shape` .", "question_id": 3093},
{"snippet": "chararray.reshape(shape, order='C')", "intent": "Returns an array containing the same data with a new `shape` . With arguments `order`.", "question_id": 3094},
{"snippet": "ma.masked_array.size", "intent": "Number of elements in the array.", "question_id": 3095},
{"snippet": "ndarray.argmax()", "intent": "Return indices of the maximum values along the given `axis` .", "question_id": 3096},
{"snippet": "ndarray.argmax(axis=None)", "intent": "Return indices of the maximum values along the given `axis` .", "question_id": 3097},
{"snippet": "ndarray.argmax(out=None)", "intent": "Return indices of the maximum values along the given `axis` . With arguments `out`.", "question_id": 3098},
{"snippet": "ndarray.argmax(axis=None, out=None)", "intent": "Return indices of the maximum values along the given `axis` . With arguments `out`.", "question_id": 3099},
{"snippet": "recarray.ndim", "intent": "Number of array dimensions.", "question_id": 3100},
{"snippet": "numpy.busday_count(begindates, enddates)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates .", "question_id": 3101},
{"snippet": "numpy.busday_count(begindates, enddates, weekmask='1111100')", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `weekmask`.", "question_id": 3102},
{"snippet": "numpy.busday_count(begindates, enddates, holidays=)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `holidays`.", "question_id": 3103},
{"snippet": "numpy.busday_count(begindates, enddates, busdaycal=None)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `busdaycal`.", "question_id": 3104},
{"snippet": "numpy.busday_count(begindates, enddates, out=None)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `out`.", "question_id": 3105},
{"snippet": "numpy.busday_count(begindates, enddates, weekmask='1111100', holidays=)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `weekmask`, `holidays`.", "question_id": 3106},
{"snippet": "numpy.busday_count(begindates, enddates, weekmask='1111100', busdaycal=None)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `weekmask`, `busdaycal`.", "question_id": 3107},
{"snippet": "numpy.busday_count(begindates, enddates, weekmask='1111100', out=None)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `weekmask`, `out`.", "question_id": 3108},
{"snippet": "numpy.busday_count(begindates, enddates, holidays=, busdaycal=None)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `holidays`, `busdaycal`.", "question_id": 3109},
{"snippet": "numpy.busday_count(begindates, enddates, holidays=, out=None)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `holidays`, `out`.", "question_id": 3110},
{"snippet": "numpy.busday_count(begindates)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates .", "question_id": 3111},
{"snippet": "numpy.busday_count(begindates, weekmask='1111100')", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `weekmask`.", "question_id": 3112},
{"snippet": "numpy.busday_count(begindates, holidays=)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `holidays`.", "question_id": 3113},
{"snippet": "numpy.busday_count(begindates, busdaycal=None)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `busdaycal`.", "question_id": 3114},
{"snippet": "numpy.busday_count(begindates, out=None)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `out`.", "question_id": 3115},
{"snippet": "numpy.busday_count(begindates, weekmask='1111100', holidays=)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `weekmask`, `holidays`.", "question_id": 3116},
{"snippet": "numpy.busday_count(begindates, weekmask='1111100', busdaycal=None)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `weekmask`, `busdaycal`.", "question_id": 3117},
{"snippet": "numpy.busday_count(begindates, weekmask='1111100', out=None)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `weekmask`, `out`.", "question_id": 3118},
{"snippet": "numpy.busday_count(begindates, holidays=, busdaycal=None)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `holidays`, `busdaycal`.", "question_id": 3119},
{"snippet": "numpy.busday_count(begindates, holidays=, out=None)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `holidays`, `out`.", "question_id": 3120},
{"snippet": "polynomial.legendre.legvander3d(x, y, z, deg)", "intent": "Pseudo-Vandermonde matrix of given degrees . Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points ( `x` , `y` , `z` ) .", "question_id": 3121},
{"snippet": "char.chararray.dtype", "intent": "Data-type of the array\u2019s elements.", "question_id": 3122},
{"snippet": "ma.MaskedArray.squeeze()", "intent": "Remove axes of length one from a .", "question_id": 3123},
{"snippet": "ma.MaskedArray.squeeze(axis=None)", "intent": "Remove axes of length one from a . With arguments `axis`.", "question_id": 3124},
{"snippet": "ma.MaskType.searchsorted()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 3125},
{"snippet": "polynomial.hermite_e.HermiteE.roots()", "intent": "Return the roots of the series polynomial .", "question_id": 3126},
{"snippet": "chararray.isdigit()", "intent": "Returns true for each element if all characters in the string are digits and there is at least one character , false otherwise .", "question_id": 3127},
{"snippet": "numpy.trapz(y)", "intent": "Integrate along the given `axis` using the composite trapezoidal rule . Integrate `y` ( x ) along each 1d slice on the given axis , compute \\ ( \\int y ( x ) dx\\ ) .", "question_id": 3128},
{"snippet": "numpy.trapz(y, x=None)", "intent": "Integrate along the given `axis` using the composite trapezoidal rule . Integrate `y` ( x ) along each 1d slice on the given axis , compute \\ ( \\int y ( x ) dx\\ ) . If `x` is provided , the integration happens in sequence along its elements - they are not sorted .", "question_id": 3129},
{"snippet": "numpy.trapz(y, dx=1.0)", "intent": "Integrate along the given `axis` using the composite trapezoidal rule . Integrate `y` ( x ) along each 1d slice on the given axis , compute \\ ( \\int y ( x ) dx\\ ) . When x is specified , this integrates along the parametric curve , computing \\ ( \\int_t y ( t ) dt = \\int_t y ( t ) \\left.\\frac { `dx` } { dt } \\right|_ { x=x ( t ) } dt\\ ) .", "question_id": 3130},
{"snippet": "numpy.trapz(y, axis=- 1)", "intent": "Integrate along the given `axis` using the composite trapezoidal rule . Integrate `y` ( x ) along each 1d slice on the given axis , compute \\ ( \\int y ( x ) dx\\ ) .", "question_id": 3131},
{"snippet": "numpy.trapz(y, x=None, dx=1.0)", "intent": "Integrate along the given `axis` using the composite trapezoidal rule . Integrate `y` ( x ) along each 1d slice on the given axis , compute \\ ( \\int y ( x ) dx\\ ) . If `x` is provided , the integration happens in sequence along its elements - they are not sorted . When x is specified , this integrates along the parametric curve , computing \\ ( \\int_t y ( t ) dt = \\int_t y ( t ) \\left.\\frac { `dx` } { dt } \\right|_ { x=x ( t ) } dt\\ ) .", "question_id": 3132},
{"snippet": "numpy.trapz(y, x=None, axis=- 1)", "intent": "Integrate along the given `axis` using the composite trapezoidal rule . Integrate `y` ( x ) along each 1d slice on the given axis , compute \\ ( \\int y ( x ) dx\\ ) . If `x` is provided , the integration happens in sequence along its elements - they are not sorted .", "question_id": 3133},
{"snippet": "numpy.trapz(y, dx=1.0, axis=- 1)", "intent": "Integrate along the given `axis` using the composite trapezoidal rule . Integrate `y` ( x ) along each 1d slice on the given axis , compute \\ ( \\int y ( x ) dx\\ ) . When x is specified , this integrates along the parametric curve , computing \\ ( \\int_t y ( t ) dt = \\int_t y ( t ) \\left.\\frac { `dx` } { dt } \\right|_ { x=x ( t ) } dt\\ ) .", "question_id": 3134},
{"snippet": "numpy.trapz(y, x=None, dx=1.0, axis=- 1)", "intent": "Integrate along the given `axis` using the composite trapezoidal rule . Integrate `y` ( x ) along each 1d slice on the given axis , compute \\ ( \\int y ( x ) dx\\ ) . If `x` is provided , the integration happens in sequence along its elements - they are not sorted . When x is specified , this integrates along the parametric curve , computing \\ ( \\int_t y ( t ) dt = \\int_t y ( t ) \\left.\\frac { `dx` } { dt } \\right|_ { x=x ( t ) } dt\\ ) .", "question_id": 3135},
{"snippet": "numpy.ones(shape)", "intent": "Return a new array of given `shape` and type , filled with ones .", "question_id": 3136},
{"snippet": "numpy.ones(shape, dtype=None)", "intent": "Return a new array of given `shape` and type , filled with ones . With arguments `dtype`.", "question_id": 3137},
{"snippet": "numpy.ones(shape, order='C')", "intent": "Return a new array of given `shape` and type , filled with ones . With arguments `order`.", "question_id": 3138},
{"snippet": "numpy.ones(shape, like=None)", "intent": "Return a new array of given `shape` and type , filled with ones . With arguments `like`.", "question_id": 3139},
{"snippet": "numpy.ones(shape, dtype=None, order='C')", "intent": "Return a new array of given `shape` and type , filled with ones . With arguments `dtype`, `order`.", "question_id": 3140},
{"snippet": "numpy.ones(shape, dtype=None, like=None)", "intent": "Return a new array of given `shape` and type , filled with ones . With arguments `dtype`, `like`.", "question_id": 3141},
{"snippet": "numpy.ones(shape, order='C', like=None)", "intent": "Return a new array of given `shape` and type , filled with ones . With arguments `order`, `like`.", "question_id": 3142},
{"snippet": "numpy.ones(shape, dtype=None, order='C', like=None)", "intent": "Return a new array of given `shape` and type , filled with ones . With arguments `dtype`, `order`, `like`.", "question_id": 3143},
{"snippet": "ma.MaskType.fill()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 3144},
{"snippet": "random.Generator.negative_binomial(n, p)", "intent": "Draw samples from a negative binomial distribution . Samples are drawn from a negative binomial distribution with specified parameters , `n` successes and `p` probability of success where n is > 0 and p is in the interval ( 0 , 1 ] .", "question_id": 3145},
{"snippet": "random.Generator.negative_binomial(n, p, size=None)", "intent": "Draw samples from a negative binomial distribution . Samples are drawn from a negative binomial distribution with specified parameters , `n` successes and `p` probability of success where n is > 0 and p is in the interval ( 0 , 1 ] . With arguments `size`.", "question_id": 3146},
{"snippet": "chararray.translate(table)", "intent": "For each element in self , return a copy of the string where all characters occurring in the optional argument `deletechars` are removed , and the remaining characters have been mapped through the given translation `table` .", "question_id": 3147},
{"snippet": "chararray.translate(table, deletechars=None)", "intent": "For each element in self , return a copy of the string where all characters occurring in the optional argument `deletechars` are removed , and the remaining characters have been mapped through the given translation `table` .", "question_id": 3148},
{"snippet": "record.argmax()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 3149},
{"snippet": "ma.MaskedArray.__div__(other)", "intent": "Divide `other` into self , and return a new masked array .", "question_id": 3150},
{"snippet": "ma.MaskedArray.__rpow__(other)", "intent": "Raise `other` to the power self , masking the potential NaNs/Infs", "question_id": 3151},
{"snippet": "ma.inner(a, b)", "intent": "Inner product of two arrays . Ordinary inner product of vectors for 1-D arrays ( without complex conjugation ) , in higher dimensions `a` sum product over the last axes . More generally , if ndim ( a ) = r > 0 and ndim ( `b` ) = s > 0 :", "question_id": 3152},
{"snippet": "polynomial.legendre.Legendre.roots()", "intent": "Return the roots of the series polynomial .", "question_id": 3153},
{"snippet": "random.lognormal()", "intent": "Draw samples from a log-normal distribution .", "question_id": 3154},
{"snippet": "random.lognormal(mean=0.0)", "intent": "Draw samples from a log-normal distribution . Draw samples from a log-normal distribution with specified `mean` , standard deviation , and array shape .", "question_id": 3155},
{"snippet": "random.lognormal(sigma=1.0)", "intent": "Draw samples from a log-normal distribution . With arguments `sigma`.", "question_id": 3156},
{"snippet": "random.lognormal(size=None)", "intent": "Draw samples from a log-normal distribution . With arguments `size`.", "question_id": 3157},
{"snippet": "random.lognormal(mean=0.0, sigma=1.0)", "intent": "Draw samples from a log-normal distribution . Draw samples from a log-normal distribution with specified `mean` , standard deviation , and array shape . With arguments `sigma`.", "question_id": 3158},
{"snippet": "random.lognormal(mean=0.0, size=None)", "intent": "Draw samples from a log-normal distribution . Draw samples from a log-normal distribution with specified `mean` , standard deviation , and array shape . With arguments `size`.", "question_id": 3159},
{"snippet": "random.lognormal(sigma=1.0, size=None)", "intent": "Draw samples from a log-normal distribution . With arguments `sigma`, `size`.", "question_id": 3160},
{"snippet": "random.lognormal(mean=0.0, sigma=1.0, size=None)", "intent": "Draw samples from a log-normal distribution . Draw samples from a log-normal distribution with specified `mean` , standard deviation , and array shape . With arguments `sigma`, `size`.", "question_id": 3161},
{"snippet": "matrix.cumprod()", "intent": "Return the cumulative product of the elements along the given `axis` .", "question_id": 3162},
{"snippet": "matrix.cumprod(axis=None)", "intent": "Return the cumulative product of the elements along the given `axis` .", "question_id": 3163},
{"snippet": "matrix.cumprod(dtype=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`.", "question_id": 3164},
{"snippet": "matrix.cumprod(out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `out`.", "question_id": 3165},
{"snippet": "matrix.cumprod(axis=None, dtype=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`.", "question_id": 3166},
{"snippet": "matrix.cumprod(axis=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `out`.", "question_id": 3167},
{"snippet": "matrix.cumprod(dtype=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 3168},
{"snippet": "matrix.cumprod(axis=None, dtype=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 3169},
{"snippet": "char.startswith(a, prefix)", "intent": "Returns `a` boolean array which is True where the string element in a starts with `prefix` , otherwise False .", "question_id": 3170},
{"snippet": "char.startswith(a, prefix, start=0)", "intent": "Returns `a` boolean array which is True where the string element in a starts with `prefix` , otherwise False . With arguments `start`.", "question_id": 3171},
{"snippet": "char.startswith(a, prefix, end=None)", "intent": "Returns `a` boolean array which is True where the string element in a starts with `prefix` , otherwise False . With arguments `end`.", "question_id": 3172},
{"snippet": "char.startswith(a, prefix, start=0, end=None)", "intent": "Returns `a` boolean array which is True where the string element in a starts with `prefix` , otherwise False . With arguments `start`, `end`.", "question_id": 3173},
{"snippet": "char.less_equal(x1, x2)", "intent": "Return ( `x1` < = `x2` ) element-wise .", "question_id": 3174},
{"snippet": "lib.scimath.arctanh(x)", "intent": "Compute the inverse hyperbolic tangent of `x` .", "question_id": 3175},
{"snippet": "ndarray.dtype", "intent": "Data-type of the array\u2019s elements.", "question_id": 3176},
{"snippet": "testing.assert_string_equal(actual, desired)", "intent": "Test if two strings are equal . With arguments `actual`, `desired`.", "question_id": 3177},
{"snippet": "numpy.arcsinh(x, /, signature, extobj)", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `extobj`.", "question_id": 3178},
{"snippet": "numpy.arcsinh(x, /, signature, extobj, out=None)", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 3179},
{"snippet": "numpy.arcsinh(x, /, signature, extobj, where=True)", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 3180},
{"snippet": "numpy.arcsinh(x, /, signature, extobj, casting='same_kind')", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 3181},
{"snippet": "numpy.arcsinh(x, /, signature, extobj, order='K')", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 3182},
{"snippet": "numpy.arcsinh(x, /, signature, extobj, dtype=None)", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 3183},
{"snippet": "numpy.arcsinh(x, /, signature, extobj, subok=True)", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 3184},
{"snippet": "numpy.arcsinh(x, /, signature, extobj, out=None, where=True)", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 3185},
{"snippet": "numpy.arcsinh(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 3186},
{"snippet": "numpy.arcsinh(x, /, signature, extobj, out=None, order='K')", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 3187},
{"snippet": "numpy.arcsinh(x, /, signature)", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`.", "question_id": 3188},
{"snippet": "numpy.arcsinh(x, /, signature, out=None)", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `out`.", "question_id": 3189},
{"snippet": "numpy.arcsinh(x, /, signature, where=True)", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `where`.", "question_id": 3190},
{"snippet": "numpy.arcsinh(x, /, signature, casting='same_kind')", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `casting`.", "question_id": 3191},
{"snippet": "numpy.arcsinh(x, /, signature, order='K')", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `order`.", "question_id": 3192},
{"snippet": "numpy.arcsinh(x, /, signature, dtype=None)", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `dtype`.", "question_id": 3193},
{"snippet": "numpy.arcsinh(x, /, signature, subok=True)", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `subok`.", "question_id": 3194},
{"snippet": "numpy.arcsinh(x, /, signature, out=None, where=True)", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `out`, `where`.", "question_id": 3195},
{"snippet": "numpy.arcsinh(x, /, signature, out=None, casting='same_kind')", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 3196},
{"snippet": "numpy.arcsinh(x, /, signature, out=None, order='K')", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `out`, `order`.", "question_id": 3197},
{"snippet": "record.any()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 3198},
{"snippet": "ma.MaskType.item()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 3199},
{"snippet": "ma.hsplit(*args, **kwargs)", "intent": "Split an array into multiple sub-arrays horizontally ( column-wise ) . With arguments `*args`, `**kwargs`.", "question_id": 3200},
{"snippet": "numpy.exp(x, /, signature, extobj)", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `extobj`.", "question_id": 3201},
{"snippet": "numpy.exp(x, /, signature, extobj, out=None)", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 3202},
{"snippet": "numpy.exp(x, /, signature, extobj, where=True)", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 3203},
{"snippet": "numpy.exp(x, /, signature, extobj, casting='same_kind')", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 3204},
{"snippet": "numpy.exp(x, /, signature, extobj, order='K')", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 3205},
{"snippet": "numpy.exp(x, /, signature, extobj, dtype=None)", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 3206},
{"snippet": "numpy.exp(x, /, signature, extobj, subok=True)", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 3207},
{"snippet": "numpy.exp(x, /, signature, extobj, out=None, where=True)", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 3208},
{"snippet": "numpy.exp(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 3209},
{"snippet": "numpy.exp(x, /, signature, extobj, out=None, order='K')", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 3210},
{"snippet": "numpy.exp(x, /, signature)", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`.", "question_id": 3211},
{"snippet": "numpy.exp(x, /, signature, out=None)", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `out`.", "question_id": 3212},
{"snippet": "numpy.exp(x, /, signature, where=True)", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `where`.", "question_id": 3213},
{"snippet": "numpy.exp(x, /, signature, casting='same_kind')", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `casting`.", "question_id": 3214},
{"snippet": "numpy.exp(x, /, signature, order='K')", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `order`.", "question_id": 3215},
{"snippet": "numpy.exp(x, /, signature, dtype=None)", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `dtype`.", "question_id": 3216},
{"snippet": "numpy.exp(x, /, signature, subok=True)", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `subok`.", "question_id": 3217},
{"snippet": "numpy.exp(x, /, signature, out=None, where=True)", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `out`, `where`.", "question_id": 3218},
{"snippet": "numpy.exp(x, /, signature, out=None, casting='same_kind')", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 3219},
{"snippet": "numpy.exp(x, /, signature, out=None, order='K')", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `out`, `order`.", "question_id": 3220},
{"snippet": "char.mod(a, values)", "intent": "Return ( `a` % i ) , that is pre-Python 2.6 string formatting ( interpolation ) , element-wise for a pair of array_likes of str or unicode . With arguments `values`.", "question_id": 3221},
{"snippet": "record.std()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 3222},
{"snippet": "numpy.isinf(x, /, signature, extobj)", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `extobj`.", "question_id": 3223},
{"snippet": "numpy.isinf(x, /, signature, extobj, out=None)", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 3224},
{"snippet": "numpy.isinf(x, /, signature, extobj, where=True)", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `extobj`.", "question_id": 3225},
{"snippet": "numpy.isinf(x, /, signature, extobj, casting='same_kind')", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 3226},
{"snippet": "numpy.isinf(x, /, signature, extobj, order='K')", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 3227},
{"snippet": "numpy.isinf(x, /, signature, extobj, dtype=None)", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 3228},
{"snippet": "numpy.isinf(x, /, signature, extobj, subok=True)", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 3229},
{"snippet": "numpy.isinf(x, /, signature, extobj, out=None, where=True)", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 3230},
{"snippet": "numpy.isinf(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 3231},
{"snippet": "numpy.isinf(x, /, signature, extobj, out=None, order='K')", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 3232},
{"snippet": "numpy.isinf(x, /, signature)", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`.", "question_id": 3233},
{"snippet": "numpy.isinf(x, /, signature, out=None)", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `out`.", "question_id": 3234},
{"snippet": "numpy.isinf(x, /, signature, where=True)", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`.", "question_id": 3235},
{"snippet": "numpy.isinf(x, /, signature, casting='same_kind')", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `casting`.", "question_id": 3236},
{"snippet": "numpy.isinf(x, /, signature, order='K')", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `order`.", "question_id": 3237},
{"snippet": "numpy.isinf(x, /, signature, dtype=None)", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `dtype`.", "question_id": 3238},
{"snippet": "numpy.isinf(x, /, signature, subok=True)", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `subok`.", "question_id": 3239},
{"snippet": "numpy.isinf(x, /, signature, out=None, where=True)", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `out`.", "question_id": 3240},
{"snippet": "numpy.isinf(x, /, signature, out=None, casting='same_kind')", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 3241},
{"snippet": "numpy.isinf(x, /, signature, out=None, order='K')", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `out`, `order`.", "question_id": 3242},
{"snippet": "ndarray.ctypes", "intent": "An object to simplify the interaction of the array with the ctypes module.", "question_id": 3243},
{"snippet": "_ctypes.data", "intent": "A pointer to the memory area of the array as a Python integer.", "question_id": 3244},
{"snippet": "_ctypes.shape", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the C-integer corresponding to dtype('p') on this platform.", "question_id": 3245},
{"snippet": "_ctypes.strides", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the same as for the shape attribute.", "question_id": 3246},
{"snippet": "_ctypes.data_as(obj)", "intent": "Return the data pointer cast to a particular c-types object . With arguments `obj`.", "question_id": 3247},
{"snippet": "_ctypes.shape_as(obj)", "intent": "Return the shape tuple as an array of some other c-types type . With arguments `obj`.", "question_id": 3248},
{"snippet": "_ctypes.strides_as(obj)", "intent": "Return the strides tuple as an array of some other c-types type . With arguments `obj`.", "question_id": 3249},
{"snippet": "random.RandomState.rand(d0, d1, dn)", "intent": "Random values in a given shape . With arguments `d0`, `d1`, `dn`.", "question_id": 3250},
{"snippet": "ma.masked_all_like(arr)", "intent": "Empty masked array with the properties of an existing array . Return an empty masked array of the same shape and dtype as the array `arr` , where all the data are masked .", "question_id": 3251},
{"snippet": "polynomial.polynomial.polyval2d(x, y, c)", "intent": "Evaluate a 2-D polynomial at points ( `x` , `y` ) . In either case , either x and y or their elements must support multiplication and addition both with themselves and with the elements of `c` .", "question_id": 3252},
{"snippet": "char.chararray.choose(choices)", "intent": "Use an index array to construct a new array from a set of `choices` .", "question_id": 3253},
{"snippet": "char.chararray.choose(choices, out=None)", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`.", "question_id": 3254},
{"snippet": "char.chararray.choose(choices, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `mode`.", "question_id": 3255},
{"snippet": "char.chararray.choose(choices, out=None, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`, `mode`.", "question_id": 3256},
{"snippet": "chararray.nbytes", "intent": "Total bytes consumed by the elements of the array.", "question_id": 3257},
{"snippet": "ma.masked_array.tolist()", "intent": "Return the data portion of the masked array as a hierarchical Python list .", "question_id": 3258},
{"snippet": "ma.masked_array.tolist(fill_value=None)", "intent": "Return the data portion of the masked array as a hierarchical Python list . Masked values are converted to `fill_value` .", "question_id": 3259},
{"snippet": "ma.MaskType.std()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 3260},
{"snippet": "ma.MaskedArray.copy()", "intent": "Return a copy of the array .", "question_id": 3261},
{"snippet": "ma.MaskedArray.copy(order='C')", "intent": "Return a copy of the array . The function numpy.copy is similar , but it defaults to using `order` \u2018 K \u2019 , and will not pass sub-classes through by default .", "question_id": 3262},
{"snippet": "chararray.min()", "intent": "Return the minimum along a given `axis` .", "question_id": 3263},
{"snippet": "chararray.min(axis=None)", "intent": "Return the minimum along a given `axis` .", "question_id": 3264},
{"snippet": "chararray.min(out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`.", "question_id": 3265},
{"snippet": "chararray.min(keepdims=False)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`.", "question_id": 3266},
{"snippet": "chararray.min(initial=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `initial`.", "question_id": 3267},
{"snippet": "chararray.min(where=True)", "intent": "Return the minimum along a given `axis` . With arguments `where`.", "question_id": 3268},
{"snippet": "chararray.min(axis=None, out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`.", "question_id": 3269},
{"snippet": "chararray.min(axis=None, keepdims=False)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`.", "question_id": 3270},
{"snippet": "chararray.min(axis=None, initial=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `initial`.", "question_id": 3271},
{"snippet": "chararray.min(axis=None, where=True)", "intent": "Return the minimum along a given `axis` . With arguments `where`.", "question_id": 3272},
{"snippet": "recarray.argmax()", "intent": "Return indices of the maximum values along the given `axis` .", "question_id": 3273},
{"snippet": "recarray.argmax(axis=None)", "intent": "Return indices of the maximum values along the given `axis` .", "question_id": 3274},
{"snippet": "recarray.argmax(out=None)", "intent": "Return indices of the maximum values along the given `axis` . With arguments `out`.", "question_id": 3275},
{"snippet": "recarray.argmax(axis=None, out=None)", "intent": "Return indices of the maximum values along the given `axis` . With arguments `out`.", "question_id": 3276},
{"snippet": "ma.MaskedArray.torecords()", "intent": "Transforms a masked array into a flexible-type array .", "question_id": 3277},
{"snippet": "recarray.copy()", "intent": "Return a copy of the array .", "question_id": 3278},
{"snippet": "recarray.copy(order='C')", "intent": "Return a copy of the array . The function numpy.copy is similar , but it defaults to using `order` \u2018 K \u2019 , and will not pass sub-classes through by default .", "question_id": 3279},
{"snippet": "random.RandomState.f(dfnum, dfden)", "intent": "Draw samples from an F distribution . Samples are drawn from an F distribution with specified parameters , `dfnum` ( degrees of freedom in numerator ) and `dfden` ( degrees of freedom in denominator ) , where both parameters must be greater than zero .", "question_id": 3280},
{"snippet": "random.RandomState.f(dfnum, dfden, size=None)", "intent": "Draw samples from an F distribution . Samples are drawn from an F distribution with specified parameters , `dfnum` ( degrees of freedom in numerator ) and `dfden` ( degrees of freedom in denominator ) , where both parameters must be greater than zero . With arguments `size`.", "question_id": 3281},
{"snippet": "ndarray.ravel(order)", "intent": "Return a flattened array . With arguments `order`.", "question_id": 3282},
{"snippet": "ndarray.ravel()", "intent": "Return a flattened array .", "question_id": 3283},
{"snippet": "char.chararray.count(sub)", "intent": "Returns an array with the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] .", "question_id": 3284},
{"snippet": "char.chararray.count(sub, start=0)", "intent": "Returns an array with the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] .", "question_id": 3285},
{"snippet": "char.chararray.count(sub, end=None)", "intent": "Returns an array with the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] .", "question_id": 3286},
{"snippet": "char.chararray.count(sub, start=0, end=None)", "intent": "Returns an array with the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] .", "question_id": 3287},
{"snippet": "ndarray.__rshift__(value, /)", "intent": "Return self > > `value` . With arguments `/`.", "question_id": 3288},
{"snippet": "ma.flatnotmasked_contiguous(a)", "intent": "Find contiguous unmasked data in `a` masked array along the given axis .", "question_id": 3289},
{"snippet": "ndarray.__iadd__(value, /)", "intent": "Return self+=value . With arguments `value`, `/`.", "question_id": 3290},
{"snippet": "recarray.max()", "intent": "Return the maximum along a given `axis` .", "question_id": 3291},
{"snippet": "recarray.max(axis=None)", "intent": "Return the maximum along a given `axis` .", "question_id": 3292},
{"snippet": "recarray.max(out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`.", "question_id": 3293},
{"snippet": "recarray.max(keepdims=False)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`.", "question_id": 3294},
{"snippet": "recarray.max(initial=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `initial`.", "question_id": 3295},
{"snippet": "recarray.max(where=True)", "intent": "Return the maximum along a given `axis` . With arguments `where`.", "question_id": 3296},
{"snippet": "recarray.max(axis=None, out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`.", "question_id": 3297},
{"snippet": "recarray.max(axis=None, keepdims=False)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`.", "question_id": 3298},
{"snippet": "recarray.max(axis=None, initial=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `initial`.", "question_id": 3299},
{"snippet": "recarray.max(axis=None, where=True)", "intent": "Return the maximum along a given `axis` . With arguments `where`.", "question_id": 3300},
{"snippet": "recarray.dumps()", "intent": "Returns the pickle of the array as a string .", "question_id": 3301},
{"snippet": "polynomial.polynomial.Polynomial.integ()", "intent": "Integrate .", "question_id": 3302},
{"snippet": "polynomial.polynomial.Polynomial.integ(m=1)", "intent": "Integrate . With arguments `m`.", "question_id": 3303},
{"snippet": "polynomial.polynomial.Polynomial.integ(k=)", "intent": "Integrate . With arguments `k`.", "question_id": 3304},
{"snippet": "polynomial.polynomial.Polynomial.integ(lbnd=None)", "intent": "Integrate . With arguments `lbnd`.", "question_id": 3305},
{"snippet": "polynomial.polynomial.Polynomial.integ(m=1, k=)", "intent": "Integrate . With arguments `m`, `k`.", "question_id": 3306},
{"snippet": "polynomial.polynomial.Polynomial.integ(m=1, lbnd=None)", "intent": "Integrate . With arguments `m`, `lbnd`.", "question_id": 3307},
{"snippet": "polynomial.polynomial.Polynomial.integ(k=, lbnd=None)", "intent": "Integrate . With arguments `k`, `lbnd`.", "question_id": 3308},
{"snippet": "polynomial.polynomial.Polynomial.integ(m=1, k=, lbnd=None)", "intent": "Integrate . With arguments `m`, `k`, `lbnd`.", "question_id": 3309},
{"snippet": "polynomial.polynomial.Polynomial.integ()", "intent": "Integrate .", "question_id": 3310},
{"snippet": "polynomial.polynomial.Polynomial.integ(m=1)", "intent": "Integrate . With arguments `m`.", "question_id": 3311},
{"snippet": "polynomial.polynomial.Polynomial.integ(k=)", "intent": "Integrate . With arguments `k`.", "question_id": 3312},
{"snippet": "polynomial.polynomial.Polynomial.integ(lbnd=None)", "intent": "Integrate . With arguments `lbnd`.", "question_id": 3313},
{"snippet": "polynomial.polynomial.Polynomial.integ(m=1, k=)", "intent": "Integrate . With arguments `m`, `k`.", "question_id": 3314},
{"snippet": "polynomial.polynomial.Polynomial.integ(m=1, lbnd=None)", "intent": "Integrate . With arguments `m`, `lbnd`.", "question_id": 3315},
{"snippet": "polynomial.polynomial.Polynomial.integ(k=, lbnd=None)", "intent": "Integrate . With arguments `k`, `lbnd`.", "question_id": 3316},
{"snippet": "polynomial.polynomial.Polynomial.integ(m=1, k=, lbnd=None)", "intent": "Integrate . With arguments `m`, `k`, `lbnd`.", "question_id": 3317},
{"snippet": "numpy.choose(a, choices)", "intent": "Construct an array from an index array and `a` list of arrays to choose from . Given an \u201c index \u201d array ( a ) of integers and a sequence of n arrays ( `choices` ) , a and each choice array are first broadcast , as necessary , to arrays of a common shape ; calling these Ba and Bchoices [ i ] , i = 0 , \u2026 , n-1 we have that , necessarily , Ba.shape == Bchoices [ i ] .shape for each i .", "question_id": 3318},
{"snippet": "numpy.choose(a, choices, out=None)", "intent": "Construct an array from an index array and `a` list of arrays to choose from . Given an \u201c index \u201d array ( a ) of integers and a sequence of n arrays ( `choices` ) , a and each choice array are first broadcast , as necessary , to arrays of a common shape ; calling these Ba and Bchoices [ i ] , i = 0 , \u2026 , n-1 we have that , necessarily , Ba.shape == Bchoices [ i ] .shape for each i . With arguments `out`.", "question_id": 3319},
{"snippet": "numpy.choose(a, choices, mode='raise')", "intent": "Construct an array from an index array and `a` list of arrays to choose from . Given an \u201c index \u201d array ( a ) of integers and a sequence of n arrays ( `choices` ) , a and each choice array are first broadcast , as necessary , to arrays of a common shape ; calling these Ba and Bchoices [ i ] , i = 0 , \u2026 , n-1 we have that , necessarily , Ba.shape == Bchoices [ i ] .shape for each i . With arguments `mode`.", "question_id": 3320},
{"snippet": "numpy.choose(a, choices, out=None, mode='raise')", "intent": "Construct an array from an index array and `a` list of arrays to choose from . Given an \u201c index \u201d array ( a ) of integers and a sequence of n arrays ( `choices` ) , a and each choice array are first broadcast , as necessary , to arrays of a common shape ; calling these Ba and Bchoices [ i ] , i = 0 , \u2026 , n-1 we have that , necessarily , Ba.shape == Bchoices [ i ] .shape for each i . With arguments `out`, `mode`.", "question_id": 3321},
{"snippet": "record.size", "intent": "The number of elements in the gentype.", "question_id": 3322},
{"snippet": "char.chararray.isdigit()", "intent": "Returns true for each element if all characters in the string are digits and there is at least one character , false otherwise .", "question_id": 3323},
{"snippet": "ma.masked_invalid(a)", "intent": "Mask an array where invalid values occur ( NaNs or infs ) . This function is `a` shortcut to masked_where , with condition = ~ ( np.isfinite ( a ) ) .", "question_id": 3324},
{"snippet": "ma.masked_invalid(a, copy=True)", "intent": "Mask an array where invalid values occur ( NaNs or infs ) . This function is `a` shortcut to masked_where , with condition = ~ ( np.isfinite ( a ) ) . With arguments `copy`.", "question_id": 3325},
{"snippet": "ma.atleast_3d(*args, **kwargs)", "intent": "View inputs as arrays with at least three dimensions . With arguments `*args`, `**kwargs`.", "question_id": 3326},
{"snippet": "generic.__array_struct__", "intent": "Array protocol: struct", "question_id": 3327},
{"snippet": "numpy.lib.Arrayterator(var)", "intent": "Buffered iterator for big arrays . With arguments `var`.", "question_id": 3328},
{"snippet": "numpy.lib.Arrayterator(var, buf_size=None)", "intent": "Buffered iterator for big arrays . if `buf_size` is smaller than d1 , the first dimension will be used . With arguments `var`.", "question_id": 3329},
{"snippet": "polynomial.laguerre.lagweight(x)", "intent": "Weight function of the Laguerre polynomials . With arguments `x`.", "question_id": 3330},
{"snippet": "polynomial.chebyshev.chebpts2(npts)", "intent": "Chebyshev points of the second kind . The Chebyshev points of the second kind are the points cos ( x ) , where x = [ pi * k/ ( `npts` - 1 ) for k in range ( npts ) ] .", "question_id": 3331},
{"snippet": "ma.MaskType.newbyteorder(/)", "intent": "Return a new dtype with a different byte order . With arguments `/`.", "question_id": 3332},
{"snippet": "ma.MaskType.newbyteorder(/, new_order='S')", "intent": "Return a new dtype with a different byte order . The `new_order` code can be any from the following : With arguments `/`.", "question_id": 3333},
{"snippet": "dtype.kind", "intent": "A character code (one of \u2018biufcmMOSUV\u2019) identifying the general kind of data.", "question_id": 3334},
{"snippet": "polynomial.hermite_e.hermeval(x, c)", "intent": "Evaluate an HermiteE series at points `x` . If `c` is of length n + 1 , this function returns the value :", "question_id": 3335},
{"snippet": "polynomial.hermite_e.hermeval(x, c, tensor=True)", "intent": "Evaluate an HermiteE series at points `x` . If `c` is of length n + 1 , this function returns the value : If c is multidimensional , then the shape of the result depends on the value of `tensor` .", "question_id": 3336},
{"snippet": "random.RandomState.noncentral_f(dfnum, dfden, nonc)", "intent": "Draw samples from the noncentral F distribution . Samples are drawn from an F distribution with specified parameters , `dfnum` ( degrees of freedom in numerator ) and `dfden` ( degrees of freedom in denominator ) , where both parameters > 1. `nonc` is the non-centrality parameter .", "question_id": 3337},
{"snippet": "random.RandomState.noncentral_f(dfnum, dfden, nonc, size=None)", "intent": "Draw samples from the noncentral F distribution . Samples are drawn from an F distribution with specified parameters , `dfnum` ( degrees of freedom in numerator ) and `dfden` ( degrees of freedom in denominator ) , where both parameters > 1. `nonc` is the non-centrality parameter . With arguments `size`.", "question_id": 3338},
{"snippet": "recarray.prod()", "intent": "Return the product of the array elements over the given `axis`", "question_id": 3339},
{"snippet": "recarray.prod(axis=None)", "intent": "Return the product of the array elements over the given `axis`", "question_id": 3340},
{"snippet": "recarray.prod(dtype=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `dtype`.", "question_id": 3341},
{"snippet": "recarray.prod(out=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `out`.", "question_id": 3342},
{"snippet": "recarray.prod(keepdims=False)", "intent": "Return the product of the array elements over the given `axis` With arguments `keepdims`.", "question_id": 3343},
{"snippet": "recarray.prod(initial=1)", "intent": "Return the product of the array elements over the given `axis` With arguments `initial`.", "question_id": 3344},
{"snippet": "recarray.prod(where=True)", "intent": "Return the product of the array elements over the given `axis` With arguments `where`.", "question_id": 3345},
{"snippet": "recarray.prod(axis=None, dtype=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `dtype`.", "question_id": 3346},
{"snippet": "recarray.prod(axis=None, out=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `out`.", "question_id": 3347},
{"snippet": "recarray.prod(axis=None, keepdims=False)", "intent": "Return the product of the array elements over the given `axis` With arguments `keepdims`.", "question_id": 3348},
{"snippet": "numpy.nanargmin(a)", "intent": "Return the indices of the minimum values in the specified `axis` ignoring NaNs . Warning : the results can not be trusted if `a` slice contains only NaNs and Infs .", "question_id": 3349},
{"snippet": "numpy.nanargmin(a, axis=None)", "intent": "Return the indices of the minimum values in the specified `axis` ignoring NaNs . Warning : the results can not be trusted if `a` slice contains only NaNs and Infs .", "question_id": 3350},
{"snippet": "polynomial.hermite_e.hermemulx(c)", "intent": "Multiply a Hermite series by x . Multiply the Hermite series `c` by x , where x is the independent variable .", "question_id": 3351},
{"snippet": "ndarray.prod()", "intent": "Return the product of the array elements over the given `axis`", "question_id": 3352},
{"snippet": "ndarray.prod(axis=None)", "intent": "Return the product of the array elements over the given `axis`", "question_id": 3353},
{"snippet": "ndarray.prod(dtype=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `dtype`.", "question_id": 3354},
{"snippet": "ndarray.prod(out=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `out`.", "question_id": 3355},
{"snippet": "ndarray.prod(keepdims=False)", "intent": "Return the product of the array elements over the given `axis` With arguments `keepdims`.", "question_id": 3356},
{"snippet": "ndarray.prod(initial=1)", "intent": "Return the product of the array elements over the given `axis` With arguments `initial`.", "question_id": 3357},
{"snippet": "ndarray.prod(where=True)", "intent": "Return the product of the array elements over the given `axis` With arguments `where`.", "question_id": 3358},
{"snippet": "ndarray.prod(axis=None, dtype=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `dtype`.", "question_id": 3359},
{"snippet": "ndarray.prod(axis=None, out=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `out`.", "question_id": 3360},
{"snippet": "ndarray.prod(axis=None, keepdims=False)", "intent": "Return the product of the array elements over the given `axis` With arguments `keepdims`.", "question_id": 3361},
{"snippet": "ndarray.__len__(/)", "intent": "Return len ( self ) . With arguments `/`.", "question_id": 3362},
{"snippet": "polynomial.legendre.Legendre.deriv()", "intent": "Differentiate .", "question_id": 3363},
{"snippet": "polynomial.legendre.Legendre.deriv(m=1)", "intent": "Differentiate . With arguments `m`.", "question_id": 3364},
{"snippet": "numpy.outer(a, b)", "intent": "Compute the outer product of two vectors . Given two vectors , `a` = [ a0 , a1 , ... , aM ] and `b` = [ b0 , b1 , ... , bN ] , the outer product [ 1 ] is :", "question_id": 3365},
{"snippet": "numpy.outer(a, b, out=None)", "intent": "Compute the outer product of two vectors . Given two vectors , `a` = [ a0 , a1 , ... , aM ] and `b` = [ b0 , b1 , ... , bN ] , the outer product [ 1 ] is : With arguments `out`.", "question_id": 3366},
{"snippet": "matrix.setflags()", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively .", "question_id": 3367},
{"snippet": "matrix.setflags(write=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`.", "question_id": 3368},
{"snippet": "matrix.setflags(align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`.", "question_id": 3369},
{"snippet": "matrix.setflags(uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `uic`.", "question_id": 3370},
{"snippet": "matrix.setflags(write=None, align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`.", "question_id": 3371},
{"snippet": "matrix.setflags(write=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `uic`.", "question_id": 3372},
{"snippet": "matrix.setflags(align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`, `uic`.", "question_id": 3373},
{"snippet": "matrix.setflags(write=None, align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`, `uic`.", "question_id": 3374},
{"snippet": "recarray.shape", "intent": "Tuple of array dimensions.", "question_id": 3375},
{"snippet": "ndarray.max()", "intent": "Return the maximum along a given `axis` .", "question_id": 3376},
{"snippet": "ndarray.max(axis=None)", "intent": "Return the maximum along a given `axis` .", "question_id": 3377},
{"snippet": "ndarray.max(out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`.", "question_id": 3378},
{"snippet": "ndarray.max(keepdims=False)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`.", "question_id": 3379},
{"snippet": "ndarray.max(initial=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `initial`.", "question_id": 3380},
{"snippet": "ndarray.max(where=True)", "intent": "Return the maximum along a given `axis` . With arguments `where`.", "question_id": 3381},
{"snippet": "ndarray.max(axis=None, out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`.", "question_id": 3382},
{"snippet": "ndarray.max(axis=None, keepdims=False)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`.", "question_id": 3383},
{"snippet": "ndarray.max(axis=None, initial=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `initial`.", "question_id": 3384},
{"snippet": "ndarray.max(axis=None, where=True)", "intent": "Return the maximum along a given `axis` . With arguments `where`.", "question_id": 3385},
{"snippet": "recarray.clip(**kwargs)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 3386},
{"snippet": "recarray.clip(**kwargs, min=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 3387},
{"snippet": "recarray.clip(**kwargs, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 3388},
{"snippet": "recarray.clip(**kwargs, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 3389},
{"snippet": "recarray.clip(**kwargs, min=None, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 3390},
{"snippet": "recarray.clip(**kwargs, min=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 3391},
{"snippet": "recarray.clip(**kwargs, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 3392},
{"snippet": "recarray.clip(**kwargs, min=None, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 3393},
{"snippet": "memmap.argpartition(kth)", "intent": "Returns the indices that would partition this array . With arguments `kth`.", "question_id": 3394},
{"snippet": "memmap.argpartition(kth, axis=- 1)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`.", "question_id": 3395},
{"snippet": "memmap.argpartition(kth, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`.", "question_id": 3396},
{"snippet": "memmap.argpartition(kth, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `order`.", "question_id": 3397},
{"snippet": "memmap.argpartition(kth, axis=- 1, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`.", "question_id": 3398},
{"snippet": "memmap.argpartition(kth, axis=- 1, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `order`.", "question_id": 3399},
{"snippet": "memmap.argpartition(kth, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`, `order`.", "question_id": 3400},
{"snippet": "memmap.argpartition(kth, axis=- 1, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`, `order`.", "question_id": 3401},
{"snippet": "ma.masked_array.tofile(fid)", "intent": "Save a masked array to a file in binary `format` . With arguments `fid`.", "question_id": 3402},
{"snippet": "ma.masked_array.tofile(fid, sep='')", "intent": "Save a masked array to a file in binary `format` . With arguments `fid`, `sep`.", "question_id": 3403},
{"snippet": "ma.masked_array.tofile(fid, format='%s')", "intent": "Save a masked array to a file in binary `format` . With arguments `fid`.", "question_id": 3404},
{"snippet": "ma.masked_array.tofile(fid, sep='', format='%s')", "intent": "Save a masked array to a file in binary `format` . With arguments `fid`, `sep`.", "question_id": 3405},
{"snippet": "chararray.setflags()", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively .", "question_id": 3406},
{"snippet": "chararray.setflags(write=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`.", "question_id": 3407},
{"snippet": "chararray.setflags(align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`.", "question_id": 3408},
{"snippet": "chararray.setflags(uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `uic`.", "question_id": 3409},
{"snippet": "chararray.setflags(write=None, align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`.", "question_id": 3410},
{"snippet": "chararray.setflags(write=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `uic`.", "question_id": 3411},
{"snippet": "chararray.setflags(align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`, `uic`.", "question_id": 3412},
{"snippet": "chararray.setflags(write=None, align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`, `uic`.", "question_id": 3413},
{"snippet": "random.shuffle(x)", "intent": "Modify a sequence in-place by shuffling its contents . With arguments `x`.", "question_id": 3414},
{"snippet": "ma.MaskedArray.__floordiv__(other)", "intent": "Divide `other` into self , and return a new masked array .", "question_id": 3415},
{"snippet": "matrix.itemset(*args)", "intent": "Insert scalar into an array ( scalar is cast to array \u2019 s dtype , if possible ) With arguments `*args`.", "question_id": 3416},
{"snippet": "ma.masked_array.compressed()", "intent": "Return all the non-masked data as a 1-D array .", "question_id": 3417},
{"snippet": "linalg.tensorsolve(a, b)", "intent": "Solve the tensor equation `a` x = `b` for x .", "question_id": 3418},
{"snippet": "linalg.tensorsolve(a, b, axes=None)", "intent": "Solve the tensor equation `a` x = `b` for x . With arguments `axes`.", "question_id": 3419},
{"snippet": "ma.MaskedArray.mean()", "intent": "Returns the average of the array elements along given `axis` .", "question_id": 3420},
{"snippet": "ma.MaskedArray.mean(axis=None)", "intent": "Returns the average of the array elements along given `axis` .", "question_id": 3421},
{"snippet": "ma.MaskedArray.mean(dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`.", "question_id": 3422},
{"snippet": "ma.MaskedArray.mean(out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`.", "question_id": 3423},
{"snippet": "ma.MaskedArray.mean(keepdims=<no value>)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`.", "question_id": 3424},
{"snippet": "ma.MaskedArray.mean(axis=None, dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`.", "question_id": 3425},
{"snippet": "ma.MaskedArray.mean(axis=None, out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`.", "question_id": 3426},
{"snippet": "ma.MaskedArray.mean(axis=None, keepdims=<no value>)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`.", "question_id": 3427},
{"snippet": "ma.MaskedArray.mean(dtype=None, out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`, `out`.", "question_id": 3428},
{"snippet": "ma.MaskedArray.mean(dtype=None, keepdims=<no value>)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`, `keepdims`.", "question_id": 3429},
{"snippet": "random.seed(self)", "intent": "Reseed a legacy MT19937 BitGenerator With arguments `self`.", "question_id": 3430},
{"snippet": "random.seed(self, seed=None)", "intent": "Reseed a legacy MT19937 BitGenerator With arguments `self`, `seed`.", "question_id": 3431},
{"snippet": "ma.MaskType.flags", "intent": "The integer value of flags.", "question_id": 3432},
{"snippet": "numpy.tile(A, reps)", "intent": "Construct an array by repeating `A` the number of times given by `reps` .", "question_id": 3433},
{"snippet": "ma.MaskedArray.dumps()", "intent": "Returns the pickle of the array as a string .", "question_id": 3434},
{"snippet": "numpy.angle(z)", "intent": "Return the angle of the complex argument . With arguments `z`.", "question_id": 3435},
{"snippet": "numpy.angle(z, deg=False)", "intent": "Return the angle of the complex argument . With arguments `z`, `deg`.", "question_id": 3436},
{"snippet": "numpy.swapaxes(a, axis1, axis2)", "intent": "Interchange two axes of an array . With arguments `a`, `axis1`, `axis2`.", "question_id": 3437},
{"snippet": "matrix.ravel()", "intent": "Return a flattened matrix .", "question_id": 3438},
{"snippet": "matrix.ravel(order='C')", "intent": "Return a flattened matrix . With arguments `order`.", "question_id": 3439},
{"snippet": "flatiter.copy()", "intent": "Get a copy of the iterator as a 1-D array .", "question_id": 3440},
{"snippet": "char.chararray.swapcase()", "intent": "For each element in self , return a copy of the string with uppercase characters converted to lowercase and vice versa .", "question_id": 3441},
{"snippet": "polynomial.laguerre.Laguerre.linspace()", "intent": "Return x , y values at equally spaced points in `domain` .", "question_id": 3442},
{"snippet": "polynomial.laguerre.Laguerre.linspace(n=100)", "intent": "Return x , y values at equally spaced points in `domain` . Returns the x , y values at `n` linearly spaced points across the domain .", "question_id": 3443},
{"snippet": "polynomial.laguerre.Laguerre.linspace(domain=None)", "intent": "Return x , y values at equally spaced points in `domain` .", "question_id": 3444},
{"snippet": "polynomial.laguerre.Laguerre.linspace(n=100, domain=None)", "intent": "Return x , y values at equally spaced points in `domain` . Returns the x , y values at `n` linearly spaced points across the domain .", "question_id": 3445},
{"snippet": "random.permutation(x)", "intent": "Randomly permute a sequence , or return a permuted range . If `x` is a multi-dimensional array , it is only shuffled along its first index .", "question_id": 3446},
{"snippet": "ma.MaskedArray.__contains__(key, /)", "intent": "Return `key` in self . With arguments `/`.", "question_id": 3447},
{"snippet": "recarray.real", "intent": "The real part of the array.", "question_id": 3448},
{"snippet": "polynomial.legendre.Legendre.truncate(size)", "intent": "Truncate series to length `size` .", "question_id": 3449},
{"snippet": "ndarray.dump(file)", "intent": "Dump a pickle of the array to the specified `file` .", "question_id": 3450},
{"snippet": "polynomial.laguerre.lagadd(c1, c2)", "intent": "Add one Laguerre series to another . Returns the sum of two Laguerre series `c1` + `c2` .", "question_id": 3451},
{"snippet": "numpy.arctanh(x, /, signature, extobj)", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `extobj`.", "question_id": 3452},
{"snippet": "numpy.arctanh(x, /, signature, extobj, out=None)", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 3453},
{"snippet": "numpy.arctanh(x, /, signature, extobj, where=True)", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 3454},
{"snippet": "numpy.arctanh(x, /, signature, extobj, casting='same_kind')", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 3455},
{"snippet": "numpy.arctanh(x, /, signature, extobj, order='K')", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 3456},
{"snippet": "numpy.arctanh(x, /, signature, extobj, dtype=None)", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 3457},
{"snippet": "numpy.arctanh(x, /, signature, extobj, subok=True)", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 3458},
{"snippet": "numpy.arctanh(x, /, signature, extobj, out=None, where=True)", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 3459},
{"snippet": "numpy.arctanh(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 3460},
{"snippet": "numpy.arctanh(x, /, signature, extobj, out=None, order='K')", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 3461},
{"snippet": "numpy.arctanh(x, /, signature)", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`.", "question_id": 3462},
{"snippet": "numpy.arctanh(x, /, signature, out=None)", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `out`.", "question_id": 3463},
{"snippet": "numpy.arctanh(x, /, signature, where=True)", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `where`.", "question_id": 3464},
{"snippet": "numpy.arctanh(x, /, signature, casting='same_kind')", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `casting`.", "question_id": 3465},
{"snippet": "numpy.arctanh(x, /, signature, order='K')", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `order`.", "question_id": 3466},
{"snippet": "numpy.arctanh(x, /, signature, dtype=None)", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `dtype`.", "question_id": 3467},
{"snippet": "numpy.arctanh(x, /, signature, subok=True)", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `subok`.", "question_id": 3468},
{"snippet": "numpy.arctanh(x, /, signature, out=None, where=True)", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `out`, `where`.", "question_id": 3469},
{"snippet": "numpy.arctanh(x, /, signature, out=None, casting='same_kind')", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 3470},
{"snippet": "numpy.arctanh(x, /, signature, out=None, order='K')", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `out`, `order`.", "question_id": 3471},
{"snippet": "record.swapaxes()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 3472},
{"snippet": "matrix.size", "intent": "Number of elements in the array.", "question_id": 3473},
{"snippet": "numpy.nancumprod(a)", "intent": "Return the cumulative product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as one .", "question_id": 3474},
{"snippet": "numpy.nancumprod(a, axis=None)", "intent": "Return the cumulative product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as one .", "question_id": 3475},
{"snippet": "numpy.nancumprod(a, dtype=None)", "intent": "Return the cumulative product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as one . With arguments `dtype`.", "question_id": 3476},
{"snippet": "numpy.nancumprod(a, out=None)", "intent": "Return the cumulative product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as one . With arguments `out`.", "question_id": 3477},
{"snippet": "numpy.nancumprod(a, axis=None, dtype=None)", "intent": "Return the cumulative product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as one . With arguments `dtype`.", "question_id": 3478},
{"snippet": "numpy.nancumprod(a, axis=None, out=None)", "intent": "Return the cumulative product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as one . With arguments `out`.", "question_id": 3479},
{"snippet": "numpy.nancumprod(a, dtype=None, out=None)", "intent": "Return the cumulative product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as one . With arguments `dtype`, `out`.", "question_id": 3480},
{"snippet": "numpy.nancumprod(a, axis=None, dtype=None, out=None)", "intent": "Return the cumulative product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as one . With arguments `dtype`, `out`.", "question_id": 3481},
{"snippet": "polynomial.polyutils.getdomain(x)", "intent": "Return a domain suitable for given abscissae . With arguments `x`.", "question_id": 3482},
{"snippet": "numpy.ix_(*args)", "intent": "Construct an open mesh from multiple sequences . With arguments `*args`.", "question_id": 3483},
{"snippet": "polynomial.laguerre.lagval3d(x, y, z, c)", "intent": "Evaluate a 3-D Laguerre series at points ( `x` , `y` , `z` ) . In either case , either x , y , and z or their elements must support multiplication and addition both with themselves and with the elements of `c` .", "question_id": 3484},
{"snippet": "numpy.gcd(x1, x2, /, signature, extobj)", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`.", "question_id": 3485},
{"snippet": "numpy.gcd(x1, x2, /, signature, extobj, out=None)", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`.", "question_id": 3486},
{"snippet": "numpy.gcd(x1, x2, /, signature, extobj, where=True)", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `where`.", "question_id": 3487},
{"snippet": "numpy.gcd(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `casting`.", "question_id": 3488},
{"snippet": "numpy.gcd(x1, x2, /, signature, extobj, order='K')", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `order`.", "question_id": 3489},
{"snippet": "numpy.gcd(x1, x2, /, signature, extobj, dtype=None)", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `dtype`.", "question_id": 3490},
{"snippet": "numpy.gcd(x1, x2, /, signature, extobj, subok=True)", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `subok`.", "question_id": 3491},
{"snippet": "numpy.gcd(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 3492},
{"snippet": "numpy.gcd(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 3493},
{"snippet": "numpy.gcd(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 3494},
{"snippet": "numpy.gcd(x1, x2, /, signature)", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`.", "question_id": 3495},
{"snippet": "numpy.gcd(x1, x2, /, signature, out=None)", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `out`.", "question_id": 3496},
{"snippet": "numpy.gcd(x1, x2, /, signature, where=True)", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `where`.", "question_id": 3497},
{"snippet": "numpy.gcd(x1, x2, /, signature, casting='same_kind')", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `casting`.", "question_id": 3498},
{"snippet": "numpy.gcd(x1, x2, /, signature, order='K')", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `order`.", "question_id": 3499},
{"snippet": "numpy.gcd(x1, x2, /, signature, dtype=None)", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `dtype`.", "question_id": 3500},
{"snippet": "numpy.gcd(x1, x2, /, signature, subok=True)", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `subok`.", "question_id": 3501},
{"snippet": "numpy.gcd(x1, x2, /, signature, out=None, where=True)", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `out`, `where`.", "question_id": 3502},
{"snippet": "numpy.gcd(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `out`, `casting`.", "question_id": 3503},
{"snippet": "numpy.gcd(x1, x2, /, signature, out=None, order='K')", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `out`, `order`.", "question_id": 3504},
{"snippet": "ma.masked_array.torecords()", "intent": "Transforms a masked array into a flexible-type array .", "question_id": 3505},
{"snippet": "polynomial.chebyshev.Chebyshev.identity()", "intent": "Identity function .", "question_id": 3506},
{"snippet": "polynomial.chebyshev.Chebyshev.identity(domain=None)", "intent": "Identity function . With arguments `domain`.", "question_id": 3507},
{"snippet": "polynomial.chebyshev.Chebyshev.identity(window=None)", "intent": "Identity function . With arguments `window`.", "question_id": 3508},
{"snippet": "polynomial.chebyshev.Chebyshev.identity(domain=None, window=None)", "intent": "Identity function . With arguments `domain`, `window`.", "question_id": 3509},
{"snippet": "char.chararray.setflags()", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively .", "question_id": 3510},
{"snippet": "char.chararray.setflags(write=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`.", "question_id": 3511},
{"snippet": "char.chararray.setflags(align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`.", "question_id": 3512},
{"snippet": "char.chararray.setflags(uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `uic`.", "question_id": 3513},
{"snippet": "char.chararray.setflags(write=None, align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`.", "question_id": 3514},
{"snippet": "char.chararray.setflags(write=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `uic`.", "question_id": 3515},
{"snippet": "char.chararray.setflags(align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`, `uic`.", "question_id": 3516},
{"snippet": "char.chararray.setflags(write=None, align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`, `uic`.", "question_id": 3517},
{"snippet": "dtype.name", "intent": "A bit-width name for this data-type.", "question_id": 3518},
{"snippet": "numpy.issubclass_(arg1, arg2)", "intent": "Determine if a class is a subclass of a second class . With arguments `arg1`, `arg2`.", "question_id": 3519},
{"snippet": "ma.resize(x, new_shape)", "intent": "Return a new masked array with the specified size and shape . The new array is filled with repeated copies of `x` ( in the order that the data are stored in memory ) . With arguments `new_shape`.", "question_id": 3520},
{"snippet": "ma.expand_dims(a, axis)", "intent": "Expand the shape of an array . Insert `a` new `axis` that will appear at the axis position in the expanded array shape .", "question_id": 3521},
{"snippet": "record.imag", "intent": "The imaginary part of the scalar.", "question_id": 3522},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.is_cached()", "intent": "Returns True if the class loaded from the cache file", "question_id": 3523},
{"snippet": "polynomial.hermite.hermadd(c1, c2)", "intent": "Add one Hermite series to another . Returns the sum of two Hermite series `c1` + `c2` .", "question_id": 3524},
{"snippet": "numpy.vstack(tup)", "intent": "Stack arrays in sequence vertically ( row wise ) . With arguments `tup`.", "question_id": 3525},
{"snippet": "polynomial.chebyshev.chebgauss(deg)", "intent": "Gauss-Chebyshev quadrature . These sample points and weights will correctly integrate polynomials of degree \\ ( 2 * `deg` - 1\\ ) or less over the interval \\ ( [ -1 , 1 ] \\ ) with the weight function \\ ( f ( x ) = 1/\\sqrt { 1 - x^2 } \\ ) .", "question_id": 3526},
{"snippet": "polynomial.hermite.hermline(off, scl)", "intent": "Hermite series whose graph is a straight line . With arguments `off`, `scl`.", "question_id": 3527},
{"snippet": "chararray.itemset(*args)", "intent": "Insert scalar into an array ( scalar is cast to array \u2019 s dtype , if possible ) With arguments `*args`.", "question_id": 3528},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_get_til(names, keyisfalse)", "intent": "same as feature_implies_c ( ) but stop collecting implied features when feature \u2019 s option that provided through parameter \u2018 `keyisfalse` \u2019 is False , also sorting the returned features . With arguments `names`.", "question_id": 3529},
{"snippet": "core.records.fromfile(fd)", "intent": "Create an array from binary file data With arguments `fd`.", "question_id": 3530},
{"snippet": "core.records.fromfile(fd, dtype=None)", "intent": "Create an array from binary file data With arguments `fd`, `dtype`.", "question_id": 3531},
{"snippet": "core.records.fromfile(fd, shape=None)", "intent": "Create an array from binary file data With arguments `fd`, `shape`.", "question_id": 3532},
{"snippet": "core.records.fromfile(fd, offset=0)", "intent": "Create an array from binary file data With arguments `fd`, `offset`.", "question_id": 3533},
{"snippet": "core.records.fromfile(fd, formats=None)", "intent": "Create an array from binary file data With arguments `fd`, `formats`.", "question_id": 3534},
{"snippet": "core.records.fromfile(fd, names=None)", "intent": "Create an array from binary file data With arguments `fd`, `names`.", "question_id": 3535},
{"snippet": "core.records.fromfile(fd, titles=None)", "intent": "Create an array from binary file data With arguments `fd`, `titles`.", "question_id": 3536},
{"snippet": "core.records.fromfile(fd, aligned=False)", "intent": "Create an array from binary file data With arguments `fd`, `aligned`.", "question_id": 3537},
{"snippet": "core.records.fromfile(fd, byteorder=None)", "intent": "Create an array from binary file data With arguments `fd`, `byteorder`.", "question_id": 3538},
{"snippet": "core.records.fromfile(fd, dtype=None, shape=None)", "intent": "Create an array from binary file data With arguments `fd`, `dtype`, `shape`.", "question_id": 3539},
{"snippet": "polynomial.polynomial.Polynomial.fit(x, y, deg)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`.", "question_id": 3540},
{"snippet": "polynomial.polynomial.Polynomial.fit(x, y, deg, domain=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`.", "question_id": 3541},
{"snippet": "polynomial.polynomial.Polynomial.fit(x, y, deg, rcond=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `rcond`.", "question_id": 3542},
{"snippet": "polynomial.polynomial.Polynomial.fit(x, y, deg, full=False)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `full`.", "question_id": 3543},
{"snippet": "polynomial.polynomial.Polynomial.fit(x, y, deg, w=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `w`.", "question_id": 3544},
{"snippet": "polynomial.polynomial.Polynomial.fit(x, y, deg, window=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `window`.", "question_id": 3545},
{"snippet": "polynomial.polynomial.Polynomial.fit(x, y, deg, domain=None, rcond=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `rcond`.", "question_id": 3546},
{"snippet": "polynomial.polynomial.Polynomial.fit(x, y, deg, domain=None, full=False)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `full`.", "question_id": 3547},
{"snippet": "polynomial.polynomial.Polynomial.fit(x, y, deg, domain=None, w=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `w`.", "question_id": 3548},
{"snippet": "polynomial.polynomial.Polynomial.fit(x, y, deg, domain=None, window=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `window`.", "question_id": 3549},
{"snippet": "char.chararray.translate(table)", "intent": "For each element in self , return a copy of the string where all characters occurring in the optional argument `deletechars` are removed , and the remaining characters have been mapped through the given translation `table` .", "question_id": 3550},
{"snippet": "char.chararray.translate(table, deletechars=None)", "intent": "For each element in self , return a copy of the string where all characters occurring in the optional argument `deletechars` are removed , and the remaining characters have been mapped through the given translation `table` .", "question_id": 3551},
{"snippet": "ma.MaskedArray.__mul__(other)", "intent": "Multiply self by `other` , and return a new masked array .", "question_id": 3552},
{"snippet": "fft.rfft(a)", "intent": "Compute the one-dimensional discrete Fourier Transform for real input . This function computes the one-dimensional n-point discrete Fourier Transform ( DFT ) of `a` real-valued array by means of an efficient algorithm called the Fast Fourier Transform ( FFT ) .", "question_id": 3553},
{"snippet": "fft.rfft(a, n=None)", "intent": "Compute the one-dimensional discrete Fourier Transform for real input . This function computes the one-dimensional n-point discrete Fourier Transform ( DFT ) of `a` real-valued array by means of an efficient algorithm called the Fast Fourier Transform ( FFT ) . If `n` is even , A [ -1 ] contains the term representing both positive and negative Nyquist frequency ( +fs/2 and -fs/2 ) , and must also be purely real .", "question_id": 3554},
{"snippet": "fft.rfft(a, axis=- 1)", "intent": "Compute the one-dimensional discrete Fourier Transform for real input . This function computes the one-dimensional n-point discrete Fourier Transform ( DFT ) of `a` real-valued array by means of an efficient algorithm called the Fast Fourier Transform ( FFT ) . This function does not compute the negative frequency terms , and the length of the transformed `axis` of the output is therefore n//2 + 1 .", "question_id": 3555},
{"snippet": "fft.rfft(a, norm=None)", "intent": "Compute the one-dimensional discrete Fourier Transform for real input . This function computes the one-dimensional n-point discrete Fourier Transform ( DFT ) of `a` real-valued array by means of an efficient algorithm called the Fast Fourier Transform ( FFT ) . With arguments `norm`.", "question_id": 3556},
{"snippet": "fft.rfft(a, n=None, axis=- 1)", "intent": "Compute the one-dimensional discrete Fourier Transform for real input . This function computes the one-dimensional n-point discrete Fourier Transform ( DFT ) of `a` real-valued array by means of an efficient algorithm called the Fast Fourier Transform ( FFT ) . If `n` is even , A [ -1 ] contains the term representing both positive and negative Nyquist frequency ( +fs/2 and -fs/2 ) , and must also be purely real . This function does not compute the negative frequency terms , and the length of the transformed `axis` of the output is therefore n//2 + 1 .", "question_id": 3557},
{"snippet": "fft.rfft(a, n=None, norm=None)", "intent": "Compute the one-dimensional discrete Fourier Transform for real input . This function computes the one-dimensional n-point discrete Fourier Transform ( DFT ) of `a` real-valued array by means of an efficient algorithm called the Fast Fourier Transform ( FFT ) . If `n` is even , A [ -1 ] contains the term representing both positive and negative Nyquist frequency ( +fs/2 and -fs/2 ) , and must also be purely real . With arguments `norm`.", "question_id": 3558},
{"snippet": "fft.rfft(a, axis=- 1, norm=None)", "intent": "Compute the one-dimensional discrete Fourier Transform for real input . This function computes the one-dimensional n-point discrete Fourier Transform ( DFT ) of `a` real-valued array by means of an efficient algorithm called the Fast Fourier Transform ( FFT ) . This function does not compute the negative frequency terms , and the length of the transformed `axis` of the output is therefore n//2 + 1 . With arguments `norm`.", "question_id": 3559},
{"snippet": "fft.rfft(a, n=None, axis=- 1, norm=None)", "intent": "Compute the one-dimensional discrete Fourier Transform for real input . This function computes the one-dimensional n-point discrete Fourier Transform ( DFT ) of `a` real-valued array by means of an efficient algorithm called the Fast Fourier Transform ( FFT ) . If `n` is even , A [ -1 ] contains the term representing both positive and negative Nyquist frequency ( +fs/2 and -fs/2 ) , and must also be purely real . This function does not compute the negative frequency terms , and the length of the transformed `axis` of the output is therefore n//2 + 1 . With arguments `norm`.", "question_id": 3560},
{"snippet": "memmap.astype(dtype)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`.", "question_id": 3561},
{"snippet": "memmap.astype(dtype, order='K')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`.", "question_id": 3562},
{"snippet": "memmap.astype(dtype, casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`.", "question_id": 3563},
{"snippet": "memmap.astype(dtype, subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `subok`.", "question_id": 3564},
{"snippet": "memmap.astype(dtype, copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `copy`.", "question_id": 3565},
{"snippet": "memmap.astype(dtype, order='K', casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `casting`.", "question_id": 3566},
{"snippet": "memmap.astype(dtype, order='K', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `subok`.", "question_id": 3567},
{"snippet": "memmap.astype(dtype, order='K', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `copy`.", "question_id": 3568},
{"snippet": "memmap.astype(dtype, casting='unsafe', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `subok`.", "question_id": 3569},
{"snippet": "memmap.astype(dtype, casting='unsafe', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `copy`.", "question_id": 3570},
{"snippet": "matrix.imag", "intent": "The imaginary part of the array.", "question_id": 3571},
{"snippet": "matrix.getfield(dtype)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements .", "question_id": 3572},
{"snippet": "matrix.getfield(dtype, offset=0)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements . The values in the view are determined by the given type and the `offset` into the current array in bytes .", "question_id": 3573},
{"snippet": "matrix.nonzero()", "intent": "Return the indices of the elements that are non-zero .", "question_id": 3574},
{"snippet": "char.chararray.argmax()", "intent": "Return indices of the maximum values along the given `axis` .", "question_id": 3575},
{"snippet": "char.chararray.argmax(axis=None)", "intent": "Return indices of the maximum values along the given `axis` .", "question_id": 3576},
{"snippet": "char.chararray.argmax(out=None)", "intent": "Return indices of the maximum values along the given `axis` . With arguments `out`.", "question_id": 3577},
{"snippet": "char.chararray.argmax(axis=None, out=None)", "intent": "Return indices of the maximum values along the given `axis` . With arguments `out`.", "question_id": 3578},
{"snippet": "ma.masked_array.sort()", "intent": "Sort the array , in-place", "question_id": 3579},
{"snippet": "ma.masked_array.sort(axis=- 1)", "intent": "Sort the array , in-place With arguments `axis`.", "question_id": 3580},
{"snippet": "ma.masked_array.sort(kind=None)", "intent": "Sort the array , in-place With arguments `kind`.", "question_id": 3581},
{"snippet": "ma.masked_array.sort(order=None)", "intent": "Sort the array , in-place With arguments `order`.", "question_id": 3582},
{"snippet": "ma.masked_array.sort(endwith=True)", "intent": "Sort the array , in-place With arguments `endwith`.", "question_id": 3583},
{"snippet": "ma.masked_array.sort(fill_value=None)", "intent": "Sort the array , in-place With arguments `fill_value`.", "question_id": 3584},
{"snippet": "ma.masked_array.sort(axis=- 1, kind=None)", "intent": "Sort the array , in-place With arguments `axis`, `kind`.", "question_id": 3585},
{"snippet": "ma.masked_array.sort(axis=- 1, order=None)", "intent": "Sort the array , in-place With arguments `axis`, `order`.", "question_id": 3586},
{"snippet": "ma.masked_array.sort(axis=- 1, endwith=True)", "intent": "Sort the array , in-place With arguments `axis`, `endwith`.", "question_id": 3587},
{"snippet": "ma.masked_array.sort(axis=- 1, fill_value=None)", "intent": "Sort the array , in-place With arguments `axis`, `fill_value`.", "question_id": 3588},
{"snippet": "polynomial.legendre.Legendre.identity()", "intent": "Identity function .", "question_id": 3589},
{"snippet": "polynomial.legendre.Legendre.identity(domain=None)", "intent": "Identity function . With arguments `domain`.", "question_id": 3590},
{"snippet": "polynomial.legendre.Legendre.identity(window=None)", "intent": "Identity function . With arguments `window`.", "question_id": 3591},
{"snippet": "polynomial.legendre.Legendre.identity(domain=None, window=None)", "intent": "Identity function . With arguments `domain`, `window`.", "question_id": 3592},
{"snippet": "memmap.ctypes", "intent": "An object to simplify the interaction of the array with the ctypes module.", "question_id": 3593},
{"snippet": "_ctypes.data", "intent": "A pointer to the memory area of the array as a Python integer.", "question_id": 3594},
{"snippet": "_ctypes.shape", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the C-integer corresponding to dtype('p') on this platform.", "question_id": 3595},
{"snippet": "_ctypes.strides", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the same as for the shape attribute.", "question_id": 3596},
{"snippet": "_ctypes.data_as(obj)", "intent": "Return the data pointer cast to a particular c-types object . With arguments `obj`.", "question_id": 3597},
{"snippet": "_ctypes.shape_as(obj)", "intent": "Return the shape tuple as an array of some other c-types type . With arguments `obj`.", "question_id": 3598},
{"snippet": "_ctypes.strides_as(obj)", "intent": "Return the strides tuple as an array of some other c-types type . With arguments `obj`.", "question_id": 3599},
{"snippet": "record.cumprod()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 3600},
{"snippet": "random.Generator.integers(low)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) , or if endpoint=True , low ( inclusive ) to high ( inclusive ) .", "question_id": 3601},
{"snippet": "random.Generator.integers(low, high=None)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) , or if endpoint=True , low ( inclusive ) to high ( inclusive ) .", "question_id": 3602},
{"snippet": "random.Generator.integers(low, size=None)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) , or if endpoint=True , low ( inclusive ) to high ( inclusive ) . With arguments `size`.", "question_id": 3603},
{"snippet": "random.Generator.integers(low, dtype=np.int64)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) , or if endpoint=True , low ( inclusive ) to high ( inclusive ) . Return random integers from the \u201c discrete uniform \u201d distribution of the specified `dtype` .", "question_id": 3604},
{"snippet": "random.Generator.integers(low, endpoint=False)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) , or if endpoint=True , low ( inclusive ) to high ( inclusive ) . With arguments `endpoint`.", "question_id": 3605},
{"snippet": "random.Generator.integers(low, high=None, size=None)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) , or if endpoint=True , low ( inclusive ) to high ( inclusive ) . With arguments `size`.", "question_id": 3606},
{"snippet": "random.Generator.integers(low, high=None, dtype=np.int64)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) , or if endpoint=True , low ( inclusive ) to high ( inclusive ) . Return random integers from the \u201c discrete uniform \u201d distribution of the specified `dtype` .", "question_id": 3607},
{"snippet": "random.Generator.integers(low, high=None, endpoint=False)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) , or if endpoint=True , low ( inclusive ) to high ( inclusive ) . With arguments `endpoint`.", "question_id": 3608},
{"snippet": "random.Generator.integers(low, size=None, dtype=np.int64)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) , or if endpoint=True , low ( inclusive ) to high ( inclusive ) . Return random integers from the \u201c discrete uniform \u201d distribution of the specified `dtype` . With arguments `size`.", "question_id": 3609},
{"snippet": "random.Generator.integers(low, size=None, endpoint=False)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) , or if endpoint=True , low ( inclusive ) to high ( inclusive ) . With arguments `size`, `endpoint`.", "question_id": 3610},
{"snippet": "polynomial.chebyshev.chebvander2d(x, y, deg)", "intent": "Pseudo-Vandermonde matrix of given degrees . Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points ( `x` , `y` ) .", "question_id": 3611},
{"snippet": "numpy.zeros(shape)", "intent": "Return a new array of given `shape` and type , filled with zeros .", "question_id": 3612},
{"snippet": "numpy.zeros(shape, dtype=float)", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `dtype`.", "question_id": 3613},
{"snippet": "numpy.zeros(shape, order='C')", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `order`.", "question_id": 3614},
{"snippet": "numpy.zeros(shape, like=None)", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `like`.", "question_id": 3615},
{"snippet": "numpy.zeros(shape, dtype=float, order='C')", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `dtype`, `order`.", "question_id": 3616},
{"snippet": "numpy.zeros(shape, dtype=float, like=None)", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `dtype`, `like`.", "question_id": 3617},
{"snippet": "numpy.zeros(shape, order='C', like=None)", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `order`, `like`.", "question_id": 3618},
{"snippet": "numpy.zeros(shape, dtype=float, order='C', like=None)", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `dtype`, `order`, `like`.", "question_id": 3619},
{"snippet": "polynomial.hermite_e.HermiteE.degree()", "intent": "The degree of the series .", "question_id": 3620},
{"snippet": "polynomial.hermite_e.hermeline(off, scl)", "intent": "Hermite series whose graph is a straight line . With arguments `off`, `scl`.", "question_id": 3621},
{"snippet": "numpy.nonzero(a)", "intent": "Return the indices of the elements that are non-zero . Returns `a` tuple of arrays , one for each dimension of a , containing the indices of the non-zero elements in that dimension .", "question_id": 3622},
{"snippet": "polynomial.laguerre.Laguerre.__call__(arg)", "intent": "Call self as a function . With arguments `arg`.", "question_id": 3623},
{"snippet": "ma.MaskedArray.put(indices, values)", "intent": "Set storage-indexed locations to corresponding `values` . Sets self._data.flat [ n ] = values [ n ] for each n in `indices` .", "question_id": 3624},
{"snippet": "ma.MaskedArray.put(indices, values, mode='raise')", "intent": "Set storage-indexed locations to corresponding `values` . Sets self._data.flat [ n ] = values [ n ] for each n in `indices` . With arguments `mode`.", "question_id": 3625},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_detect(names)", "intent": "Return a list of CPU features that required to be detected sorted from the lowest to highest interest . With arguments `names`.", "question_id": 3626},
{"snippet": "testing.dec.deprecated()", "intent": "Filter deprecation warnings while running the test suite .", "question_id": 3627},
{"snippet": "testing.dec.deprecated(conditional=True)", "intent": "Filter deprecation warnings while running the test suite . With arguments `conditional`.", "question_id": 3628},
{"snippet": "fft.ifft2(a, - 1))", "intent": "Compute the 2-dimensional inverse discrete Fourier Transform . In other words , ifft2 ( fft2 ( `a` ) ) == a to within numerical accuracy . With arguments `- 1)`.", "question_id": 3629},
{"snippet": "fft.ifft2(a, - 1), s=None)", "intent": "Compute the 2-dimensional inverse discrete Fourier Transform . In other words , ifft2 ( fft2 ( `a` ) ) == a to within numerical accuracy . With arguments `- 1)`, `s`.", "question_id": 3630},
{"snippet": "fft.ifft2(a, - 1), axes=(- 2)", "intent": "Compute the 2-dimensional inverse discrete Fourier Transform . In other words , ifft2 ( fft2 ( `a` ) ) == a to within numerical accuracy . This function computes the inverse of the 2-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `- 1)`.", "question_id": 3631},
{"snippet": "fft.ifft2(a, - 1), norm=None)", "intent": "Compute the 2-dimensional inverse discrete Fourier Transform . In other words , ifft2 ( fft2 ( `a` ) ) == a to within numerical accuracy . With arguments `- 1)`, `norm`.", "question_id": 3632},
{"snippet": "fft.ifft2(a, - 1), s=None, axes=(- 2)", "intent": "Compute the 2-dimensional inverse discrete Fourier Transform . In other words , ifft2 ( fft2 ( `a` ) ) == a to within numerical accuracy . This function computes the inverse of the 2-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `- 1)`, `s`.", "question_id": 3633},
{"snippet": "fft.ifft2(a, - 1), s=None, norm=None)", "intent": "Compute the 2-dimensional inverse discrete Fourier Transform . In other words , ifft2 ( fft2 ( `a` ) ) == a to within numerical accuracy . With arguments `- 1)`, `s`, `norm`.", "question_id": 3634},
{"snippet": "fft.ifft2(a, - 1), axes=(- 2, norm=None)", "intent": "Compute the 2-dimensional inverse discrete Fourier Transform . In other words , ifft2 ( fft2 ( `a` ) ) == a to within numerical accuracy . This function computes the inverse of the 2-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `- 1)`, `norm`.", "question_id": 3635},
{"snippet": "fft.ifft2(a, - 1), s=None, axes=(- 2, norm=None)", "intent": "Compute the 2-dimensional inverse discrete Fourier Transform . In other words , ifft2 ( fft2 ( `a` ) ) == a to within numerical accuracy . This function computes the inverse of the 2-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `- 1)`, `s`, `norm`.", "question_id": 3636},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.dist_compile(sources, flags, **kwargs)", "intent": "Wrap CCompiler.compile ( ) With arguments `sources`, `flags`, `**kwargs`.", "question_id": 3637},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.dist_compile(sources, flags, **kwargs, ccompiler=None)", "intent": "Wrap CCompiler.compile ( ) With arguments `sources`, `flags`, `**kwargs`, `ccompiler`.", "question_id": 3638},
{"snippet": "polynomial.laguerre.lagvander2d(x, y, deg)", "intent": "Pseudo-Vandermonde matrix of given degrees . Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points ( `x` , `y` ) .", "question_id": 3639},
{"snippet": "polynomial.hermite.Hermite.cast(series)", "intent": "Convert `series` to series of this class .", "question_id": 3640},
{"snippet": "polynomial.hermite.Hermite.cast(series, domain=None)", "intent": "Convert `series` to series of this class . With arguments `domain`.", "question_id": 3641},
{"snippet": "polynomial.hermite.Hermite.cast(series, window=None)", "intent": "Convert `series` to series of this class . With arguments `window`.", "question_id": 3642},
{"snippet": "polynomial.hermite.Hermite.cast(series, domain=None, window=None)", "intent": "Convert `series` to series of this class . With arguments `domain`, `window`.", "question_id": 3643},
{"snippet": "distutils.ccompiler.CCompiler_customize(self, dist)", "intent": "Do any platform-specific customization of a compiler instance . With arguments `self`, `dist`.", "question_id": 3644},
{"snippet": "distutils.ccompiler.CCompiler_customize(self, dist, need_cxx=0)", "intent": "Do any platform-specific customization of a compiler instance . With arguments `self`, `dist`, `need_cxx`.", "question_id": 3645},
{"snippet": "ma.MaskType.choose()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 3646},
{"snippet": "matrix.getA1()", "intent": "Return self as a flattened ndarray .", "question_id": 3647},
{"snippet": "ndarray.any()", "intent": "Returns True if any of the elements of a evaluate to True .", "question_id": 3648},
{"snippet": "ndarray.any(axis=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`.", "question_id": 3649},
{"snippet": "ndarray.any(out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`.", "question_id": 3650},
{"snippet": "ndarray.any(keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `keepdims`.", "question_id": 3651},
{"snippet": "ndarray.any(where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `where`.", "question_id": 3652},
{"snippet": "ndarray.any(axis=None, out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `out`.", "question_id": 3653},
{"snippet": "ndarray.any(axis=None, keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `keepdims`.", "question_id": 3654},
{"snippet": "ndarray.any(axis=None, where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `where`.", "question_id": 3655},
{"snippet": "ndarray.any(out=None, keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`, `keepdims`.", "question_id": 3656},
{"snippet": "ndarray.any(out=None, where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`, `where`.", "question_id": 3657},
{"snippet": "polynomial.chebyshev.chebval(x, c)", "intent": "Evaluate a Chebyshev series at points `x` . If `c` is of length n + 1 , this function returns the value :", "question_id": 3658},
{"snippet": "polynomial.chebyshev.chebval(x, c, tensor=True)", "intent": "Evaluate a Chebyshev series at points `x` . If `c` is of length n + 1 , this function returns the value : If c is multidimensional , then the shape of the result depends on the value of `tensor` .", "question_id": 3659},
{"snippet": "ma.MaskedArray.__rdivmod__(value, /)", "intent": "Return divmod ( `value` , self ) . With arguments `/`.", "question_id": 3660},
{"snippet": "ndarray.__imod__(value, /)", "intent": "Return self % =value . With arguments `value`, `/`.", "question_id": 3661},
{"snippet": "ma.MaskType.view()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 3662},
{"snippet": "numpy.indices(dimensions)", "intent": "Return an array representing the indices of a grid . The output shape in the dense case is obtained by prepending the number of `dimensions` in front of the tuple of dimensions , i.e .", "question_id": 3663},
{"snippet": "numpy.indices(dimensions, dtype=<class 'int'>)", "intent": "Return an array representing the indices of a grid . The output shape in the dense case is obtained by prepending the number of `dimensions` in front of the tuple of dimensions , i.e . With arguments `dtype`.", "question_id": 3664},
{"snippet": "numpy.indices(dimensions, sparse=False)", "intent": "Return an array representing the indices of a grid . The output shape in the dense case is obtained by prepending the number of `dimensions` in front of the tuple of dimensions , i.e . If `sparse` is set to true , the grid will be returned in a sparse representation .", "question_id": 3665},
{"snippet": "numpy.indices(dimensions, dtype=<class 'int'>, sparse=False)", "intent": "Return an array representing the indices of a grid . The output shape in the dense case is obtained by prepending the number of `dimensions` in front of the tuple of dimensions , i.e . If `sparse` is set to true , the grid will be returned in a sparse representation . With arguments `dtype`.", "question_id": 3666},
{"snippet": "ma.MaskedArray.__and__(value, /)", "intent": "Return self & `value` . With arguments `/`.", "question_id": 3667},
{"snippet": "numpy.format_parser(formats, names, titles)", "intent": "Class to convert `formats` , `names` , `titles` description to a dtype .", "question_id": 3668},
{"snippet": "numpy.format_parser(formats, names, titles, aligned=False)", "intent": "Class to convert `formats` , `names` , `titles` description to a dtype . With arguments `aligned`.", "question_id": 3669},
{"snippet": "numpy.format_parser(formats, names, titles, byteorder=None)", "intent": "Class to convert `formats` , `names` , `titles` description to a dtype . With arguments `byteorder`.", "question_id": 3670},
{"snippet": "numpy.format_parser(formats, names, titles, aligned=False, byteorder=None)", "intent": "Class to convert `formats` , `names` , `titles` description to a dtype . With arguments `aligned`, `byteorder`.", "question_id": 3671},
{"snippet": "polynomial.chebyshev.chebval3d(x, y, z, c)", "intent": "Evaluate a 3-D Chebyshev series at points ( `x` , `y` , `z` ) . In either case , either x , y , and z or their elements must support multiplication and addition both with themselves and with the elements of `c` .", "question_id": 3672},
{"snippet": "numpy.ravel(a)", "intent": "Return `a` contiguous flattened array .", "question_id": 3673},
{"snippet": "numpy.ravel(a, order='C')", "intent": "Return `a` contiguous flattened array . In row-major , C-style `order` , in two dimensions , the row index varies the slowest , and the column index the quickest .", "question_id": 3674},
{"snippet": "char.strip(a)", "intent": "For each element in `a` , return a copy with the leading and trailing characters removed .", "question_id": 3675},
{"snippet": "char.strip(a, chars=None)", "intent": "For each element in `a` , return a copy with the leading and trailing characters removed . With arguments `chars`.", "question_id": 3676},
{"snippet": "ndarray.trace()", "intent": "Return the sum along diagonals of the array .", "question_id": 3677},
{"snippet": "ndarray.trace(offset=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`.", "question_id": 3678},
{"snippet": "ndarray.trace(axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `axis1`.", "question_id": 3679},
{"snippet": "ndarray.trace(axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `axis2`.", "question_id": 3680},
{"snippet": "ndarray.trace(dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `dtype`.", "question_id": 3681},
{"snippet": "ndarray.trace(out=None)", "intent": "Return the sum along diagonals of the array . With arguments `out`.", "question_id": 3682},
{"snippet": "ndarray.trace(offset=0, axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis1`.", "question_id": 3683},
{"snippet": "ndarray.trace(offset=0, axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis2`.", "question_id": 3684},
{"snippet": "ndarray.trace(offset=0, dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `dtype`.", "question_id": 3685},
{"snippet": "ndarray.trace(offset=0, out=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `out`.", "question_id": 3686},
{"snippet": "ufunc.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 3687},
{"snippet": "polynomial.hermite.hermfromroots(roots)", "intent": "Generate a Hermite series with given `roots` .", "question_id": 3688},
{"snippet": "ma.MaskedArray.all()", "intent": "Returns True if all elements evaluate to True .", "question_id": 3689},
{"snippet": "ma.MaskedArray.all(axis=None)", "intent": "Returns True if all elements evaluate to True . The output array is masked where all the values along the given `axis` are masked : if the output would have been a scalar and that all the values are masked , then the output is masked .", "question_id": 3690},
{"snippet": "ma.MaskedArray.all(out=None)", "intent": "Returns True if all elements evaluate to True . With arguments `out`.", "question_id": 3691},
{"snippet": "ma.MaskedArray.all(keepdims=<no value>)", "intent": "Returns True if all elements evaluate to True . With arguments `keepdims`.", "question_id": 3692},
{"snippet": "ma.MaskedArray.all(axis=None, out=None)", "intent": "Returns True if all elements evaluate to True . The output array is masked where all the values along the given `axis` are masked : if the output would have been a scalar and that all the values are masked , then the output is masked . With arguments `out`.", "question_id": 3693},
{"snippet": "ma.MaskedArray.all(axis=None, keepdims=<no value>)", "intent": "Returns True if all elements evaluate to True . The output array is masked where all the values along the given `axis` are masked : if the output would have been a scalar and that all the values are masked , then the output is masked . With arguments `keepdims`.", "question_id": 3694},
{"snippet": "ma.MaskedArray.all(out=None, keepdims=<no value>)", "intent": "Returns True if all elements evaluate to True . With arguments `out`, `keepdims`.", "question_id": 3695},
{"snippet": "ma.MaskedArray.all(axis=None, out=None, keepdims=<no value>)", "intent": "Returns True if all elements evaluate to True . The output array is masked where all the values along the given `axis` are masked : if the output would have been a scalar and that all the values are masked , then the output is masked . With arguments `out`, `keepdims`.", "question_id": 3696},
{"snippet": "char.chararray.transpose(*axes)", "intent": "Returns a view of the array with axes transposed . With arguments `*axes`.", "question_id": 3697},
{"snippet": "numpy.tril_indices(n)", "intent": "Return the indices for the lower-triangle of an ( `n` , `m` ) array .", "question_id": 3698},
{"snippet": "numpy.tril_indices(n, k=0)", "intent": "Return the indices for the lower-triangle of an ( `n` , `m` ) array . With arguments `k`.", "question_id": 3699},
{"snippet": "numpy.tril_indices(n, m=None)", "intent": "Return the indices for the lower-triangle of an ( `n` , `m` ) array .", "question_id": 3700},
{"snippet": "numpy.tril_indices(n, k=0, m=None)", "intent": "Return the indices for the lower-triangle of an ( `n` , `m` ) array . With arguments `k`.", "question_id": 3701},
{"snippet": "char.str_len(a)", "intent": "Return len ( `a` ) element-wise .", "question_id": 3702},
{"snippet": "numpy.iscomplexobj(x)", "intent": "Check for a complex type or an array of complex numbers . With arguments `x`.", "question_id": 3703},
{"snippet": "numpy.result_type(*arrays_and_dtypes)", "intent": "Returns the type that results from applying the NumPy type promotion rules to the arguments . With arguments `*arrays_and_dtypes`.", "question_id": 3704},
{"snippet": "matrix.min()", "intent": "Return the minimum value along an `axis` .", "question_id": 3705},
{"snippet": "matrix.min(axis=None)", "intent": "Return the minimum value along an `axis` .", "question_id": 3706},
{"snippet": "matrix.min(out=None)", "intent": "Return the minimum value along an `axis` . With arguments `out`.", "question_id": 3707},
{"snippet": "matrix.min(axis=None, out=None)", "intent": "Return the minimum value along an `axis` . With arguments `out`.", "question_id": 3708},
{"snippet": "char.chararray.index(sub)", "intent": "Like find , but raises ValueError when the substring is not found . With arguments `sub`.", "question_id": 3709},
{"snippet": "char.chararray.index(sub, start=0)", "intent": "Like find , but raises ValueError when the substring is not found . With arguments `sub`, `start`.", "question_id": 3710},
{"snippet": "char.chararray.index(sub, end=None)", "intent": "Like find , but raises ValueError when the substring is not found . With arguments `sub`, `end`.", "question_id": 3711},
{"snippet": "char.chararray.index(sub, start=0, end=None)", "intent": "Like find , but raises ValueError when the substring is not found . With arguments `sub`, `start`, `end`.", "question_id": 3712},
{"snippet": "ma.MaskedArray.__xor__(value, /)", "intent": "Return self^value . With arguments `value`, `/`.", "question_id": 3713},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_sorted(names)", "intent": "Sort a list of CPU features ordered by the lowest interest . With arguments `names`.", "question_id": 3714},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_sorted(names, reverse=False)", "intent": "Sort a list of CPU features ordered by the lowest interest . With arguments `names`, `reverse`.", "question_id": 3715},
{"snippet": "record.var()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 3716},
{"snippet": "numpy.lcm(x1, x2, /, signature, extobj)", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`.", "question_id": 3717},
{"snippet": "numpy.lcm(x1, x2, /, signature, extobj, out=None)", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`.", "question_id": 3718},
{"snippet": "numpy.lcm(x1, x2, /, signature, extobj, where=True)", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `where`.", "question_id": 3719},
{"snippet": "numpy.lcm(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `casting`.", "question_id": 3720},
{"snippet": "numpy.lcm(x1, x2, /, signature, extobj, order='K')", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `order`.", "question_id": 3721},
{"snippet": "numpy.lcm(x1, x2, /, signature, extobj, dtype=None)", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `dtype`.", "question_id": 3722},
{"snippet": "numpy.lcm(x1, x2, /, signature, extobj, subok=True)", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `subok`.", "question_id": 3723},
{"snippet": "numpy.lcm(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 3724},
{"snippet": "numpy.lcm(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 3725},
{"snippet": "numpy.lcm(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 3726},
{"snippet": "numpy.lcm(x1, x2, /, signature)", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`.", "question_id": 3727},
{"snippet": "numpy.lcm(x1, x2, /, signature, out=None)", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `out`.", "question_id": 3728},
{"snippet": "numpy.lcm(x1, x2, /, signature, where=True)", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `where`.", "question_id": 3729},
{"snippet": "numpy.lcm(x1, x2, /, signature, casting='same_kind')", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `casting`.", "question_id": 3730},
{"snippet": "numpy.lcm(x1, x2, /, signature, order='K')", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `order`.", "question_id": 3731},
{"snippet": "numpy.lcm(x1, x2, /, signature, dtype=None)", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `dtype`.", "question_id": 3732},
{"snippet": "numpy.lcm(x1, x2, /, signature, subok=True)", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `subok`.", "question_id": 3733},
{"snippet": "numpy.lcm(x1, x2, /, signature, out=None, where=True)", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `out`, `where`.", "question_id": 3734},
{"snippet": "numpy.lcm(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `out`, `casting`.", "question_id": 3735},
{"snippet": "numpy.lcm(x1, x2, /, signature, out=None, order='K')", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `out`, `order`.", "question_id": 3736},
{"snippet": "numpy.moveaxis(a, source, destination)", "intent": "Move axes of an array to new positions . With arguments `a`, `source`, `destination`.", "question_id": 3737},
{"snippet": "char.chararray.join(seq)", "intent": "Return a string which is the concatenation of the strings in the sequence `seq` .", "question_id": 3738},
{"snippet": "numpy.append(arr, values)", "intent": "Append `values` to the end of an array . With arguments `arr`.", "question_id": 3739},
{"snippet": "numpy.append(arr, values, axis=None)", "intent": "Append `values` to the end of an array . When `axis` is specified , values must have the correct shape . With arguments `arr`.", "question_id": 3740},
{"snippet": "ndarray.__mod__(value, /)", "intent": "Return self % `value` . With arguments `/`.", "question_id": 3741},
{"snippet": "ma.masked_array.searchsorted(v)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order .", "question_id": 3742},
{"snippet": "ma.masked_array.searchsorted(v, side='left')", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`.", "question_id": 3743},
{"snippet": "ma.masked_array.searchsorted(v, sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `sorter`.", "question_id": 3744},
{"snippet": "ma.masked_array.searchsorted(v, side='left', sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`, `sorter`.", "question_id": 3745},
{"snippet": "ma.MaskedArray.resize(newshape)", "intent": "This method is difficult to implement safely and may be deprecated in future releases of NumPy . With arguments `newshape`.", "question_id": 3746},
{"snippet": "ma.MaskedArray.resize(newshape, refcheck=True)", "intent": "This method is difficult to implement safely and may be deprecated in future releases of NumPy . With arguments `newshape`, `refcheck`.", "question_id": 3747},
{"snippet": "ma.MaskedArray.resize(newshape, order=False)", "intent": "This method is difficult to implement safely and may be deprecated in future releases of NumPy . With arguments `newshape`, `order`.", "question_id": 3748},
{"snippet": "ma.MaskedArray.resize(newshape, refcheck=True, order=False)", "intent": "This method is difficult to implement safely and may be deprecated in future releases of NumPy . With arguments `newshape`, `refcheck`, `order`.", "question_id": 3749},
{"snippet": "ma.arange(start, stop, step)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . When using a non-integer `step` , such as 0.1 , the results will often not be consistent .", "question_id": 3750},
{"snippet": "ma.arange(start, stop, step, dtype=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . When using a non-integer `step` , such as 0.1 , the results will often not be consistent . With arguments `dtype`.", "question_id": 3751},
{"snippet": "ma.arange(start, stop, step, like=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . When using a non-integer `step` , such as 0.1 , the results will often not be consistent . With arguments `like`.", "question_id": 3752},
{"snippet": "ma.arange(start, stop, step, dtype=None, like=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . When using a non-integer `step` , such as 0.1 , the results will often not be consistent . With arguments `dtype`, `like`.", "question_id": 3753},
{"snippet": "ma.arange(start, stop)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) .", "question_id": 3754},
{"snippet": "ma.arange(start, stop, dtype=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . With arguments `dtype`.", "question_id": 3755},
{"snippet": "ma.arange(start, stop, like=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . With arguments `like`.", "question_id": 3756},
{"snippet": "ma.arange(start, stop, dtype=None, like=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . With arguments `dtype`, `like`.", "question_id": 3757},
{"snippet": "ma.arange(start)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) .", "question_id": 3758},
{"snippet": "ma.arange(start, dtype=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . With arguments `dtype`.", "question_id": 3759},
{"snippet": "ma.arange(start, like=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . With arguments `like`.", "question_id": 3760},
{"snippet": "ma.arange(start, dtype=None, like=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . With arguments `dtype`, `like`.", "question_id": 3761},
{"snippet": "recarray.var()", "intent": "Returns the variance of the array elements , along given `axis` .", "question_id": 3762},
{"snippet": "recarray.var(axis=None)", "intent": "Returns the variance of the array elements , along given `axis` .", "question_id": 3763},
{"snippet": "recarray.var(dtype=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `dtype`.", "question_id": 3764},
{"snippet": "recarray.var(out=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `out`.", "question_id": 3765},
{"snippet": "recarray.var(ddof=0)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `ddof`.", "question_id": 3766},
{"snippet": "recarray.var(keepdims=False)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `keepdims`.", "question_id": 3767},
{"snippet": "recarray.var(where=True)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `where`.", "question_id": 3768},
{"snippet": "recarray.var(axis=None, dtype=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `dtype`.", "question_id": 3769},
{"snippet": "recarray.var(axis=None, out=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `out`.", "question_id": 3770},
{"snippet": "recarray.var(axis=None, ddof=0)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `ddof`.", "question_id": 3771},
{"snippet": "ma.squeeze(a)", "intent": "Remove axes of length one from `a` .", "question_id": 3772},
{"snippet": "ma.squeeze(a, axis=None)", "intent": "Remove axes of length one from `a` . With arguments `axis`.", "question_id": 3773},
{"snippet": "record.transpose()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 3774},
{"snippet": "matlib.zeros(shape)", "intent": "Return a matrix of given `shape` and type , filled with zeros .", "question_id": 3775},
{"snippet": "matlib.zeros(shape, dtype=None)", "intent": "Return a matrix of given `shape` and type , filled with zeros . With arguments `dtype`.", "question_id": 3776},
{"snippet": "matlib.zeros(shape, order='C')", "intent": "Return a matrix of given `shape` and type , filled with zeros . With arguments `order`.", "question_id": 3777},
{"snippet": "matlib.zeros(shape, dtype=None, order='C')", "intent": "Return a matrix of given `shape` and type , filled with zeros . With arguments `dtype`, `order`.", "question_id": 3778},
{"snippet": "recarray.fill(value)", "intent": "Fill the array with a scalar `value` .", "question_id": 3779},
{"snippet": "ma.mask_or(m1, m2)", "intent": "Combine two masks with the logical_or operator . The result may be a view on `m1` or `m2` if the other is nomask ( i.e .", "question_id": 3780},
{"snippet": "ma.mask_or(m1, m2, copy=False)", "intent": "Combine two masks with the logical_or operator . The result may be a view on `m1` or `m2` if the other is nomask ( i.e . With arguments `copy`.", "question_id": 3781},
{"snippet": "ma.mask_or(m1, m2, shrink=True)", "intent": "Combine two masks with the logical_or operator . The result may be a view on `m1` or `m2` if the other is nomask ( i.e . With arguments `shrink`.", "question_id": 3782},
{"snippet": "ma.mask_or(m1, m2, copy=False, shrink=True)", "intent": "Combine two masks with the logical_or operator . The result may be a view on `m1` or `m2` if the other is nomask ( i.e . With arguments `copy`, `shrink`.", "question_id": 3783},
{"snippet": "char.chararray.put(indices, values)", "intent": "Set a.flat [ n ] = `values` [ n ] for all n in `indices` .", "question_id": 3784},
{"snippet": "char.chararray.put(indices, values, mode='raise')", "intent": "Set a.flat [ n ] = `values` [ n ] for all n in `indices` . With arguments `mode`.", "question_id": 3785},
{"snippet": "numpy.kron(a, b)", "intent": "Kronecker product of two arrays . Computes the Kronecker product , `a` composite array made of blocks of the second array scaled by the first . The function assumes that the number of dimensions of a and `b` are the same , if necessary prepending the smallest with ones .", "question_id": 3786},
{"snippet": "char.chararray.swapaxes(axis1, axis2)", "intent": "Return a view of the array with `axis1` and `axis2` interchanged .", "question_id": 3787},
{"snippet": "polynomial.polynomial.Polynomial.linspace()", "intent": "Return x , y values at equally spaced points in `domain` .", "question_id": 3788},
{"snippet": "polynomial.polynomial.Polynomial.linspace(n=100)", "intent": "Return x , y values at equally spaced points in `domain` . Returns the x , y values at `n` linearly spaced points across the domain .", "question_id": 3789},
{"snippet": "polynomial.polynomial.Polynomial.linspace(domain=None)", "intent": "Return x , y values at equally spaced points in `domain` .", "question_id": 3790},
{"snippet": "polynomial.polynomial.Polynomial.linspace(n=100, domain=None)", "intent": "Return x , y values at equally spaced points in `domain` . Returns the x , y values at `n` linearly spaced points across the domain .", "question_id": 3791},
{"snippet": "ufunc.nargs", "intent": "The number of arguments.", "question_id": 3792},
{"snippet": "numpy.bmat(obj)", "intent": "Build a matrix object from a string , nested sequence , or array . With arguments `obj`.", "question_id": 3793},
{"snippet": "numpy.bmat(obj, ldict=None)", "intent": "Build a matrix object from a string , nested sequence , or array . With arguments `obj`, `ldict`.", "question_id": 3794},
{"snippet": "numpy.bmat(obj, gdict=None)", "intent": "Build a matrix object from a string , nested sequence , or array . With arguments `obj`, `gdict`.", "question_id": 3795},
{"snippet": "numpy.bmat(obj, ldict=None, gdict=None)", "intent": "Build a matrix object from a string , nested sequence , or array . With arguments `obj`, `ldict`, `gdict`.", "question_id": 3796},
{"snippet": "char.chararray.round()", "intent": "Return a with each element rounded to the given number of `decimals` .", "question_id": 3797},
{"snippet": "char.chararray.round(decimals=0)", "intent": "Return a with each element rounded to the given number of `decimals` .", "question_id": 3798},
{"snippet": "char.chararray.round(out=None)", "intent": "Return a with each element rounded to the given number of `decimals` . With arguments `out`.", "question_id": 3799},
{"snippet": "char.chararray.round(decimals=0, out=None)", "intent": "Return a with each element rounded to the given number of `decimals` . With arguments `out`.", "question_id": 3800},
{"snippet": "numpy.iscomplex(x)", "intent": "Returns a bool array , where True if input element is complex . With arguments `x`.", "question_id": 3801},
{"snippet": "polynomial.hermite.Hermite.roots()", "intent": "Return the roots of the series polynomial .", "question_id": 3802},
{"snippet": "ndarray.__itruediv__(value, /)", "intent": "Return self/=value . With arguments `value`, `/`.", "question_id": 3803},
{"snippet": "numpy.fmod(x1, x2, /, signature, extobj)", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `extobj`.", "question_id": 3804},
{"snippet": "numpy.fmod(x1, x2, /, signature, extobj, out=None)", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 3805},
{"snippet": "numpy.fmod(x1, x2, /, signature, extobj, where=True)", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 3806},
{"snippet": "numpy.fmod(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 3807},
{"snippet": "numpy.fmod(x1, x2, /, signature, extobj, order='K')", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 3808},
{"snippet": "numpy.fmod(x1, x2, /, signature, extobj, dtype=None)", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 3809},
{"snippet": "numpy.fmod(x1, x2, /, signature, extobj, subok=True)", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 3810},
{"snippet": "numpy.fmod(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 3811},
{"snippet": "numpy.fmod(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 3812},
{"snippet": "numpy.fmod(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 3813},
{"snippet": "numpy.fmod(x1, x2, /, signature)", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`.", "question_id": 3814},
{"snippet": "numpy.fmod(x1, x2, /, signature, out=None)", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `out`.", "question_id": 3815},
{"snippet": "numpy.fmod(x1, x2, /, signature, where=True)", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `where`.", "question_id": 3816},
{"snippet": "numpy.fmod(x1, x2, /, signature, casting='same_kind')", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `casting`.", "question_id": 3817},
{"snippet": "numpy.fmod(x1, x2, /, signature, order='K')", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `order`.", "question_id": 3818},
{"snippet": "numpy.fmod(x1, x2, /, signature, dtype=None)", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `dtype`.", "question_id": 3819},
{"snippet": "numpy.fmod(x1, x2, /, signature, subok=True)", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `subok`.", "question_id": 3820},
{"snippet": "numpy.fmod(x1, x2, /, signature, out=None, where=True)", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `out`, `where`.", "question_id": 3821},
{"snippet": "numpy.fmod(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 3822},
{"snippet": "numpy.fmod(x1, x2, /, signature, out=None, order='K')", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `out`, `order`.", "question_id": 3823},
{"snippet": "dtype.char", "intent": "A unique character code for each of the 21 different built-in types.", "question_id": 3824},
{"snippet": "ma.MaskedArray.anom()", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` .", "question_id": 3825},
{"snippet": "ma.MaskedArray.anom(axis=None)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` .", "question_id": 3826},
{"snippet": "ma.MaskedArray.anom(dtype=None)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . With arguments `dtype`.", "question_id": 3827},
{"snippet": "ma.MaskedArray.anom(axis=None, dtype=None)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . With arguments `dtype`.", "question_id": 3828},
{"snippet": "ma.cumsum(self)", "intent": "Return the cumulative sum of the array elements over the given `axis` . With arguments `self`.", "question_id": 3829},
{"snippet": "ma.cumsum(self, axis=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . With arguments `self`.", "question_id": 3830},
{"snippet": "ma.cumsum(self, dtype=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . With arguments `self`, `dtype`.", "question_id": 3831},
{"snippet": "ma.cumsum(self, out=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . The mask is lost if `out` is not a valid ma.MaskedArray ! With arguments `self`.", "question_id": 3832},
{"snippet": "ma.cumsum(self, axis=None, dtype=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . With arguments `self`, `dtype`.", "question_id": 3833},
{"snippet": "ma.cumsum(self, axis=None, out=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . The mask is lost if `out` is not a valid ma.MaskedArray ! With arguments `self`.", "question_id": 3834},
{"snippet": "ma.cumsum(self, dtype=None, out=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . The mask is lost if `out` is not a valid ma.MaskedArray ! With arguments `self`, `dtype`.", "question_id": 3835},
{"snippet": "ma.cumsum(self, axis=None, dtype=None, out=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . The mask is lost if `out` is not a valid ma.MaskedArray ! With arguments `self`, `dtype`.", "question_id": 3836},
{"snippet": "fft.ifftshift(x)", "intent": "The inverse of fftshift . Although identical for even-length `x` , the functions differ by one sample for odd-length x .", "question_id": 3837},
{"snippet": "fft.ifftshift(x, axes=None)", "intent": "The inverse of fftshift . Although identical for even-length `x` , the functions differ by one sample for odd-length x . With arguments `axes`.", "question_id": 3838},
{"snippet": "polynomial.hermite_e.HermiteE.fit(x, y, deg)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`.", "question_id": 3839},
{"snippet": "polynomial.hermite_e.HermiteE.fit(x, y, deg, domain=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`.", "question_id": 3840},
{"snippet": "polynomial.hermite_e.HermiteE.fit(x, y, deg, rcond=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `rcond`.", "question_id": 3841},
{"snippet": "polynomial.hermite_e.HermiteE.fit(x, y, deg, full=False)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `full`.", "question_id": 3842},
{"snippet": "polynomial.hermite_e.HermiteE.fit(x, y, deg, w=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `w`.", "question_id": 3843},
{"snippet": "polynomial.hermite_e.HermiteE.fit(x, y, deg, window=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `window`.", "question_id": 3844},
{"snippet": "polynomial.hermite_e.HermiteE.fit(x, y, deg, domain=None, rcond=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `rcond`.", "question_id": 3845},
{"snippet": "polynomial.hermite_e.HermiteE.fit(x, y, deg, domain=None, full=False)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `full`.", "question_id": 3846},
{"snippet": "polynomial.hermite_e.HermiteE.fit(x, y, deg, domain=None, w=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `w`.", "question_id": 3847},
{"snippet": "polynomial.hermite_e.HermiteE.fit(x, y, deg, domain=None, window=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `window`.", "question_id": 3848},
{"snippet": "ma.MaskedArray.__le__(value, /)", "intent": "Return self < =value . With arguments `value`, `/`.", "question_id": 3849},
{"snippet": "chararray.item(*args)", "intent": "Copy an element of an array to a standard Python scalar and return it . With arguments `*args`.", "question_id": 3850},
{"snippet": "matrix.var()", "intent": "Returns the variance of the matrix elements , along the given `axis` .", "question_id": 3851},
{"snippet": "matrix.var(axis=None)", "intent": "Returns the variance of the matrix elements , along the given `axis` .", "question_id": 3852},
{"snippet": "matrix.var(dtype=None)", "intent": "Returns the variance of the matrix elements , along the given `axis` . With arguments `dtype`.", "question_id": 3853},
{"snippet": "matrix.var(out=None)", "intent": "Returns the variance of the matrix elements , along the given `axis` . With arguments `out`.", "question_id": 3854},
{"snippet": "matrix.var(ddof=0)", "intent": "Returns the variance of the matrix elements , along the given `axis` . With arguments `ddof`.", "question_id": 3855},
{"snippet": "matrix.var(axis=None, dtype=None)", "intent": "Returns the variance of the matrix elements , along the given `axis` . With arguments `dtype`.", "question_id": 3856},
{"snippet": "matrix.var(axis=None, out=None)", "intent": "Returns the variance of the matrix elements , along the given `axis` . With arguments `out`.", "question_id": 3857},
{"snippet": "matrix.var(axis=None, ddof=0)", "intent": "Returns the variance of the matrix elements , along the given `axis` . With arguments `ddof`.", "question_id": 3858},
{"snippet": "matrix.var(dtype=None, out=None)", "intent": "Returns the variance of the matrix elements , along the given `axis` . With arguments `dtype`, `out`.", "question_id": 3859},
{"snippet": "matrix.var(dtype=None, ddof=0)", "intent": "Returns the variance of the matrix elements , along the given `axis` . With arguments `dtype`, `ddof`.", "question_id": 3860},
{"snippet": "ndarray.ndim", "intent": "Number of array dimensions.", "question_id": 3861},
{"snippet": "testing.run_module_suite()", "intent": "Run a test module .", "question_id": 3862},
{"snippet": "testing.run_module_suite(file_to_run=None)", "intent": "Run a test module . Equivalent to calling $ nosetests < `argv` > < `file_to_run` > from the command line", "question_id": 3863},
{"snippet": "testing.run_module_suite(argv=None)", "intent": "Run a test module . Equivalent to calling $ nosetests < `argv` > < `file_to_run` > from the command line", "question_id": 3864},
{"snippet": "testing.run_module_suite(file_to_run=None, argv=None)", "intent": "Run a test module . Equivalent to calling $ nosetests < `argv` > < `file_to_run` > from the command line", "question_id": 3865},
{"snippet": "ma.isarray(x)", "intent": "Test whether input is an instance of MaskedArray . This function returns True if `x` is an instance of MaskedArray and returns False otherwise .", "question_id": 3866},
{"snippet": "testing.suppress_warnings.record()", "intent": "Append a new recording filter or apply it if the state is entered .", "question_id": 3867},
{"snippet": "testing.suppress_warnings.record(category=<class 'Warning'>)", "intent": "Append a new recording filter or apply it if the state is entered . With arguments `category`.", "question_id": 3868},
{"snippet": "testing.suppress_warnings.record(message='')", "intent": "Append a new recording filter or apply it if the state is entered . With arguments `message`.", "question_id": 3869},
{"snippet": "testing.suppress_warnings.record(module=None)", "intent": "Append a new recording filter or apply it if the state is entered . With arguments `module`.", "question_id": 3870},
{"snippet": "testing.suppress_warnings.record(category=<class 'Warning'>, message='')", "intent": "Append a new recording filter or apply it if the state is entered . With arguments `category`, `message`.", "question_id": 3871},
{"snippet": "testing.suppress_warnings.record(category=<class 'Warning'>, module=None)", "intent": "Append a new recording filter or apply it if the state is entered . With arguments `category`, `module`.", "question_id": 3872},
{"snippet": "testing.suppress_warnings.record(message='', module=None)", "intent": "Append a new recording filter or apply it if the state is entered . With arguments `message`, `module`.", "question_id": 3873},
{"snippet": "testing.suppress_warnings.record(category=<class 'Warning'>, message='', module=None)", "intent": "Append a new recording filter or apply it if the state is entered . With arguments `category`, `message`, `module`.", "question_id": 3874},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_is_exist(name)", "intent": "Returns True if a certain feature is exist and covered within _Config.conf_features . With arguments `name`.", "question_id": 3875},
{"snippet": "numpy.unpackbits(a)", "intent": "Unpacks elements of `a` uint8 array into a binary-valued output array .", "question_id": 3876},
{"snippet": "numpy.unpackbits(a, axis=None)", "intent": "Unpacks elements of `a` uint8 array into a binary-valued output array . The shape of the output array is either 1-D ( if `axis` is None ) or the same shape as the input array with unpacking done along the axis specified .", "question_id": 3877},
{"snippet": "numpy.unpackbits(a, count=None)", "intent": "Unpacks elements of `a` uint8 array into a binary-valued output array . With arguments `count`.", "question_id": 3878},
{"snippet": "numpy.unpackbits(a, bitorder='big')", "intent": "Unpacks elements of `a` uint8 array into a binary-valued output array . With arguments `bitorder`.", "question_id": 3879},
{"snippet": "numpy.unpackbits(a, axis=None, count=None)", "intent": "Unpacks elements of `a` uint8 array into a binary-valued output array . The shape of the output array is either 1-D ( if `axis` is None ) or the same shape as the input array with unpacking done along the axis specified . With arguments `count`.", "question_id": 3880},
{"snippet": "numpy.unpackbits(a, axis=None, bitorder='big')", "intent": "Unpacks elements of `a` uint8 array into a binary-valued output array . The shape of the output array is either 1-D ( if `axis` is None ) or the same shape as the input array with unpacking done along the axis specified . With arguments `bitorder`.", "question_id": 3881},
{"snippet": "numpy.unpackbits(a, count=None, bitorder='big')", "intent": "Unpacks elements of `a` uint8 array into a binary-valued output array . With arguments `count`, `bitorder`.", "question_id": 3882},
{"snippet": "numpy.unpackbits(a, axis=None, count=None, bitorder='big')", "intent": "Unpacks elements of `a` uint8 array into a binary-valued output array . The shape of the output array is either 1-D ( if `axis` is None ) or the same shape as the input array with unpacking done along the axis specified . With arguments `count`, `bitorder`.", "question_id": 3883},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_implies(names)", "intent": "Return a set of CPU features that implied by \u2018 `names` \u2019", "question_id": 3884},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_implies(names, keep_origins=False)", "intent": "Return a set of CPU features that implied by \u2018 `names` \u2019 With arguments `keep_origins`.", "question_id": 3885},
{"snippet": "memmap.diagonal()", "intent": "Return specified diagonals .", "question_id": 3886},
{"snippet": "memmap.diagonal(offset=0)", "intent": "Return specified diagonals . With arguments `offset`.", "question_id": 3887},
{"snippet": "memmap.diagonal(axis1=0)", "intent": "Return specified diagonals . With arguments `axis1`.", "question_id": 3888},
{"snippet": "memmap.diagonal(axis2=1)", "intent": "Return specified diagonals . With arguments `axis2`.", "question_id": 3889},
{"snippet": "memmap.diagonal(offset=0, axis1=0)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`.", "question_id": 3890},
{"snippet": "memmap.diagonal(offset=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis2`.", "question_id": 3891},
{"snippet": "memmap.diagonal(axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `axis1`, `axis2`.", "question_id": 3892},
{"snippet": "memmap.diagonal(offset=0, axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`, `axis2`.", "question_id": 3893},
{"snippet": "polynomial.legendre.Legendre.convert()", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 3894},
{"snippet": "polynomial.legendre.Legendre.convert(domain=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 3895},
{"snippet": "polynomial.legendre.Legendre.convert(kind=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 3896},
{"snippet": "polynomial.legendre.Legendre.convert(window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 3897},
{"snippet": "polynomial.legendre.Legendre.convert(domain=None, kind=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 3898},
{"snippet": "polynomial.legendre.Legendre.convert(domain=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 3899},
{"snippet": "polynomial.legendre.Legendre.convert(kind=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 3900},
{"snippet": "polynomial.legendre.Legendre.convert(domain=None, kind=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 3901},
{"snippet": "char.chararray.endswith(suffix)", "intent": "Returns a boolean array which is True where the string element in self ends with `suffix` , otherwise False .", "question_id": 3902},
{"snippet": "char.chararray.endswith(suffix, start=0)", "intent": "Returns a boolean array which is True where the string element in self ends with `suffix` , otherwise False . With arguments `start`.", "question_id": 3903},
{"snippet": "char.chararray.endswith(suffix, end=None)", "intent": "Returns a boolean array which is True where the string element in self ends with `suffix` , otherwise False . With arguments `end`.", "question_id": 3904},
{"snippet": "char.chararray.endswith(suffix, start=0, end=None)", "intent": "Returns a boolean array which is True where the string element in self ends with `suffix` , otherwise False . With arguments `start`, `end`.", "question_id": 3905},
{"snippet": "numpy.conjugate(x, /, signature, extobj)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`.", "question_id": 3906},
{"snippet": "numpy.conjugate(x, /, signature, extobj, out=None)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`.", "question_id": 3907},
{"snippet": "numpy.conjugate(x, /, signature, extobj, where=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `where`.", "question_id": 3908},
{"snippet": "numpy.conjugate(x, /, signature, extobj, casting='same_kind')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `casting`.", "question_id": 3909},
{"snippet": "numpy.conjugate(x, /, signature, extobj, order='K')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `order`.", "question_id": 3910},
{"snippet": "numpy.conjugate(x, /, signature, extobj, dtype=None)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `dtype`.", "question_id": 3911},
{"snippet": "numpy.conjugate(x, /, signature, extobj, subok=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `subok`.", "question_id": 3912},
{"snippet": "numpy.conjugate(x, /, signature, extobj, out=None, where=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 3913},
{"snippet": "numpy.conjugate(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 3914},
{"snippet": "numpy.conjugate(x, /, signature, extobj, out=None, order='K')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 3915},
{"snippet": "numpy.conjugate(x, /, signature)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`.", "question_id": 3916},
{"snippet": "numpy.conjugate(x, /, signature, out=None)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `out`.", "question_id": 3917},
{"snippet": "numpy.conjugate(x, /, signature, where=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `where`.", "question_id": 3918},
{"snippet": "numpy.conjugate(x, /, signature, casting='same_kind')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `casting`.", "question_id": 3919},
{"snippet": "numpy.conjugate(x, /, signature, order='K')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `order`.", "question_id": 3920},
{"snippet": "numpy.conjugate(x, /, signature, dtype=None)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `dtype`.", "question_id": 3921},
{"snippet": "numpy.conjugate(x, /, signature, subok=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `subok`.", "question_id": 3922},
{"snippet": "numpy.conjugate(x, /, signature, out=None, where=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `out`, `where`.", "question_id": 3923},
{"snippet": "numpy.conjugate(x, /, signature, out=None, casting='same_kind')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `out`, `casting`.", "question_id": 3924},
{"snippet": "numpy.conjugate(x, /, signature, out=None, order='K')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `out`, `order`.", "question_id": 3925},
{"snippet": "recarray.setfield(val, dtype)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field .", "question_id": 3926},
{"snippet": "recarray.setfield(val, dtype, offset=0)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field .", "question_id": 3927},
{"snippet": "linalg.det(a)", "intent": "Compute the determinant of an array . The determinant of `a` 2-D array [ [ a , b ] , [ c , d ] ] is ad - bc :", "question_id": 3928},
{"snippet": "lib.stride_tricks.as_strided(x)", "intent": "Create a view into the array with the given `shape` and `strides` . With arguments `x`.", "question_id": 3929},
{"snippet": "lib.stride_tricks.as_strided(x, shape=None)", "intent": "Create a view into the array with the given `shape` and `strides` . With arguments `x`.", "question_id": 3930},
{"snippet": "lib.stride_tricks.as_strided(x, strides=None)", "intent": "Create a view into the array with the given `shape` and `strides` . With arguments `x`.", "question_id": 3931},
{"snippet": "lib.stride_tricks.as_strided(x, subok=False)", "intent": "Create a view into the array with the given `shape` and `strides` . With arguments `x`, `subok`.", "question_id": 3932},
{"snippet": "lib.stride_tricks.as_strided(x, writeable=True)", "intent": "Create a view into the array with the given `shape` and `strides` . With arguments `x`, `writeable`.", "question_id": 3933},
{"snippet": "lib.stride_tricks.as_strided(x, shape=None, strides=None)", "intent": "Create a view into the array with the given `shape` and `strides` . With arguments `x`.", "question_id": 3934},
{"snippet": "lib.stride_tricks.as_strided(x, shape=None, subok=False)", "intent": "Create a view into the array with the given `shape` and `strides` . With arguments `x`, `subok`.", "question_id": 3935},
{"snippet": "lib.stride_tricks.as_strided(x, shape=None, writeable=True)", "intent": "Create a view into the array with the given `shape` and `strides` . With arguments `x`, `writeable`.", "question_id": 3936},
{"snippet": "lib.stride_tricks.as_strided(x, strides=None, subok=False)", "intent": "Create a view into the array with the given `shape` and `strides` . With arguments `x`, `subok`.", "question_id": 3937},
{"snippet": "lib.stride_tricks.as_strided(x, strides=None, writeable=True)", "intent": "Create a view into the array with the given `shape` and `strides` . With arguments `x`, `writeable`.", "question_id": 3938},
{"snippet": "dtype.base", "intent": "Returns dtype for the base element of the subarrays, regardless of their dimension or shape.", "question_id": 3939},
{"snippet": "polynomial.chebyshev.Chebyshev.degree()", "intent": "The degree of the series .", "question_id": 3940},
{"snippet": "numpy.shares_memory(a, b)", "intent": "Determine if two arrays share memory . Hence , `max_work` should generally be set to `a` finite number , as it is possible to construct examples that take extremely long to run : With arguments `b`.", "question_id": 3941},
{"snippet": "numpy.shares_memory(a, b, max_work=None)", "intent": "Determine if two arrays share memory . Hence , `max_work` should generally be set to `a` finite number , as it is possible to construct examples that take extremely long to run : With arguments `b`.", "question_id": 3942},
{"snippet": "ma.reshape(a, new_shape)", "intent": "Returns an array containing the same data with `a` new shape . With arguments `new_shape`.", "question_id": 3943},
{"snippet": "ma.reshape(a, new_shape, order='C')", "intent": "Returns an array containing the same data with `a` new shape . With arguments `new_shape`, `order`.", "question_id": 3944},
{"snippet": "char.chararray.center(width)", "intent": "Return a copy of self with its elements centered in a string of length `width` .", "question_id": 3945},
{"snippet": "char.chararray.center(width, fillchar=' ')", "intent": "Return a copy of self with its elements centered in a string of length `width` . With arguments `fillchar`.", "question_id": 3946},
{"snippet": "polynomial.hermite_e.HermiteE.fromroots(roots)", "intent": "Return series instance that has the specified `roots` .", "question_id": 3947},
{"snippet": "polynomial.hermite_e.HermiteE.fromroots(roots, domain=)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`.", "question_id": 3948},
{"snippet": "polynomial.hermite_e.HermiteE.fromroots(roots, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `window`.", "question_id": 3949},
{"snippet": "polynomial.hermite_e.HermiteE.fromroots(roots, domain=, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`, `window`.", "question_id": 3950},
{"snippet": "polynomial.hermite_e.HermiteE.fromroots()", "intent": "Return series instance that has the specified `roots` .", "question_id": 3951},
{"snippet": "polynomial.hermite_e.HermiteE.fromroots(domain=)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`.", "question_id": 3952},
{"snippet": "polynomial.hermite_e.HermiteE.fromroots(window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `window`.", "question_id": 3953},
{"snippet": "polynomial.hermite_e.HermiteE.fromroots(domain=, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`, `window`.", "question_id": 3954},
{"snippet": "memmap.prod()", "intent": "Return the product of the array elements over the given `axis`", "question_id": 3955},
{"snippet": "memmap.prod(axis=None)", "intent": "Return the product of the array elements over the given `axis`", "question_id": 3956},
{"snippet": "memmap.prod(dtype=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `dtype`.", "question_id": 3957},
{"snippet": "memmap.prod(out=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `out`.", "question_id": 3958},
{"snippet": "memmap.prod(keepdims=False)", "intent": "Return the product of the array elements over the given `axis` With arguments `keepdims`.", "question_id": 3959},
{"snippet": "memmap.prod(initial=1)", "intent": "Return the product of the array elements over the given `axis` With arguments `initial`.", "question_id": 3960},
{"snippet": "memmap.prod(where=True)", "intent": "Return the product of the array elements over the given `axis` With arguments `where`.", "question_id": 3961},
{"snippet": "memmap.prod(axis=None, dtype=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `dtype`.", "question_id": 3962},
{"snippet": "memmap.prod(axis=None, out=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `out`.", "question_id": 3963},
{"snippet": "memmap.prod(axis=None, keepdims=False)", "intent": "Return the product of the array elements over the given `axis` With arguments `keepdims`.", "question_id": 3964},
{"snippet": "polynomial.chebyshev.chebint(c)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 3965},
{"snippet": "polynomial.chebyshev.chebint(c, m=1)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 3966},
{"snippet": "polynomial.chebyshev.chebint(c, k=)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 3967},
{"snippet": "polynomial.chebyshev.chebint(c, lbnd=0)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 3968},
{"snippet": "polynomial.chebyshev.chebint(c, scl=1)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 3969},
{"snippet": "polynomial.chebyshev.chebint(c, axis=0)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 3970},
{"snippet": "polynomial.chebyshev.chebint(c, m=1, k=)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 3971},
{"snippet": "polynomial.chebyshev.chebint(c, m=1, lbnd=0)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 3972},
{"snippet": "polynomial.chebyshev.chebint(c, m=1, scl=1)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 3973},
{"snippet": "polynomial.chebyshev.chebint(c, m=1, axis=0)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 3974},
{"snippet": "polynomial.chebyshev.chebint()", "intent": "Integrate a Chebyshev series .", "question_id": 3975},
{"snippet": "polynomial.chebyshev.chebint(m=1)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 3976},
{"snippet": "polynomial.chebyshev.chebint(k=)", "intent": "Integrate a Chebyshev series . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 3977},
{"snippet": "polynomial.chebyshev.chebint(lbnd=0)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 3978},
{"snippet": "polynomial.chebyshev.chebint(scl=1)", "intent": "Integrate a Chebyshev series . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 3979},
{"snippet": "polynomial.chebyshev.chebint(axis=0)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 3980},
{"snippet": "polynomial.chebyshev.chebint(m=1, k=)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 3981},
{"snippet": "polynomial.chebyshev.chebint(m=1, lbnd=0)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 3982},
{"snippet": "polynomial.chebyshev.chebint(m=1, scl=1)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 3983},
{"snippet": "polynomial.chebyshev.chebint(m=1, axis=0)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 3984},
{"snippet": "ma.MaskType.real", "intent": "The real part of the scalar.", "question_id": 3985},
{"snippet": "numpy.blackman(M)", "intent": "Return the Blackman window . With arguments `M`.", "question_id": 3986},
{"snippet": "testing.assert_array_equal(x, y)", "intent": "Raises an AssertionError if two array_like objects are not equal . When one of `x` and `y` is a scalar and the other is array_like , the function checks that each element of the array_like object is equal to the scalar .", "question_id": 3987},
{"snippet": "testing.assert_array_equal(x, y, err_msg='')", "intent": "Raises an AssertionError if two array_like objects are not equal . When one of `x` and `y` is a scalar and the other is array_like , the function checks that each element of the array_like object is equal to the scalar . With arguments `err_msg`.", "question_id": 3988},
{"snippet": "testing.assert_array_equal(x, y, verbose=True)", "intent": "Raises an AssertionError if two array_like objects are not equal . When one of `x` and `y` is a scalar and the other is array_like , the function checks that each element of the array_like object is equal to the scalar . With arguments `verbose`.", "question_id": 3989},
{"snippet": "testing.assert_array_equal(x, y, err_msg='', verbose=True)", "intent": "Raises an AssertionError if two array_like objects are not equal . When one of `x` and `y` is a scalar and the other is array_like , the function checks that each element of the array_like object is equal to the scalar . With arguments `err_msg`, `verbose`.", "question_id": 3990},
{"snippet": "char.chararray.find(sub)", "intent": "For each element , return the lowest index in the string where substring `sub` is found .", "question_id": 3991},
{"snippet": "char.chararray.find(sub, start=0)", "intent": "For each element , return the lowest index in the string where substring `sub` is found . With arguments `start`.", "question_id": 3992},
{"snippet": "char.chararray.find(sub, end=None)", "intent": "For each element , return the lowest index in the string where substring `sub` is found . With arguments `end`.", "question_id": 3993},
{"snippet": "char.chararray.find(sub, start=0, end=None)", "intent": "For each element , return the lowest index in the string where substring `sub` is found . With arguments `start`, `end`.", "question_id": 3994},
{"snippet": "numpy.min_scalar_type(a)", "intent": "For scalar `a` , returns the data type with the smallest size and smallest scalar kind which can hold its value .", "question_id": 3995},
{"snippet": "numpy.mod(x1, x2, /, signature, extobj)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`.", "question_id": 3996},
{"snippet": "numpy.mod(x1, x2, /, signature, extobj, out=None)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 3997},
{"snippet": "numpy.mod(x1, x2, /, signature, extobj, where=True)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 3998},
{"snippet": "numpy.mod(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 3999},
{"snippet": "numpy.mod(x1, x2, /, signature, extobj, order='K')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 4000},
{"snippet": "numpy.mod(x1, x2, /, signature, extobj, dtype=None)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 4001},
{"snippet": "numpy.mod(x1, x2, /, signature, extobj, subok=True)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 4002},
{"snippet": "numpy.mod(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 4003},
{"snippet": "numpy.mod(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 4004},
{"snippet": "numpy.mod(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 4005},
{"snippet": "numpy.mod(x1, x2, /, signature)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`.", "question_id": 4006},
{"snippet": "numpy.mod(x1, x2, /, signature, out=None)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `out`.", "question_id": 4007},
{"snippet": "numpy.mod(x1, x2, /, signature, where=True)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `where`.", "question_id": 4008},
{"snippet": "numpy.mod(x1, x2, /, signature, casting='same_kind')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `casting`.", "question_id": 4009},
{"snippet": "numpy.mod(x1, x2, /, signature, order='K')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `order`.", "question_id": 4010},
{"snippet": "numpy.mod(x1, x2, /, signature, dtype=None)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `dtype`.", "question_id": 4011},
{"snippet": "numpy.mod(x1, x2, /, signature, subok=True)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `subok`.", "question_id": 4012},
{"snippet": "numpy.mod(x1, x2, /, signature, out=None, where=True)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `out`, `where`.", "question_id": 4013},
{"snippet": "numpy.mod(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 4014},
{"snippet": "numpy.mod(x1, x2, /, signature, out=None, order='K')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `out`, `order`.", "question_id": 4015},
{"snippet": "record.nonzero()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 4016},
{"snippet": "ma.choose(indices, choices)", "intent": "Use an index array to construct a new array from a list of `choices` . With arguments `indices`.", "question_id": 4017},
{"snippet": "ma.choose(indices, choices, out=None)", "intent": "Use an index array to construct a new array from a list of `choices` . With arguments `indices`, `out`.", "question_id": 4018},
{"snippet": "ma.choose(indices, choices, mode='raise')", "intent": "Use an index array to construct a new array from a list of `choices` . With arguments `indices`, `mode`.", "question_id": 4019},
{"snippet": "ma.choose(indices, choices, out=None, mode='raise')", "intent": "Use an index array to construct a new array from a list of `choices` . With arguments `indices`, `out`, `mode`.", "question_id": 4020},
{"snippet": "chararray.istitle()", "intent": "Returns true for each element if the element is a titlecased string and there is at least one character , false otherwise .", "question_id": 4021},
{"snippet": "char.chararray.splitlines()", "intent": "For each element in self , return a list of the lines in the element , breaking at line boundaries .", "question_id": 4022},
{"snippet": "char.chararray.splitlines(keepends=None)", "intent": "For each element in self , return a list of the lines in the element , breaking at line boundaries . With arguments `keepends`.", "question_id": 4023},
{"snippet": "numpy.testing.Tester", "intent": "alias of numpy.testing._private.nosetester.NoseTester", "question_id": 4024},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.dist_fatal(*args)", "intent": "Raise a distutils error With arguments `*args`.", "question_id": 4025},
{"snippet": "ma.masked_array.cumsum()", "intent": "Return the cumulative sum of the array elements over the given `axis` .", "question_id": 4026},
{"snippet": "ma.masked_array.cumsum(axis=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` .", "question_id": 4027},
{"snippet": "ma.masked_array.cumsum(dtype=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 4028},
{"snippet": "ma.masked_array.cumsum(out=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . The mask is lost if `out` is not a valid ma.MaskedArray !", "question_id": 4029},
{"snippet": "ma.masked_array.cumsum(axis=None, dtype=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 4030},
{"snippet": "ma.masked_array.cumsum(axis=None, out=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . The mask is lost if `out` is not a valid ma.MaskedArray !", "question_id": 4031},
{"snippet": "ma.masked_array.cumsum(dtype=None, out=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . The mask is lost if `out` is not a valid ma.MaskedArray ! With arguments `dtype`.", "question_id": 4032},
{"snippet": "ma.masked_array.cumsum(axis=None, dtype=None, out=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . The mask is lost if `out` is not a valid ma.MaskedArray ! With arguments `dtype`.", "question_id": 4033},
{"snippet": "polynomial.chebyshev.Chebyshev.has_samecoef(other)", "intent": "Check if coefficients match . With arguments `other`.", "question_id": 4034},
{"snippet": "ndarray.__ne__(value, /)", "intent": "Return self ! =value . With arguments `value`, `/`.", "question_id": 4035},
{"snippet": "random.Generator.noncentral_chisquare(df, nonc)", "intent": "Draw samples from a noncentral chi-square distribution . With arguments `df`, `nonc`.", "question_id": 4036},
{"snippet": "random.Generator.noncentral_chisquare(df, nonc, size=None)", "intent": "Draw samples from a noncentral chi-square distribution . With arguments `df`, `nonc`, `size`.", "question_id": 4037},
{"snippet": "polynomial.chebyshev.chebpow(c, pow)", "intent": "Raise a Chebyshev series to a power . Returns the Chebyshev series `c` raised to the power `pow` .", "question_id": 4038},
{"snippet": "polynomial.chebyshev.chebpow(c, pow, maxpower=16)", "intent": "Raise a Chebyshev series to a power . Returns the Chebyshev series `c` raised to the power `pow` . With arguments `maxpower`.", "question_id": 4039},
{"snippet": "ma.masked_object(x, value)", "intent": "Mask the array `x` where the data are exactly equal to `value` .", "question_id": 4040},
{"snippet": "ma.masked_object(x, value, copy=True)", "intent": "Mask the array `x` where the data are exactly equal to `value` . With arguments `copy`.", "question_id": 4041},
{"snippet": "ma.masked_object(x, value, shrink=True)", "intent": "Mask the array `x` where the data are exactly equal to `value` . With arguments `shrink`.", "question_id": 4042},
{"snippet": "ma.masked_object(x, value, copy=True, shrink=True)", "intent": "Mask the array `x` where the data are exactly equal to `value` . With arguments `copy`, `shrink`.", "question_id": 4043},
{"snippet": "polynomial.legendre.leg2poly(c)", "intent": "Convert a Legendre series to a polynomial . With arguments `c`.", "question_id": 4044},
{"snippet": "ma.mask_cols(a)", "intent": "Mask columns of `a` 2D array that contain masked values .", "question_id": 4045},
{"snippet": "ma.mask_cols(a, axis=<no value>)", "intent": "Mask columns of `a` 2D array that contain masked values . This function is a shortcut to mask_rowcols with `axis` equal to 1 .", "question_id": 4046},
{"snippet": "chararray.shape", "intent": "Tuple of array dimensions.", "question_id": 4047},
{"snippet": "ma.around", "intent": "Round an array to the given number of decimals.", "question_id": 4048},
{"snippet": "memmap.tofile(fid)", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method .", "question_id": 4049},
{"snippet": "memmap.tofile(fid, sep='')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `sep`.", "question_id": 4050},
{"snippet": "memmap.tofile(fid, format='%s')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `format`.", "question_id": 4051},
{"snippet": "memmap.tofile(fid, sep='', format='%s')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `sep`, `format`.", "question_id": 4052},
{"snippet": "ndarray.clip(**kwargs)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 4053},
{"snippet": "ndarray.clip(**kwargs, min=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 4054},
{"snippet": "ndarray.clip(**kwargs, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 4055},
{"snippet": "ndarray.clip(**kwargs, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 4056},
{"snippet": "ndarray.clip(**kwargs, min=None, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 4057},
{"snippet": "ndarray.clip(**kwargs, min=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 4058},
{"snippet": "ndarray.clip(**kwargs, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 4059},
{"snippet": "ndarray.clip(**kwargs, min=None, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 4060},
{"snippet": "polynomial.hermite_e.HermiteE.copy()", "intent": "Return a copy .", "question_id": 4061},
{"snippet": "polynomial.legendre.legadd(c1, c2)", "intent": "Add one Legendre series to another . Returns the sum of two Legendre series `c1` + `c2` .", "question_id": 4062},
{"snippet": "numpy.busday_offset(dates, offsets)", "intent": "First adjusts the date to fall on a valid day according to the `roll` rule , then applies `offsets` to the given `dates` counted in valid days .", "question_id": 4063},
{"snippet": "numpy.busday_offset(dates, offsets, roll='raise')", "intent": "First adjusts the date to fall on a valid day according to the `roll` rule , then applies `offsets` to the given `dates` counted in valid days .", "question_id": 4064},
{"snippet": "numpy.busday_offset(dates, offsets, weekmask='1111100')", "intent": "First adjusts the date to fall on a valid day according to the `roll` rule , then applies `offsets` to the given `dates` counted in valid days . With arguments `weekmask`.", "question_id": 4065},
{"snippet": "numpy.busday_offset(dates, offsets, holidays=None)", "intent": "First adjusts the date to fall on a valid day according to the `roll` rule , then applies `offsets` to the given `dates` counted in valid days . With arguments `holidays`.", "question_id": 4066},
{"snippet": "numpy.busday_offset(dates, offsets, busdaycal=None)", "intent": "First adjusts the date to fall on a valid day according to the `roll` rule , then applies `offsets` to the given `dates` counted in valid days . With arguments `busdaycal`.", "question_id": 4067},
{"snippet": "numpy.busday_offset(dates, offsets, out=None)", "intent": "First adjusts the date to fall on a valid day according to the `roll` rule , then applies `offsets` to the given `dates` counted in valid days . With arguments `out`.", "question_id": 4068},
{"snippet": "numpy.busday_offset(dates, offsets, roll='raise', weekmask='1111100')", "intent": "First adjusts the date to fall on a valid day according to the `roll` rule , then applies `offsets` to the given `dates` counted in valid days . With arguments `weekmask`.", "question_id": 4069},
{"snippet": "numpy.busday_offset(dates, offsets, roll='raise', holidays=None)", "intent": "First adjusts the date to fall on a valid day according to the `roll` rule , then applies `offsets` to the given `dates` counted in valid days . With arguments `holidays`.", "question_id": 4070},
{"snippet": "numpy.busday_offset(dates, offsets, roll='raise', busdaycal=None)", "intent": "First adjusts the date to fall on a valid day according to the `roll` rule , then applies `offsets` to the given `dates` counted in valid days . With arguments `busdaycal`.", "question_id": 4071},
{"snippet": "numpy.busday_offset(dates, offsets, roll='raise', out=None)", "intent": "First adjusts the date to fall on a valid day according to the `roll` rule , then applies `offsets` to the given `dates` counted in valid days . With arguments `out`.", "question_id": 4072},
{"snippet": "ndarray.__lshift__(value, /)", "intent": "Return self < < `value` . With arguments `/`.", "question_id": 4073},
{"snippet": "core.defchararray.asarray(obj)", "intent": "Convert the input to a chararray , copying the data only if necessary . With arguments `obj`.", "question_id": 4074},
{"snippet": "core.defchararray.asarray(obj, itemsize=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . With arguments `obj`, `itemsize`.", "question_id": 4075},
{"snippet": "core.defchararray.asarray(obj, unicode=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`.", "question_id": 4076},
{"snippet": "core.defchararray.asarray(obj, order=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . With arguments `obj`, `order`.", "question_id": 4077},
{"snippet": "core.defchararray.asarray(obj, itemsize=None, unicode=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`, `itemsize`.", "question_id": 4078},
{"snippet": "core.defchararray.asarray(obj, itemsize=None, order=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . With arguments `obj`, `itemsize`, `order`.", "question_id": 4079},
{"snippet": "core.defchararray.asarray(obj, unicode=None, order=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`, `order`.", "question_id": 4080},
{"snippet": "core.defchararray.asarray(obj, itemsize=None, unicode=None, order=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`, `itemsize`, `order`.", "question_id": 4081},
{"snippet": "memmap.argmin()", "intent": "Return indices of the minimum values along the given `axis` .", "question_id": 4082},
{"snippet": "memmap.argmin(axis=None)", "intent": "Return indices of the minimum values along the given `axis` .", "question_id": 4083},
{"snippet": "memmap.argmin(out=None)", "intent": "Return indices of the minimum values along the given `axis` . With arguments `out`.", "question_id": 4084},
{"snippet": "memmap.argmin(axis=None, out=None)", "intent": "Return indices of the minimum values along the given `axis` . With arguments `out`.", "question_id": 4085},
{"snippet": "ma.MaskedArray.__truediv__(other)", "intent": "Divide `other` into self , and return a new masked array .", "question_id": 4086},
{"snippet": "matrix.argmin()", "intent": "Indexes of the minimum values along an `axis` .", "question_id": 4087},
{"snippet": "matrix.argmin(axis=None)", "intent": "Indexes of the minimum values along an `axis` .", "question_id": 4088},
{"snippet": "matrix.argmin(out=None)", "intent": "Indexes of the minimum values along an `axis` . With arguments `out`.", "question_id": 4089},
{"snippet": "matrix.argmin(axis=None, out=None)", "intent": "Indexes of the minimum values along an `axis` . With arguments `out`.", "question_id": 4090},
{"snippet": "polynomial.legendre.Legendre.has_sametype(other)", "intent": "Check if types match . With arguments `other`.", "question_id": 4091},
{"snippet": "random.RandomState.shuffle(x)", "intent": "Modify a sequence in-place by shuffling its contents . With arguments `x`.", "question_id": 4092},
{"snippet": "testing.suppress_warnings.filter()", "intent": "Add a new suppressing filter or apply it if the state is entered .", "question_id": 4093},
{"snippet": "testing.suppress_warnings.filter(category=<class 'Warning'>)", "intent": "Add a new suppressing filter or apply it if the state is entered . With arguments `category`.", "question_id": 4094},
{"snippet": "testing.suppress_warnings.filter(message='')", "intent": "Add a new suppressing filter or apply it if the state is entered . With arguments `message`.", "question_id": 4095},
{"snippet": "testing.suppress_warnings.filter(module=None)", "intent": "Add a new suppressing filter or apply it if the state is entered . With arguments `module`.", "question_id": 4096},
{"snippet": "testing.suppress_warnings.filter(category=<class 'Warning'>, message='')", "intent": "Add a new suppressing filter or apply it if the state is entered . With arguments `category`, `message`.", "question_id": 4097},
{"snippet": "testing.suppress_warnings.filter(category=<class 'Warning'>, module=None)", "intent": "Add a new suppressing filter or apply it if the state is entered . With arguments `category`, `module`.", "question_id": 4098},
{"snippet": "testing.suppress_warnings.filter(message='', module=None)", "intent": "Add a new suppressing filter or apply it if the state is entered . With arguments `message`, `module`.", "question_id": 4099},
{"snippet": "testing.suppress_warnings.filter(category=<class 'Warning'>, message='', module=None)", "intent": "Add a new suppressing filter or apply it if the state is entered . With arguments `category`, `message`, `module`.", "question_id": 4100},
{"snippet": "char.index(a, sub)", "intent": "Like find , but raises ValueError when the substring is not found . With arguments `a`, `sub`.", "question_id": 4101},
{"snippet": "char.index(a, sub, start=0)", "intent": "Like find , but raises ValueError when the substring is not found . With arguments `a`, `sub`, `start`.", "question_id": 4102},
{"snippet": "char.index(a, sub, end=None)", "intent": "Like find , but raises ValueError when the substring is not found . With arguments `a`, `sub`, `end`.", "question_id": 4103},
{"snippet": "char.index(a, sub, start=0, end=None)", "intent": "Like find , but raises ValueError when the substring is not found . With arguments `a`, `sub`, `start`, `end`.", "question_id": 4104},
{"snippet": "matrix.choose(choices)", "intent": "Use an index array to construct a new array from a set of `choices` .", "question_id": 4105},
{"snippet": "matrix.choose(choices, out=None)", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`.", "question_id": 4106},
{"snippet": "matrix.choose(choices, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `mode`.", "question_id": 4107},
{"snippet": "matrix.choose(choices, out=None, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`, `mode`.", "question_id": 4108},
{"snippet": "numpy.diagonal(a)", "intent": "Return specified diagonals . If `a` is 2-D , returns the diagonal of a with the given `offset` , i.e. , the collection of elements of the form a [ i , i+offset ] .", "question_id": 4109},
{"snippet": "numpy.diagonal(a, offset=0)", "intent": "Return specified diagonals . If `a` is 2-D , returns the diagonal of a with the given `offset` , i.e. , the collection of elements of the form a [ i , i+offset ] .", "question_id": 4110},
{"snippet": "numpy.diagonal(a, axis1=0)", "intent": "Return specified diagonals . If `a` is 2-D , returns the diagonal of a with the given `offset` , i.e. , the collection of elements of the form a [ i , i+offset ] . If a has more than two dimensions , then the axes specified by `axis1` and `axis2` are used to determine the 2-D sub-array whose diagonal is returned .", "question_id": 4111},
{"snippet": "numpy.diagonal(a, axis2=1)", "intent": "Return specified diagonals . If `a` is 2-D , returns the diagonal of a with the given `offset` , i.e. , the collection of elements of the form a [ i , i+offset ] . If a has more than two dimensions , then the axes specified by `axis1` and `axis2` are used to determine the 2-D sub-array whose diagonal is returned .", "question_id": 4112},
{"snippet": "numpy.diagonal(a, offset=0, axis1=0)", "intent": "Return specified diagonals . If `a` is 2-D , returns the diagonal of a with the given `offset` , i.e. , the collection of elements of the form a [ i , i+offset ] . If a has more than two dimensions , then the axes specified by `axis1` and `axis2` are used to determine the 2-D sub-array whose diagonal is returned .", "question_id": 4113},
{"snippet": "numpy.diagonal(a, offset=0, axis2=1)", "intent": "Return specified diagonals . If `a` is 2-D , returns the diagonal of a with the given `offset` , i.e. , the collection of elements of the form a [ i , i+offset ] . If a has more than two dimensions , then the axes specified by `axis1` and `axis2` are used to determine the 2-D sub-array whose diagonal is returned .", "question_id": 4114},
{"snippet": "numpy.diagonal(a, axis1=0, axis2=1)", "intent": "Return specified diagonals . If `a` is 2-D , returns the diagonal of a with the given `offset` , i.e. , the collection of elements of the form a [ i , i+offset ] . If a has more than two dimensions , then the axes specified by `axis1` and `axis2` are used to determine the 2-D sub-array whose diagonal is returned .", "question_id": 4115},
{"snippet": "numpy.diagonal(a, offset=0, axis1=0, axis2=1)", "intent": "Return specified diagonals . If `a` is 2-D , returns the diagonal of a with the given `offset` , i.e. , the collection of elements of the form a [ i , i+offset ] . If a has more than two dimensions , then the axes specified by `axis1` and `axis2` are used to determine the 2-D sub-array whose diagonal is returned .", "question_id": 4116},
{"snippet": "polynomial.chebyshev.chebmulx(c)", "intent": "Multiply a Chebyshev series by x . Multiply the polynomial `c` by x , where x is the independent variable .", "question_id": 4117},
{"snippet": "numpy.roots(p)", "intent": "Return the roots of a polynomial with coefficients given in `p` .", "question_id": 4118},
{"snippet": "ma.masked_array.view()", "intent": "Return a view of the MaskedArray data .", "question_id": 4119},
{"snippet": "ma.masked_array.view(dtype=None)", "intent": "Return a view of the MaskedArray data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . )", "question_id": 4120},
{"snippet": "ma.masked_array.view(type=None)", "intent": "Return a view of the MaskedArray data . With arguments `type`.", "question_id": 4121},
{"snippet": "ma.masked_array.view(fill_value=None)", "intent": "Return a view of the MaskedArray data . If `fill_value` is not specified , but dtype is specified ( and is not an ndarray sub-class ) , the fill_value of the MaskedArray will be reset .", "question_id": 4122},
{"snippet": "ma.masked_array.view(dtype=None, type=None)", "intent": "Return a view of the MaskedArray data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) With arguments `type`.", "question_id": 4123},
{"snippet": "ma.masked_array.view(dtype=None, fill_value=None)", "intent": "Return a view of the MaskedArray data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) If `fill_value` is not specified , but dtype is specified ( and is not an ndarray sub-class ) , the fill_value of the MaskedArray will be reset .", "question_id": 4124},
{"snippet": "ma.masked_array.view(type=None, fill_value=None)", "intent": "Return a view of the MaskedArray data . If `fill_value` is not specified , but dtype is specified ( and is not an ndarray sub-class ) , the fill_value of the MaskedArray will be reset . With arguments `type`.", "question_id": 4125},
{"snippet": "ma.masked_array.view(dtype=None, type=None, fill_value=None)", "intent": "Return a view of the MaskedArray data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) If `fill_value` is not specified , but dtype is specified ( and is not an ndarray sub-class ) , the fill_value of the MaskedArray will be reset . With arguments `type`.", "question_id": 4126},
{"snippet": "ndarray.var()", "intent": "Returns the variance of the array elements , along given `axis` .", "question_id": 4127},
{"snippet": "ndarray.var(axis=None)", "intent": "Returns the variance of the array elements , along given `axis` .", "question_id": 4128},
{"snippet": "ndarray.var(dtype=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `dtype`.", "question_id": 4129},
{"snippet": "ndarray.var(out=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `out`.", "question_id": 4130},
{"snippet": "ndarray.var(ddof=0)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `ddof`.", "question_id": 4131},
{"snippet": "ndarray.var(keepdims=False)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `keepdims`.", "question_id": 4132},
{"snippet": "ndarray.var(where=True)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `where`.", "question_id": 4133},
{"snippet": "ndarray.var(axis=None, dtype=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `dtype`.", "question_id": 4134},
{"snippet": "ndarray.var(axis=None, out=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `out`.", "question_id": 4135},
{"snippet": "ndarray.var(axis=None, ddof=0)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `ddof`.", "question_id": 4136},
{"snippet": "random.random_sample()", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) .", "question_id": 4137},
{"snippet": "random.random_sample(size=None)", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) . With arguments `size`.", "question_id": 4138},
{"snippet": "record.resize()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 4139},
{"snippet": "memmap.item(*args)", "intent": "Copy an element of an array to a standard Python scalar and return it . With arguments `*args`.", "question_id": 4140},
{"snippet": "chararray.lower()", "intent": "Return an array with the elements of self converted to lowercase .", "question_id": 4141},
{"snippet": "numpy.real_if_close(a)", "intent": "If input is complex with all imaginary parts close to zero , return real parts . \u201c Close to zero \u201d is defined as `tol` * ( machine epsilon of the type for `a` ) .", "question_id": 4142},
{"snippet": "numpy.real_if_close(a, tol=100)", "intent": "If input is complex with all imaginary parts close to zero , return real parts . \u201c Close to zero \u201d is defined as `tol` * ( machine epsilon of the type for `a` ) .", "question_id": 4143},
{"snippet": "chararray.swapcase()", "intent": "For each element in self , return a copy of the string with uppercase characters converted to lowercase and vice versa .", "question_id": 4144},
{"snippet": "ma.MaskedArray.filled()", "intent": "Return a copy of self , with masked values filled with a given value .", "question_id": 4145},
{"snippet": "ma.MaskedArray.filled(fill_value=None)", "intent": "Return a copy of self , with masked values filled with a given value . With arguments `fill_value`.", "question_id": 4146},
{"snippet": "numpy.iinfo(type)", "intent": "Machine limits for integer types . With arguments `type`.", "question_id": 4147},
{"snippet": "numpy.loadtxt(fname)", "intent": "Load data from a text file . With arguments `fname`.", "question_id": 4148},
{"snippet": "numpy.loadtxt(fname, dtype=<class 'float'>)", "intent": "Load data from a text file . With arguments `fname`, `dtype`.", "question_id": 4149},
{"snippet": "numpy.loadtxt(fname, comments='#')", "intent": "Load data from a text file . With arguments `fname`, `comments`.", "question_id": 4150},
{"snippet": "numpy.loadtxt(fname, delimiter=None)", "intent": "Load data from a text file . With arguments `fname`, `delimiter`.", "question_id": 4151},
{"snippet": "numpy.loadtxt(fname, converters=None)", "intent": "Load data from a text file . This example shows how `converters` can be used to convert a field with a trailing minus sign into a negative number . With arguments `fname`.", "question_id": 4152},
{"snippet": "numpy.loadtxt(fname, skiprows=0)", "intent": "Load data from a text file . With arguments `fname`, `skiprows`.", "question_id": 4153},
{"snippet": "numpy.loadtxt(fname, usecols=None)", "intent": "Load data from a text file . With arguments `fname`, `usecols`.", "question_id": 4154},
{"snippet": "numpy.loadtxt(fname, unpack=False)", "intent": "Load data from a text file . With arguments `fname`, `unpack`.", "question_id": 4155},
{"snippet": "numpy.loadtxt(fname, ndmin=0)", "intent": "Load data from a text file . With arguments `fname`, `ndmin`.", "question_id": 4156},
{"snippet": "numpy.loadtxt(fname, encoding='bytes')", "intent": "Load data from a text file . With arguments `fname`, `encoding`.", "question_id": 4157},
{"snippet": "ma.MaskedArray.conjugate()", "intent": "Return the complex conjugate , element-wise .", "question_id": 4158},
{"snippet": "ndarray.__or__(value, /)", "intent": "Return self|value . With arguments `value`, `/`.", "question_id": 4159},
{"snippet": "numpy.array_equal(a1, a2)", "intent": "True if two arrays have the same shape and elements , False otherwise . With arguments `a1`, `a2`.", "question_id": 4160},
{"snippet": "numpy.array_equal(a1, a2, equal_nan=False)", "intent": "True if two arrays have the same shape and elements , False otherwise . When `equal_nan` is True , complex values with nan components are considered equal if either the real or the imaginary components are nan . With arguments `a1`, `a2`.", "question_id": 4161},
{"snippet": "broadcast.ndim", "intent": "Number of dimensions of broadcasted result.", "question_id": 4162},
{"snippet": "polynomial.hermite_e.HermiteE.basis(deg)", "intent": "Series basis polynomial of degree `deg` .", "question_id": 4163},
{"snippet": "polynomial.hermite_e.HermiteE.basis(deg, domain=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `domain`.", "question_id": 4164},
{"snippet": "polynomial.hermite_e.HermiteE.basis(deg, window=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `window`.", "question_id": 4165},
{"snippet": "polynomial.hermite_e.HermiteE.basis(deg, domain=None, window=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `domain`, `window`.", "question_id": 4166},
{"snippet": "chararray.encode()", "intent": "Calls str.encode element-wise .", "question_id": 4167},
{"snippet": "chararray.encode(encoding=None)", "intent": "Calls str.encode element-wise . With arguments `encoding`.", "question_id": 4168},
{"snippet": "chararray.encode(errors=None)", "intent": "Calls str.encode element-wise . With arguments `errors`.", "question_id": 4169},
{"snippet": "chararray.encode(encoding=None, errors=None)", "intent": "Calls str.encode element-wise . With arguments `encoding`, `errors`.", "question_id": 4170},
{"snippet": "ndarray.tostring()", "intent": "A compatibility alias for tobytes , with exactly the same behavior .", "question_id": 4171},
{"snippet": "ndarray.tostring(order='C')", "intent": "A compatibility alias for tobytes , with exactly the same behavior . With arguments `order`.", "question_id": 4172},
{"snippet": "random.geometric(p)", "intent": "Draw samples from the geometric distribution . where `p` is the probability of success of an individual trial .", "question_id": 4173},
{"snippet": "random.geometric(p, size=None)", "intent": "Draw samples from the geometric distribution . where `p` is the probability of success of an individual trial . With arguments `size`.", "question_id": 4174},
{"snippet": "ma.MaskType.dtype", "intent": "Get array data-descriptor.", "question_id": 4175},
{"snippet": "memmap.strides", "intent": "Tuple of bytes to step in each dimension when traversing an array.", "question_id": 4176},
{"snippet": "numpy.issubdtype(arg1, arg2)", "intent": "Returns True if first argument is a typecode lower/equal in type hierarchy . With arguments `arg1`, `arg2`.", "question_id": 4177},
{"snippet": "ufunc.accumulate(array)", "intent": "Accumulate the result of applying the operator to all elements . For a one-dimensional `array` , accumulate produces results equivalent to :", "question_id": 4178},
{"snippet": "ufunc.accumulate(array, axis=0)", "intent": "Accumulate the result of applying the operator to all elements . For a one-dimensional `array` , accumulate produces results equivalent to : For a multi-dimensional array , accumulate is applied along only one `axis` ( axis zero by default ; see Examples below ) so repeated use is necessary if one wants to accumulate over multiple axes .", "question_id": 4179},
{"snippet": "ufunc.accumulate(array, dtype=None)", "intent": "Accumulate the result of applying the operator to all elements . For a one-dimensional `array` , accumulate produces results equivalent to : With arguments `dtype`.", "question_id": 4180},
{"snippet": "ufunc.accumulate(array, out=None)", "intent": "Accumulate the result of applying the operator to all elements . For a one-dimensional `array` , accumulate produces results equivalent to : With arguments `out`.", "question_id": 4181},
{"snippet": "ufunc.accumulate(array, axis=0, dtype=None)", "intent": "Accumulate the result of applying the operator to all elements . For a one-dimensional `array` , accumulate produces results equivalent to : For a multi-dimensional array , accumulate is applied along only one `axis` ( axis zero by default ; see Examples below ) so repeated use is necessary if one wants to accumulate over multiple axes . With arguments `dtype`.", "question_id": 4182},
{"snippet": "ufunc.accumulate(array, axis=0, out=None)", "intent": "Accumulate the result of applying the operator to all elements . For a one-dimensional `array` , accumulate produces results equivalent to : For a multi-dimensional array , accumulate is applied along only one `axis` ( axis zero by default ; see Examples below ) so repeated use is necessary if one wants to accumulate over multiple axes . With arguments `out`.", "question_id": 4183},
{"snippet": "ufunc.accumulate(array, dtype=None, out=None)", "intent": "Accumulate the result of applying the operator to all elements . For a one-dimensional `array` , accumulate produces results equivalent to : With arguments `dtype`, `out`.", "question_id": 4184},
{"snippet": "ufunc.accumulate(array, axis=0, dtype=None, out=None)", "intent": "Accumulate the result of applying the operator to all elements . For a one-dimensional `array` , accumulate produces results equivalent to : For a multi-dimensional array , accumulate is applied along only one `axis` ( axis zero by default ; see Examples below ) so repeated use is necessary if one wants to accumulate over multiple axes . With arguments `dtype`, `out`.", "question_id": 4185},
{"snippet": "generic.strides", "intent": "Tuple of bytes steps in each dimension.", "question_id": 4186},
{"snippet": "ma.MaskType.shape", "intent": "Tuple of array dimensions.", "question_id": 4187},
{"snippet": "numpy.polynomial.chebyshev.Chebyshev(coef)", "intent": "A Chebyshev series class . With arguments `coef`.", "question_id": 4188},
{"snippet": "numpy.polynomial.chebyshev.Chebyshev(coef, domain=None)", "intent": "A Chebyshev series class . With arguments `coef`, `domain`.", "question_id": 4189},
{"snippet": "numpy.polynomial.chebyshev.Chebyshev(coef, window=None)", "intent": "A Chebyshev series class . With arguments `coef`, `window`.", "question_id": 4190},
{"snippet": "numpy.polynomial.chebyshev.Chebyshev(coef, domain=None, window=None)", "intent": "A Chebyshev series class . With arguments `coef`, `domain`, `window`.", "question_id": 4191},
{"snippet": "memmap.var()", "intent": "Returns the variance of the array elements , along given `axis` .", "question_id": 4192},
{"snippet": "memmap.var(axis=None)", "intent": "Returns the variance of the array elements , along given `axis` .", "question_id": 4193},
{"snippet": "memmap.var(dtype=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `dtype`.", "question_id": 4194},
{"snippet": "memmap.var(out=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `out`.", "question_id": 4195},
{"snippet": "memmap.var(ddof=0)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `ddof`.", "question_id": 4196},
{"snippet": "memmap.var(keepdims=False)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `keepdims`.", "question_id": 4197},
{"snippet": "memmap.var(where=True)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `where`.", "question_id": 4198},
{"snippet": "memmap.var(axis=None, dtype=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `dtype`.", "question_id": 4199},
{"snippet": "memmap.var(axis=None, out=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `out`.", "question_id": 4200},
{"snippet": "memmap.var(axis=None, ddof=0)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `ddof`.", "question_id": 4201},
{"snippet": "numpy.inner(a, b)", "intent": "Inner product of two arrays . Ordinary inner product of vectors for 1-D arrays ( without complex conjugation ) , in higher dimensions `a` sum product over the last axes . More generally , if ndim ( a ) = r > 0 and ndim ( `b` ) = s > 0 :", "question_id": 4202},
{"snippet": "random.Generator.weibull(a)", "intent": "Draw samples from `a` Weibull distribution .", "question_id": 4203},
{"snippet": "random.Generator.weibull(a, size=None)", "intent": "Draw samples from `a` Weibull distribution . With arguments `size`.", "question_id": 4204},
{"snippet": "polynomial.hermite_e.HermiteE.__call__(arg)", "intent": "Call self as a function . With arguments `arg`.", "question_id": 4205},
{"snippet": "fft.irfft2(a, - 1))", "intent": "Computes the inverse of rfft2 . With arguments `a`, `- 1)`.", "question_id": 4206},
{"snippet": "fft.irfft2(a, - 1), s=None)", "intent": "Computes the inverse of rfft2 . With arguments `a`, `- 1)`, `s`.", "question_id": 4207},
{"snippet": "fft.irfft2(a, - 1), axes=(- 2)", "intent": "Computes the inverse of rfft2 . With arguments `a`, `- 1)`, `axes`.", "question_id": 4208},
{"snippet": "fft.irfft2(a, - 1), norm=None)", "intent": "Computes the inverse of rfft2 . With arguments `a`, `- 1)`, `norm`.", "question_id": 4209},
{"snippet": "fft.irfft2(a, - 1), s=None, axes=(- 2)", "intent": "Computes the inverse of rfft2 . With arguments `a`, `- 1)`, `s`, `axes`.", "question_id": 4210},
{"snippet": "fft.irfft2(a, - 1), s=None, norm=None)", "intent": "Computes the inverse of rfft2 . With arguments `a`, `- 1)`, `s`, `norm`.", "question_id": 4211},
{"snippet": "fft.irfft2(a, - 1), axes=(- 2, norm=None)", "intent": "Computes the inverse of rfft2 . With arguments `a`, `- 1)`, `axes`, `norm`.", "question_id": 4212},
{"snippet": "fft.irfft2(a, - 1), s=None, axes=(- 2, norm=None)", "intent": "Computes the inverse of rfft2 . With arguments `a`, `- 1)`, `s`, `axes`, `norm`.", "question_id": 4213},
{"snippet": "ma.getmaskarray(arr)", "intent": "Return the mask of a masked array , or full boolean array of False . Return the mask of `arr` as an ndarray if arr is a MaskedArray and the mask is not nomask , else return a full boolean array of False of the same shape as arr .", "question_id": 4214},
{"snippet": "ma.masked_equal(x, value)", "intent": "Mask an array where equal to a given `value` . This function is a shortcut to masked_where , with condition = ( `x` == value ) .", "question_id": 4215},
{"snippet": "ma.masked_equal(x, value, copy=True)", "intent": "Mask an array where equal to a given `value` . This function is a shortcut to masked_where , with condition = ( `x` == value ) . With arguments `copy`.", "question_id": 4216},
{"snippet": "broadcast.iters", "intent": "tuple of iterators along self\u2019s \u201ccomponents.\u201d", "question_id": 4217},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.cpu_baseline_names()", "intent": "return a list of final CPU baseline feature names", "question_id": 4218},
{"snippet": "random.Generator.standard_t(df)", "intent": "Draw samples from a standard Student \u2019 s t distribution with `df` degrees of freedom .", "question_id": 4219},
{"snippet": "random.Generator.standard_t(df, size=None)", "intent": "Draw samples from a standard Student \u2019 s t distribution with `df` degrees of freedom . With arguments `size`.", "question_id": 4220},
{"snippet": "ma.MaskedArray.ids()", "intent": "Return the addresses of the data and mask areas .", "question_id": 4221},
{"snippet": "ma.MaskedArray.__ipow__(other)", "intent": "Raise self to the power `other` , in place .", "question_id": 4222},
{"snippet": "polynomial.chebyshev.chebinterpolate(func, deg)", "intent": "Interpolate a function at the Chebyshev points of the first kind . Returns the Chebyshev series that interpolates `func` at the Chebyshev points of the first kind in the interval [ -1 , 1 ] . The interpolating series tends to a minmax approximation to func with increasing `deg` if the function is continuous in the interval .", "question_id": 4223},
{"snippet": "polynomial.chebyshev.chebinterpolate(func, deg, args=())", "intent": "Interpolate a function at the Chebyshev points of the first kind . Returns the Chebyshev series that interpolates `func` at the Chebyshev points of the first kind in the interval [ -1 , 1 ] . The interpolating series tends to a minmax approximation to func with increasing `deg` if the function is continuous in the interval . With arguments `args`.", "question_id": 4224},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names()", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler .", "question_id": 4225},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(names=None)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler .", "question_id": 4226},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(force_flags=None)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . With arguments `force_flags`.", "question_id": 4227},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(macros=)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . With arguments `macros`.", "question_id": 4228},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(names=None, force_flags=None)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . With arguments `force_flags`.", "question_id": 4229},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(names=None, macros=)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . With arguments `macros`.", "question_id": 4230},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(force_flags=None, macros=)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . With arguments `force_flags`, `macros`.", "question_id": 4231},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(names=None, force_flags=None, macros=)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . With arguments `force_flags`, `macros`.", "question_id": 4232},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names()", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler .", "question_id": 4233},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(names=None)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler .", "question_id": 4234},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(force_flags=None)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . With arguments `force_flags`.", "question_id": 4235},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(macros=)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . With arguments `macros`.", "question_id": 4236},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(names=None, force_flags=None)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . With arguments `force_flags`.", "question_id": 4237},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(names=None, macros=)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . With arguments `macros`.", "question_id": 4238},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(force_flags=None, macros=)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . With arguments `force_flags`, `macros`.", "question_id": 4239},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(names=None, force_flags=None, macros=)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . With arguments `force_flags`, `macros`.", "question_id": 4240},
{"snippet": "ndarray.tobytes()", "intent": "Construct Python bytes containing the raw data bytes in the array .", "question_id": 4241},
{"snippet": "ndarray.tobytes(order='C')", "intent": "Construct Python bytes containing the raw data bytes in the array . This behavior is controlled by the `order` parameter .", "question_id": 4242},
{"snippet": "chararray.ndim", "intent": "Number of array dimensions.", "question_id": 4243},
{"snippet": "numpy.vdot(a, b)", "intent": "Return the dot product of two vectors . The vdot ( `a` , `b` ) function handles complex numbers differently than dot ( a , b ) .", "question_id": 4244},
{"snippet": "polynomial.polyutils.mapparms(old, new)", "intent": "Linear map parameters between domains . Return the parameters of the linear map offset + scale * x that maps `old` to `new` such that old [ i ] - > new [ i ] , i = 0 , 1 .", "question_id": 4245},
{"snippet": "numpy.common_type(*arrays)", "intent": "Return a scalar type which is common to the input arrays . With arguments `*arrays`.", "question_id": 4246},
{"snippet": "testing.assert_approx_equal(actual, desired)", "intent": "Raises an AssertionError if two items are not equal up to `significant` digits . With arguments `actual`, `desired`.", "question_id": 4247},
{"snippet": "testing.assert_approx_equal(actual, desired, significant=7)", "intent": "Raises an AssertionError if two items are not equal up to `significant` digits . With arguments `actual`, `desired`.", "question_id": 4248},
{"snippet": "testing.assert_approx_equal(actual, desired, err_msg='')", "intent": "Raises an AssertionError if two items are not equal up to `significant` digits . With arguments `actual`, `desired`, `err_msg`.", "question_id": 4249},
{"snippet": "testing.assert_approx_equal(actual, desired, verbose=True)", "intent": "Raises an AssertionError if two items are not equal up to `significant` digits . With arguments `actual`, `desired`, `verbose`.", "question_id": 4250},
{"snippet": "testing.assert_approx_equal(actual, desired, significant=7, err_msg='')", "intent": "Raises an AssertionError if two items are not equal up to `significant` digits . With arguments `actual`, `desired`, `err_msg`.", "question_id": 4251},
{"snippet": "testing.assert_approx_equal(actual, desired, significant=7, verbose=True)", "intent": "Raises an AssertionError if two items are not equal up to `significant` digits . With arguments `actual`, `desired`, `verbose`.", "question_id": 4252},
{"snippet": "testing.assert_approx_equal(actual, desired, err_msg='', verbose=True)", "intent": "Raises an AssertionError if two items are not equal up to `significant` digits . With arguments `actual`, `desired`, `err_msg`, `verbose`.", "question_id": 4253},
{"snippet": "testing.assert_approx_equal(actual, desired, significant=7, err_msg='', verbose=True)", "intent": "Raises an AssertionError if two items are not equal up to `significant` digits . With arguments `actual`, `desired`, `err_msg`, `verbose`.", "question_id": 4254},
{"snippet": "char.chararray.compress(condition)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`.", "question_id": 4255},
{"snippet": "char.chararray.compress(condition, axis=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`.", "question_id": 4256},
{"snippet": "char.chararray.compress(condition, out=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`, `out`.", "question_id": 4257},
{"snippet": "char.chararray.compress(condition, axis=None, out=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`, `out`.", "question_id": 4258},
{"snippet": "core.records.fromarrays(arrayList)", "intent": "Create a record array from a ( flat ) list of arrays With arguments `arrayList`.", "question_id": 4259},
{"snippet": "core.records.fromarrays(arrayList, dtype=None)", "intent": "Create a record array from a ( flat ) list of arrays With arguments `arrayList`, `dtype`.", "question_id": 4260},
{"snippet": "core.records.fromarrays(arrayList, shape=None)", "intent": "Create a record array from a ( flat ) list of arrays With arguments `arrayList`, `shape`.", "question_id": 4261},
{"snippet": "core.records.fromarrays(arrayList, formats=None)", "intent": "Create a record array from a ( flat ) list of arrays With arguments `arrayList`, `formats`.", "question_id": 4262},
{"snippet": "core.records.fromarrays(arrayList, names=None)", "intent": "Create a record array from a ( flat ) list of arrays With arguments `arrayList`, `names`.", "question_id": 4263},
{"snippet": "core.records.fromarrays(arrayList, titles=None)", "intent": "Create a record array from a ( flat ) list of arrays With arguments `arrayList`, `titles`.", "question_id": 4264},
{"snippet": "core.records.fromarrays(arrayList, aligned=False)", "intent": "Create a record array from a ( flat ) list of arrays With arguments `arrayList`, `aligned`.", "question_id": 4265},
{"snippet": "core.records.fromarrays(arrayList, byteorder=None)", "intent": "Create a record array from a ( flat ) list of arrays With arguments `arrayList`, `byteorder`.", "question_id": 4266},
{"snippet": "core.records.fromarrays(arrayList, dtype=None, shape=None)", "intent": "Create a record array from a ( flat ) list of arrays With arguments `arrayList`, `dtype`, `shape`.", "question_id": 4267},
{"snippet": "core.records.fromarrays(arrayList, dtype=None, formats=None)", "intent": "Create a record array from a ( flat ) list of arrays With arguments `arrayList`, `dtype`, `formats`.", "question_id": 4268},
{"snippet": "chararray.any()", "intent": "Returns True if any of the elements of a evaluate to True .", "question_id": 4269},
{"snippet": "chararray.any(axis=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`.", "question_id": 4270},
{"snippet": "chararray.any(out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`.", "question_id": 4271},
{"snippet": "chararray.any(keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `keepdims`.", "question_id": 4272},
{"snippet": "chararray.any(where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `where`.", "question_id": 4273},
{"snippet": "chararray.any(axis=None, out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `out`.", "question_id": 4274},
{"snippet": "chararray.any(axis=None, keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `keepdims`.", "question_id": 4275},
{"snippet": "chararray.any(axis=None, where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `where`.", "question_id": 4276},
{"snippet": "chararray.any(out=None, keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`, `keepdims`.", "question_id": 4277},
{"snippet": "chararray.any(out=None, where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`, `where`.", "question_id": 4278},
{"snippet": "matrix.sum()", "intent": "Returns the sum of the matrix elements , along the given `axis` .", "question_id": 4279},
{"snippet": "matrix.sum(axis=None)", "intent": "Returns the sum of the matrix elements , along the given `axis` .", "question_id": 4280},
{"snippet": "matrix.sum(dtype=None)", "intent": "Returns the sum of the matrix elements , along the given `axis` . With arguments `dtype`.", "question_id": 4281},
{"snippet": "matrix.sum(out=None)", "intent": "Returns the sum of the matrix elements , along the given `axis` . With arguments `out`.", "question_id": 4282},
{"snippet": "matrix.sum(axis=None, dtype=None)", "intent": "Returns the sum of the matrix elements , along the given `axis` . With arguments `dtype`.", "question_id": 4283},
{"snippet": "matrix.sum(axis=None, out=None)", "intent": "Returns the sum of the matrix elements , along the given `axis` . With arguments `out`.", "question_id": 4284},
{"snippet": "matrix.sum(dtype=None, out=None)", "intent": "Returns the sum of the matrix elements , along the given `axis` . With arguments `dtype`, `out`.", "question_id": 4285},
{"snippet": "matrix.sum(axis=None, dtype=None, out=None)", "intent": "Returns the sum of the matrix elements , along the given `axis` . With arguments `dtype`, `out`.", "question_id": 4286},
{"snippet": "matlib.randn(*args)", "intent": "Return a random matrix with data from the \u201c standard normal \u201d distribution . With arguments `*args`.", "question_id": 4287},
{"snippet": "random.RandomState.geometric(p)", "intent": "Draw samples from the geometric distribution . where `p` is the probability of success of an individual trial .", "question_id": 4288},
{"snippet": "random.RandomState.geometric(p, size=None)", "intent": "Draw samples from the geometric distribution . where `p` is the probability of success of an individual trial . With arguments `size`.", "question_id": 4289},
{"snippet": "memmap.fill(value)", "intent": "Fill the array with a scalar `value` .", "question_id": 4290},
{"snippet": "ma.masked_array.argpartition(kth)", "intent": "Returns the indices that would partition this array . With arguments `kth`.", "question_id": 4291},
{"snippet": "ma.masked_array.argpartition(kth, axis=- 1)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`.", "question_id": 4292},
{"snippet": "ma.masked_array.argpartition(kth, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`.", "question_id": 4293},
{"snippet": "ma.masked_array.argpartition(kth, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `order`.", "question_id": 4294},
{"snippet": "ma.masked_array.argpartition(kth, axis=- 1, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`.", "question_id": 4295},
{"snippet": "ma.masked_array.argpartition(kth, axis=- 1, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `order`.", "question_id": 4296},
{"snippet": "ma.masked_array.argpartition(kth, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`, `order`.", "question_id": 4297},
{"snippet": "ma.masked_array.argpartition(kth, axis=- 1, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`, `order`.", "question_id": 4298},
{"snippet": "numpy.may_share_memory(a, b)", "intent": "Determine if two arrays might share memory Only the memory bounds of `a` and `b` are checked by default .", "question_id": 4299},
{"snippet": "numpy.may_share_memory(a, b, max_work=None)", "intent": "Determine if two arrays might share memory Only the memory bounds of `a` and `b` are checked by default . With arguments `max_work`.", "question_id": 4300},
{"snippet": "nditer.remove_axis(i)", "intent": "Removes axis `i` from the iterator .", "question_id": 4301},
{"snippet": "core.records.array(obj)", "intent": "Construct a record array from a wide-variety of objects . If `obj` is None , then call the recarray constructor .", "question_id": 4302},
{"snippet": "core.records.array(obj, dtype=None)", "intent": "Construct a record array from a wide-variety of objects . If `obj` is None , then call the recarray constructor . With arguments `dtype`.", "question_id": 4303},
{"snippet": "core.records.array(obj, shape=None)", "intent": "Construct a record array from a wide-variety of objects . If `obj` is None , then call the recarray constructor . With arguments `shape`.", "question_id": 4304},
{"snippet": "core.records.array(obj, offset=0)", "intent": "Construct a record array from a wide-variety of objects . If `obj` is None , then call the recarray constructor . With arguments `offset`.", "question_id": 4305},
{"snippet": "core.records.array(obj, strides=None)", "intent": "Construct a record array from a wide-variety of objects . If `obj` is None , then call the recarray constructor . With arguments `strides`.", "question_id": 4306},
{"snippet": "core.records.array(obj, formats=None)", "intent": "Construct a record array from a wide-variety of objects . If `obj` is None , then call the recarray constructor . If obj is a recarray , then make a `copy` of the data in the recarray ( if copy=True ) and use the new `formats` , `names` , and `titles` .", "question_id": 4307},
{"snippet": "core.records.array(obj, names=None)", "intent": "Construct a record array from a wide-variety of objects . If `obj` is None , then call the recarray constructor . If obj is a recarray , then make a `copy` of the data in the recarray ( if copy=True ) and use the new `formats` , `names` , and `titles` .", "question_id": 4308},
{"snippet": "core.records.array(obj, titles=None)", "intent": "Construct a record array from a wide-variety of objects . If `obj` is None , then call the recarray constructor . If obj is a recarray , then make a `copy` of the data in the recarray ( if copy=True ) and use the new `formats` , `names` , and `titles` .", "question_id": 4309},
{"snippet": "core.records.array(obj, aligned=False)", "intent": "Construct a record array from a wide-variety of objects . If `obj` is None , then call the recarray constructor . With arguments `aligned`.", "question_id": 4310},
{"snippet": "core.records.array(obj, byteorder=None)", "intent": "Construct a record array from a wide-variety of objects . If `obj` is None , then call the recarray constructor . With arguments `byteorder`.", "question_id": 4311},
{"snippet": "ma.asarray(a)", "intent": "Convert the input to `a` masked array of the given data-type .", "question_id": 4312},
{"snippet": "ma.asarray(a, dtype=None)", "intent": "Convert the input to `a` masked array of the given data-type . With arguments `dtype`.", "question_id": 4313},
{"snippet": "ma.asarray(a, order=None)", "intent": "Convert the input to `a` masked array of the given data-type . With arguments `order`.", "question_id": 4314},
{"snippet": "ma.asarray(a, dtype=None, order=None)", "intent": "Convert the input to `a` masked array of the given data-type . With arguments `dtype`, `order`.", "question_id": 4315},
{"snippet": "numpy.trunc(x, /, signature, extobj)", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `extobj`.", "question_id": 4316},
{"snippet": "numpy.trunc(x, /, signature, extobj, out=None)", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 4317},
{"snippet": "numpy.trunc(x, /, signature, extobj, where=True)", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 4318},
{"snippet": "numpy.trunc(x, /, signature, extobj, casting='same_kind')", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 4319},
{"snippet": "numpy.trunc(x, /, signature, extobj, order='K')", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 4320},
{"snippet": "numpy.trunc(x, /, signature, extobj, dtype=None)", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 4321},
{"snippet": "numpy.trunc(x, /, signature, extobj, subok=True)", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 4322},
{"snippet": "numpy.trunc(x, /, signature, extobj, out=None, where=True)", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 4323},
{"snippet": "numpy.trunc(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 4324},
{"snippet": "numpy.trunc(x, /, signature, extobj, out=None, order='K')", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 4325},
{"snippet": "numpy.trunc(x, /, signature)", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`.", "question_id": 4326},
{"snippet": "numpy.trunc(x, /, signature, out=None)", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `out`.", "question_id": 4327},
{"snippet": "numpy.trunc(x, /, signature, where=True)", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `where`.", "question_id": 4328},
{"snippet": "numpy.trunc(x, /, signature, casting='same_kind')", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `casting`.", "question_id": 4329},
{"snippet": "numpy.trunc(x, /, signature, order='K')", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `order`.", "question_id": 4330},
{"snippet": "numpy.trunc(x, /, signature, dtype=None)", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `dtype`.", "question_id": 4331},
{"snippet": "numpy.trunc(x, /, signature, subok=True)", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `subok`.", "question_id": 4332},
{"snippet": "numpy.trunc(x, /, signature, out=None, where=True)", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `out`, `where`.", "question_id": 4333},
{"snippet": "numpy.trunc(x, /, signature, out=None, casting='same_kind')", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 4334},
{"snippet": "numpy.trunc(x, /, signature, out=None, order='K')", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `out`, `order`.", "question_id": 4335},
{"snippet": "chararray.count(sub)", "intent": "Returns an array with the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] .", "question_id": 4336},
{"snippet": "chararray.count(sub, start=0)", "intent": "Returns an array with the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] .", "question_id": 4337},
{"snippet": "chararray.count(sub, end=None)", "intent": "Returns an array with the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] .", "question_id": 4338},
{"snippet": "chararray.count(sub, start=0, end=None)", "intent": "Returns an array with the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] .", "question_id": 4339},
{"snippet": "polynomial.hermite.hermfit(x, y, deg)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a Hermite series of degree `deg` that is the least squares fit to the data values `y` given at points `x` .", "question_id": 4340},
{"snippet": "polynomial.hermite.hermfit(x, y, deg, rcond=None)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a Hermite series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error .", "question_id": 4341},
{"snippet": "polynomial.hermite.hermfit(x, y, deg, full=False)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a Hermite series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . With arguments `full`.", "question_id": 4342},
{"snippet": "polynomial.hermite.hermfit(x, y, deg, w=None)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a Hermite series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , y are the observed values .", "question_id": 4343},
{"snippet": "polynomial.hermite.hermfit(x, y, deg, rcond=None, full=False)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a Hermite series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . With arguments `full`.", "question_id": 4344},
{"snippet": "polynomial.hermite.hermfit(x, y, deg, rcond=None, w=None)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a Hermite series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , y are the observed values .", "question_id": 4345},
{"snippet": "polynomial.hermite.hermfit(x, y, deg, full=False, w=None)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a Hermite series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , y are the observed values . With arguments `full`.", "question_id": 4346},
{"snippet": "polynomial.hermite.hermfit(x, y, deg, rcond=None, full=False, w=None)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a Hermite series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , y are the observed values . With arguments `full`.", "question_id": 4347},
{"snippet": "memmap.T", "intent": "The transposed array.", "question_id": 4348},
{"snippet": "record.newbyteorder(/)", "intent": "Return a new dtype with a different byte order . With arguments `/`.", "question_id": 4349},
{"snippet": "record.newbyteorder(/, new_order='S')", "intent": "Return a new dtype with a different byte order . The `new_order` code can be any from the following : With arguments `/`.", "question_id": 4350},
{"snippet": "numpy.ufunc", "intent": "Functions that operate element by element on whole arrays.", "question_id": 4351},
{"snippet": "numpy.DataSource()", "intent": "A generic data source file ( file , http , ftp , \u2026 ) .", "question_id": 4352},
{"snippet": "numpy.DataSource(destpath='.')", "intent": "A generic data source file ( file , http , ftp , \u2026 ) . With arguments `destpath`.", "question_id": 4353},
{"snippet": "generic.__reduce__()", "intent": "Helper for pickle .", "question_id": 4354},
{"snippet": "ma.MaskedArray.fill(value)", "intent": "Fill the array with a scalar `value` .", "question_id": 4355},
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, extobj)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`.", "question_id": 4356},
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, extobj, out=(None)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `out`.", "question_id": 4357},
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, extobj, where=True)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `where`.", "question_id": 4358},
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, extobj, casting='same_kind')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `casting`.", "question_id": 4359},
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, extobj, order='K')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `order`.", "question_id": 4360},
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, extobj, dtype=None)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `dtype`.", "question_id": 4361},
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, extobj, subok=True)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `subok`.", "question_id": 4362},
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, extobj, out=(None, where=True)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `out`, `where`.", "question_id": 4363},
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, extobj, out=(None, casting='same_kind')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `out`, `casting`.", "question_id": 4364},
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, extobj, out=(None, order='K')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `out`, `order`.", "question_id": 4365},
{"snippet": "numpy.modf(x, out1, out2, /, None), signature)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`.", "question_id": 4366},
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, out=(None)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `out`.", "question_id": 4367},
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, where=True)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `where`.", "question_id": 4368},
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, casting='same_kind')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `casting`.", "question_id": 4369},
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, order='K')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `order`.", "question_id": 4370},
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, dtype=None)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `dtype`.", "question_id": 4371},
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, subok=True)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `subok`.", "question_id": 4372},
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, out=(None, where=True)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `out`, `where`.", "question_id": 4373},
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, out=(None, casting='same_kind')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `out`, `casting`.", "question_id": 4374},
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, out=(None, order='K')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `out`, `order`.", "question_id": 4375},
{"snippet": "numpy.modf(x, out1, out2, /, None))", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`.", "question_id": 4376},
{"snippet": "numpy.modf(x, out1, out2, /, None), out=(None)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `out`.", "question_id": 4377},
{"snippet": "numpy.modf(x, out1, out2, /, None), where=True)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `where`.", "question_id": 4378},
{"snippet": "numpy.modf(x, out1, out2, /, None), casting='same_kind')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `casting`.", "question_id": 4379},
{"snippet": "numpy.modf(x, out1, out2, /, None), order='K')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `order`.", "question_id": 4380},
{"snippet": "numpy.modf(x, out1, out2, /, None), dtype=None)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `dtype`.", "question_id": 4381},
{"snippet": "numpy.modf(x, out1, out2, /, None), subok=True)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `subok`.", "question_id": 4382},
{"snippet": "numpy.modf(x, out1, out2, /, None), out=(None, where=True)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `out`, `where`.", "question_id": 4383},
{"snippet": "numpy.modf(x, out1, out2, /, None), out=(None, casting='same_kind')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `out`, `casting`.", "question_id": 4384},
{"snippet": "numpy.modf(x, out1, out2, /, None), out=(None, order='K')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `out`, `order`.", "question_id": 4385},
{"snippet": "numpy.modf(x, out1, out2, /)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`.", "question_id": 4386},
{"snippet": "numpy.modf(x, out1, out2, /, out=(None)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `out`.", "question_id": 4387},
{"snippet": "numpy.modf(x, out1, out2, /, where=True)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `where`.", "question_id": 4388},
{"snippet": "numpy.modf(x, out1, out2, /, casting='same_kind')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `casting`.", "question_id": 4389},
{"snippet": "numpy.modf(x, out1, out2, /, order='K')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `order`.", "question_id": 4390},
{"snippet": "numpy.modf(x, out1, out2, /, dtype=None)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `dtype`.", "question_id": 4391},
{"snippet": "numpy.modf(x, out1, out2, /, subok=True)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `subok`.", "question_id": 4392},
{"snippet": "numpy.modf(x, out1, out2, /, out=(None, where=True)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `out`, `where`.", "question_id": 4393},
{"snippet": "numpy.modf(x, out1, out2, /, out=(None, casting='same_kind')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `out`, `casting`.", "question_id": 4394},
{"snippet": "numpy.modf(x, out1, out2, /, out=(None, order='K')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `out`, `order`.", "question_id": 4395},
{"snippet": "numpy.insert(arr, obj, values)", "intent": "Insert `values` along the given `axis` before the given indices . Note that for higher dimensional inserts obj=0 behaves very different from obj= [ 0 ] just like `arr` [ : ,0 , : ] = values is different from arr [ : , [ 0 ] , : ] = values . With arguments `obj`.", "question_id": 4396},
{"snippet": "numpy.insert(arr, obj, values, axis=None)", "intent": "Insert `values` along the given `axis` before the given indices . Note that for higher dimensional inserts obj=0 behaves very different from obj= [ 0 ] just like `arr` [ : ,0 , : ] = values is different from arr [ : , [ 0 ] , : ] = values . With arguments `obj`.", "question_id": 4397},
{"snippet": "numpy.isposinf(x)", "intent": "Test element-wise for positive infinity , return result as bool array . Errors result if the second argument is also supplied when `x` is a scalar input , if first and second arguments have different shapes , or if the first argument has complex values", "question_id": 4398},
{"snippet": "numpy.isposinf(x, out=None)", "intent": "Test element-wise for positive infinity , return result as bool array . Errors result if the second argument is also supplied when `x` is a scalar input , if first and second arguments have different shapes , or if the first argument has complex values With arguments `out`.", "question_id": 4399},
{"snippet": "ma.allequal(a, b)", "intent": "Return True if all entries of `a` and `b` are equal , using `fill_value` as a truth value where either or both are masked .", "question_id": 4400},
{"snippet": "ma.allequal(a, b, fill_value=True)", "intent": "Return True if all entries of `a` and `b` are equal , using `fill_value` as a truth value where either or both are masked .", "question_id": 4401},
{"snippet": "ma.MaskedArray.cumsum()", "intent": "Return the cumulative sum of the array elements over the given `axis` .", "question_id": 4402},
{"snippet": "ma.MaskedArray.cumsum(axis=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` .", "question_id": 4403},
{"snippet": "ma.MaskedArray.cumsum(dtype=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 4404},
{"snippet": "ma.MaskedArray.cumsum(out=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . The mask is lost if `out` is not a valid ma.MaskedArray !", "question_id": 4405},
{"snippet": "ma.MaskedArray.cumsum(axis=None, dtype=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 4406},
{"snippet": "ma.MaskedArray.cumsum(axis=None, out=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . The mask is lost if `out` is not a valid ma.MaskedArray !", "question_id": 4407},
{"snippet": "ma.MaskedArray.cumsum(dtype=None, out=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . The mask is lost if `out` is not a valid ma.MaskedArray ! With arguments `dtype`.", "question_id": 4408},
{"snippet": "ma.MaskedArray.cumsum(axis=None, dtype=None, out=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . The mask is lost if `out` is not a valid ma.MaskedArray ! With arguments `dtype`.", "question_id": 4409},
{"snippet": "numpy.finfo(dtype)", "intent": "Machine limits for floating point types . With arguments `dtype`.", "question_id": 4410},
{"snippet": "random.Generator.wald(mean, scale)", "intent": "Draw samples from a Wald , or inverse Gaussian , distribution . Some references claim that the Wald is an inverse Gaussian with `mean` equal to 1 , but this is by no means universal . As the `scale` approaches infinity , the distribution becomes more like a Gaussian .", "question_id": 4411},
{"snippet": "random.Generator.wald(mean, scale, size=None)", "intent": "Draw samples from a Wald , or inverse Gaussian , distribution . Some references claim that the Wald is an inverse Gaussian with `mean` equal to 1 , but this is by no means universal . As the `scale` approaches infinity , the distribution becomes more like a Gaussian . With arguments `size`.", "question_id": 4412},
{"snippet": "numpy.MachAr()", "intent": "Diagnosing machine parameters .", "question_id": 4413},
{"snippet": "numpy.MachAr(float_conv=<class 'float'>)", "intent": "Diagnosing machine parameters . With arguments `float_conv`.", "question_id": 4414},
{"snippet": "numpy.MachAr(int_conv=<class 'int'>)", "intent": "Diagnosing machine parameters . With arguments `int_conv`.", "question_id": 4415},
{"snippet": "numpy.MachAr(float_to_float=<class 'float'>)", "intent": "Diagnosing machine parameters . With arguments `float_to_float`.", "question_id": 4416},
{"snippet": "numpy.MachAr(float_to_str=<function MachAr.<lambda>>)", "intent": "Diagnosing machine parameters . With arguments `float_to_str`.", "question_id": 4417},
{"snippet": "numpy.MachAr(title='Python floating point number')", "intent": "Diagnosing machine parameters . With arguments `title`.", "question_id": 4418},
{"snippet": "numpy.MachAr(float_conv=<class 'float'>, int_conv=<class 'int'>)", "intent": "Diagnosing machine parameters . With arguments `float_conv`, `int_conv`.", "question_id": 4419},
{"snippet": "numpy.MachAr(float_conv=<class 'float'>, float_to_float=<class 'float'>)", "intent": "Diagnosing machine parameters . With arguments `float_conv`, `float_to_float`.", "question_id": 4420},
{"snippet": "numpy.MachAr(float_conv=<class 'float'>, float_to_str=<function MachAr.<lambda>>)", "intent": "Diagnosing machine parameters . With arguments `float_conv`, `float_to_str`.", "question_id": 4421},
{"snippet": "numpy.MachAr(float_conv=<class 'float'>, title='Python floating point number')", "intent": "Diagnosing machine parameters . With arguments `float_conv`, `title`.", "question_id": 4422},
{"snippet": "generic.real", "intent": "The real part of the scalar.", "question_id": 4423},
{"snippet": "random.Generator.logistic()", "intent": "Draw samples from a logistic distribution .", "question_id": 4424},
{"snippet": "random.Generator.logistic(loc=0.0)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) .", "question_id": 4425},
{"snippet": "random.Generator.logistic(scale=1.0)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) .", "question_id": 4426},
{"snippet": "random.Generator.logistic(size=None)", "intent": "Draw samples from a logistic distribution . With arguments `size`.", "question_id": 4427},
{"snippet": "random.Generator.logistic(loc=0.0, scale=1.0)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) .", "question_id": 4428},
{"snippet": "random.Generator.logistic(loc=0.0, size=None)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . With arguments `size`.", "question_id": 4429},
{"snippet": "random.Generator.logistic(scale=1.0, size=None)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . With arguments `size`.", "question_id": 4430},
{"snippet": "random.Generator.logistic(loc=0.0, scale=1.0, size=None)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . With arguments `size`.", "question_id": 4431},
{"snippet": "record.strides", "intent": "Tuple of bytes steps in each dimension.", "question_id": 4432},
{"snippet": "record.take()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 4433},
{"snippet": "memmap.setflags()", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively .", "question_id": 4434},
{"snippet": "memmap.setflags(write=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`.", "question_id": 4435},
{"snippet": "memmap.setflags(align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`.", "question_id": 4436},
{"snippet": "memmap.setflags(uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `uic`.", "question_id": 4437},
{"snippet": "memmap.setflags(write=None, align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`.", "question_id": 4438},
{"snippet": "memmap.setflags(write=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `uic`.", "question_id": 4439},
{"snippet": "memmap.setflags(align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`, `uic`.", "question_id": 4440},
{"snippet": "memmap.setflags(write=None, align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`, `uic`.", "question_id": 4441},
{"snippet": "polynomial.hermite.hermval3d(x, y, z, c)", "intent": "Evaluate a 3-D Hermite series at points ( `x` , `y` , `z` ) . In either case , either x , y , and z or their elements must support multiplication and addition both with themselves and with the elements of `c` .", "question_id": 4442},
{"snippet": "numpy.rint(x, /, signature, extobj)", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `extobj`.", "question_id": 4443},
{"snippet": "numpy.rint(x, /, signature, extobj, out=None)", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `extobj`, `out`.", "question_id": 4444},
{"snippet": "numpy.rint(x, /, signature, extobj, where=True)", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `extobj`, `where`.", "question_id": 4445},
{"snippet": "numpy.rint(x, /, signature, extobj, casting='same_kind')", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `extobj`, `casting`.", "question_id": 4446},
{"snippet": "numpy.rint(x, /, signature, extobj, order='K')", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `extobj`, `order`.", "question_id": 4447},
{"snippet": "numpy.rint(x, /, signature, extobj, dtype=None)", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `extobj`, `dtype`.", "question_id": 4448},
{"snippet": "numpy.rint(x, /, signature, extobj, subok=True)", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `extobj`, `subok`.", "question_id": 4449},
{"snippet": "numpy.rint(x, /, signature, extobj, out=None, where=True)", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 4450},
{"snippet": "numpy.rint(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 4451},
{"snippet": "numpy.rint(x, /, signature, extobj, out=None, order='K')", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 4452},
{"snippet": "numpy.rint(x, /, signature)", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`.", "question_id": 4453},
{"snippet": "numpy.rint(x, /, signature, out=None)", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `out`.", "question_id": 4454},
{"snippet": "numpy.rint(x, /, signature, where=True)", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `where`.", "question_id": 4455},
{"snippet": "numpy.rint(x, /, signature, casting='same_kind')", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `casting`.", "question_id": 4456},
{"snippet": "numpy.rint(x, /, signature, order='K')", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `order`.", "question_id": 4457},
{"snippet": "numpy.rint(x, /, signature, dtype=None)", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `dtype`.", "question_id": 4458},
{"snippet": "numpy.rint(x, /, signature, subok=True)", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `subok`.", "question_id": 4459},
{"snippet": "numpy.rint(x, /, signature, out=None, where=True)", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `out`, `where`.", "question_id": 4460},
{"snippet": "numpy.rint(x, /, signature, out=None, casting='same_kind')", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `out`, `casting`.", "question_id": 4461},
{"snippet": "numpy.rint(x, /, signature, out=None, order='K')", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `out`, `order`.", "question_id": 4462},
{"snippet": "ma.MaskedArray.transpose(*axes)", "intent": "Returns a view of the array with axes transposed . With arguments `*axes`.", "question_id": 4463},
{"snippet": "recarray.compress(condition)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`.", "question_id": 4464},
{"snippet": "recarray.compress(condition, axis=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`.", "question_id": 4465},
{"snippet": "recarray.compress(condition, out=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`, `out`.", "question_id": 4466},
{"snippet": "recarray.compress(condition, axis=None, out=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`, `out`.", "question_id": 4467},
{"snippet": "chararray.dumps()", "intent": "Returns the pickle of the array as a string .", "question_id": 4468},
{"snippet": "memmap.ndim", "intent": "Number of array dimensions.", "question_id": 4469},
{"snippet": "char.capitalize(a)", "intent": "Return `a` copy of a with only the first character of each element capitalized .", "question_id": 4470},
{"snippet": "char.splitlines(a)", "intent": "For each element in `a` , return a list of the lines in the element , breaking at line boundaries .", "question_id": 4471},
{"snippet": "char.splitlines(a, keepends=None)", "intent": "For each element in `a` , return a list of the lines in the element , breaking at line boundaries . With arguments `keepends`.", "question_id": 4472},
{"snippet": "ndarray.argmin()", "intent": "Return indices of the minimum values along the given `axis` .", "question_id": 4473},
{"snippet": "ndarray.argmin(axis=None)", "intent": "Return indices of the minimum values along the given `axis` .", "question_id": 4474},
{"snippet": "ndarray.argmin(out=None)", "intent": "Return indices of the minimum values along the given `axis` . With arguments `out`.", "question_id": 4475},
{"snippet": "ndarray.argmin(axis=None, out=None)", "intent": "Return indices of the minimum values along the given `axis` . With arguments `out`.", "question_id": 4476},
{"snippet": "ndarray.sort()", "intent": "Sort an array in-place .", "question_id": 4477},
{"snippet": "ndarray.sort(axis=- 1)", "intent": "Sort an array in-place . With arguments `axis`.", "question_id": 4478},
{"snippet": "ndarray.sort(kind=None)", "intent": "Sort an array in-place . With arguments `kind`.", "question_id": 4479},
{"snippet": "ndarray.sort(order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array :", "question_id": 4480},
{"snippet": "ndarray.sort(axis=- 1, kind=None)", "intent": "Sort an array in-place . With arguments `axis`, `kind`.", "question_id": 4481},
{"snippet": "ndarray.sort(axis=- 1, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `axis`.", "question_id": 4482},
{"snippet": "ndarray.sort(kind=None, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `kind`.", "question_id": 4483},
{"snippet": "ndarray.sort(axis=- 1, kind=None, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `axis`, `kind`.", "question_id": 4484},
{"snippet": "fft.irfft(a)", "intent": "Computes the inverse of rfft . In other words , irfft ( rfft ( `a` ) , len ( a ) ) == a to within numerical accuracy .", "question_id": 4485},
{"snippet": "fft.irfft(a, n=None)", "intent": "Computes the inverse of rfft . In other words , irfft ( rfft ( `a` ) , len ( a ) ) == a to within numerical accuracy . `n` is the length of the result , not the input .", "question_id": 4486},
{"snippet": "fft.irfft(a, axis=- 1)", "intent": "Computes the inverse of rfft . In other words , irfft ( rfft ( `a` ) , len ( a ) ) == a to within numerical accuracy . With arguments `axis`.", "question_id": 4487},
{"snippet": "fft.irfft(a, norm=None)", "intent": "Computes the inverse of rfft . In other words , irfft ( rfft ( `a` ) , len ( a ) ) == a to within numerical accuracy . With arguments `norm`.", "question_id": 4488},
{"snippet": "fft.irfft(a, n=None, axis=- 1)", "intent": "Computes the inverse of rfft . In other words , irfft ( rfft ( `a` ) , len ( a ) ) == a to within numerical accuracy . `n` is the length of the result , not the input . With arguments `axis`.", "question_id": 4489},
{"snippet": "fft.irfft(a, n=None, norm=None)", "intent": "Computes the inverse of rfft . In other words , irfft ( rfft ( `a` ) , len ( a ) ) == a to within numerical accuracy . `n` is the length of the result , not the input . With arguments `norm`.", "question_id": 4490},
{"snippet": "fft.irfft(a, axis=- 1, norm=None)", "intent": "Computes the inverse of rfft . In other words , irfft ( rfft ( `a` ) , len ( a ) ) == a to within numerical accuracy . With arguments `axis`, `norm`.", "question_id": 4491},
{"snippet": "fft.irfft(a, n=None, axis=- 1, norm=None)", "intent": "Computes the inverse of rfft . In other words , irfft ( rfft ( `a` ) , len ( a ) ) == a to within numerical accuracy . `n` is the length of the result , not the input . With arguments `axis`, `norm`.", "question_id": 4492},
{"snippet": "ma.MaskedArray.__iand__(value, /)", "intent": "Return self & =value . With arguments `value`, `/`.", "question_id": 4493},
{"snippet": "numpy.asmatrix(data)", "intent": "Interpret the input as a matrix . Equivalent to matrix ( `data` , copy=False ) .", "question_id": 4494},
{"snippet": "numpy.asmatrix(data, dtype=None)", "intent": "Interpret the input as a matrix . Equivalent to matrix ( `data` , copy=False ) . With arguments `dtype`.", "question_id": 4495},
{"snippet": "char.chararray.nbytes", "intent": "Total bytes consumed by the elements of the array.", "question_id": 4496},
{"snippet": "ma.make_mask_none(newshape)", "intent": "Return a boolean mask of the given shape , filled with False . With arguments `newshape`.", "question_id": 4497},
{"snippet": "ma.make_mask_none(newshape, dtype=None)", "intent": "Return a boolean mask of the given shape , filled with False . If a complex `dtype` is specified , the type of each field is converted to a boolean type . With arguments `newshape`.", "question_id": 4498},
{"snippet": "numpy.apply_over_axes(func, a, axes)", "intent": "Apply `a` function repeatedly over multiple `axes` . `func` is called as res = func ( a , axis ) , where axis is the first element of axes .", "question_id": 4499},
{"snippet": "numpy.triu(m)", "intent": "Upper triangle of an array . With arguments `m`.", "question_id": 4500},
{"snippet": "numpy.triu(m, k=0)", "intent": "Upper triangle of an array . With arguments `m`, `k`.", "question_id": 4501},
{"snippet": "chararray.searchsorted(v)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order .", "question_id": 4502},
{"snippet": "chararray.searchsorted(v, side='left')", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`.", "question_id": 4503},
{"snippet": "chararray.searchsorted(v, sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `sorter`.", "question_id": 4504},
{"snippet": "chararray.searchsorted(v, side='left', sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`, `sorter`.", "question_id": 4505},
{"snippet": "random.RandomState.negative_binomial(n, p)", "intent": "Draw samples from a negative binomial distribution . Samples are drawn from a negative binomial distribution with specified parameters , `n` successes and `p` probability of success where n is > 0 and p is in the interval [ 0 , 1 ] .", "question_id": 4506},
{"snippet": "random.RandomState.negative_binomial(n, p, size=None)", "intent": "Draw samples from a negative binomial distribution . Samples are drawn from a negative binomial distribution with specified parameters , `n` successes and `p` probability of success where n is > 0 and p is in the interval [ 0 , 1 ] . With arguments `size`.", "question_id": 4507},
{"snippet": "chararray.ptp()", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` .", "question_id": 4508},
{"snippet": "chararray.ptp(axis=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` .", "question_id": 4509},
{"snippet": "chararray.ptp(out=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`.", "question_id": 4510},
{"snippet": "chararray.ptp(keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `keepdims`.", "question_id": 4511},
{"snippet": "chararray.ptp(axis=None, out=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`.", "question_id": 4512},
{"snippet": "chararray.ptp(axis=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `keepdims`.", "question_id": 4513},
{"snippet": "chararray.ptp(out=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`, `keepdims`.", "question_id": 4514},
{"snippet": "chararray.ptp(axis=None, out=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`, `keepdims`.", "question_id": 4515},
{"snippet": "polynomial.hermite_e.hermefit(x, y, deg)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a HermiteE series of degree `deg` that is the least squares fit to the data values `y` given at points `x` .", "question_id": 4516},
{"snippet": "polynomial.hermite_e.hermefit(x, y, deg, rcond=None)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a HermiteE series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error .", "question_id": 4517},
{"snippet": "polynomial.hermite_e.hermefit(x, y, deg, full=False)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a HermiteE series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . With arguments `full`.", "question_id": 4518},
{"snippet": "polynomial.hermite_e.hermefit(x, y, deg, w=None)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a HermiteE series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . Fits using HermiteE series are probably most useful when the data can be approximated by sqrt ( `w` ( x ) ) * p ( x ) , where w ( x ) is the HermiteE weight .", "question_id": 4519},
{"snippet": "polynomial.hermite_e.hermefit(x, y, deg, rcond=None, full=False)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a HermiteE series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . With arguments `full`.", "question_id": 4520},
{"snippet": "polynomial.hermite_e.hermefit(x, y, deg, rcond=None, w=None)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a HermiteE series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . Fits using HermiteE series are probably most useful when the data can be approximated by sqrt ( `w` ( x ) ) * p ( x ) , where w ( x ) is the HermiteE weight .", "question_id": 4521},
{"snippet": "polynomial.hermite_e.hermefit(x, y, deg, full=False, w=None)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a HermiteE series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . Fits using HermiteE series are probably most useful when the data can be approximated by sqrt ( `w` ( x ) ) * p ( x ) , where w ( x ) is the HermiteE weight . With arguments `full`.", "question_id": 4522},
{"snippet": "polynomial.hermite_e.hermefit(x, y, deg, rcond=None, full=False, w=None)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a HermiteE series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . Fits using HermiteE series are probably most useful when the data can be approximated by sqrt ( `w` ( x ) ) * p ( x ) , where w ( x ) is the HermiteE weight . With arguments `full`.", "question_id": 4523},
{"snippet": "random.standard_cauchy()", "intent": "Draw samples from a standard Cauchy distribution with mode = 0 .", "question_id": 4524},
{"snippet": "random.standard_cauchy(size=None)", "intent": "Draw samples from a standard Cauchy distribution with mode = 0 . With arguments `size`.", "question_id": 4525},
{"snippet": "polynomial.laguerre.Laguerre.copy()", "intent": "Return a copy .", "question_id": 4526},
{"snippet": "distutils.ccompiler.simple_version_match()", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler .", "question_id": 4527},
{"snippet": "distutils.ccompiler.simple_version_match(pat='-.\\\\d+')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `pat`.", "question_id": 4528},
{"snippet": "distutils.ccompiler.simple_version_match(ignore='')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `ignore`.", "question_id": 4529},
{"snippet": "distutils.ccompiler.simple_version_match(start='')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `start`.", "question_id": 4530},
{"snippet": "distutils.ccompiler.simple_version_match(pat='-.\\\\d+', ignore='')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `pat`, `ignore`.", "question_id": 4531},
{"snippet": "distutils.ccompiler.simple_version_match(pat='-.\\\\d+', start='')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `pat`, `start`.", "question_id": 4532},
{"snippet": "distutils.ccompiler.simple_version_match(ignore='', start='')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `ignore`, `start`.", "question_id": 4533},
{"snippet": "distutils.ccompiler.simple_version_match(pat='-.\\\\d+', ignore='', start='')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `pat`, `ignore`, `start`.", "question_id": 4534},
{"snippet": "distutils.ccompiler.simple_version_match()", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler .", "question_id": 4535},
{"snippet": "distutils.ccompiler.simple_version_match(pat='-.\\\\d+')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `pat`.", "question_id": 4536},
{"snippet": "distutils.ccompiler.simple_version_match(ignore='')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `ignore`.", "question_id": 4537},
{"snippet": "distutils.ccompiler.simple_version_match(start='')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `start`.", "question_id": 4538},
{"snippet": "distutils.ccompiler.simple_version_match(pat='-.\\\\d+', ignore='')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `pat`, `ignore`.", "question_id": 4539},
{"snippet": "distutils.ccompiler.simple_version_match(pat='-.\\\\d+', start='')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `pat`, `start`.", "question_id": 4540},
{"snippet": "distutils.ccompiler.simple_version_match(ignore='', start='')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `ignore`, `start`.", "question_id": 4541},
{"snippet": "distutils.ccompiler.simple_version_match(pat='-.\\\\d+', ignore='', start='')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `pat`, `ignore`, `start`.", "question_id": 4542},
{"snippet": "char.chararray.tobytes()", "intent": "Construct Python bytes containing the raw data bytes in the array .", "question_id": 4543},
{"snippet": "char.chararray.tobytes(order='C')", "intent": "Construct Python bytes containing the raw data bytes in the array . This behavior is controlled by the `order` parameter .", "question_id": 4544},
{"snippet": "random.RandomState.lognormal()", "intent": "Draw samples from a log-normal distribution .", "question_id": 4545},
{"snippet": "random.RandomState.lognormal(mean=0.0)", "intent": "Draw samples from a log-normal distribution . Draw samples from a log-normal distribution with specified `mean` , standard deviation , and array shape .", "question_id": 4546},
{"snippet": "random.RandomState.lognormal(sigma=1.0)", "intent": "Draw samples from a log-normal distribution . With arguments `sigma`.", "question_id": 4547},
{"snippet": "random.RandomState.lognormal(size=None)", "intent": "Draw samples from a log-normal distribution . With arguments `size`.", "question_id": 4548},
{"snippet": "random.RandomState.lognormal(mean=0.0, sigma=1.0)", "intent": "Draw samples from a log-normal distribution . Draw samples from a log-normal distribution with specified `mean` , standard deviation , and array shape . With arguments `sigma`.", "question_id": 4549},
{"snippet": "random.RandomState.lognormal(mean=0.0, size=None)", "intent": "Draw samples from a log-normal distribution . Draw samples from a log-normal distribution with specified `mean` , standard deviation , and array shape . With arguments `size`.", "question_id": 4550},
{"snippet": "random.RandomState.lognormal(sigma=1.0, size=None)", "intent": "Draw samples from a log-normal distribution . With arguments `sigma`, `size`.", "question_id": 4551},
{"snippet": "random.RandomState.lognormal(mean=0.0, sigma=1.0, size=None)", "intent": "Draw samples from a log-normal distribution . Draw samples from a log-normal distribution with specified `mean` , standard deviation , and array shape . With arguments `sigma`, `size`.", "question_id": 4552},
{"snippet": "numpy.log1p(x, /, signature, extobj)", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `extobj`.", "question_id": 4553},
{"snippet": "numpy.log1p(x, /, signature, extobj, out=None)", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 4554},
{"snippet": "numpy.log1p(x, /, signature, extobj, where=True)", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 4555},
{"snippet": "numpy.log1p(x, /, signature, extobj, casting='same_kind')", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 4556},
{"snippet": "numpy.log1p(x, /, signature, extobj, order='K')", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 4557},
{"snippet": "numpy.log1p(x, /, signature, extobj, dtype=None)", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 4558},
{"snippet": "numpy.log1p(x, /, signature, extobj, subok=True)", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 4559},
{"snippet": "numpy.log1p(x, /, signature, extobj, out=None, where=True)", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 4560},
{"snippet": "numpy.log1p(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 4561},
{"snippet": "numpy.log1p(x, /, signature, extobj, out=None, order='K')", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 4562},
{"snippet": "numpy.log1p(x, /, signature)", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`.", "question_id": 4563},
{"snippet": "numpy.log1p(x, /, signature, out=None)", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `out`.", "question_id": 4564},
{"snippet": "numpy.log1p(x, /, signature, where=True)", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `where`.", "question_id": 4565},
{"snippet": "numpy.log1p(x, /, signature, casting='same_kind')", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `casting`.", "question_id": 4566},
{"snippet": "numpy.log1p(x, /, signature, order='K')", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `order`.", "question_id": 4567},
{"snippet": "numpy.log1p(x, /, signature, dtype=None)", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `dtype`.", "question_id": 4568},
{"snippet": "numpy.log1p(x, /, signature, subok=True)", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `subok`.", "question_id": 4569},
{"snippet": "numpy.log1p(x, /, signature, out=None, where=True)", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `out`, `where`.", "question_id": 4570},
{"snippet": "numpy.log1p(x, /, signature, out=None, casting='same_kind')", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 4571},
{"snippet": "numpy.log1p(x, /, signature, out=None, order='K')", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `out`, `order`.", "question_id": 4572},
{"snippet": "polynomial.hermite_e.HermiteE.convert()", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 4573},
{"snippet": "polynomial.hermite_e.HermiteE.convert(domain=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 4574},
{"snippet": "polynomial.hermite_e.HermiteE.convert(kind=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 4575},
{"snippet": "polynomial.hermite_e.HermiteE.convert(window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 4576},
{"snippet": "polynomial.hermite_e.HermiteE.convert(domain=None, kind=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 4577},
{"snippet": "polynomial.hermite_e.HermiteE.convert(domain=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 4578},
{"snippet": "polynomial.hermite_e.HermiteE.convert(kind=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 4579},
{"snippet": "polynomial.hermite_e.HermiteE.convert(domain=None, kind=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 4580},
{"snippet": "numpy.sort(a)", "intent": "Return `a` sorted copy of an array .", "question_id": 4581},
{"snippet": "numpy.sort(a, axis=- 1)", "intent": "Return `a` sorted copy of an array . All the sort algorithms make temporary copies of the data when sorting along any but the last `axis` .", "question_id": 4582},
{"snippet": "numpy.sort(a, kind=None)", "intent": "Return `a` sorted copy of an array . With arguments `kind`.", "question_id": 4583},
{"snippet": "numpy.sort(a, order=None)", "intent": "Return `a` sorted copy of an array . A stable sort keeps items with the same key in the same relative `order` .", "question_id": 4584},
{"snippet": "numpy.sort(a, axis=- 1, kind=None)", "intent": "Return `a` sorted copy of an array . All the sort algorithms make temporary copies of the data when sorting along any but the last `axis` . With arguments `kind`.", "question_id": 4585},
{"snippet": "numpy.sort(a, axis=- 1, order=None)", "intent": "Return `a` sorted copy of an array . All the sort algorithms make temporary copies of the data when sorting along any but the last `axis` . A stable sort keeps items with the same key in the same relative `order` .", "question_id": 4586},
{"snippet": "numpy.sort(a, kind=None, order=None)", "intent": "Return `a` sorted copy of an array . A stable sort keeps items with the same key in the same relative `order` . With arguments `kind`.", "question_id": 4587},
{"snippet": "numpy.sort(a, axis=- 1, kind=None, order=None)", "intent": "Return `a` sorted copy of an array . All the sort algorithms make temporary copies of the data when sorting along any but the last `axis` . A stable sort keeps items with the same key in the same relative `order` . With arguments `kind`.", "question_id": 4588},
{"snippet": "char.chararray.strip()", "intent": "For each element in self , return a copy with the leading and trailing characters removed .", "question_id": 4589},
{"snippet": "char.chararray.strip(chars=None)", "intent": "For each element in self , return a copy with the leading and trailing characters removed . With arguments `chars`.", "question_id": 4590},
{"snippet": "numpy.polyfit(x, y, deg)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) .", "question_id": 4591},
{"snippet": "numpy.polyfit(x, y, deg, rcond=None)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious : including contributions from the small singular values can add numerical noise to the result .", "question_id": 4592},
{"snippet": "numpy.polyfit(x, y, deg, full=False)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . With arguments `full`.", "question_id": 4593},
{"snippet": "numpy.polyfit(x, y, deg, w=None)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . With arguments `w`.", "question_id": 4594},
{"snippet": "numpy.polyfit(x, y, deg, cov=False)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . With arguments `cov`.", "question_id": 4595},
{"snippet": "numpy.polyfit(x, y, deg, rcond=None, full=False)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious : including contributions from the small singular values can add numerical noise to the result . With arguments `full`.", "question_id": 4596},
{"snippet": "numpy.polyfit(x, y, deg, rcond=None, w=None)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious : including contributions from the small singular values can add numerical noise to the result . With arguments `w`.", "question_id": 4597},
{"snippet": "numpy.polyfit(x, y, deg, rcond=None, cov=False)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious : including contributions from the small singular values can add numerical noise to the result . With arguments `cov`.", "question_id": 4598},
{"snippet": "numpy.polyfit(x, y, deg, full=False, w=None)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . With arguments `full`, `w`.", "question_id": 4599},
{"snippet": "numpy.polyfit(x, y, deg, full=False, cov=False)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . With arguments `full`, `cov`.", "question_id": 4600},
{"snippet": "record.diagonal()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 4601},
{"snippet": "numpy.ldexp(x1, x2, /, signature, extobj)", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `extobj`.", "question_id": 4602},
{"snippet": "numpy.ldexp(x1, x2, /, signature, extobj, out=None)", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 4603},
{"snippet": "numpy.ldexp(x1, x2, /, signature, extobj, where=True)", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 4604},
{"snippet": "numpy.ldexp(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 4605},
{"snippet": "numpy.ldexp(x1, x2, /, signature, extobj, order='K')", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 4606},
{"snippet": "numpy.ldexp(x1, x2, /, signature, extobj, dtype=None)", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 4607},
{"snippet": "numpy.ldexp(x1, x2, /, signature, extobj, subok=True)", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 4608},
{"snippet": "numpy.ldexp(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 4609},
{"snippet": "numpy.ldexp(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 4610},
{"snippet": "numpy.ldexp(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 4611},
{"snippet": "numpy.ldexp(x1, x2, /, signature)", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`.", "question_id": 4612},
{"snippet": "numpy.ldexp(x1, x2, /, signature, out=None)", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `out`.", "question_id": 4613},
{"snippet": "numpy.ldexp(x1, x2, /, signature, where=True)", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `where`.", "question_id": 4614},
{"snippet": "numpy.ldexp(x1, x2, /, signature, casting='same_kind')", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `casting`.", "question_id": 4615},
{"snippet": "numpy.ldexp(x1, x2, /, signature, order='K')", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `order`.", "question_id": 4616},
{"snippet": "numpy.ldexp(x1, x2, /, signature, dtype=None)", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `dtype`.", "question_id": 4617},
{"snippet": "numpy.ldexp(x1, x2, /, signature, subok=True)", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `subok`.", "question_id": 4618},
{"snippet": "numpy.ldexp(x1, x2, /, signature, out=None, where=True)", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `out`, `where`.", "question_id": 4619},
{"snippet": "numpy.ldexp(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 4620},
{"snippet": "numpy.ldexp(x1, x2, /, signature, out=None, order='K')", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `out`, `order`.", "question_id": 4621},
{"snippet": "numpy.cov(m)", "intent": "Estimate a covariance matrix , given data and weights . Assume that the observations are in the columns of the observation array `m` and let f = `fweights` and a = `aweights` for brevity .", "question_id": 4622},
{"snippet": "numpy.cov(m, y=None)", "intent": "Estimate a covariance matrix , given data and weights . Assume that the observations are in the columns of the observation array `m` and let f = `fweights` and a = `aweights` for brevity . Further , note how x and `y` are combined :", "question_id": 4623},
{"snippet": "numpy.cov(m, rowvar=True)", "intent": "Estimate a covariance matrix , given data and weights . Assume that the observations are in the columns of the observation array `m` and let f = `fweights` and a = `aweights` for brevity . With arguments `rowvar`.", "question_id": 4624},
{"snippet": "numpy.cov(m, bias=False)", "intent": "Estimate a covariance matrix , given data and weights . Assume that the observations are in the columns of the observation array `m` and let f = `fweights` and a = `aweights` for brevity . With arguments `bias`.", "question_id": 4625},
{"snippet": "numpy.cov(m, ddof=None)", "intent": "Estimate a covariance matrix , given data and weights . Assume that the observations are in the columns of the observation array `m` and let f = `fweights` and a = `aweights` for brevity . Note that when a == 1 , the normalization factor v1 / ( v1 * * 2 - `ddof` * v2 ) goes over to 1 / ( np.sum ( f ) - ddof ) as it should .", "question_id": 4626},
{"snippet": "numpy.cov(m, fweights=None)", "intent": "Estimate a covariance matrix , given data and weights . Assume that the observations are in the columns of the observation array `m` and let f = `fweights` and a = `aweights` for brevity .", "question_id": 4627},
{"snippet": "numpy.cov(m, aweights=None)", "intent": "Estimate a covariance matrix , given data and weights . Assume that the observations are in the columns of the observation array `m` and let f = `fweights` and a = `aweights` for brevity .", "question_id": 4628},
{"snippet": "numpy.cov(m, dtype=None)", "intent": "Estimate a covariance matrix , given data and weights . Assume that the observations are in the columns of the observation array `m` and let f = `fweights` and a = `aweights` for brevity . With arguments `dtype`.", "question_id": 4629},
{"snippet": "numpy.cov(m, y=None, rowvar=True)", "intent": "Estimate a covariance matrix , given data and weights . Assume that the observations are in the columns of the observation array `m` and let f = `fweights` and a = `aweights` for brevity . Further , note how x and `y` are combined : With arguments `rowvar`.", "question_id": 4630},
{"snippet": "numpy.cov(m, y=None, bias=False)", "intent": "Estimate a covariance matrix , given data and weights . Assume that the observations are in the columns of the observation array `m` and let f = `fweights` and a = `aweights` for brevity . Further , note how x and `y` are combined : With arguments `bias`.", "question_id": 4631},
{"snippet": "lib.format.read_array(fp)", "intent": "Read an array from an NPY file . With arguments `fp`.", "question_id": 4632},
{"snippet": "lib.format.read_array(fp, allow_pickle=False)", "intent": "Read an array from an NPY file . With arguments `fp`, `allow_pickle`.", "question_id": 4633},
{"snippet": "lib.format.read_array(fp, pickle_kwargs=None)", "intent": "Read an array from an NPY file . With arguments `fp`, `pickle_kwargs`.", "question_id": 4634},
{"snippet": "lib.format.read_array(fp, allow_pickle=False, pickle_kwargs=None)", "intent": "Read an array from an NPY file . With arguments `fp`, `allow_pickle`, `pickle_kwargs`.", "question_id": 4635},
{"snippet": "numpy.savetxt(fname, X)", "intent": "Save an array to a text file . With arguments `fname`, `X`.", "question_id": 4636},
{"snippet": "numpy.savetxt(fname, X, fmt='%.18e')", "intent": "Save an array to a text file . Further explanation of the `fmt` parameter ( % [ flag ] width [ .precision ] specifier ) : With arguments `fname`, `X`.", "question_id": 4637},
{"snippet": "numpy.savetxt(fname, X, delimiter=' ')", "intent": "Save an array to a text file . With arguments `fname`, `X`, `delimiter`.", "question_id": 4638},
{"snippet": "numpy.savetxt(fname, X, newline='\\n')", "intent": "Save an array to a text file . With arguments `fname`, `X`, `newline`.", "question_id": 4639},
{"snippet": "numpy.savetxt(fname, X, header='')", "intent": "Save an array to a text file . With arguments `fname`, `X`, `header`.", "question_id": 4640},
{"snippet": "numpy.savetxt(fname, X, footer='')", "intent": "Save an array to a text file . With arguments `fname`, `X`, `footer`.", "question_id": 4641},
{"snippet": "numpy.savetxt(fname, X, comments='# ')", "intent": "Save an array to a text file . With arguments `fname`, `X`, `comments`.", "question_id": 4642},
{"snippet": "numpy.savetxt(fname, X, encoding=None)", "intent": "Save an array to a text file . With arguments `fname`, `X`, `encoding`.", "question_id": 4643},
{"snippet": "numpy.savetxt(fname, X, fmt='%.18e', delimiter=' ')", "intent": "Save an array to a text file . Further explanation of the `fmt` parameter ( % [ flag ] width [ .precision ] specifier ) : With arguments `fname`, `X`, `delimiter`.", "question_id": 4644},
{"snippet": "numpy.savetxt(fname, X, fmt='%.18e', newline='\\n')", "intent": "Save an array to a text file . Further explanation of the `fmt` parameter ( % [ flag ] width [ .precision ] specifier ) : With arguments `fname`, `X`, `newline`.", "question_id": 4645},
{"snippet": "numpy.rot90(m, 1))", "intent": "Rotate an array by 90 degrees in the plane specified by `axes` . rot90 ( `m` , k=1 , axes= ( 1,0 ) ) is the reverse of rot90 ( m , k=1 , axes= ( 0,1 ) ) rot90 ( m , k=1 , axes= ( 1,0 ) ) is equivalent to rot90 ( m , k=-1 , axes= ( 0,1 ) ) With arguments `1)`.", "question_id": 4646},
{"snippet": "numpy.rot90(m, 1), k=1)", "intent": "Rotate an array by 90 degrees in the plane specified by `axes` . rot90 ( `m` , k=1 , axes= ( 1,0 ) ) is the reverse of rot90 ( m , k=1 , axes= ( 0,1 ) ) rot90 ( m , k=1 , axes= ( 1,0 ) ) is equivalent to rot90 ( m , k=-1 , axes= ( 0,1 ) ) With arguments `1)`, `k`.", "question_id": 4647},
{"snippet": "numpy.rot90(m, 1), axes=(0)", "intent": "Rotate an array by 90 degrees in the plane specified by `axes` . rot90 ( `m` , k=1 , axes= ( 1,0 ) ) is the reverse of rot90 ( m , k=1 , axes= ( 0,1 ) ) rot90 ( m , k=1 , axes= ( 1,0 ) ) is equivalent to rot90 ( m , k=-1 , axes= ( 0,1 ) ) With arguments `1)`.", "question_id": 4648},
{"snippet": "numpy.rot90(m, 1), k=1, axes=(0)", "intent": "Rotate an array by 90 degrees in the plane specified by `axes` . rot90 ( `m` , k=1 , axes= ( 1,0 ) ) is the reverse of rot90 ( m , k=1 , axes= ( 0,1 ) ) rot90 ( m , k=1 , axes= ( 1,0 ) ) is equivalent to rot90 ( m , k=-1 , axes= ( 0,1 ) ) With arguments `1)`, `k`.", "question_id": 4649},
{"snippet": "polynomial.hermite.Hermite.has_samecoef(other)", "intent": "Check if coefficients match . With arguments `other`.", "question_id": 4650},
{"snippet": "numpy.array2string(a)", "intent": "Return `a` string representation of an array .", "question_id": 4651},
{"snippet": "numpy.array2string(a, max_line_width=None)", "intent": "Return `a` string representation of an array . With arguments `max_line_width`.", "question_id": 4652},
{"snippet": "numpy.array2string(a, precision=None)", "intent": "Return `a` string representation of an array . If a `formatter` is specified for a certain type , the `precision` keyword is ignored for that type .", "question_id": 4653},
{"snippet": "numpy.array2string(a, suppress_small=None)", "intent": "Return `a` string representation of an array . With arguments `suppress_small`.", "question_id": 4654},
{"snippet": "numpy.array2string(a, separator=' ')", "intent": "Return `a` string representation of an array . With arguments `separator`.", "question_id": 4655},
{"snippet": "numpy.array2string(a, prefix='')", "intent": "Return `a` string representation of an array . With arguments `prefix`.", "question_id": 4656},
{"snippet": "numpy.array2string(a, style=<no value>)", "intent": "Return `a` string representation of an array . With arguments `style`.", "question_id": 4657},
{"snippet": "numpy.array2string(a, formatter=None)", "intent": "Return `a` string representation of an array . If a `formatter` is specified for a certain type , the `precision` keyword is ignored for that type .", "question_id": 4658},
{"snippet": "numpy.array2string(a, threshold=None)", "intent": "Return `a` string representation of an array . With arguments `threshold`.", "question_id": 4659},
{"snippet": "numpy.array2string(a, edgeitems=None)", "intent": "Return `a` string representation of an array . With arguments `edgeitems`.", "question_id": 4660},
{"snippet": "ma.masked_array.compress(condition)", "intent": "Return a where `condition` is True .", "question_id": 4661},
{"snippet": "ma.masked_array.compress(condition, axis=None)", "intent": "Return a where `condition` is True . With arguments `axis`.", "question_id": 4662},
{"snippet": "ma.masked_array.compress(condition, out=None)", "intent": "Return a where `condition` is True . With arguments `out`.", "question_id": 4663},
{"snippet": "ma.masked_array.compress(condition, axis=None, out=None)", "intent": "Return a where `condition` is True . With arguments `axis`, `out`.", "question_id": 4664},
{"snippet": "polynomial.hermite.Hermite.degree()", "intent": "The degree of the series .", "question_id": 4665},
{"snippet": "numpy.polynomial.polynomial.Polynomial(coef)", "intent": "A power series class . With arguments `coef`.", "question_id": 4666},
{"snippet": "numpy.polynomial.polynomial.Polynomial(coef, domain=None)", "intent": "A power series class . With arguments `coef`, `domain`.", "question_id": 4667},
{"snippet": "numpy.polynomial.polynomial.Polynomial(coef, window=None)", "intent": "A power series class . With arguments `coef`, `window`.", "question_id": 4668},
{"snippet": "numpy.polynomial.polynomial.Polynomial(coef, domain=None, window=None)", "intent": "A power series class . With arguments `coef`, `domain`, `window`.", "question_id": 4669},
{"snippet": "random.Generator.standard_exponential()", "intent": "Draw samples from the standard exponential distribution .", "question_id": 4670},
{"snippet": "random.Generator.standard_exponential(size=None)", "intent": "Draw samples from the standard exponential distribution . With arguments `size`.", "question_id": 4671},
{"snippet": "random.Generator.standard_exponential(dtype=np.float64)", "intent": "Draw samples from the standard exponential distribution . With arguments `dtype`.", "question_id": 4672},
{"snippet": "random.Generator.standard_exponential(method='zig')", "intent": "Draw samples from the standard exponential distribution . With arguments `method`.", "question_id": 4673},
{"snippet": "random.Generator.standard_exponential(out=None)", "intent": "Draw samples from the standard exponential distribution . With arguments `out`.", "question_id": 4674},
{"snippet": "random.Generator.standard_exponential(size=None, dtype=np.float64)", "intent": "Draw samples from the standard exponential distribution . With arguments `size`, `dtype`.", "question_id": 4675},
{"snippet": "random.Generator.standard_exponential(size=None, method='zig')", "intent": "Draw samples from the standard exponential distribution . With arguments `size`, `method`.", "question_id": 4676},
{"snippet": "random.Generator.standard_exponential(size=None, out=None)", "intent": "Draw samples from the standard exponential distribution . With arguments `size`, `out`.", "question_id": 4677},
{"snippet": "random.Generator.standard_exponential(dtype=np.float64, method='zig')", "intent": "Draw samples from the standard exponential distribution . With arguments `dtype`, `method`.", "question_id": 4678},
{"snippet": "random.Generator.standard_exponential(dtype=np.float64, out=None)", "intent": "Draw samples from the standard exponential distribution . With arguments `dtype`, `out`.", "question_id": 4679},
{"snippet": "ma.zeros(shape)", "intent": "Return a new array of given `shape` and type , filled with zeros .", "question_id": 4680},
{"snippet": "ma.zeros(shape, dtype=float)", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `dtype`.", "question_id": 4681},
{"snippet": "ma.zeros(shape, order='C')", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `order`.", "question_id": 4682},
{"snippet": "ma.zeros(shape, like=None)", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `like`.", "question_id": 4683},
{"snippet": "ma.zeros(shape, dtype=float, order='C')", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `dtype`, `order`.", "question_id": 4684},
{"snippet": "ma.zeros(shape, dtype=float, like=None)", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `dtype`, `like`.", "question_id": 4685},
{"snippet": "ma.zeros(shape, order='C', like=None)", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `order`, `like`.", "question_id": 4686},
{"snippet": "ma.zeros(shape, dtype=float, order='C', like=None)", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `dtype`, `order`, `like`.", "question_id": 4687},
{"snippet": "random.RandomState.poisson()", "intent": "Draw samples from a Poisson distribution .", "question_id": 4688},
{"snippet": "random.RandomState.poisson(lam=1.0)", "intent": "Draw samples from a Poisson distribution . Because the output is limited to the range of the C int64 type , a ValueError is raised when `lam` is within 10 sigma of the maximum representable value .", "question_id": 4689},
{"snippet": "random.RandomState.poisson(size=None)", "intent": "Draw samples from a Poisson distribution . With arguments `size`.", "question_id": 4690},
{"snippet": "random.RandomState.poisson(lam=1.0, size=None)", "intent": "Draw samples from a Poisson distribution . Because the output is limited to the range of the C int64 type , a ValueError is raised when `lam` is within 10 sigma of the maximum representable value . With arguments `size`.", "question_id": 4691},
{"snippet": "char.isnumeric(a)", "intent": "For each element , return True if there are only numeric characters in the element . With arguments `a`.", "question_id": 4692},
{"snippet": "numpy.copysign(x1, x2, /, signature, extobj)", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `extobj`.", "question_id": 4693},
{"snippet": "numpy.copysign(x1, x2, /, signature, extobj, out=None)", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 4694},
{"snippet": "numpy.copysign(x1, x2, /, signature, extobj, where=True)", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 4695},
{"snippet": "numpy.copysign(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 4696},
{"snippet": "numpy.copysign(x1, x2, /, signature, extobj, order='K')", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 4697},
{"snippet": "numpy.copysign(x1, x2, /, signature, extobj, dtype=None)", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 4698},
{"snippet": "numpy.copysign(x1, x2, /, signature, extobj, subok=True)", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 4699},
{"snippet": "numpy.copysign(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 4700},
{"snippet": "numpy.copysign(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 4701},
{"snippet": "numpy.copysign(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 4702},
{"snippet": "numpy.copysign(x1, x2, /, signature)", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`.", "question_id": 4703},
{"snippet": "numpy.copysign(x1, x2, /, signature, out=None)", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `out`.", "question_id": 4704},
{"snippet": "numpy.copysign(x1, x2, /, signature, where=True)", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `where`.", "question_id": 4705},
{"snippet": "numpy.copysign(x1, x2, /, signature, casting='same_kind')", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `casting`.", "question_id": 4706},
{"snippet": "numpy.copysign(x1, x2, /, signature, order='K')", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `order`.", "question_id": 4707},
{"snippet": "numpy.copysign(x1, x2, /, signature, dtype=None)", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `dtype`.", "question_id": 4708},
{"snippet": "numpy.copysign(x1, x2, /, signature, subok=True)", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `subok`.", "question_id": 4709},
{"snippet": "numpy.copysign(x1, x2, /, signature, out=None, where=True)", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `out`, `where`.", "question_id": 4710},
{"snippet": "numpy.copysign(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 4711},
{"snippet": "numpy.copysign(x1, x2, /, signature, out=None, order='K')", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `out`, `order`.", "question_id": 4712},
{"snippet": "chararray.argmin()", "intent": "Return indices of the minimum values along the given `axis` .", "question_id": 4713},
{"snippet": "chararray.argmin(axis=None)", "intent": "Return indices of the minimum values along the given `axis` .", "question_id": 4714},
{"snippet": "chararray.argmin(out=None)", "intent": "Return indices of the minimum values along the given `axis` . With arguments `out`.", "question_id": 4715},
{"snippet": "chararray.argmin(axis=None, out=None)", "intent": "Return indices of the minimum values along the given `axis` . With arguments `out`.", "question_id": 4716},
{"snippet": "numpy.setxor1d(ar1, ar2)", "intent": "Find the set exclusive-or of two arrays . With arguments `ar1`, `ar2`.", "question_id": 4717},
{"snippet": "numpy.setxor1d(ar1, ar2, assume_unique=False)", "intent": "Find the set exclusive-or of two arrays . With arguments `ar1`, `ar2`, `assume_unique`.", "question_id": 4718},
{"snippet": "ma.MaskedArray.__setitem__(indx, value)", "intent": "x.__setitem__ ( i , y ) < == > x [ i ] =y If `value` is masked , masks those locations . With arguments `indx`.", "question_id": 4719},
{"snippet": "chararray.rsplit()", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string .", "question_id": 4720},
{"snippet": "chararray.rsplit(sep=None)", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string .", "question_id": 4721},
{"snippet": "chararray.rsplit(maxsplit=None)", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string . With arguments `maxsplit`.", "question_id": 4722},
{"snippet": "chararray.rsplit(sep=None, maxsplit=None)", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string . With arguments `maxsplit`.", "question_id": 4723},
{"snippet": "char.zfill(a, width)", "intent": "Return the numeric string left-filled with zeros With arguments `a`, `width`.", "question_id": 4724},
{"snippet": "numpy.save(file, arr)", "intent": "Save an array to a binary `file` in NumPy .npy format . With arguments `arr`.", "question_id": 4725},
{"snippet": "numpy.save(file, arr, allow_pickle=True)", "intent": "Save an array to a binary `file` in NumPy .npy format . With arguments `arr`, `allow_pickle`.", "question_id": 4726},
{"snippet": "numpy.save(file, arr, fix_imports=True)", "intent": "Save an array to a binary `file` in NumPy .npy format . With arguments `arr`, `fix_imports`.", "question_id": 4727},
{"snippet": "numpy.save(file, arr, allow_pickle=True, fix_imports=True)", "intent": "Save an array to a binary `file` in NumPy .npy format . With arguments `arr`, `allow_pickle`, `fix_imports`.", "question_id": 4728},
{"snippet": "matrix.flat", "intent": "A 1-D iterator over the array.", "question_id": 4729},
{"snippet": "polynomial.hermite_e.hermeval3d(x, y, z, c)", "intent": "Evaluate a 3-D Hermite_e series at points ( `x` , `y` , `z` ) . In either case , either x , y , and z or their elements must support multiplication and addition both with themselves and with the elements of `c` .", "question_id": 4730},
{"snippet": "random.logseries(p)", "intent": "Draw samples from a logarithmic series distribution . Samples are drawn from a log series distribution with specified shape parameter , 0 < `p` < 1 .", "question_id": 4731},
{"snippet": "random.logseries(p, size=None)", "intent": "Draw samples from a logarithmic series distribution . Samples are drawn from a log series distribution with specified shape parameter , 0 < `p` < 1 . With arguments `size`.", "question_id": 4732},
{"snippet": "ma.min(obj)", "intent": "Return the minimum along a given `axis` . With arguments `obj`.", "question_id": 4733},
{"snippet": "ma.min(obj, axis=None)", "intent": "Return the minimum along a given `axis` . With arguments `obj`.", "question_id": 4734},
{"snippet": "ma.min(obj, out=None)", "intent": "Return the minimum along a given `axis` . With arguments `obj`, `out`.", "question_id": 4735},
{"snippet": "ma.min(obj, fill_value=None)", "intent": "Return the minimum along a given `axis` . With arguments `obj`, `fill_value`.", "question_id": 4736},
{"snippet": "ma.min(obj, keepdims=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `obj`, `keepdims`.", "question_id": 4737},
{"snippet": "ma.min(obj, axis=None, out=None)", "intent": "Return the minimum along a given `axis` . With arguments `obj`, `out`.", "question_id": 4738},
{"snippet": "ma.min(obj, axis=None, fill_value=None)", "intent": "Return the minimum along a given `axis` . With arguments `obj`, `fill_value`.", "question_id": 4739},
{"snippet": "ma.min(obj, axis=None, keepdims=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `obj`, `keepdims`.", "question_id": 4740},
{"snippet": "ma.min(obj, out=None, fill_value=None)", "intent": "Return the minimum along a given `axis` . With arguments `obj`, `out`, `fill_value`.", "question_id": 4741},
{"snippet": "ma.min(obj, out=None, keepdims=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `obj`, `out`, `keepdims`.", "question_id": 4742},
{"snippet": "random.chisquare(df)", "intent": "Draw samples from a chi-square distribution . When `df` independent random variables , each with standard normal distributions ( mean 0 , variance 1 ) , are squared and summed , the resulting distribution is chi-square ( see Notes ) .", "question_id": 4743},
{"snippet": "random.chisquare(df, size=None)", "intent": "Draw samples from a chi-square distribution . When `df` independent random variables , each with standard normal distributions ( mean 0 , variance 1 ) , are squared and summed , the resulting distribution is chi-square ( see Notes ) . With arguments `size`.", "question_id": 4744},
{"snippet": "numpy.column_stack(tup)", "intent": "Stack 1-D arrays as columns into a 2-D array . With arguments `tup`.", "question_id": 4745},
{"snippet": "ndarray.__sub__(value, /)", "intent": "Return self-value . With arguments `value`, `/`.", "question_id": 4746},
{"snippet": "ma.isMA(x)", "intent": "Test whether input is an instance of MaskedArray . This function returns True if `x` is an instance of MaskedArray and returns False otherwise .", "question_id": 4747},
{"snippet": "random.rayleigh()", "intent": "Draw samples from a Rayleigh distribution .", "question_id": 4748},
{"snippet": "random.rayleigh(scale=1.0)", "intent": "Draw samples from a Rayleigh distribution . With arguments `scale`.", "question_id": 4749},
{"snippet": "random.rayleigh(size=None)", "intent": "Draw samples from a Rayleigh distribution . With arguments `size`.", "question_id": 4750},
{"snippet": "random.rayleigh(scale=1.0, size=None)", "intent": "Draw samples from a Rayleigh distribution . With arguments `scale`, `size`.", "question_id": 4751},
{"snippet": "chararray.mean()", "intent": "Returns the average of the array elements along given `axis` .", "question_id": 4752},
{"snippet": "chararray.mean(axis=None)", "intent": "Returns the average of the array elements along given `axis` .", "question_id": 4753},
{"snippet": "chararray.mean(dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`.", "question_id": 4754},
{"snippet": "chararray.mean(out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`.", "question_id": 4755},
{"snippet": "chararray.mean(keepdims=False)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`.", "question_id": 4756},
{"snippet": "chararray.mean(where=True)", "intent": "Returns the average of the array elements along given `axis` . With arguments `where`.", "question_id": 4757},
{"snippet": "chararray.mean(axis=None, dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`.", "question_id": 4758},
{"snippet": "chararray.mean(axis=None, out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`.", "question_id": 4759},
{"snippet": "chararray.mean(axis=None, keepdims=False)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`.", "question_id": 4760},
{"snippet": "chararray.mean(axis=None, where=True)", "intent": "Returns the average of the array elements along given `axis` . With arguments `where`.", "question_id": 4761},
{"snippet": "ma.masked_array.get_fill_value()", "intent": "The filling value of the masked array is a scalar .", "question_id": 4762},
{"snippet": "numpy.polynomial.legendre.Legendre(coef)", "intent": "A Legendre series class . With arguments `coef`.", "question_id": 4763},
{"snippet": "numpy.polynomial.legendre.Legendre(coef, domain=None)", "intent": "A Legendre series class . With arguments `coef`, `domain`.", "question_id": 4764},
{"snippet": "numpy.polynomial.legendre.Legendre(coef, window=None)", "intent": "A Legendre series class . With arguments `coef`, `window`.", "question_id": 4765},
{"snippet": "numpy.polynomial.legendre.Legendre(coef, domain=None, window=None)", "intent": "A Legendre series class . With arguments `coef`, `domain`, `window`.", "question_id": 4766},
{"snippet": "polynomial.legendre.legsub(c1, c2)", "intent": "Subtract one Legendre series from another . Returns the difference of two Legendre series `c1` - `c2` .", "question_id": 4767},
{"snippet": "polynomial.legendre.legmulx(c)", "intent": "Multiply a Legendre series by x . Multiply the Legendre series `c` by x , where x is the independent variable .", "question_id": 4768},
{"snippet": "ma.MaskType.tolist()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 4769},
{"snippet": "DataSource.exists(path)", "intent": "Test if `path` exists .", "question_id": 4770},
{"snippet": "flatiter.base", "intent": "A reference to the array that is iterated over.", "question_id": 4771},
{"snippet": "ma.masked_array.min()", "intent": "Return the minimum along a given `axis` .", "question_id": 4772},
{"snippet": "ma.masked_array.min(axis=None)", "intent": "Return the minimum along a given `axis` .", "question_id": 4773},
{"snippet": "ma.masked_array.min(out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`.", "question_id": 4774},
{"snippet": "ma.masked_array.min(fill_value=None)", "intent": "Return the minimum along a given `axis` . With arguments `fill_value`.", "question_id": 4775},
{"snippet": "ma.masked_array.min(keepdims=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`.", "question_id": 4776},
{"snippet": "ma.masked_array.min(axis=None, out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`.", "question_id": 4777},
{"snippet": "ma.masked_array.min(axis=None, fill_value=None)", "intent": "Return the minimum along a given `axis` . With arguments `fill_value`.", "question_id": 4778},
{"snippet": "ma.masked_array.min(axis=None, keepdims=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`.", "question_id": 4779},
{"snippet": "ma.masked_array.min(out=None, fill_value=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`, `fill_value`.", "question_id": 4780},
{"snippet": "ma.masked_array.min(out=None, keepdims=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `out`, `keepdims`.", "question_id": 4781},
{"snippet": "random.Generator.pareto(a)", "intent": "Draw samples from `a` Pareto II or Lomax distribution with specified shape .", "question_id": 4782},
{"snippet": "random.Generator.pareto(a, size=None)", "intent": "Draw samples from `a` Pareto II or Lomax distribution with specified shape . With arguments `size`.", "question_id": 4783},
{"snippet": "ma.MaskType.argmax()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 4784},
{"snippet": "char.chararray.rstrip()", "intent": "For each element in self , return a copy with the trailing characters removed .", "question_id": 4785},
{"snippet": "char.chararray.rstrip(chars=None)", "intent": "For each element in self , return a copy with the trailing characters removed . With arguments `chars`.", "question_id": 4786},
{"snippet": "recarray.byteswap()", "intent": "Swap the bytes of the array elements", "question_id": 4787},
{"snippet": "recarray.byteswap(inplace=False)", "intent": "Swap the bytes of the array elements With arguments `inplace`.", "question_id": 4788},
{"snippet": "ndarray.__truediv__(value, /)", "intent": "Return self/value . With arguments `value`, `/`.", "question_id": 4789},
{"snippet": "matrix.ctypes", "intent": "An object to simplify the interaction of the array with the ctypes module.", "question_id": 4790},
{"snippet": "_ctypes.data", "intent": "A pointer to the memory area of the array as a Python integer.", "question_id": 4791},
{"snippet": "_ctypes.shape", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the C-integer corresponding to dtype('p') on this platform.", "question_id": 4792},
{"snippet": "_ctypes.strides", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the same as for the shape attribute.", "question_id": 4793},
{"snippet": "_ctypes.data_as(obj)", "intent": "Return the data pointer cast to a particular c-types object . With arguments `obj`.", "question_id": 4794},
{"snippet": "_ctypes.shape_as(obj)", "intent": "Return the shape tuple as an array of some other c-types type . With arguments `obj`.", "question_id": 4795},
{"snippet": "_ctypes.strides_as(obj)", "intent": "Return the strides tuple as an array of some other c-types type . With arguments `obj`.", "question_id": 4796},
{"snippet": "ma.atleast_2d(*args, **kwargs)", "intent": "View inputs as arrays with at least two dimensions . With arguments `*args`, `**kwargs`.", "question_id": 4797},
{"snippet": "ma.masked_array.mini()", "intent": "Return the array minimum along the specified `axis` .", "question_id": 4798},
{"snippet": "ma.masked_array.mini(axis=None)", "intent": "Return the array minimum along the specified `axis` .", "question_id": 4799},
{"snippet": "numpy.seterrobj(errobj)", "intent": "Set the object that defines floating-point error handling . With arguments `errobj`.", "question_id": 4800},
{"snippet": "char.chararray.decode()", "intent": "Calls str.decode element-wise .", "question_id": 4801},
{"snippet": "char.chararray.decode(encoding=None)", "intent": "Calls str.decode element-wise . With arguments `encoding`.", "question_id": 4802},
{"snippet": "char.chararray.decode(errors=None)", "intent": "Calls str.decode element-wise . With arguments `errors`.", "question_id": 4803},
{"snippet": "char.chararray.decode(encoding=None, errors=None)", "intent": "Calls str.decode element-wise . With arguments `encoding`, `errors`.", "question_id": 4804},
{"snippet": "random.bytes(length)", "intent": "Return random bytes . With arguments `length`.", "question_id": 4805},
{"snippet": "polynomial.polynomial.Polynomial.convert()", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 4806},
{"snippet": "polynomial.polynomial.Polynomial.convert(domain=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 4807},
{"snippet": "polynomial.polynomial.Polynomial.convert(kind=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 4808},
{"snippet": "polynomial.polynomial.Polynomial.convert(window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 4809},
{"snippet": "polynomial.polynomial.Polynomial.convert(domain=None, kind=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 4810},
{"snippet": "polynomial.polynomial.Polynomial.convert(domain=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 4811},
{"snippet": "polynomial.polynomial.Polynomial.convert(kind=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 4812},
{"snippet": "polynomial.polynomial.Polynomial.convert(domain=None, kind=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 4813},
{"snippet": "ndarray.diagonal()", "intent": "Return specified diagonals .", "question_id": 4814},
{"snippet": "ndarray.diagonal(offset=0)", "intent": "Return specified diagonals . With arguments `offset`.", "question_id": 4815},
{"snippet": "ndarray.diagonal(axis1=0)", "intent": "Return specified diagonals . With arguments `axis1`.", "question_id": 4816},
{"snippet": "ndarray.diagonal(axis2=1)", "intent": "Return specified diagonals . With arguments `axis2`.", "question_id": 4817},
{"snippet": "ndarray.diagonal(offset=0, axis1=0)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`.", "question_id": 4818},
{"snippet": "ndarray.diagonal(offset=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis2`.", "question_id": 4819},
{"snippet": "ndarray.diagonal(axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `axis1`, `axis2`.", "question_id": 4820},
{"snippet": "ndarray.diagonal(offset=0, axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`, `axis2`.", "question_id": 4821},
{"snippet": "numpy.sctype2char(sctype)", "intent": "Return the string representation of a scalar dtype . With arguments `sctype`.", "question_id": 4822},
{"snippet": "polynomial.polynomial.Polynomial.degree()", "intent": "The degree of the series .", "question_id": 4823},
{"snippet": "chararray.lstrip()", "intent": "For each element in self , return a copy with the leading characters removed .", "question_id": 4824},
{"snippet": "chararray.lstrip(chars=None)", "intent": "For each element in self , return a copy with the leading characters removed . With arguments `chars`.", "question_id": 4825},
{"snippet": "ndarray.__reduce__()", "intent": "For pickling .", "question_id": 4826},
{"snippet": "broadcast.shape", "intent": "Shape of broadcasted result.", "question_id": 4827},
{"snippet": "nditer.iternext()", "intent": "Check whether iterations are left , and perform a single internal iteration without returning the result .", "question_id": 4828},
{"snippet": "ma.clump_masked(a)", "intent": "Returns `a` list of slices corresponding to the masked clumps of a 1-D array .", "question_id": 4829},
{"snippet": "numpy.convolve(a, v)", "intent": "Returns the discrete , linear convolution of two one-dimensional sequences . The convolution operator is often seen in signal processing , where it models the effect of `a` linear time-invariant system on a signal [ 1 ] . If `v` is longer than a , the arrays are swapped before computation .", "question_id": 4830},
{"snippet": "numpy.convolve(a, v, mode='full')", "intent": "Returns the discrete , linear convolution of two one-dimensional sequences . The convolution operator is often seen in signal processing , where it models the effect of `a` linear time-invariant system on a signal [ 1 ] . If `v` is longer than a , the arrays are swapped before computation . With arguments `mode`.", "question_id": 4831},
{"snippet": "numpy.conj(x, /, signature, extobj)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`.", "question_id": 4832},
{"snippet": "numpy.conj(x, /, signature, extobj, out=None)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`.", "question_id": 4833},
{"snippet": "numpy.conj(x, /, signature, extobj, where=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `where`.", "question_id": 4834},
{"snippet": "numpy.conj(x, /, signature, extobj, casting='same_kind')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `casting`.", "question_id": 4835},
{"snippet": "numpy.conj(x, /, signature, extobj, order='K')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `order`.", "question_id": 4836},
{"snippet": "numpy.conj(x, /, signature, extobj, dtype=None)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `dtype`.", "question_id": 4837},
{"snippet": "numpy.conj(x, /, signature, extobj, subok=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `subok`.", "question_id": 4838},
{"snippet": "numpy.conj(x, /, signature, extobj, out=None, where=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 4839},
{"snippet": "numpy.conj(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 4840},
{"snippet": "numpy.conj(x, /, signature, extobj, out=None, order='K')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 4841},
{"snippet": "numpy.conj(x, /, signature)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`.", "question_id": 4842},
{"snippet": "numpy.conj(x, /, signature, out=None)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `out`.", "question_id": 4843},
{"snippet": "numpy.conj(x, /, signature, where=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `where`.", "question_id": 4844},
{"snippet": "numpy.conj(x, /, signature, casting='same_kind')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `casting`.", "question_id": 4845},
{"snippet": "numpy.conj(x, /, signature, order='K')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `order`.", "question_id": 4846},
{"snippet": "numpy.conj(x, /, signature, dtype=None)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `dtype`.", "question_id": 4847},
{"snippet": "numpy.conj(x, /, signature, subok=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `subok`.", "question_id": 4848},
{"snippet": "numpy.conj(x, /, signature, out=None, where=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `out`, `where`.", "question_id": 4849},
{"snippet": "numpy.conj(x, /, signature, out=None, casting='same_kind')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `out`, `casting`.", "question_id": 4850},
{"snippet": "numpy.conj(x, /, signature, out=None, order='K')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `out`, `order`.", "question_id": 4851},
{"snippet": "polynomial.polynomial.Polynomial.__call__(arg)", "intent": "Call self as a function . With arguments `arg`.", "question_id": 4852},
{"snippet": "nditer.reset()", "intent": "Reset the iterator to its initial state .", "question_id": 4853},
{"snippet": "polynomial.polynomial.Polynomial.fromroots(roots)", "intent": "Return series instance that has the specified `roots` .", "question_id": 4854},
{"snippet": "polynomial.polynomial.Polynomial.fromroots(roots, domain=)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`.", "question_id": 4855},
{"snippet": "polynomial.polynomial.Polynomial.fromroots(roots, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `window`.", "question_id": 4856},
{"snippet": "polynomial.polynomial.Polynomial.fromroots(roots, domain=, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`, `window`.", "question_id": 4857},
{"snippet": "polynomial.polynomial.Polynomial.fromroots()", "intent": "Return series instance that has the specified `roots` .", "question_id": 4858},
{"snippet": "polynomial.polynomial.Polynomial.fromroots(domain=)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`.", "question_id": 4859},
{"snippet": "polynomial.polynomial.Polynomial.fromroots(window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `window`.", "question_id": 4860},
{"snippet": "polynomial.polynomial.Polynomial.fromroots(domain=, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`, `window`.", "question_id": 4861},
{"snippet": "numpy.fabs(x, /, signature, extobj)", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `extobj`.", "question_id": 4862},
{"snippet": "numpy.fabs(x, /, signature, extobj, out=None)", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 4863},
{"snippet": "numpy.fabs(x, /, signature, extobj, where=True)", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 4864},
{"snippet": "numpy.fabs(x, /, signature, extobj, casting='same_kind')", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 4865},
{"snippet": "numpy.fabs(x, /, signature, extobj, order='K')", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 4866},
{"snippet": "numpy.fabs(x, /, signature, extobj, dtype=None)", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 4867},
{"snippet": "numpy.fabs(x, /, signature, extobj, subok=True)", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 4868},
{"snippet": "numpy.fabs(x, /, signature, extobj, out=None, where=True)", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 4869},
{"snippet": "numpy.fabs(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 4870},
{"snippet": "numpy.fabs(x, /, signature, extobj, out=None, order='K')", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 4871},
{"snippet": "numpy.fabs(x, /, signature)", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`.", "question_id": 4872},
{"snippet": "numpy.fabs(x, /, signature, out=None)", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `out`.", "question_id": 4873},
{"snippet": "numpy.fabs(x, /, signature, where=True)", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `where`.", "question_id": 4874},
{"snippet": "numpy.fabs(x, /, signature, casting='same_kind')", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `casting`.", "question_id": 4875},
{"snippet": "numpy.fabs(x, /, signature, order='K')", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `order`.", "question_id": 4876},
{"snippet": "numpy.fabs(x, /, signature, dtype=None)", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `dtype`.", "question_id": 4877},
{"snippet": "numpy.fabs(x, /, signature, subok=True)", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `subok`.", "question_id": 4878},
{"snippet": "numpy.fabs(x, /, signature, out=None, where=True)", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `out`, `where`.", "question_id": 4879},
{"snippet": "numpy.fabs(x, /, signature, out=None, casting='same_kind')", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 4880},
{"snippet": "numpy.fabs(x, /, signature, out=None, order='K')", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `out`, `order`.", "question_id": 4881},
{"snippet": "dtype.byteorder", "intent": "A character indicating the byte-order of this data-type object.", "question_id": 4882},
{"snippet": "numpy.histogram(a)", "intent": "Compute the histogram of `a` dataset .", "question_id": 4883},
{"snippet": "numpy.histogram(a, bins=10)", "intent": "Compute the histogram of `a` dataset . In other words , if `bins` is :", "question_id": 4884},
{"snippet": "numpy.histogram(a, range=None)", "intent": "Compute the histogram of `a` dataset . With arguments `range`.", "question_id": 4885},
{"snippet": "numpy.histogram(a, normed=None)", "intent": "Compute the histogram of `a` dataset . With arguments `normed`.", "question_id": 4886},
{"snippet": "numpy.histogram(a, weights=None)", "intent": "Compute the histogram of `a` dataset . With arguments `weights`.", "question_id": 4887},
{"snippet": "numpy.histogram(a, density=None)", "intent": "Compute the histogram of `a` dataset . With arguments `density`.", "question_id": 4888},
{"snippet": "numpy.histogram(a, bins=10, range=None)", "intent": "Compute the histogram of `a` dataset . In other words , if `bins` is : With arguments `range`.", "question_id": 4889},
{"snippet": "numpy.histogram(a, bins=10, normed=None)", "intent": "Compute the histogram of `a` dataset . In other words , if `bins` is : With arguments `normed`.", "question_id": 4890},
{"snippet": "numpy.histogram(a, bins=10, weights=None)", "intent": "Compute the histogram of `a` dataset . In other words , if `bins` is : With arguments `weights`.", "question_id": 4891},
{"snippet": "numpy.histogram(a, bins=10, density=None)", "intent": "Compute the histogram of `a` dataset . In other words , if `bins` is : With arguments `density`.", "question_id": 4892},
{"snippet": "numpy.histogramdd(sample)", "intent": "Compute the multidimensional histogram of some data . With arguments `sample`.", "question_id": 4893},
{"snippet": "numpy.histogramdd(sample, bins=10)", "intent": "Compute the multidimensional histogram of some data . With arguments `sample`, `bins`.", "question_id": 4894},
{"snippet": "numpy.histogramdd(sample, range=None)", "intent": "Compute the multidimensional histogram of some data . With arguments `sample`, `range`.", "question_id": 4895},
{"snippet": "numpy.histogramdd(sample, normed=None)", "intent": "Compute the multidimensional histogram of some data . With arguments `sample`, `normed`.", "question_id": 4896},
{"snippet": "numpy.histogramdd(sample, weights=None)", "intent": "Compute the multidimensional histogram of some data . With arguments `sample`, `weights`.", "question_id": 4897},
{"snippet": "numpy.histogramdd(sample, density=None)", "intent": "Compute the multidimensional histogram of some data . With arguments `sample`, `density`.", "question_id": 4898},
{"snippet": "numpy.histogramdd(sample, bins=10, range=None)", "intent": "Compute the multidimensional histogram of some data . With arguments `sample`, `bins`, `range`.", "question_id": 4899},
{"snippet": "numpy.histogramdd(sample, bins=10, normed=None)", "intent": "Compute the multidimensional histogram of some data . With arguments `sample`, `bins`, `normed`.", "question_id": 4900},
{"snippet": "numpy.histogramdd(sample, bins=10, weights=None)", "intent": "Compute the multidimensional histogram of some data . With arguments `sample`, `bins`, `weights`.", "question_id": 4901},
{"snippet": "numpy.histogramdd(sample, bins=10, density=None)", "intent": "Compute the multidimensional histogram of some data . With arguments `sample`, `bins`, `density`.", "question_id": 4902},
{"snippet": "numpy.unique(ar)", "intent": "Find the unique elements of an array . With arguments `ar`.", "question_id": 4903},
{"snippet": "numpy.unique(ar, return_index=False)", "intent": "Find the unique elements of an array . With arguments `ar`, `return_index`.", "question_id": 4904},
{"snippet": "numpy.unique(ar, return_inverse=False)", "intent": "Find the unique elements of an array . With arguments `ar`, `return_inverse`.", "question_id": 4905},
{"snippet": "numpy.unique(ar, return_counts=False)", "intent": "Find the unique elements of an array . With arguments `ar`, `return_counts`.", "question_id": 4906},
{"snippet": "numpy.unique(ar, axis=None)", "intent": "Find the unique elements of an array . When an `axis` is specified the subarrays indexed by the axis are sorted . With arguments `ar`.", "question_id": 4907},
{"snippet": "numpy.unique(ar, return_index=False, return_inverse=False)", "intent": "Find the unique elements of an array . With arguments `ar`, `return_index`, `return_inverse`.", "question_id": 4908},
{"snippet": "numpy.unique(ar, return_index=False, return_counts=False)", "intent": "Find the unique elements of an array . With arguments `ar`, `return_index`, `return_counts`.", "question_id": 4909},
{"snippet": "numpy.unique(ar, return_index=False, axis=None)", "intent": "Find the unique elements of an array . When an `axis` is specified the subarrays indexed by the axis are sorted . With arguments `ar`, `return_index`.", "question_id": 4910},
{"snippet": "numpy.unique(ar, return_inverse=False, return_counts=False)", "intent": "Find the unique elements of an array . With arguments `ar`, `return_inverse`, `return_counts`.", "question_id": 4911},
{"snippet": "numpy.unique(ar, return_inverse=False, axis=None)", "intent": "Find the unique elements of an array . When an `axis` is specified the subarrays indexed by the axis are sorted . With arguments `ar`, `return_inverse`.", "question_id": 4912},
{"snippet": "ma.MaskedArray.soften_mask()", "intent": "Force the mask to soft .", "question_id": 4913},
{"snippet": "numpy.triu_indices(n)", "intent": "Return the indices for the upper-triangle of an ( `n` , `m` ) array .", "question_id": 4914},
{"snippet": "numpy.triu_indices(n, k=0)", "intent": "Return the indices for the upper-triangle of an ( `n` , `m` ) array . With arguments `k`.", "question_id": 4915},
{"snippet": "numpy.triu_indices(n, m=None)", "intent": "Return the indices for the upper-triangle of an ( `n` , `m` ) array .", "question_id": 4916},
{"snippet": "numpy.triu_indices(n, k=0, m=None)", "intent": "Return the indices for the upper-triangle of an ( `n` , `m` ) array . With arguments `k`.", "question_id": 4917},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.cpu_dispatch_names()", "intent": "return a list of final CPU dispatch feature names", "question_id": 4918},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.cc_normalize_flags(flags)", "intent": "Remove the conflicts that caused due gathering implied features `flags` .", "question_id": 4919},
{"snippet": "numpy.less(x1, x2, /, signature, extobj)", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `extobj`.", "question_id": 4920},
{"snippet": "numpy.less(x1, x2, /, signature, extobj, out=None)", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 4921},
{"snippet": "numpy.less(x1, x2, /, signature, extobj, where=True)", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 4922},
{"snippet": "numpy.less(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 4923},
{"snippet": "numpy.less(x1, x2, /, signature, extobj, order='K')", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 4924},
{"snippet": "numpy.less(x1, x2, /, signature, extobj, dtype=None)", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 4925},
{"snippet": "numpy.less(x1, x2, /, signature, extobj, subok=True)", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 4926},
{"snippet": "numpy.less(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 4927},
{"snippet": "numpy.less(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 4928},
{"snippet": "numpy.less(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 4929},
{"snippet": "numpy.less(x1, x2, /, signature)", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`.", "question_id": 4930},
{"snippet": "numpy.less(x1, x2, /, signature, out=None)", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `out`.", "question_id": 4931},
{"snippet": "numpy.less(x1, x2, /, signature, where=True)", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `where`.", "question_id": 4932},
{"snippet": "numpy.less(x1, x2, /, signature, casting='same_kind')", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `casting`.", "question_id": 4933},
{"snippet": "numpy.less(x1, x2, /, signature, order='K')", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `order`.", "question_id": 4934},
{"snippet": "numpy.less(x1, x2, /, signature, dtype=None)", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `dtype`.", "question_id": 4935},
{"snippet": "numpy.less(x1, x2, /, signature, subok=True)", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `subok`.", "question_id": 4936},
{"snippet": "numpy.less(x1, x2, /, signature, out=None, where=True)", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `out`, `where`.", "question_id": 4937},
{"snippet": "numpy.less(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 4938},
{"snippet": "numpy.less(x1, x2, /, signature, out=None, order='K')", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `out`, `order`.", "question_id": 4939},
{"snippet": "numpy.take(a, indices)", "intent": "Take elements from an array along an `axis` . When axis is not None , this function does the same thing as \u201c fancy \u201d indexing ( indexing arrays using arrays ) ; however , it can be easier to use if you need elements along `a` given axis . A call such as np.take ( arr , `indices` , axis=3 ) is equivalent to arr [ : , : , : ,indices , ... ] .", "question_id": 4940},
{"snippet": "numpy.take(a, indices, axis=None)", "intent": "Take elements from an array along an `axis` . When axis is not None , this function does the same thing as \u201c fancy \u201d indexing ( indexing arrays using arrays ) ; however , it can be easier to use if you need elements along `a` given axis . A call such as np.take ( arr , `indices` , axis=3 ) is equivalent to arr [ : , : , : ,indices , ... ] .", "question_id": 4941},
{"snippet": "numpy.take(a, indices, out=None)", "intent": "Take elements from an array along an `axis` . When axis is not None , this function does the same thing as \u201c fancy \u201d indexing ( indexing arrays using arrays ) ; however , it can be easier to use if you need elements along `a` given axis . A call such as np.take ( arr , `indices` , axis=3 ) is equivalent to arr [ : , : , : ,indices , ... ] . With arguments `out`.", "question_id": 4942},
{"snippet": "numpy.take(a, indices, mode='raise')", "intent": "Take elements from an array along an `axis` . When axis is not None , this function does the same thing as \u201c fancy \u201d indexing ( indexing arrays using arrays ) ; however , it can be easier to use if you need elements along `a` given axis . A call such as np.take ( arr , `indices` , axis=3 ) is equivalent to arr [ : , : , : ,indices , ... ] . With arguments `mode`.", "question_id": 4943},
{"snippet": "numpy.take(a, indices, axis=None, out=None)", "intent": "Take elements from an array along an `axis` . When axis is not None , this function does the same thing as \u201c fancy \u201d indexing ( indexing arrays using arrays ) ; however , it can be easier to use if you need elements along `a` given axis . A call such as np.take ( arr , `indices` , axis=3 ) is equivalent to arr [ : , : , : ,indices , ... ] . With arguments `out`.", "question_id": 4944},
{"snippet": "numpy.take(a, indices, axis=None, mode='raise')", "intent": "Take elements from an array along an `axis` . When axis is not None , this function does the same thing as \u201c fancy \u201d indexing ( indexing arrays using arrays ) ; however , it can be easier to use if you need elements along `a` given axis . A call such as np.take ( arr , `indices` , axis=3 ) is equivalent to arr [ : , : , : ,indices , ... ] . With arguments `mode`.", "question_id": 4945},
{"snippet": "numpy.take(a, indices, out=None, mode='raise')", "intent": "Take elements from an array along an `axis` . When axis is not None , this function does the same thing as \u201c fancy \u201d indexing ( indexing arrays using arrays ) ; however , it can be easier to use if you need elements along `a` given axis . A call such as np.take ( arr , `indices` , axis=3 ) is equivalent to arr [ : , : , : ,indices , ... ] . With arguments `out`, `mode`.", "question_id": 4946},
{"snippet": "numpy.take(a, indices, axis=None, out=None, mode='raise')", "intent": "Take elements from an array along an `axis` . When axis is not None , this function does the same thing as \u201c fancy \u201d indexing ( indexing arrays using arrays ) ; however , it can be easier to use if you need elements along `a` given axis . A call such as np.take ( arr , `indices` , axis=3 ) is equivalent to arr [ : , : , : ,indices , ... ] . With arguments `out`, `mode`.", "question_id": 4947},
{"snippet": "testing.dec.skipif(skip_condition)", "intent": "Make function raise SkipTest exception if a given condition is true . With arguments `skip_condition`.", "question_id": 4948},
{"snippet": "testing.dec.skipif(skip_condition, msg=None)", "intent": "Make function raise SkipTest exception if a given condition is true . With arguments `skip_condition`, `msg`.", "question_id": 4949},
{"snippet": "numpy.absolute(x, /, signature, extobj)", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `extobj`.", "question_id": 4950},
{"snippet": "numpy.absolute(x, /, signature, extobj, out=None)", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`.", "question_id": 4951},
{"snippet": "numpy.absolute(x, /, signature, extobj, where=True)", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `extobj`, `where`.", "question_id": 4952},
{"snippet": "numpy.absolute(x, /, signature, extobj, casting='same_kind')", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `extobj`, `casting`.", "question_id": 4953},
{"snippet": "numpy.absolute(x, /, signature, extobj, order='K')", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `extobj`, `order`.", "question_id": 4954},
{"snippet": "numpy.absolute(x, /, signature, extobj, dtype=None)", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `extobj`, `dtype`.", "question_id": 4955},
{"snippet": "numpy.absolute(x, /, signature, extobj, subok=True)", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `extobj`, `subok`.", "question_id": 4956},
{"snippet": "numpy.absolute(x, /, signature, extobj, out=None, where=True)", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 4957},
{"snippet": "numpy.absolute(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 4958},
{"snippet": "numpy.absolute(x, /, signature, extobj, out=None, order='K')", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 4959},
{"snippet": "numpy.absolute(x, /, signature)", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`.", "question_id": 4960},
{"snippet": "numpy.absolute(x, /, signature, out=None)", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `out`.", "question_id": 4961},
{"snippet": "numpy.absolute(x, /, signature, where=True)", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `where`.", "question_id": 4962},
{"snippet": "numpy.absolute(x, /, signature, casting='same_kind')", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `casting`.", "question_id": 4963},
{"snippet": "numpy.absolute(x, /, signature, order='K')", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `order`.", "question_id": 4964},
{"snippet": "numpy.absolute(x, /, signature, dtype=None)", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `dtype`.", "question_id": 4965},
{"snippet": "numpy.absolute(x, /, signature, subok=True)", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `subok`.", "question_id": 4966},
{"snippet": "numpy.absolute(x, /, signature, out=None, where=True)", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `out`, `where`.", "question_id": 4967},
{"snippet": "numpy.absolute(x, /, signature, out=None, casting='same_kind')", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `out`, `casting`.", "question_id": 4968},
{"snippet": "numpy.absolute(x, /, signature, out=None, order='K')", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `out`, `order`.", "question_id": 4969},
{"snippet": "recarray.squeeze()", "intent": "Remove axes of length one from a .", "question_id": 4970},
{"snippet": "recarray.squeeze(axis=None)", "intent": "Remove axes of length one from a . With arguments `axis`.", "question_id": 4971},
{"snippet": "numpy.put_along_axis(arr, indices, values, axis)", "intent": "Put `values` into the destination array by matching 1d index and data slices . Functions returning an index along an axis , like argsort and argpartition , produce suitable `indices` for this function . This iterates over matching 1d slices oriented along the specified `axis` in the index and data arrays , and uses the former to place values into the latter . With arguments `arr`.", "question_id": 4972},
{"snippet": "polynomial.legendre.legint(c)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 4973},
{"snippet": "polynomial.legendre.legint(c, m=1)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 4974},
{"snippet": "polynomial.legendre.legint(c, k=)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 4975},
{"snippet": "polynomial.legendre.legint(c, lbnd=0)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 4976},
{"snippet": "polynomial.legendre.legint(c, scl=1)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 4977},
{"snippet": "polynomial.legendre.legint(c, axis=0)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 4978},
{"snippet": "polynomial.legendre.legint(c, m=1, k=)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 4979},
{"snippet": "polynomial.legendre.legint(c, m=1, lbnd=0)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 4980},
{"snippet": "polynomial.legendre.legint(c, m=1, scl=1)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 4981},
{"snippet": "polynomial.legendre.legint(c, m=1, axis=0)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 4982},
{"snippet": "polynomial.legendre.legint()", "intent": "Integrate a Legendre series .", "question_id": 4983},
{"snippet": "polynomial.legendre.legint(m=1)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 4984},
{"snippet": "polynomial.legendre.legint(k=)", "intent": "Integrate a Legendre series . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 4985},
{"snippet": "polynomial.legendre.legint(lbnd=0)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 4986},
{"snippet": "polynomial.legendre.legint(scl=1)", "intent": "Integrate a Legendre series . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 4987},
{"snippet": "polynomial.legendre.legint(axis=0)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 4988},
{"snippet": "polynomial.legendre.legint(m=1, k=)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 4989},
{"snippet": "polynomial.legendre.legint(m=1, lbnd=0)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 4990},
{"snippet": "polynomial.legendre.legint(m=1, scl=1)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 4991},
{"snippet": "polynomial.legendre.legint(m=1, axis=0)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 4992},
{"snippet": "polynomial.legendre.legfit(x, y, deg)", "intent": "Least squares fit of Legendre series to data . Return the coefficients of a Legendre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` .", "question_id": 4993},
{"snippet": "polynomial.legendre.legfit(x, y, deg, rcond=None)", "intent": "Least squares fit of Legendre series to data . Return the coefficients of a Legendre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error .", "question_id": 4994},
{"snippet": "polynomial.legendre.legfit(x, y, deg, full=False)", "intent": "Least squares fit of Legendre series to data . Return the coefficients of a Legendre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . With arguments `full`.", "question_id": 4995},
{"snippet": "polynomial.legendre.legfit(x, y, deg, w=None)", "intent": "Least squares fit of Legendre series to data . Return the coefficients of a Legendre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values .", "question_id": 4996},
{"snippet": "polynomial.legendre.legfit(x, y, deg, rcond=None, full=False)", "intent": "Least squares fit of Legendre series to data . Return the coefficients of a Legendre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . With arguments `full`.", "question_id": 4997},
{"snippet": "polynomial.legendre.legfit(x, y, deg, rcond=None, w=None)", "intent": "Least squares fit of Legendre series to data . Return the coefficients of a Legendre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values .", "question_id": 4998},
{"snippet": "polynomial.legendre.legfit(x, y, deg, full=False, w=None)", "intent": "Least squares fit of Legendre series to data . Return the coefficients of a Legendre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values . With arguments `full`.", "question_id": 4999},
{"snippet": "polynomial.legendre.legfit(x, y, deg, rcond=None, full=False, w=None)", "intent": "Least squares fit of Legendre series to data . Return the coefficients of a Legendre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values . With arguments `full`.", "question_id": 5000},
{"snippet": "numpy.distutils.core.Extension(name, sources)", "intent": "Methods With arguments `name`, `sources`.", "question_id": 5001},
{"snippet": "numpy.distutils.core.Extension(name, sources, include_dirs=None)", "intent": "Methods With arguments `name`, `sources`, `include_dirs`.", "question_id": 5002},
{"snippet": "numpy.distutils.core.Extension(name, sources, define_macros=None)", "intent": "Methods With arguments `name`, `sources`, `define_macros`.", "question_id": 5003},
{"snippet": "numpy.distutils.core.Extension(name, sources, undef_macros=None)", "intent": "Methods With arguments `name`, `sources`, `undef_macros`.", "question_id": 5004},
{"snippet": "numpy.distutils.core.Extension(name, sources, library_dirs=None)", "intent": "Methods With arguments `name`, `sources`, `library_dirs`.", "question_id": 5005},
{"snippet": "numpy.distutils.core.Extension(name, sources, libraries=None)", "intent": "Methods With arguments `name`, `sources`, `libraries`.", "question_id": 5006},
{"snippet": "numpy.distutils.core.Extension(name, sources, runtime_library_dirs=None)", "intent": "Methods With arguments `name`, `sources`, `runtime_library_dirs`.", "question_id": 5007},
{"snippet": "numpy.distutils.core.Extension(name, sources, extra_objects=None)", "intent": "Methods With arguments `name`, `sources`, `extra_objects`.", "question_id": 5008},
{"snippet": "numpy.distutils.core.Extension(name, sources, extra_compile_args=None)", "intent": "Methods With arguments `name`, `sources`, `extra_compile_args`.", "question_id": 5009},
{"snippet": "numpy.distutils.core.Extension(name, sources, extra_link_args=None)", "intent": "Methods With arguments `name`, `sources`, `extra_link_args`.", "question_id": 5010},
{"snippet": "matrix.argpartition(kth)", "intent": "Returns the indices that would partition this array . With arguments `kth`.", "question_id": 5011},
{"snippet": "matrix.argpartition(kth, axis=- 1)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`.", "question_id": 5012},
{"snippet": "matrix.argpartition(kth, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`.", "question_id": 5013},
{"snippet": "matrix.argpartition(kth, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `order`.", "question_id": 5014},
{"snippet": "matrix.argpartition(kth, axis=- 1, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`.", "question_id": 5015},
{"snippet": "matrix.argpartition(kth, axis=- 1, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `order`.", "question_id": 5016},
{"snippet": "matrix.argpartition(kth, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`, `order`.", "question_id": 5017},
{"snippet": "matrix.argpartition(kth, axis=- 1, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`, `order`.", "question_id": 5018},
{"snippet": "numpy.corrcoef(x)", "intent": "Return Pearson product-moment correlation coefficients . With arguments `x`.", "question_id": 5019},
{"snippet": "numpy.corrcoef(x, y=None)", "intent": "Return Pearson product-moment correlation coefficients . With arguments `x`, `y`.", "question_id": 5020},
{"snippet": "numpy.corrcoef(x, rowvar=True)", "intent": "Return Pearson product-moment correlation coefficients . In this example we generate two random arrays , xarr and yarr , and compute the row-wise and column-wise Pearson correlation coefficients , R. Since `rowvar` is true by default , we first find the row-wise Pearson correlation coefficients between the variables of xarr . With arguments `x`.", "question_id": 5021},
{"snippet": "numpy.corrcoef(x, bias=<no value>)", "intent": "Return Pearson product-moment correlation coefficients . This function accepts but discards arguments `bias` and `ddof` . With arguments `x`.", "question_id": 5022},
{"snippet": "numpy.corrcoef(x, ddof=<no value>)", "intent": "Return Pearson product-moment correlation coefficients . This function accepts but discards arguments `bias` and `ddof` . With arguments `x`.", "question_id": 5023},
{"snippet": "numpy.corrcoef(x, dtype=None)", "intent": "Return Pearson product-moment correlation coefficients . With arguments `x`, `dtype`.", "question_id": 5024},
{"snippet": "numpy.corrcoef(x, y=None, rowvar=True)", "intent": "Return Pearson product-moment correlation coefficients . In this example we generate two random arrays , xarr and yarr , and compute the row-wise and column-wise Pearson correlation coefficients , R. Since `rowvar` is true by default , we first find the row-wise Pearson correlation coefficients between the variables of xarr . With arguments `x`, `y`.", "question_id": 5025},
{"snippet": "numpy.corrcoef(x, y=None, bias=<no value>)", "intent": "Return Pearson product-moment correlation coefficients . This function accepts but discards arguments `bias` and `ddof` . With arguments `x`, `y`.", "question_id": 5026},
{"snippet": "numpy.corrcoef(x, y=None, ddof=<no value>)", "intent": "Return Pearson product-moment correlation coefficients . This function accepts but discards arguments `bias` and `ddof` . With arguments `x`, `y`.", "question_id": 5027},
{"snippet": "numpy.corrcoef(x, y=None, dtype=None)", "intent": "Return Pearson product-moment correlation coefficients . With arguments `x`, `y`, `dtype`.", "question_id": 5028},
{"snippet": "chararray.all()", "intent": "Returns True if all elements evaluate to True .", "question_id": 5029},
{"snippet": "chararray.all(axis=None)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`.", "question_id": 5030},
{"snippet": "chararray.all(out=None)", "intent": "Returns True if all elements evaluate to True . With arguments `out`.", "question_id": 5031},
{"snippet": "chararray.all(keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `keepdims`.", "question_id": 5032},
{"snippet": "chararray.all(where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `where`.", "question_id": 5033},
{"snippet": "chararray.all(axis=None, out=None)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `out`.", "question_id": 5034},
{"snippet": "chararray.all(axis=None, keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `keepdims`.", "question_id": 5035},
{"snippet": "chararray.all(axis=None, where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `where`.", "question_id": 5036},
{"snippet": "chararray.all(out=None, keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `out`, `keepdims`.", "question_id": 5037},
{"snippet": "chararray.all(out=None, where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `out`, `where`.", "question_id": 5038},
{"snippet": "ma.MaskType.reshape()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 5039},
{"snippet": "memmap.nbytes", "intent": "Total bytes consumed by the elements of the array.", "question_id": 5040},
{"snippet": "record.astype()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 5041},
{"snippet": "ma.row_stack(*args, **kwargs)", "intent": "Stack arrays in sequence vertically ( row wise ) . With arguments `*args`, `**kwargs`.", "question_id": 5042},
{"snippet": "generic.setflags()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 5043},
{"snippet": "polynomial.legendre.legroots(c)", "intent": "Compute the roots of a Legendre series . With arguments `c`.", "question_id": 5044},
{"snippet": "char.compare_chararrays(a, b, cmp_op, rstrip)", "intent": "Performs element-wise comparison of two string arrays using the comparison operator specified by `cmp_op` . With arguments `a`, `b`, `rstrip`.", "question_id": 5045},
{"snippet": "numpy.broadcast_to(array, shape)", "intent": "Broadcast an `array` to a new `shape` .", "question_id": 5046},
{"snippet": "numpy.broadcast_to(array, shape, subok=False)", "intent": "Broadcast an `array` to a new `shape` . With arguments `subok`.", "question_id": 5047},
{"snippet": "recarray.cumprod()", "intent": "Return the cumulative product of the elements along the given `axis` .", "question_id": 5048},
{"snippet": "recarray.cumprod(axis=None)", "intent": "Return the cumulative product of the elements along the given `axis` .", "question_id": 5049},
{"snippet": "recarray.cumprod(dtype=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`.", "question_id": 5050},
{"snippet": "recarray.cumprod(out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `out`.", "question_id": 5051},
{"snippet": "recarray.cumprod(axis=None, dtype=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`.", "question_id": 5052},
{"snippet": "recarray.cumprod(axis=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `out`.", "question_id": 5053},
{"snippet": "recarray.cumprod(dtype=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 5054},
{"snippet": "recarray.cumprod(axis=None, dtype=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 5055},
{"snippet": "polynomial.hermite.hermmulx(c)", "intent": "Multiply a Hermite series by x . Multiply the Hermite series `c` by x , where x is the independent variable .", "question_id": 5056},
{"snippet": "ma.round(a)", "intent": "Return `a` copy of a , rounded to \u2018 `decimals` \u2019 places .", "question_id": 5057},
{"snippet": "ma.round(a, decimals=0)", "intent": "Return `a` copy of a , rounded to \u2018 `decimals` \u2019 places .", "question_id": 5058},
{"snippet": "ma.round(a, out=None)", "intent": "Return `a` copy of a , rounded to \u2018 `decimals` \u2019 places . If `out` is given and does not have a mask attribute , the mask of a is lost !", "question_id": 5059},
{"snippet": "ma.round(a, decimals=0, out=None)", "intent": "Return `a` copy of a , rounded to \u2018 `decimals` \u2019 places . If `out` is given and does not have a mask attribute , the mask of a is lost !", "question_id": 5060},
{"snippet": "dtype.metadata", "intent": "Either None or a readonly dictionary of metadata (mappingproxy).", "question_id": 5061},
{"snippet": "ma.stack(*args, **kwargs)", "intent": "Join a sequence of arrays along a new axis . With arguments `*args`, `**kwargs`.", "question_id": 5062},
{"snippet": "polynomial.laguerre.Laguerre.convert()", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 5063},
{"snippet": "polynomial.laguerre.Laguerre.convert(domain=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 5064},
{"snippet": "polynomial.laguerre.Laguerre.convert(kind=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 5065},
{"snippet": "polynomial.laguerre.Laguerre.convert(window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 5066},
{"snippet": "polynomial.laguerre.Laguerre.convert(domain=None, kind=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 5067},
{"snippet": "polynomial.laguerre.Laguerre.convert(domain=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 5068},
{"snippet": "polynomial.laguerre.Laguerre.convert(kind=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 5069},
{"snippet": "polynomial.laguerre.Laguerre.convert(domain=None, kind=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 5070},
{"snippet": "numpy.nan_to_num(x)", "intent": "Replace NaN with zero and infinity with large finite numbers ( default behaviour ) or with the numbers defined by the user using the `nan` , `posinf` and/or `neginf` keywords . If `x` is inexact , NaN is replaced by zero or by the user defined value in nan keyword , infinity is replaced by the largest finite floating point values representable by x.dtype or by the user defined value in posinf keyword and -infinity is replaced by the most negative finite floating point values representable by x.dtype or by the user defined value in neginf keyword .", "question_id": 5071},
{"snippet": "numpy.nan_to_num(x, copy=True)", "intent": "Replace NaN with zero and infinity with large finite numbers ( default behaviour ) or with the numbers defined by the user using the `nan` , `posinf` and/or `neginf` keywords . If `x` is inexact , NaN is replaced by zero or by the user defined value in nan keyword , infinity is replaced by the largest finite floating point values representable by x.dtype or by the user defined value in posinf keyword and -infinity is replaced by the most negative finite floating point values representable by x.dtype or by the user defined value in neginf keyword . With arguments `copy`.", "question_id": 5072},
{"snippet": "numpy.nan_to_num(x, nan=0.0)", "intent": "Replace NaN with zero and infinity with large finite numbers ( default behaviour ) or with the numbers defined by the user using the `nan` , `posinf` and/or `neginf` keywords . If `x` is inexact , NaN is replaced by zero or by the user defined value in nan keyword , infinity is replaced by the largest finite floating point values representable by x.dtype or by the user defined value in posinf keyword and -infinity is replaced by the most negative finite floating point values representable by x.dtype or by the user defined value in neginf keyword .", "question_id": 5073},
{"snippet": "numpy.nan_to_num(x, posinf=None)", "intent": "Replace NaN with zero and infinity with large finite numbers ( default behaviour ) or with the numbers defined by the user using the `nan` , `posinf` and/or `neginf` keywords . If `x` is inexact , NaN is replaced by zero or by the user defined value in nan keyword , infinity is replaced by the largest finite floating point values representable by x.dtype or by the user defined value in posinf keyword and -infinity is replaced by the most negative finite floating point values representable by x.dtype or by the user defined value in neginf keyword .", "question_id": 5074},
{"snippet": "numpy.nan_to_num(x, neginf=None)", "intent": "Replace NaN with zero and infinity with large finite numbers ( default behaviour ) or with the numbers defined by the user using the `nan` , `posinf` and/or `neginf` keywords . If `x` is inexact , NaN is replaced by zero or by the user defined value in nan keyword , infinity is replaced by the largest finite floating point values representable by x.dtype or by the user defined value in posinf keyword and -infinity is replaced by the most negative finite floating point values representable by x.dtype or by the user defined value in neginf keyword .", "question_id": 5075},
{"snippet": "numpy.nan_to_num(x, copy=True, nan=0.0)", "intent": "Replace NaN with zero and infinity with large finite numbers ( default behaviour ) or with the numbers defined by the user using the `nan` , `posinf` and/or `neginf` keywords . If `x` is inexact , NaN is replaced by zero or by the user defined value in nan keyword , infinity is replaced by the largest finite floating point values representable by x.dtype or by the user defined value in posinf keyword and -infinity is replaced by the most negative finite floating point values representable by x.dtype or by the user defined value in neginf keyword . With arguments `copy`.", "question_id": 5076},
{"snippet": "numpy.nan_to_num(x, copy=True, posinf=None)", "intent": "Replace NaN with zero and infinity with large finite numbers ( default behaviour ) or with the numbers defined by the user using the `nan` , `posinf` and/or `neginf` keywords . If `x` is inexact , NaN is replaced by zero or by the user defined value in nan keyword , infinity is replaced by the largest finite floating point values representable by x.dtype or by the user defined value in posinf keyword and -infinity is replaced by the most negative finite floating point values representable by x.dtype or by the user defined value in neginf keyword . With arguments `copy`.", "question_id": 5077},
{"snippet": "numpy.nan_to_num(x, copy=True, neginf=None)", "intent": "Replace NaN with zero and infinity with large finite numbers ( default behaviour ) or with the numbers defined by the user using the `nan` , `posinf` and/or `neginf` keywords . If `x` is inexact , NaN is replaced by zero or by the user defined value in nan keyword , infinity is replaced by the largest finite floating point values representable by x.dtype or by the user defined value in posinf keyword and -infinity is replaced by the most negative finite floating point values representable by x.dtype or by the user defined value in neginf keyword . With arguments `copy`.", "question_id": 5078},
{"snippet": "numpy.nan_to_num(x, nan=0.0, posinf=None)", "intent": "Replace NaN with zero and infinity with large finite numbers ( default behaviour ) or with the numbers defined by the user using the `nan` , `posinf` and/or `neginf` keywords . If `x` is inexact , NaN is replaced by zero or by the user defined value in nan keyword , infinity is replaced by the largest finite floating point values representable by x.dtype or by the user defined value in posinf keyword and -infinity is replaced by the most negative finite floating point values representable by x.dtype or by the user defined value in neginf keyword .", "question_id": 5079},
{"snippet": "numpy.nan_to_num(x, nan=0.0, neginf=None)", "intent": "Replace NaN with zero and infinity with large finite numbers ( default behaviour ) or with the numbers defined by the user using the `nan` , `posinf` and/or `neginf` keywords . If `x` is inexact , NaN is replaced by zero or by the user defined value in nan keyword , infinity is replaced by the largest finite floating point values representable by x.dtype or by the user defined value in posinf keyword and -infinity is replaced by the most negative finite floating point values representable by x.dtype or by the user defined value in neginf keyword .", "question_id": 5080},
{"snippet": "record.tostring()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 5081},
{"snippet": "random.sample()", "intent": "This is an alias of random_sample .", "question_id": 5082},
{"snippet": "record.shape", "intent": "Tuple of array dimensions.", "question_id": 5083},
{"snippet": "generic.__array__()", "intent": "sc.__array__ ( dtype ) return 0-dim array from scalar with specified dtype", "question_id": 5084},
{"snippet": "numpy.extract(condition, arr)", "intent": "Return the elements of an array that satisfy some `condition` . This is equivalent to np.compress ( ravel ( condition ) , ravel ( `arr` ) ) .", "question_id": 5085},
{"snippet": "numpy.put(a, ind, v)", "intent": "Replaces specified elements of an array with given values . With arguments `a`, `ind`, `v`.", "question_id": 5086},
{"snippet": "numpy.put(a, ind, v, mode='raise')", "intent": "Replaces specified elements of an array with given values . With arguments `a`, `ind`, `v`, `mode`.", "question_id": 5087},
{"snippet": "ma.concatenate(arrays)", "intent": "Concatenate a sequence of `arrays` along the given `axis` .", "question_id": 5088},
{"snippet": "ma.concatenate(arrays, axis=0)", "intent": "Concatenate a sequence of `arrays` along the given `axis` .", "question_id": 5089},
{"snippet": "char.chararray.split()", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string .", "question_id": 5090},
{"snippet": "char.chararray.split(sep=None)", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string .", "question_id": 5091},
{"snippet": "char.chararray.split(maxsplit=None)", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string . With arguments `maxsplit`.", "question_id": 5092},
{"snippet": "char.chararray.split(sep=None, maxsplit=None)", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string . With arguments `maxsplit`.", "question_id": 5093},
{"snippet": "polynomial.chebyshev.chebvander3d(x, y, z, deg)", "intent": "Pseudo-Vandermonde matrix of given degrees . Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points ( `x` , `y` , `z` ) .", "question_id": 5094},
{"snippet": "dtype.ndim", "intent": "Number of dimensions of the sub-array if this data type describes a sub-array, and 0 otherwise.", "question_id": 5095},
{"snippet": "memmap.imag", "intent": "The imaginary part of the array.", "question_id": 5096},
{"snippet": "ma.MaskType.cumsum()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 5097},
{"snippet": "numpy.issctype(rep)", "intent": "Determines whether the given object represents a scalar data-type . With arguments `rep`.", "question_id": 5098},
{"snippet": "numpy.isnan(x, /, signature, extobj)", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`.", "question_id": 5099},
{"snippet": "numpy.isnan(x, /, signature, extobj, out=None)", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `out`.", "question_id": 5100},
{"snippet": "numpy.isnan(x, /, signature, extobj, where=True)", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `where`.", "question_id": 5101},
{"snippet": "numpy.isnan(x, /, signature, extobj, casting='same_kind')", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `casting`.", "question_id": 5102},
{"snippet": "numpy.isnan(x, /, signature, extobj, order='K')", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `order`.", "question_id": 5103},
{"snippet": "numpy.isnan(x, /, signature, extobj, dtype=None)", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `dtype`.", "question_id": 5104},
{"snippet": "numpy.isnan(x, /, signature, extobj, subok=True)", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `subok`.", "question_id": 5105},
{"snippet": "numpy.isnan(x, /, signature, extobj, out=None, where=True)", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 5106},
{"snippet": "numpy.isnan(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 5107},
{"snippet": "numpy.isnan(x, /, signature, extobj, out=None, order='K')", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 5108},
{"snippet": "numpy.isnan(x, /, signature)", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`.", "question_id": 5109},
{"snippet": "numpy.isnan(x, /, signature, out=None)", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `out`.", "question_id": 5110},
{"snippet": "numpy.isnan(x, /, signature, where=True)", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `where`.", "question_id": 5111},
{"snippet": "numpy.isnan(x, /, signature, casting='same_kind')", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `casting`.", "question_id": 5112},
{"snippet": "numpy.isnan(x, /, signature, order='K')", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `order`.", "question_id": 5113},
{"snippet": "numpy.isnan(x, /, signature, dtype=None)", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `dtype`.", "question_id": 5114},
{"snippet": "numpy.isnan(x, /, signature, subok=True)", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `subok`.", "question_id": 5115},
{"snippet": "numpy.isnan(x, /, signature, out=None, where=True)", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `out`, `where`.", "question_id": 5116},
{"snippet": "numpy.isnan(x, /, signature, out=None, casting='same_kind')", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `out`, `casting`.", "question_id": 5117},
{"snippet": "numpy.isnan(x, /, signature, out=None, order='K')", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `out`, `order`.", "question_id": 5118},
{"snippet": "ndarray.shape", "intent": "Tuple of array dimensions.", "question_id": 5119},
{"snippet": "polynomial.chebyshev.Chebyshev.has_samedomain(other)", "intent": "Check if domains match . With arguments `other`.", "question_id": 5120},
{"snippet": "numpy.partition(a, kth)", "intent": "Return `a` partitioned copy of an array . With arguments `kth`.", "question_id": 5121},
{"snippet": "numpy.partition(a, kth, axis=- 1)", "intent": "Return `a` partitioned copy of an array . All the partition algorithms make temporary copies of the data when partitioning along any but the last `axis` . With arguments `kth`.", "question_id": 5122},
{"snippet": "numpy.partition(a, kth, kind='introselect')", "intent": "Return `a` partitioned copy of an array . With arguments `kth`, `kind`.", "question_id": 5123},
{"snippet": "numpy.partition(a, kth, order=None)", "intent": "Return `a` partitioned copy of an array . A stable sort keeps items with the same key in the same relative `order` . With arguments `kth`.", "question_id": 5124},
{"snippet": "numpy.partition(a, kth, axis=- 1, kind='introselect')", "intent": "Return `a` partitioned copy of an array . All the partition algorithms make temporary copies of the data when partitioning along any but the last `axis` . With arguments `kth`, `kind`.", "question_id": 5125},
{"snippet": "numpy.partition(a, kth, axis=- 1, order=None)", "intent": "Return `a` partitioned copy of an array . All the partition algorithms make temporary copies of the data when partitioning along any but the last `axis` . A stable sort keeps items with the same key in the same relative `order` . With arguments `kth`.", "question_id": 5126},
{"snippet": "numpy.partition(a, kth, kind='introselect', order=None)", "intent": "Return `a` partitioned copy of an array . A stable sort keeps items with the same key in the same relative `order` . With arguments `kth`, `kind`.", "question_id": 5127},
{"snippet": "numpy.partition(a, kth, axis=- 1, kind='introselect', order=None)", "intent": "Return `a` partitioned copy of an array . All the partition algorithms make temporary copies of the data when partitioning along any but the last `axis` . A stable sort keeps items with the same key in the same relative `order` . With arguments `kth`, `kind`.", "question_id": 5128},
{"snippet": "polynomial.legendre.Legendre.has_samecoef(other)", "intent": "Check if coefficients match . With arguments `other`.", "question_id": 5129},
{"snippet": "random.Generator.permutation(x)", "intent": "Randomly permute a sequence , or return a permuted range . With arguments `x`.", "question_id": 5130},
{"snippet": "random.Generator.permutation(x, axis=0)", "intent": "Randomly permute a sequence , or return a permuted range . With arguments `x`, `axis`.", "question_id": 5131},
{"snippet": "ndarray.__neg__(/)", "intent": "-self With arguments `/`.", "question_id": 5132},
{"snippet": "numpy.nanmean(a)", "intent": "Compute the arithmetic mean along the specified `axis` , ignoring NaNs . For all-NaN slices , NaN is returned and `a` RuntimeWarning is raised .", "question_id": 5133},
{"snippet": "numpy.nanmean(a, axis=None)", "intent": "Compute the arithmetic mean along the specified `axis` , ignoring NaNs . For all-NaN slices , NaN is returned and `a` RuntimeWarning is raised .", "question_id": 5134},
{"snippet": "numpy.nanmean(a, dtype=None)", "intent": "Compute the arithmetic mean along the specified `axis` , ignoring NaNs . For all-NaN slices , NaN is returned and `a` RuntimeWarning is raised . Specifying a higher-precision accumulator using the `dtype` keyword can alleviate this issue .", "question_id": 5135},
{"snippet": "numpy.nanmean(a, out=None)", "intent": "Compute the arithmetic mean along the specified `axis` , ignoring NaNs . For all-NaN slices , NaN is returned and `a` RuntimeWarning is raised . With arguments `out`.", "question_id": 5136},
{"snippet": "numpy.nanmean(a, keepdims=<no value>)", "intent": "Compute the arithmetic mean along the specified `axis` , ignoring NaNs . For all-NaN slices , NaN is returned and `a` RuntimeWarning is raised . With arguments `keepdims`.", "question_id": 5137},
{"snippet": "numpy.nanmean(a, axis=None, dtype=None)", "intent": "Compute the arithmetic mean along the specified `axis` , ignoring NaNs . For all-NaN slices , NaN is returned and `a` RuntimeWarning is raised . Specifying a higher-precision accumulator using the `dtype` keyword can alleviate this issue .", "question_id": 5138},
{"snippet": "numpy.nanmean(a, axis=None, out=None)", "intent": "Compute the arithmetic mean along the specified `axis` , ignoring NaNs . For all-NaN slices , NaN is returned and `a` RuntimeWarning is raised . With arguments `out`.", "question_id": 5139},
{"snippet": "numpy.nanmean(a, axis=None, keepdims=<no value>)", "intent": "Compute the arithmetic mean along the specified `axis` , ignoring NaNs . For all-NaN slices , NaN is returned and `a` RuntimeWarning is raised . With arguments `keepdims`.", "question_id": 5140},
{"snippet": "numpy.nanmean(a, dtype=None, out=None)", "intent": "Compute the arithmetic mean along the specified `axis` , ignoring NaNs . For all-NaN slices , NaN is returned and `a` RuntimeWarning is raised . Specifying a higher-precision accumulator using the `dtype` keyword can alleviate this issue . With arguments `out`.", "question_id": 5141},
{"snippet": "numpy.nanmean(a, dtype=None, keepdims=<no value>)", "intent": "Compute the arithmetic mean along the specified `axis` , ignoring NaNs . For all-NaN slices , NaN is returned and `a` RuntimeWarning is raised . Specifying a higher-precision accumulator using the `dtype` keyword can alleviate this issue . With arguments `keepdims`.", "question_id": 5142},
{"snippet": "ma.MaskType.setflags()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 5143},
{"snippet": "numpy.obj2sctype(rep)", "intent": "Return the scalar dtype or NumPy equivalent of Python type of an object . With arguments `rep`.", "question_id": 5144},
{"snippet": "numpy.obj2sctype(rep, default=None)", "intent": "Return the scalar dtype or NumPy equivalent of Python type of an object . With arguments `rep`, `default`.", "question_id": 5145},
{"snippet": "numpy.array_str(a)", "intent": "Return `a` string representation of the data in an array .", "question_id": 5146},
{"snippet": "numpy.array_str(a, max_line_width=None)", "intent": "Return `a` string representation of the data in an array . With arguments `max_line_width`.", "question_id": 5147},
{"snippet": "numpy.array_str(a, precision=None)", "intent": "Return `a` string representation of the data in an array . With arguments `precision`.", "question_id": 5148},
{"snippet": "numpy.array_str(a, suppress_small=None)", "intent": "Return `a` string representation of the data in an array . With arguments `suppress_small`.", "question_id": 5149},
{"snippet": "numpy.array_str(a, max_line_width=None, precision=None)", "intent": "Return `a` string representation of the data in an array . With arguments `max_line_width`, `precision`.", "question_id": 5150},
{"snippet": "numpy.array_str(a, max_line_width=None, suppress_small=None)", "intent": "Return `a` string representation of the data in an array . With arguments `max_line_width`, `suppress_small`.", "question_id": 5151},
{"snippet": "numpy.array_str(a, precision=None, suppress_small=None)", "intent": "Return `a` string representation of the data in an array . With arguments `precision`, `suppress_small`.", "question_id": 5152},
{"snippet": "numpy.array_str(a, max_line_width=None, precision=None, suppress_small=None)", "intent": "Return `a` string representation of the data in an array . With arguments `max_line_width`, `precision`, `suppress_small`.", "question_id": 5153},
{"snippet": "polynomial.chebyshev.Chebyshev.fit(x, y, deg)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`.", "question_id": 5154},
{"snippet": "polynomial.chebyshev.Chebyshev.fit(x, y, deg, domain=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`.", "question_id": 5155},
{"snippet": "polynomial.chebyshev.Chebyshev.fit(x, y, deg, rcond=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `rcond`.", "question_id": 5156},
{"snippet": "polynomial.chebyshev.Chebyshev.fit(x, y, deg, full=False)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `full`.", "question_id": 5157},
{"snippet": "polynomial.chebyshev.Chebyshev.fit(x, y, deg, w=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `w`.", "question_id": 5158},
{"snippet": "polynomial.chebyshev.Chebyshev.fit(x, y, deg, window=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `window`.", "question_id": 5159},
{"snippet": "polynomial.chebyshev.Chebyshev.fit(x, y, deg, domain=None, rcond=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `rcond`.", "question_id": 5160},
{"snippet": "polynomial.chebyshev.Chebyshev.fit(x, y, deg, domain=None, full=False)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `full`.", "question_id": 5161},
{"snippet": "polynomial.chebyshev.Chebyshev.fit(x, y, deg, domain=None, w=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `w`.", "question_id": 5162},
{"snippet": "polynomial.chebyshev.Chebyshev.fit(x, y, deg, domain=None, window=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `window`.", "question_id": 5163},
{"snippet": "ma.MaskedArray.reshape(*s, **kwargs)", "intent": "Give a new shape to the array without changing its data . With arguments `*s`, `**kwargs`.", "question_id": 5164},
{"snippet": "char.islower(a)", "intent": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character , false otherwise . With arguments `a`.", "question_id": 5165},
{"snippet": "ma.power(a, b)", "intent": "Returns element-wise base array raised to power from second array . With arguments `a`, `b`.", "question_id": 5166},
{"snippet": "ma.power(a, b, third=None)", "intent": "Returns element-wise base array raised to power from second array . The out argument to numpy.power is not supported , `third` has to be None . With arguments `a`, `b`.", "question_id": 5167},
{"snippet": "numpy.real(val)", "intent": "Return the real part of the complex argument . With arguments `val`.", "question_id": 5168},
{"snippet": "ma.MaskedArray.ctypes", "intent": "An object to simplify the interaction of the array with the ctypes module.", "question_id": 5169},
{"snippet": "_ctypes.data", "intent": "A pointer to the memory area of the array as a Python integer.", "question_id": 5170},
{"snippet": "_ctypes.shape", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the C-integer corresponding to dtype('p') on this platform.", "question_id": 5171},
{"snippet": "_ctypes.strides", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the same as for the shape attribute.", "question_id": 5172},
{"snippet": "_ctypes.data_as(obj)", "intent": "Return the data pointer cast to a particular c-types object . With arguments `obj`.", "question_id": 5173},
{"snippet": "_ctypes.shape_as(obj)", "intent": "Return the shape tuple as an array of some other c-types type . With arguments `obj`.", "question_id": 5174},
{"snippet": "_ctypes.strides_as(obj)", "intent": "Return the strides tuple as an array of some other c-types type . With arguments `obj`.", "question_id": 5175},
{"snippet": "char.chararray.dot(b)", "intent": "Dot product of two arrays . With arguments `b`.", "question_id": 5176},
{"snippet": "char.chararray.dot(b, out=None)", "intent": "Dot product of two arrays . With arguments `b`, `out`.", "question_id": 5177},
{"snippet": "numpy.dstack(tup)", "intent": "Stack arrays in sequence depth wise ( along third axis ) . With arguments `tup`.", "question_id": 5178},
{"snippet": "polynomial.legendre.Legendre.basis(deg)", "intent": "Series basis polynomial of degree `deg` .", "question_id": 5179},
{"snippet": "polynomial.legendre.Legendre.basis(deg, domain=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `domain`.", "question_id": 5180},
{"snippet": "polynomial.legendre.Legendre.basis(deg, window=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `window`.", "question_id": 5181},
{"snippet": "polynomial.legendre.Legendre.basis(deg, domain=None, window=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `domain`, `window`.", "question_id": 5182},
{"snippet": "ma.std(self)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `self`.", "question_id": 5183},
{"snippet": "ma.std(self, axis=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `self`.", "question_id": 5184},
{"snippet": "ma.std(self, dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `self`, `dtype`.", "question_id": 5185},
{"snippet": "ma.std(self, out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `self`, `out`.", "question_id": 5186},
{"snippet": "ma.std(self, ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `self`, `ddof`.", "question_id": 5187},
{"snippet": "ma.std(self, keepdims=<no value>)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `self`, `keepdims`.", "question_id": 5188},
{"snippet": "ma.std(self, axis=None, dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `self`, `dtype`.", "question_id": 5189},
{"snippet": "ma.std(self, axis=None, out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `self`, `out`.", "question_id": 5190},
{"snippet": "ma.std(self, axis=None, ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `self`, `ddof`.", "question_id": 5191},
{"snippet": "ma.std(self, axis=None, keepdims=<no value>)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `self`, `keepdims`.", "question_id": 5192},
{"snippet": "fft.ifftn(a)", "intent": "Compute the N-dimensional inverse discrete Fourier Transform . In other words , ifftn ( fftn ( `a` ) ) == a to within numerical accuracy .", "question_id": 5193},
{"snippet": "fft.ifftn(a, s=None)", "intent": "Compute the N-dimensional inverse discrete Fourier Transform . In other words , ifftn ( fftn ( `a` ) ) == a to within numerical accuracy . With arguments `s`.", "question_id": 5194},
{"snippet": "fft.ifftn(a, axes=None)", "intent": "Compute the N-dimensional inverse discrete Fourier Transform . In other words , ifftn ( fftn ( `a` ) ) == a to within numerical accuracy . This function computes the inverse of the N-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) .", "question_id": 5195},
{"snippet": "fft.ifftn(a, norm=None)", "intent": "Compute the N-dimensional inverse discrete Fourier Transform . In other words , ifftn ( fftn ( `a` ) ) == a to within numerical accuracy . With arguments `norm`.", "question_id": 5196},
{"snippet": "fft.ifftn(a, s=None, axes=None)", "intent": "Compute the N-dimensional inverse discrete Fourier Transform . In other words , ifftn ( fftn ( `a` ) ) == a to within numerical accuracy . This function computes the inverse of the N-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `s`.", "question_id": 5197},
{"snippet": "fft.ifftn(a, s=None, norm=None)", "intent": "Compute the N-dimensional inverse discrete Fourier Transform . In other words , ifftn ( fftn ( `a` ) ) == a to within numerical accuracy . With arguments `s`, `norm`.", "question_id": 5198},
{"snippet": "fft.ifftn(a, axes=None, norm=None)", "intent": "Compute the N-dimensional inverse discrete Fourier Transform . In other words , ifftn ( fftn ( `a` ) ) == a to within numerical accuracy . This function computes the inverse of the N-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `norm`.", "question_id": 5199},
{"snippet": "fft.ifftn(a, s=None, axes=None, norm=None)", "intent": "Compute the N-dimensional inverse discrete Fourier Transform . In other words , ifftn ( fftn ( `a` ) ) == a to within numerical accuracy . This function computes the inverse of the N-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `s`, `norm`.", "question_id": 5200},
{"snippet": "numpy.who()", "intent": "Print the NumPy arrays in the given dictionary .", "question_id": 5201},
{"snippet": "numpy.who(vardict=None)", "intent": "Print the NumPy arrays in the given dictionary . If there is no dictionary passed in or `vardict` is None then returns NumPy arrays in the globals ( ) dictionary ( all NumPy arrays in the namespace ) .", "question_id": 5202},
{"snippet": "ndarray.__mul__(value, /)", "intent": "Return self * `value` . With arguments `/`.", "question_id": 5203},
{"snippet": "polynomial.polynomial.Polynomial.has_samewindow(other)", "intent": "Check if windows match . With arguments `other`.", "question_id": 5204},
{"snippet": "numpy.empty(shape)", "intent": "Return a new array of given `shape` and type , without initializing entries .", "question_id": 5205},
{"snippet": "numpy.empty(shape, dtype=float)", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `dtype`.", "question_id": 5206},
{"snippet": "numpy.empty(shape, order='C')", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `order`.", "question_id": 5207},
{"snippet": "numpy.empty(shape, like=None)", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `like`.", "question_id": 5208},
{"snippet": "numpy.empty(shape, dtype=float, order='C')", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `dtype`, `order`.", "question_id": 5209},
{"snippet": "numpy.empty(shape, dtype=float, like=None)", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `dtype`, `like`.", "question_id": 5210},
{"snippet": "numpy.empty(shape, order='C', like=None)", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `order`, `like`.", "question_id": 5211},
{"snippet": "numpy.empty(shape, dtype=float, order='C', like=None)", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `dtype`, `order`, `like`.", "question_id": 5212},
{"snippet": "chararray.dot(b)", "intent": "Dot product of two arrays . With arguments `b`.", "question_id": 5213},
{"snippet": "chararray.dot(b, out=None)", "intent": "Dot product of two arrays . With arguments `b`, `out`.", "question_id": 5214},
{"snippet": "matrix.getT()", "intent": "Returns the transpose of the matrix .", "question_id": 5215},
{"snippet": "numpy.base_repr(number)", "intent": "Return a string representation of a `number` in the given `base` system .", "question_id": 5216},
{"snippet": "numpy.base_repr(number, base=2)", "intent": "Return a string representation of a `number` in the given `base` system .", "question_id": 5217},
{"snippet": "numpy.base_repr(number, padding=0)", "intent": "Return a string representation of a `number` in the given `base` system . With arguments `padding`.", "question_id": 5218},
{"snippet": "numpy.base_repr(number, base=2, padding=0)", "intent": "Return a string representation of a `number` in the given `base` system . With arguments `padding`.", "question_id": 5219},
{"snippet": "numpy.flatnonzero(a)", "intent": "Return indices that are non-zero in the flattened version of `a` .", "question_id": 5220},
{"snippet": "polynomial.chebyshev.Chebyshev.basis(deg)", "intent": "Series basis polynomial of degree `deg` .", "question_id": 5221},
{"snippet": "polynomial.chebyshev.Chebyshev.basis(deg, domain=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `domain`.", "question_id": 5222},
{"snippet": "polynomial.chebyshev.Chebyshev.basis(deg, window=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `window`.", "question_id": 5223},
{"snippet": "polynomial.chebyshev.Chebyshev.basis(deg, domain=None, window=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `domain`, `window`.", "question_id": 5224},
{"snippet": "matrix.std()", "intent": "Return the standard deviation of the array elements along the given `axis` .", "question_id": 5225},
{"snippet": "matrix.std(axis=None)", "intent": "Return the standard deviation of the array elements along the given `axis` .", "question_id": 5226},
{"snippet": "matrix.std(dtype=None)", "intent": "Return the standard deviation of the array elements along the given `axis` . With arguments `dtype`.", "question_id": 5227},
{"snippet": "matrix.std(out=None)", "intent": "Return the standard deviation of the array elements along the given `axis` . With arguments `out`.", "question_id": 5228},
{"snippet": "matrix.std(ddof=0)", "intent": "Return the standard deviation of the array elements along the given `axis` . With arguments `ddof`.", "question_id": 5229},
{"snippet": "matrix.std(axis=None, dtype=None)", "intent": "Return the standard deviation of the array elements along the given `axis` . With arguments `dtype`.", "question_id": 5230},
{"snippet": "matrix.std(axis=None, out=None)", "intent": "Return the standard deviation of the array elements along the given `axis` . With arguments `out`.", "question_id": 5231},
{"snippet": "matrix.std(axis=None, ddof=0)", "intent": "Return the standard deviation of the array elements along the given `axis` . With arguments `ddof`.", "question_id": 5232},
{"snippet": "matrix.std(dtype=None, out=None)", "intent": "Return the standard deviation of the array elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 5233},
{"snippet": "matrix.std(dtype=None, ddof=0)", "intent": "Return the standard deviation of the array elements along the given `axis` . With arguments `dtype`, `ddof`.", "question_id": 5234},
{"snippet": "numpy.floor(x, /, signature, extobj)", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `extobj`.", "question_id": 5235},
{"snippet": "numpy.floor(x, /, signature, extobj, out=None)", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 5236},
{"snippet": "numpy.floor(x, /, signature, extobj, where=True)", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . Some spreadsheet programs calculate the \u201c floor-towards-zero \u201d , `where` floor ( -2.5 ) == -2 . With arguments `/`, `signature`, `extobj`.", "question_id": 5237},
{"snippet": "numpy.floor(x, /, signature, extobj, casting='same_kind')", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 5238},
{"snippet": "numpy.floor(x, /, signature, extobj, order='K')", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 5239},
{"snippet": "numpy.floor(x, /, signature, extobj, dtype=None)", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 5240},
{"snippet": "numpy.floor(x, /, signature, extobj, subok=True)", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 5241},
{"snippet": "numpy.floor(x, /, signature, extobj, out=None, where=True)", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . Some spreadsheet programs calculate the \u201c floor-towards-zero \u201d , `where` floor ( -2.5 ) == -2 . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 5242},
{"snippet": "numpy.floor(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 5243},
{"snippet": "numpy.floor(x, /, signature, extobj, out=None, order='K')", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 5244},
{"snippet": "numpy.floor(x, /, signature)", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`.", "question_id": 5245},
{"snippet": "numpy.floor(x, /, signature, out=None)", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `out`.", "question_id": 5246},
{"snippet": "numpy.floor(x, /, signature, where=True)", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . Some spreadsheet programs calculate the \u201c floor-towards-zero \u201d , `where` floor ( -2.5 ) == -2 . With arguments `/`, `signature`.", "question_id": 5247},
{"snippet": "numpy.floor(x, /, signature, casting='same_kind')", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `casting`.", "question_id": 5248},
{"snippet": "numpy.floor(x, /, signature, order='K')", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `order`.", "question_id": 5249},
{"snippet": "numpy.floor(x, /, signature, dtype=None)", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `dtype`.", "question_id": 5250},
{"snippet": "numpy.floor(x, /, signature, subok=True)", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `subok`.", "question_id": 5251},
{"snippet": "numpy.floor(x, /, signature, out=None, where=True)", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . Some spreadsheet programs calculate the \u201c floor-towards-zero \u201d , `where` floor ( -2.5 ) == -2 . With arguments `/`, `signature`, `out`.", "question_id": 5252},
{"snippet": "numpy.floor(x, /, signature, out=None, casting='same_kind')", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 5253},
{"snippet": "numpy.floor(x, /, signature, out=None, order='K')", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `out`, `order`.", "question_id": 5254},
{"snippet": "numpy.nanpercentile(a, q)", "intent": "Compute the qth percentile of the data along the specified `axis` , while ignoring nan values . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly .", "question_id": 5255},
{"snippet": "numpy.nanpercentile(a, q, axis=None)", "intent": "Compute the qth percentile of the data along the specified `axis` , while ignoring nan values . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly .", "question_id": 5256},
{"snippet": "numpy.nanpercentile(a, q, out=None)", "intent": "Compute the qth percentile of the data along the specified `axis` , while ignoring nan values . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . With arguments `out`.", "question_id": 5257},
{"snippet": "numpy.nanpercentile(a, q, overwrite_input=False)", "intent": "Compute the qth percentile of the data along the specified `axis` , while ignoring nan values . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . With arguments `overwrite_input`.", "question_id": 5258},
{"snippet": "numpy.nanpercentile(a, q, interpolation='linear')", "intent": "Compute the qth percentile of the data along the specified `axis` , while ignoring nan values . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly .", "question_id": 5259},
{"snippet": "numpy.nanpercentile(a, q, keepdims=<no value>)", "intent": "Compute the qth percentile of the data along the specified `axis` , while ignoring nan values . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . With arguments `keepdims`.", "question_id": 5260},
{"snippet": "numpy.nanpercentile(a, q, axis=None, out=None)", "intent": "Compute the qth percentile of the data along the specified `axis` , while ignoring nan values . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . With arguments `out`.", "question_id": 5261},
{"snippet": "numpy.nanpercentile(a, q, axis=None, overwrite_input=False)", "intent": "Compute the qth percentile of the data along the specified `axis` , while ignoring nan values . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . With arguments `overwrite_input`.", "question_id": 5262},
{"snippet": "numpy.nanpercentile(a, q, axis=None, interpolation='linear')", "intent": "Compute the qth percentile of the data along the specified `axis` , while ignoring nan values . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly .", "question_id": 5263},
{"snippet": "numpy.nanpercentile(a, q, axis=None, keepdims=<no value>)", "intent": "Compute the qth percentile of the data along the specified `axis` , while ignoring nan values . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . With arguments `keepdims`.", "question_id": 5264},
{"snippet": "ma.MaskedArray.__float__()", "intent": "Convert to float .", "question_id": 5265},
{"snippet": "ndarray.real", "intent": "The real part of the array.", "question_id": 5266},
{"snippet": "memmap.choose(choices)", "intent": "Use an index array to construct a new array from a set of `choices` .", "question_id": 5267},
{"snippet": "memmap.choose(choices, out=None)", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`.", "question_id": 5268},
{"snippet": "memmap.choose(choices, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `mode`.", "question_id": 5269},
{"snippet": "memmap.choose(choices, out=None, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`, `mode`.", "question_id": 5270},
{"snippet": "memmap.tobytes()", "intent": "Construct Python bytes containing the raw data bytes in the array .", "question_id": 5271},
{"snippet": "memmap.tobytes(order='C')", "intent": "Construct Python bytes containing the raw data bytes in the array . This behavior is controlled by the `order` parameter .", "question_id": 5272},
{"snippet": "random.RandomState.standard_t(df)", "intent": "Draw samples from a standard Student \u2019 s t distribution with `df` degrees of freedom .", "question_id": 5273},
{"snippet": "random.RandomState.standard_t(df, size=None)", "intent": "Draw samples from a standard Student \u2019 s t distribution with `df` degrees of freedom . With arguments `size`.", "question_id": 5274},
{"snippet": "numpy.record", "intent": "A data-type scalar that allows field access as attribute lookup.", "question_id": 5275},
{"snippet": "polynomial.polynomial.polyvalfromroots(x, r)", "intent": "Evaluate a polynomial specified by its roots at points `x` . If `r` is of length N , this function returns the value", "question_id": 5276},
{"snippet": "polynomial.polynomial.polyvalfromroots(x, r, tensor=True)", "intent": "Evaluate a polynomial specified by its roots at points `x` . If `r` is of length N , this function returns the value If r is multidimensional , then the shape of the result depends on the value of `tensor` .", "question_id": 5277},
{"snippet": "numpy.less_equal(x1, x2, /, signature, extobj)", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`.", "question_id": 5278},
{"snippet": "numpy.less_equal(x1, x2, /, signature, extobj, out=None)", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 5279},
{"snippet": "numpy.less_equal(x1, x2, /, signature, extobj, where=True)", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 5280},
{"snippet": "numpy.less_equal(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 5281},
{"snippet": "numpy.less_equal(x1, x2, /, signature, extobj, order='K')", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 5282},
{"snippet": "numpy.less_equal(x1, x2, /, signature, extobj, dtype=None)", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 5283},
{"snippet": "numpy.less_equal(x1, x2, /, signature, extobj, subok=True)", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 5284},
{"snippet": "numpy.less_equal(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 5285},
{"snippet": "numpy.less_equal(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 5286},
{"snippet": "numpy.less_equal(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 5287},
{"snippet": "numpy.less_equal(x1, x2, /, signature)", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`.", "question_id": 5288},
{"snippet": "numpy.less_equal(x1, x2, /, signature, out=None)", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `out`.", "question_id": 5289},
{"snippet": "numpy.less_equal(x1, x2, /, signature, where=True)", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `where`.", "question_id": 5290},
{"snippet": "numpy.less_equal(x1, x2, /, signature, casting='same_kind')", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `casting`.", "question_id": 5291},
{"snippet": "numpy.less_equal(x1, x2, /, signature, order='K')", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `order`.", "question_id": 5292},
{"snippet": "numpy.less_equal(x1, x2, /, signature, dtype=None)", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `dtype`.", "question_id": 5293},
{"snippet": "numpy.less_equal(x1, x2, /, signature, subok=True)", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `subok`.", "question_id": 5294},
{"snippet": "numpy.less_equal(x1, x2, /, signature, out=None, where=True)", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `out`, `where`.", "question_id": 5295},
{"snippet": "numpy.less_equal(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 5296},
{"snippet": "numpy.less_equal(x1, x2, /, signature, out=None, order='K')", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `out`, `order`.", "question_id": 5297},
{"snippet": "polynomial.laguerre.Laguerre.cast(series)", "intent": "Convert `series` to series of this class .", "question_id": 5298},
{"snippet": "polynomial.laguerre.Laguerre.cast(series, domain=None)", "intent": "Convert `series` to series of this class . With arguments `domain`.", "question_id": 5299},
{"snippet": "polynomial.laguerre.Laguerre.cast(series, window=None)", "intent": "Convert `series` to series of this class . With arguments `window`.", "question_id": 5300},
{"snippet": "polynomial.laguerre.Laguerre.cast(series, domain=None, window=None)", "intent": "Convert `series` to series of this class . With arguments `domain`, `window`.", "question_id": 5301},
{"snippet": "polynomial.polynomial.Polynomial.basis(deg)", "intent": "Series basis polynomial of degree `deg` .", "question_id": 5302},
{"snippet": "polynomial.polynomial.Polynomial.basis(deg, domain=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `domain`.", "question_id": 5303},
{"snippet": "polynomial.polynomial.Polynomial.basis(deg, window=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `window`.", "question_id": 5304},
{"snippet": "polynomial.polynomial.Polynomial.basis(deg, domain=None, window=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `domain`, `window`.", "question_id": 5305},
{"snippet": "polynomial.polynomial.polysub(c1, c2)", "intent": "Subtract one polynomial from another . Returns the difference of two polynomials `c1` - `c2` .", "question_id": 5306},
{"snippet": "numpy.not_equal(x1, x2, /, signature, extobj)", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`.", "question_id": 5307},
{"snippet": "numpy.not_equal(x1, x2, /, signature, extobj, out=None)", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 5308},
{"snippet": "numpy.not_equal(x1, x2, /, signature, extobj, where=True)", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 5309},
{"snippet": "numpy.not_equal(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 5310},
{"snippet": "numpy.not_equal(x1, x2, /, signature, extobj, order='K')", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 5311},
{"snippet": "numpy.not_equal(x1, x2, /, signature, extobj, dtype=None)", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 5312},
{"snippet": "numpy.not_equal(x1, x2, /, signature, extobj, subok=True)", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 5313},
{"snippet": "numpy.not_equal(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 5314},
{"snippet": "numpy.not_equal(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 5315},
{"snippet": "numpy.not_equal(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 5316},
{"snippet": "numpy.not_equal(x1, x2, /, signature)", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`.", "question_id": 5317},
{"snippet": "numpy.not_equal(x1, x2, /, signature, out=None)", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `out`.", "question_id": 5318},
{"snippet": "numpy.not_equal(x1, x2, /, signature, where=True)", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `where`.", "question_id": 5319},
{"snippet": "numpy.not_equal(x1, x2, /, signature, casting='same_kind')", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `casting`.", "question_id": 5320},
{"snippet": "numpy.not_equal(x1, x2, /, signature, order='K')", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `order`.", "question_id": 5321},
{"snippet": "numpy.not_equal(x1, x2, /, signature, dtype=None)", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `dtype`.", "question_id": 5322},
{"snippet": "numpy.not_equal(x1, x2, /, signature, subok=True)", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `subok`.", "question_id": 5323},
{"snippet": "numpy.not_equal(x1, x2, /, signature, out=None, where=True)", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `out`, `where`.", "question_id": 5324},
{"snippet": "numpy.not_equal(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 5325},
{"snippet": "numpy.not_equal(x1, x2, /, signature, out=None, order='K')", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `out`, `order`.", "question_id": 5326},
{"snippet": "recarray.newbyteorder(/)", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`.", "question_id": 5327},
{"snippet": "recarray.newbyteorder(/, new_order='S')", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`, `new_order`.", "question_id": 5328},
{"snippet": "random.RandomState.logseries(p)", "intent": "Draw samples from a logarithmic series distribution . Samples are drawn from a log series distribution with specified shape parameter , 0 < `p` < 1 .", "question_id": 5329},
{"snippet": "random.RandomState.logseries(p, size=None)", "intent": "Draw samples from a logarithmic series distribution . Samples are drawn from a log series distribution with specified shape parameter , 0 < `p` < 1 . With arguments `size`.", "question_id": 5330},
{"snippet": "lib.format.magic(major, minor)", "intent": "Return the magic string for the given file format version . With arguments `major`, `minor`.", "question_id": 5331},
{"snippet": "polynomial.chebyshev.chebsub(c1, c2)", "intent": "Subtract one Chebyshev series from another . Returns the difference of two Chebyshev series `c1` - `c2` .", "question_id": 5332},
{"snippet": "char.chararray.cumsum()", "intent": "Return the cumulative sum of the elements along the given `axis` .", "question_id": 5333},
{"snippet": "char.chararray.cumsum(axis=None)", "intent": "Return the cumulative sum of the elements along the given `axis` .", "question_id": 5334},
{"snippet": "char.chararray.cumsum(dtype=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`.", "question_id": 5335},
{"snippet": "char.chararray.cumsum(out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `out`.", "question_id": 5336},
{"snippet": "char.chararray.cumsum(axis=None, dtype=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`.", "question_id": 5337},
{"snippet": "char.chararray.cumsum(axis=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `out`.", "question_id": 5338},
{"snippet": "char.chararray.cumsum(dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 5339},
{"snippet": "char.chararray.cumsum(axis=None, dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 5340},
{"snippet": "polynomial.hermite_e.hermecompanion(c)", "intent": "Return the scaled companion matrix of `c` .", "question_id": 5341},
{"snippet": "matrix.argmax()", "intent": "Indexes of the maximum values along an `axis` .", "question_id": 5342},
{"snippet": "matrix.argmax(axis=None)", "intent": "Indexes of the maximum values along an `axis` .", "question_id": 5343},
{"snippet": "matrix.argmax(out=None)", "intent": "Indexes of the maximum values along an `axis` . With arguments `out`.", "question_id": 5344},
{"snippet": "matrix.argmax(axis=None, out=None)", "intent": "Indexes of the maximum values along an `axis` . With arguments `out`.", "question_id": 5345},
{"snippet": "numpy.datetime_as_string(arr)", "intent": "Convert an array of datetimes into an array of strings . With arguments `arr`.", "question_id": 5346},
{"snippet": "numpy.datetime_as_string(arr, unit=None)", "intent": "Convert an array of datetimes into an array of strings . Passing in a `unit` will change the precision With arguments `arr`.", "question_id": 5347},
{"snippet": "numpy.datetime_as_string(arr, timezone='naive')", "intent": "Convert an array of datetimes into an array of strings . Setting the `timezone` to UTC shows the same information , but with a Z suffix With arguments `arr`.", "question_id": 5348},
{"snippet": "numpy.datetime_as_string(arr, casting='same_kind')", "intent": "Convert an array of datetimes into an array of strings . \u2018 `casting` \u2019 can be used to specify whether precision can be changed With arguments `arr`.", "question_id": 5349},
{"snippet": "numpy.datetime_as_string(arr, unit=None, timezone='naive')", "intent": "Convert an array of datetimes into an array of strings . Passing in a `unit` will change the precision Setting the `timezone` to UTC shows the same information , but with a Z suffix With arguments `arr`.", "question_id": 5350},
{"snippet": "numpy.datetime_as_string(arr, unit=None, casting='same_kind')", "intent": "Convert an array of datetimes into an array of strings . Passing in a `unit` will change the precision \u2018 `casting` \u2019 can be used to specify whether precision can be changed With arguments `arr`.", "question_id": 5351},
{"snippet": "numpy.datetime_as_string(arr, timezone='naive', casting='same_kind')", "intent": "Convert an array of datetimes into an array of strings . Setting the `timezone` to UTC shows the same information , but with a Z suffix \u2018 `casting` \u2019 can be used to specify whether precision can be changed With arguments `arr`.", "question_id": 5352},
{"snippet": "numpy.datetime_as_string(arr, unit=None, timezone='naive', casting='same_kind')", "intent": "Convert an array of datetimes into an array of strings . Passing in a `unit` will change the precision Setting the `timezone` to UTC shows the same information , but with a Z suffix \u2018 `casting` \u2019 can be used to specify whether precision can be changed With arguments `arr`.", "question_id": 5353},
{"snippet": "chararray.conjugate()", "intent": "Return the complex conjugate , element-wise .", "question_id": 5354},
{"snippet": "polynomial.polynomial.polyvander2d(x, y, deg)", "intent": "Pseudo-Vandermonde matrix of given degrees . Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points ( `x` , `y` ) .", "question_id": 5355},
{"snippet": "ma.MaskType.round()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 5356},
{"snippet": "random.zipf(a)", "intent": "Draw samples from `a` Zipf distribution .", "question_id": 5357},
{"snippet": "random.zipf(a, size=None)", "intent": "Draw samples from `a` Zipf distribution . With arguments `size`.", "question_id": 5358},
{"snippet": "numpy.sinh(x, /, signature, extobj)", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . With arguments `/`, `signature`, `extobj`.", "question_id": 5359},
{"snippet": "numpy.sinh(x, /, signature, extobj, out=None)", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `extobj`.", "question_id": 5360},
{"snippet": "numpy.sinh(x, /, signature, extobj, where=True)", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 5361},
{"snippet": "numpy.sinh(x, /, signature, extobj, casting='same_kind')", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 5362},
{"snippet": "numpy.sinh(x, /, signature, extobj, order='K')", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 5363},
{"snippet": "numpy.sinh(x, /, signature, extobj, dtype=None)", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 5364},
{"snippet": "numpy.sinh(x, /, signature, extobj, subok=True)", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 5365},
{"snippet": "numpy.sinh(x, /, signature, extobj, out=None, where=True)", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 5366},
{"snippet": "numpy.sinh(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 5367},
{"snippet": "numpy.sinh(x, /, signature, extobj, out=None, order='K')", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 5368},
{"snippet": "numpy.sinh(x, /, signature)", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . With arguments `/`, `signature`.", "question_id": 5369},
{"snippet": "numpy.sinh(x, /, signature, out=None)", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`.", "question_id": 5370},
{"snippet": "numpy.sinh(x, /, signature, where=True)", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . With arguments `/`, `signature`, `where`.", "question_id": 5371},
{"snippet": "numpy.sinh(x, /, signature, casting='same_kind')", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . With arguments `/`, `signature`, `casting`.", "question_id": 5372},
{"snippet": "numpy.sinh(x, /, signature, order='K')", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . With arguments `/`, `signature`, `order`.", "question_id": 5373},
{"snippet": "numpy.sinh(x, /, signature, dtype=None)", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . With arguments `/`, `signature`, `dtype`.", "question_id": 5374},
{"snippet": "numpy.sinh(x, /, signature, subok=True)", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . With arguments `/`, `signature`, `subok`.", "question_id": 5375},
{"snippet": "numpy.sinh(x, /, signature, out=None, where=True)", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `where`.", "question_id": 5376},
{"snippet": "numpy.sinh(x, /, signature, out=None, casting='same_kind')", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `casting`.", "question_id": 5377},
{"snippet": "numpy.sinh(x, /, signature, out=None, order='K')", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `order`.", "question_id": 5378},
{"snippet": "polynomial.hermite_e.hermeint(c)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 5379},
{"snippet": "polynomial.hermite_e.hermeint(c, m=1)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 5380},
{"snippet": "polynomial.hermite_e.hermeint(c, k=)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 5381},
{"snippet": "polynomial.hermite_e.hermeint(c, lbnd=0)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 5382},
{"snippet": "polynomial.hermite_e.hermeint(c, scl=1)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 5383},
{"snippet": "polynomial.hermite_e.hermeint(c, axis=0)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 5384},
{"snippet": "polynomial.hermite_e.hermeint(c, m=1, k=)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 5385},
{"snippet": "polynomial.hermite_e.hermeint(c, m=1, lbnd=0)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 5386},
{"snippet": "polynomial.hermite_e.hermeint(c, m=1, scl=1)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 5387},
{"snippet": "polynomial.hermite_e.hermeint(c, m=1, axis=0)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 5388},
{"snippet": "polynomial.hermite_e.hermeint()", "intent": "Integrate a Hermite_e series .", "question_id": 5389},
{"snippet": "polynomial.hermite_e.hermeint(m=1)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 5390},
{"snippet": "polynomial.hermite_e.hermeint(k=)", "intent": "Integrate a Hermite_e series . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 5391},
{"snippet": "polynomial.hermite_e.hermeint(lbnd=0)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 5392},
{"snippet": "polynomial.hermite_e.hermeint(scl=1)", "intent": "Integrate a Hermite_e series . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 5393},
{"snippet": "polynomial.hermite_e.hermeint(axis=0)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 5394},
{"snippet": "polynomial.hermite_e.hermeint(m=1, k=)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 5395},
{"snippet": "polynomial.hermite_e.hermeint(m=1, lbnd=0)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 5396},
{"snippet": "polynomial.hermite_e.hermeint(m=1, scl=1)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 5397},
{"snippet": "polynomial.hermite_e.hermeint(m=1, axis=0)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 5398},
{"snippet": "ma.isMaskedArray(x)", "intent": "Test whether input is an instance of MaskedArray . This function returns True if `x` is an instance of MaskedArray and returns False otherwise .", "question_id": 5399},
{"snippet": "random.Generator.random()", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) .", "question_id": 5400},
{"snippet": "random.Generator.random(size=None)", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) . With arguments `size`.", "question_id": 5401},
{"snippet": "random.Generator.random(dtype=np.float64)", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) . With arguments `dtype`.", "question_id": 5402},
{"snippet": "random.Generator.random(out=None)", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) . With arguments `out`.", "question_id": 5403},
{"snippet": "random.Generator.random(size=None, dtype=np.float64)", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) . With arguments `size`, `dtype`.", "question_id": 5404},
{"snippet": "random.Generator.random(size=None, out=None)", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) . With arguments `size`, `out`.", "question_id": 5405},
{"snippet": "random.Generator.random(dtype=np.float64, out=None)", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) . With arguments `dtype`, `out`.", "question_id": 5406},
{"snippet": "random.Generator.random(size=None, dtype=np.float64, out=None)", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) . With arguments `size`, `dtype`, `out`.", "question_id": 5407},
{"snippet": "dtype.subdtype", "intent": "Tuple (item_dtype, shape) if this dtype describes a sub-array, and None otherwise.", "question_id": 5408},
{"snippet": "numpy.format_float_scientific(x)", "intent": "Format a floating-point scalar as a decimal string in scientific notation . With arguments `x`.", "question_id": 5409},
{"snippet": "numpy.format_float_scientific(x, precision=None)", "intent": "Format a floating-point scalar as a decimal string in scientific notation . With arguments `x`, `precision`.", "question_id": 5410},
{"snippet": "numpy.format_float_scientific(x, unique=True)", "intent": "Format a floating-point scalar as a decimal string in scientific notation . With arguments `x`, `unique`.", "question_id": 5411},
{"snippet": "numpy.format_float_scientific(x, trim='k')", "intent": "Format a floating-point scalar as a decimal string in scientific notation . With arguments `x`, `trim`.", "question_id": 5412},
{"snippet": "numpy.format_float_scientific(x, sign=False)", "intent": "Format a floating-point scalar as a decimal string in scientific notation . With arguments `x`, `sign`.", "question_id": 5413},
{"snippet": "numpy.format_float_scientific(x, pad_left=None)", "intent": "Format a floating-point scalar as a decimal string in scientific notation . With arguments `x`, `pad_left`.", "question_id": 5414},
{"snippet": "numpy.format_float_scientific(x, exp_digits=None)", "intent": "Format a floating-point scalar as a decimal string in scientific notation . With arguments `x`, `exp_digits`.", "question_id": 5415},
{"snippet": "numpy.format_float_scientific(x, min_digits=None)", "intent": "Format a floating-point scalar as a decimal string in scientific notation . With arguments `x`, `min_digits`.", "question_id": 5416},
{"snippet": "numpy.format_float_scientific(x, precision=None, unique=True)", "intent": "Format a floating-point scalar as a decimal string in scientific notation . With arguments `x`, `precision`, `unique`.", "question_id": 5417},
{"snippet": "numpy.format_float_scientific(x, precision=None, trim='k')", "intent": "Format a floating-point scalar as a decimal string in scientific notation . With arguments `x`, `precision`, `trim`.", "question_id": 5418},
{"snippet": "random.RandomState.chisquare(df)", "intent": "Draw samples from a chi-square distribution . When `df` independent random variables , each with standard normal distributions ( mean 0 , variance 1 ) , are squared and summed , the resulting distribution is chi-square ( see Notes ) .", "question_id": 5419},
{"snippet": "random.RandomState.chisquare(df, size=None)", "intent": "Draw samples from a chi-square distribution . When `df` independent random variables , each with standard normal distributions ( mean 0 , variance 1 ) , are squared and summed , the resulting distribution is chi-square ( see Notes ) . With arguments `size`.", "question_id": 5420},
{"snippet": "ma.frombuffer(buffer)", "intent": "Interpret a `buffer` as a 1-dimensional array .", "question_id": 5421},
{"snippet": "ma.frombuffer(buffer, dtype=float)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `dtype`.", "question_id": 5422},
{"snippet": "ma.frombuffer(buffer, count=- 1)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `count`.", "question_id": 5423},
{"snippet": "ma.frombuffer(buffer, offset=0)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `offset`.", "question_id": 5424},
{"snippet": "ma.frombuffer(buffer, like=None)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `like`.", "question_id": 5425},
{"snippet": "ma.frombuffer(buffer, dtype=float, count=- 1)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `dtype`, `count`.", "question_id": 5426},
{"snippet": "ma.frombuffer(buffer, dtype=float, offset=0)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `dtype`, `offset`.", "question_id": 5427},
{"snippet": "ma.frombuffer(buffer, dtype=float, like=None)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `dtype`, `like`.", "question_id": 5428},
{"snippet": "ma.frombuffer(buffer, count=- 1, offset=0)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `count`, `offset`.", "question_id": 5429},
{"snippet": "ma.frombuffer(buffer, count=- 1, like=None)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `count`, `like`.", "question_id": 5430},
{"snippet": "numpy.poly1d(c_or_r)", "intent": "A one-dimensional polynomial class . With arguments `c_or_r`.", "question_id": 5431},
{"snippet": "numpy.poly1d(c_or_r, r=False)", "intent": "A one-dimensional polynomial class . With arguments `c_or_r`, `r`.", "question_id": 5432},
{"snippet": "numpy.poly1d(c_or_r, variable=None)", "intent": "A one-dimensional polynomial class . The `variable` used in the string representation of p can be modified , using the variable parameter : With arguments `c_or_r`.", "question_id": 5433},
{"snippet": "numpy.poly1d(c_or_r, r=False, variable=None)", "intent": "A one-dimensional polynomial class . The `variable` used in the string representation of p can be modified , using the variable parameter : With arguments `c_or_r`, `r`.", "question_id": 5434},
{"snippet": "ma.MaskType.swapaxes()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 5435},
{"snippet": "record.itemsize", "intent": "The length of one element in bytes.", "question_id": 5436},
{"snippet": "ma.MaskedArray.__getitem__(indx)", "intent": "x.__getitem__ ( y ) < == > x [ y ] With arguments `indx`.", "question_id": 5437},
{"snippet": "ma.MaskedArray.trace()", "intent": "Return the sum along diagonals of the array .", "question_id": 5438},
{"snippet": "ma.MaskedArray.trace(offset=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`.", "question_id": 5439},
{"snippet": "ma.MaskedArray.trace(axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `axis1`.", "question_id": 5440},
{"snippet": "ma.MaskedArray.trace(axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `axis2`.", "question_id": 5441},
{"snippet": "ma.MaskedArray.trace(dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `dtype`.", "question_id": 5442},
{"snippet": "ma.MaskedArray.trace(out=None)", "intent": "Return the sum along diagonals of the array . With arguments `out`.", "question_id": 5443},
{"snippet": "ma.MaskedArray.trace(offset=0, axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis1`.", "question_id": 5444},
{"snippet": "ma.MaskedArray.trace(offset=0, axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis2`.", "question_id": 5445},
{"snippet": "ma.MaskedArray.trace(offset=0, dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `dtype`.", "question_id": 5446},
{"snippet": "ma.MaskedArray.trace(offset=0, out=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `out`.", "question_id": 5447},
{"snippet": "polynomial.hermite_e.HermiteE.has_samewindow(other)", "intent": "Check if windows match . With arguments `other`.", "question_id": 5448},
{"snippet": "polynomial.set_default_printstyle(style)", "intent": "Set the default format for the string representation of polynomials . Values for `style` must be valid inputs to __format__ , i.e .", "question_id": 5449},
{"snippet": "dtype.alignment", "intent": "The required alignment (bytes) of this data-type according to the compiler.", "question_id": 5450},
{"snippet": "chararray.conj()", "intent": "Complex-conjugate all elements .", "question_id": 5451},
{"snippet": "polynomial.hermite_e.HermiteE.integ()", "intent": "Integrate .", "question_id": 5452},
{"snippet": "polynomial.hermite_e.HermiteE.integ(m=1)", "intent": "Integrate . With arguments `m`.", "question_id": 5453},
{"snippet": "polynomial.hermite_e.HermiteE.integ(k=)", "intent": "Integrate . With arguments `k`.", "question_id": 5454},
{"snippet": "polynomial.hermite_e.HermiteE.integ(lbnd=None)", "intent": "Integrate . With arguments `lbnd`.", "question_id": 5455},
{"snippet": "polynomial.hermite_e.HermiteE.integ(m=1, k=)", "intent": "Integrate . With arguments `m`, `k`.", "question_id": 5456},
{"snippet": "polynomial.hermite_e.HermiteE.integ(m=1, lbnd=None)", "intent": "Integrate . With arguments `m`, `lbnd`.", "question_id": 5457},
{"snippet": "polynomial.hermite_e.HermiteE.integ(k=, lbnd=None)", "intent": "Integrate . With arguments `k`, `lbnd`.", "question_id": 5458},
{"snippet": "polynomial.hermite_e.HermiteE.integ(m=1, k=, lbnd=None)", "intent": "Integrate . With arguments `m`, `k`, `lbnd`.", "question_id": 5459},
{"snippet": "polynomial.hermite_e.HermiteE.integ()", "intent": "Integrate .", "question_id": 5460},
{"snippet": "polynomial.hermite_e.HermiteE.integ(m=1)", "intent": "Integrate . With arguments `m`.", "question_id": 5461},
{"snippet": "polynomial.hermite_e.HermiteE.integ(k=)", "intent": "Integrate . With arguments `k`.", "question_id": 5462},
{"snippet": "polynomial.hermite_e.HermiteE.integ(lbnd=None)", "intent": "Integrate . With arguments `lbnd`.", "question_id": 5463},
{"snippet": "polynomial.hermite_e.HermiteE.integ(m=1, k=)", "intent": "Integrate . With arguments `m`, `k`.", "question_id": 5464},
{"snippet": "polynomial.hermite_e.HermiteE.integ(m=1, lbnd=None)", "intent": "Integrate . With arguments `m`, `lbnd`.", "question_id": 5465},
{"snippet": "polynomial.hermite_e.HermiteE.integ(k=, lbnd=None)", "intent": "Integrate . With arguments `k`, `lbnd`.", "question_id": 5466},
{"snippet": "polynomial.hermite_e.HermiteE.integ(m=1, k=, lbnd=None)", "intent": "Integrate . With arguments `m`, `k`, `lbnd`.", "question_id": 5467},
{"snippet": "numpy.tril_indices_from(arr)", "intent": "Return the indices for the lower-triangle of `arr` .", "question_id": 5468},
{"snippet": "numpy.tril_indices_from(arr, k=0)", "intent": "Return the indices for the lower-triangle of `arr` . With arguments `k`.", "question_id": 5469},
{"snippet": "char.split(a)", "intent": "For each element in `a` , return a list of the words in the string , using `sep` as the delimiter string .", "question_id": 5470},
{"snippet": "char.split(a, sep=None)", "intent": "For each element in `a` , return a list of the words in the string , using `sep` as the delimiter string .", "question_id": 5471},
{"snippet": "char.split(a, maxsplit=None)", "intent": "For each element in `a` , return a list of the words in the string , using `sep` as the delimiter string . With arguments `maxsplit`.", "question_id": 5472},
{"snippet": "char.split(a, sep=None, maxsplit=None)", "intent": "For each element in `a` , return a list of the words in the string , using `sep` as the delimiter string . With arguments `maxsplit`.", "question_id": 5473},
{"snippet": "ma.masked_array.reshape(*s, **kwargs)", "intent": "Give a new shape to the array without changing its data . With arguments `*s`, `**kwargs`.", "question_id": 5474},
{"snippet": "char.chararray.conj()", "intent": "Complex-conjugate all elements .", "question_id": 5475},
{"snippet": "numpy.fromstring(string)", "intent": "A new 1-D array initialized from text data in a `string` .", "question_id": 5476},
{"snippet": "numpy.fromstring(string, dtype=float)", "intent": "A new 1-D array initialized from text data in a `string` . With arguments `dtype`.", "question_id": 5477},
{"snippet": "numpy.fromstring(string, count=- 1)", "intent": "A new 1-D array initialized from text data in a `string` . With arguments `count`.", "question_id": 5478},
{"snippet": "numpy.fromstring(string, sep='')", "intent": "A new 1-D array initialized from text data in a `string` . With arguments `sep`.", "question_id": 5479},
{"snippet": "numpy.fromstring(string, like=None)", "intent": "A new 1-D array initialized from text data in a `string` . With arguments `like`.", "question_id": 5480},
{"snippet": "numpy.fromstring(string, dtype=float, count=- 1)", "intent": "A new 1-D array initialized from text data in a `string` . With arguments `dtype`, `count`.", "question_id": 5481},
{"snippet": "numpy.fromstring(string, dtype=float, sep='')", "intent": "A new 1-D array initialized from text data in a `string` . With arguments `dtype`, `sep`.", "question_id": 5482},
{"snippet": "numpy.fromstring(string, dtype=float, like=None)", "intent": "A new 1-D array initialized from text data in a `string` . With arguments `dtype`, `like`.", "question_id": 5483},
{"snippet": "numpy.fromstring(string, count=- 1, sep='')", "intent": "A new 1-D array initialized from text data in a `string` . With arguments `count`, `sep`.", "question_id": 5484},
{"snippet": "numpy.fromstring(string, count=- 1, like=None)", "intent": "A new 1-D array initialized from text data in a `string` . With arguments `count`, `like`.", "question_id": 5485},
{"snippet": "ma.MaskedArray.toflex()", "intent": "Transforms a masked array into a flexible-type array .", "question_id": 5486},
{"snippet": "random.RandomState.weibull(a)", "intent": "Draw samples from `a` Weibull distribution .", "question_id": 5487},
{"snippet": "random.RandomState.weibull(a, size=None)", "intent": "Draw samples from `a` Weibull distribution . With arguments `size`.", "question_id": 5488},
{"snippet": "matrix.dumps()", "intent": "Returns the pickle of the array as a string .", "question_id": 5489},
{"snippet": "polynomial.hermite_e.HermiteE.truncate(size)", "intent": "Truncate series to length `size` .", "question_id": 5490},
{"snippet": "polynomial.chebyshev.chebtrim(c)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . With arguments `c`.", "question_id": 5491},
{"snippet": "polynomial.chebyshev.chebtrim(c, tol=0)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . \u201c Small \u201d means \u201c small in absolute value \u201d and is controlled by the parameter `tol` ; \u201c trailing \u201d means highest order coefficient ( s ) , e.g. , in [ 0 , 1 , 1 , 0 , 0 ] ( which represents 0 + x + x * * 2 + 0 * x * * 3 + 0 * x * * 4 ) both the 3-rd and 4-th order coefficients would be \u201c trimmed . \u201d With arguments `c`.", "question_id": 5492},
{"snippet": "numpy.heaviside(x1, x2, /, signature, extobj)", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `extobj`.", "question_id": 5493},
{"snippet": "numpy.heaviside(x1, x2, /, signature, extobj, out=None)", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `extobj`, `out`.", "question_id": 5494},
{"snippet": "numpy.heaviside(x1, x2, /, signature, extobj, where=True)", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `extobj`.", "question_id": 5495},
{"snippet": "numpy.heaviside(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `extobj`, `casting`.", "question_id": 5496},
{"snippet": "numpy.heaviside(x1, x2, /, signature, extobj, order='K')", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `extobj`, `order`.", "question_id": 5497},
{"snippet": "numpy.heaviside(x1, x2, /, signature, extobj, dtype=None)", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `extobj`, `dtype`.", "question_id": 5498},
{"snippet": "numpy.heaviside(x1, x2, /, signature, extobj, subok=True)", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `extobj`, `subok`.", "question_id": 5499},
{"snippet": "numpy.heaviside(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `extobj`, `out`.", "question_id": 5500},
{"snippet": "numpy.heaviside(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 5501},
{"snippet": "numpy.heaviside(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 5502},
{"snippet": "numpy.heaviside(x1, x2, /, signature)", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`.", "question_id": 5503},
{"snippet": "numpy.heaviside(x1, x2, /, signature, out=None)", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `out`.", "question_id": 5504},
{"snippet": "numpy.heaviside(x1, x2, /, signature, where=True)", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`.", "question_id": 5505},
{"snippet": "numpy.heaviside(x1, x2, /, signature, casting='same_kind')", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `casting`.", "question_id": 5506},
{"snippet": "numpy.heaviside(x1, x2, /, signature, order='K')", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `order`.", "question_id": 5507},
{"snippet": "numpy.heaviside(x1, x2, /, signature, dtype=None)", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `dtype`.", "question_id": 5508},
{"snippet": "numpy.heaviside(x1, x2, /, signature, subok=True)", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `subok`.", "question_id": 5509},
{"snippet": "numpy.heaviside(x1, x2, /, signature, out=None, where=True)", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `out`.", "question_id": 5510},
{"snippet": "numpy.heaviside(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `out`, `casting`.", "question_id": 5511},
{"snippet": "numpy.heaviside(x1, x2, /, signature, out=None, order='K')", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `out`, `order`.", "question_id": 5512},
{"snippet": "polynomial.hermite_e.HermiteE.has_sametype(other)", "intent": "Check if types match . With arguments `other`.", "question_id": 5513},
{"snippet": "numpy.array_split(ary, indices_or_sections)", "intent": "Split an array into multiple sub-arrays . The only difference between these functions is that array_split allows `indices_or_sections` to be an integer that does not equally divide the `axis` . With arguments `ary`.", "question_id": 5514},
{"snippet": "numpy.array_split(ary, indices_or_sections, axis=0)", "intent": "Split an array into multiple sub-arrays . The only difference between these functions is that array_split allows `indices_or_sections` to be an integer that does not equally divide the `axis` . With arguments `ary`.", "question_id": 5515},
{"snippet": "ma.MaskedArray.diagonal()", "intent": "Return specified diagonals .", "question_id": 5516},
{"snippet": "ma.MaskedArray.diagonal(offset=0)", "intent": "Return specified diagonals . With arguments `offset`.", "question_id": 5517},
{"snippet": "ma.MaskedArray.diagonal(axis1=0)", "intent": "Return specified diagonals . With arguments `axis1`.", "question_id": 5518},
{"snippet": "ma.MaskedArray.diagonal(axis2=1)", "intent": "Return specified diagonals . With arguments `axis2`.", "question_id": 5519},
{"snippet": "ma.MaskedArray.diagonal(offset=0, axis1=0)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`.", "question_id": 5520},
{"snippet": "ma.MaskedArray.diagonal(offset=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis2`.", "question_id": 5521},
{"snippet": "ma.MaskedArray.diagonal(axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `axis1`, `axis2`.", "question_id": 5522},
{"snippet": "ma.MaskedArray.diagonal(offset=0, axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`, `axis2`.", "question_id": 5523},
{"snippet": "ma.masked_array.toflex()", "intent": "Transforms a masked array into a flexible-type array .", "question_id": 5524},
{"snippet": "chararray.tofile(fid)", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method .", "question_id": 5525},
{"snippet": "chararray.tofile(fid, sep='')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `sep`.", "question_id": 5526},
{"snippet": "chararray.tofile(fid, format='%s')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `format`.", "question_id": 5527},
{"snippet": "chararray.tofile(fid, sep='', format='%s')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `sep`, `format`.", "question_id": 5528},
{"snippet": "distutils.exec_command.find_executable(exe)", "intent": "Return full `path` of a executable or None . With arguments `exe`.", "question_id": 5529},
{"snippet": "distutils.exec_command.find_executable(exe, path=None)", "intent": "Return full `path` of a executable or None . With arguments `exe`.", "question_id": 5530},
{"snippet": "distutils.exec_command.find_executable(exe, _cache={})", "intent": "Return full `path` of a executable or None . With arguments `exe`, `_cache`.", "question_id": 5531},
{"snippet": "distutils.exec_command.find_executable(exe, path=None, _cache={})", "intent": "Return full `path` of a executable or None . With arguments `exe`, `_cache`.", "question_id": 5532},
{"snippet": "char.chararray.startswith(prefix)", "intent": "Returns a boolean array which is True where the string element in self starts with `prefix` , otherwise False .", "question_id": 5533},
{"snippet": "char.chararray.startswith(prefix, start=0)", "intent": "Returns a boolean array which is True where the string element in self starts with `prefix` , otherwise False . With arguments `start`.", "question_id": 5534},
{"snippet": "char.chararray.startswith(prefix, end=None)", "intent": "Returns a boolean array which is True where the string element in self starts with `prefix` , otherwise False . With arguments `end`.", "question_id": 5535},
{"snippet": "char.chararray.startswith(prefix, start=0, end=None)", "intent": "Returns a boolean array which is True where the string element in self starts with `prefix` , otherwise False . With arguments `start`, `end`.", "question_id": 5536},
{"snippet": "matrix.real", "intent": "The real part of the array.", "question_id": 5537},
{"snippet": "ma.MaskType.imag", "intent": "The imaginary part of the scalar.", "question_id": 5538},
{"snippet": "polynomial.hermite_e.hermegrid2d(x, y, c)", "intent": "Evaluate a 2-D HermiteE series on the Cartesian product of `x` and `y` . In either case , either x and y or their elements must support multiplication and addition both with themselves and with the elements of `c` .", "question_id": 5539},
{"snippet": "dtype.names", "intent": "Ordered list of field names, or None if there are no fields.", "question_id": 5540},
{"snippet": "recarray.any()", "intent": "Returns True if any of the elements of a evaluate to True .", "question_id": 5541},
{"snippet": "recarray.any(axis=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`.", "question_id": 5542},
{"snippet": "recarray.any(out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`.", "question_id": 5543},
{"snippet": "recarray.any(keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `keepdims`.", "question_id": 5544},
{"snippet": "recarray.any(where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `where`.", "question_id": 5545},
{"snippet": "recarray.any(axis=None, out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `out`.", "question_id": 5546},
{"snippet": "recarray.any(axis=None, keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `keepdims`.", "question_id": 5547},
{"snippet": "recarray.any(axis=None, where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `where`.", "question_id": 5548},
{"snippet": "recarray.any(out=None, keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`, `keepdims`.", "question_id": 5549},
{"snippet": "recarray.any(out=None, where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`, `where`.", "question_id": 5550},
{"snippet": "numpy.lexsort(keys)", "intent": "Perform an indirect stable sort using a sequence of `keys` .", "question_id": 5551},
{"snippet": "numpy.lexsort(keys, axis=- 1)", "intent": "Perform an indirect stable sort using a sequence of `keys` . With arguments `axis`.", "question_id": 5552},
{"snippet": "ma.MaskType.tostring()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 5553},
{"snippet": "polynomial.legendre.Legendre.degree()", "intent": "The degree of the series .", "question_id": 5554},
{"snippet": "numpy.polynomial.hermite.Hermite(coef)", "intent": "An Hermite series class . With arguments `coef`.", "question_id": 5555},
{"snippet": "numpy.polynomial.hermite.Hermite(coef, domain=None)", "intent": "An Hermite series class . With arguments `coef`, `domain`.", "question_id": 5556},
{"snippet": "numpy.polynomial.hermite.Hermite(coef, window=None)", "intent": "An Hermite series class . With arguments `coef`, `window`.", "question_id": 5557},
{"snippet": "numpy.polynomial.hermite.Hermite(coef, domain=None, window=None)", "intent": "An Hermite series class . With arguments `coef`, `domain`, `window`.", "question_id": 5558},
{"snippet": "lib.format.read_array_header_2_0(fp)", "intent": "Read an array header from a filelike object using the 2.0 file format version . With arguments `fp`.", "question_id": 5559},
{"snippet": "polynomial.hermite_e.HermiteE.linspace()", "intent": "Return x , y values at equally spaced points in `domain` .", "question_id": 5560},
{"snippet": "polynomial.hermite_e.HermiteE.linspace(n=100)", "intent": "Return x , y values at equally spaced points in `domain` . Returns the x , y values at `n` linearly spaced points across the domain .", "question_id": 5561},
{"snippet": "polynomial.hermite_e.HermiteE.linspace(domain=None)", "intent": "Return x , y values at equally spaced points in `domain` .", "question_id": 5562},
{"snippet": "polynomial.hermite_e.HermiteE.linspace(n=100, domain=None)", "intent": "Return x , y values at equally spaced points in `domain` . Returns the x , y values at `n` linearly spaced points across the domain .", "question_id": 5563},
{"snippet": "polynomial.polynomial.polyder(c)", "intent": "Differentiate a polynomial . Returns the polynomial coefficients `c` differentiated `m` times along `axis` .", "question_id": 5564},
{"snippet": "polynomial.polynomial.polyder(c, m=1)", "intent": "Differentiate a polynomial . Returns the polynomial coefficients `c` differentiated `m` times along `axis` .", "question_id": 5565},
{"snippet": "polynomial.polynomial.polyder(c, scl=1)", "intent": "Differentiate a polynomial . Returns the polynomial coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) .", "question_id": 5566},
{"snippet": "polynomial.polynomial.polyder(c, axis=0)", "intent": "Differentiate a polynomial . Returns the polynomial coefficients `c` differentiated `m` times along `axis` .", "question_id": 5567},
{"snippet": "polynomial.polynomial.polyder(c, m=1, scl=1)", "intent": "Differentiate a polynomial . Returns the polynomial coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) .", "question_id": 5568},
{"snippet": "polynomial.polynomial.polyder(c, m=1, axis=0)", "intent": "Differentiate a polynomial . Returns the polynomial coefficients `c` differentiated `m` times along `axis` .", "question_id": 5569},
{"snippet": "polynomial.polynomial.polyder(c, scl=1, axis=0)", "intent": "Differentiate a polynomial . Returns the polynomial coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) .", "question_id": 5570},
{"snippet": "polynomial.polynomial.polyder(c, m=1, scl=1, axis=0)", "intent": "Differentiate a polynomial . Returns the polynomial coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) .", "question_id": 5571},
{"snippet": "lib.stride_tricks.sliding_window_view(x, window_shape)", "intent": "Create a sliding window view into the array with the given window shape . With arguments `x`, `window_shape`.", "question_id": 5572},
{"snippet": "lib.stride_tricks.sliding_window_view(x, window_shape, axis=None)", "intent": "Create a sliding window view into the array with the given window shape . The `axis` can be specified explicitly : With arguments `x`, `window_shape`.", "question_id": 5573},
{"snippet": "lib.stride_tricks.sliding_window_view(x, window_shape, subok=False)", "intent": "Create a sliding window view into the array with the given window shape . With arguments `x`, `window_shape`, `subok`.", "question_id": 5574},
{"snippet": "lib.stride_tricks.sliding_window_view(x, window_shape, writeable=False)", "intent": "Create a sliding window view into the array with the given window shape . With arguments `x`, `window_shape`, `writeable`.", "question_id": 5575},
{"snippet": "lib.stride_tricks.sliding_window_view(x, window_shape, axis=None, subok=False)", "intent": "Create a sliding window view into the array with the given window shape . The `axis` can be specified explicitly : With arguments `x`, `window_shape`, `subok`.", "question_id": 5576},
{"snippet": "lib.stride_tricks.sliding_window_view(x, window_shape, axis=None, writeable=False)", "intent": "Create a sliding window view into the array with the given window shape . The `axis` can be specified explicitly : With arguments `x`, `window_shape`, `writeable`.", "question_id": 5577},
{"snippet": "lib.stride_tricks.sliding_window_view(x, window_shape, subok=False, writeable=False)", "intent": "Create a sliding window view into the array with the given window shape . With arguments `x`, `window_shape`, `subok`, `writeable`.", "question_id": 5578},
{"snippet": "lib.stride_tricks.sliding_window_view(x, window_shape, axis=None, subok=False, writeable=False)", "intent": "Create a sliding window view into the array with the given window shape . The `axis` can be specified explicitly : With arguments `x`, `window_shape`, `subok`, `writeable`.", "question_id": 5579},
{"snippet": "polynomial.laguerre.Laguerre.fit(x, y, deg)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`.", "question_id": 5580},
{"snippet": "polynomial.laguerre.Laguerre.fit(x, y, deg, domain=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`.", "question_id": 5581},
{"snippet": "polynomial.laguerre.Laguerre.fit(x, y, deg, rcond=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `rcond`.", "question_id": 5582},
{"snippet": "polynomial.laguerre.Laguerre.fit(x, y, deg, full=False)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `full`.", "question_id": 5583},
{"snippet": "polynomial.laguerre.Laguerre.fit(x, y, deg, w=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `w`.", "question_id": 5584},
{"snippet": "polynomial.laguerre.Laguerre.fit(x, y, deg, window=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `window`.", "question_id": 5585},
{"snippet": "polynomial.laguerre.Laguerre.fit(x, y, deg, domain=None, rcond=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `rcond`.", "question_id": 5586},
{"snippet": "polynomial.laguerre.Laguerre.fit(x, y, deg, domain=None, full=False)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `full`.", "question_id": 5587},
{"snippet": "polynomial.laguerre.Laguerre.fit(x, y, deg, domain=None, w=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `w`.", "question_id": 5588},
{"snippet": "polynomial.laguerre.Laguerre.fit(x, y, deg, domain=None, window=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `window`.", "question_id": 5589},
{"snippet": "polynomial.hermite.hermsub(c1, c2)", "intent": "Subtract one Hermite series from another . Returns the difference of two Hermite series `c1` - `c2` .", "question_id": 5590},
{"snippet": "numpy.logaddexp(x1, x2, /, signature, extobj)", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `extobj`.", "question_id": 5591},
{"snippet": "numpy.logaddexp(x1, x2, /, signature, extobj, out=None)", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 5592},
{"snippet": "numpy.logaddexp(x1, x2, /, signature, extobj, where=True)", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . This function is useful in statistics `where` the calculated probabilities of events may be so small as to exceed the range of normal floating point numbers . With arguments `/`, `signature`, `extobj`.", "question_id": 5593},
{"snippet": "numpy.logaddexp(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 5594},
{"snippet": "numpy.logaddexp(x1, x2, /, signature, extobj, order='K')", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 5595},
{"snippet": "numpy.logaddexp(x1, x2, /, signature, extobj, dtype=None)", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 5596},
{"snippet": "numpy.logaddexp(x1, x2, /, signature, extobj, subok=True)", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 5597},
{"snippet": "numpy.logaddexp(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . This function is useful in statistics `where` the calculated probabilities of events may be so small as to exceed the range of normal floating point numbers . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 5598},
{"snippet": "numpy.logaddexp(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 5599},
{"snippet": "numpy.logaddexp(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 5600},
{"snippet": "numpy.logaddexp(x1, x2, /, signature)", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`.", "question_id": 5601},
{"snippet": "numpy.logaddexp(x1, x2, /, signature, out=None)", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `out`.", "question_id": 5602},
{"snippet": "numpy.logaddexp(x1, x2, /, signature, where=True)", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . This function is useful in statistics `where` the calculated probabilities of events may be so small as to exceed the range of normal floating point numbers . With arguments `/`, `signature`.", "question_id": 5603},
{"snippet": "numpy.logaddexp(x1, x2, /, signature, casting='same_kind')", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `casting`.", "question_id": 5604},
{"snippet": "numpy.logaddexp(x1, x2, /, signature, order='K')", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `order`.", "question_id": 5605},
{"snippet": "numpy.logaddexp(x1, x2, /, signature, dtype=None)", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `dtype`.", "question_id": 5606},
{"snippet": "numpy.logaddexp(x1, x2, /, signature, subok=True)", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `subok`.", "question_id": 5607},
{"snippet": "numpy.logaddexp(x1, x2, /, signature, out=None, where=True)", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . This function is useful in statistics `where` the calculated probabilities of events may be so small as to exceed the range of normal floating point numbers . With arguments `/`, `signature`, `out`.", "question_id": 5608},
{"snippet": "numpy.logaddexp(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 5609},
{"snippet": "numpy.logaddexp(x1, x2, /, signature, out=None, order='K')", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `out`, `order`.", "question_id": 5610},
{"snippet": "polynomial.laguerre.lagroots(c)", "intent": "Compute the roots of a Laguerre series . With arguments `c`.", "question_id": 5611},
{"snippet": "ma.MaskType.var()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 5612},
{"snippet": "polynomial.hermite.Hermite.basis(deg)", "intent": "Series basis polynomial of degree `deg` .", "question_id": 5613},
{"snippet": "polynomial.hermite.Hermite.basis(deg, domain=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `domain`.", "question_id": 5614},
{"snippet": "polynomial.hermite.Hermite.basis(deg, window=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `window`.", "question_id": 5615},
{"snippet": "polynomial.hermite.Hermite.basis(deg, domain=None, window=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `domain`, `window`.", "question_id": 5616},
{"snippet": "polynomial.polyutils.as_series(alist)", "intent": "Return argument as a list of 1-d arrays . With arguments `alist`.", "question_id": 5617},
{"snippet": "polynomial.polyutils.as_series(alist, trim=True)", "intent": "Return argument as a list of 1-d arrays . With arguments `alist`, `trim`.", "question_id": 5618},
{"snippet": "numpy.dsplit(ary, indices_or_sections)", "intent": "Split array into multiple sub-arrays along the 3rd axis ( depth ) . With arguments `ary`, `indices_or_sections`.", "question_id": 5619},
{"snippet": "numpy.isclose(a, b)", "intent": "Returns `a` boolean array where two arrays are element-wise equal within a tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b .", "question_id": 5620},
{"snippet": "numpy.isclose(a, b, rtol=1e-05)", "intent": "Returns `a` boolean array where two arrays are element-wise equal within a tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b .", "question_id": 5621},
{"snippet": "numpy.isclose(a, b, atol=1e-08)", "intent": "Returns `a` boolean array where two arrays are element-wise equal within a tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b .", "question_id": 5622},
{"snippet": "numpy.isclose(a, b, equal_nan=False)", "intent": "Returns `a` boolean array where two arrays are element-wise equal within a tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b . With arguments `equal_nan`.", "question_id": 5623},
{"snippet": "numpy.isclose(a, b, rtol=1e-05, atol=1e-08)", "intent": "Returns `a` boolean array where two arrays are element-wise equal within a tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b .", "question_id": 5624},
{"snippet": "numpy.isclose(a, b, rtol=1e-05, equal_nan=False)", "intent": "Returns `a` boolean array where two arrays are element-wise equal within a tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b . With arguments `equal_nan`.", "question_id": 5625},
{"snippet": "numpy.isclose(a, b, atol=1e-08, equal_nan=False)", "intent": "Returns `a` boolean array where two arrays are element-wise equal within a tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b . With arguments `equal_nan`.", "question_id": 5626},
{"snippet": "numpy.isclose(a, b, rtol=1e-05, atol=1e-08, equal_nan=False)", "intent": "Returns `a` boolean array where two arrays are element-wise equal within a tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b . With arguments `equal_nan`.", "question_id": 5627},
{"snippet": "record.compress()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 5628},
{"snippet": "random.RandomState.randn(d0, d1, dn)", "intent": "Return a sample ( or samples ) from the \u201c standard normal \u201d distribution . If positive int_like arguments are provided , randn generates an array of shape ( `d0` , `d1` , ... , `dn` ) , filled with random floats sampled from a univariate \u201c normal \u201d ( Gaussian ) distribution of mean 0 and variance 1 .", "question_id": 5629},
{"snippet": "ma.MaskType.ravel()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 5630},
{"snippet": "numpy.byte_bounds(a)", "intent": "Returns pointers to the end-points of an array . With arguments `a`.", "question_id": 5631},
{"snippet": "random.RandomState.vonmises(mu, kappa)", "intent": "Draw samples from a von Mises distribution . Samples are drawn from a von Mises distribution with specified mode ( `mu` ) and dispersion ( `kappa` ) , on the interval [ -pi , pi ] .", "question_id": 5632},
{"snippet": "random.RandomState.vonmises(mu, kappa, size=None)", "intent": "Draw samples from a von Mises distribution . Samples are drawn from a von Mises distribution with specified mode ( `mu` ) and dispersion ( `kappa` ) , on the interval [ -pi , pi ] . With arguments `size`.", "question_id": 5633},
{"snippet": "ndarray.__ipow__(value, /)", "intent": "Return self * * =value . With arguments `value`, `/`.", "question_id": 5634},
{"snippet": "record.sort()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 5635},
{"snippet": "chararray.dtype", "intent": "Data-type of the array\u2019s elements.", "question_id": 5636},
{"snippet": "fft.ifft(a)", "intent": "Compute the one-dimensional inverse discrete Fourier Transform . In other words , ifft ( fft ( `a` ) ) == a to within numerical accuracy .", "question_id": 5637},
{"snippet": "fft.ifft(a, n=None)", "intent": "Compute the one-dimensional inverse discrete Fourier Transform . In other words , ifft ( fft ( `a` ) ) == a to within numerical accuracy . If the input parameter `n` is larger than the size of the input , the input is padded by appending zeros at the end .", "question_id": 5638},
{"snippet": "fft.ifft(a, axis=- 1)", "intent": "Compute the one-dimensional inverse discrete Fourier Transform . In other words , ifft ( fft ( `a` ) ) == a to within numerical accuracy . With arguments `axis`.", "question_id": 5639},
{"snippet": "fft.ifft(a, norm=None)", "intent": "Compute the one-dimensional inverse discrete Fourier Transform . In other words , ifft ( fft ( `a` ) ) == a to within numerical accuracy . With arguments `norm`.", "question_id": 5640},
{"snippet": "fft.ifft(a, n=None, axis=- 1)", "intent": "Compute the one-dimensional inverse discrete Fourier Transform . In other words , ifft ( fft ( `a` ) ) == a to within numerical accuracy . If the input parameter `n` is larger than the size of the input , the input is padded by appending zeros at the end . With arguments `axis`.", "question_id": 5641},
{"snippet": "fft.ifft(a, n=None, norm=None)", "intent": "Compute the one-dimensional inverse discrete Fourier Transform . In other words , ifft ( fft ( `a` ) ) == a to within numerical accuracy . If the input parameter `n` is larger than the size of the input , the input is padded by appending zeros at the end . With arguments `norm`.", "question_id": 5642},
{"snippet": "fft.ifft(a, axis=- 1, norm=None)", "intent": "Compute the one-dimensional inverse discrete Fourier Transform . In other words , ifft ( fft ( `a` ) ) == a to within numerical accuracy . With arguments `axis`, `norm`.", "question_id": 5643},
{"snippet": "fft.ifft(a, n=None, axis=- 1, norm=None)", "intent": "Compute the one-dimensional inverse discrete Fourier Transform . In other words , ifft ( fft ( `a` ) ) == a to within numerical accuracy . If the input parameter `n` is larger than the size of the input , the input is padded by appending zeros at the end . With arguments `axis`, `norm`.", "question_id": 5644},
{"snippet": "ufunc.nout", "intent": "The number of outputs.", "question_id": 5645},
{"snippet": "numpy.fromregex(file, regexp, dtype)", "intent": "Construct an array from a text `file` , using regular expression parsing . With arguments `regexp`, `dtype`.", "question_id": 5646},
{"snippet": "numpy.fromregex(file, regexp, dtype, encoding=None)", "intent": "Construct an array from a text `file` , using regular expression parsing . With arguments `regexp`, `dtype`, `encoding`.", "question_id": 5647},
{"snippet": "char.chararray.clip(**kwargs)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 5648},
{"snippet": "char.chararray.clip(**kwargs, min=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 5649},
{"snippet": "char.chararray.clip(**kwargs, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 5650},
{"snippet": "char.chararray.clip(**kwargs, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 5651},
{"snippet": "char.chararray.clip(**kwargs, min=None, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 5652},
{"snippet": "char.chararray.clip(**kwargs, min=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 5653},
{"snippet": "char.chararray.clip(**kwargs, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 5654},
{"snippet": "char.chararray.clip(**kwargs, min=None, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 5655},
{"snippet": "chararray.ravel(order)", "intent": "Return a flattened array . With arguments `order`.", "question_id": 5656},
{"snippet": "chararray.ravel()", "intent": "Return a flattened array .", "question_id": 5657},
{"snippet": "chararray.ctypes", "intent": "An object to simplify the interaction of the array with the ctypes module.", "question_id": 5658},
{"snippet": "_ctypes.data", "intent": "A pointer to the memory area of the array as a Python integer.", "question_id": 5659},
{"snippet": "_ctypes.shape", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the C-integer corresponding to dtype('p') on this platform.", "question_id": 5660},
{"snippet": "_ctypes.strides", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the same as for the shape attribute.", "question_id": 5661},
{"snippet": "_ctypes.data_as(obj)", "intent": "Return the data pointer cast to a particular c-types object . With arguments `obj`.", "question_id": 5662},
{"snippet": "_ctypes.shape_as(obj)", "intent": "Return the shape tuple as an array of some other c-types type . With arguments `obj`.", "question_id": 5663},
{"snippet": "_ctypes.strides_as(obj)", "intent": "Return the strides tuple as an array of some other c-types type . With arguments `obj`.", "question_id": 5664},
{"snippet": "numpy.hstack(tup)", "intent": "Stack arrays in sequence horizontally ( column wise ) . With arguments `tup`.", "question_id": 5665},
{"snippet": "polynomial.hermite_e.hermevander(x, deg)", "intent": "Pseudo-Vandermonde matrix of given degree . Returns the pseudo-Vandermonde matrix of degree `deg` and sample points `x` .", "question_id": 5666},
{"snippet": "char.chararray.isnumeric()", "intent": "For each element in self , return True if there are only numeric characters in the element .", "question_id": 5667},
{"snippet": "ndarray.copy()", "intent": "Return a copy of the array .", "question_id": 5668},
{"snippet": "ndarray.copy(order='C')", "intent": "Return a copy of the array . The function numpy.copy is similar , but it defaults to using `order` \u2018 K \u2019 , and will not pass sub-classes through by default .", "question_id": 5669},
{"snippet": "chararray.islower()", "intent": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character , false otherwise .", "question_id": 5670},
{"snippet": "numpy.sinc(x)", "intent": "Return the normalized sinc function . The sinc function is \\ ( \\sin ( \\pi `x` ) / ( \\pi x ) \\ ) .", "question_id": 5671},
{"snippet": "matrix.conjugate()", "intent": "Return the complex conjugate , element-wise .", "question_id": 5672},
{"snippet": "polynomial.chebyshev.Chebyshev.mapparms()", "intent": "Return the mapping parameters .", "question_id": 5673},
{"snippet": "polynomial.hermite.Hermite.has_sametype(other)", "intent": "Check if types match . With arguments `other`.", "question_id": 5674},
{"snippet": "recarray.astype(dtype)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`.", "question_id": 5675},
{"snippet": "recarray.astype(dtype, order='K')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`.", "question_id": 5676},
{"snippet": "recarray.astype(dtype, casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`.", "question_id": 5677},
{"snippet": "recarray.astype(dtype, subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `subok`.", "question_id": 5678},
{"snippet": "recarray.astype(dtype, copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `copy`.", "question_id": 5679},
{"snippet": "recarray.astype(dtype, order='K', casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `casting`.", "question_id": 5680},
{"snippet": "recarray.astype(dtype, order='K', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `subok`.", "question_id": 5681},
{"snippet": "recarray.astype(dtype, order='K', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `copy`.", "question_id": 5682},
{"snippet": "recarray.astype(dtype, casting='unsafe', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `subok`.", "question_id": 5683},
{"snippet": "recarray.astype(dtype, casting='unsafe', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `copy`.", "question_id": 5684},
{"snippet": "memmap.ravel(order)", "intent": "Return a flattened array . With arguments `order`.", "question_id": 5685},
{"snippet": "memmap.ravel()", "intent": "Return a flattened array .", "question_id": 5686},
{"snippet": "chararray.compress(condition)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`.", "question_id": 5687},
{"snippet": "chararray.compress(condition, axis=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`.", "question_id": 5688},
{"snippet": "chararray.compress(condition, out=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`, `out`.", "question_id": 5689},
{"snippet": "chararray.compress(condition, axis=None, out=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`, `out`.", "question_id": 5690},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.dist_error(*args)", "intent": "Raise a compiler error With arguments `*args`.", "question_id": 5691},
{"snippet": "polynomial.laguerre.lagdiv(c1, c2)", "intent": "Divide one Laguerre series by another . Returns the quotient-with-remainder of two Laguerre series `c1` / `c2` .", "question_id": 5692},
{"snippet": "numpy.dtype", "intent": "Methods", "question_id": 5693},
{"snippet": "numpy.polymul(a1, a2)", "intent": "Find the product of two polynomials . With arguments `a1`, `a2`.", "question_id": 5694},
{"snippet": "chararray.copy()", "intent": "Return a copy of the array .", "question_id": 5695},
{"snippet": "chararray.copy(order='C')", "intent": "Return a copy of the array . The function numpy.copy is similar , but it defaults to using `order` \u2018 K \u2019 , and will not pass sub-classes through by default .", "question_id": 5696},
{"snippet": "ma.MaskedArray.flags", "intent": "Information about the memory layout of the array.", "question_id": 5697},
{"snippet": "polynomial.laguerre.Laguerre.basis(deg)", "intent": "Series basis polynomial of degree `deg` .", "question_id": 5698},
{"snippet": "polynomial.laguerre.Laguerre.basis(deg, domain=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `domain`.", "question_id": 5699},
{"snippet": "polynomial.laguerre.Laguerre.basis(deg, window=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `window`.", "question_id": 5700},
{"snippet": "polynomial.laguerre.Laguerre.basis(deg, domain=None, window=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `domain`, `window`.", "question_id": 5701},
{"snippet": "record.ndim", "intent": "The number of array dimensions.", "question_id": 5702},
{"snippet": "memmap.getfield(dtype)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements .", "question_id": 5703},
{"snippet": "memmap.getfield(dtype, offset=0)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements . The values in the view are determined by the given type and the `offset` into the current array in bytes .", "question_id": 5704},
{"snippet": "polynomial.chebyshev.chebfit(x, y, deg)", "intent": "Least squares fit of Chebyshev series to data . Return the coefficients of a Chebyshev series of degree `deg` that is the least squares fit to the data values `y` given at points `x` .", "question_id": 5705},
{"snippet": "polynomial.chebyshev.chebfit(x, y, deg, rcond=None)", "intent": "Least squares fit of Chebyshev series to data . Return the coefficients of a Chebyshev series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error .", "question_id": 5706},
{"snippet": "polynomial.chebyshev.chebfit(x, y, deg, full=False)", "intent": "Least squares fit of Chebyshev series to data . Return the coefficients of a Chebyshev series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . With arguments `full`.", "question_id": 5707},
{"snippet": "polynomial.chebyshev.chebfit(x, y, deg, w=None)", "intent": "Least squares fit of Chebyshev series to data . Return the coefficients of a Chebyshev series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values .", "question_id": 5708},
{"snippet": "polynomial.chebyshev.chebfit(x, y, deg, rcond=None, full=False)", "intent": "Least squares fit of Chebyshev series to data . Return the coefficients of a Chebyshev series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . With arguments `full`.", "question_id": 5709},
{"snippet": "polynomial.chebyshev.chebfit(x, y, deg, rcond=None, w=None)", "intent": "Least squares fit of Chebyshev series to data . Return the coefficients of a Chebyshev series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values .", "question_id": 5710},
{"snippet": "polynomial.chebyshev.chebfit(x, y, deg, full=False, w=None)", "intent": "Least squares fit of Chebyshev series to data . Return the coefficients of a Chebyshev series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values . With arguments `full`.", "question_id": 5711},
{"snippet": "polynomial.chebyshev.chebfit(x, y, deg, rcond=None, full=False, w=None)", "intent": "Least squares fit of Chebyshev series to data . Return the coefficients of a Chebyshev series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values . With arguments `full`.", "question_id": 5712},
{"snippet": "polynomial.legendre.legpow(c, pow)", "intent": "Raise a Legendre series to a power . Returns the Legendre series `c` raised to the power `pow` .", "question_id": 5713},
{"snippet": "polynomial.legendre.legpow(c, pow, maxpower=16)", "intent": "Raise a Legendre series to a power . Returns the Legendre series `c` raised to the power `pow` . With arguments `maxpower`.", "question_id": 5714},
{"snippet": "recarray.mean()", "intent": "Returns the average of the array elements along given `axis` .", "question_id": 5715},
{"snippet": "recarray.mean(axis=None)", "intent": "Returns the average of the array elements along given `axis` .", "question_id": 5716},
{"snippet": "recarray.mean(dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`.", "question_id": 5717},
{"snippet": "recarray.mean(out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`.", "question_id": 5718},
{"snippet": "recarray.mean(keepdims=False)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`.", "question_id": 5719},
{"snippet": "recarray.mean(where=True)", "intent": "Returns the average of the array elements along given `axis` . With arguments `where`.", "question_id": 5720},
{"snippet": "recarray.mean(axis=None, dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`.", "question_id": 5721},
{"snippet": "recarray.mean(axis=None, out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`.", "question_id": 5722},
{"snippet": "recarray.mean(axis=None, keepdims=False)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`.", "question_id": 5723},
{"snippet": "recarray.mean(axis=None, where=True)", "intent": "Returns the average of the array elements along given `axis` . With arguments `where`.", "question_id": 5724},
{"snippet": "polynomial.hermite.hermdiv(c1, c2)", "intent": "Divide one Hermite series by another . Returns the quotient-with-remainder of two Hermite series `c1` / `c2` .", "question_id": 5725},
{"snippet": "numpy.kaiser(M, beta)", "intent": "Return the Kaiser window . The Kaiser can approximate many other windows by varying the `beta` parameter . With arguments `M`.", "question_id": 5726},
{"snippet": "ma.MaskType.all()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 5727},
{"snippet": "polynomial.laguerre.lagmul(c1, c2)", "intent": "Multiply one Laguerre series by another . Returns the product of two Laguerre series `c1` * `c2` .", "question_id": 5728},
{"snippet": "testing.assert_array_max_ulp(a, b)", "intent": "Check that all items of arrays differ in at most N Units in the Last Place . With arguments `a`, `b`.", "question_id": 5729},
{"snippet": "testing.assert_array_max_ulp(a, b, maxulp=1)", "intent": "Check that all items of arrays differ in at most N Units in the Last Place . With arguments `a`, `b`, `maxulp`.", "question_id": 5730},
{"snippet": "testing.assert_array_max_ulp(a, b, dtype=None)", "intent": "Check that all items of arrays differ in at most N Units in the Last Place . With arguments `a`, `b`, `dtype`.", "question_id": 5731},
{"snippet": "testing.assert_array_max_ulp(a, b, maxulp=1, dtype=None)", "intent": "Check that all items of arrays differ in at most N Units in the Last Place . With arguments `a`, `b`, `maxulp`, `dtype`.", "question_id": 5732},
{"snippet": "polynomial.chebyshev.Chebyshev.has_sametype(other)", "intent": "Check if types match . With arguments `other`.", "question_id": 5733},
{"snippet": "chararray.join(seq)", "intent": "Return a string which is the concatenation of the strings in the sequence `seq` .", "question_id": 5734},
{"snippet": "numpy.fmax(x1, x2, /, signature, extobj)", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`.", "question_id": 5735},
{"snippet": "numpy.fmax(x1, x2, /, signature, extobj, out=None)", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 5736},
{"snippet": "numpy.fmax(x1, x2, /, signature, extobj, where=True)", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 5737},
{"snippet": "numpy.fmax(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 5738},
{"snippet": "numpy.fmax(x1, x2, /, signature, extobj, order='K')", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 5739},
{"snippet": "numpy.fmax(x1, x2, /, signature, extobj, dtype=None)", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 5740},
{"snippet": "numpy.fmax(x1, x2, /, signature, extobj, subok=True)", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 5741},
{"snippet": "numpy.fmax(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 5742},
{"snippet": "numpy.fmax(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 5743},
{"snippet": "numpy.fmax(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 5744},
{"snippet": "numpy.fmax(x1, x2, /, signature)", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`.", "question_id": 5745},
{"snippet": "numpy.fmax(x1, x2, /, signature, out=None)", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`.", "question_id": 5746},
{"snippet": "numpy.fmax(x1, x2, /, signature, where=True)", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `where`.", "question_id": 5747},
{"snippet": "numpy.fmax(x1, x2, /, signature, casting='same_kind')", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `casting`.", "question_id": 5748},
{"snippet": "numpy.fmax(x1, x2, /, signature, order='K')", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `order`.", "question_id": 5749},
{"snippet": "numpy.fmax(x1, x2, /, signature, dtype=None)", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `dtype`.", "question_id": 5750},
{"snippet": "numpy.fmax(x1, x2, /, signature, subok=True)", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `subok`.", "question_id": 5751},
{"snippet": "numpy.fmax(x1, x2, /, signature, out=None, where=True)", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`, `where`.", "question_id": 5752},
{"snippet": "numpy.fmax(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 5753},
{"snippet": "numpy.fmax(x1, x2, /, signature, out=None, order='K')", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`, `order`.", "question_id": 5754},
{"snippet": "ma.is_mask(m)", "intent": "Return True if `m` is a valid , standard mask .", "question_id": 5755},
{"snippet": "polynomial.laguerre.lagpow(c, pow)", "intent": "Raise a Laguerre series to a power . Returns the Laguerre series `c` raised to the power `pow` .", "question_id": 5756},
{"snippet": "polynomial.laguerre.lagpow(c, pow, maxpower=16)", "intent": "Raise a Laguerre series to a power . Returns the Laguerre series `c` raised to the power `pow` . With arguments `maxpower`.", "question_id": 5757},
{"snippet": "matrix.dot(b)", "intent": "Dot product of two arrays . With arguments `b`.", "question_id": 5758},
{"snippet": "matrix.dot(b, out=None)", "intent": "Dot product of two arrays . With arguments `b`, `out`.", "question_id": 5759},
{"snippet": "char.isalpha(a)", "intent": "Returns true for each element if all characters in the string are alphabetic and there is at least one character , false otherwise . With arguments `a`.", "question_id": 5760},
{"snippet": "char.chararray.setfield(val, dtype)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field .", "question_id": 5761},
{"snippet": "char.chararray.setfield(val, dtype, offset=0)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field .", "question_id": 5762},
{"snippet": "numpy.logspace(start, stop)", "intent": "Return numbers spaced evenly on a log scale . In linear space , the sequence starts at `base` * * `start` ( base to the power of start ) and ends with base * * `stop` ( see `endpoint` below ) .", "question_id": 5763},
{"snippet": "numpy.logspace(start, stop, num=50)", "intent": "Return numbers spaced evenly on a log scale . In linear space , the sequence starts at `base` * * `start` ( base to the power of start ) and ends with base * * `stop` ( see `endpoint` below ) . With arguments `num`.", "question_id": 5764},
{"snippet": "numpy.logspace(start, stop, endpoint=True)", "intent": "Return numbers spaced evenly on a log scale . In linear space , the sequence starts at `base` * * `start` ( base to the power of start ) and ends with base * * `stop` ( see `endpoint` below ) .", "question_id": 5765},
{"snippet": "numpy.logspace(start, stop, base=10.0)", "intent": "Return numbers spaced evenly on a log scale . In linear space , the sequence starts at `base` * * `start` ( base to the power of start ) and ends with base * * `stop` ( see `endpoint` below ) .", "question_id": 5766},
{"snippet": "numpy.logspace(start, stop, dtype=None)", "intent": "Return numbers spaced evenly on a log scale . In linear space , the sequence starts at `base` * * `start` ( base to the power of start ) and ends with base * * `stop` ( see `endpoint` below ) . With arguments `dtype`.", "question_id": 5767},
{"snippet": "numpy.logspace(start, stop, axis=0)", "intent": "Return numbers spaced evenly on a log scale . In linear space , the sequence starts at `base` * * `start` ( base to the power of start ) and ends with base * * `stop` ( see `endpoint` below ) . With arguments `axis`.", "question_id": 5768},
{"snippet": "numpy.logspace(start, stop, num=50, endpoint=True)", "intent": "Return numbers spaced evenly on a log scale . In linear space , the sequence starts at `base` * * `start` ( base to the power of start ) and ends with base * * `stop` ( see `endpoint` below ) . With arguments `num`.", "question_id": 5769},
{"snippet": "numpy.logspace(start, stop, num=50, base=10.0)", "intent": "Return numbers spaced evenly on a log scale . In linear space , the sequence starts at `base` * * `start` ( base to the power of start ) and ends with base * * `stop` ( see `endpoint` below ) . With arguments `num`.", "question_id": 5770},
{"snippet": "numpy.logspace(start, stop, num=50, dtype=None)", "intent": "Return numbers spaced evenly on a log scale . In linear space , the sequence starts at `base` * * `start` ( base to the power of start ) and ends with base * * `stop` ( see `endpoint` below ) . With arguments `num`, `dtype`.", "question_id": 5771},
{"snippet": "numpy.logspace(start, stop, num=50, axis=0)", "intent": "Return numbers spaced evenly on a log scale . In linear space , the sequence starts at `base` * * `start` ( base to the power of start ) and ends with base * * `stop` ( see `endpoint` below ) . With arguments `num`, `axis`.", "question_id": 5772},
{"snippet": "numpy.fill_diagonal(a, val)", "intent": "Fill the main diagonal of the given array of any dimensionality . For an array `a` with a.ndim > = 2 , the diagonal is the list of locations with indices a [ i , ... , i ] all identical . With arguments `val`.", "question_id": 5773},
{"snippet": "numpy.fill_diagonal(a, val, wrap=False)", "intent": "Fill the main diagonal of the given array of any dimensionality . For an array `a` with a.ndim > = 2 , the diagonal is the list of locations with indices a [ i , ... , i ] all identical . The `wrap` option affects only tall matrices : With arguments `val`.", "question_id": 5774},
{"snippet": "record.reshape()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 5775},
{"snippet": "memmap.repeat(repeats)", "intent": "Repeat elements of an array . With arguments `repeats`.", "question_id": 5776},
{"snippet": "memmap.repeat(repeats, axis=None)", "intent": "Repeat elements of an array . With arguments `repeats`, `axis`.", "question_id": 5777},
{"snippet": "ma.MaskedArray.prod()", "intent": "Return the product of the array elements over the given `axis` .", "question_id": 5778},
{"snippet": "ma.MaskedArray.prod(axis=None)", "intent": "Return the product of the array elements over the given `axis` .", "question_id": 5779},
{"snippet": "ma.MaskedArray.prod(dtype=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 5780},
{"snippet": "ma.MaskedArray.prod(out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `out`.", "question_id": 5781},
{"snippet": "ma.MaskedArray.prod(keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `keepdims`.", "question_id": 5782},
{"snippet": "ma.MaskedArray.prod(axis=None, dtype=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 5783},
{"snippet": "ma.MaskedArray.prod(axis=None, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `out`.", "question_id": 5784},
{"snippet": "ma.MaskedArray.prod(axis=None, keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `keepdims`.", "question_id": 5785},
{"snippet": "ma.MaskedArray.prod(dtype=None, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`, `out`.", "question_id": 5786},
{"snippet": "ma.MaskedArray.prod(dtype=None, keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`, `keepdims`.", "question_id": 5787},
{"snippet": "recarray.transpose(*axes)", "intent": "Returns a view of the array with axes transposed . With arguments `*axes`.", "question_id": 5788},
{"snippet": "fft.fftfreq(n)", "intent": "Return the Discrete Fourier Transform sample frequencies . Given a window length `n` and a sample spacing `d` :", "question_id": 5789},
{"snippet": "fft.fftfreq(n, d=1.0)", "intent": "Return the Discrete Fourier Transform sample frequencies . Given a window length `n` and a sample spacing `d` :", "question_id": 5790},
{"snippet": "polynomial.hermite.Hermite.convert()", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 5791},
{"snippet": "polynomial.hermite.Hermite.convert(domain=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 5792},
{"snippet": "polynomial.hermite.Hermite.convert(kind=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 5793},
{"snippet": "polynomial.hermite.Hermite.convert(window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 5794},
{"snippet": "polynomial.hermite.Hermite.convert(domain=None, kind=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 5795},
{"snippet": "polynomial.hermite.Hermite.convert(domain=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 5796},
{"snippet": "polynomial.hermite.Hermite.convert(kind=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 5797},
{"snippet": "polynomial.hermite.Hermite.convert(domain=None, kind=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 5798},
{"snippet": "random.Generator.standard_gamma(shape)", "intent": "Draw samples from a standard Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and scale=1 .", "question_id": 5799},
{"snippet": "random.Generator.standard_gamma(shape, size=None)", "intent": "Draw samples from a standard Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and scale=1 . With arguments `size`.", "question_id": 5800},
{"snippet": "random.Generator.standard_gamma(shape, dtype=np.float64)", "intent": "Draw samples from a standard Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and scale=1 . With arguments `dtype`.", "question_id": 5801},
{"snippet": "random.Generator.standard_gamma(shape, out=None)", "intent": "Draw samples from a standard Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and scale=1 . With arguments `out`.", "question_id": 5802},
{"snippet": "random.Generator.standard_gamma(shape, size=None, dtype=np.float64)", "intent": "Draw samples from a standard Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and scale=1 . With arguments `size`, `dtype`.", "question_id": 5803},
{"snippet": "random.Generator.standard_gamma(shape, size=None, out=None)", "intent": "Draw samples from a standard Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and scale=1 . With arguments `size`, `out`.", "question_id": 5804},
{"snippet": "random.Generator.standard_gamma(shape, dtype=np.float64, out=None)", "intent": "Draw samples from a standard Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and scale=1 . With arguments `dtype`, `out`.", "question_id": 5805},
{"snippet": "random.Generator.standard_gamma(shape, size=None, dtype=np.float64, out=None)", "intent": "Draw samples from a standard Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and scale=1 . With arguments `size`, `dtype`, `out`.", "question_id": 5806},
{"snippet": "numpy.reciprocal(x, /, signature, extobj)", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `extobj`.", "question_id": 5807},
{"snippet": "numpy.reciprocal(x, /, signature, extobj, out=None)", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`.", "question_id": 5808},
{"snippet": "numpy.reciprocal(x, /, signature, extobj, where=True)", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `where`.", "question_id": 5809},
{"snippet": "numpy.reciprocal(x, /, signature, extobj, casting='same_kind')", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `casting`.", "question_id": 5810},
{"snippet": "numpy.reciprocal(x, /, signature, extobj, order='K')", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `order`.", "question_id": 5811},
{"snippet": "numpy.reciprocal(x, /, signature, extobj, dtype=None)", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `dtype`.", "question_id": 5812},
{"snippet": "numpy.reciprocal(x, /, signature, extobj, subok=True)", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `subok`.", "question_id": 5813},
{"snippet": "numpy.reciprocal(x, /, signature, extobj, out=None, where=True)", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 5814},
{"snippet": "numpy.reciprocal(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 5815},
{"snippet": "numpy.reciprocal(x, /, signature, extobj, out=None, order='K')", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 5816},
{"snippet": "numpy.reciprocal(x, /, signature)", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`.", "question_id": 5817},
{"snippet": "numpy.reciprocal(x, /, signature, out=None)", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `out`.", "question_id": 5818},
{"snippet": "numpy.reciprocal(x, /, signature, where=True)", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `where`.", "question_id": 5819},
{"snippet": "numpy.reciprocal(x, /, signature, casting='same_kind')", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `casting`.", "question_id": 5820},
{"snippet": "numpy.reciprocal(x, /, signature, order='K')", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `order`.", "question_id": 5821},
{"snippet": "numpy.reciprocal(x, /, signature, dtype=None)", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `dtype`.", "question_id": 5822},
{"snippet": "numpy.reciprocal(x, /, signature, subok=True)", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `subok`.", "question_id": 5823},
{"snippet": "numpy.reciprocal(x, /, signature, out=None, where=True)", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `out`, `where`.", "question_id": 5824},
{"snippet": "numpy.reciprocal(x, /, signature, out=None, casting='same_kind')", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `out`, `casting`.", "question_id": 5825},
{"snippet": "numpy.reciprocal(x, /, signature, out=None, order='K')", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `out`, `order`.", "question_id": 5826},
{"snippet": "polynomial.hermite.poly2herm(pol)", "intent": "Convert a polynomial to a Hermite series . With arguments `pol`.", "question_id": 5827},
{"snippet": "recarray.getfield(dtype)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements .", "question_id": 5828},
{"snippet": "recarray.getfield(dtype, offset=0)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements . The values in the view are determined by the given type and the `offset` into the current array in bytes .", "question_id": 5829},
{"snippet": "numpy.frompyfunc(func, nin, nout, identity)", "intent": "Takes an arbitrary Python function and returns a NumPy ufunc . With arguments `func`, `nin`, `nout`, `identity`.", "question_id": 5830},
{"snippet": "numpy.frompyfunc(func, nin, nout)", "intent": "Takes an arbitrary Python function and returns a NumPy ufunc . With arguments `func`, `nin`, `nout`.", "question_id": 5831},
{"snippet": "ma.MaskedArray.tofile(fid)", "intent": "Save a masked array to a file in binary `format` . With arguments `fid`.", "question_id": 5832},
{"snippet": "ma.MaskedArray.tofile(fid, sep='')", "intent": "Save a masked array to a file in binary `format` . With arguments `fid`, `sep`.", "question_id": 5833},
{"snippet": "ma.MaskedArray.tofile(fid, format='%s')", "intent": "Save a masked array to a file in binary `format` . With arguments `fid`.", "question_id": 5834},
{"snippet": "ma.MaskedArray.tofile(fid, sep='', format='%s')", "intent": "Save a masked array to a file in binary `format` . With arguments `fid`, `sep`.", "question_id": 5835},
{"snippet": "ma.masked_array.get_imag()", "intent": "The imaginary part of the masked array .", "question_id": 5836},
{"snippet": "core.records.fromrecords(recList)", "intent": "Create a recarray from a list of records in text form . With arguments `recList`.", "question_id": 5837},
{"snippet": "core.records.fromrecords(recList, dtype=None)", "intent": "Create a recarray from a list of records in text form . With arguments `recList`, `dtype`.", "question_id": 5838},
{"snippet": "core.records.fromrecords(recList, shape=None)", "intent": "Create a recarray from a list of records in text form . With arguments `recList`, `shape`.", "question_id": 5839},
{"snippet": "core.records.fromrecords(recList, formats=None)", "intent": "Create a recarray from a list of records in text form . With arguments `recList`, `formats`.", "question_id": 5840},
{"snippet": "core.records.fromrecords(recList, names=None)", "intent": "Create a recarray from a list of records in text form . With arguments `recList`, `names`.", "question_id": 5841},
{"snippet": "core.records.fromrecords(recList, titles=None)", "intent": "Create a recarray from a list of records in text form . With arguments `recList`, `titles`.", "question_id": 5842},
{"snippet": "core.records.fromrecords(recList, aligned=False)", "intent": "Create a recarray from a list of records in text form . With arguments `recList`, `aligned`.", "question_id": 5843},
{"snippet": "core.records.fromrecords(recList, byteorder=None)", "intent": "Create a recarray from a list of records in text form . With arguments `recList`, `byteorder`.", "question_id": 5844},
{"snippet": "core.records.fromrecords(recList, dtype=None, shape=None)", "intent": "Create a recarray from a list of records in text form . With arguments `recList`, `dtype`, `shape`.", "question_id": 5845},
{"snippet": "core.records.fromrecords(recList, dtype=None, formats=None)", "intent": "Create a recarray from a list of records in text form . With arguments `recList`, `dtype`, `formats`.", "question_id": 5846},
{"snippet": "numpy.subtract(x1, x2, /, signature, extobj)", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`.", "question_id": 5847},
{"snippet": "numpy.subtract(x1, x2, /, signature, extobj, out=None)", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 5848},
{"snippet": "numpy.subtract(x1, x2, /, signature, extobj, where=True)", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 5849},
{"snippet": "numpy.subtract(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 5850},
{"snippet": "numpy.subtract(x1, x2, /, signature, extobj, order='K')", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 5851},
{"snippet": "numpy.subtract(x1, x2, /, signature, extobj, dtype=None)", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 5852},
{"snippet": "numpy.subtract(x1, x2, /, signature, extobj, subok=True)", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 5853},
{"snippet": "numpy.subtract(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 5854},
{"snippet": "numpy.subtract(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 5855},
{"snippet": "numpy.subtract(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 5856},
{"snippet": "numpy.subtract(x1, x2, /, signature)", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`.", "question_id": 5857},
{"snippet": "numpy.subtract(x1, x2, /, signature, out=None)", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `out`.", "question_id": 5858},
{"snippet": "numpy.subtract(x1, x2, /, signature, where=True)", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `where`.", "question_id": 5859},
{"snippet": "numpy.subtract(x1, x2, /, signature, casting='same_kind')", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `casting`.", "question_id": 5860},
{"snippet": "numpy.subtract(x1, x2, /, signature, order='K')", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `order`.", "question_id": 5861},
{"snippet": "numpy.subtract(x1, x2, /, signature, dtype=None)", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `dtype`.", "question_id": 5862},
{"snippet": "numpy.subtract(x1, x2, /, signature, subok=True)", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `subok`.", "question_id": 5863},
{"snippet": "numpy.subtract(x1, x2, /, signature, out=None, where=True)", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `out`, `where`.", "question_id": 5864},
{"snippet": "numpy.subtract(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 5865},
{"snippet": "numpy.subtract(x1, x2, /, signature, out=None, order='K')", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `out`, `order`.", "question_id": 5866},
{"snippet": "numpy.logical_xor(x1, x2, /, signature, extobj)", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `extobj`.", "question_id": 5867},
{"snippet": "numpy.logical_xor(x1, x2, /, signature, extobj, out=None)", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 5868},
{"snippet": "numpy.logical_xor(x1, x2, /, signature, extobj, where=True)", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 5869},
{"snippet": "numpy.logical_xor(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 5870},
{"snippet": "numpy.logical_xor(x1, x2, /, signature, extobj, order='K')", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 5871},
{"snippet": "numpy.logical_xor(x1, x2, /, signature, extobj, dtype=None)", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 5872},
{"snippet": "numpy.logical_xor(x1, x2, /, signature, extobj, subok=True)", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 5873},
{"snippet": "numpy.logical_xor(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 5874},
{"snippet": "numpy.logical_xor(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 5875},
{"snippet": "numpy.logical_xor(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 5876},
{"snippet": "numpy.logical_xor(x1, x2, /, signature)", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`.", "question_id": 5877},
{"snippet": "numpy.logical_xor(x1, x2, /, signature, out=None)", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `out`.", "question_id": 5878},
{"snippet": "numpy.logical_xor(x1, x2, /, signature, where=True)", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `where`.", "question_id": 5879},
{"snippet": "numpy.logical_xor(x1, x2, /, signature, casting='same_kind')", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `casting`.", "question_id": 5880},
{"snippet": "numpy.logical_xor(x1, x2, /, signature, order='K')", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `order`.", "question_id": 5881},
{"snippet": "numpy.logical_xor(x1, x2, /, signature, dtype=None)", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `dtype`.", "question_id": 5882},
{"snippet": "numpy.logical_xor(x1, x2, /, signature, subok=True)", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `subok`.", "question_id": 5883},
{"snippet": "numpy.logical_xor(x1, x2, /, signature, out=None, where=True)", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `out`, `where`.", "question_id": 5884},
{"snippet": "numpy.logical_xor(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 5885},
{"snippet": "numpy.logical_xor(x1, x2, /, signature, out=None, order='K')", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `out`, `order`.", "question_id": 5886},
{"snippet": "memmap.searchsorted(v)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order .", "question_id": 5887},
{"snippet": "memmap.searchsorted(v, side='left')", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`.", "question_id": 5888},
{"snippet": "memmap.searchsorted(v, sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `sorter`.", "question_id": 5889},
{"snippet": "memmap.searchsorted(v, side='left', sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`, `sorter`.", "question_id": 5890},
{"snippet": "ma.empty_like(prototype)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`.", "question_id": 5891},
{"snippet": "ma.empty_like(prototype, dtype=None)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `dtype`.", "question_id": 5892},
{"snippet": "ma.empty_like(prototype, order='K')", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `order`.", "question_id": 5893},
{"snippet": "ma.empty_like(prototype, subok=True)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `subok`.", "question_id": 5894},
{"snippet": "ma.empty_like(prototype, shape=None)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`.", "question_id": 5895},
{"snippet": "ma.empty_like(prototype, dtype=None, order='K')", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `dtype`, `order`.", "question_id": 5896},
{"snippet": "ma.empty_like(prototype, dtype=None, subok=True)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `dtype`, `subok`.", "question_id": 5897},
{"snippet": "ma.empty_like(prototype, dtype=None, shape=None)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `dtype`.", "question_id": 5898},
{"snippet": "ma.empty_like(prototype, order='K', subok=True)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `order`, `subok`.", "question_id": 5899},
{"snippet": "ma.empty_like(prototype, order='K', shape=None)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `order`.", "question_id": 5900},
{"snippet": "numpy.typename(char)", "intent": "Return a description for the given data type code . With arguments `char`.", "question_id": 5901},
{"snippet": "polynomial.hermite_e.hermeadd(c1, c2)", "intent": "Add one Hermite series to another . Returns the sum of two Hermite series `c1` + `c2` .", "question_id": 5902},
{"snippet": "memmap.view(dtype, type)", "intent": "New view of array with the same data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) Viewing array data using a different `type` and dtype :", "question_id": 5903},
{"snippet": "memmap.view(dtype)", "intent": "New view of array with the same data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . )", "question_id": 5904},
{"snippet": "memmap.view()", "intent": "New view of array with the same data .", "question_id": 5905},
{"snippet": "ma.MaskedArray.__ne__(other)", "intent": "Check whether `other` does not equal self elementwise .", "question_id": 5906},
{"snippet": "lib.format.dtype_to_descr(dtype)", "intent": "Get a serializable descriptor from the `dtype` .", "question_id": 5907},
{"snippet": "generic.shape", "intent": "Tuple of array dimensions.", "question_id": 5908},
{"snippet": "ma.make_mask_descr(ndtype)", "intent": "Construct a dtype description list from a given dtype . Returns a new dtype object , with the type of all fields in `ndtype` to a boolean type .", "question_id": 5909},
{"snippet": "ma.MaskType.compress()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 5910},
{"snippet": "numpy.setbufsize(size)", "intent": "Set the `size` of the buffer used in ufuncs .", "question_id": 5911},
{"snippet": "polynomial.polynomial.polyadd(c1, c2)", "intent": "Add one polynomial to another . Returns the sum of two polynomials `c1` + `c2` .", "question_id": 5912},
{"snippet": "ma.MaskedArray.searchsorted(v)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order .", "question_id": 5913},
{"snippet": "ma.MaskedArray.searchsorted(v, side='left')", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`.", "question_id": 5914},
{"snippet": "ma.MaskedArray.searchsorted(v, sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `sorter`.", "question_id": 5915},
{"snippet": "ma.MaskedArray.searchsorted(v, side='left', sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`, `sorter`.", "question_id": 5916},
{"snippet": "char.chararray.rfind(sub)", "intent": "For each element in self , return the highest index in the string where substring `sub` is found , such that sub is contained within [ `start` , `end` ] .", "question_id": 5917},
{"snippet": "char.chararray.rfind(sub, start=0)", "intent": "For each element in self , return the highest index in the string where substring `sub` is found , such that sub is contained within [ `start` , `end` ] .", "question_id": 5918},
{"snippet": "char.chararray.rfind(sub, end=None)", "intent": "For each element in self , return the highest index in the string where substring `sub` is found , such that sub is contained within [ `start` , `end` ] .", "question_id": 5919},
{"snippet": "char.chararray.rfind(sub, start=0, end=None)", "intent": "For each element in self , return the highest index in the string where substring `sub` is found , such that sub is contained within [ `start` , `end` ] .", "question_id": 5920},
{"snippet": "generic.size", "intent": "The number of elements in the gentype.", "question_id": 5921},
{"snippet": "ma.max(obj)", "intent": "Return the maximum along a given `axis` . With arguments `obj`.", "question_id": 5922},
{"snippet": "ma.max(obj, axis=None)", "intent": "Return the maximum along a given `axis` . With arguments `obj`.", "question_id": 5923},
{"snippet": "ma.max(obj, out=None)", "intent": "Return the maximum along a given `axis` . With arguments `obj`, `out`.", "question_id": 5924},
{"snippet": "ma.max(obj, fill_value=None)", "intent": "Return the maximum along a given `axis` . With arguments `obj`, `fill_value`.", "question_id": 5925},
{"snippet": "ma.max(obj, keepdims=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `obj`, `keepdims`.", "question_id": 5926},
{"snippet": "ma.max(obj, axis=None, out=None)", "intent": "Return the maximum along a given `axis` . With arguments `obj`, `out`.", "question_id": 5927},
{"snippet": "ma.max(obj, axis=None, fill_value=None)", "intent": "Return the maximum along a given `axis` . With arguments `obj`, `fill_value`.", "question_id": 5928},
{"snippet": "ma.max(obj, axis=None, keepdims=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `obj`, `keepdims`.", "question_id": 5929},
{"snippet": "ma.max(obj, out=None, fill_value=None)", "intent": "Return the maximum along a given `axis` . With arguments `obj`, `out`, `fill_value`.", "question_id": 5930},
{"snippet": "ma.max(obj, out=None, keepdims=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `obj`, `out`, `keepdims`.", "question_id": 5931},
{"snippet": "polynomial.polynomial.Polynomial.has_sametype(other)", "intent": "Check if types match . With arguments `other`.", "question_id": 5932},
{"snippet": "ma.MaskedArray.nbytes", "intent": "Total bytes consumed by the elements of the array.", "question_id": 5933},
{"snippet": "flatiter.coords", "intent": "An N-dimensional tuple of current coordinates.", "question_id": 5934},
{"snippet": "numpy.imag(val)", "intent": "Return the imaginary part of the complex argument . With arguments `val`.", "question_id": 5935},
{"snippet": "chararray.splitlines()", "intent": "For each element in self , return a list of the lines in the element , breaking at line boundaries .", "question_id": 5936},
{"snippet": "chararray.splitlines(keepends=None)", "intent": "For each element in self , return a list of the lines in the element , breaking at line boundaries . With arguments `keepends`.", "question_id": 5937},
{"snippet": "ma.MaskedArray.__setmask__(mask)", "intent": "Set the `mask` .", "question_id": 5938},
{"snippet": "ma.MaskedArray.__setmask__(mask, copy=False)", "intent": "Set the `mask` . With arguments `copy`.", "question_id": 5939},
{"snippet": "numpy.spacing(x, /, signature, extobj)", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `extobj`.", "question_id": 5940},
{"snippet": "numpy.spacing(x, /, signature, extobj, out=None)", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 5941},
{"snippet": "numpy.spacing(x, /, signature, extobj, where=True)", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 5942},
{"snippet": "numpy.spacing(x, /, signature, extobj, casting='same_kind')", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 5943},
{"snippet": "numpy.spacing(x, /, signature, extobj, order='K')", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 5944},
{"snippet": "numpy.spacing(x, /, signature, extobj, dtype=None)", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 5945},
{"snippet": "numpy.spacing(x, /, signature, extobj, subok=True)", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 5946},
{"snippet": "numpy.spacing(x, /, signature, extobj, out=None, where=True)", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 5947},
{"snippet": "numpy.spacing(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 5948},
{"snippet": "numpy.spacing(x, /, signature, extobj, out=None, order='K')", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 5949},
{"snippet": "numpy.spacing(x, /, signature)", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`.", "question_id": 5950},
{"snippet": "numpy.spacing(x, /, signature, out=None)", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `out`.", "question_id": 5951},
{"snippet": "numpy.spacing(x, /, signature, where=True)", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `where`.", "question_id": 5952},
{"snippet": "numpy.spacing(x, /, signature, casting='same_kind')", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `casting`.", "question_id": 5953},
{"snippet": "numpy.spacing(x, /, signature, order='K')", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `order`.", "question_id": 5954},
{"snippet": "numpy.spacing(x, /, signature, dtype=None)", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `dtype`.", "question_id": 5955},
{"snippet": "numpy.spacing(x, /, signature, subok=True)", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `subok`.", "question_id": 5956},
{"snippet": "numpy.spacing(x, /, signature, out=None, where=True)", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `out`, `where`.", "question_id": 5957},
{"snippet": "numpy.spacing(x, /, signature, out=None, casting='same_kind')", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 5958},
{"snippet": "numpy.spacing(x, /, signature, out=None, order='K')", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `out`, `order`.", "question_id": 5959},
{"snippet": "matrix.strides", "intent": "Tuple of bytes to step in each dimension when traversing an array.", "question_id": 5960},
{"snippet": "polynomial.laguerre.Laguerre.has_samewindow(other)", "intent": "Check if windows match . With arguments `other`.", "question_id": 5961},
{"snippet": "char.not_equal(x1, x2)", "intent": "Return ( `x1` ! = `x2` ) element-wise .", "question_id": 5962},
{"snippet": "ma.masked_array.cumprod()", "intent": "Return the cumulative product of the array elements over the given `axis` .", "question_id": 5963},
{"snippet": "ma.masked_array.cumprod(axis=None)", "intent": "Return the cumulative product of the array elements over the given `axis` .", "question_id": 5964},
{"snippet": "ma.masked_array.cumprod(dtype=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 5965},
{"snippet": "ma.masked_array.cumprod(out=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . The mask is lost if `out` is not a valid MaskedArray !", "question_id": 5966},
{"snippet": "ma.masked_array.cumprod(axis=None, dtype=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 5967},
{"snippet": "ma.masked_array.cumprod(axis=None, out=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . The mask is lost if `out` is not a valid MaskedArray !", "question_id": 5968},
{"snippet": "ma.masked_array.cumprod(dtype=None, out=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . The mask is lost if `out` is not a valid MaskedArray ! With arguments `dtype`.", "question_id": 5969},
{"snippet": "ma.masked_array.cumprod(axis=None, dtype=None, out=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . The mask is lost if `out` is not a valid MaskedArray ! With arguments `dtype`.", "question_id": 5970},
{"snippet": "recarray.flags", "intent": "Information about the memory layout of the array.", "question_id": 5971},
{"snippet": "ma.masked_array.base", "intent": "Base object if memory is from some other object.", "question_id": 5972},
{"snippet": "ma.filled(a)", "intent": "Return input as an array with masked data replaced by `a` fill value .", "question_id": 5973},
{"snippet": "ma.filled(a, fill_value=None)", "intent": "Return input as an array with masked data replaced by `a` fill value . If a is a MaskedArray and `fill_value` is None , fill_value is set to a.fill_value .", "question_id": 5974},
{"snippet": "ma.MaskedArray.argmin()", "intent": "Return array of indices to the minimum values along the given `axis` .", "question_id": 5975},
{"snippet": "ma.MaskedArray.argmin(axis=None)", "intent": "Return array of indices to the minimum values along the given `axis` .", "question_id": 5976},
{"snippet": "ma.MaskedArray.argmin(fill_value=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `fill_value`.", "question_id": 5977},
{"snippet": "ma.MaskedArray.argmin(out=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `out`.", "question_id": 5978},
{"snippet": "ma.MaskedArray.argmin(axis=None, fill_value=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `fill_value`.", "question_id": 5979},
{"snippet": "ma.MaskedArray.argmin(axis=None, out=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `out`.", "question_id": 5980},
{"snippet": "ma.MaskedArray.argmin(fill_value=None, out=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `fill_value`, `out`.", "question_id": 5981},
{"snippet": "ma.MaskedArray.argmin(axis=None, fill_value=None, out=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `fill_value`, `out`.", "question_id": 5982},
{"snippet": "numpy.argmin(a)", "intent": "Returns the indices of the minimum values along an `axis` . Indices of the minimum elements of `a` N-dimensional array :", "question_id": 5983},
{"snippet": "numpy.argmin(a, axis=None)", "intent": "Returns the indices of the minimum values along an `axis` . Indices of the minimum elements of `a` N-dimensional array :", "question_id": 5984},
{"snippet": "numpy.argmin(a, out=None)", "intent": "Returns the indices of the minimum values along an `axis` . Indices of the minimum elements of `a` N-dimensional array : With arguments `out`.", "question_id": 5985},
{"snippet": "numpy.argmin(a, axis=None, out=None)", "intent": "Returns the indices of the minimum values along an `axis` . Indices of the minimum elements of `a` N-dimensional array : With arguments `out`.", "question_id": 5986},
{"snippet": "char.chararray.base", "intent": "Base object if memory is from some other object.", "question_id": 5987},
{"snippet": "ma.MaskedArray.nonzero()", "intent": "Return the indices of unmasked elements that are not zero .", "question_id": 5988},
{"snippet": "ufunc.identity", "intent": "The identity value.", "question_id": 5989},
{"snippet": "ma.MaskedArray.argsort()", "intent": "Return an ndarray of indices that sort the array along the specified `axis` .", "question_id": 5990},
{"snippet": "ma.MaskedArray.argsort(axis=<no value>)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` .", "question_id": 5991},
{"snippet": "ma.MaskedArray.argsort(kind=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `kind`.", "question_id": 5992},
{"snippet": "ma.MaskedArray.argsort(order=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `order`.", "question_id": 5993},
{"snippet": "ma.MaskedArray.argsort(endwith=True)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `endwith`.", "question_id": 5994},
{"snippet": "ma.MaskedArray.argsort(fill_value=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . Masked values are filled beforehand to `fill_value` .", "question_id": 5995},
{"snippet": "ma.MaskedArray.argsort(axis=<no value>, kind=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `kind`.", "question_id": 5996},
{"snippet": "ma.MaskedArray.argsort(axis=<no value>, order=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `order`.", "question_id": 5997},
{"snippet": "ma.MaskedArray.argsort(axis=<no value>, endwith=True)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `endwith`.", "question_id": 5998},
{"snippet": "ma.MaskedArray.argsort(axis=<no value>, fill_value=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . Masked values are filled beforehand to `fill_value` .", "question_id": 5999},
{"snippet": "ndarray.__floordiv__(value, /)", "intent": "Return self//value . With arguments `value`, `/`.", "question_id": 6000},
{"snippet": "ma.masked_array.tobytes()", "intent": "Return the array data as a string containing the raw bytes in the array .", "question_id": 6001},
{"snippet": "ma.masked_array.tobytes(fill_value=None)", "intent": "Return the array data as a string containing the raw bytes in the array . As for ndarray.tobytes , information about the shape , dtype , etc. , but also about `fill_value` , will be lost .", "question_id": 6002},
{"snippet": "ma.masked_array.tobytes(order='C')", "intent": "Return the array data as a string containing the raw bytes in the array . With arguments `order`.", "question_id": 6003},
{"snippet": "ma.masked_array.tobytes(fill_value=None, order='C')", "intent": "Return the array data as a string containing the raw bytes in the array . As for ndarray.tobytes , information about the shape , dtype , etc. , but also about `fill_value` , will be lost . With arguments `order`.", "question_id": 6004},
{"snippet": "numpy.nansum(a)", "intent": "Return the sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero .", "question_id": 6005},
{"snippet": "numpy.nansum(a, axis=None)", "intent": "Return the sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero .", "question_id": 6006},
{"snippet": "numpy.nansum(a, dtype=None)", "intent": "Return the sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `dtype`.", "question_id": 6007},
{"snippet": "numpy.nansum(a, out=None)", "intent": "Return the sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `out`.", "question_id": 6008},
{"snippet": "numpy.nansum(a, keepdims=<no value>)", "intent": "Return the sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `keepdims`.", "question_id": 6009},
{"snippet": "numpy.nansum(a, axis=None, dtype=None)", "intent": "Return the sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `dtype`.", "question_id": 6010},
{"snippet": "numpy.nansum(a, axis=None, out=None)", "intent": "Return the sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `out`.", "question_id": 6011},
{"snippet": "numpy.nansum(a, axis=None, keepdims=<no value>)", "intent": "Return the sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `keepdims`.", "question_id": 6012},
{"snippet": "numpy.nansum(a, dtype=None, out=None)", "intent": "Return the sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `dtype`, `out`.", "question_id": 6013},
{"snippet": "numpy.nansum(a, dtype=None, keepdims=<no value>)", "intent": "Return the sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `dtype`, `keepdims`.", "question_id": 6014},
{"snippet": "chararray.setfield(val, dtype)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field .", "question_id": 6015},
{"snippet": "chararray.setfield(val, dtype, offset=0)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field .", "question_id": 6016},
{"snippet": "numpy.var(a)", "intent": "Compute the variance along the specified `axis` . Returns the variance of the array elements , `a` measure of the spread of a distribution .", "question_id": 6017},
{"snippet": "numpy.var(a, axis=None)", "intent": "Compute the variance along the specified `axis` . Returns the variance of the array elements , `a` measure of the spread of a distribution .", "question_id": 6018},
{"snippet": "numpy.var(a, dtype=None)", "intent": "Compute the variance along the specified `axis` . Returns the variance of the array elements , `a` measure of the spread of a distribution . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue .", "question_id": 6019},
{"snippet": "numpy.var(a, out=None)", "intent": "Compute the variance along the specified `axis` . Returns the variance of the array elements , `a` measure of the spread of a distribution . With arguments `out`.", "question_id": 6020},
{"snippet": "numpy.var(a, ddof=0)", "intent": "Compute the variance along the specified `axis` . Returns the variance of the array elements , `a` measure of the spread of a distribution . If , however , `ddof` is specified , the divisor N - ddof is used instead .", "question_id": 6021},
{"snippet": "numpy.var(a, keepdims=<no value>)", "intent": "Compute the variance along the specified `axis` . Returns the variance of the array elements , `a` measure of the spread of a distribution . With arguments `keepdims`.", "question_id": 6022},
{"snippet": "numpy.var(a, where=<no value>)", "intent": "Compute the variance along the specified `axis` . Returns the variance of the array elements , `a` measure of the spread of a distribution . The variance is the average of the squared deviations from the mean , i.e. , var = mean ( x ) , `where` x = abs ( a - a.mean ( ) ) * * 2 .", "question_id": 6023},
{"snippet": "numpy.var(a, axis=None, dtype=None)", "intent": "Compute the variance along the specified `axis` . Returns the variance of the array elements , `a` measure of the spread of a distribution . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue .", "question_id": 6024},
{"snippet": "numpy.var(a, axis=None, out=None)", "intent": "Compute the variance along the specified `axis` . Returns the variance of the array elements , `a` measure of the spread of a distribution . With arguments `out`.", "question_id": 6025},
{"snippet": "numpy.var(a, axis=None, ddof=0)", "intent": "Compute the variance along the specified `axis` . Returns the variance of the array elements , `a` measure of the spread of a distribution . If , however , `ddof` is specified , the divisor N - ddof is used instead .", "question_id": 6026},
{"snippet": "recarray.min()", "intent": "Return the minimum along a given `axis` .", "question_id": 6027},
{"snippet": "recarray.min(axis=None)", "intent": "Return the minimum along a given `axis` .", "question_id": 6028},
{"snippet": "recarray.min(out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`.", "question_id": 6029},
{"snippet": "recarray.min(keepdims=False)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`.", "question_id": 6030},
{"snippet": "recarray.min(initial=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `initial`.", "question_id": 6031},
{"snippet": "recarray.min(where=True)", "intent": "Return the minimum along a given `axis` . With arguments `where`.", "question_id": 6032},
{"snippet": "recarray.min(axis=None, out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`.", "question_id": 6033},
{"snippet": "recarray.min(axis=None, keepdims=False)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`.", "question_id": 6034},
{"snippet": "recarray.min(axis=None, initial=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `initial`.", "question_id": 6035},
{"snippet": "recarray.min(axis=None, where=True)", "intent": "Return the minimum along a given `axis` . With arguments `where`.", "question_id": 6036},
{"snippet": "ma.masked_array.newbyteorder(/)", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`.", "question_id": 6037},
{"snippet": "ma.masked_array.newbyteorder(/, new_order='S')", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`, `new_order`.", "question_id": 6038},
{"snippet": "numpy.eye(N)", "intent": "Return a 2-D array with ones on the diagonal and zeros elsewhere . With arguments `N`.", "question_id": 6039},
{"snippet": "numpy.eye(N, M=None)", "intent": "Return a 2-D array with ones on the diagonal and zeros elsewhere . With arguments `N`, `M`.", "question_id": 6040},
{"snippet": "numpy.eye(N, k=0)", "intent": "Return a 2-D array with ones on the diagonal and zeros elsewhere . With arguments `N`, `k`.", "question_id": 6041},
{"snippet": "numpy.eye(N, dtype=<class 'float'>)", "intent": "Return a 2-D array with ones on the diagonal and zeros elsewhere . With arguments `N`, `dtype`.", "question_id": 6042},
{"snippet": "numpy.eye(N, order='C')", "intent": "Return a 2-D array with ones on the diagonal and zeros elsewhere . With arguments `N`, `order`.", "question_id": 6043},
{"snippet": "numpy.eye(N, like=None)", "intent": "Return a 2-D array with ones on the diagonal and zeros elsewhere . With arguments `N`, `like`.", "question_id": 6044},
{"snippet": "numpy.eye(N, M=None, k=0)", "intent": "Return a 2-D array with ones on the diagonal and zeros elsewhere . With arguments `N`, `M`, `k`.", "question_id": 6045},
{"snippet": "numpy.eye(N, M=None, dtype=<class 'float'>)", "intent": "Return a 2-D array with ones on the diagonal and zeros elsewhere . With arguments `N`, `M`, `dtype`.", "question_id": 6046},
{"snippet": "numpy.eye(N, M=None, order='C')", "intent": "Return a 2-D array with ones on the diagonal and zeros elsewhere . With arguments `N`, `M`, `order`.", "question_id": 6047},
{"snippet": "numpy.eye(N, M=None, like=None)", "intent": "Return a 2-D array with ones on the diagonal and zeros elsewhere . With arguments `N`, `M`, `like`.", "question_id": 6048},
{"snippet": "ma.masked_array.astype(dtype)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`.", "question_id": 6049},
{"snippet": "ma.masked_array.astype(dtype, order='K')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`.", "question_id": 6050},
{"snippet": "ma.masked_array.astype(dtype, casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`.", "question_id": 6051},
{"snippet": "ma.masked_array.astype(dtype, subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `subok`.", "question_id": 6052},
{"snippet": "ma.masked_array.astype(dtype, copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `copy`.", "question_id": 6053},
{"snippet": "ma.masked_array.astype(dtype, order='K', casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `casting`.", "question_id": 6054},
{"snippet": "ma.masked_array.astype(dtype, order='K', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `subok`.", "question_id": 6055},
{"snippet": "ma.masked_array.astype(dtype, order='K', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `copy`.", "question_id": 6056},
{"snippet": "ma.masked_array.astype(dtype, casting='unsafe', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `subok`.", "question_id": 6057},
{"snippet": "ma.masked_array.astype(dtype, casting='unsafe', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `copy`.", "question_id": 6058},
{"snippet": "numpy.ma.masked_array", "intent": "alias of numpy.ma.core.MaskedArray", "question_id": 6059},
{"snippet": "numpy.r_", "intent": "Translates slice objects to concatenation along the first axis.", "question_id": 6060},
{"snippet": "ma.masked_array.unshare_mask()", "intent": "Copy the mask and set the sharedmask flag to False .", "question_id": 6061},
{"snippet": "recarray.nbytes", "intent": "Total bytes consumed by the elements of the array.", "question_id": 6062},
{"snippet": "numpy.info()", "intent": "Get help information for a function , class , or module .", "question_id": 6063},
{"snippet": "numpy.info(object=None)", "intent": "Get help information for a function , class , or module . When used interactively with an `object` , np.info ( obj ) is equivalent to help ( obj ) on the Python prompt or obj ?", "question_id": 6064},
{"snippet": "numpy.info(maxwidth=76)", "intent": "Get help information for a function , class , or module . With arguments `maxwidth`.", "question_id": 6065},
{"snippet": "numpy.info(output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>)", "intent": "Get help information for a function , class , or module . With arguments `output`.", "question_id": 6066},
{"snippet": "numpy.info(toplevel='numpy')", "intent": "Get help information for a function , class , or module . With arguments `toplevel`.", "question_id": 6067},
{"snippet": "numpy.info(object=None, maxwidth=76)", "intent": "Get help information for a function , class , or module . When used interactively with an `object` , np.info ( obj ) is equivalent to help ( obj ) on the Python prompt or obj ? With arguments `maxwidth`.", "question_id": 6068},
{"snippet": "numpy.info(object=None, output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>)", "intent": "Get help information for a function , class , or module . When used interactively with an `object` , np.info ( obj ) is equivalent to help ( obj ) on the Python prompt or obj ? With arguments `output`.", "question_id": 6069},
{"snippet": "numpy.info(object=None, toplevel='numpy')", "intent": "Get help information for a function , class , or module . When used interactively with an `object` , np.info ( obj ) is equivalent to help ( obj ) on the Python prompt or obj ? With arguments `toplevel`.", "question_id": 6070},
{"snippet": "numpy.info(maxwidth=76, output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>)", "intent": "Get help information for a function , class , or module . With arguments `maxwidth`, `output`.", "question_id": 6071},
{"snippet": "numpy.info(maxwidth=76, toplevel='numpy')", "intent": "Get help information for a function , class , or module . With arguments `maxwidth`, `toplevel`.", "question_id": 6072},
{"snippet": "numpy.union1d(ar1, ar2)", "intent": "Find the union of two arrays . With arguments `ar1`, `ar2`.", "question_id": 6073},
{"snippet": "chararray.var()", "intent": "Returns the variance of the array elements , along given `axis` .", "question_id": 6074},
{"snippet": "chararray.var(axis=None)", "intent": "Returns the variance of the array elements , along given `axis` .", "question_id": 6075},
{"snippet": "chararray.var(dtype=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `dtype`.", "question_id": 6076},
{"snippet": "chararray.var(out=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `out`.", "question_id": 6077},
{"snippet": "chararray.var(ddof=0)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `ddof`.", "question_id": 6078},
{"snippet": "chararray.var(keepdims=False)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `keepdims`.", "question_id": 6079},
{"snippet": "chararray.var(where=True)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `where`.", "question_id": 6080},
{"snippet": "chararray.var(axis=None, dtype=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `dtype`.", "question_id": 6081},
{"snippet": "chararray.var(axis=None, out=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `out`.", "question_id": 6082},
{"snippet": "chararray.var(axis=None, ddof=0)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `ddof`.", "question_id": 6083},
{"snippet": "char.rfind(a, sub)", "intent": "For each element in `a` , return the highest index in the string where substring `sub` is found , such that sub is contained within [ `start` , `end` ] .", "question_id": 6084},
{"snippet": "char.rfind(a, sub, start=0)", "intent": "For each element in `a` , return the highest index in the string where substring `sub` is found , such that sub is contained within [ `start` , `end` ] .", "question_id": 6085},
{"snippet": "char.rfind(a, sub, end=None)", "intent": "For each element in `a` , return the highest index in the string where substring `sub` is found , such that sub is contained within [ `start` , `end` ] .", "question_id": 6086},
{"snippet": "char.rfind(a, sub, start=0, end=None)", "intent": "For each element in `a` , return the highest index in the string where substring `sub` is found , such that sub is contained within [ `start` , `end` ] .", "question_id": 6087},
{"snippet": "ma.MaskedArray.__isub__(other)", "intent": "Subtract `other` from self in-place .", "question_id": 6088},
{"snippet": "ma.MaskedArray.__iadd__(other)", "intent": "Add `other` to self in-place .", "question_id": 6089},
{"snippet": "char.chararray.reshape(shape)", "intent": "Returns an array containing the same data with a new `shape` .", "question_id": 6090},
{"snippet": "char.chararray.reshape(shape, order='C')", "intent": "Returns an array containing the same data with a new `shape` . With arguments `order`.", "question_id": 6091},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_implies_c(names)", "intent": "same as feature_implies ( ) but combining \u2018 `names` \u2019", "question_id": 6092},
{"snippet": "char.chararray.prod()", "intent": "Return the product of the array elements over the given `axis`", "question_id": 6093},
{"snippet": "char.chararray.prod(axis=None)", "intent": "Return the product of the array elements over the given `axis`", "question_id": 6094},
{"snippet": "char.chararray.prod(dtype=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `dtype`.", "question_id": 6095},
{"snippet": "char.chararray.prod(out=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `out`.", "question_id": 6096},
{"snippet": "char.chararray.prod(keepdims=False)", "intent": "Return the product of the array elements over the given `axis` With arguments `keepdims`.", "question_id": 6097},
{"snippet": "char.chararray.prod(initial=1)", "intent": "Return the product of the array elements over the given `axis` With arguments `initial`.", "question_id": 6098},
{"snippet": "char.chararray.prod(where=True)", "intent": "Return the product of the array elements over the given `axis` With arguments `where`.", "question_id": 6099},
{"snippet": "char.chararray.prod(axis=None, dtype=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `dtype`.", "question_id": 6100},
{"snippet": "char.chararray.prod(axis=None, out=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `out`.", "question_id": 6101},
{"snippet": "char.chararray.prod(axis=None, keepdims=False)", "intent": "Return the product of the array elements over the given `axis` With arguments `keepdims`.", "question_id": 6102},
{"snippet": "numpy.set_string_function(f)", "intent": "Set a Python function to be used when pretty printing arrays . With arguments `f`.", "question_id": 6103},
{"snippet": "numpy.set_string_function(f, repr=True)", "intent": "Set a Python function to be used when pretty printing arrays . `repr` affects either pretty printing or normal string representation . With arguments `f`.", "question_id": 6104},
{"snippet": "random.standard_t(df)", "intent": "Draw samples from a standard Student \u2019 s t distribution with `df` degrees of freedom .", "question_id": 6105},
{"snippet": "random.standard_t(df, size=None)", "intent": "Draw samples from a standard Student \u2019 s t distribution with `df` degrees of freedom . With arguments `size`.", "question_id": 6106},
{"snippet": "polynomial.polynomial.Polynomial.truncate(size)", "intent": "Truncate series to length `size` .", "question_id": 6107},
{"snippet": "recarray.setflags()", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively .", "question_id": 6108},
{"snippet": "recarray.setflags(write=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`.", "question_id": 6109},
{"snippet": "recarray.setflags(align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`.", "question_id": 6110},
{"snippet": "recarray.setflags(uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `uic`.", "question_id": 6111},
{"snippet": "recarray.setflags(write=None, align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`.", "question_id": 6112},
{"snippet": "recarray.setflags(write=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `uic`.", "question_id": 6113},
{"snippet": "recarray.setflags(align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`, `uic`.", "question_id": 6114},
{"snippet": "recarray.setflags(write=None, align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`, `uic`.", "question_id": 6115},
{"snippet": "ma.MaskedArray.repeat(repeats)", "intent": "Repeat elements of an array . With arguments `repeats`.", "question_id": 6116},
{"snippet": "ma.MaskedArray.repeat(repeats, axis=None)", "intent": "Repeat elements of an array . With arguments `repeats`, `axis`.", "question_id": 6117},
{"snippet": "core.records.fromstring(datastring)", "intent": "Create a record array from binary data With arguments `datastring`.", "question_id": 6118},
{"snippet": "core.records.fromstring(datastring, dtype=None)", "intent": "Create a record array from binary data With arguments `datastring`, `dtype`.", "question_id": 6119},
{"snippet": "core.records.fromstring(datastring, shape=None)", "intent": "Create a record array from binary data With arguments `datastring`, `shape`.", "question_id": 6120},
{"snippet": "core.records.fromstring(datastring, offset=0)", "intent": "Create a record array from binary data With arguments `datastring`, `offset`.", "question_id": 6121},
{"snippet": "core.records.fromstring(datastring, formats=None)", "intent": "Create a record array from binary data With arguments `datastring`, `formats`.", "question_id": 6122},
{"snippet": "core.records.fromstring(datastring, names=None)", "intent": "Create a record array from binary data With arguments `datastring`, `names`.", "question_id": 6123},
{"snippet": "core.records.fromstring(datastring, titles=None)", "intent": "Create a record array from binary data With arguments `datastring`, `titles`.", "question_id": 6124},
{"snippet": "core.records.fromstring(datastring, aligned=False)", "intent": "Create a record array from binary data With arguments `datastring`, `aligned`.", "question_id": 6125},
{"snippet": "core.records.fromstring(datastring, byteorder=None)", "intent": "Create a record array from binary data With arguments `datastring`, `byteorder`.", "question_id": 6126},
{"snippet": "core.records.fromstring(datastring, dtype=None, shape=None)", "intent": "Create a record array from binary data With arguments `datastring`, `dtype`, `shape`.", "question_id": 6127},
{"snippet": "ma.MaskType.nonzero()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 6128},
{"snippet": "numpy.logical_or(x1, x2, /, signature, extobj)", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `extobj`.", "question_id": 6129},
{"snippet": "numpy.logical_or(x1, x2, /, signature, extobj, out=None)", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 6130},
{"snippet": "numpy.logical_or(x1, x2, /, signature, extobj, where=True)", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 6131},
{"snippet": "numpy.logical_or(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 6132},
{"snippet": "numpy.logical_or(x1, x2, /, signature, extobj, order='K')", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 6133},
{"snippet": "numpy.logical_or(x1, x2, /, signature, extobj, dtype=None)", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 6134},
{"snippet": "numpy.logical_or(x1, x2, /, signature, extobj, subok=True)", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 6135},
{"snippet": "numpy.logical_or(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 6136},
{"snippet": "numpy.logical_or(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 6137},
{"snippet": "numpy.logical_or(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 6138},
{"snippet": "numpy.logical_or(x1, x2, /, signature)", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`.", "question_id": 6139},
{"snippet": "numpy.logical_or(x1, x2, /, signature, out=None)", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `out`.", "question_id": 6140},
{"snippet": "numpy.logical_or(x1, x2, /, signature, where=True)", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `where`.", "question_id": 6141},
{"snippet": "numpy.logical_or(x1, x2, /, signature, casting='same_kind')", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `casting`.", "question_id": 6142},
{"snippet": "numpy.logical_or(x1, x2, /, signature, order='K')", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `order`.", "question_id": 6143},
{"snippet": "numpy.logical_or(x1, x2, /, signature, dtype=None)", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `dtype`.", "question_id": 6144},
{"snippet": "numpy.logical_or(x1, x2, /, signature, subok=True)", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `subok`.", "question_id": 6145},
{"snippet": "numpy.logical_or(x1, x2, /, signature, out=None, where=True)", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `out`, `where`.", "question_id": 6146},
{"snippet": "numpy.logical_or(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 6147},
{"snippet": "numpy.logical_or(x1, x2, /, signature, out=None, order='K')", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `out`, `order`.", "question_id": 6148},
{"snippet": "ndarray.__irshift__(value, /)", "intent": "Return self > > =value . With arguments `value`, `/`.", "question_id": 6149},
{"snippet": "polynomial.hermite.hermroots(c)", "intent": "Compute the roots of a Hermite series . With arguments `c`.", "question_id": 6150},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.dist_load_module(name, path)", "intent": "Load a module from file , required by the abstract class \u2018 _Cache \u2019 . With arguments `name`, `path`.", "question_id": 6151},
{"snippet": "numpy.reshape(a, newshape)", "intent": "Gives `a` new shape to an array without changing its data . With arguments `newshape`.", "question_id": 6152},
{"snippet": "numpy.reshape(a, newshape, order='C')", "intent": "Gives `a` new shape to an array without changing its data . The `order` keyword gives the index ordering both for fetching the values from a , and then placing the values into the output array . With arguments `newshape`.", "question_id": 6153},
{"snippet": "random.weibull(a)", "intent": "Draw samples from `a` Weibull distribution .", "question_id": 6154},
{"snippet": "random.weibull(a, size=None)", "intent": "Draw samples from `a` Weibull distribution . With arguments `size`.", "question_id": 6155},
{"snippet": "ma.MaskedArray.__bool__(/)", "intent": "self ! = 0 With arguments `/`.", "question_id": 6156},
{"snippet": "char.add(x1, x2)", "intent": "Return element-wise string concatenation for two arrays of str or unicode . Arrays `x1` and `x2` must have the same shape .", "question_id": 6157},
{"snippet": "ma.MaskedArray.__ge__(value, /)", "intent": "Return self > =value . With arguments `value`, `/`.", "question_id": 6158},
{"snippet": "matrix.ptp()", "intent": "Peak-to-peak ( maximum - minimum ) value along the given `axis` .", "question_id": 6159},
{"snippet": "matrix.ptp(axis=None)", "intent": "Peak-to-peak ( maximum - minimum ) value along the given `axis` .", "question_id": 6160},
{"snippet": "matrix.ptp(out=None)", "intent": "Peak-to-peak ( maximum - minimum ) value along the given `axis` . With arguments `out`.", "question_id": 6161},
{"snippet": "matrix.ptp(axis=None, out=None)", "intent": "Peak-to-peak ( maximum - minimum ) value along the given `axis` . With arguments `out`.", "question_id": 6162},
{"snippet": "char.partition(a, sep)", "intent": "Partition each element in `a` around `sep` .", "question_id": 6163},
{"snippet": "random.RandomState.set_state(state)", "intent": "Set the internal `state` of the generator from a tuple .", "question_id": 6164},
{"snippet": "polynomial.laguerre.Laguerre.deriv()", "intent": "Differentiate .", "question_id": 6165},
{"snippet": "polynomial.laguerre.Laguerre.deriv(m=1)", "intent": "Differentiate . With arguments `m`.", "question_id": 6166},
{"snippet": "memmap.take(indices)", "intent": "Return an array formed from the elements of a at the given `indices` .", "question_id": 6167},
{"snippet": "memmap.take(indices, axis=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`.", "question_id": 6168},
{"snippet": "memmap.take(indices, out=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `out`.", "question_id": 6169},
{"snippet": "memmap.take(indices, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `mode`.", "question_id": 6170},
{"snippet": "memmap.take(indices, axis=None, out=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `out`.", "question_id": 6171},
{"snippet": "memmap.take(indices, axis=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `mode`.", "question_id": 6172},
{"snippet": "memmap.take(indices, out=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `out`, `mode`.", "question_id": 6173},
{"snippet": "memmap.take(indices, axis=None, out=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `out`, `mode`.", "question_id": 6174},
{"snippet": "char.equal(x1, x2)", "intent": "Return ( `x1` == `x2` ) element-wise .", "question_id": 6175},
{"snippet": "numpy.repeat(a, repeats)", "intent": "Repeat elements of an array . With arguments `a`, `repeats`.", "question_id": 6176},
{"snippet": "numpy.repeat(a, repeats, axis=None)", "intent": "Repeat elements of an array . With arguments `a`, `repeats`, `axis`.", "question_id": 6177},
{"snippet": "numpy.trim_zeros(filt)", "intent": "Trim the leading and/or trailing zeros from a 1-D array or sequence . With arguments `filt`.", "question_id": 6178},
{"snippet": "numpy.trim_zeros(filt, trim='fb')", "intent": "Trim the leading and/or trailing zeros from a 1-D array or sequence . With arguments `filt`, `trim`.", "question_id": 6179},
{"snippet": "ma.MaskType.any()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 6180},
{"snippet": "ma.hstack(*args, **kwargs)", "intent": "Stack arrays in sequence horizontally ( column wise ) . With arguments `*args`, `**kwargs`.", "question_id": 6181},
{"snippet": "numpy.asanyarray(a)", "intent": "Convert the input to an ndarray , but pass ndarray subclasses through . Convert `a` list into an array :", "question_id": 6182},
{"snippet": "numpy.asanyarray(a, dtype=None)", "intent": "Convert the input to an ndarray , but pass ndarray subclasses through . Convert `a` list into an array : With arguments `dtype`.", "question_id": 6183},
{"snippet": "numpy.asanyarray(a, order=None)", "intent": "Convert the input to an ndarray , but pass ndarray subclasses through . Convert `a` list into an array : With arguments `order`.", "question_id": 6184},
{"snippet": "numpy.asanyarray(a, like=None)", "intent": "Convert the input to an ndarray , but pass ndarray subclasses through . Convert `a` list into an array : With arguments `like`.", "question_id": 6185},
{"snippet": "numpy.asanyarray(a, dtype=None, order=None)", "intent": "Convert the input to an ndarray , but pass ndarray subclasses through . Convert `a` list into an array : With arguments `dtype`, `order`.", "question_id": 6186},
{"snippet": "numpy.asanyarray(a, dtype=None, like=None)", "intent": "Convert the input to an ndarray , but pass ndarray subclasses through . Convert `a` list into an array : With arguments `dtype`, `like`.", "question_id": 6187},
{"snippet": "numpy.asanyarray(a, order=None, like=None)", "intent": "Convert the input to an ndarray , but pass ndarray subclasses through . Convert `a` list into an array : With arguments `order`, `like`.", "question_id": 6188},
{"snippet": "numpy.asanyarray(a, dtype=None, order=None, like=None)", "intent": "Convert the input to an ndarray , but pass ndarray subclasses through . Convert `a` list into an array : With arguments `dtype`, `order`, `like`.", "question_id": 6189},
{"snippet": "char.chararray.islower()", "intent": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character , false otherwise .", "question_id": 6190},
{"snippet": "matrix.copy()", "intent": "Return a copy of the array .", "question_id": 6191},
{"snippet": "matrix.copy(order='C')", "intent": "Return a copy of the array . The function numpy.copy is similar , but it defaults to using `order` \u2018 K \u2019 , and will not pass sub-classes through by default .", "question_id": 6192},
{"snippet": "numpy.radians(x, /, signature, extobj)", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `extobj`.", "question_id": 6193},
{"snippet": "numpy.radians(x, /, signature, extobj, out=None)", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `extobj`, `out`.", "question_id": 6194},
{"snippet": "numpy.radians(x, /, signature, extobj, where=True)", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `extobj`, `where`.", "question_id": 6195},
{"snippet": "numpy.radians(x, /, signature, extobj, casting='same_kind')", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `extobj`, `casting`.", "question_id": 6196},
{"snippet": "numpy.radians(x, /, signature, extobj, order='K')", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `extobj`, `order`.", "question_id": 6197},
{"snippet": "numpy.radians(x, /, signature, extobj, dtype=None)", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `extobj`, `dtype`.", "question_id": 6198},
{"snippet": "numpy.radians(x, /, signature, extobj, subok=True)", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `extobj`, `subok`.", "question_id": 6199},
{"snippet": "numpy.radians(x, /, signature, extobj, out=None, where=True)", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 6200},
{"snippet": "numpy.radians(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 6201},
{"snippet": "numpy.radians(x, /, signature, extobj, out=None, order='K')", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 6202},
{"snippet": "numpy.radians(x, /, signature)", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`.", "question_id": 6203},
{"snippet": "numpy.radians(x, /, signature, out=None)", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `out`.", "question_id": 6204},
{"snippet": "numpy.radians(x, /, signature, where=True)", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `where`.", "question_id": 6205},
{"snippet": "numpy.radians(x, /, signature, casting='same_kind')", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `casting`.", "question_id": 6206},
{"snippet": "numpy.radians(x, /, signature, order='K')", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `order`.", "question_id": 6207},
{"snippet": "numpy.radians(x, /, signature, dtype=None)", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `dtype`.", "question_id": 6208},
{"snippet": "numpy.radians(x, /, signature, subok=True)", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `subok`.", "question_id": 6209},
{"snippet": "numpy.radians(x, /, signature, out=None, where=True)", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `out`, `where`.", "question_id": 6210},
{"snippet": "numpy.radians(x, /, signature, out=None, casting='same_kind')", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `out`, `casting`.", "question_id": 6211},
{"snippet": "numpy.radians(x, /, signature, out=None, order='K')", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `out`, `order`.", "question_id": 6212},
{"snippet": "ma.masked_array.dumps()", "intent": "Returns the pickle of the array as a string .", "question_id": 6213},
{"snippet": "char.chararray.rjust(width)", "intent": "Return an array with the elements of self right-justified in a string of length `width` .", "question_id": 6214},
{"snippet": "char.chararray.rjust(width, fillchar=' ')", "intent": "Return an array with the elements of self right-justified in a string of length `width` . With arguments `fillchar`.", "question_id": 6215},
{"snippet": "polynomial.hermite.hermvander(x, deg)", "intent": "Pseudo-Vandermonde matrix of given degree . Returns the pseudo-Vandermonde matrix of degree `deg` and sample points `x` .", "question_id": 6216},
{"snippet": "ma.masked_array.repeat(repeats)", "intent": "Repeat elements of an array . With arguments `repeats`.", "question_id": 6217},
{"snippet": "ma.masked_array.repeat(repeats, axis=None)", "intent": "Repeat elements of an array . With arguments `repeats`, `axis`.", "question_id": 6218},
{"snippet": "matlib.eye(n)", "intent": "Return a matrix with ones on the diagonal and zeros elsewhere . With arguments `n`.", "question_id": 6219},
{"snippet": "matlib.eye(n, M=None)", "intent": "Return a matrix with ones on the diagonal and zeros elsewhere . With arguments `n`, `M`.", "question_id": 6220},
{"snippet": "matlib.eye(n, k=0)", "intent": "Return a matrix with ones on the diagonal and zeros elsewhere . With arguments `n`, `k`.", "question_id": 6221},
{"snippet": "matlib.eye(n, dtype=<class 'float'>)", "intent": "Return a matrix with ones on the diagonal and zeros elsewhere . With arguments `n`, `dtype`.", "question_id": 6222},
{"snippet": "matlib.eye(n, order='C')", "intent": "Return a matrix with ones on the diagonal and zeros elsewhere . With arguments `n`, `order`.", "question_id": 6223},
{"snippet": "matlib.eye(n, M=None, k=0)", "intent": "Return a matrix with ones on the diagonal and zeros elsewhere . With arguments `n`, `M`, `k`.", "question_id": 6224},
{"snippet": "matlib.eye(n, M=None, dtype=<class 'float'>)", "intent": "Return a matrix with ones on the diagonal and zeros elsewhere . With arguments `n`, `M`, `dtype`.", "question_id": 6225},
{"snippet": "matlib.eye(n, M=None, order='C')", "intent": "Return a matrix with ones on the diagonal and zeros elsewhere . With arguments `n`, `M`, `order`.", "question_id": 6226},
{"snippet": "matlib.eye(n, k=0, dtype=<class 'float'>)", "intent": "Return a matrix with ones on the diagonal and zeros elsewhere . With arguments `n`, `k`, `dtype`.", "question_id": 6227},
{"snippet": "matlib.eye(n, k=0, order='C')", "intent": "Return a matrix with ones on the diagonal and zeros elsewhere . With arguments `n`, `k`, `order`.", "question_id": 6228},
{"snippet": "chararray.isupper()", "intent": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character , false otherwise .", "question_id": 6229},
{"snippet": "chararray.strip()", "intent": "For each element in self , return a copy with the leading and trailing characters removed .", "question_id": 6230},
{"snippet": "chararray.strip(chars=None)", "intent": "For each element in self , return a copy with the leading and trailing characters removed . With arguments `chars`.", "question_id": 6231},
{"snippet": "ufunc.ntypes", "intent": "The number of types.", "question_id": 6232},
{"snippet": "polynomial.laguerre.lagfromroots(roots)", "intent": "Generate a Laguerre series with given `roots` .", "question_id": 6233},
{"snippet": "numpy.all(a)", "intent": "Test whether all array elements along `a` given `axis` evaluate to True .", "question_id": 6234},
{"snippet": "numpy.all(a, axis=None)", "intent": "Test whether all array elements along `a` given `axis` evaluate to True .", "question_id": 6235},
{"snippet": "numpy.all(a, out=None)", "intent": "Test whether all array elements along `a` given `axis` evaluate to True . With arguments `out`.", "question_id": 6236},
{"snippet": "numpy.all(a, keepdims=<no value>)", "intent": "Test whether all array elements along `a` given `axis` evaluate to True . With arguments `keepdims`.", "question_id": 6237},
{"snippet": "numpy.all(a, where=<no value>)", "intent": "Test whether all array elements along `a` given `axis` evaluate to True . With arguments `where`.", "question_id": 6238},
{"snippet": "numpy.all(a, axis=None, out=None)", "intent": "Test whether all array elements along `a` given `axis` evaluate to True . With arguments `out`.", "question_id": 6239},
{"snippet": "numpy.all(a, axis=None, keepdims=<no value>)", "intent": "Test whether all array elements along `a` given `axis` evaluate to True . With arguments `keepdims`.", "question_id": 6240},
{"snippet": "numpy.all(a, axis=None, where=<no value>)", "intent": "Test whether all array elements along `a` given `axis` evaluate to True . With arguments `where`.", "question_id": 6241},
{"snippet": "numpy.all(a, out=None, keepdims=<no value>)", "intent": "Test whether all array elements along `a` given `axis` evaluate to True . With arguments `out`, `keepdims`.", "question_id": 6242},
{"snippet": "numpy.all(a, out=None, where=<no value>)", "intent": "Test whether all array elements along `a` given `axis` evaluate to True . With arguments `out`, `where`.", "question_id": 6243},
{"snippet": "char.chararray.shape", "intent": "Tuple of array dimensions.", "question_id": 6244},
{"snippet": "ma.argmin(self)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `self`.", "question_id": 6245},
{"snippet": "ma.argmin(self, axis=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `self`.", "question_id": 6246},
{"snippet": "ma.argmin(self, fill_value=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `self`, `fill_value`.", "question_id": 6247},
{"snippet": "ma.argmin(self, out=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `self`, `out`.", "question_id": 6248},
{"snippet": "ma.argmin(self, axis=None, fill_value=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `self`, `fill_value`.", "question_id": 6249},
{"snippet": "ma.argmin(self, axis=None, out=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `self`, `out`.", "question_id": 6250},
{"snippet": "ma.argmin(self, fill_value=None, out=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `self`, `fill_value`, `out`.", "question_id": 6251},
{"snippet": "ma.argmin(self, axis=None, fill_value=None, out=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `self`, `fill_value`, `out`.", "question_id": 6252},
{"snippet": "memmap.cumsum()", "intent": "Return the cumulative sum of the elements along the given `axis` .", "question_id": 6253},
{"snippet": "memmap.cumsum(axis=None)", "intent": "Return the cumulative sum of the elements along the given `axis` .", "question_id": 6254},
{"snippet": "memmap.cumsum(dtype=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`.", "question_id": 6255},
{"snippet": "memmap.cumsum(out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `out`.", "question_id": 6256},
{"snippet": "memmap.cumsum(axis=None, dtype=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`.", "question_id": 6257},
{"snippet": "memmap.cumsum(axis=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `out`.", "question_id": 6258},
{"snippet": "memmap.cumsum(dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 6259},
{"snippet": "memmap.cumsum(axis=None, dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 6260},
{"snippet": "numpy.nanmedian(a)", "intent": "Compute the median along the specified `axis` , while ignoring NaNs . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i.e. , V_sorted [ ( N-1 ) /2 ] , when N is odd and the average of the two middle values of V_sorted when N is even .", "question_id": 6261},
{"snippet": "numpy.nanmedian(a, axis=None)", "intent": "Compute the median along the specified `axis` , while ignoring NaNs . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i.e. , V_sorted [ ( N-1 ) /2 ] , when N is odd and the average of the two middle values of V_sorted when N is even .", "question_id": 6262},
{"snippet": "numpy.nanmedian(a, out=None)", "intent": "Compute the median along the specified `axis` , while ignoring NaNs . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i.e. , V_sorted [ ( N-1 ) /2 ] , when N is odd and the average of the two middle values of V_sorted when N is even . With arguments `out`.", "question_id": 6263},
{"snippet": "numpy.nanmedian(a, overwrite_input=False)", "intent": "Compute the median along the specified `axis` , while ignoring NaNs . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i.e. , V_sorted [ ( N-1 ) /2 ] , when N is odd and the average of the two middle values of V_sorted when N is even . With arguments `overwrite_input`.", "question_id": 6264},
{"snippet": "numpy.nanmedian(a, keepdims=<no value>)", "intent": "Compute the median along the specified `axis` , while ignoring NaNs . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i.e. , V_sorted [ ( N-1 ) /2 ] , when N is odd and the average of the two middle values of V_sorted when N is even . With arguments `keepdims`.", "question_id": 6265},
{"snippet": "numpy.nanmedian(a, axis=None, out=None)", "intent": "Compute the median along the specified `axis` , while ignoring NaNs . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i.e. , V_sorted [ ( N-1 ) /2 ] , when N is odd and the average of the two middle values of V_sorted when N is even . With arguments `out`.", "question_id": 6266},
{"snippet": "numpy.nanmedian(a, axis=None, overwrite_input=False)", "intent": "Compute the median along the specified `axis` , while ignoring NaNs . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i.e. , V_sorted [ ( N-1 ) /2 ] , when N is odd and the average of the two middle values of V_sorted when N is even . With arguments `overwrite_input`.", "question_id": 6267},
{"snippet": "numpy.nanmedian(a, axis=None, keepdims=<no value>)", "intent": "Compute the median along the specified `axis` , while ignoring NaNs . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i.e. , V_sorted [ ( N-1 ) /2 ] , when N is odd and the average of the two middle values of V_sorted when N is even . With arguments `keepdims`.", "question_id": 6268},
{"snippet": "numpy.nanmedian(a, out=None, overwrite_input=False)", "intent": "Compute the median along the specified `axis` , while ignoring NaNs . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i.e. , V_sorted [ ( N-1 ) /2 ] , when N is odd and the average of the two middle values of V_sorted when N is even . With arguments `out`, `overwrite_input`.", "question_id": 6269},
{"snippet": "numpy.nanmedian(a, out=None, keepdims=<no value>)", "intent": "Compute the median along the specified `axis` , while ignoring NaNs . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i.e. , V_sorted [ ( N-1 ) /2 ] , when N is odd and the average of the two middle values of V_sorted when N is even . With arguments `out`, `keepdims`.", "question_id": 6270},
{"snippet": "ma.masked_array.transpose(*axes)", "intent": "Returns a view of the array with axes transposed . With arguments `*axes`.", "question_id": 6271},
{"snippet": "numpy.argsort(a)", "intent": "Returns the indices that would sort an array . It returns an array of indices of the same shape as `a` that index data along the given axis in sorted `order` .", "question_id": 6272},
{"snippet": "numpy.argsort(a, axis=- 1)", "intent": "Returns the indices that would sort an array . It returns an array of indices of the same shape as `a` that index data along the given axis in sorted `order` . Perform an indirect sort along the given `axis` using the algorithm specified by the `kind` keyword .", "question_id": 6273},
{"snippet": "numpy.argsort(a, kind=None)", "intent": "Returns the indices that would sort an array . It returns an array of indices of the same shape as `a` that index data along the given axis in sorted `order` . Perform an indirect sort along the given `axis` using the algorithm specified by the `kind` keyword .", "question_id": 6274},
{"snippet": "numpy.argsort(a, order=None)", "intent": "Returns the indices that would sort an array . It returns an array of indices of the same shape as `a` that index data along the given axis in sorted `order` .", "question_id": 6275},
{"snippet": "numpy.argsort(a, axis=- 1, kind=None)", "intent": "Returns the indices that would sort an array . It returns an array of indices of the same shape as `a` that index data along the given axis in sorted `order` . Perform an indirect sort along the given `axis` using the algorithm specified by the `kind` keyword .", "question_id": 6276},
{"snippet": "numpy.argsort(a, axis=- 1, order=None)", "intent": "Returns the indices that would sort an array . It returns an array of indices of the same shape as `a` that index data along the given axis in sorted `order` . Perform an indirect sort along the given `axis` using the algorithm specified by the `kind` keyword .", "question_id": 6277},
{"snippet": "numpy.argsort(a, kind=None, order=None)", "intent": "Returns the indices that would sort an array . It returns an array of indices of the same shape as `a` that index data along the given axis in sorted `order` . Perform an indirect sort along the given `axis` using the algorithm specified by the `kind` keyword .", "question_id": 6278},
{"snippet": "numpy.argsort(a, axis=- 1, kind=None, order=None)", "intent": "Returns the indices that would sort an array . It returns an array of indices of the same shape as `a` that index data along the given axis in sorted `order` . Perform an indirect sort along the given `axis` using the algorithm specified by the `kind` keyword .", "question_id": 6279},
{"snippet": "ma.MaskedArray.__int__()", "intent": "Convert to int .", "question_id": 6280},
{"snippet": "ma.MaskedArray.__mod__(value, /)", "intent": "Return self % `value` . With arguments `/`.", "question_id": 6281},
{"snippet": "polynomial.hermite.Hermite.trim()", "intent": "Remove trailing coefficients", "question_id": 6282},
{"snippet": "polynomial.hermite.Hermite.trim(tol=0)", "intent": "Remove trailing coefficients Remove trailing coefficients until a coefficient is reached whose absolute value greater than `tol` or the beginning of the series is reached .", "question_id": 6283},
{"snippet": "random.noncentral_f(dfnum, dfden, nonc)", "intent": "Draw samples from the noncentral F distribution . Samples are drawn from an F distribution with specified parameters , `dfnum` ( degrees of freedom in numerator ) and `dfden` ( degrees of freedom in denominator ) , where both parameters > 1. `nonc` is the non-centrality parameter .", "question_id": 6284},
{"snippet": "random.noncentral_f(dfnum, dfden, nonc, size=None)", "intent": "Draw samples from the noncentral F distribution . Samples are drawn from an F distribution with specified parameters , `dfnum` ( degrees of freedom in numerator ) and `dfden` ( degrees of freedom in denominator ) , where both parameters > 1. `nonc` is the non-centrality parameter . With arguments `size`.", "question_id": 6285},
{"snippet": "ma.diag(v)", "intent": "Extract a diagonal or construct a diagonal array . With arguments `v`.", "question_id": 6286},
{"snippet": "ma.diag(v, k=0)", "intent": "Extract a diagonal or construct a diagonal array . With arguments `v`, `k`.", "question_id": 6287},
{"snippet": "ndarray.tolist()", "intent": "Return the array as an a.ndim-levels deep nested list of Python scalars .", "question_id": 6288},
{"snippet": "matrix.trace()", "intent": "Return the sum along diagonals of the array .", "question_id": 6289},
{"snippet": "matrix.trace(offset=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`.", "question_id": 6290},
{"snippet": "matrix.trace(axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `axis1`.", "question_id": 6291},
{"snippet": "matrix.trace(axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `axis2`.", "question_id": 6292},
{"snippet": "matrix.trace(dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `dtype`.", "question_id": 6293},
{"snippet": "matrix.trace(out=None)", "intent": "Return the sum along diagonals of the array . With arguments `out`.", "question_id": 6294},
{"snippet": "matrix.trace(offset=0, axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis1`.", "question_id": 6295},
{"snippet": "matrix.trace(offset=0, axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis2`.", "question_id": 6296},
{"snippet": "matrix.trace(offset=0, dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `dtype`.", "question_id": 6297},
{"snippet": "matrix.trace(offset=0, out=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `out`.", "question_id": 6298},
{"snippet": "poly1d.deriv()", "intent": "Return a derivative of this polynomial .", "question_id": 6299},
{"snippet": "poly1d.deriv(m=1)", "intent": "Return a derivative of this polynomial . With arguments `m`.", "question_id": 6300},
{"snippet": "numpy.isfinite(x, /, signature, extobj)", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `extobj`.", "question_id": 6301},
{"snippet": "numpy.isfinite(x, /, signature, extobj, out=None)", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 6302},
{"snippet": "numpy.isfinite(x, /, signature, extobj, where=True)", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 6303},
{"snippet": "numpy.isfinite(x, /, signature, extobj, casting='same_kind')", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 6304},
{"snippet": "numpy.isfinite(x, /, signature, extobj, order='K')", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 6305},
{"snippet": "numpy.isfinite(x, /, signature, extobj, dtype=None)", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 6306},
{"snippet": "numpy.isfinite(x, /, signature, extobj, subok=True)", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 6307},
{"snippet": "numpy.isfinite(x, /, signature, extobj, out=None, where=True)", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 6308},
{"snippet": "numpy.isfinite(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 6309},
{"snippet": "numpy.isfinite(x, /, signature, extobj, out=None, order='K')", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 6310},
{"snippet": "numpy.isfinite(x, /, signature)", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`.", "question_id": 6311},
{"snippet": "numpy.isfinite(x, /, signature, out=None)", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `out`.", "question_id": 6312},
{"snippet": "numpy.isfinite(x, /, signature, where=True)", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `where`.", "question_id": 6313},
{"snippet": "numpy.isfinite(x, /, signature, casting='same_kind')", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `casting`.", "question_id": 6314},
{"snippet": "numpy.isfinite(x, /, signature, order='K')", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `order`.", "question_id": 6315},
{"snippet": "numpy.isfinite(x, /, signature, dtype=None)", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `dtype`.", "question_id": 6316},
{"snippet": "numpy.isfinite(x, /, signature, subok=True)", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `subok`.", "question_id": 6317},
{"snippet": "numpy.isfinite(x, /, signature, out=None, where=True)", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `out`, `where`.", "question_id": 6318},
{"snippet": "numpy.isfinite(x, /, signature, out=None, casting='same_kind')", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 6319},
{"snippet": "numpy.isfinite(x, /, signature, out=None, order='K')", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `out`, `order`.", "question_id": 6320},
{"snippet": "numpy.require(a)", "intent": "Return an ndarray of the provided type that satisfies `requirements` . The returned array will be guaranteed to have the listed requirements by making `a` copy if needed .", "question_id": 6321},
{"snippet": "numpy.require(a, dtype=None)", "intent": "Return an ndarray of the provided type that satisfies `requirements` . The returned array will be guaranteed to have the listed requirements by making `a` copy if needed . With arguments `dtype`.", "question_id": 6322},
{"snippet": "numpy.require(a, requirements=None)", "intent": "Return an ndarray of the provided type that satisfies `requirements` . The returned array will be guaranteed to have the listed requirements by making `a` copy if needed .", "question_id": 6323},
{"snippet": "numpy.require(a, like=None)", "intent": "Return an ndarray of the provided type that satisfies `requirements` . The returned array will be guaranteed to have the listed requirements by making `a` copy if needed . With arguments `like`.", "question_id": 6324},
{"snippet": "numpy.require(a, dtype=None, requirements=None)", "intent": "Return an ndarray of the provided type that satisfies `requirements` . The returned array will be guaranteed to have the listed requirements by making `a` copy if needed . With arguments `dtype`.", "question_id": 6325},
{"snippet": "numpy.require(a, dtype=None, like=None)", "intent": "Return an ndarray of the provided type that satisfies `requirements` . The returned array will be guaranteed to have the listed requirements by making `a` copy if needed . With arguments `dtype`, `like`.", "question_id": 6326},
{"snippet": "numpy.require(a, requirements=None, like=None)", "intent": "Return an ndarray of the provided type that satisfies `requirements` . The returned array will be guaranteed to have the listed requirements by making `a` copy if needed . With arguments `like`.", "question_id": 6327},
{"snippet": "numpy.require(a, dtype=None, requirements=None, like=None)", "intent": "Return an ndarray of the provided type that satisfies `requirements` . The returned array will be guaranteed to have the listed requirements by making `a` copy if needed . With arguments `dtype`, `like`.", "question_id": 6328},
{"snippet": "char.chararray.size", "intent": "Number of elements in the array.", "question_id": 6329},
{"snippet": "memmap.data", "intent": "Python buffer object pointing to the start of the array\u2019s data.", "question_id": 6330},
{"snippet": "ma.harden_mask(self)", "intent": "Force the mask to hard . With arguments `self`.", "question_id": 6331},
{"snippet": "numpy.full(shape, fill_value)", "intent": "Return a new array of given `shape` and type , filled with `fill_value` .", "question_id": 6332},
{"snippet": "numpy.full(shape, fill_value, dtype=None)", "intent": "Return a new array of given `shape` and type , filled with `fill_value` . With arguments `dtype`.", "question_id": 6333},
{"snippet": "numpy.full(shape, fill_value, order='C')", "intent": "Return a new array of given `shape` and type , filled with `fill_value` . With arguments `order`.", "question_id": 6334},
{"snippet": "numpy.full(shape, fill_value, like=None)", "intent": "Return a new array of given `shape` and type , filled with `fill_value` . With arguments `like`.", "question_id": 6335},
{"snippet": "numpy.full(shape, fill_value, dtype=None, order='C')", "intent": "Return a new array of given `shape` and type , filled with `fill_value` . With arguments `dtype`, `order`.", "question_id": 6336},
{"snippet": "numpy.full(shape, fill_value, dtype=None, like=None)", "intent": "Return a new array of given `shape` and type , filled with `fill_value` . With arguments `dtype`, `like`.", "question_id": 6337},
{"snippet": "numpy.full(shape, fill_value, order='C', like=None)", "intent": "Return a new array of given `shape` and type , filled with `fill_value` . With arguments `order`, `like`.", "question_id": 6338},
{"snippet": "numpy.full(shape, fill_value, dtype=None, order='C', like=None)", "intent": "Return a new array of given `shape` and type , filled with `fill_value` . With arguments `dtype`, `order`, `like`.", "question_id": 6339},
{"snippet": "polynomial.hermite_e.HermiteE.trim()", "intent": "Remove trailing coefficients", "question_id": 6340},
{"snippet": "polynomial.hermite_e.HermiteE.trim(tol=0)", "intent": "Remove trailing coefficients Remove trailing coefficients until a coefficient is reached whose absolute value greater than `tol` or the beginning of the series is reached .", "question_id": 6341},
{"snippet": "matrix.getA()", "intent": "Return self as an ndarray object .", "question_id": 6342},
{"snippet": "char.chararray.copy()", "intent": "Return a copy of the array .", "question_id": 6343},
{"snippet": "char.chararray.copy(order='C')", "intent": "Return a copy of the array . The function numpy.copy is similar , but it defaults to using `order` \u2018 K \u2019 , and will not pass sub-classes through by default .", "question_id": 6344},
{"snippet": "polynomial.chebyshev.chebweight(x)", "intent": "The weight function of the Chebyshev polynomials . With arguments `x`.", "question_id": 6345},
{"snippet": "ma.masked_where(condition, a)", "intent": "Mask an array where `a` `condition` is met .", "question_id": 6346},
{"snippet": "ma.masked_where(condition, a, copy=True)", "intent": "Mask an array where `a` `condition` is met . Effect of the `copy` argument .", "question_id": 6347},
{"snippet": "numpy.arcsin(x, /, signature, extobj)", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `extobj`.", "question_id": 6348},
{"snippet": "numpy.arcsin(x, /, signature, extobj, out=None)", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 6349},
{"snippet": "numpy.arcsin(x, /, signature, extobj, where=True)", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 6350},
{"snippet": "numpy.arcsin(x, /, signature, extobj, casting='same_kind')", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 6351},
{"snippet": "numpy.arcsin(x, /, signature, extobj, order='K')", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 6352},
{"snippet": "numpy.arcsin(x, /, signature, extobj, dtype=None)", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 6353},
{"snippet": "numpy.arcsin(x, /, signature, extobj, subok=True)", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 6354},
{"snippet": "numpy.arcsin(x, /, signature, extobj, out=None, where=True)", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 6355},
{"snippet": "numpy.arcsin(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 6356},
{"snippet": "numpy.arcsin(x, /, signature, extobj, out=None, order='K')", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 6357},
{"snippet": "numpy.arcsin(x, /, signature)", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`.", "question_id": 6358},
{"snippet": "numpy.arcsin(x, /, signature, out=None)", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `out`.", "question_id": 6359},
{"snippet": "numpy.arcsin(x, /, signature, where=True)", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `where`.", "question_id": 6360},
{"snippet": "numpy.arcsin(x, /, signature, casting='same_kind')", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `casting`.", "question_id": 6361},
{"snippet": "numpy.arcsin(x, /, signature, order='K')", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `order`.", "question_id": 6362},
{"snippet": "numpy.arcsin(x, /, signature, dtype=None)", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `dtype`.", "question_id": 6363},
{"snippet": "numpy.arcsin(x, /, signature, subok=True)", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `subok`.", "question_id": 6364},
{"snippet": "numpy.arcsin(x, /, signature, out=None, where=True)", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `out`, `where`.", "question_id": 6365},
{"snippet": "numpy.arcsin(x, /, signature, out=None, casting='same_kind')", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 6366},
{"snippet": "numpy.arcsin(x, /, signature, out=None, order='K')", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `out`, `order`.", "question_id": 6367},
{"snippet": "numpy.row_stack(tup)", "intent": "Stack arrays in sequence vertically ( row wise ) . With arguments `tup`.", "question_id": 6368},
{"snippet": "polynomial.chebyshev.Chebyshev.trim()", "intent": "Remove trailing coefficients", "question_id": 6369},
{"snippet": "polynomial.chebyshev.Chebyshev.trim(tol=0)", "intent": "Remove trailing coefficients Remove trailing coefficients until a coefficient is reached whose absolute value greater than `tol` or the beginning of the series is reached .", "question_id": 6370},
{"snippet": "ma.MaskedArray.__eq__(other)", "intent": "Check whether `other` equals self elementwise .", "question_id": 6371},
{"snippet": "polynomial.legendre.leggrid3d(x, y, z, c)", "intent": "Evaluate a 3-D Legendre series on the Cartesian product of `x` , `y` , and `z` . where the points ( a , b , `c` ) consist of all triples formed by taking a from x , b from y , and c from z .", "question_id": 6372},
{"snippet": "random.RandomState.normal()", "intent": "Draw random samples from a normal ( Gaussian ) distribution .", "question_id": 6373},
{"snippet": "random.RandomState.normal(loc=0.0)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `loc`.", "question_id": 6374},
{"snippet": "random.RandomState.normal(scale=1.0)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `scale`.", "question_id": 6375},
{"snippet": "random.RandomState.normal(size=None)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `size`.", "question_id": 6376},
{"snippet": "random.RandomState.normal(loc=0.0, scale=1.0)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `loc`, `scale`.", "question_id": 6377},
{"snippet": "random.RandomState.normal(loc=0.0, size=None)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `loc`, `size`.", "question_id": 6378},
{"snippet": "random.RandomState.normal(scale=1.0, size=None)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `scale`, `size`.", "question_id": 6379},
{"snippet": "random.RandomState.normal(loc=0.0, scale=1.0, size=None)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `loc`, `scale`, `size`.", "question_id": 6380},
{"snippet": "numpy.c_", "intent": "Translates slice objects to concatenation along the second axis.", "question_id": 6381},
{"snippet": "testing.assert_array_less(x, y)", "intent": "Raises an AssertionError if two array_like objects are not ordered by less than . With arguments `x`, `y`.", "question_id": 6382},
{"snippet": "testing.assert_array_less(x, y, err_msg='')", "intent": "Raises an AssertionError if two array_like objects are not ordered by less than . With arguments `x`, `y`, `err_msg`.", "question_id": 6383},
{"snippet": "testing.assert_array_less(x, y, verbose=True)", "intent": "Raises an AssertionError if two array_like objects are not ordered by less than . With arguments `x`, `y`, `verbose`.", "question_id": 6384},
{"snippet": "testing.assert_array_less(x, y, err_msg='', verbose=True)", "intent": "Raises an AssertionError if two array_like objects are not ordered by less than . With arguments `x`, `y`, `err_msg`, `verbose`.", "question_id": 6385},
{"snippet": "numpy.nditer(op)", "intent": "Efficient multi-dimensional iterator object to iterate over arrays . With arguments `op`.", "question_id": 6386},
{"snippet": "numpy.nditer(op, flags=None)", "intent": "Efficient multi-dimensional iterator object to iterate over arrays . If operand `flags` \u201c writeonly \u201d or \u201c readwrite \u201d are used the operands may be views into the original data with the WRITEBACKIFCOPY flag . With arguments `op`.", "question_id": 6387},
{"snippet": "numpy.nditer(op, op_flags=None)", "intent": "Efficient multi-dimensional iterator object to iterate over arrays . With arguments `op`, `op_flags`.", "question_id": 6388},
{"snippet": "numpy.nditer(op, op_dtypes=None)", "intent": "Efficient multi-dimensional iterator object to iterate over arrays . With arguments `op`, `op_dtypes`.", "question_id": 6389},
{"snippet": "numpy.nditer(op, order='K')", "intent": "Efficient multi-dimensional iterator object to iterate over arrays . With arguments `op`, `order`.", "question_id": 6390},
{"snippet": "numpy.nditer(op, casting='safe')", "intent": "Efficient multi-dimensional iterator object to iterate over arrays . With arguments `op`, `casting`.", "question_id": 6391},
{"snippet": "numpy.nditer(op, op_axes=None)", "intent": "Efficient multi-dimensional iterator object to iterate over arrays . With arguments `op`, `op_axes`.", "question_id": 6392},
{"snippet": "numpy.nditer(op, itershape=None)", "intent": "Efficient multi-dimensional iterator object to iterate over arrays . With arguments `op`, `itershape`.", "question_id": 6393},
{"snippet": "numpy.nditer(op, buffersize=0)", "intent": "Efficient multi-dimensional iterator object to iterate over arrays . With arguments `op`, `buffersize`.", "question_id": 6394},
{"snippet": "numpy.nditer(op, flags=None, op_flags=None)", "intent": "Efficient multi-dimensional iterator object to iterate over arrays . If operand `flags` \u201c writeonly \u201d or \u201c readwrite \u201d are used the operands may be views into the original data with the WRITEBACKIFCOPY flag . With arguments `op`, `op_flags`.", "question_id": 6395},
{"snippet": "chararray.real", "intent": "The real part of the array.", "question_id": 6396},
{"snippet": "ma.MaskType.sort()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 6397},
{"snippet": "random.Generator.beta(a, b)", "intent": "Draw samples from `a` Beta distribution . With arguments `b`.", "question_id": 6398},
{"snippet": "random.Generator.beta(a, b, size=None)", "intent": "Draw samples from `a` Beta distribution . With arguments `b`, `size`.", "question_id": 6399},
{"snippet": "random.RandomState.exponential()", "intent": "Draw samples from an exponential distribution .", "question_id": 6400},
{"snippet": "random.RandomState.exponential(scale=1.0)", "intent": "Draw samples from an exponential distribution . \\ ( \\beta\\ ) is the `scale` parameter , which is the inverse of the rate parameter \\ ( \\lambda = 1/\\beta\\ ) .", "question_id": 6401},
{"snippet": "random.RandomState.exponential(size=None)", "intent": "Draw samples from an exponential distribution . It describes many common situations , such as the `size` of raindrops measured over many rainstorms [ 1 ] , or the time between page requests to Wikipedia [ 2 ] .", "question_id": 6402},
{"snippet": "random.RandomState.exponential(scale=1.0, size=None)", "intent": "Draw samples from an exponential distribution . \\ ( \\beta\\ ) is the `scale` parameter , which is the inverse of the rate parameter \\ ( \\lambda = 1/\\beta\\ ) . It describes many common situations , such as the `size` of raindrops measured over many rainstorms [ 1 ] , or the time between page requests to Wikipedia [ 2 ] .", "question_id": 6403},
{"snippet": "char.replace(a, old, new)", "intent": "For each element in `a` , return a copy of the string with all occurrences of substring `old` replaced by `new` .", "question_id": 6404},
{"snippet": "char.replace(a, old, new, count=None)", "intent": "For each element in `a` , return a copy of the string with all occurrences of substring `old` replaced by `new` . With arguments `count`.", "question_id": 6405},
{"snippet": "ma.soften_mask(self)", "intent": "Force the mask to soft . With arguments `self`.", "question_id": 6406},
{"snippet": "recarray.flat", "intent": "A 1-D iterator over the array.", "question_id": 6407},
{"snippet": "char.rjust(a, width)", "intent": "Return an array with the elements of `a` right-justified in a string of length `width` .", "question_id": 6408},
{"snippet": "char.rjust(a, width, fillchar=' ')", "intent": "Return an array with the elements of `a` right-justified in a string of length `width` . With arguments `fillchar`.", "question_id": 6409},
{"snippet": "numpy.mat(data)", "intent": "Interpret the input as a matrix . Equivalent to matrix ( `data` , copy=False ) .", "question_id": 6410},
{"snippet": "numpy.mat(data, dtype=None)", "intent": "Interpret the input as a matrix . Equivalent to matrix ( `data` , copy=False ) . With arguments `dtype`.", "question_id": 6411},
{"snippet": "polynomial.laguerre.lagfit(x, y, deg)", "intent": "Least squares fit of Laguerre series to data . Return the coefficients of a Laguerre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` .", "question_id": 6412},
{"snippet": "polynomial.laguerre.lagfit(x, y, deg, rcond=None)", "intent": "Least squares fit of Laguerre series to data . Return the coefficients of a Laguerre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error .", "question_id": 6413},
{"snippet": "polynomial.laguerre.lagfit(x, y, deg, full=False)", "intent": "Least squares fit of Laguerre series to data . Return the coefficients of a Laguerre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . With arguments `full`.", "question_id": 6414},
{"snippet": "polynomial.laguerre.lagfit(x, y, deg, w=None)", "intent": "Least squares fit of Laguerre series to data . Return the coefficients of a Laguerre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values .", "question_id": 6415},
{"snippet": "polynomial.laguerre.lagfit(x, y, deg, rcond=None, full=False)", "intent": "Least squares fit of Laguerre series to data . Return the coefficients of a Laguerre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . With arguments `full`.", "question_id": 6416},
{"snippet": "polynomial.laguerre.lagfit(x, y, deg, rcond=None, w=None)", "intent": "Least squares fit of Laguerre series to data . Return the coefficients of a Laguerre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values .", "question_id": 6417},
{"snippet": "polynomial.laguerre.lagfit(x, y, deg, full=False, w=None)", "intent": "Least squares fit of Laguerre series to data . Return the coefficients of a Laguerre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values . With arguments `full`.", "question_id": 6418},
{"snippet": "polynomial.laguerre.lagfit(x, y, deg, rcond=None, full=False, w=None)", "intent": "Least squares fit of Laguerre series to data . Return the coefficients of a Laguerre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values . With arguments `full`.", "question_id": 6419},
{"snippet": "numpy.expm1(x, /, signature, extobj)", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `extobj`.", "question_id": 6420},
{"snippet": "numpy.expm1(x, /, signature, extobj, out=None)", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 6421},
{"snippet": "numpy.expm1(x, /, signature, extobj, where=True)", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 6422},
{"snippet": "numpy.expm1(x, /, signature, extobj, casting='same_kind')", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 6423},
{"snippet": "numpy.expm1(x, /, signature, extobj, order='K')", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 6424},
{"snippet": "numpy.expm1(x, /, signature, extobj, dtype=None)", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 6425},
{"snippet": "numpy.expm1(x, /, signature, extobj, subok=True)", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 6426},
{"snippet": "numpy.expm1(x, /, signature, extobj, out=None, where=True)", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 6427},
{"snippet": "numpy.expm1(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 6428},
{"snippet": "numpy.expm1(x, /, signature, extobj, out=None, order='K')", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 6429},
{"snippet": "numpy.expm1(x, /, signature)", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`.", "question_id": 6430},
{"snippet": "numpy.expm1(x, /, signature, out=None)", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `out`.", "question_id": 6431},
{"snippet": "numpy.expm1(x, /, signature, where=True)", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `where`.", "question_id": 6432},
{"snippet": "numpy.expm1(x, /, signature, casting='same_kind')", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `casting`.", "question_id": 6433},
{"snippet": "numpy.expm1(x, /, signature, order='K')", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `order`.", "question_id": 6434},
{"snippet": "numpy.expm1(x, /, signature, dtype=None)", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `dtype`.", "question_id": 6435},
{"snippet": "numpy.expm1(x, /, signature, subok=True)", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `subok`.", "question_id": 6436},
{"snippet": "numpy.expm1(x, /, signature, out=None, where=True)", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `out`, `where`.", "question_id": 6437},
{"snippet": "numpy.expm1(x, /, signature, out=None, casting='same_kind')", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 6438},
{"snippet": "numpy.expm1(x, /, signature, out=None, order='K')", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `out`, `order`.", "question_id": 6439},
{"snippet": "memmap.mean()", "intent": "Returns the average of the array elements along given `axis` .", "question_id": 6440},
{"snippet": "memmap.mean(axis=None)", "intent": "Returns the average of the array elements along given `axis` .", "question_id": 6441},
{"snippet": "memmap.mean(dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`.", "question_id": 6442},
{"snippet": "memmap.mean(out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`.", "question_id": 6443},
{"snippet": "memmap.mean(keepdims=False)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`.", "question_id": 6444},
{"snippet": "memmap.mean(where=True)", "intent": "Returns the average of the array elements along given `axis` . With arguments `where`.", "question_id": 6445},
{"snippet": "memmap.mean(axis=None, dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`.", "question_id": 6446},
{"snippet": "memmap.mean(axis=None, out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`.", "question_id": 6447},
{"snippet": "memmap.mean(axis=None, keepdims=False)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`.", "question_id": 6448},
{"snippet": "memmap.mean(axis=None, where=True)", "intent": "Returns the average of the array elements along given `axis` . With arguments `where`.", "question_id": 6449},
{"snippet": "lib.scimath.log10(x)", "intent": "Compute the logarithm base 10 of `x` .", "question_id": 6450},
{"snippet": "ndarray.__add__(value, /)", "intent": "Return self+value . With arguments `value`, `/`.", "question_id": 6451},
{"snippet": "ma.MaskType.sum()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 6452},
{"snippet": "dtype.str", "intent": "The array-protocol typestring of this data-type object.", "question_id": 6453},
{"snippet": "numpy.degrees(x, /, signature, extobj)", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `extobj`.", "question_id": 6454},
{"snippet": "numpy.degrees(x, /, signature, extobj, out=None)", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `extobj`, `out`.", "question_id": 6455},
{"snippet": "numpy.degrees(x, /, signature, extobj, where=True)", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `extobj`, `where`.", "question_id": 6456},
{"snippet": "numpy.degrees(x, /, signature, extobj, casting='same_kind')", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `extobj`, `casting`.", "question_id": 6457},
{"snippet": "numpy.degrees(x, /, signature, extobj, order='K')", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `extobj`, `order`.", "question_id": 6458},
{"snippet": "numpy.degrees(x, /, signature, extobj, dtype=None)", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `extobj`, `dtype`.", "question_id": 6459},
{"snippet": "numpy.degrees(x, /, signature, extobj, subok=True)", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `extobj`, `subok`.", "question_id": 6460},
{"snippet": "numpy.degrees(x, /, signature, extobj, out=None, where=True)", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 6461},
{"snippet": "numpy.degrees(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 6462},
{"snippet": "numpy.degrees(x, /, signature, extobj, out=None, order='K')", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 6463},
{"snippet": "numpy.degrees(x, /, signature)", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`.", "question_id": 6464},
{"snippet": "numpy.degrees(x, /, signature, out=None)", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `out`.", "question_id": 6465},
{"snippet": "numpy.degrees(x, /, signature, where=True)", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `where`.", "question_id": 6466},
{"snippet": "numpy.degrees(x, /, signature, casting='same_kind')", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `casting`.", "question_id": 6467},
{"snippet": "numpy.degrees(x, /, signature, order='K')", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `order`.", "question_id": 6468},
{"snippet": "numpy.degrees(x, /, signature, dtype=None)", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `dtype`.", "question_id": 6469},
{"snippet": "numpy.degrees(x, /, signature, subok=True)", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `subok`.", "question_id": 6470},
{"snippet": "numpy.degrees(x, /, signature, out=None, where=True)", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `out`, `where`.", "question_id": 6471},
{"snippet": "numpy.degrees(x, /, signature, out=None, casting='same_kind')", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `out`, `casting`.", "question_id": 6472},
{"snippet": "numpy.degrees(x, /, signature, out=None, order='K')", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `out`, `order`.", "question_id": 6473},
{"snippet": "chararray.diagonal()", "intent": "Return specified diagonals .", "question_id": 6474},
{"snippet": "chararray.diagonal(offset=0)", "intent": "Return specified diagonals . With arguments `offset`.", "question_id": 6475},
{"snippet": "chararray.diagonal(axis1=0)", "intent": "Return specified diagonals . With arguments `axis1`.", "question_id": 6476},
{"snippet": "chararray.diagonal(axis2=1)", "intent": "Return specified diagonals . With arguments `axis2`.", "question_id": 6477},
{"snippet": "chararray.diagonal(offset=0, axis1=0)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`.", "question_id": 6478},
{"snippet": "chararray.diagonal(offset=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis2`.", "question_id": 6479},
{"snippet": "chararray.diagonal(axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `axis1`, `axis2`.", "question_id": 6480},
{"snippet": "chararray.diagonal(offset=0, axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`, `axis2`.", "question_id": 6481},
{"snippet": "ma.masked_array.mean()", "intent": "Returns the average of the array elements along given `axis` .", "question_id": 6482},
{"snippet": "ma.masked_array.mean(axis=None)", "intent": "Returns the average of the array elements along given `axis` .", "question_id": 6483},
{"snippet": "ma.masked_array.mean(dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`.", "question_id": 6484},
{"snippet": "ma.masked_array.mean(out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`.", "question_id": 6485},
{"snippet": "ma.masked_array.mean(keepdims=<no value>)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`.", "question_id": 6486},
{"snippet": "ma.masked_array.mean(axis=None, dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`.", "question_id": 6487},
{"snippet": "ma.masked_array.mean(axis=None, out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`.", "question_id": 6488},
{"snippet": "ma.masked_array.mean(axis=None, keepdims=<no value>)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`.", "question_id": 6489},
{"snippet": "ma.masked_array.mean(dtype=None, out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`, `out`.", "question_id": 6490},
{"snippet": "ma.masked_array.mean(dtype=None, keepdims=<no value>)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`, `keepdims`.", "question_id": 6491},
{"snippet": "ndarray.__pos__(/)", "intent": "+self With arguments `/`.", "question_id": 6492},
{"snippet": "ma.masked_array.fill(value)", "intent": "Fill the array with a scalar `value` .", "question_id": 6493},
{"snippet": "ma.masked_array.getfield(dtype)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements .", "question_id": 6494},
{"snippet": "ma.masked_array.getfield(dtype, offset=0)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements . The values in the view are determined by the given type and the `offset` into the current array in bytes .", "question_id": 6495},
{"snippet": "polynomial.polynomial.polygrid3d(x, y, z, c)", "intent": "Evaluate a 3-D polynomial on the Cartesian product of `x` , `y` and `z` . where the points ( a , b , `c` ) consist of all triples formed by taking a from x , b from y , and c from z .", "question_id": 6496},
{"snippet": "dtype.fields", "intent": "Dictionary of named fields defined for this data type, or None.", "question_id": 6497},
{"snippet": "ma.MaskedArray.__array__(dtype, /)", "intent": "Returns either a new reference to self if `dtype` is not given or a new array of provided data type if dtype is different from the current dtype of the array . With arguments `/`.", "question_id": 6498},
{"snippet": "ma.MaskedArray.__array__(dtype)", "intent": "Returns either a new reference to self if `dtype` is not given or a new array of provided data type if dtype is different from the current dtype of the array .", "question_id": 6499},
{"snippet": "generic.T", "intent": "Scalar attribute identical to the corresponding array attribute.", "question_id": 6500},
{"snippet": "fft.rfftfreq(n)", "intent": "Return the Discrete Fourier Transform sample frequencies ( for usage with rfft , irfft ) . Given a window length `n` and a sample spacing `d` :", "question_id": 6501},
{"snippet": "fft.rfftfreq(n, d=1.0)", "intent": "Return the Discrete Fourier Transform sample frequencies ( for usage with rfft , irfft ) . Given a window length `n` and a sample spacing `d` :", "question_id": 6502},
{"snippet": "chararray.dump(file)", "intent": "Dump a pickle of the array to the specified `file` .", "question_id": 6503},
{"snippet": "ma.masked_array.ids()", "intent": "Return the addresses of the data and mask areas .", "question_id": 6504},
{"snippet": "numpy.array_repr(arr)", "intent": "Return the string representation of an array . With arguments `arr`.", "question_id": 6505},
{"snippet": "numpy.array_repr(arr, max_line_width=None)", "intent": "Return the string representation of an array . With arguments `arr`, `max_line_width`.", "question_id": 6506},
{"snippet": "numpy.array_repr(arr, precision=None)", "intent": "Return the string representation of an array . With arguments `arr`, `precision`.", "question_id": 6507},
{"snippet": "numpy.array_repr(arr, suppress_small=None)", "intent": "Return the string representation of an array . With arguments `arr`, `suppress_small`.", "question_id": 6508},
{"snippet": "numpy.array_repr(arr, max_line_width=None, precision=None)", "intent": "Return the string representation of an array . With arguments `arr`, `max_line_width`, `precision`.", "question_id": 6509},
{"snippet": "numpy.array_repr(arr, max_line_width=None, suppress_small=None)", "intent": "Return the string representation of an array . With arguments `arr`, `max_line_width`, `suppress_small`.", "question_id": 6510},
{"snippet": "numpy.array_repr(arr, precision=None, suppress_small=None)", "intent": "Return the string representation of an array . With arguments `arr`, `precision`, `suppress_small`.", "question_id": 6511},
{"snippet": "numpy.array_repr(arr, max_line_width=None, precision=None, suppress_small=None)", "intent": "Return the string representation of an array . With arguments `arr`, `max_line_width`, `precision`, `suppress_small`.", "question_id": 6512},
{"snippet": "random.Generator.gumbel()", "intent": "Draw samples from a Gumbel distribution .", "question_id": 6513},
{"snippet": "random.Generator.gumbel(loc=0.0)", "intent": "Draw samples from a Gumbel distribution . With arguments `loc`.", "question_id": 6514},
{"snippet": "random.Generator.gumbel(scale=1.0)", "intent": "Draw samples from a Gumbel distribution . Draw samples from a Gumbel distribution with specified location and `scale` .", "question_id": 6515},
{"snippet": "random.Generator.gumbel(size=None)", "intent": "Draw samples from a Gumbel distribution . With arguments `size`.", "question_id": 6516},
{"snippet": "random.Generator.gumbel(loc=0.0, scale=1.0)", "intent": "Draw samples from a Gumbel distribution . Draw samples from a Gumbel distribution with specified location and `scale` . With arguments `loc`.", "question_id": 6517},
{"snippet": "random.Generator.gumbel(loc=0.0, size=None)", "intent": "Draw samples from a Gumbel distribution . With arguments `loc`, `size`.", "question_id": 6518},
{"snippet": "random.Generator.gumbel(scale=1.0, size=None)", "intent": "Draw samples from a Gumbel distribution . Draw samples from a Gumbel distribution with specified location and `scale` . With arguments `size`.", "question_id": 6519},
{"snippet": "random.Generator.gumbel(loc=0.0, scale=1.0, size=None)", "intent": "Draw samples from a Gumbel distribution . Draw samples from a Gumbel distribution with specified location and `scale` . With arguments `loc`, `size`.", "question_id": 6520},
{"snippet": "polynomial.hermite.hermmul(c1, c2)", "intent": "Multiply one Hermite series by another . Returns the product of two Hermite series `c1` * `c2` .", "question_id": 6521},
{"snippet": "ndarray.__ifloordiv__(value, /)", "intent": "Return self//=value . With arguments `value`, `/`.", "question_id": 6522},
{"snippet": "ndarray.flat", "intent": "A 1-D iterator over the array.", "question_id": 6523},
{"snippet": "chararray.clip(**kwargs)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 6524},
{"snippet": "chararray.clip(**kwargs, min=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 6525},
{"snippet": "chararray.clip(**kwargs, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 6526},
{"snippet": "chararray.clip(**kwargs, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 6527},
{"snippet": "chararray.clip(**kwargs, min=None, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 6528},
{"snippet": "chararray.clip(**kwargs, min=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 6529},
{"snippet": "chararray.clip(**kwargs, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 6530},
{"snippet": "chararray.clip(**kwargs, min=None, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 6531},
{"snippet": "char.center(a, width)", "intent": "Return `a` copy of a with its elements centered in a string of length `width` .", "question_id": 6532},
{"snippet": "char.center(a, width, fillchar=' ')", "intent": "Return `a` copy of a with its elements centered in a string of length `width` . With arguments `fillchar`.", "question_id": 6533},
{"snippet": "polynomial.polyutils.trimcoef(c)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . With arguments `c`.", "question_id": 6534},
{"snippet": "polynomial.polyutils.trimcoef(c, tol=0)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . \u201c Small \u201d means \u201c small in absolute value \u201d and is controlled by the parameter `tol` ; \u201c trailing \u201d means highest order coefficient ( s ) , e.g. , in [ 0 , 1 , 1 , 0 , 0 ] ( which represents 0 + x + x * * 2 + 0 * x * * 3 + 0 * x * * 4 ) both the 3-rd and 4-th order coefficients would be \u201c trimmed . \u201d With arguments `c`.", "question_id": 6535},
{"snippet": "chararray.transpose(*axes)", "intent": "Returns a view of the array with axes transposed . With arguments `*axes`.", "question_id": 6536},
{"snippet": "polynomial.chebyshev.Chebyshev.integ()", "intent": "Integrate .", "question_id": 6537},
{"snippet": "polynomial.chebyshev.Chebyshev.integ(m=1)", "intent": "Integrate . With arguments `m`.", "question_id": 6538},
{"snippet": "polynomial.chebyshev.Chebyshev.integ(k=)", "intent": "Integrate . With arguments `k`.", "question_id": 6539},
{"snippet": "polynomial.chebyshev.Chebyshev.integ(lbnd=None)", "intent": "Integrate . With arguments `lbnd`.", "question_id": 6540},
{"snippet": "polynomial.chebyshev.Chebyshev.integ(m=1, k=)", "intent": "Integrate . With arguments `m`, `k`.", "question_id": 6541},
{"snippet": "polynomial.chebyshev.Chebyshev.integ(m=1, lbnd=None)", "intent": "Integrate . With arguments `m`, `lbnd`.", "question_id": 6542},
{"snippet": "polynomial.chebyshev.Chebyshev.integ(k=, lbnd=None)", "intent": "Integrate . With arguments `k`, `lbnd`.", "question_id": 6543},
{"snippet": "polynomial.chebyshev.Chebyshev.integ(m=1, k=, lbnd=None)", "intent": "Integrate . With arguments `m`, `k`, `lbnd`.", "question_id": 6544},
{"snippet": "polynomial.chebyshev.Chebyshev.integ()", "intent": "Integrate .", "question_id": 6545},
{"snippet": "polynomial.chebyshev.Chebyshev.integ(m=1)", "intent": "Integrate . With arguments `m`.", "question_id": 6546},
{"snippet": "polynomial.chebyshev.Chebyshev.integ(k=)", "intent": "Integrate . With arguments `k`.", "question_id": 6547},
{"snippet": "polynomial.chebyshev.Chebyshev.integ(lbnd=None)", "intent": "Integrate . With arguments `lbnd`.", "question_id": 6548},
{"snippet": "polynomial.chebyshev.Chebyshev.integ(m=1, k=)", "intent": "Integrate . With arguments `m`, `k`.", "question_id": 6549},
{"snippet": "polynomial.chebyshev.Chebyshev.integ(m=1, lbnd=None)", "intent": "Integrate . With arguments `m`, `lbnd`.", "question_id": 6550},
{"snippet": "polynomial.chebyshev.Chebyshev.integ(k=, lbnd=None)", "intent": "Integrate . With arguments `k`, `lbnd`.", "question_id": 6551},
{"snippet": "polynomial.chebyshev.Chebyshev.integ(m=1, k=, lbnd=None)", "intent": "Integrate . With arguments `m`, `k`, `lbnd`.", "question_id": 6552},
{"snippet": "char.chararray.min()", "intent": "Return the minimum along a given `axis` .", "question_id": 6553},
{"snippet": "char.chararray.min(axis=None)", "intent": "Return the minimum along a given `axis` .", "question_id": 6554},
{"snippet": "char.chararray.min(out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`.", "question_id": 6555},
{"snippet": "char.chararray.min(keepdims=False)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`.", "question_id": 6556},
{"snippet": "char.chararray.min(initial=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `initial`.", "question_id": 6557},
{"snippet": "char.chararray.min(where=True)", "intent": "Return the minimum along a given `axis` . With arguments `where`.", "question_id": 6558},
{"snippet": "char.chararray.min(axis=None, out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`.", "question_id": 6559},
{"snippet": "char.chararray.min(axis=None, keepdims=False)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`.", "question_id": 6560},
{"snippet": "char.chararray.min(axis=None, initial=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `initial`.", "question_id": 6561},
{"snippet": "char.chararray.min(axis=None, where=True)", "intent": "Return the minimum along a given `axis` . With arguments `where`.", "question_id": 6562},
{"snippet": "ndindex.ndincr()", "intent": "Increment the multi-dimensional index by one .", "question_id": 6563},
{"snippet": "memmap.base", "intent": "Base object if memory is from some other object.", "question_id": 6564},
{"snippet": "testing.Tester.test()", "intent": "Run tests for module using nose .", "question_id": 6565},
{"snippet": "testing.Tester.test(label='fast')", "intent": "Run tests for module using nose . With arguments `label`.", "question_id": 6566},
{"snippet": "testing.Tester.test(verbose=1)", "intent": "Run tests for module using nose . With arguments `verbose`.", "question_id": 6567},
{"snippet": "testing.Tester.test(extra_argv=None)", "intent": "Run tests for module using nose . With arguments `extra_argv`.", "question_id": 6568},
{"snippet": "testing.Tester.test(doctests=False)", "intent": "Run tests for module using nose . With arguments `doctests`.", "question_id": 6569},
{"snippet": "testing.Tester.test(coverage=False)", "intent": "Run tests for module using nose . With arguments `coverage`.", "question_id": 6570},
{"snippet": "testing.Tester.test(raise_warnings=None)", "intent": "Run tests for module using nose . With arguments `raise_warnings`.", "question_id": 6571},
{"snippet": "testing.Tester.test(timer=False)", "intent": "Run tests for module using nose . With arguments `timer`.", "question_id": 6572},
{"snippet": "testing.Tester.test(label='fast', verbose=1)", "intent": "Run tests for module using nose . With arguments `label`, `verbose`.", "question_id": 6573},
{"snippet": "testing.Tester.test(label='fast', extra_argv=None)", "intent": "Run tests for module using nose . With arguments `label`, `extra_argv`.", "question_id": 6574},
{"snippet": "ma.indices(dimensions)", "intent": "Return an array representing the indices of a grid . The output shape in the dense case is obtained by prepending the number of `dimensions` in front of the tuple of dimensions , i.e .", "question_id": 6575},
{"snippet": "ma.indices(dimensions, dtype=<class 'int'>)", "intent": "Return an array representing the indices of a grid . The output shape in the dense case is obtained by prepending the number of `dimensions` in front of the tuple of dimensions , i.e . With arguments `dtype`.", "question_id": 6576},
{"snippet": "ma.indices(dimensions, sparse=False)", "intent": "Return an array representing the indices of a grid . The output shape in the dense case is obtained by prepending the number of `dimensions` in front of the tuple of dimensions , i.e . If `sparse` is set to true , the grid will be returned in a sparse representation .", "question_id": 6577},
{"snippet": "ma.indices(dimensions, dtype=<class 'int'>, sparse=False)", "intent": "Return an array representing the indices of a grid . The output shape in the dense case is obtained by prepending the number of `dimensions` in front of the tuple of dimensions , i.e . If `sparse` is set to true , the grid will be returned in a sparse representation . With arguments `dtype`.", "question_id": 6578},
{"snippet": "recarray.nonzero()", "intent": "Return the indices of the elements that are non-zero .", "question_id": 6579},
{"snippet": "numpy.ma.MaskType", "intent": "alias of numpy.bool_", "question_id": 6580},
{"snippet": "ma.MaskedArray.__rand__(value, /)", "intent": "Return `value` & self . With arguments `/`.", "question_id": 6581},
{"snippet": "ma.masked_array.max()", "intent": "Return the maximum along a given `axis` .", "question_id": 6582},
{"snippet": "ma.masked_array.max(axis=None)", "intent": "Return the maximum along a given `axis` .", "question_id": 6583},
{"snippet": "ma.masked_array.max(out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`.", "question_id": 6584},
{"snippet": "ma.masked_array.max(fill_value=None)", "intent": "Return the maximum along a given `axis` . With arguments `fill_value`.", "question_id": 6585},
{"snippet": "ma.masked_array.max(keepdims=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`.", "question_id": 6586},
{"snippet": "ma.masked_array.max(axis=None, out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`.", "question_id": 6587},
{"snippet": "ma.masked_array.max(axis=None, fill_value=None)", "intent": "Return the maximum along a given `axis` . With arguments `fill_value`.", "question_id": 6588},
{"snippet": "ma.masked_array.max(axis=None, keepdims=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`.", "question_id": 6589},
{"snippet": "ma.masked_array.max(out=None, fill_value=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`, `fill_value`.", "question_id": 6590},
{"snippet": "ma.masked_array.max(out=None, keepdims=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `out`, `keepdims`.", "question_id": 6591},
{"snippet": "ma.MaskedArray.choose(choices)", "intent": "Use an index array to construct a new array from a set of `choices` .", "question_id": 6592},
{"snippet": "ma.MaskedArray.choose(choices, out=None)", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`.", "question_id": 6593},
{"snippet": "ma.MaskedArray.choose(choices, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `mode`.", "question_id": 6594},
{"snippet": "ma.MaskedArray.choose(choices, out=None, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`, `mode`.", "question_id": 6595},
{"snippet": "recarray.ravel(order)", "intent": "Return a flattened array . With arguments `order`.", "question_id": 6596},
{"snippet": "recarray.ravel()", "intent": "Return a flattened array .", "question_id": 6597},
{"snippet": "memmap.clip(**kwargs)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 6598},
{"snippet": "memmap.clip(**kwargs, min=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 6599},
{"snippet": "memmap.clip(**kwargs, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 6600},
{"snippet": "memmap.clip(**kwargs, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 6601},
{"snippet": "memmap.clip(**kwargs, min=None, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 6602},
{"snippet": "memmap.clip(**kwargs, min=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 6603},
{"snippet": "memmap.clip(**kwargs, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 6604},
{"snippet": "memmap.clip(**kwargs, min=None, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 6605},
{"snippet": "ma.MaskedArray.__repr__()", "intent": "Literal string representation .", "question_id": 6606},
{"snippet": "ma.MaskType.copy()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 6607},
{"snippet": "polynomial.hermite.hermgauss(deg)", "intent": "Gauss-Hermite quadrature . These sample points and weights will correctly integrate polynomials of degree \\ ( 2 * `deg` - 1\\ ) or less over the interval \\ ( [ -\\inf , \\inf ] \\ ) with the weight function \\ ( f ( x ) = \\exp ( -x^2 ) \\ ) .", "question_id": 6608},
{"snippet": "recarray.reshape(shape)", "intent": "Returns an array containing the same data with a new `shape` .", "question_id": 6609},
{"snippet": "recarray.reshape(shape, order='C')", "intent": "Returns an array containing the same data with a new `shape` . With arguments `order`.", "question_id": 6610},
{"snippet": "random.gamma(shape)", "intent": "Draw samples from a Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and `scale` ( sometimes designated \u201c theta \u201d ) , where both parameters are > 0 .", "question_id": 6611},
{"snippet": "random.gamma(shape, scale=1.0)", "intent": "Draw samples from a Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and `scale` ( sometimes designated \u201c theta \u201d ) , where both parameters are > 0 .", "question_id": 6612},
{"snippet": "random.gamma(shape, size=None)", "intent": "Draw samples from a Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and `scale` ( sometimes designated \u201c theta \u201d ) , where both parameters are > 0 . With arguments `size`.", "question_id": 6613},
{"snippet": "random.gamma(shape, scale=1.0, size=None)", "intent": "Draw samples from a Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and `scale` ( sometimes designated \u201c theta \u201d ) , where both parameters are > 0 . With arguments `size`.", "question_id": 6614},
{"snippet": "numpy.ptp(a)", "intent": "Range of values ( maximum - minimum ) along an `axis` . This example shows that `a` negative value can be returned when the input is an array of signed integers .", "question_id": 6615},
{"snippet": "numpy.ptp(a, axis=None)", "intent": "Range of values ( maximum - minimum ) along an `axis` . This example shows that `a` negative value can be returned when the input is an array of signed integers .", "question_id": 6616},
{"snippet": "numpy.ptp(a, out=None)", "intent": "Range of values ( maximum - minimum ) along an `axis` . This example shows that `a` negative value can be returned when the input is an array of signed integers . With arguments `out`.", "question_id": 6617},
{"snippet": "numpy.ptp(a, keepdims=<no value>)", "intent": "Range of values ( maximum - minimum ) along an `axis` . This example shows that `a` negative value can be returned when the input is an array of signed integers . With arguments `keepdims`.", "question_id": 6618},
{"snippet": "numpy.ptp(a, axis=None, out=None)", "intent": "Range of values ( maximum - minimum ) along an `axis` . This example shows that `a` negative value can be returned when the input is an array of signed integers . With arguments `out`.", "question_id": 6619},
{"snippet": "numpy.ptp(a, axis=None, keepdims=<no value>)", "intent": "Range of values ( maximum - minimum ) along an `axis` . This example shows that `a` negative value can be returned when the input is an array of signed integers . With arguments `keepdims`.", "question_id": 6620},
{"snippet": "numpy.ptp(a, out=None, keepdims=<no value>)", "intent": "Range of values ( maximum - minimum ) along an `axis` . This example shows that `a` negative value can be returned when the input is an array of signed integers . With arguments `out`, `keepdims`.", "question_id": 6621},
{"snippet": "numpy.ptp(a, axis=None, out=None, keepdims=<no value>)", "intent": "Range of values ( maximum - minimum ) along an `axis` . This example shows that `a` negative value can be returned when the input is an array of signed integers . With arguments `out`, `keepdims`.", "question_id": 6622},
{"snippet": "dtype.descr", "intent": "__array_interface__ description of the data-type.", "question_id": 6623},
{"snippet": "chararray.isnumeric()", "intent": "For each element in self , return True if there are only numeric characters in the element .", "question_id": 6624},
{"snippet": "generic.__array_interface__", "intent": "Array protocol: Python side", "question_id": 6625},
{"snippet": "ma.masked_array.setfield(val, dtype)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field .", "question_id": 6626},
{"snippet": "ma.masked_array.setfield(val, dtype, offset=0)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field .", "question_id": 6627},
{"snippet": "polynomial.legendre.legmul(c1, c2)", "intent": "Multiply one Legendre series by another . Returns the product of two Legendre series `c1` * `c2` .", "question_id": 6628},
{"snippet": "numpy.nanstd(a)", "intent": "Compute the standard deviation along the specified `axis` , while ignoring NaNs . Returns the standard deviation , `a` measure of the spread of a distribution , of the non-NaN array elements .", "question_id": 6629},
{"snippet": "numpy.nanstd(a, axis=None)", "intent": "Compute the standard deviation along the specified `axis` , while ignoring NaNs . Returns the standard deviation , `a` measure of the spread of a distribution , of the non-NaN array elements .", "question_id": 6630},
{"snippet": "numpy.nanstd(a, dtype=None)", "intent": "Compute the standard deviation along the specified `axis` , while ignoring NaNs . Returns the standard deviation , `a` measure of the spread of a distribution , of the non-NaN array elements . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue .", "question_id": 6631},
{"snippet": "numpy.nanstd(a, out=None)", "intent": "Compute the standard deviation along the specified `axis` , while ignoring NaNs . Returns the standard deviation , `a` measure of the spread of a distribution , of the non-NaN array elements . With arguments `out`.", "question_id": 6632},
{"snippet": "numpy.nanstd(a, ddof=0)", "intent": "Compute the standard deviation along the specified `axis` , while ignoring NaNs . Returns the standard deviation , `a` measure of the spread of a distribution , of the non-NaN array elements . If , however , `ddof` is specified , the divisor N - ddof is used instead .", "question_id": 6633},
{"snippet": "numpy.nanstd(a, keepdims=<no value>)", "intent": "Compute the standard deviation along the specified `axis` , while ignoring NaNs . Returns the standard deviation , `a` measure of the spread of a distribution , of the non-NaN array elements . With arguments `keepdims`.", "question_id": 6634},
{"snippet": "numpy.nanstd(a, axis=None, dtype=None)", "intent": "Compute the standard deviation along the specified `axis` , while ignoring NaNs . Returns the standard deviation , `a` measure of the spread of a distribution , of the non-NaN array elements . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue .", "question_id": 6635},
{"snippet": "numpy.nanstd(a, axis=None, out=None)", "intent": "Compute the standard deviation along the specified `axis` , while ignoring NaNs . Returns the standard deviation , `a` measure of the spread of a distribution , of the non-NaN array elements . With arguments `out`.", "question_id": 6636},
{"snippet": "numpy.nanstd(a, axis=None, ddof=0)", "intent": "Compute the standard deviation along the specified `axis` , while ignoring NaNs . Returns the standard deviation , `a` measure of the spread of a distribution , of the non-NaN array elements . If , however , `ddof` is specified , the divisor N - ddof is used instead .", "question_id": 6637},
{"snippet": "numpy.nanstd(a, axis=None, keepdims=<no value>)", "intent": "Compute the standard deviation along the specified `axis` , while ignoring NaNs . Returns the standard deviation , `a` measure of the spread of a distribution , of the non-NaN array elements . With arguments `keepdims`.", "question_id": 6638},
{"snippet": "polynomial.chebyshev.Chebyshev.__call__(arg)", "intent": "Call self as a function . With arguments `arg`.", "question_id": 6639},
{"snippet": "dtype.shape", "intent": "Shape tuple of the sub-array if this data type describes a sub-array, and () otherwise.", "question_id": 6640},
{"snippet": "linalg.cholesky(a)", "intent": "Cholesky decomposition . Return the Cholesky decomposition , L * L.H , of the square matrix `a` , where L is lower-triangular and .H is the conjugate transpose operator ( which is the ordinary transpose if a is real-valued ) .", "question_id": 6641},
{"snippet": "ma.masked_greater(x, value)", "intent": "Mask an array where greater than a given `value` . This function is a shortcut to masked_where , with condition = ( `x` > value ) .", "question_id": 6642},
{"snippet": "ma.masked_greater(x, value, copy=True)", "intent": "Mask an array where greater than a given `value` . This function is a shortcut to masked_where , with condition = ( `x` > value ) . With arguments `copy`.", "question_id": 6643},
{"snippet": "numpy.asscalar(a)", "intent": "Convert an array of size 1 to its scalar equivalent . With arguments `a`.", "question_id": 6644},
{"snippet": "chararray.isspace()", "intent": "Returns true for each element if there are only whitespace characters in the string and there is at least one character , false otherwise .", "question_id": 6645},
{"snippet": "distutils.system_info.get_standard_file(fname)", "intent": "Returns a list of files named \u2018 `fname` \u2019 from 1 ) System-wide directory ( directory-location of this module ) 2 ) Users HOME directory ( os.environ [ \u2018 HOME \u2019 ] ) 3 ) Local directory", "question_id": 6646},
{"snippet": "numpy.maximum_sctype(t)", "intent": "Return the scalar type of highest precision of the same kind as the input . With arguments `t`.", "question_id": 6647},
{"snippet": "ma.where(condition)", "intent": "Return a masked array with elements from `x` or `y` , depending on `condition` .", "question_id": 6648},
{"snippet": "ma.where(condition, x=<no value>)", "intent": "Return a masked array with elements from `x` or `y` , depending on `condition` .", "question_id": 6649},
{"snippet": "ma.where(condition, y=<no value>)", "intent": "Return a masked array with elements from `x` or `y` , depending on `condition` .", "question_id": 6650},
{"snippet": "ma.where(condition, x=<no value>, y=<no value>)", "intent": "Return a masked array with elements from `x` or `y` , depending on `condition` .", "question_id": 6651},
{"snippet": "polynomial.laguerre.Laguerre.integ()", "intent": "Integrate .", "question_id": 6652},
{"snippet": "polynomial.laguerre.Laguerre.integ(m=1)", "intent": "Integrate . With arguments `m`.", "question_id": 6653},
{"snippet": "polynomial.laguerre.Laguerre.integ(k=)", "intent": "Integrate . With arguments `k`.", "question_id": 6654},
{"snippet": "polynomial.laguerre.Laguerre.integ(lbnd=None)", "intent": "Integrate . With arguments `lbnd`.", "question_id": 6655},
{"snippet": "polynomial.laguerre.Laguerre.integ(m=1, k=)", "intent": "Integrate . With arguments `m`, `k`.", "question_id": 6656},
{"snippet": "polynomial.laguerre.Laguerre.integ(m=1, lbnd=None)", "intent": "Integrate . With arguments `m`, `lbnd`.", "question_id": 6657},
{"snippet": "polynomial.laguerre.Laguerre.integ(k=, lbnd=None)", "intent": "Integrate . With arguments `k`, `lbnd`.", "question_id": 6658},
{"snippet": "polynomial.laguerre.Laguerre.integ(m=1, k=, lbnd=None)", "intent": "Integrate . With arguments `m`, `k`, `lbnd`.", "question_id": 6659},
{"snippet": "polynomial.laguerre.Laguerre.integ()", "intent": "Integrate .", "question_id": 6660},
{"snippet": "polynomial.laguerre.Laguerre.integ(m=1)", "intent": "Integrate . With arguments `m`.", "question_id": 6661},
{"snippet": "polynomial.laguerre.Laguerre.integ(k=)", "intent": "Integrate . With arguments `k`.", "question_id": 6662},
{"snippet": "polynomial.laguerre.Laguerre.integ(lbnd=None)", "intent": "Integrate . With arguments `lbnd`.", "question_id": 6663},
{"snippet": "polynomial.laguerre.Laguerre.integ(m=1, k=)", "intent": "Integrate . With arguments `m`, `k`.", "question_id": 6664},
{"snippet": "polynomial.laguerre.Laguerre.integ(m=1, lbnd=None)", "intent": "Integrate . With arguments `m`, `lbnd`.", "question_id": 6665},
{"snippet": "polynomial.laguerre.Laguerre.integ(k=, lbnd=None)", "intent": "Integrate . With arguments `k`, `lbnd`.", "question_id": 6666},
{"snippet": "polynomial.laguerre.Laguerre.integ(m=1, k=, lbnd=None)", "intent": "Integrate . With arguments `m`, `k`, `lbnd`.", "question_id": 6667},
{"snippet": "ndarray.searchsorted(v)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order .", "question_id": 6668},
{"snippet": "ndarray.searchsorted(v, side='left')", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`.", "question_id": 6669},
{"snippet": "ndarray.searchsorted(v, sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `sorter`.", "question_id": 6670},
{"snippet": "ndarray.searchsorted(v, side='left', sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`, `sorter`.", "question_id": 6671},
{"snippet": "polynomial.chebyshev.Chebyshev.fromroots(roots)", "intent": "Return series instance that has the specified `roots` .", "question_id": 6672},
{"snippet": "polynomial.chebyshev.Chebyshev.fromroots(roots, domain=)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`.", "question_id": 6673},
{"snippet": "polynomial.chebyshev.Chebyshev.fromroots(roots, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `window`.", "question_id": 6674},
{"snippet": "polynomial.chebyshev.Chebyshev.fromroots(roots, domain=, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`, `window`.", "question_id": 6675},
{"snippet": "polynomial.chebyshev.Chebyshev.fromroots()", "intent": "Return series instance that has the specified `roots` .", "question_id": 6676},
{"snippet": "polynomial.chebyshev.Chebyshev.fromroots(domain=)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`.", "question_id": 6677},
{"snippet": "polynomial.chebyshev.Chebyshev.fromroots(window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `window`.", "question_id": 6678},
{"snippet": "polynomial.chebyshev.Chebyshev.fromroots(domain=, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`, `window`.", "question_id": 6679},
{"snippet": "distutils.exec_command.forward_bytes_to_stdout(val)", "intent": "Forward bytes from a subprocess call to the console , without attempting to decode them . With arguments `val`.", "question_id": 6680},
{"snippet": "random.beta(a, b)", "intent": "Draw samples from `a` Beta distribution . With arguments `b`.", "question_id": 6681},
{"snippet": "random.beta(a, b, size=None)", "intent": "Draw samples from `a` Beta distribution . With arguments `b`, `size`.", "question_id": 6682},
{"snippet": "random.RandomState.zipf(a)", "intent": "Draw samples from `a` Zipf distribution .", "question_id": 6683},
{"snippet": "random.RandomState.zipf(a, size=None)", "intent": "Draw samples from `a` Zipf distribution . With arguments `size`.", "question_id": 6684},
{"snippet": "ma.empty(shape)", "intent": "Return a new array of given `shape` and type , without initializing entries .", "question_id": 6685},
{"snippet": "ma.empty(shape, dtype=float)", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `dtype`.", "question_id": 6686},
{"snippet": "ma.empty(shape, order='C')", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `order`.", "question_id": 6687},
{"snippet": "ma.empty(shape, like=None)", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `like`.", "question_id": 6688},
{"snippet": "ma.empty(shape, dtype=float, order='C')", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `dtype`, `order`.", "question_id": 6689},
{"snippet": "ma.empty(shape, dtype=float, like=None)", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `dtype`, `like`.", "question_id": 6690},
{"snippet": "ma.empty(shape, order='C', like=None)", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `order`, `like`.", "question_id": 6691},
{"snippet": "ma.empty(shape, dtype=float, order='C', like=None)", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `dtype`, `order`, `like`.", "question_id": 6692},
{"snippet": "ma.masked_array.flatten()", "intent": "Return a copy of the array collapsed into one dimension .", "question_id": 6693},
{"snippet": "ma.masked_array.flatten(order='C')", "intent": "Return a copy of the array collapsed into one dimension . With arguments `order`.", "question_id": 6694},
{"snippet": "numpy.matrix(data)", "intent": "Returns a matrix from an array-like object , or from a string of `data` .", "question_id": 6695},
{"snippet": "numpy.matrix(data, dtype=None)", "intent": "Returns a matrix from an array-like object , or from a string of `data` . With arguments `dtype`.", "question_id": 6696},
{"snippet": "numpy.matrix(data, copy=True)", "intent": "Returns a matrix from an array-like object , or from a string of `data` . With arguments `copy`.", "question_id": 6697},
{"snippet": "numpy.matrix(data, dtype=None, copy=True)", "intent": "Returns a matrix from an array-like object , or from a string of `data` . With arguments `dtype`, `copy`.", "question_id": 6698},
{"snippet": "numpy.ceil(x, /, signature, extobj)", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `extobj`.", "question_id": 6699},
{"snippet": "numpy.ceil(x, /, signature, extobj, out=None)", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 6700},
{"snippet": "numpy.ceil(x, /, signature, extobj, where=True)", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 6701},
{"snippet": "numpy.ceil(x, /, signature, extobj, casting='same_kind')", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 6702},
{"snippet": "numpy.ceil(x, /, signature, extobj, order='K')", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 6703},
{"snippet": "numpy.ceil(x, /, signature, extobj, dtype=None)", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 6704},
{"snippet": "numpy.ceil(x, /, signature, extobj, subok=True)", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 6705},
{"snippet": "numpy.ceil(x, /, signature, extobj, out=None, where=True)", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 6706},
{"snippet": "numpy.ceil(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 6707},
{"snippet": "numpy.ceil(x, /, signature, extobj, out=None, order='K')", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 6708},
{"snippet": "numpy.ceil(x, /, signature)", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`.", "question_id": 6709},
{"snippet": "numpy.ceil(x, /, signature, out=None)", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `out`.", "question_id": 6710},
{"snippet": "numpy.ceil(x, /, signature, where=True)", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `where`.", "question_id": 6711},
{"snippet": "numpy.ceil(x, /, signature, casting='same_kind')", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `casting`.", "question_id": 6712},
{"snippet": "numpy.ceil(x, /, signature, order='K')", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `order`.", "question_id": 6713},
{"snippet": "numpy.ceil(x, /, signature, dtype=None)", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `dtype`.", "question_id": 6714},
{"snippet": "numpy.ceil(x, /, signature, subok=True)", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `subok`.", "question_id": 6715},
{"snippet": "numpy.ceil(x, /, signature, out=None, where=True)", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `out`, `where`.", "question_id": 6716},
{"snippet": "numpy.ceil(x, /, signature, out=None, casting='same_kind')", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 6717},
{"snippet": "numpy.ceil(x, /, signature, out=None, order='K')", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `out`, `order`.", "question_id": 6718},
{"snippet": "random.RandomState.multivariate_normal(mean, cov)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`.", "question_id": 6719},
{"snippet": "random.RandomState.multivariate_normal(mean, cov, size=None)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `size`.", "question_id": 6720},
{"snippet": "random.RandomState.multivariate_normal(mean, cov, check_valid='warn')", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `check_valid`.", "question_id": 6721},
{"snippet": "random.RandomState.multivariate_normal(mean, cov, tol=1e-8)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `tol`.", "question_id": 6722},
{"snippet": "random.RandomState.multivariate_normal(mean, cov, size=None, check_valid='warn')", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `size`, `check_valid`.", "question_id": 6723},
{"snippet": "random.RandomState.multivariate_normal(mean, cov, size=None, tol=1e-8)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `size`, `tol`.", "question_id": 6724},
{"snippet": "random.RandomState.multivariate_normal(mean, cov, check_valid='warn', tol=1e-8)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `check_valid`, `tol`.", "question_id": 6725},
{"snippet": "random.RandomState.multivariate_normal(mean, cov, size=None, check_valid='warn', tol=1e-8)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `size`, `check_valid`, `tol`.", "question_id": 6726},
{"snippet": "char.title(a)", "intent": "Return element-wise title cased version of string or unicode . With arguments `a`.", "question_id": 6727},
{"snippet": "numpy.fliplr(m)", "intent": "Reverse the order of elements along axis 1 ( left/right ) . Equivalent to `m` [ : , : :-1 ] or np.flip ( m , axis=1 ) .", "question_id": 6728},
{"snippet": "numpy.fmin(x1, x2, /, signature, extobj)", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`.", "question_id": 6729},
{"snippet": "numpy.fmin(x1, x2, /, signature, extobj, out=None)", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 6730},
{"snippet": "numpy.fmin(x1, x2, /, signature, extobj, where=True)", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 6731},
{"snippet": "numpy.fmin(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 6732},
{"snippet": "numpy.fmin(x1, x2, /, signature, extobj, order='K')", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 6733},
{"snippet": "numpy.fmin(x1, x2, /, signature, extobj, dtype=None)", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 6734},
{"snippet": "numpy.fmin(x1, x2, /, signature, extobj, subok=True)", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 6735},
{"snippet": "numpy.fmin(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 6736},
{"snippet": "numpy.fmin(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 6737},
{"snippet": "numpy.fmin(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 6738},
{"snippet": "numpy.fmin(x1, x2, /, signature)", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`.", "question_id": 6739},
{"snippet": "numpy.fmin(x1, x2, /, signature, out=None)", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`.", "question_id": 6740},
{"snippet": "numpy.fmin(x1, x2, /, signature, where=True)", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `where`.", "question_id": 6741},
{"snippet": "numpy.fmin(x1, x2, /, signature, casting='same_kind')", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `casting`.", "question_id": 6742},
{"snippet": "numpy.fmin(x1, x2, /, signature, order='K')", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `order`.", "question_id": 6743},
{"snippet": "numpy.fmin(x1, x2, /, signature, dtype=None)", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `dtype`.", "question_id": 6744},
{"snippet": "numpy.fmin(x1, x2, /, signature, subok=True)", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `subok`.", "question_id": 6745},
{"snippet": "numpy.fmin(x1, x2, /, signature, out=None, where=True)", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`, `where`.", "question_id": 6746},
{"snippet": "numpy.fmin(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 6747},
{"snippet": "numpy.fmin(x1, x2, /, signature, out=None, order='K')", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`, `order`.", "question_id": 6748},
{"snippet": "chararray.T", "intent": "The transposed array.", "question_id": 6749},
{"snippet": "ma.MaskedArray.__radd__(other)", "intent": "Add `other` to self , and return a new masked array .", "question_id": 6750},
{"snippet": "polynomial.laguerre.lagcompanion(c)", "intent": "Return the companion matrix of `c` .", "question_id": 6751},
{"snippet": "ndarray.nbytes", "intent": "Total bytes consumed by the elements of the array.", "question_id": 6752},
{"snippet": "polynomial.hermite_e.herme2poly(c)", "intent": "Convert a Hermite series to a polynomial . With arguments `c`.", "question_id": 6753},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.try_dispatch(sources, **kwargs)", "intent": "Compile one or more dispatch-able `sources` and generates object files , also generates abstract C config headers and macros that used later for the final runtime dispatching process . With arguments `**kwargs`.", "question_id": 6754},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.try_dispatch(sources, **kwargs, src_dir=None)", "intent": "Compile one or more dispatch-able `sources` and generates object files , also generates abstract C config headers and macros that used later for the final runtime dispatching process . With arguments `**kwargs`, `src_dir`.", "question_id": 6755},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.try_dispatch(sources, **kwargs, ccompiler=None)", "intent": "Compile one or more dispatch-able `sources` and generates object files , also generates abstract C config headers and macros that used later for the final runtime dispatching process . With arguments `**kwargs`, `ccompiler`.", "question_id": 6756},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.try_dispatch(sources, **kwargs, src_dir=None, ccompiler=None)", "intent": "Compile one or more dispatch-able `sources` and generates object files , also generates abstract C config headers and macros that used later for the final runtime dispatching process . With arguments `**kwargs`, `src_dir`, `ccompiler`.", "question_id": 6757},
{"snippet": "char.chararray.resize(new_shape)", "intent": "Change shape and size of array in-place . With arguments `new_shape`.", "question_id": 6758},
{"snippet": "char.chararray.resize(new_shape, refcheck=True)", "intent": "Change shape and size of array in-place . However , reference counts can increase in other ways so if you are sure that you have not shared the memory for this array with another Python object , then you may safely set `refcheck` to False . With arguments `new_shape`.", "question_id": 6759},
{"snippet": "polynomial.chebyshev.Chebyshev.linspace()", "intent": "Return x , y values at equally spaced points in `domain` .", "question_id": 6760},
{"snippet": "polynomial.chebyshev.Chebyshev.linspace(n=100)", "intent": "Return x , y values at equally spaced points in `domain` . Returns the x , y values at `n` linearly spaced points across the domain .", "question_id": 6761},
{"snippet": "polynomial.chebyshev.Chebyshev.linspace(domain=None)", "intent": "Return x , y values at equally spaced points in `domain` .", "question_id": 6762},
{"snippet": "polynomial.chebyshev.Chebyshev.linspace(n=100, domain=None)", "intent": "Return x , y values at equally spaced points in `domain` . Returns the x , y values at `n` linearly spaced points across the domain .", "question_id": 6763},
{"snippet": "random.uniform()", "intent": "Draw samples from a uniform distribution .", "question_id": 6764},
{"snippet": "random.uniform(low=0.0)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) .", "question_id": 6765},
{"snippet": "random.uniform(high=1.0)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) .", "question_id": 6766},
{"snippet": "random.uniform(size=None)", "intent": "Draw samples from a uniform distribution . With arguments `size`.", "question_id": 6767},
{"snippet": "random.uniform(low=0.0, high=1.0)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) .", "question_id": 6768},
{"snippet": "random.uniform(low=0.0, size=None)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . With arguments `size`.", "question_id": 6769},
{"snippet": "random.uniform(high=1.0, size=None)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . With arguments `size`.", "question_id": 6770},
{"snippet": "random.uniform(low=0.0, high=1.0, size=None)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . With arguments `size`.", "question_id": 6771},
{"snippet": "polynomial.hermite_e.hermeval2d(x, y, c)", "intent": "Evaluate a 2-D HermiteE series at points ( `x` , `y` ) . In either case , either x and y or their elements must support multiplication and addition both with themselves and with the elements of `c` .", "question_id": 6772},
{"snippet": "record.dtype", "intent": "dtype object", "question_id": 6773},
{"snippet": "polynomial.laguerre.lagvander3d(x, y, z, deg)", "intent": "Pseudo-Vandermonde matrix of given degrees . Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points ( `x` , `y` , `z` ) .", "question_id": 6774},
{"snippet": "numpy.block(arrays)", "intent": "Assemble an nd-array from nested lists of blocks . np.block ( [ [ a , b ] , [ c , d ] ] ) is not restricted to `arrays` of the form :", "question_id": 6775},
{"snippet": "recarray.all()", "intent": "Returns True if all elements evaluate to True .", "question_id": 6776},
{"snippet": "recarray.all(axis=None)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`.", "question_id": 6777},
{"snippet": "recarray.all(out=None)", "intent": "Returns True if all elements evaluate to True . With arguments `out`.", "question_id": 6778},
{"snippet": "recarray.all(keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `keepdims`.", "question_id": 6779},
{"snippet": "recarray.all(where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `where`.", "question_id": 6780},
{"snippet": "recarray.all(axis=None, out=None)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `out`.", "question_id": 6781},
{"snippet": "recarray.all(axis=None, keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `keepdims`.", "question_id": 6782},
{"snippet": "recarray.all(axis=None, where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `where`.", "question_id": 6783},
{"snippet": "recarray.all(out=None, keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `out`, `keepdims`.", "question_id": 6784},
{"snippet": "recarray.all(out=None, where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `out`, `where`.", "question_id": 6785},
{"snippet": "polynomial.chebyshev.cheb2poly(c)", "intent": "Convert a Chebyshev series to a polynomial . With arguments `c`.", "question_id": 6786},
{"snippet": "ma.MaskType.squeeze()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 6787},
{"snippet": "recarray.swapaxes(axis1, axis2)", "intent": "Return a view of the array with `axis1` and `axis2` interchanged .", "question_id": 6788},
{"snippet": "testing.dec.setastest()", "intent": "Signals to nose that this function is or is not a test .", "question_id": 6789},
{"snippet": "testing.dec.setastest(tf=True)", "intent": "Signals to nose that this function is or is not a test . With arguments `tf`.", "question_id": 6790},
{"snippet": "ma.MaskType.clip()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 6791},
{"snippet": "polynomial.hermite.Hermite.identity()", "intent": "Identity function .", "question_id": 6792},
{"snippet": "polynomial.hermite.Hermite.identity(domain=None)", "intent": "Identity function . With arguments `domain`.", "question_id": 6793},
{"snippet": "polynomial.hermite.Hermite.identity(window=None)", "intent": "Identity function . With arguments `window`.", "question_id": 6794},
{"snippet": "polynomial.hermite.Hermite.identity(domain=None, window=None)", "intent": "Identity function . With arguments `domain`, `window`.", "question_id": 6795},
{"snippet": "numpy.i0(x)", "intent": "Modified Bessel function of the first kind , order 0 . With arguments `x`.", "question_id": 6796},
{"snippet": "ndarray.transpose(*axes)", "intent": "Returns a view of the array with axes transposed . With arguments `*axes`.", "question_id": 6797},
{"snippet": "matlib.rand(*args)", "intent": "Return a matrix of random values with given shape . With arguments `*args`.", "question_id": 6798},
{"snippet": "polynomial.laguerre.lagval2d(x, y, c)", "intent": "Evaluate a 2-D Laguerre series at points ( `x` , `y` ) . In either case , either x and y or their elements must support multiplication and addition both with themselves and with the elements of `c` .", "question_id": 6799},
{"snippet": "random.RandomState.noncentral_chisquare(df, nonc)", "intent": "Draw samples from a noncentral chi-square distribution . With arguments `df`, `nonc`.", "question_id": 6800},
{"snippet": "random.RandomState.noncentral_chisquare(df, nonc, size=None)", "intent": "Draw samples from a noncentral chi-square distribution . With arguments `df`, `nonc`, `size`.", "question_id": 6801},
{"snippet": "memmap.put(indices, values)", "intent": "Set a.flat [ n ] = `values` [ n ] for all n in `indices` .", "question_id": 6802},
{"snippet": "memmap.put(indices, values, mode='raise')", "intent": "Set a.flat [ n ] = `values` [ n ] for all n in `indices` . With arguments `mode`.", "question_id": 6803},
{"snippet": "char.chararray.itemsize", "intent": "Length of one array element in bytes.", "question_id": 6804},
{"snippet": "numpy.shape(a)", "intent": "Return the shape of an array . With arguments `a`.", "question_id": 6805},
{"snippet": "random.Generator.laplace()", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) .", "question_id": 6806},
{"snippet": "random.Generator.laplace(loc=0.0)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `loc`.", "question_id": 6807},
{"snippet": "random.Generator.laplace(scale=1.0)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) .", "question_id": 6808},
{"snippet": "random.Generator.laplace(size=None)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `size`.", "question_id": 6809},
{"snippet": "random.Generator.laplace(loc=0.0, scale=1.0)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `loc`.", "question_id": 6810},
{"snippet": "random.Generator.laplace(loc=0.0, size=None)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `loc`, `size`.", "question_id": 6811},
{"snippet": "random.Generator.laplace(scale=1.0, size=None)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `size`.", "question_id": 6812},
{"snippet": "random.Generator.laplace(loc=0.0, scale=1.0, size=None)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `loc`, `size`.", "question_id": 6813},
{"snippet": "ma.sum(self)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `self`.", "question_id": 6814},
{"snippet": "ma.sum(self, axis=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `self`.", "question_id": 6815},
{"snippet": "ma.sum(self, dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `self`, `dtype`.", "question_id": 6816},
{"snippet": "ma.sum(self, out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `self`, `out`.", "question_id": 6817},
{"snippet": "ma.sum(self, keepdims=<no value>)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `self`, `keepdims`.", "question_id": 6818},
{"snippet": "ma.sum(self, axis=None, dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `self`, `dtype`.", "question_id": 6819},
{"snippet": "ma.sum(self, axis=None, out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `self`, `out`.", "question_id": 6820},
{"snippet": "ma.sum(self, axis=None, keepdims=<no value>)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `self`, `keepdims`.", "question_id": 6821},
{"snippet": "ma.sum(self, dtype=None, out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `self`, `dtype`, `out`.", "question_id": 6822},
{"snippet": "ma.sum(self, dtype=None, keepdims=<no value>)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `self`, `dtype`, `keepdims`.", "question_id": 6823},
{"snippet": "ma.MaskType.astype()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 6824},
{"snippet": "char.chararray.partition(sep)", "intent": "Partition each element in self around `sep` .", "question_id": 6825},
{"snippet": "generic.dtype", "intent": "Get array data-descriptor.", "question_id": 6826},
{"snippet": "ndarray.dumps()", "intent": "Returns the pickle of the array as a string .", "question_id": 6827},
{"snippet": "ndarray.__lt__(value, /)", "intent": "Return self < `value` . With arguments `/`.", "question_id": 6828},
{"snippet": "numpy.broadcast_shapes(*args)", "intent": "Broadcast the input shapes into a single shape . With arguments `*args`.", "question_id": 6829},
{"snippet": "random.multivariate_normal(mean, cov)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`.", "question_id": 6830},
{"snippet": "random.multivariate_normal(mean, cov, size=None)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `size`.", "question_id": 6831},
{"snippet": "random.multivariate_normal(mean, cov, check_valid='warn')", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `check_valid`.", "question_id": 6832},
{"snippet": "random.multivariate_normal(mean, cov, tol=1e-8)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `tol`.", "question_id": 6833},
{"snippet": "random.multivariate_normal(mean, cov, size=None, check_valid='warn')", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `size`, `check_valid`.", "question_id": 6834},
{"snippet": "random.multivariate_normal(mean, cov, size=None, tol=1e-8)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `size`, `tol`.", "question_id": 6835},
{"snippet": "random.multivariate_normal(mean, cov, check_valid='warn', tol=1e-8)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `check_valid`, `tol`.", "question_id": 6836},
{"snippet": "random.multivariate_normal(mean, cov, size=None, check_valid='warn', tol=1e-8)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `size`, `check_valid`, `tol`.", "question_id": 6837},
{"snippet": "record.argsort()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 6838},
{"snippet": "ma.mask_rowcols(a)", "intent": "Mask rows and/or columns of `a` 2D array that contain masked values .", "question_id": 6839},
{"snippet": "ma.mask_rowcols(a, axis=None)", "intent": "Mask rows and/or columns of `a` 2D array that contain masked values . The masking behavior is selected using the `axis` parameter .", "question_id": 6840},
{"snippet": "numpy.mintypecode(typechars)", "intent": "Return the character for the minimum-size type to which given types can be safely cast . The returned type character must represent the smallest size dtype such that an array of the returned type can handle the data from an array of all types in `typechars` ( or if typechars is an array , then its dtype.char ) .", "question_id": 6841},
{"snippet": "numpy.mintypecode(typechars, typeset='GDFgdf')", "intent": "Return the character for the minimum-size type to which given types can be safely cast . The returned type character must represent the smallest size dtype such that an array of the returned type can handle the data from an array of all types in `typechars` ( or if typechars is an array , then its dtype.char ) . With arguments `typeset`.", "question_id": 6842},
{"snippet": "numpy.mintypecode(typechars, default='d')", "intent": "Return the character for the minimum-size type to which given types can be safely cast . The returned type character must represent the smallest size dtype such that an array of the returned type can handle the data from an array of all types in `typechars` ( or if typechars is an array , then its dtype.char ) . With arguments `default`.", "question_id": 6843},
{"snippet": "numpy.mintypecode(typechars, typeset='GDFgdf', default='d')", "intent": "Return the character for the minimum-size type to which given types can be safely cast . The returned type character must represent the smallest size dtype such that an array of the returned type can handle the data from an array of all types in `typechars` ( or if typechars is an array , then its dtype.char ) . With arguments `typeset`, `default`.", "question_id": 6844},
{"snippet": "matrix.dump(file)", "intent": "Dump a pickle of the array to the specified `file` .", "question_id": 6845},
{"snippet": "numpy.poly(seq_of_zeros)", "intent": "Find the coefficients of a polynomial with the given sequence of roots . With arguments `seq_of_zeros`.", "question_id": 6846},
{"snippet": "linalg.qr(a)", "intent": "Compute the qr factorization of `a` matrix .", "question_id": 6847},
{"snippet": "linalg.qr(a, mode='reduced')", "intent": "Compute the qr factorization of `a` matrix . Subclasses of ndarray are preserved except for the \u2018 raw \u2019 `mode` .", "question_id": 6848},
{"snippet": "memmap.all()", "intent": "Returns True if all elements evaluate to True .", "question_id": 6849},
{"snippet": "memmap.all(axis=None)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`.", "question_id": 6850},
{"snippet": "memmap.all(out=None)", "intent": "Returns True if all elements evaluate to True . With arguments `out`.", "question_id": 6851},
{"snippet": "memmap.all(keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `keepdims`.", "question_id": 6852},
{"snippet": "memmap.all(where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `where`.", "question_id": 6853},
{"snippet": "memmap.all(axis=None, out=None)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `out`.", "question_id": 6854},
{"snippet": "memmap.all(axis=None, keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `keepdims`.", "question_id": 6855},
{"snippet": "memmap.all(axis=None, where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `where`.", "question_id": 6856},
{"snippet": "memmap.all(out=None, keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `out`, `keepdims`.", "question_id": 6857},
{"snippet": "memmap.all(out=None, where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `out`, `where`.", "question_id": 6858},
{"snippet": "ma.MaskedArray.__pow__(other)", "intent": "Raise self to the power `other` , masking the potential NaNs/Infs", "question_id": 6859},
{"snippet": "distutils.ccompiler.CCompiler_cxx_compiler(self)", "intent": "Return the C++ compiler . With arguments `self`.", "question_id": 6860},
{"snippet": "recarray.flatten()", "intent": "Return a copy of the array collapsed into one dimension .", "question_id": 6861},
{"snippet": "recarray.flatten(order='C')", "intent": "Return a copy of the array collapsed into one dimension . With arguments `order`.", "question_id": 6862},
{"snippet": "ma.size(obj)", "intent": "Return the number of elements along a given `axis` . With arguments `obj`.", "question_id": 6863},
{"snippet": "ma.size(obj, axis=None)", "intent": "Return the number of elements along a given `axis` . With arguments `obj`.", "question_id": 6864},
{"snippet": "numpy.std(a)", "intent": "Compute the standard deviation along the specified `axis` . Returns the standard deviation , `a` measure of the spread of a distribution , of the array elements .", "question_id": 6865},
{"snippet": "numpy.std(a, axis=None)", "intent": "Compute the standard deviation along the specified `axis` . Returns the standard deviation , `a` measure of the spread of a distribution , of the array elements .", "question_id": 6866},
{"snippet": "numpy.std(a, dtype=None)", "intent": "Compute the standard deviation along the specified `axis` . Returns the standard deviation , `a` measure of the spread of a distribution , of the array elements . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue .", "question_id": 6867},
{"snippet": "numpy.std(a, out=None)", "intent": "Compute the standard deviation along the specified `axis` . Returns the standard deviation , `a` measure of the spread of a distribution , of the array elements . With arguments `out`.", "question_id": 6868},
{"snippet": "numpy.std(a, ddof=0)", "intent": "Compute the standard deviation along the specified `axis` . Returns the standard deviation , `a` measure of the spread of a distribution , of the array elements . If , however , `ddof` is specified , the divisor N - ddof is used instead .", "question_id": 6869},
{"snippet": "numpy.std(a, keepdims=<no value>)", "intent": "Compute the standard deviation along the specified `axis` . Returns the standard deviation , `a` measure of the spread of a distribution , of the array elements . With arguments `keepdims`.", "question_id": 6870},
{"snippet": "numpy.std(a, where=<no value>)", "intent": "Compute the standard deviation along the specified `axis` . Returns the standard deviation , `a` measure of the spread of a distribution , of the array elements . The standard deviation is the square root of the average of the squared deviations from the mean , i.e. , std = sqrt ( mean ( x ) ) , `where` x = abs ( a - a.mean ( ) ) * * 2 .", "question_id": 6871},
{"snippet": "numpy.std(a, axis=None, dtype=None)", "intent": "Compute the standard deviation along the specified `axis` . Returns the standard deviation , `a` measure of the spread of a distribution , of the array elements . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue .", "question_id": 6872},
{"snippet": "numpy.std(a, axis=None, out=None)", "intent": "Compute the standard deviation along the specified `axis` . Returns the standard deviation , `a` measure of the spread of a distribution , of the array elements . With arguments `out`.", "question_id": 6873},
{"snippet": "numpy.std(a, axis=None, ddof=0)", "intent": "Compute the standard deviation along the specified `axis` . Returns the standard deviation , `a` measure of the spread of a distribution , of the array elements . If , however , `ddof` is specified , the divisor N - ddof is used instead .", "question_id": 6874},
{"snippet": "ma.masked_array.dump(file)", "intent": "Dump a pickle of the array to the specified `file` .", "question_id": 6875},
{"snippet": "ma.MaskedArray.harden_mask()", "intent": "Force the mask to hard .", "question_id": 6876},
{"snippet": "ma.MaskType.mean()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 6877},
{"snippet": "numpy.recarray(shape)", "intent": "Construct an ndarray that allows field access using attributes . With arguments `shape`.", "question_id": 6878},
{"snippet": "numpy.recarray(shape, dtype=None)", "intent": "Construct an ndarray that allows field access using attributes . With arguments `shape`, `dtype`.", "question_id": 6879},
{"snippet": "numpy.recarray(shape, buf=None)", "intent": "Construct an ndarray that allows field access using attributes . With arguments `shape`, `buf`.", "question_id": 6880},
{"snippet": "numpy.recarray(shape, offset=0)", "intent": "Construct an ndarray that allows field access using attributes . With arguments `shape`, `offset`.", "question_id": 6881},
{"snippet": "numpy.recarray(shape, strides=None)", "intent": "Construct an ndarray that allows field access using attributes . With arguments `shape`, `strides`.", "question_id": 6882},
{"snippet": "numpy.recarray(shape, formats=None)", "intent": "Construct an ndarray that allows field access using attributes . With arguments `shape`, `formats`.", "question_id": 6883},
{"snippet": "numpy.recarray(shape, names=None)", "intent": "Construct an ndarray that allows field access using attributes . With arguments `shape`, `names`.", "question_id": 6884},
{"snippet": "numpy.recarray(shape, titles=None)", "intent": "Construct an ndarray that allows field access using attributes . With arguments `shape`, `titles`.", "question_id": 6885},
{"snippet": "numpy.recarray(shape, byteorder=None)", "intent": "Construct an ndarray that allows field access using attributes . With arguments `shape`, `byteorder`.", "question_id": 6886},
{"snippet": "numpy.recarray(shape, aligned=False)", "intent": "Construct an ndarray that allows field access using attributes . With arguments `shape`, `aligned`.", "question_id": 6887},
{"snippet": "record.choose()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 6888},
{"snippet": "ndarray.item(*args)", "intent": "Copy an element of an array to a standard Python scalar and return it . With arguments `*args`.", "question_id": 6889},
{"snippet": "polynomial.hermite.Hermite.has_samedomain(other)", "intent": "Check if domains match . With arguments `other`.", "question_id": 6890},
{"snippet": "polynomial.chebyshev.Chebyshev.copy()", "intent": "Return a copy .", "question_id": 6891},
{"snippet": "matrix.put(indices, values)", "intent": "Set a.flat [ n ] = `values` [ n ] for all n in `indices` .", "question_id": 6892},
{"snippet": "matrix.put(indices, values, mode='raise')", "intent": "Set a.flat [ n ] = `values` [ n ] for all n in `indices` . With arguments `mode`.", "question_id": 6893},
{"snippet": "numpy.ndenumerate(arr)", "intent": "Multidimensional index iterator . With arguments `arr`.", "question_id": 6894},
{"snippet": "memmap.max()", "intent": "Return the maximum along a given `axis` .", "question_id": 6895},
{"snippet": "memmap.max(axis=None)", "intent": "Return the maximum along a given `axis` .", "question_id": 6896},
{"snippet": "memmap.max(out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`.", "question_id": 6897},
{"snippet": "memmap.max(keepdims=False)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`.", "question_id": 6898},
{"snippet": "memmap.max(initial=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `initial`.", "question_id": 6899},
{"snippet": "memmap.max(where=True)", "intent": "Return the maximum along a given `axis` . With arguments `where`.", "question_id": 6900},
{"snippet": "memmap.max(axis=None, out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`.", "question_id": 6901},
{"snippet": "memmap.max(axis=None, keepdims=False)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`.", "question_id": 6902},
{"snippet": "memmap.max(axis=None, initial=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `initial`.", "question_id": 6903},
{"snippet": "memmap.max(axis=None, where=True)", "intent": "Return the maximum along a given `axis` . With arguments `where`.", "question_id": 6904},
{"snippet": "chararray.rjust(width)", "intent": "Return an array with the elements of self right-justified in a string of length `width` .", "question_id": 6905},
{"snippet": "chararray.rjust(width, fillchar=' ')", "intent": "Return an array with the elements of self right-justified in a string of length `width` . With arguments `fillchar`.", "question_id": 6906},
{"snippet": "linalg.tensorinv(a)", "intent": "Compute the \u2018 inverse \u2019 of an N-dimensional array . The result is an inverse for `a` relative to the tensordot operation tensordot ( a , b , `ind` ) , i. e. , up to floating-point accuracy , tensordot ( tensorinv ( a ) , a , ind ) is the \u201c identity \u201d tensor for the tensordot operation .", "question_id": 6907},
{"snippet": "linalg.tensorinv(a, ind=2)", "intent": "Compute the \u2018 inverse \u2019 of an N-dimensional array . The result is an inverse for `a` relative to the tensordot operation tensordot ( a , b , `ind` ) , i. e. , up to floating-point accuracy , tensordot ( tensorinv ( a ) , a , ind ) is the \u201c identity \u201d tensor for the tensordot operation .", "question_id": 6908},
{"snippet": "char.chararray.lower()", "intent": "Return an array with the elements of self converted to lowercase .", "question_id": 6909},
{"snippet": "ma.MaskedArray.__deepcopy__(memo, /)", "intent": "Used if copy.deepcopy is called on an array . With arguments `memo`, `/`.", "question_id": 6910},
{"snippet": "ma.masked_array.argmin()", "intent": "Return array of indices to the minimum values along the given `axis` .", "question_id": 6911},
{"snippet": "ma.masked_array.argmin(axis=None)", "intent": "Return array of indices to the minimum values along the given `axis` .", "question_id": 6912},
{"snippet": "ma.masked_array.argmin(fill_value=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `fill_value`.", "question_id": 6913},
{"snippet": "ma.masked_array.argmin(out=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `out`.", "question_id": 6914},
{"snippet": "ma.masked_array.argmin(axis=None, fill_value=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `fill_value`.", "question_id": 6915},
{"snippet": "ma.masked_array.argmin(axis=None, out=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `out`.", "question_id": 6916},
{"snippet": "ma.masked_array.argmin(fill_value=None, out=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `fill_value`, `out`.", "question_id": 6917},
{"snippet": "ma.masked_array.argmin(axis=None, fill_value=None, out=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `fill_value`, `out`.", "question_id": 6918},
{"snippet": "ma.make_mask(m)", "intent": "Create a boolean mask from an array . Return `m` as a boolean mask , creating a `copy` if necessary or requested .", "question_id": 6919},
{"snippet": "ma.make_mask(m, copy=False)", "intent": "Create a boolean mask from an array . Return `m` as a boolean mask , creating a `copy` if necessary or requested .", "question_id": 6920},
{"snippet": "ma.make_mask(m, shrink=True)", "intent": "Create a boolean mask from an array . Return `m` as a boolean mask , creating a `copy` if necessary or requested . Effect of the `shrink` parameter .", "question_id": 6921},
{"snippet": "ma.make_mask(m, dtype=<class 'numpy.bool_'>)", "intent": "Create a boolean mask from an array . Return `m` as a boolean mask , creating a `copy` if necessary or requested . Using a flexible `dtype` .", "question_id": 6922},
{"snippet": "ma.make_mask(m, copy=False, shrink=True)", "intent": "Create a boolean mask from an array . Return `m` as a boolean mask , creating a `copy` if necessary or requested . Effect of the `shrink` parameter .", "question_id": 6923},
{"snippet": "ma.make_mask(m, copy=False, dtype=<class 'numpy.bool_'>)", "intent": "Create a boolean mask from an array . Return `m` as a boolean mask , creating a `copy` if necessary or requested . Using a flexible `dtype` .", "question_id": 6924},
{"snippet": "ma.make_mask(m, shrink=True, dtype=<class 'numpy.bool_'>)", "intent": "Create a boolean mask from an array . Return `m` as a boolean mask , creating a `copy` if necessary or requested . Effect of the `shrink` parameter . Using a flexible `dtype` .", "question_id": 6925},
{"snippet": "ma.make_mask(m, copy=False, shrink=True, dtype=<class 'numpy.bool_'>)", "intent": "Create a boolean mask from an array . Return `m` as a boolean mask , creating a `copy` if necessary or requested . Effect of the `shrink` parameter . Using a flexible `dtype` .", "question_id": 6926},
{"snippet": "ma.allclose(a, b)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . Return True if all elements of a and `b` are equal subject to given tolerances .", "question_id": 6927},
{"snippet": "ma.allclose(a, b, masked_equal=True)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . Return True if all elements of a and `b` are equal subject to given tolerances . This function is equivalent to allclose except that masked values are treated as equal ( default ) or unequal , depending on the `masked_equal` argument .", "question_id": 6928},
{"snippet": "ma.allclose(a, b, rtol=1e-05)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . Return True if all elements of a and `b` are equal subject to given tolerances . With arguments `rtol`.", "question_id": 6929},
{"snippet": "ma.allclose(a, b, atol=1e-08)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . Return True if all elements of a and `b` are equal subject to given tolerances . With arguments `atol`.", "question_id": 6930},
{"snippet": "ma.allclose(a, b, masked_equal=True, rtol=1e-05)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . Return True if all elements of a and `b` are equal subject to given tolerances . This function is equivalent to allclose except that masked values are treated as equal ( default ) or unequal , depending on the `masked_equal` argument . With arguments `rtol`.", "question_id": 6931},
{"snippet": "ma.allclose(a, b, masked_equal=True, atol=1e-08)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . Return True if all elements of a and `b` are equal subject to given tolerances . This function is equivalent to allclose except that masked values are treated as equal ( default ) or unequal , depending on the `masked_equal` argument . With arguments `atol`.", "question_id": 6932},
{"snippet": "ma.allclose(a, b, rtol=1e-05, atol=1e-08)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . Return True if all elements of a and `b` are equal subject to given tolerances . With arguments `rtol`, `atol`.", "question_id": 6933},
{"snippet": "ma.allclose(a, b, masked_equal=True, rtol=1e-05, atol=1e-08)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . Return True if all elements of a and `b` are equal subject to given tolerances . This function is equivalent to allclose except that masked values are treated as equal ( default ) or unequal , depending on the `masked_equal` argument . With arguments `rtol`, `atol`.", "question_id": 6934},
{"snippet": "numpy.array(object)", "intent": "Create an array . When `order` is \u2018 A \u2019 and `object` is an array in neither \u2018 C \u2019 nor \u2018 F \u2019 order , and a `copy` is forced by a change in `dtype` , then the order of the result is not necessarily \u2018 C \u2019 as expected .", "question_id": 6935},
{"snippet": "numpy.array(object, dtype=None)", "intent": "Create an array . When `order` is \u2018 A \u2019 and `object` is an array in neither \u2018 C \u2019 nor \u2018 F \u2019 order , and a `copy` is forced by a change in `dtype` , then the order of the result is not necessarily \u2018 C \u2019 as expected .", "question_id": 6936},
{"snippet": "numpy.array(object, copy=True)", "intent": "Create an array . When `order` is \u2018 A \u2019 and `object` is an array in neither \u2018 C \u2019 nor \u2018 F \u2019 order , and a `copy` is forced by a change in `dtype` , then the order of the result is not necessarily \u2018 C \u2019 as expected .", "question_id": 6937},
{"snippet": "numpy.array(object, order='K')", "intent": "Create an array . When `order` is \u2018 A \u2019 and `object` is an array in neither \u2018 C \u2019 nor \u2018 F \u2019 order , and a `copy` is forced by a change in `dtype` , then the order of the result is not necessarily \u2018 C \u2019 as expected .", "question_id": 6938},
{"snippet": "numpy.array(object, subok=False)", "intent": "Create an array . When `order` is \u2018 A \u2019 and `object` is an array in neither \u2018 C \u2019 nor \u2018 F \u2019 order , and a `copy` is forced by a change in `dtype` , then the order of the result is not necessarily \u2018 C \u2019 as expected . With arguments `subok`.", "question_id": 6939},
{"snippet": "numpy.array(object, ndmin=0)", "intent": "Create an array . When `order` is \u2018 A \u2019 and `object` is an array in neither \u2018 C \u2019 nor \u2018 F \u2019 order , and a `copy` is forced by a change in `dtype` , then the order of the result is not necessarily \u2018 C \u2019 as expected . With arguments `ndmin`.", "question_id": 6940},
{"snippet": "numpy.array(object, like=None)", "intent": "Create an array . When `order` is \u2018 A \u2019 and `object` is an array in neither \u2018 C \u2019 nor \u2018 F \u2019 order , and a `copy` is forced by a change in `dtype` , then the order of the result is not necessarily \u2018 C \u2019 as expected . With arguments `like`.", "question_id": 6941},
{"snippet": "numpy.array(object, dtype=None, copy=True)", "intent": "Create an array . When `order` is \u2018 A \u2019 and `object` is an array in neither \u2018 C \u2019 nor \u2018 F \u2019 order , and a `copy` is forced by a change in `dtype` , then the order of the result is not necessarily \u2018 C \u2019 as expected .", "question_id": 6942},
{"snippet": "numpy.array(object, dtype=None, order='K')", "intent": "Create an array . When `order` is \u2018 A \u2019 and `object` is an array in neither \u2018 C \u2019 nor \u2018 F \u2019 order , and a `copy` is forced by a change in `dtype` , then the order of the result is not necessarily \u2018 C \u2019 as expected .", "question_id": 6943},
{"snippet": "numpy.array(object, dtype=None, subok=False)", "intent": "Create an array . When `order` is \u2018 A \u2019 and `object` is an array in neither \u2018 C \u2019 nor \u2018 F \u2019 order , and a `copy` is forced by a change in `dtype` , then the order of the result is not necessarily \u2018 C \u2019 as expected . With arguments `subok`.", "question_id": 6944},
{"snippet": "fft.ihfft(a)", "intent": "Compute the inverse FFT of `a` signal that has Hermitian symmetry .", "question_id": 6945},
{"snippet": "fft.ihfft(a, n=None)", "intent": "Compute the inverse FFT of `a` signal that has Hermitian symmetry . With arguments `n`.", "question_id": 6946},
{"snippet": "fft.ihfft(a, axis=- 1)", "intent": "Compute the inverse FFT of `a` signal that has Hermitian symmetry . With arguments `axis`.", "question_id": 6947},
{"snippet": "fft.ihfft(a, norm=None)", "intent": "Compute the inverse FFT of `a` signal that has Hermitian symmetry . With arguments `norm`.", "question_id": 6948},
{"snippet": "fft.ihfft(a, n=None, axis=- 1)", "intent": "Compute the inverse FFT of `a` signal that has Hermitian symmetry . With arguments `n`, `axis`.", "question_id": 6949},
{"snippet": "fft.ihfft(a, n=None, norm=None)", "intent": "Compute the inverse FFT of `a` signal that has Hermitian symmetry . With arguments `n`, `norm`.", "question_id": 6950},
{"snippet": "fft.ihfft(a, axis=- 1, norm=None)", "intent": "Compute the inverse FFT of `a` signal that has Hermitian symmetry . With arguments `axis`, `norm`.", "question_id": 6951},
{"snippet": "fft.ihfft(a, n=None, axis=- 1, norm=None)", "intent": "Compute the inverse FFT of `a` signal that has Hermitian symmetry . With arguments `n`, `axis`, `norm`.", "question_id": 6952},
{"snippet": "numpy.set_printoptions()", "intent": "Set printing options .", "question_id": 6953},
{"snippet": "numpy.set_printoptions(precision=None)", "intent": "Set printing options . Floating point `precision` can be set :", "question_id": 6954},
{"snippet": "numpy.set_printoptions(threshold=None)", "intent": "Set printing options . With arguments `threshold`.", "question_id": 6955},
{"snippet": "numpy.set_printoptions(edgeitems=None)", "intent": "Set printing options . With arguments `edgeitems`.", "question_id": 6956},
{"snippet": "numpy.set_printoptions(linewidth=None)", "intent": "Set printing options . With arguments `linewidth`.", "question_id": 6957},
{"snippet": "numpy.set_printoptions(suppress=None)", "intent": "Set printing options . With arguments `suppress`.", "question_id": 6958},
{"snippet": "numpy.set_printoptions(nanstr=None)", "intent": "Set printing options . With arguments `nanstr`.", "question_id": 6959},
{"snippet": "numpy.set_printoptions(infstr=None)", "intent": "Set printing options . With arguments `infstr`.", "question_id": 6960},
{"snippet": "numpy.set_printoptions(formatter=None)", "intent": "Set printing options . `formatter` is always reset with a call to set_printoptions .", "question_id": 6961},
{"snippet": "numpy.set_printoptions(sign=None)", "intent": "Set printing options . With arguments `sign`.", "question_id": 6962},
{"snippet": "polynomial.hermite_e.poly2herme(pol)", "intent": "Convert a polynomial to a Hermite series . With arguments `pol`.", "question_id": 6963},
{"snippet": "polynomial.hermite.hermtrim(c)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . With arguments `c`.", "question_id": 6964},
{"snippet": "polynomial.hermite.hermtrim(c, tol=0)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . \u201c Small \u201d means \u201c small in absolute value \u201d and is controlled by the parameter `tol` ; \u201c trailing \u201d means highest order coefficient ( s ) , e.g. , in [ 0 , 1 , 1 , 0 , 0 ] ( which represents 0 + x + x * * 2 + 0 * x * * 3 + 0 * x * * 4 ) both the 3-rd and 4-th order coefficients would be \u201c trimmed . \u201d With arguments `c`.", "question_id": 6965},
{"snippet": "record.dump()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 6966},
{"snippet": "ma.MaskType.resize()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 6967},
{"snippet": "polynomial.chebyshev.chebcompanion(c)", "intent": "Return the scaled companion matrix of `c` .", "question_id": 6968},
{"snippet": "polynomial.polyutils.mapdomain(x, old, new)", "intent": "Apply linear map to input points . The linear map offset + scale * `x` that maps the domain `old` to the domain `new` is applied to the points x .", "question_id": 6969},
{"snippet": "char.isspace(a)", "intent": "Returns true for each element if there are only whitespace characters in the string and there is at least one character , false otherwise . With arguments `a`.", "question_id": 6970},
{"snippet": "ma.MaskedArray.__len__(/)", "intent": "Return len ( self ) . With arguments `/`.", "question_id": 6971},
{"snippet": "numpy.multiply(x1, x2, /, signature, extobj)", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`.", "question_id": 6972},
{"snippet": "numpy.multiply(x1, x2, /, signature, extobj, out=None)", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 6973},
{"snippet": "numpy.multiply(x1, x2, /, signature, extobj, where=True)", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 6974},
{"snippet": "numpy.multiply(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 6975},
{"snippet": "numpy.multiply(x1, x2, /, signature, extobj, order='K')", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 6976},
{"snippet": "numpy.multiply(x1, x2, /, signature, extobj, dtype=None)", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 6977},
{"snippet": "numpy.multiply(x1, x2, /, signature, extobj, subok=True)", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 6978},
{"snippet": "numpy.multiply(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 6979},
{"snippet": "numpy.multiply(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 6980},
{"snippet": "numpy.multiply(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 6981},
{"snippet": "numpy.multiply(x1, x2, /, signature)", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`.", "question_id": 6982},
{"snippet": "numpy.multiply(x1, x2, /, signature, out=None)", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `out`.", "question_id": 6983},
{"snippet": "numpy.multiply(x1, x2, /, signature, where=True)", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `where`.", "question_id": 6984},
{"snippet": "numpy.multiply(x1, x2, /, signature, casting='same_kind')", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `casting`.", "question_id": 6985},
{"snippet": "numpy.multiply(x1, x2, /, signature, order='K')", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `order`.", "question_id": 6986},
{"snippet": "numpy.multiply(x1, x2, /, signature, dtype=None)", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `dtype`.", "question_id": 6987},
{"snippet": "numpy.multiply(x1, x2, /, signature, subok=True)", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `subok`.", "question_id": 6988},
{"snippet": "numpy.multiply(x1, x2, /, signature, out=None, where=True)", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `out`, `where`.", "question_id": 6989},
{"snippet": "numpy.multiply(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 6990},
{"snippet": "numpy.multiply(x1, x2, /, signature, out=None, order='K')", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `out`, `order`.", "question_id": 6991},
{"snippet": "ma.MaskedArray.tostring()", "intent": "A compatibility alias for tobytes , with exactly the same behavior .", "question_id": 6992},
{"snippet": "ma.MaskedArray.tostring(fill_value=None)", "intent": "A compatibility alias for tobytes , with exactly the same behavior . With arguments `fill_value`.", "question_id": 6993},
{"snippet": "ma.MaskedArray.tostring(order='C')", "intent": "A compatibility alias for tobytes , with exactly the same behavior . With arguments `order`.", "question_id": 6994},
{"snippet": "ma.MaskedArray.tostring(fill_value=None, order='C')", "intent": "A compatibility alias for tobytes , with exactly the same behavior . With arguments `fill_value`, `order`.", "question_id": 6995},
{"snippet": "record.tolist()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 6996},
{"snippet": "chararray.title()", "intent": "For each element in self , return a titlecased version of the string : words start with uppercase characters , all remaining cased characters are lowercase .", "question_id": 6997},
{"snippet": "ma.MaskedArray.__rmod__(value, /)", "intent": "Return `value` % self . With arguments `/`.", "question_id": 6998},
{"snippet": "ma.masked_greater_equal(x, value)", "intent": "Mask an array where greater than or equal to a given `value` . This function is a shortcut to masked_where , with condition = ( `x` > = value ) .", "question_id": 6999},
{"snippet": "ma.masked_greater_equal(x, value, copy=True)", "intent": "Mask an array where greater than or equal to a given `value` . This function is a shortcut to masked_where , with condition = ( `x` > = value ) . With arguments `copy`.", "question_id": 7000},
{"snippet": "record.T", "intent": "Scalar attribute identical to the corresponding array attribute.", "question_id": 7001},
{"snippet": "ma.MaskedArray.__rxor__(value, /)", "intent": "Return value^self . With arguments `value`, `/`.", "question_id": 7002},
{"snippet": "polynomial.hermite.hermcompanion(c)", "intent": "Return the scaled companion matrix of `c` .", "question_id": 7003},
{"snippet": "polynomial.hermite.Hermite.linspace()", "intent": "Return x , y values at equally spaced points in `domain` .", "question_id": 7004},
{"snippet": "polynomial.hermite.Hermite.linspace(n=100)", "intent": "Return x , y values at equally spaced points in `domain` . Returns the x , y values at `n` linearly spaced points across the domain .", "question_id": 7005},
{"snippet": "polynomial.hermite.Hermite.linspace(domain=None)", "intent": "Return x , y values at equally spaced points in `domain` .", "question_id": 7006},
{"snippet": "polynomial.hermite.Hermite.linspace(n=100, domain=None)", "intent": "Return x , y values at equally spaced points in `domain` . Returns the x , y values at `n` linearly spaced points across the domain .", "question_id": 7007},
{"snippet": "fft.hfft(a)", "intent": "Compute the FFT of `a` signal that has Hermitian symmetry , i.e. , a real spectrum .", "question_id": 7008},
{"snippet": "fft.hfft(a, n=None)", "intent": "Compute the FFT of `a` signal that has Hermitian symmetry , i.e. , a real spectrum . With arguments `n`.", "question_id": 7009},
{"snippet": "fft.hfft(a, axis=- 1)", "intent": "Compute the FFT of `a` signal that has Hermitian symmetry , i.e. , a real spectrum . With arguments `axis`.", "question_id": 7010},
{"snippet": "fft.hfft(a, norm=None)", "intent": "Compute the FFT of `a` signal that has Hermitian symmetry , i.e. , a real spectrum . With arguments `norm`.", "question_id": 7011},
{"snippet": "fft.hfft(a, n=None, axis=- 1)", "intent": "Compute the FFT of `a` signal that has Hermitian symmetry , i.e. , a real spectrum . With arguments `n`, `axis`.", "question_id": 7012},
{"snippet": "fft.hfft(a, n=None, norm=None)", "intent": "Compute the FFT of `a` signal that has Hermitian symmetry , i.e. , a real spectrum . With arguments `n`, `norm`.", "question_id": 7013},
{"snippet": "fft.hfft(a, axis=- 1, norm=None)", "intent": "Compute the FFT of `a` signal that has Hermitian symmetry , i.e. , a real spectrum . With arguments `axis`, `norm`.", "question_id": 7014},
{"snippet": "fft.hfft(a, n=None, axis=- 1, norm=None)", "intent": "Compute the FFT of `a` signal that has Hermitian symmetry , i.e. , a real spectrum . With arguments `n`, `axis`, `norm`.", "question_id": 7015},
{"snippet": "ma.masked_array.strides", "intent": "Tuple of bytes to step in each dimension when traversing an array.", "question_id": 7016},
{"snippet": "memmap.byteswap()", "intent": "Swap the bytes of the array elements", "question_id": 7017},
{"snippet": "memmap.byteswap(inplace=False)", "intent": "Swap the bytes of the array elements With arguments `inplace`.", "question_id": 7018},
{"snippet": "ma.MaskType.min()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 7019},
{"snippet": "char.less(x1, x2)", "intent": "Return ( `x1` < `x2` ) element-wise .", "question_id": 7020},
{"snippet": "numpy.errstate(**kwargs)", "intent": "Context manager for floating-point error handling . With arguments `**kwargs`.", "question_id": 7021},
{"snippet": "record.dumps()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 7022},
{"snippet": "matrix.transpose(*axes)", "intent": "Returns a view of the array with axes transposed . With arguments `*axes`.", "question_id": 7023},
{"snippet": "record.real", "intent": "The real part of the scalar.", "question_id": 7024},
{"snippet": "lib.format.write_array_header_1_0(fp, d)", "intent": "Write the header for an array using the 1.0 format . With arguments `fp`, `d`.", "question_id": 7025},
{"snippet": "char.chararray.rpartition(sep)", "intent": "Partition each element in self around `sep` .", "question_id": 7026},
{"snippet": "char.lstrip(a)", "intent": "For each element in `a` , return a copy with the leading characters removed .", "question_id": 7027},
{"snippet": "char.lstrip(a, chars=None)", "intent": "For each element in `a` , return a copy with the leading characters removed . With arguments `chars`.", "question_id": 7028},
{"snippet": "polynomial.polynomial.polyint(c)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 7029},
{"snippet": "polynomial.polynomial.polyint(c, m=1)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 7030},
{"snippet": "polynomial.polynomial.polyint(c, k=)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 7031},
{"snippet": "polynomial.polynomial.polyint(c, lbnd=0)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 7032},
{"snippet": "polynomial.polynomial.polyint(c, scl=1)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 7033},
{"snippet": "polynomial.polynomial.polyint(c, axis=0)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 7034},
{"snippet": "polynomial.polynomial.polyint(c, m=1, k=)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 7035},
{"snippet": "polynomial.polynomial.polyint(c, m=1, lbnd=0)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 7036},
{"snippet": "polynomial.polynomial.polyint(c, m=1, scl=1)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 7037},
{"snippet": "polynomial.polynomial.polyint(c, m=1, axis=0)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 7038},
{"snippet": "polynomial.polynomial.polyint()", "intent": "Integrate a polynomial .", "question_id": 7039},
{"snippet": "polynomial.polynomial.polyint(m=1)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 7040},
{"snippet": "polynomial.polynomial.polyint(k=)", "intent": "Integrate a polynomial . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 7041},
{"snippet": "polynomial.polynomial.polyint(lbnd=0)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 7042},
{"snippet": "polynomial.polynomial.polyint(scl=1)", "intent": "Integrate a polynomial . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 7043},
{"snippet": "polynomial.polynomial.polyint(axis=0)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 7044},
{"snippet": "polynomial.polynomial.polyint(m=1, k=)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 7045},
{"snippet": "polynomial.polynomial.polyint(m=1, lbnd=0)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 7046},
{"snippet": "polynomial.polynomial.polyint(m=1, scl=1)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added .", "question_id": 7047},
{"snippet": "polynomial.polynomial.polyint(m=1, axis=0)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` .", "question_id": 7048},
{"snippet": "matrix.argsort()", "intent": "Returns the indices that would sort this array .", "question_id": 7049},
{"snippet": "matrix.argsort(axis=- 1)", "intent": "Returns the indices that would sort this array . With arguments `axis`.", "question_id": 7050},
{"snippet": "matrix.argsort(kind=None)", "intent": "Returns the indices that would sort this array . With arguments `kind`.", "question_id": 7051},
{"snippet": "matrix.argsort(order=None)", "intent": "Returns the indices that would sort this array . With arguments `order`.", "question_id": 7052},
{"snippet": "matrix.argsort(axis=- 1, kind=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `kind`.", "question_id": 7053},
{"snippet": "matrix.argsort(axis=- 1, order=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `order`.", "question_id": 7054},
{"snippet": "matrix.argsort(kind=None, order=None)", "intent": "Returns the indices that would sort this array . With arguments `kind`, `order`.", "question_id": 7055},
{"snippet": "matrix.argsort(axis=- 1, kind=None, order=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `kind`, `order`.", "question_id": 7056},
{"snippet": "numpy.arctan(x, /, signature, extobj)", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `extobj`.", "question_id": 7057},
{"snippet": "numpy.arctan(x, /, signature, extobj, out=None)", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 7058},
{"snippet": "numpy.arctan(x, /, signature, extobj, where=True)", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 7059},
{"snippet": "numpy.arctan(x, /, signature, extobj, casting='same_kind')", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 7060},
{"snippet": "numpy.arctan(x, /, signature, extobj, order='K')", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 7061},
{"snippet": "numpy.arctan(x, /, signature, extobj, dtype=None)", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 7062},
{"snippet": "numpy.arctan(x, /, signature, extobj, subok=True)", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 7063},
{"snippet": "numpy.arctan(x, /, signature, extobj, out=None, where=True)", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 7064},
{"snippet": "numpy.arctan(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 7065},
{"snippet": "numpy.arctan(x, /, signature, extobj, out=None, order='K')", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 7066},
{"snippet": "numpy.arctan(x, /, signature)", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`.", "question_id": 7067},
{"snippet": "numpy.arctan(x, /, signature, out=None)", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `out`.", "question_id": 7068},
{"snippet": "numpy.arctan(x, /, signature, where=True)", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `where`.", "question_id": 7069},
{"snippet": "numpy.arctan(x, /, signature, casting='same_kind')", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `casting`.", "question_id": 7070},
{"snippet": "numpy.arctan(x, /, signature, order='K')", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `order`.", "question_id": 7071},
{"snippet": "numpy.arctan(x, /, signature, dtype=None)", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `dtype`.", "question_id": 7072},
{"snippet": "numpy.arctan(x, /, signature, subok=True)", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `subok`.", "question_id": 7073},
{"snippet": "numpy.arctan(x, /, signature, out=None, where=True)", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `out`, `where`.", "question_id": 7074},
{"snippet": "numpy.arctan(x, /, signature, out=None, casting='same_kind')", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 7075},
{"snippet": "numpy.arctan(x, /, signature, out=None, order='K')", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `out`, `order`.", "question_id": 7076},
{"snippet": "matrix.tofile(fid)", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method .", "question_id": 7077},
{"snippet": "matrix.tofile(fid, sep='')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `sep`.", "question_id": 7078},
{"snippet": "matrix.tofile(fid, format='%s')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `format`.", "question_id": 7079},
{"snippet": "matrix.tofile(fid, sep='', format='%s')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `sep`, `format`.", "question_id": 7080},
{"snippet": "random.RandomState.logistic()", "intent": "Draw samples from a logistic distribution .", "question_id": 7081},
{"snippet": "random.RandomState.logistic(loc=0.0)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) .", "question_id": 7082},
{"snippet": "random.RandomState.logistic(scale=1.0)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) .", "question_id": 7083},
{"snippet": "random.RandomState.logistic(size=None)", "intent": "Draw samples from a logistic distribution . With arguments `size`.", "question_id": 7084},
{"snippet": "random.RandomState.logistic(loc=0.0, scale=1.0)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) .", "question_id": 7085},
{"snippet": "random.RandomState.logistic(loc=0.0, size=None)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . With arguments `size`.", "question_id": 7086},
{"snippet": "random.RandomState.logistic(scale=1.0, size=None)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . With arguments `size`.", "question_id": 7087},
{"snippet": "random.RandomState.logistic(loc=0.0, scale=1.0, size=None)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . With arguments `size`.", "question_id": 7088},
{"snippet": "ma.masked_array.conj()", "intent": "Complex-conjugate all elements .", "question_id": 7089},
{"snippet": "random.rand(d0, d1, dn)", "intent": "Random values in a given shape . With arguments `d0`, `d1`, `dn`.", "question_id": 7090},
{"snippet": "ma.masked_array.all()", "intent": "Returns True if all elements evaluate to True .", "question_id": 7091},
{"snippet": "ma.masked_array.all(axis=None)", "intent": "Returns True if all elements evaluate to True . The output array is masked where all the values along the given `axis` are masked : if the output would have been a scalar and that all the values are masked , then the output is masked .", "question_id": 7092},
{"snippet": "ma.masked_array.all(out=None)", "intent": "Returns True if all elements evaluate to True . With arguments `out`.", "question_id": 7093},
{"snippet": "ma.masked_array.all(keepdims=<no value>)", "intent": "Returns True if all elements evaluate to True . With arguments `keepdims`.", "question_id": 7094},
{"snippet": "ma.masked_array.all(axis=None, out=None)", "intent": "Returns True if all elements evaluate to True . The output array is masked where all the values along the given `axis` are masked : if the output would have been a scalar and that all the values are masked , then the output is masked . With arguments `out`.", "question_id": 7095},
{"snippet": "ma.masked_array.all(axis=None, keepdims=<no value>)", "intent": "Returns True if all elements evaluate to True . The output array is masked where all the values along the given `axis` are masked : if the output would have been a scalar and that all the values are masked , then the output is masked . With arguments `keepdims`.", "question_id": 7096},
{"snippet": "ma.masked_array.all(out=None, keepdims=<no value>)", "intent": "Returns True if all elements evaluate to True . With arguments `out`, `keepdims`.", "question_id": 7097},
{"snippet": "ma.masked_array.all(axis=None, out=None, keepdims=<no value>)", "intent": "Returns True if all elements evaluate to True . The output array is masked where all the values along the given `axis` are masked : if the output would have been a scalar and that all the values are masked , then the output is masked . With arguments `out`, `keepdims`.", "question_id": 7098},
{"snippet": "chararray.rpartition(sep)", "intent": "Partition each element in self around `sep` .", "question_id": 7099},
{"snippet": "ndarray.put(indices, values)", "intent": "Set a.flat [ n ] = `values` [ n ] for all n in `indices` .", "question_id": 7100},
{"snippet": "ndarray.put(indices, values, mode='raise')", "intent": "Set a.flat [ n ] = `values` [ n ] for all n in `indices` . With arguments `mode`.", "question_id": 7101},
{"snippet": "numpy.binary_repr(num)", "intent": "Return the binary representation of the input number as a string . With arguments `num`.", "question_id": 7102},
{"snippet": "numpy.binary_repr(num, width=None)", "intent": "Return the binary representation of the input number as a string . For negative numbers , if `width` is not given , a minus sign is added to the front . With arguments `num`.", "question_id": 7103},
{"snippet": "matrix.tobytes()", "intent": "Construct Python bytes containing the raw data bytes in the array .", "question_id": 7104},
{"snippet": "matrix.tobytes(order='C')", "intent": "Construct Python bytes containing the raw data bytes in the array . This behavior is controlled by the `order` parameter .", "question_id": 7105},
{"snippet": "char.rstrip(a)", "intent": "For each element in `a` , return a copy with the trailing characters removed .", "question_id": 7106},
{"snippet": "char.rstrip(a, chars=None)", "intent": "For each element in `a` , return a copy with the trailing characters removed . With arguments `chars`.", "question_id": 7107},
{"snippet": "generic.squeeze()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 7108},
{"snippet": "numpy.geterrcall()", "intent": "Return the current callback function used on floating-point errors .", "question_id": 7109},
{"snippet": "dtype.hasobject", "intent": "Boolean indicating whether this dtype contains any reference-counted objects in any fields or sub-dtypes.", "question_id": 7110},
{"snippet": "polynomial.legendre.Legendre.trim()", "intent": "Remove trailing coefficients", "question_id": 7111},
{"snippet": "polynomial.legendre.Legendre.trim(tol=0)", "intent": "Remove trailing coefficients Remove trailing coefficients until a coefficient is reached whose absolute value greater than `tol` or the beginning of the series is reached .", "question_id": 7112},
{"snippet": "numpy.asfarray(a)", "intent": "Return an array converted to `a` float type .", "question_id": 7113},
{"snippet": "numpy.asfarray(a, dtype=<class 'numpy.double'>)", "intent": "Return an array converted to `a` float type . With arguments `dtype`.", "question_id": 7114},
{"snippet": "chararray.std()", "intent": "Returns the standard deviation of the array elements along given `axis` .", "question_id": 7115},
{"snippet": "chararray.std(axis=None)", "intent": "Returns the standard deviation of the array elements along given `axis` .", "question_id": 7116},
{"snippet": "chararray.std(dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`.", "question_id": 7117},
{"snippet": "chararray.std(out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`.", "question_id": 7118},
{"snippet": "chararray.std(ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`.", "question_id": 7119},
{"snippet": "chararray.std(keepdims=False)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `keepdims`.", "question_id": 7120},
{"snippet": "chararray.std(where=True)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `where`.", "question_id": 7121},
{"snippet": "chararray.std(axis=None, dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`.", "question_id": 7122},
{"snippet": "chararray.std(axis=None, out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`.", "question_id": 7123},
{"snippet": "chararray.std(axis=None, ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`.", "question_id": 7124},
{"snippet": "generic.base", "intent": "Scalar attribute identical to the corresponding array attribute.", "question_id": 7125},
{"snippet": "polynomial.legendre.legder(c)", "intent": "Differentiate a Legendre series . Returns the Legendre series coefficients `c` differentiated `m` times along `axis` .", "question_id": 7126},
{"snippet": "polynomial.legendre.legder(c, m=1)", "intent": "Differentiate a Legendre series . Returns the Legendre series coefficients `c` differentiated `m` times along `axis` .", "question_id": 7127},
{"snippet": "polynomial.legendre.legder(c, scl=1)", "intent": "Differentiate a Legendre series . Returns the Legendre series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) .", "question_id": 7128},
{"snippet": "polynomial.legendre.legder(c, axis=0)", "intent": "Differentiate a Legendre series . Returns the Legendre series coefficients `c` differentiated `m` times along `axis` .", "question_id": 7129},
{"snippet": "polynomial.legendre.legder(c, m=1, scl=1)", "intent": "Differentiate a Legendre series . Returns the Legendre series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) .", "question_id": 7130},
{"snippet": "polynomial.legendre.legder(c, m=1, axis=0)", "intent": "Differentiate a Legendre series . Returns the Legendre series coefficients `c` differentiated `m` times along `axis` .", "question_id": 7131},
{"snippet": "polynomial.legendre.legder(c, scl=1, axis=0)", "intent": "Differentiate a Legendre series . Returns the Legendre series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) .", "question_id": 7132},
{"snippet": "polynomial.legendre.legder(c, m=1, scl=1, axis=0)", "intent": "Differentiate a Legendre series . Returns the Legendre series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) .", "question_id": 7133},
{"snippet": "fft.fft2(a, - 1))", "intent": "Compute the 2-dimensional discrete Fourier Transform . By default , the transform is computed over the last two axes of the input array , i.e. , `a` 2-dimensional FFT . With arguments `- 1)`.", "question_id": 7134},
{"snippet": "fft.fft2(a, - 1), s=None)", "intent": "Compute the 2-dimensional discrete Fourier Transform . By default , the transform is computed over the last two axes of the input array , i.e. , `a` 2-dimensional FFT . With arguments `- 1)`, `s`.", "question_id": 7135},
{"snippet": "fft.fft2(a, - 1), axes=(- 2)", "intent": "Compute the 2-dimensional discrete Fourier Transform . By default , the transform is computed over the last two axes of the input array , i.e. , `a` 2-dimensional FFT . This function computes the n-dimensional discrete Fourier Transform over any `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `- 1)`.", "question_id": 7136},
{"snippet": "fft.fft2(a, - 1), norm=None)", "intent": "Compute the 2-dimensional discrete Fourier Transform . By default , the transform is computed over the last two axes of the input array , i.e. , `a` 2-dimensional FFT . With arguments `- 1)`, `norm`.", "question_id": 7137},
{"snippet": "fft.fft2(a, - 1), s=None, axes=(- 2)", "intent": "Compute the 2-dimensional discrete Fourier Transform . By default , the transform is computed over the last two axes of the input array , i.e. , `a` 2-dimensional FFT . This function computes the n-dimensional discrete Fourier Transform over any `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `- 1)`, `s`.", "question_id": 7138},
{"snippet": "fft.fft2(a, - 1), s=None, norm=None)", "intent": "Compute the 2-dimensional discrete Fourier Transform . By default , the transform is computed over the last two axes of the input array , i.e. , `a` 2-dimensional FFT . With arguments `- 1)`, `s`, `norm`.", "question_id": 7139},
{"snippet": "fft.fft2(a, - 1), axes=(- 2, norm=None)", "intent": "Compute the 2-dimensional discrete Fourier Transform . By default , the transform is computed over the last two axes of the input array , i.e. , `a` 2-dimensional FFT . This function computes the n-dimensional discrete Fourier Transform over any `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `- 1)`, `norm`.", "question_id": 7140},
{"snippet": "fft.fft2(a, - 1), s=None, axes=(- 2, norm=None)", "intent": "Compute the 2-dimensional discrete Fourier Transform . By default , the transform is computed over the last two axes of the input array , i.e. , `a` 2-dimensional FFT . This function computes the n-dimensional discrete Fourier Transform over any `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `- 1)`, `s`, `norm`.", "question_id": 7141},
{"snippet": "polynomial.laguerre.lagval(x, c)", "intent": "Evaluate a Laguerre series at points `x` . If `c` is of length n + 1 , this function returns the value :", "question_id": 7142},
{"snippet": "polynomial.laguerre.lagval(x, c, tensor=True)", "intent": "Evaluate a Laguerre series at points `x` . If `c` is of length n + 1 , this function returns the value : If c is multidimensional , then the shape of the result depends on the value of `tensor` .", "question_id": 7143},
{"snippet": "ma.any(self)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `self`.", "question_id": 7144},
{"snippet": "ma.any(self, axis=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `self`, `axis`.", "question_id": 7145},
{"snippet": "ma.any(self, out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `self`, `out`.", "question_id": 7146},
{"snippet": "ma.any(self, keepdims=<no value>)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `self`, `keepdims`.", "question_id": 7147},
{"snippet": "ma.any(self, axis=None, out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `self`, `axis`, `out`.", "question_id": 7148},
{"snippet": "ma.any(self, axis=None, keepdims=<no value>)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `self`, `axis`, `keepdims`.", "question_id": 7149},
{"snippet": "ma.any(self, out=None, keepdims=<no value>)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `self`, `out`, `keepdims`.", "question_id": 7150},
{"snippet": "ma.any(self, axis=None, out=None, keepdims=<no value>)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `self`, `axis`, `out`, `keepdims`.", "question_id": 7151},
{"snippet": "numpy.can_cast(from_, to)", "intent": "Returns True if cast between data types can occur according `to` the `casting` rule . With arguments `from_`.", "question_id": 7152},
{"snippet": "numpy.can_cast(from_, to, casting='safe')", "intent": "Returns True if cast between data types can occur according `to` the `casting` rule . With arguments `from_`.", "question_id": 7153},
{"snippet": "char.greater(x1, x2)", "intent": "Return ( `x1` > `x2` ) element-wise .", "question_id": 7154},
{"snippet": "ma.MaskType.itemset()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 7155},
{"snippet": "lib.format.read_array_header_1_0(fp)", "intent": "Read an array header from a filelike object using the 1.0 file format version . With arguments `fp`.", "question_id": 7156},
{"snippet": "numpy.isscalar(element)", "intent": "Returns True if the type of `element` is a scalar type .", "question_id": 7157},
{"snippet": "numpy.signbit(x, /, signature, extobj)", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `extobj`.", "question_id": 7158},
{"snippet": "numpy.signbit(x, /, signature, extobj, out=None)", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `extobj`, `out`.", "question_id": 7159},
{"snippet": "numpy.signbit(x, /, signature, extobj, where=True)", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `extobj`.", "question_id": 7160},
{"snippet": "numpy.signbit(x, /, signature, extobj, casting='same_kind')", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `extobj`, `casting`.", "question_id": 7161},
{"snippet": "numpy.signbit(x, /, signature, extobj, order='K')", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `extobj`, `order`.", "question_id": 7162},
{"snippet": "numpy.signbit(x, /, signature, extobj, dtype=None)", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `extobj`, `dtype`.", "question_id": 7163},
{"snippet": "numpy.signbit(x, /, signature, extobj, subok=True)", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `extobj`, `subok`.", "question_id": 7164},
{"snippet": "numpy.signbit(x, /, signature, extobj, out=None, where=True)", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `extobj`, `out`.", "question_id": 7165},
{"snippet": "numpy.signbit(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 7166},
{"snippet": "numpy.signbit(x, /, signature, extobj, out=None, order='K')", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 7167},
{"snippet": "numpy.signbit(x, /, signature)", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`.", "question_id": 7168},
{"snippet": "numpy.signbit(x, /, signature, out=None)", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `out`.", "question_id": 7169},
{"snippet": "numpy.signbit(x, /, signature, where=True)", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`.", "question_id": 7170},
{"snippet": "numpy.signbit(x, /, signature, casting='same_kind')", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `casting`.", "question_id": 7171},
{"snippet": "numpy.signbit(x, /, signature, order='K')", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `order`.", "question_id": 7172},
{"snippet": "numpy.signbit(x, /, signature, dtype=None)", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `dtype`.", "question_id": 7173},
{"snippet": "numpy.signbit(x, /, signature, subok=True)", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `subok`.", "question_id": 7174},
{"snippet": "numpy.signbit(x, /, signature, out=None, where=True)", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `out`.", "question_id": 7175},
{"snippet": "numpy.signbit(x, /, signature, out=None, casting='same_kind')", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `out`, `casting`.", "question_id": 7176},
{"snippet": "numpy.signbit(x, /, signature, out=None, order='K')", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `out`, `order`.", "question_id": 7177},
{"snippet": "ndarray.__bool__(/)", "intent": "self ! = 0 With arguments `/`.", "question_id": 7178},
{"snippet": "matrix.clip(**kwargs)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 7179},
{"snippet": "matrix.clip(**kwargs, min=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 7180},
{"snippet": "matrix.clip(**kwargs, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 7181},
{"snippet": "matrix.clip(**kwargs, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 7182},
{"snippet": "matrix.clip(**kwargs, min=None, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`.", "question_id": 7183},
{"snippet": "matrix.clip(**kwargs, min=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 7184},
{"snippet": "matrix.clip(**kwargs, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 7185},
{"snippet": "matrix.clip(**kwargs, min=None, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`.", "question_id": 7186},
{"snippet": "ma.MaskedArray.__rrshift__(value, /)", "intent": "Return `value` > > self . With arguments `/`.", "question_id": 7187},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.parse_targets(source)", "intent": "Fetch and parse configuration statements that required for defining the targeted CPU features , statements should be declared in the top of `source` in between C comment and start with a special mark @ targets .", "question_id": 7188},
{"snippet": "matlib.empty(shape)", "intent": "Return a new matrix of given `shape` and type , without initializing entries .", "question_id": 7189},
{"snippet": "matlib.empty(shape, dtype=None)", "intent": "Return a new matrix of given `shape` and type , without initializing entries . With arguments `dtype`.", "question_id": 7190},
{"snippet": "matlib.empty(shape, order='C')", "intent": "Return a new matrix of given `shape` and type , without initializing entries . With arguments `order`.", "question_id": 7191},
{"snippet": "matlib.empty(shape, dtype=None, order='C')", "intent": "Return a new matrix of given `shape` and type , without initializing entries . With arguments `dtype`, `order`.", "question_id": 7192},
{"snippet": "random.Generator.vonmises(mu, kappa)", "intent": "Draw samples from a von Mises distribution . Samples are drawn from a von Mises distribution with specified mode ( `mu` ) and dispersion ( `kappa` ) , on the interval [ -pi , pi ] .", "question_id": 7193},
{"snippet": "random.Generator.vonmises(mu, kappa, size=None)", "intent": "Draw samples from a von Mises distribution . Samples are drawn from a von Mises distribution with specified mode ( `mu` ) and dispersion ( `kappa` ) , on the interval [ -pi , pi ] . With arguments `size`.", "question_id": 7194},
{"snippet": "memmap.sum()", "intent": "Return the sum of the array elements over the given `axis` .", "question_id": 7195},
{"snippet": "memmap.sum(axis=None)", "intent": "Return the sum of the array elements over the given `axis` .", "question_id": 7196},
{"snippet": "memmap.sum(dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 7197},
{"snippet": "memmap.sum(out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`.", "question_id": 7198},
{"snippet": "memmap.sum(keepdims=False)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`.", "question_id": 7199},
{"snippet": "memmap.sum(initial=0)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `initial`.", "question_id": 7200},
{"snippet": "memmap.sum(where=True)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `where`.", "question_id": 7201},
{"snippet": "memmap.sum(axis=None, dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 7202},
{"snippet": "memmap.sum(axis=None, out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`.", "question_id": 7203},
{"snippet": "memmap.sum(axis=None, keepdims=False)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`.", "question_id": 7204},
{"snippet": "char.chararray.fill(value)", "intent": "Fill the array with a scalar `value` .", "question_id": 7205},
{"snippet": "ma.minimum_fill_value(obj)", "intent": "Return the maximum value that can be represented by the dtype of an object . With arguments `obj`.", "question_id": 7206},
{"snippet": "ma.ediff1d(arr)", "intent": "Compute the differences between consecutive elements of an array . With arguments `arr`.", "question_id": 7207},
{"snippet": "ma.ediff1d(arr, to_end=None)", "intent": "Compute the differences between consecutive elements of an array . With arguments `arr`, `to_end`.", "question_id": 7208},
{"snippet": "ma.ediff1d(arr, to_begin=None)", "intent": "Compute the differences between consecutive elements of an array . With arguments `arr`, `to_begin`.", "question_id": 7209},
{"snippet": "ma.ediff1d(arr, to_end=None, to_begin=None)", "intent": "Compute the differences between consecutive elements of an array . With arguments `arr`, `to_end`, `to_begin`.", "question_id": 7210},
{"snippet": "numpy.triu_indices_from(arr)", "intent": "Return the indices for the upper-triangle of `arr` .", "question_id": 7211},
{"snippet": "numpy.triu_indices_from(arr, k=0)", "intent": "Return the indices for the upper-triangle of `arr` . With arguments `k`.", "question_id": 7212},
{"snippet": "char.asarray(obj)", "intent": "Convert the input to a chararray , copying the data only if necessary . With arguments `obj`.", "question_id": 7213},
{"snippet": "char.asarray(obj, itemsize=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . With arguments `obj`, `itemsize`.", "question_id": 7214},
{"snippet": "char.asarray(obj, unicode=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`.", "question_id": 7215},
{"snippet": "char.asarray(obj, order=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . With arguments `obj`, `order`.", "question_id": 7216},
{"snippet": "char.asarray(obj, itemsize=None, unicode=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`, `itemsize`.", "question_id": 7217},
{"snippet": "char.asarray(obj, itemsize=None, order=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . With arguments `obj`, `itemsize`, `order`.", "question_id": 7218},
{"snippet": "char.asarray(obj, unicode=None, order=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`, `order`.", "question_id": 7219},
{"snippet": "char.asarray(obj, itemsize=None, unicode=None, order=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`, `itemsize`, `order`.", "question_id": 7220},
{"snippet": "ma.masked_not_equal(x, value)", "intent": "Mask an array where not equal to a given `value` . This function is a shortcut to masked_where , with condition = ( `x` ! = value ) .", "question_id": 7221},
{"snippet": "ma.masked_not_equal(x, value, copy=True)", "intent": "Mask an array where not equal to a given `value` . This function is a shortcut to masked_where , with condition = ( `x` ! = value ) . With arguments `copy`.", "question_id": 7222},
{"snippet": "ma.masked_array.anom()", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` .", "question_id": 7223},
{"snippet": "ma.masked_array.anom(axis=None)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` .", "question_id": 7224},
{"snippet": "ma.masked_array.anom(dtype=None)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . With arguments `dtype`.", "question_id": 7225},
{"snippet": "ma.masked_array.anom(axis=None, dtype=None)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . With arguments `dtype`.", "question_id": 7226},
{"snippet": "polynomial.legendre.legweight(x)", "intent": "Weight function of the Legendre polynomials . With arguments `x`.", "question_id": 7227},
{"snippet": "ma.MaskedArray.ndim", "intent": "Number of array dimensions.", "question_id": 7228},
{"snippet": "ma.append(a, b)", "intent": "Append values to the end of an array . With arguments `a`, `b`.", "question_id": 7229},
{"snippet": "ma.append(a, b, axis=None)", "intent": "Append values to the end of an array . With arguments `a`, `b`, `axis`.", "question_id": 7230},
{"snippet": "distutils.exec_command.exec_command(command, **env)", "intent": "Return ( status , output ) of executed `command` . With arguments `**env`.", "question_id": 7231},
{"snippet": "distutils.exec_command.exec_command(command, **env, execute_in='')", "intent": "Return ( status , output ) of executed `command` . With arguments `**env`, `execute_in`.", "question_id": 7232},
{"snippet": "distutils.exec_command.exec_command(command, **env, use_shell=None)", "intent": "Return ( status , output ) of executed `command` . With arguments `**env`, `use_shell`.", "question_id": 7233},
{"snippet": "distutils.exec_command.exec_command(command, **env, use_tee=None)", "intent": "Return ( status , output ) of executed `command` . With arguments `**env`, `use_tee`.", "question_id": 7234},
{"snippet": "distutils.exec_command.exec_command(command, **env, _with_python=1)", "intent": "Return ( status , output ) of executed `command` . With arguments `**env`, `_with_python`.", "question_id": 7235},
{"snippet": "distutils.exec_command.exec_command(command, **env, execute_in='', use_shell=None)", "intent": "Return ( status , output ) of executed `command` . With arguments `**env`, `execute_in`, `use_shell`.", "question_id": 7236},
{"snippet": "distutils.exec_command.exec_command(command, **env, execute_in='', use_tee=None)", "intent": "Return ( status , output ) of executed `command` . With arguments `**env`, `execute_in`, `use_tee`.", "question_id": 7237},
{"snippet": "distutils.exec_command.exec_command(command, **env, execute_in='', _with_python=1)", "intent": "Return ( status , output ) of executed `command` . With arguments `**env`, `execute_in`, `_with_python`.", "question_id": 7238},
{"snippet": "distutils.exec_command.exec_command(command, **env, use_shell=None, use_tee=None)", "intent": "Return ( status , output ) of executed `command` . With arguments `**env`, `use_shell`, `use_tee`.", "question_id": 7239},
{"snippet": "distutils.exec_command.exec_command(command, **env, use_shell=None, _with_python=1)", "intent": "Return ( status , output ) of executed `command` . With arguments `**env`, `use_shell`, `_with_python`.", "question_id": 7240},
{"snippet": "random.dirichlet(alpha)", "intent": "Draw samples from the Dirichlet distribution . With arguments `alpha`.", "question_id": 7241},
{"snippet": "random.dirichlet(alpha, size=None)", "intent": "Draw samples from the Dirichlet distribution . Draw `size` samples of dimension k from a Dirichlet distribution . With arguments `alpha`.", "question_id": 7242},
{"snippet": "testing.suppress_warnings.__call__(func)", "intent": "Function decorator to apply certain suppressions to a whole function . With arguments `func`.", "question_id": 7243},
{"snippet": "polynomial.hermite.hermval(x, c)", "intent": "Evaluate an Hermite series at points `x` . If `c` is of length n + 1 , this function returns the value :", "question_id": 7244},
{"snippet": "polynomial.hermite.hermval(x, c, tensor=True)", "intent": "Evaluate an Hermite series at points `x` . If `c` is of length n + 1 , this function returns the value : If c is multidimensional , then the shape of the result depends on the value of `tensor` .", "question_id": 7245},
{"snippet": "distutils.ccompiler.CCompiler_customize_cmd(self, cmd)", "intent": "Customize compiler using distutils command . With arguments `self`, `cmd`.", "question_id": 7246},
{"snippet": "distutils.ccompiler.CCompiler_customize_cmd(self, cmd, ignore=())", "intent": "Customize compiler using distutils command . With arguments `self`, `cmd`, `ignore`.", "question_id": 7247},
{"snippet": "polynomial.polyutils.trimseq(seq)", "intent": "Remove small Poly series coefficients . With arguments `seq`.", "question_id": 7248},
{"snippet": "ma.MaskedArray.__ilshift__(value, /)", "intent": "Return self < < =value . With arguments `value`, `/`.", "question_id": 7249},
{"snippet": "matlib.ones(shape)", "intent": "Matrix of ones . Return a matrix of given `shape` and type , filled with ones .", "question_id": 7250},
{"snippet": "matlib.ones(shape, dtype=None)", "intent": "Matrix of ones . Return a matrix of given `shape` and type , filled with ones . With arguments `dtype`.", "question_id": 7251},
{"snippet": "matlib.ones(shape, order='C')", "intent": "Matrix of ones . Return a matrix of given `shape` and type , filled with ones . With arguments `order`.", "question_id": 7252},
{"snippet": "matlib.ones(shape, dtype=None, order='C')", "intent": "Matrix of ones . Return a matrix of given `shape` and type , filled with ones . With arguments `dtype`, `order`.", "question_id": 7253},
{"snippet": "random.negative_binomial(n, p)", "intent": "Draw samples from a negative binomial distribution . Samples are drawn from a negative binomial distribution with specified parameters , `n` successes and `p` probability of success where n is > 0 and p is in the interval [ 0 , 1 ] .", "question_id": 7254},
{"snippet": "random.negative_binomial(n, p, size=None)", "intent": "Draw samples from a negative binomial distribution . Samples are drawn from a negative binomial distribution with specified parameters , `n` successes and `p` probability of success where n is > 0 and p is in the interval [ 0 , 1 ] . With arguments `size`.", "question_id": 7255},
{"snippet": "lib.scimath.log2(x)", "intent": "Compute the logarithm base 2 of `x` .", "question_id": 7256},
{"snippet": "ma.masked_array.argmax()", "intent": "Returns array of indices of the maximum values along the given `axis` .", "question_id": 7257},
{"snippet": "ma.masked_array.argmax(axis=None)", "intent": "Returns array of indices of the maximum values along the given `axis` .", "question_id": 7258},
{"snippet": "ma.masked_array.argmax(fill_value=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . Masked values are treated as if they had the value `fill_value` .", "question_id": 7259},
{"snippet": "ma.masked_array.argmax(out=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . With arguments `out`.", "question_id": 7260},
{"snippet": "ma.masked_array.argmax(axis=None, fill_value=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . Masked values are treated as if they had the value `fill_value` .", "question_id": 7261},
{"snippet": "ma.masked_array.argmax(axis=None, out=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . With arguments `out`.", "question_id": 7262},
{"snippet": "ma.masked_array.argmax(fill_value=None, out=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . Masked values are treated as if they had the value `fill_value` . With arguments `out`.", "question_id": 7263},
{"snippet": "ma.masked_array.argmax(axis=None, fill_value=None, out=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . Masked values are treated as if they had the value `fill_value` . With arguments `out`.", "question_id": 7264},
{"snippet": "memmap.sort()", "intent": "Sort an array in-place .", "question_id": 7265},
{"snippet": "memmap.sort(axis=- 1)", "intent": "Sort an array in-place . With arguments `axis`.", "question_id": 7266},
{"snippet": "memmap.sort(kind=None)", "intent": "Sort an array in-place . With arguments `kind`.", "question_id": 7267},
{"snippet": "memmap.sort(order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array :", "question_id": 7268},
{"snippet": "memmap.sort(axis=- 1, kind=None)", "intent": "Sort an array in-place . With arguments `axis`, `kind`.", "question_id": 7269},
{"snippet": "memmap.sort(axis=- 1, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `axis`.", "question_id": 7270},
{"snippet": "memmap.sort(kind=None, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `kind`.", "question_id": 7271},
{"snippet": "memmap.sort(axis=- 1, kind=None, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `axis`, `kind`.", "question_id": 7272},
{"snippet": "linalg.cond(x)", "intent": "Compute the condition number of a matrix . The condition number of `x` is defined as the norm of x times the norm of the inverse of x [ 1 ] ; the norm can be the usual L2-norm ( root-of-sum-of-squares ) or one of a number of other matrix norms .", "question_id": 7273},
{"snippet": "linalg.cond(x, p=None)", "intent": "Compute the condition number of a matrix . The condition number of `x` is defined as the norm of x times the norm of the inverse of x [ 1 ] ; the norm can be the usual L2-norm ( root-of-sum-of-squares ) or one of a number of other matrix norms . This function is capable of returning the condition number using one of seven different norms , depending on the value of `p` ( see Parameters below ) .", "question_id": 7274},
{"snippet": "char.chararray.ljust(width)", "intent": "Return an array with the elements of self left-justified in a string of length `width` .", "question_id": 7275},
{"snippet": "char.chararray.ljust(width, fillchar=' ')", "intent": "Return an array with the elements of self left-justified in a string of length `width` . With arguments `fillchar`.", "question_id": 7276},
{"snippet": "random.RandomState.bytes(length)", "intent": "Return random bytes . With arguments `length`.", "question_id": 7277},
{"snippet": "numpy.around(a)", "intent": "Evenly round to the given number of `decimals` . np.around uses `a` fast but sometimes inexact algorithm to round floating-point datatypes .", "question_id": 7278},
{"snippet": "numpy.around(a, decimals=0)", "intent": "Evenly round to the given number of `decimals` . np.around uses `a` fast but sometimes inexact algorithm to round floating-point datatypes .", "question_id": 7279},
{"snippet": "numpy.around(a, out=None)", "intent": "Evenly round to the given number of `decimals` . np.around uses `a` fast but sometimes inexact algorithm to round floating-point datatypes . With arguments `out`.", "question_id": 7280},
{"snippet": "numpy.around(a, decimals=0, out=None)", "intent": "Evenly round to the given number of `decimals` . np.around uses `a` fast but sometimes inexact algorithm to round floating-point datatypes . With arguments `out`.", "question_id": 7281},
{"snippet": "ndarray.itemset(*args)", "intent": "Insert scalar into an array ( scalar is cast to array \u2019 s dtype , if possible ) With arguments `*args`.", "question_id": 7282},
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, extobj)", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`.", "question_id": 7283},
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, extobj, out=None)", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`.", "question_id": 7284},
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, extobj, where=True)", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `where`.", "question_id": 7285},
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `casting`.", "question_id": 7286},
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, extobj, order='K')", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `order`.", "question_id": 7287},
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, extobj, dtype=None)", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `dtype`.", "question_id": 7288},
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, extobj, subok=True)", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `subok`.", "question_id": 7289},
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 7290},
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 7291},
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 7292},
{"snippet": "numpy.bitwise_and(x1, x2, /, signature)", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`.", "question_id": 7293},
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, out=None)", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `out`.", "question_id": 7294},
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, where=True)", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `where`.", "question_id": 7295},
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, casting='same_kind')", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `casting`.", "question_id": 7296},
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, order='K')", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `order`.", "question_id": 7297},
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, dtype=None)", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `dtype`.", "question_id": 7298},
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, subok=True)", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `subok`.", "question_id": 7299},
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, out=None, where=True)", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `out`, `where`.", "question_id": 7300},
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `out`, `casting`.", "question_id": 7301},
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, out=None, order='K')", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `out`, `order`.", "question_id": 7302},
{"snippet": "char.chararray.argsort()", "intent": "Returns the indices that would sort this array .", "question_id": 7303},
{"snippet": "char.chararray.argsort(axis=- 1)", "intent": "Returns the indices that would sort this array . With arguments `axis`.", "question_id": 7304},
{"snippet": "char.chararray.argsort(kind=None)", "intent": "Returns the indices that would sort this array . With arguments `kind`.", "question_id": 7305},
{"snippet": "char.chararray.argsort(order=None)", "intent": "Returns the indices that would sort this array . With arguments `order`.", "question_id": 7306},
{"snippet": "char.chararray.argsort(axis=- 1, kind=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `kind`.", "question_id": 7307},
{"snippet": "char.chararray.argsort(axis=- 1, order=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `order`.", "question_id": 7308},
{"snippet": "char.chararray.argsort(kind=None, order=None)", "intent": "Returns the indices that would sort this array . With arguments `kind`, `order`.", "question_id": 7309},
{"snippet": "char.chararray.argsort(axis=- 1, kind=None, order=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `kind`, `order`.", "question_id": 7310},
{"snippet": "polynomial.legendre.legline(off, scl)", "intent": "Legendre series whose graph is a straight line . With arguments `off`, `scl`.", "question_id": 7311},
{"snippet": "memmap.newbyteorder(/)", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`.", "question_id": 7312},
{"snippet": "memmap.newbyteorder(/, new_order='S')", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`, `new_order`.", "question_id": 7313},
{"snippet": "ma.MaskType.max()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 7314},
{"snippet": "numpy.negative(x, /, signature, extobj)", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `extobj`.", "question_id": 7315},
{"snippet": "numpy.negative(x, /, signature, extobj, out=None)", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`.", "question_id": 7316},
{"snippet": "numpy.negative(x, /, signature, extobj, where=True)", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `where`.", "question_id": 7317},
{"snippet": "numpy.negative(x, /, signature, extobj, casting='same_kind')", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `casting`.", "question_id": 7318},
{"snippet": "numpy.negative(x, /, signature, extobj, order='K')", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `order`.", "question_id": 7319},
{"snippet": "numpy.negative(x, /, signature, extobj, dtype=None)", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `dtype`.", "question_id": 7320},
{"snippet": "numpy.negative(x, /, signature, extobj, subok=True)", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `subok`.", "question_id": 7321},
{"snippet": "numpy.negative(x, /, signature, extobj, out=None, where=True)", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 7322},
{"snippet": "numpy.negative(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 7323},
{"snippet": "numpy.negative(x, /, signature, extobj, out=None, order='K')", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 7324},
{"snippet": "numpy.negative(x, /, signature)", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`.", "question_id": 7325},
{"snippet": "numpy.negative(x, /, signature, out=None)", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `out`.", "question_id": 7326},
{"snippet": "numpy.negative(x, /, signature, where=True)", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `where`.", "question_id": 7327},
{"snippet": "numpy.negative(x, /, signature, casting='same_kind')", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `casting`.", "question_id": 7328},
{"snippet": "numpy.negative(x, /, signature, order='K')", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `order`.", "question_id": 7329},
{"snippet": "numpy.negative(x, /, signature, dtype=None)", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `dtype`.", "question_id": 7330},
{"snippet": "numpy.negative(x, /, signature, subok=True)", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `subok`.", "question_id": 7331},
{"snippet": "numpy.negative(x, /, signature, out=None, where=True)", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `out`, `where`.", "question_id": 7332},
{"snippet": "numpy.negative(x, /, signature, out=None, casting='same_kind')", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `out`, `casting`.", "question_id": 7333},
{"snippet": "numpy.negative(x, /, signature, out=None, order='K')", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `out`, `order`.", "question_id": 7334},
{"snippet": "random.Generator.standard_normal()", "intent": "Draw samples from a standard Normal distribution ( mean=0 , stdev=1 ) .", "question_id": 7335},
{"snippet": "random.Generator.standard_normal(size=None)", "intent": "Draw samples from a standard Normal distribution ( mean=0 , stdev=1 ) . With arguments `size`.", "question_id": 7336},
{"snippet": "random.Generator.standard_normal(dtype=np.float64)", "intent": "Draw samples from a standard Normal distribution ( mean=0 , stdev=1 ) . With arguments `dtype`.", "question_id": 7337},
{"snippet": "random.Generator.standard_normal(out=None)", "intent": "Draw samples from a standard Normal distribution ( mean=0 , stdev=1 ) . With arguments `out`.", "question_id": 7338},
{"snippet": "random.Generator.standard_normal(size=None, dtype=np.float64)", "intent": "Draw samples from a standard Normal distribution ( mean=0 , stdev=1 ) . With arguments `size`, `dtype`.", "question_id": 7339},
{"snippet": "random.Generator.standard_normal(size=None, out=None)", "intent": "Draw samples from a standard Normal distribution ( mean=0 , stdev=1 ) . With arguments `size`, `out`.", "question_id": 7340},
{"snippet": "random.Generator.standard_normal(dtype=np.float64, out=None)", "intent": "Draw samples from a standard Normal distribution ( mean=0 , stdev=1 ) . With arguments `dtype`, `out`.", "question_id": 7341},
{"snippet": "random.Generator.standard_normal(size=None, dtype=np.float64, out=None)", "intent": "Draw samples from a standard Normal distribution ( mean=0 , stdev=1 ) . With arguments `size`, `dtype`, `out`.", "question_id": 7342},
{"snippet": "numpy.power(x1, x2, /, signature, extobj)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`.", "question_id": 7343},
{"snippet": "numpy.power(x1, x2, /, signature, extobj, out=None)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 7344},
{"snippet": "numpy.power(x1, x2, /, signature, extobj, where=True)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 7345},
{"snippet": "numpy.power(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 7346},
{"snippet": "numpy.power(x1, x2, /, signature, extobj, order='K')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 7347},
{"snippet": "numpy.power(x1, x2, /, signature, extobj, dtype=None)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 7348},
{"snippet": "numpy.power(x1, x2, /, signature, extobj, subok=True)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 7349},
{"snippet": "numpy.power(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 7350},
{"snippet": "numpy.power(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 7351},
{"snippet": "numpy.power(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 7352},
{"snippet": "numpy.power(x1, x2, /, signature)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`.", "question_id": 7353},
{"snippet": "numpy.power(x1, x2, /, signature, out=None)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `out`.", "question_id": 7354},
{"snippet": "numpy.power(x1, x2, /, signature, where=True)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `where`.", "question_id": 7355},
{"snippet": "numpy.power(x1, x2, /, signature, casting='same_kind')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `casting`.", "question_id": 7356},
{"snippet": "numpy.power(x1, x2, /, signature, order='K')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `order`.", "question_id": 7357},
{"snippet": "numpy.power(x1, x2, /, signature, dtype=None)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `dtype`.", "question_id": 7358},
{"snippet": "numpy.power(x1, x2, /, signature, subok=True)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `subok`.", "question_id": 7359},
{"snippet": "numpy.power(x1, x2, /, signature, out=None, where=True)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `out`, `where`.", "question_id": 7360},
{"snippet": "numpy.power(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 7361},
{"snippet": "numpy.power(x1, x2, /, signature, out=None, order='K')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `out`, `order`.", "question_id": 7362},
{"snippet": "ma.MaskedArray.__delitem__(key, /)", "intent": "Delete self [ `key` ] . With arguments `/`.", "question_id": 7363},
{"snippet": "numpy.exp2(x, /, signature, extobj)", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `extobj`.", "question_id": 7364},
{"snippet": "numpy.exp2(x, /, signature, extobj, out=None)", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `extobj`, `out`.", "question_id": 7365},
{"snippet": "numpy.exp2(x, /, signature, extobj, where=True)", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `extobj`, `where`.", "question_id": 7366},
{"snippet": "numpy.exp2(x, /, signature, extobj, casting='same_kind')", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `extobj`, `casting`.", "question_id": 7367},
{"snippet": "numpy.exp2(x, /, signature, extobj, order='K')", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `extobj`, `order`.", "question_id": 7368},
{"snippet": "numpy.exp2(x, /, signature, extobj, dtype=None)", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `extobj`, `dtype`.", "question_id": 7369},
{"snippet": "numpy.exp2(x, /, signature, extobj, subok=True)", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `extobj`, `subok`.", "question_id": 7370},
{"snippet": "numpy.exp2(x, /, signature, extobj, out=None, where=True)", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 7371},
{"snippet": "numpy.exp2(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 7372},
{"snippet": "numpy.exp2(x, /, signature, extobj, out=None, order='K')", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 7373},
{"snippet": "numpy.exp2(x, /, signature)", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`.", "question_id": 7374},
{"snippet": "numpy.exp2(x, /, signature, out=None)", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `out`.", "question_id": 7375},
{"snippet": "numpy.exp2(x, /, signature, where=True)", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `where`.", "question_id": 7376},
{"snippet": "numpy.exp2(x, /, signature, casting='same_kind')", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `casting`.", "question_id": 7377},
{"snippet": "numpy.exp2(x, /, signature, order='K')", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `order`.", "question_id": 7378},
{"snippet": "numpy.exp2(x, /, signature, dtype=None)", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `dtype`.", "question_id": 7379},
{"snippet": "numpy.exp2(x, /, signature, subok=True)", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `subok`.", "question_id": 7380},
{"snippet": "numpy.exp2(x, /, signature, out=None, where=True)", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `out`, `where`.", "question_id": 7381},
{"snippet": "numpy.exp2(x, /, signature, out=None, casting='same_kind')", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `out`, `casting`.", "question_id": 7382},
{"snippet": "numpy.exp2(x, /, signature, out=None, order='K')", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `out`, `order`.", "question_id": 7383},
{"snippet": "numpy.atleast_3d(*arys)", "intent": "View inputs as arrays with at least three dimensions . With arguments `*arys`.", "question_id": 7384},
{"snippet": "polynomial.legendre.legcompanion(c)", "intent": "Return the scaled companion matrix of `c` .", "question_id": 7385},
{"snippet": "polynomial.legendre.legtrim(c)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . With arguments `c`.", "question_id": 7386},
{"snippet": "polynomial.legendre.legtrim(c, tol=0)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . \u201c Small \u201d means \u201c small in absolute value \u201d and is controlled by the parameter `tol` ; \u201c trailing \u201d means highest order coefficient ( s ) , e.g. , in [ 0 , 1 , 1 , 0 , 0 ] ( which represents 0 + x + x * * 2 + 0 * x * * 3 + 0 * x * * 4 ) both the 3-rd and 4-th order coefficients would be \u201c trimmed . \u201d With arguments `c`.", "question_id": 7387},
{"snippet": "memmap.itemsize", "intent": "Length of one array element in bytes.", "question_id": 7388},
{"snippet": "char.chararray.byteswap()", "intent": "Swap the bytes of the array elements", "question_id": 7389},
{"snippet": "char.chararray.byteswap(inplace=False)", "intent": "Swap the bytes of the array elements With arguments `inplace`.", "question_id": 7390},
{"snippet": "polynomial.chebyshev.Chebyshev.interpolate(func, deg)", "intent": "Interpolate a function at the Chebyshev points of the first kind . Returns the series that interpolates `func` at the Chebyshev points of the first kind scaled and shifted to the `domain` . With arguments `deg`.", "question_id": 7391},
{"snippet": "polynomial.chebyshev.Chebyshev.interpolate(func, deg, domain=None)", "intent": "Interpolate a function at the Chebyshev points of the first kind . Returns the series that interpolates `func` at the Chebyshev points of the first kind scaled and shifted to the `domain` . With arguments `deg`.", "question_id": 7392},
{"snippet": "polynomial.chebyshev.Chebyshev.interpolate(func, deg, args=())", "intent": "Interpolate a function at the Chebyshev points of the first kind . Returns the series that interpolates `func` at the Chebyshev points of the first kind scaled and shifted to the `domain` . With arguments `deg`, `args`.", "question_id": 7393},
{"snippet": "polynomial.chebyshev.Chebyshev.interpolate(func, deg, domain=None, args=())", "intent": "Interpolate a function at the Chebyshev points of the first kind . Returns the series that interpolates `func` at the Chebyshev points of the first kind scaled and shifted to the `domain` . With arguments `deg`, `args`.", "question_id": 7394},
{"snippet": "ndarray.conjugate()", "intent": "Return the complex conjugate , element-wise .", "question_id": 7395},
{"snippet": "ndarray.astype(dtype)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`.", "question_id": 7396},
{"snippet": "ndarray.astype(dtype, order='K')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`.", "question_id": 7397},
{"snippet": "ndarray.astype(dtype, casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`.", "question_id": 7398},
{"snippet": "ndarray.astype(dtype, subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `subok`.", "question_id": 7399},
{"snippet": "ndarray.astype(dtype, copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `copy`.", "question_id": 7400},
{"snippet": "ndarray.astype(dtype, order='K', casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `casting`.", "question_id": 7401},
{"snippet": "ndarray.astype(dtype, order='K', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `subok`.", "question_id": 7402},
{"snippet": "ndarray.astype(dtype, order='K', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `copy`.", "question_id": 7403},
{"snippet": "ndarray.astype(dtype, casting='unsafe', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `subok`.", "question_id": 7404},
{"snippet": "ndarray.astype(dtype, casting='unsafe', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `copy`.", "question_id": 7405},
{"snippet": "matrix.fill(value)", "intent": "Fill the array with a scalar `value` .", "question_id": 7406},
{"snippet": "polynomial.hermite_e.hermegrid3d(x, y, z, c)", "intent": "Evaluate a 3-D HermiteE series on the Cartesian product of `x` , `y` , and `z` . where the points ( a , b , `c` ) consist of all triples formed by taking a from x , b from y , and c from z .", "question_id": 7407},
{"snippet": "memmap.squeeze()", "intent": "Remove axes of length one from a .", "question_id": 7408},
{"snippet": "memmap.squeeze(axis=None)", "intent": "Remove axes of length one from a . With arguments `axis`.", "question_id": 7409},
{"snippet": "polynomial.legendre.Legendre.integ()", "intent": "Integrate .", "question_id": 7410},
{"snippet": "polynomial.legendre.Legendre.integ(m=1)", "intent": "Integrate . With arguments `m`.", "question_id": 7411},
{"snippet": "polynomial.legendre.Legendre.integ(k=)", "intent": "Integrate . With arguments `k`.", "question_id": 7412},
{"snippet": "polynomial.legendre.Legendre.integ(lbnd=None)", "intent": "Integrate . With arguments `lbnd`.", "question_id": 7413},
{"snippet": "polynomial.legendre.Legendre.integ(m=1, k=)", "intent": "Integrate . With arguments `m`, `k`.", "question_id": 7414},
{"snippet": "polynomial.legendre.Legendre.integ(m=1, lbnd=None)", "intent": "Integrate . With arguments `m`, `lbnd`.", "question_id": 7415},
{"snippet": "polynomial.legendre.Legendre.integ(k=, lbnd=None)", "intent": "Integrate . With arguments `k`, `lbnd`.", "question_id": 7416},
{"snippet": "polynomial.legendre.Legendre.integ(m=1, k=, lbnd=None)", "intent": "Integrate . With arguments `m`, `k`, `lbnd`.", "question_id": 7417},
{"snippet": "polynomial.legendre.Legendre.integ()", "intent": "Integrate .", "question_id": 7418},
{"snippet": "polynomial.legendre.Legendre.integ(m=1)", "intent": "Integrate . With arguments `m`.", "question_id": 7419},
{"snippet": "polynomial.legendre.Legendre.integ(k=)", "intent": "Integrate . With arguments `k`.", "question_id": 7420},
{"snippet": "polynomial.legendre.Legendre.integ(lbnd=None)", "intent": "Integrate . With arguments `lbnd`.", "question_id": 7421},
{"snippet": "polynomial.legendre.Legendre.integ(m=1, k=)", "intent": "Integrate . With arguments `m`, `k`.", "question_id": 7422},
{"snippet": "polynomial.legendre.Legendre.integ(m=1, lbnd=None)", "intent": "Integrate . With arguments `m`, `lbnd`.", "question_id": 7423},
{"snippet": "polynomial.legendre.Legendre.integ(k=, lbnd=None)", "intent": "Integrate . With arguments `k`, `lbnd`.", "question_id": 7424},
{"snippet": "polynomial.legendre.Legendre.integ(m=1, k=, lbnd=None)", "intent": "Integrate . With arguments `m`, `k`, `lbnd`.", "question_id": 7425},
{"snippet": "memmap.tostring()", "intent": "A compatibility alias for tobytes , with exactly the same behavior .", "question_id": 7426},
{"snippet": "memmap.tostring(order='C')", "intent": "A compatibility alias for tobytes , with exactly the same behavior . With arguments `order`.", "question_id": 7427},
{"snippet": "ufunc.signature", "intent": "Definition of the core elements a generalized ufunc operates on.", "question_id": 7428},
{"snippet": "ma.MaskedArray.__irshift__(value, /)", "intent": "Return self > > =value . With arguments `value`, `/`.", "question_id": 7429},
{"snippet": "ndarray.base", "intent": "Base object if memory is from some other object.", "question_id": 7430},
{"snippet": "polynomial.hermite.hermder(c)", "intent": "Differentiate a Hermite series . Returns the Hermite series coefficients `c` differentiated `m` times along `axis` .", "question_id": 7431},
{"snippet": "polynomial.hermite.hermder(c, m=1)", "intent": "Differentiate a Hermite series . Returns the Hermite series coefficients `c` differentiated `m` times along `axis` .", "question_id": 7432},
{"snippet": "polynomial.hermite.hermder(c, scl=1)", "intent": "Differentiate a Hermite series . Returns the Hermite series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) .", "question_id": 7433},
{"snippet": "polynomial.hermite.hermder(c, axis=0)", "intent": "Differentiate a Hermite series . Returns the Hermite series coefficients `c` differentiated `m` times along `axis` .", "question_id": 7434},
{"snippet": "polynomial.hermite.hermder(c, m=1, scl=1)", "intent": "Differentiate a Hermite series . Returns the Hermite series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) .", "question_id": 7435},
{"snippet": "polynomial.hermite.hermder(c, m=1, axis=0)", "intent": "Differentiate a Hermite series . Returns the Hermite series coefficients `c` differentiated `m` times along `axis` .", "question_id": 7436},
{"snippet": "polynomial.hermite.hermder(c, scl=1, axis=0)", "intent": "Differentiate a Hermite series . Returns the Hermite series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) .", "question_id": 7437},
{"snippet": "polynomial.hermite.hermder(c, m=1, scl=1, axis=0)", "intent": "Differentiate a Hermite series . Returns the Hermite series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) .", "question_id": 7438},
{"snippet": "chararray.rfind(sub)", "intent": "For each element in self , return the highest index in the string where substring `sub` is found , such that sub is contained within [ `start` , `end` ] .", "question_id": 7439},
{"snippet": "chararray.rfind(sub, start=0)", "intent": "For each element in self , return the highest index in the string where substring `sub` is found , such that sub is contained within [ `start` , `end` ] .", "question_id": 7440},
{"snippet": "chararray.rfind(sub, end=None)", "intent": "For each element in self , return the highest index in the string where substring `sub` is found , such that sub is contained within [ `start` , `end` ] .", "question_id": 7441},
{"snippet": "chararray.rfind(sub, start=0, end=None)", "intent": "For each element in self , return the highest index in the string where substring `sub` is found , such that sub is contained within [ `start` , `end` ] .", "question_id": 7442},
{"snippet": "random.Generator.noncentral_f(dfnum, dfden, nonc)", "intent": "Draw samples from the noncentral F distribution . Samples are drawn from an F distribution with specified parameters , `dfnum` ( degrees of freedom in numerator ) and `dfden` ( degrees of freedom in denominator ) , where both parameters > 1. `nonc` is the non-centrality parameter .", "question_id": 7443},
{"snippet": "random.Generator.noncentral_f(dfnum, dfden, nonc, size=None)", "intent": "Draw samples from the noncentral F distribution . Samples are drawn from an F distribution with specified parameters , `dfnum` ( degrees of freedom in numerator ) and `dfden` ( degrees of freedom in denominator ) , where both parameters > 1. `nonc` is the non-centrality parameter . With arguments `size`.", "question_id": 7444},
{"snippet": "ma.getdata(a)", "intent": "Return the data of `a` masked array as an ndarray .", "question_id": 7445},
{"snippet": "ma.getdata(a, subok=True)", "intent": "Return the data of `a` masked array as an ndarray . Return the data of a ( if any ) as an ndarray if a is a MaskedArray , else return a as a ndarray or subclass ( depending on `subok` ) if not .", "question_id": 7446},
{"snippet": "record.prod()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 7447},
{"snippet": "numpy.chararray(shape)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d .", "question_id": 7448},
{"snippet": "numpy.chararray(shape, itemsize=1)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . With arguments `itemsize`.", "question_id": 7449},
{"snippet": "numpy.chararray(shape, unicode=False)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d .", "question_id": 7450},
{"snippet": "numpy.chararray(shape, buffer=None)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . This constructor creates the array , using `buffer` ( with `offset` and `strides` ) if it is not None .", "question_id": 7451},
{"snippet": "numpy.chararray(shape, offset=0)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . This constructor creates the array , using `buffer` ( with `offset` and `strides` ) if it is not None .", "question_id": 7452},
{"snippet": "numpy.chararray(shape, strides=None)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . This constructor creates the array , using `buffer` ( with `offset` and `strides` ) if it is not None .", "question_id": 7453},
{"snippet": "numpy.chararray(shape, order=None)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d .", "question_id": 7454},
{"snippet": "numpy.chararray(shape, itemsize=1, unicode=False)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . With arguments `itemsize`.", "question_id": 7455},
{"snippet": "numpy.chararray(shape, itemsize=1, buffer=None)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . This constructor creates the array , using `buffer` ( with `offset` and `strides` ) if it is not None . With arguments `itemsize`.", "question_id": 7456},
{"snippet": "numpy.chararray(shape, itemsize=1, offset=0)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . This constructor creates the array , using `buffer` ( with `offset` and `strides` ) if it is not None . With arguments `itemsize`.", "question_id": 7457},
{"snippet": "numpy.asarray_chkfinite(a)", "intent": "Convert the input to an array , checking for NaNs or Infs . Convert `a` list into an array .", "question_id": 7458},
{"snippet": "numpy.asarray_chkfinite(a, dtype=None)", "intent": "Convert the input to an array , checking for NaNs or Infs . Convert `a` list into an array . With arguments `dtype`.", "question_id": 7459},
{"snippet": "numpy.asarray_chkfinite(a, order=None)", "intent": "Convert the input to an array , checking for NaNs or Infs . Convert `a` list into an array . With arguments `order`.", "question_id": 7460},
{"snippet": "numpy.asarray_chkfinite(a, dtype=None, order=None)", "intent": "Convert the input to an array , checking for NaNs or Infs . Convert `a` list into an array . With arguments `dtype`, `order`.", "question_id": 7461},
{"snippet": "numpy.show_config()", "intent": "Show libraries in the system on which NumPy was built .", "question_id": 7462},
{"snippet": "numpy.isnat(x, /, signature, extobj)", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`.", "question_id": 7463},
{"snippet": "numpy.isnat(x, /, signature, extobj, out=None)", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `out`.", "question_id": 7464},
{"snippet": "numpy.isnat(x, /, signature, extobj, where=True)", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `where`.", "question_id": 7465},
{"snippet": "numpy.isnat(x, /, signature, extobj, casting='same_kind')", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `casting`.", "question_id": 7466},
{"snippet": "numpy.isnat(x, /, signature, extobj, order='K')", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `order`.", "question_id": 7467},
{"snippet": "numpy.isnat(x, /, signature, extobj, dtype=None)", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `dtype`.", "question_id": 7468},
{"snippet": "numpy.isnat(x, /, signature, extobj, subok=True)", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `subok`.", "question_id": 7469},
{"snippet": "numpy.isnat(x, /, signature, extobj, out=None, where=True)", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 7470},
{"snippet": "numpy.isnat(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 7471},
{"snippet": "numpy.isnat(x, /, signature, extobj, out=None, order='K')", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 7472},
{"snippet": "numpy.isnat(x, /, signature)", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`.", "question_id": 7473},
{"snippet": "numpy.isnat(x, /, signature, out=None)", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `out`.", "question_id": 7474},
{"snippet": "numpy.isnat(x, /, signature, where=True)", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `where`.", "question_id": 7475},
{"snippet": "numpy.isnat(x, /, signature, casting='same_kind')", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `casting`.", "question_id": 7476},
{"snippet": "numpy.isnat(x, /, signature, order='K')", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `order`.", "question_id": 7477},
{"snippet": "numpy.isnat(x, /, signature, dtype=None)", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `dtype`.", "question_id": 7478},
{"snippet": "numpy.isnat(x, /, signature, subok=True)", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `subok`.", "question_id": 7479},
{"snippet": "numpy.isnat(x, /, signature, out=None, where=True)", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `out`, `where`.", "question_id": 7480},
{"snippet": "numpy.isnat(x, /, signature, out=None, casting='same_kind')", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `out`, `casting`.", "question_id": 7481},
{"snippet": "numpy.isnat(x, /, signature, out=None, order='K')", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `out`, `order`.", "question_id": 7482},
{"snippet": "ma.transpose(a)", "intent": "Permute the dimensions of an array . With arguments `a`.", "question_id": 7483},
{"snippet": "ma.transpose(a, axes=None)", "intent": "Permute the dimensions of an array . With arguments `a`, `axes`.", "question_id": 7484},
{"snippet": "numpy.arccos(x, /, signature, extobj)", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `extobj`.", "question_id": 7485},
{"snippet": "numpy.arccos(x, /, signature, extobj, out=None)", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 7486},
{"snippet": "numpy.arccos(x, /, signature, extobj, where=True)", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 7487},
{"snippet": "numpy.arccos(x, /, signature, extobj, casting='same_kind')", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 7488},
{"snippet": "numpy.arccos(x, /, signature, extobj, order='K')", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 7489},
{"snippet": "numpy.arccos(x, /, signature, extobj, dtype=None)", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 7490},
{"snippet": "numpy.arccos(x, /, signature, extobj, subok=True)", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 7491},
{"snippet": "numpy.arccos(x, /, signature, extobj, out=None, where=True)", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 7492},
{"snippet": "numpy.arccos(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 7493},
{"snippet": "numpy.arccos(x, /, signature, extobj, out=None, order='K')", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 7494},
{"snippet": "numpy.arccos(x, /, signature)", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`.", "question_id": 7495},
{"snippet": "numpy.arccos(x, /, signature, out=None)", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `out`.", "question_id": 7496},
{"snippet": "numpy.arccos(x, /, signature, where=True)", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `where`.", "question_id": 7497},
{"snippet": "numpy.arccos(x, /, signature, casting='same_kind')", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `casting`.", "question_id": 7498},
{"snippet": "numpy.arccos(x, /, signature, order='K')", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `order`.", "question_id": 7499},
{"snippet": "numpy.arccos(x, /, signature, dtype=None)", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `dtype`.", "question_id": 7500},
{"snippet": "numpy.arccos(x, /, signature, subok=True)", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `subok`.", "question_id": 7501},
{"snippet": "numpy.arccos(x, /, signature, out=None, where=True)", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `out`, `where`.", "question_id": 7502},
{"snippet": "numpy.arccos(x, /, signature, out=None, casting='same_kind')", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 7503},
{"snippet": "numpy.arccos(x, /, signature, out=None, order='K')", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `out`, `order`.", "question_id": 7504},
{"snippet": "recarray.trace()", "intent": "Return the sum along diagonals of the array .", "question_id": 7505},
{"snippet": "recarray.trace(offset=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`.", "question_id": 7506},
{"snippet": "recarray.trace(axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `axis1`.", "question_id": 7507},
{"snippet": "recarray.trace(axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `axis2`.", "question_id": 7508},
{"snippet": "recarray.trace(dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `dtype`.", "question_id": 7509},
{"snippet": "recarray.trace(out=None)", "intent": "Return the sum along diagonals of the array . With arguments `out`.", "question_id": 7510},
{"snippet": "recarray.trace(offset=0, axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis1`.", "question_id": 7511},
{"snippet": "recarray.trace(offset=0, axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis2`.", "question_id": 7512},
{"snippet": "recarray.trace(offset=0, dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `dtype`.", "question_id": 7513},
{"snippet": "recarray.trace(offset=0, out=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `out`.", "question_id": 7514},
{"snippet": "ma.MaskType.base", "intent": "Scalar attribute identical to the corresponding array attribute.", "question_id": 7515},
{"snippet": "DataSource.open(path)", "intent": "Open and return file-like object . If `path` is an URL , it will be downloaded , stored in the DataSource directory and opened from there .", "question_id": 7516},
{"snippet": "DataSource.open(path, mode='r')", "intent": "Open and return file-like object . If `path` is an URL , it will be downloaded , stored in the DataSource directory and opened from there . With arguments `mode`.", "question_id": 7517},
{"snippet": "DataSource.open(path, encoding=None)", "intent": "Open and return file-like object . If `path` is an URL , it will be downloaded , stored in the DataSource directory and opened from there . With arguments `encoding`.", "question_id": 7518},
{"snippet": "DataSource.open(path, newline=None)", "intent": "Open and return file-like object . If `path` is an URL , it will be downloaded , stored in the DataSource directory and opened from there . With arguments `newline`.", "question_id": 7519},
{"snippet": "DataSource.open(path, mode='r', encoding=None)", "intent": "Open and return file-like object . If `path` is an URL , it will be downloaded , stored in the DataSource directory and opened from there . With arguments `mode`, `encoding`.", "question_id": 7520},
{"snippet": "DataSource.open(path, mode='r', newline=None)", "intent": "Open and return file-like object . If `path` is an URL , it will be downloaded , stored in the DataSource directory and opened from there . With arguments `mode`, `newline`.", "question_id": 7521},
{"snippet": "DataSource.open(path, encoding=None, newline=None)", "intent": "Open and return file-like object . If `path` is an URL , it will be downloaded , stored in the DataSource directory and opened from there . With arguments `encoding`, `newline`.", "question_id": 7522},
{"snippet": "DataSource.open(path, mode='r', encoding=None, newline=None)", "intent": "Open and return file-like object . If `path` is an URL , it will be downloaded , stored in the DataSource directory and opened from there . With arguments `mode`, `encoding`, `newline`.", "question_id": 7523},
{"snippet": "matrix.swapaxes(axis1, axis2)", "intent": "Return a view of the array with `axis1` and `axis2` interchanged .", "question_id": 7524},
{"snippet": "numpy.array_equiv(a1, a2)", "intent": "Returns True if input arrays are shape consistent and all elements equal . With arguments `a1`, `a2`.", "question_id": 7525},
{"snippet": "numpy.compress(condition, a)", "intent": "Return selected slices of an array along given `axis` . When working along `a` given axis , a slice along that axis is returned in output for each index where `condition` evaluates to True .", "question_id": 7526},
{"snippet": "numpy.compress(condition, a, axis=None)", "intent": "Return selected slices of an array along given `axis` . When working along `a` given axis , a slice along that axis is returned in output for each index where `condition` evaluates to True .", "question_id": 7527},
{"snippet": "numpy.compress(condition, a, out=None)", "intent": "Return selected slices of an array along given `axis` . When working along `a` given axis , a slice along that axis is returned in output for each index where `condition` evaluates to True . With arguments `out`.", "question_id": 7528},
{"snippet": "numpy.compress(condition, a, axis=None, out=None)", "intent": "Return selected slices of an array along given `axis` . When working along `a` given axis , a slice along that axis is returned in output for each index where `condition` evaluates to True . With arguments `out`.", "question_id": 7529},
{"snippet": "core.defchararray.array(obj)", "intent": "Create a chararray . With arguments `obj`.", "question_id": 7530},
{"snippet": "core.defchararray.array(obj, itemsize=None)", "intent": "Create a chararray . With arguments `obj`, `itemsize`.", "question_id": 7531},
{"snippet": "core.defchararray.array(obj, copy=True)", "intent": "Create a chararray . With arguments `obj`, `copy`.", "question_id": 7532},
{"snippet": "core.defchararray.array(obj, unicode=None)", "intent": "Create a chararray . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`.", "question_id": 7533},
{"snippet": "core.defchararray.array(obj, order=None)", "intent": "Create a chararray . With arguments `obj`, `order`.", "question_id": 7534},
{"snippet": "core.defchararray.array(obj, itemsize=None, copy=True)", "intent": "Create a chararray . With arguments `obj`, `itemsize`, `copy`.", "question_id": 7535},
{"snippet": "core.defchararray.array(obj, itemsize=None, unicode=None)", "intent": "Create a chararray . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`, `itemsize`.", "question_id": 7536},
{"snippet": "core.defchararray.array(obj, itemsize=None, order=None)", "intent": "Create a chararray . With arguments `obj`, `itemsize`, `order`.", "question_id": 7537},
{"snippet": "core.defchararray.array(obj, copy=True, unicode=None)", "intent": "Create a chararray . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`, `copy`.", "question_id": 7538},
{"snippet": "core.defchararray.array(obj, copy=True, order=None)", "intent": "Create a chararray . With arguments `obj`, `copy`, `order`.", "question_id": 7539},
{"snippet": "ndarray.getfield(dtype)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements .", "question_id": 7540},
{"snippet": "ndarray.getfield(dtype, offset=0)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements . The values in the view are determined by the given type and the `offset` into the current array in bytes .", "question_id": 7541},
{"snippet": "polynomial.hermite_e.HermiteE.deriv()", "intent": "Differentiate .", "question_id": 7542},
{"snippet": "polynomial.hermite_e.HermiteE.deriv(m=1)", "intent": "Differentiate . With arguments `m`.", "question_id": 7543},
{"snippet": "recarray.argpartition(kth)", "intent": "Returns the indices that would partition this array . With arguments `kth`.", "question_id": 7544},
{"snippet": "recarray.argpartition(kth, axis=- 1)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`.", "question_id": 7545},
{"snippet": "recarray.argpartition(kth, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`.", "question_id": 7546},
{"snippet": "recarray.argpartition(kth, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `order`.", "question_id": 7547},
{"snippet": "recarray.argpartition(kth, axis=- 1, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`.", "question_id": 7548},
{"snippet": "recarray.argpartition(kth, axis=- 1, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `order`.", "question_id": 7549},
{"snippet": "recarray.argpartition(kth, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`, `order`.", "question_id": 7550},
{"snippet": "recarray.argpartition(kth, axis=- 1, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`, `order`.", "question_id": 7551},
{"snippet": "char.count(a, sub)", "intent": "Returns an array with the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] . With arguments `a`.", "question_id": 7552},
{"snippet": "char.count(a, sub, start=0)", "intent": "Returns an array with the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] . With arguments `a`.", "question_id": 7553},
{"snippet": "char.count(a, sub, end=None)", "intent": "Returns an array with the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] . With arguments `a`.", "question_id": 7554},
{"snippet": "char.count(a, sub, start=0, end=None)", "intent": "Returns an array with the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] . With arguments `a`.", "question_id": 7555},
{"snippet": "chararray.itemsize", "intent": "Length of one array element in bytes.", "question_id": 7556},
{"snippet": "recarray.strides", "intent": "Tuple of bytes to step in each dimension when traversing an array.", "question_id": 7557},
{"snippet": "record.data", "intent": "Pointer to start of data.", "question_id": 7558},
{"snippet": "ma.masked_array.nonzero()", "intent": "Return the indices of unmasked elements that are not zero .", "question_id": 7559},
{"snippet": "recarray.argmin()", "intent": "Return indices of the minimum values along the given `axis` .", "question_id": 7560},
{"snippet": "recarray.argmin(axis=None)", "intent": "Return indices of the minimum values along the given `axis` .", "question_id": 7561},
{"snippet": "recarray.argmin(out=None)", "intent": "Return indices of the minimum values along the given `axis` . With arguments `out`.", "question_id": 7562},
{"snippet": "recarray.argmin(axis=None, out=None)", "intent": "Return indices of the minimum values along the given `axis` . With arguments `out`.", "question_id": 7563},
{"snippet": "polynomial.chebyshev.chebvander(x, deg)", "intent": "Pseudo-Vandermonde matrix of given degree . Returns the pseudo-Vandermonde matrix of degree `deg` and sample points `x` .", "question_id": 7564},
{"snippet": "numpy.msort(a)", "intent": "Return `a` copy of an array sorted along the first axis .", "question_id": 7565},
{"snippet": "ndarray.partition(kth)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array .", "question_id": 7566},
{"snippet": "ndarray.partition(kth, axis=- 1)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`.", "question_id": 7567},
{"snippet": "ndarray.partition(kth, kind='introselect')", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `kind`.", "question_id": 7568},
{"snippet": "ndarray.partition(kth, order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `order`.", "question_id": 7569},
{"snippet": "ndarray.partition(kth, axis=- 1, kind='introselect')", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `kind`.", "question_id": 7570},
{"snippet": "ndarray.partition(kth, axis=- 1, order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `order`.", "question_id": 7571},
{"snippet": "ndarray.partition(kth, kind='introselect', order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `kind`, `order`.", "question_id": 7572},
{"snippet": "ndarray.partition(kth, axis=- 1, kind='introselect', order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `kind`, `order`.", "question_id": 7573},
{"snippet": "record.itemset()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 7574},
{"snippet": "polynomial.chebyshev.chebder(c)", "intent": "Differentiate a Chebyshev series . Returns the Chebyshev series coefficients `c` differentiated `m` times along `axis` .", "question_id": 7575},
{"snippet": "polynomial.chebyshev.chebder(c, m=1)", "intent": "Differentiate a Chebyshev series . Returns the Chebyshev series coefficients `c` differentiated `m` times along `axis` .", "question_id": 7576},
{"snippet": "polynomial.chebyshev.chebder(c, scl=1)", "intent": "Differentiate a Chebyshev series . Returns the Chebyshev series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) .", "question_id": 7577},
{"snippet": "polynomial.chebyshev.chebder(c, axis=0)", "intent": "Differentiate a Chebyshev series . Returns the Chebyshev series coefficients `c` differentiated `m` times along `axis` .", "question_id": 7578},
{"snippet": "polynomial.chebyshev.chebder(c, m=1, scl=1)", "intent": "Differentiate a Chebyshev series . Returns the Chebyshev series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) .", "question_id": 7579},
{"snippet": "polynomial.chebyshev.chebder(c, m=1, axis=0)", "intent": "Differentiate a Chebyshev series . Returns the Chebyshev series coefficients `c` differentiated `m` times along `axis` .", "question_id": 7580},
{"snippet": "polynomial.chebyshev.chebder(c, scl=1, axis=0)", "intent": "Differentiate a Chebyshev series . Returns the Chebyshev series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) .", "question_id": 7581},
{"snippet": "polynomial.chebyshev.chebder(c, m=1, scl=1, axis=0)", "intent": "Differentiate a Chebyshev series . Returns the Chebyshev series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) .", "question_id": 7582},
{"snippet": "random.exponential()", "intent": "Draw samples from an exponential distribution .", "question_id": 7583},
{"snippet": "random.exponential(scale=1.0)", "intent": "Draw samples from an exponential distribution . \\ ( \\beta\\ ) is the `scale` parameter , which is the inverse of the rate parameter \\ ( \\lambda = 1/\\beta\\ ) .", "question_id": 7584},
{"snippet": "random.exponential(size=None)", "intent": "Draw samples from an exponential distribution . It describes many common situations , such as the `size` of raindrops measured over many rainstorms [ 1 ] , or the time between page requests to Wikipedia [ 2 ] .", "question_id": 7585},
{"snippet": "random.exponential(scale=1.0, size=None)", "intent": "Draw samples from an exponential distribution . \\ ( \\beta\\ ) is the `scale` parameter , which is the inverse of the rate parameter \\ ( \\lambda = 1/\\beta\\ ) . It describes many common situations , such as the `size` of raindrops measured over many rainstorms [ 1 ] , or the time between page requests to Wikipedia [ 2 ] .", "question_id": 7586},
{"snippet": "matrix.view(dtype, type)", "intent": "New view of array with the same data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) Viewing array data using a different `type` and dtype :", "question_id": 7587},
{"snippet": "matrix.view(dtype)", "intent": "New view of array with the same data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . )", "question_id": 7588},
{"snippet": "matrix.view()", "intent": "New view of array with the same data .", "question_id": 7589},
{"snippet": "numpy.sort_complex(a)", "intent": "Sort `a` complex array using the real part first , then the imaginary part .", "question_id": 7590},
{"snippet": "numpy.hanning(M)", "intent": "Return the Hanning window . With arguments `M`.", "question_id": 7591},
{"snippet": "ma.sort(a)", "intent": "Return `a` sorted copy of the masked array .", "question_id": 7592},
{"snippet": "ma.sort(a, axis=- 1)", "intent": "Return `a` sorted copy of the masked array . With arguments `axis`.", "question_id": 7593},
{"snippet": "ma.sort(a, kind=None)", "intent": "Return `a` sorted copy of the masked array . With arguments `kind`.", "question_id": 7594},
{"snippet": "ma.sort(a, order=None)", "intent": "Return `a` sorted copy of the masked array . With arguments `order`.", "question_id": 7595},
{"snippet": "ma.sort(a, endwith=True)", "intent": "Return `a` sorted copy of the masked array . With arguments `endwith`.", "question_id": 7596},
{"snippet": "ma.sort(a, fill_value=None)", "intent": "Return `a` sorted copy of the masked array . With arguments `fill_value`.", "question_id": 7597},
{"snippet": "ma.sort(a, axis=- 1, kind=None)", "intent": "Return `a` sorted copy of the masked array . With arguments `axis`, `kind`.", "question_id": 7598},
{"snippet": "ma.sort(a, axis=- 1, order=None)", "intent": "Return `a` sorted copy of the masked array . With arguments `axis`, `order`.", "question_id": 7599},
{"snippet": "ma.sort(a, axis=- 1, endwith=True)", "intent": "Return `a` sorted copy of the masked array . With arguments `axis`, `endwith`.", "question_id": 7600},
{"snippet": "ma.sort(a, axis=- 1, fill_value=None)", "intent": "Return `a` sorted copy of the masked array . With arguments `axis`, `fill_value`.", "question_id": 7601},
{"snippet": "polynomial.hermite.hermgrid3d(x, y, z, c)", "intent": "Evaluate a 3-D Hermite series on the Cartesian product of `x` , `y` , and `z` . where the points ( a , b , `c` ) consist of all triples formed by taking a from x , b from y , and c from z .", "question_id": 7602},
{"snippet": "ma.column_stack(*args, **kwargs)", "intent": "Stack 1-D arrays as columns into a 2-D array . With arguments `*args`, `**kwargs`.", "question_id": 7603},
{"snippet": "numpy.isreal(x)", "intent": "Returns a bool array , where True if input element is real . With arguments `x`.", "question_id": 7604},
{"snippet": "numpy.nanprod(a)", "intent": "Return the product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as ones .", "question_id": 7605},
{"snippet": "numpy.nanprod(a, axis=None)", "intent": "Return the product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as ones .", "question_id": 7606},
{"snippet": "numpy.nanprod(a, dtype=None)", "intent": "Return the product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as ones . With arguments `dtype`.", "question_id": 7607},
{"snippet": "numpy.nanprod(a, out=None)", "intent": "Return the product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as ones . With arguments `out`.", "question_id": 7608},
{"snippet": "numpy.nanprod(a, keepdims=<no value>)", "intent": "Return the product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as ones . With arguments `keepdims`.", "question_id": 7609},
{"snippet": "numpy.nanprod(a, axis=None, dtype=None)", "intent": "Return the product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as ones . With arguments `dtype`.", "question_id": 7610},
{"snippet": "numpy.nanprod(a, axis=None, out=None)", "intent": "Return the product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as ones . With arguments `out`.", "question_id": 7611},
{"snippet": "numpy.nanprod(a, axis=None, keepdims=<no value>)", "intent": "Return the product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as ones . With arguments `keepdims`.", "question_id": 7612},
{"snippet": "numpy.nanprod(a, dtype=None, out=None)", "intent": "Return the product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as ones . With arguments `dtype`, `out`.", "question_id": 7613},
{"snippet": "numpy.nanprod(a, dtype=None, keepdims=<no value>)", "intent": "Return the product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as ones . With arguments `dtype`, `keepdims`.", "question_id": 7614},
{"snippet": "numpy.rollaxis(a, axis)", "intent": "Roll the specified `axis` backwards , until it lies in `a` given position .", "question_id": 7615},
{"snippet": "numpy.rollaxis(a, axis, start=0)", "intent": "Roll the specified `axis` backwards , until it lies in `a` given position . With arguments `start`.", "question_id": 7616},
{"snippet": "polynomial.laguerre.laggrid2d(x, y, c)", "intent": "Evaluate a 2-D Laguerre series on the Cartesian product of `x` and `y` . In either case , either x and y or their elements must support multiplication and addition both with themselves and with the elements of `c` .", "question_id": 7617},
{"snippet": "ndarray.tofile(fid)", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method .", "question_id": 7618},
{"snippet": "ndarray.tofile(fid, sep='')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `sep`.", "question_id": 7619},
{"snippet": "ndarray.tofile(fid, format='%s')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `format`.", "question_id": 7620},
{"snippet": "ndarray.tofile(fid, sep='', format='%s')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `sep`, `format`.", "question_id": 7621},
{"snippet": "random.vonmises(mu, kappa)", "intent": "Draw samples from a von Mises distribution . Samples are drawn from a von Mises distribution with specified mode ( `mu` ) and dispersion ( `kappa` ) , on the interval [ -pi , pi ] .", "question_id": 7622},
{"snippet": "random.vonmises(mu, kappa, size=None)", "intent": "Draw samples from a von Mises distribution . Samples are drawn from a von Mises distribution with specified mode ( `mu` ) and dispersion ( `kappa` ) , on the interval [ -pi , pi ] . With arguments `size`.", "question_id": 7623},
{"snippet": "polynomial.hermite.Hermite.cutdeg(deg)", "intent": "Truncate series to the given degree . Reduce the degree of the series to `deg` by discarding the high order terms .", "question_id": 7624},
{"snippet": "ma.masked_inside(x, v1, v2)", "intent": "Mask an array inside a given interval . Shortcut to masked_where , where condition is True for `x` inside the interval [ `v1` , `v2` ] ( v1 < = x < = v2 ) .", "question_id": 7625},
{"snippet": "ma.masked_inside(x, v1, v2, copy=True)", "intent": "Mask an array inside a given interval . Shortcut to masked_where , where condition is True for `x` inside the interval [ `v1` , `v2` ] ( v1 < = x < = v2 ) . With arguments `copy`.", "question_id": 7626},
{"snippet": "polynomial.hermite.hermgrid2d(x, y, c)", "intent": "Evaluate a 2-D Hermite series on the Cartesian product of `x` and `y` . In either case , either x and y or their elements must support multiplication and addition both with themselves and with the elements of `c` .", "question_id": 7627},
{"snippet": "recarray.dot(b)", "intent": "Dot product of two arrays . With arguments `b`.", "question_id": 7628},
{"snippet": "recarray.dot(b, out=None)", "intent": "Dot product of two arrays . With arguments `b`, `out`.", "question_id": 7629},
{"snippet": "polynomial.hermite_e.hermesub(c1, c2)", "intent": "Subtract one Hermite series from another . Returns the difference of two Hermite series `c1` - `c2` .", "question_id": 7630},
{"snippet": "distutils.ccompiler.CCompiler_object_filenames(self, source_filenames)", "intent": "Return the name of the object files for the given source files . With arguments `self`, `source_filenames`.", "question_id": 7631},
{"snippet": "distutils.ccompiler.CCompiler_object_filenames(self, source_filenames, strip_dir=0)", "intent": "Return the name of the object files for the given source files . With arguments `self`, `source_filenames`, `strip_dir`.", "question_id": 7632},
{"snippet": "distutils.ccompiler.CCompiler_object_filenames(self, source_filenames, output_dir='')", "intent": "Return the name of the object files for the given source files . With arguments `self`, `source_filenames`, `output_dir`.", "question_id": 7633},
{"snippet": "distutils.ccompiler.CCompiler_object_filenames(self, source_filenames, strip_dir=0, output_dir='')", "intent": "Return the name of the object files for the given source files . With arguments `self`, `source_filenames`, `strip_dir`, `output_dir`.", "question_id": 7634},
{"snippet": "lib.scimath.arcsin(x)", "intent": "Compute the inverse sine of `x` .", "question_id": 7635},
{"snippet": "numpy.left_shift(x1, x2, /, signature, extobj)", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `extobj`.", "question_id": 7636},
{"snippet": "numpy.left_shift(x1, x2, /, signature, extobj, out=None)", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 7637},
{"snippet": "numpy.left_shift(x1, x2, /, signature, extobj, where=True)", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 7638},
{"snippet": "numpy.left_shift(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 7639},
{"snippet": "numpy.left_shift(x1, x2, /, signature, extobj, order='K')", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 7640},
{"snippet": "numpy.left_shift(x1, x2, /, signature, extobj, dtype=None)", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . Note that the `dtype` of the second argument may change the dtype of the result and can lead to unexpected results in some cases ( see Casting Rules ) : With arguments `/`, `signature`, `extobj`.", "question_id": 7641},
{"snippet": "numpy.left_shift(x1, x2, /, signature, extobj, subok=True)", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 7642},
{"snippet": "numpy.left_shift(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 7643},
{"snippet": "numpy.left_shift(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 7644},
{"snippet": "numpy.left_shift(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 7645},
{"snippet": "numpy.left_shift(x1, x2, /, signature)", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`.", "question_id": 7646},
{"snippet": "numpy.left_shift(x1, x2, /, signature, out=None)", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `out`.", "question_id": 7647},
{"snippet": "numpy.left_shift(x1, x2, /, signature, where=True)", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `where`.", "question_id": 7648},
{"snippet": "numpy.left_shift(x1, x2, /, signature, casting='same_kind')", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `casting`.", "question_id": 7649},
{"snippet": "numpy.left_shift(x1, x2, /, signature, order='K')", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `order`.", "question_id": 7650},
{"snippet": "numpy.left_shift(x1, x2, /, signature, dtype=None)", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . Note that the `dtype` of the second argument may change the dtype of the result and can lead to unexpected results in some cases ( see Casting Rules ) : With arguments `/`, `signature`.", "question_id": 7651},
{"snippet": "numpy.left_shift(x1, x2, /, signature, subok=True)", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `subok`.", "question_id": 7652},
{"snippet": "numpy.left_shift(x1, x2, /, signature, out=None, where=True)", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `out`, `where`.", "question_id": 7653},
{"snippet": "numpy.left_shift(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 7654},
{"snippet": "numpy.left_shift(x1, x2, /, signature, out=None, order='K')", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `out`, `order`.", "question_id": 7655},
{"snippet": "ndarray.compress(condition)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`.", "question_id": 7656},
{"snippet": "ndarray.compress(condition, axis=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`.", "question_id": 7657},
{"snippet": "ndarray.compress(condition, out=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`, `out`.", "question_id": 7658},
{"snippet": "ndarray.compress(condition, axis=None, out=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`, `out`.", "question_id": 7659},
{"snippet": "numpy.polyadd(a1, a2)", "intent": "Find the sum of two polynomials . With arguments `a1`, `a2`.", "question_id": 7660},
{"snippet": "numpy.clip(a, a_min, a_max, **kwargs)", "intent": "Clip ( limit ) the values in an array . Equivalent to but faster than np.minimum ( `a_max` , np.maximum ( `a` , `a_min` ) ) . With arguments `**kwargs`.", "question_id": 7661},
{"snippet": "numpy.clip(a, a_min, a_max, **kwargs, out=None)", "intent": "Clip ( limit ) the values in an array . Equivalent to but faster than np.minimum ( `a_max` , np.maximum ( `a` , `a_min` ) ) . With arguments `**kwargs`, `out`.", "question_id": 7662},
{"snippet": "ma.masked_array.tostring()", "intent": "A compatibility alias for tobytes , with exactly the same behavior .", "question_id": 7663},
{"snippet": "ma.masked_array.tostring(fill_value=None)", "intent": "A compatibility alias for tobytes , with exactly the same behavior . With arguments `fill_value`.", "question_id": 7664},
{"snippet": "ma.masked_array.tostring(order='C')", "intent": "A compatibility alias for tobytes , with exactly the same behavior . With arguments `order`.", "question_id": 7665},
{"snippet": "ma.masked_array.tostring(fill_value=None, order='C')", "intent": "A compatibility alias for tobytes , with exactly the same behavior . With arguments `fill_value`, `order`.", "question_id": 7666},
{"snippet": "matrix.prod()", "intent": "Return the product of the array elements over the given `axis` .", "question_id": 7667},
{"snippet": "matrix.prod(axis=None)", "intent": "Return the product of the array elements over the given `axis` .", "question_id": 7668},
{"snippet": "matrix.prod(dtype=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 7669},
{"snippet": "matrix.prod(out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `out`.", "question_id": 7670},
{"snippet": "matrix.prod(axis=None, dtype=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 7671},
{"snippet": "matrix.prod(axis=None, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `out`.", "question_id": 7672},
{"snippet": "matrix.prod(dtype=None, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`, `out`.", "question_id": 7673},
{"snippet": "matrix.prod(axis=None, dtype=None, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`, `out`.", "question_id": 7674},
{"snippet": "matrix.itemsize", "intent": "Length of one array element in bytes.", "question_id": 7675},
{"snippet": "chararray.cumprod()", "intent": "Return the cumulative product of the elements along the given `axis` .", "question_id": 7676},
{"snippet": "chararray.cumprod(axis=None)", "intent": "Return the cumulative product of the elements along the given `axis` .", "question_id": 7677},
{"snippet": "chararray.cumprod(dtype=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`.", "question_id": 7678},
{"snippet": "chararray.cumprod(out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `out`.", "question_id": 7679},
{"snippet": "chararray.cumprod(axis=None, dtype=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`.", "question_id": 7680},
{"snippet": "chararray.cumprod(axis=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `out`.", "question_id": 7681},
{"snippet": "chararray.cumprod(dtype=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 7682},
{"snippet": "chararray.cumprod(axis=None, dtype=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 7683},
{"snippet": "ma.MaskType.diagonal()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 7684},
{"snippet": "chararray.max()", "intent": "Return the maximum along a given `axis` .", "question_id": 7685},
{"snippet": "chararray.max(axis=None)", "intent": "Return the maximum along a given `axis` .", "question_id": 7686},
{"snippet": "chararray.max(out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`.", "question_id": 7687},
{"snippet": "chararray.max(keepdims=False)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`.", "question_id": 7688},
{"snippet": "chararray.max(initial=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `initial`.", "question_id": 7689},
{"snippet": "chararray.max(where=True)", "intent": "Return the maximum along a given `axis` . With arguments `where`.", "question_id": 7690},
{"snippet": "chararray.max(axis=None, out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`.", "question_id": 7691},
{"snippet": "chararray.max(axis=None, keepdims=False)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`.", "question_id": 7692},
{"snippet": "chararray.max(axis=None, initial=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `initial`.", "question_id": 7693},
{"snippet": "chararray.max(axis=None, where=True)", "intent": "Return the maximum along a given `axis` . With arguments `where`.", "question_id": 7694},
{"snippet": "memmap.real", "intent": "The real part of the array.", "question_id": 7695},
{"snippet": "ma.masked_array.ndim", "intent": "Number of array dimensions.", "question_id": 7696},
{"snippet": "numpy.amax(a)", "intent": "Return the maximum of an array or maximum along an `axis` . Don \u2019 t use amax for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , maximum ( `a` [ 0 ] , a [ 1 ] ) is faster than amax ( a , axis=0 ) .", "question_id": 7697},
{"snippet": "numpy.amax(a, axis=None)", "intent": "Return the maximum of an array or maximum along an `axis` . Don \u2019 t use amax for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , maximum ( `a` [ 0 ] , a [ 1 ] ) is faster than amax ( a , axis=0 ) .", "question_id": 7698},
{"snippet": "numpy.amax(a, out=None)", "intent": "Return the maximum of an array or maximum along an `axis` . Don \u2019 t use amax for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , maximum ( `a` [ 0 ] , a [ 1 ] ) is faster than amax ( a , axis=0 ) . With arguments `out`.", "question_id": 7699},
{"snippet": "numpy.amax(a, keepdims=<no value>)", "intent": "Return the maximum of an array or maximum along an `axis` . Don \u2019 t use amax for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , maximum ( `a` [ 0 ] , a [ 1 ] ) is faster than amax ( a , axis=0 ) . With arguments `keepdims`.", "question_id": 7700},
{"snippet": "numpy.amax(a, initial=<no value>)", "intent": "Return the maximum of an array or maximum along an `axis` . Don \u2019 t use amax for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , maximum ( `a` [ 0 ] , a [ 1 ] ) is faster than amax ( a , axis=0 ) . You can use an `initial` value to compute the maximum of an empty slice , or to initialize it to a different value :", "question_id": 7701},
{"snippet": "numpy.amax(a, where=<no value>)", "intent": "Return the maximum of an array or maximum along an `axis` . Don \u2019 t use amax for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , maximum ( `a` [ 0 ] , a [ 1 ] ) is faster than amax ( a , axis=0 ) . With arguments `where`.", "question_id": 7702},
{"snippet": "numpy.amax(a, axis=None, out=None)", "intent": "Return the maximum of an array or maximum along an `axis` . Don \u2019 t use amax for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , maximum ( `a` [ 0 ] , a [ 1 ] ) is faster than amax ( a , axis=0 ) . With arguments `out`.", "question_id": 7703},
{"snippet": "numpy.amax(a, axis=None, keepdims=<no value>)", "intent": "Return the maximum of an array or maximum along an `axis` . Don \u2019 t use amax for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , maximum ( `a` [ 0 ] , a [ 1 ] ) is faster than amax ( a , axis=0 ) . With arguments `keepdims`.", "question_id": 7704},
{"snippet": "numpy.amax(a, axis=None, initial=<no value>)", "intent": "Return the maximum of an array or maximum along an `axis` . Don \u2019 t use amax for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , maximum ( `a` [ 0 ] , a [ 1 ] ) is faster than amax ( a , axis=0 ) . You can use an `initial` value to compute the maximum of an empty slice , or to initialize it to a different value :", "question_id": 7705},
{"snippet": "numpy.amax(a, axis=None, where=<no value>)", "intent": "Return the maximum of an array or maximum along an `axis` . Don \u2019 t use amax for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , maximum ( `a` [ 0 ] , a [ 1 ] ) is faster than amax ( a , axis=0 ) . With arguments `where`.", "question_id": 7706},
{"snippet": "random.pareto(a)", "intent": "Draw samples from `a` Pareto II or Lomax distribution with specified shape .", "question_id": 7707},
{"snippet": "random.pareto(a, size=None)", "intent": "Draw samples from `a` Pareto II or Lomax distribution with specified shape . With arguments `size`.", "question_id": 7708},
{"snippet": "numpy.squeeze(a)", "intent": "Remove axes of length one from `a` .", "question_id": 7709},
{"snippet": "numpy.squeeze(a, axis=None)", "intent": "Remove axes of length one from `a` . With arguments `axis`.", "question_id": 7710},
{"snippet": "random.hypergeometric(ngood, nbad, nsample)", "intent": "Draw samples from a Hypergeometric distribution . Samples are drawn from a hypergeometric distribution with specified parameters , `ngood` ( ways to make a good selection ) , `nbad` ( ways to make a bad selection ) , and `nsample` ( number of items sampled , which is less than or equal to the sum ngood + nbad ) .", "question_id": 7711},
{"snippet": "random.hypergeometric(ngood, nbad, nsample, size=None)", "intent": "Draw samples from a Hypergeometric distribution . Samples are drawn from a hypergeometric distribution with specified parameters , `ngood` ( ways to make a good selection ) , `nbad` ( ways to make a bad selection ) , and `nsample` ( number of items sampled , which is less than or equal to the sum ngood + nbad ) . With arguments `size`.", "question_id": 7712},
{"snippet": "polynomial.polynomial.polytrim(c)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . With arguments `c`.", "question_id": 7713},
{"snippet": "polynomial.polynomial.polytrim(c, tol=0)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . \u201c Small \u201d means \u201c small in absolute value \u201d and is controlled by the parameter `tol` ; \u201c trailing \u201d means highest order coefficient ( s ) , e.g. , in [ 0 , 1 , 1 , 0 , 0 ] ( which represents 0 + x + x * * 2 + 0 * x * * 3 + 0 * x * * 4 ) both the 3-rd and 4-th order coefficients would be \u201c trimmed . \u201d With arguments `c`.", "question_id": 7714},
{"snippet": "numpy.promote_types(type1, type2)", "intent": "Returns the data type with the smallest size and smallest scalar kind to which both `type1` and `type2` may be safely cast .", "question_id": 7715},
{"snippet": "ndarray.__imul__(value, /)", "intent": "Return self * =value . With arguments `value`, `/`.", "question_id": 7716},
{"snippet": "ndarray.__ilshift__(value, /)", "intent": "Return self < < =value . With arguments `value`, `/`.", "question_id": 7717},
{"snippet": "char.chararray.var()", "intent": "Returns the variance of the array elements , along given `axis` .", "question_id": 7718},
{"snippet": "char.chararray.var(axis=None)", "intent": "Returns the variance of the array elements , along given `axis` .", "question_id": 7719},
{"snippet": "char.chararray.var(dtype=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `dtype`.", "question_id": 7720},
{"snippet": "char.chararray.var(out=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `out`.", "question_id": 7721},
{"snippet": "char.chararray.var(ddof=0)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `ddof`.", "question_id": 7722},
{"snippet": "char.chararray.var(keepdims=False)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `keepdims`.", "question_id": 7723},
{"snippet": "char.chararray.var(where=True)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `where`.", "question_id": 7724},
{"snippet": "char.chararray.var(axis=None, dtype=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `dtype`.", "question_id": 7725},
{"snippet": "char.chararray.var(axis=None, out=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `out`.", "question_id": 7726},
{"snippet": "char.chararray.var(axis=None, ddof=0)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `ddof`.", "question_id": 7727},
{"snippet": "ma.MaskedArray.__rfloordiv__(other)", "intent": "Divide self into `other` , and return a new masked array .", "question_id": 7728},
{"snippet": "ma.masked_array.put(indices, values)", "intent": "Set storage-indexed locations to corresponding `values` . Sets self._data.flat [ n ] = values [ n ] for each n in `indices` .", "question_id": 7729},
{"snippet": "ma.masked_array.put(indices, values, mode='raise')", "intent": "Set storage-indexed locations to corresponding `values` . Sets self._data.flat [ n ] = values [ n ] for each n in `indices` . With arguments `mode`.", "question_id": 7730},
{"snippet": "ma.MaskedArray.__rmul__(other)", "intent": "Multiply `other` by self , and return a new masked array .", "question_id": 7731},
{"snippet": "poly1d.integ()", "intent": "Return an antiderivative ( indefinite integral ) of this polynomial .", "question_id": 7732},
{"snippet": "poly1d.integ(m=1)", "intent": "Return an antiderivative ( indefinite integral ) of this polynomial . With arguments `m`.", "question_id": 7733},
{"snippet": "poly1d.integ(k=0)", "intent": "Return an antiderivative ( indefinite integral ) of this polynomial . With arguments `k`.", "question_id": 7734},
{"snippet": "poly1d.integ(m=1, k=0)", "intent": "Return an antiderivative ( indefinite integral ) of this polynomial . With arguments `m`, `k`.", "question_id": 7735},
{"snippet": "busdaycalendar.holidays", "intent": "A copy of the holiday array indicating additional invalid days.", "question_id": 7736},
{"snippet": "ma.MaskedArray.__imul__(other)", "intent": "Multiply self by `other` in-place .", "question_id": 7737},
{"snippet": "char.chararray.all()", "intent": "Returns True if all elements evaluate to True .", "question_id": 7738},
{"snippet": "char.chararray.all(axis=None)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`.", "question_id": 7739},
{"snippet": "char.chararray.all(out=None)", "intent": "Returns True if all elements evaluate to True . With arguments `out`.", "question_id": 7740},
{"snippet": "char.chararray.all(keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `keepdims`.", "question_id": 7741},
{"snippet": "char.chararray.all(where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `where`.", "question_id": 7742},
{"snippet": "char.chararray.all(axis=None, out=None)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `out`.", "question_id": 7743},
{"snippet": "char.chararray.all(axis=None, keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `keepdims`.", "question_id": 7744},
{"snippet": "char.chararray.all(axis=None, where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `where`.", "question_id": 7745},
{"snippet": "char.chararray.all(out=None, keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `out`, `keepdims`.", "question_id": 7746},
{"snippet": "char.chararray.all(out=None, where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `out`, `where`.", "question_id": 7747},
{"snippet": "numpy.hsplit(ary, indices_or_sections)", "intent": "Split an array into multiple sub-arrays horizontally ( column-wise ) . With arguments `ary`, `indices_or_sections`.", "question_id": 7748},
{"snippet": "numpy.interp(x, xp, fp)", "intent": "One-dimensional linear interpolation for monotonically increasing sample points . Returns the one-dimensional piecewise linear interpolant to a function with given discrete data points ( `xp` , `fp` ) , evaluated at `x` .", "question_id": 7749},
{"snippet": "numpy.interp(x, xp, fp, left=None)", "intent": "One-dimensional linear interpolation for monotonically increasing sample points . Returns the one-dimensional piecewise linear interpolant to a function with given discrete data points ( `xp` , `fp` ) , evaluated at `x` . With arguments `left`.", "question_id": 7750},
{"snippet": "numpy.interp(x, xp, fp, right=None)", "intent": "One-dimensional linear interpolation for monotonically increasing sample points . Returns the one-dimensional piecewise linear interpolant to a function with given discrete data points ( `xp` , `fp` ) , evaluated at `x` . With arguments `right`.", "question_id": 7751},
{"snippet": "numpy.interp(x, xp, fp, period=None)", "intent": "One-dimensional linear interpolation for monotonically increasing sample points . Returns the one-dimensional piecewise linear interpolant to a function with given discrete data points ( `xp` , `fp` ) , evaluated at `x` . With arguments `period`.", "question_id": 7752},
{"snippet": "numpy.interp(x, xp, fp, left=None, right=None)", "intent": "One-dimensional linear interpolation for monotonically increasing sample points . Returns the one-dimensional piecewise linear interpolant to a function with given discrete data points ( `xp` , `fp` ) , evaluated at `x` . With arguments `left`, `right`.", "question_id": 7753},
{"snippet": "numpy.interp(x, xp, fp, left=None, period=None)", "intent": "One-dimensional linear interpolation for monotonically increasing sample points . Returns the one-dimensional piecewise linear interpolant to a function with given discrete data points ( `xp` , `fp` ) , evaluated at `x` . With arguments `left`, `period`.", "question_id": 7754},
{"snippet": "numpy.interp(x, xp, fp, right=None, period=None)", "intent": "One-dimensional linear interpolation for monotonically increasing sample points . Returns the one-dimensional piecewise linear interpolant to a function with given discrete data points ( `xp` , `fp` ) , evaluated at `x` . With arguments `right`, `period`.", "question_id": 7755},
{"snippet": "numpy.interp(x, xp, fp, left=None, right=None, period=None)", "intent": "One-dimensional linear interpolation for monotonically increasing sample points . Returns the one-dimensional piecewise linear interpolant to a function with given discrete data points ( `xp` , `fp` ) , evaluated at `x` . With arguments `left`, `right`, `period`.", "question_id": 7756},
{"snippet": "ma.MaskType.ptp()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 7757},
{"snippet": "ma.masked_array.copy()", "intent": "Return a copy of the array .", "question_id": 7758},
{"snippet": "ma.masked_array.copy(order='C')", "intent": "Return a copy of the array . The function numpy.copy is similar , but it defaults to using `order` \u2018 K \u2019 , and will not pass sub-classes through by default .", "question_id": 7759},
{"snippet": "ma.MaskedArray.__add__(other)", "intent": "Add self to `other` , and return a new masked array .", "question_id": 7760},
{"snippet": "ma.masked_all(shape)", "intent": "Empty masked array with all elements masked . Return an empty masked array of the given `shape` and `dtype` , where all the data are masked .", "question_id": 7761},
{"snippet": "ma.masked_all(shape, dtype=<class 'float'>)", "intent": "Empty masked array with all elements masked . Return an empty masked array of the given `shape` and `dtype` , where all the data are masked .", "question_id": 7762},
{"snippet": "recarray.itemsize", "intent": "Length of one array element in bytes.", "question_id": 7763},
{"snippet": "random.RandomState.gamma(shape)", "intent": "Draw samples from a Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and `scale` ( sometimes designated \u201c theta \u201d ) , where both parameters are > 0 .", "question_id": 7764},
{"snippet": "random.RandomState.gamma(shape, scale=1.0)", "intent": "Draw samples from a Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and `scale` ( sometimes designated \u201c theta \u201d ) , where both parameters are > 0 .", "question_id": 7765},
{"snippet": "random.RandomState.gamma(shape, size=None)", "intent": "Draw samples from a Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and `scale` ( sometimes designated \u201c theta \u201d ) , where both parameters are > 0 . With arguments `size`.", "question_id": 7766},
{"snippet": "random.RandomState.gamma(shape, scale=1.0, size=None)", "intent": "Draw samples from a Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and `scale` ( sometimes designated \u201c theta \u201d ) , where both parameters are > 0 . With arguments `size`.", "question_id": 7767},
{"snippet": "chararray.round()", "intent": "Return a with each element rounded to the given number of `decimals` .", "question_id": 7768},
{"snippet": "chararray.round(decimals=0)", "intent": "Return a with each element rounded to the given number of `decimals` .", "question_id": 7769},
{"snippet": "chararray.round(out=None)", "intent": "Return a with each element rounded to the given number of `decimals` . With arguments `out`.", "question_id": 7770},
{"snippet": "chararray.round(decimals=0, out=None)", "intent": "Return a with each element rounded to the given number of `decimals` . With arguments `out`.", "question_id": 7771},
{"snippet": "chararray.isalpha()", "intent": "Returns true for each element if all characters in the string are alphabetic and there is at least one character , false otherwise .", "question_id": 7772},
{"snippet": "chararray.center(width)", "intent": "Return a copy of self with its elements centered in a string of length `width` .", "question_id": 7773},
{"snippet": "chararray.center(width, fillchar=' ')", "intent": "Return a copy of self with its elements centered in a string of length `width` . With arguments `fillchar`.", "question_id": 7774},
{"snippet": "ndarray.repeat(repeats)", "intent": "Repeat elements of an array . With arguments `repeats`.", "question_id": 7775},
{"snippet": "ndarray.repeat(repeats, axis=None)", "intent": "Repeat elements of an array . With arguments `repeats`, `axis`.", "question_id": 7776},
{"snippet": "record.base", "intent": "base object", "question_id": 7777},
{"snippet": "recarray.dump(file)", "intent": "Dump a pickle of the array to the specified `file` .", "question_id": 7778},
{"snippet": "record.fill()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 7779},
{"snippet": "recarray.argsort()", "intent": "Returns the indices that would sort this array .", "question_id": 7780},
{"snippet": "recarray.argsort(axis=- 1)", "intent": "Returns the indices that would sort this array . With arguments `axis`.", "question_id": 7781},
{"snippet": "recarray.argsort(kind=None)", "intent": "Returns the indices that would sort this array . With arguments `kind`.", "question_id": 7782},
{"snippet": "recarray.argsort(order=None)", "intent": "Returns the indices that would sort this array . With arguments `order`.", "question_id": 7783},
{"snippet": "recarray.argsort(axis=- 1, kind=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `kind`.", "question_id": 7784},
{"snippet": "recarray.argsort(axis=- 1, order=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `order`.", "question_id": 7785},
{"snippet": "recarray.argsort(kind=None, order=None)", "intent": "Returns the indices that would sort this array . With arguments `kind`, `order`.", "question_id": 7786},
{"snippet": "recarray.argsort(axis=- 1, kind=None, order=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `kind`, `order`.", "question_id": 7787},
{"snippet": "random.wald(mean, scale)", "intent": "Draw samples from a Wald , or inverse Gaussian , distribution . Some references claim that the Wald is an inverse Gaussian with `mean` equal to 1 , but this is by no means universal . As the `scale` approaches infinity , the distribution becomes more like a Gaussian .", "question_id": 7788},
{"snippet": "random.wald(mean, scale, size=None)", "intent": "Draw samples from a Wald , or inverse Gaussian , distribution . Some references claim that the Wald is an inverse Gaussian with `mean` equal to 1 , but this is by no means universal . As the `scale` approaches infinity , the distribution becomes more like a Gaussian . With arguments `size`.", "question_id": 7789},
{"snippet": "numpy.ravel_multi_index(multi_index, dims)", "intent": "Converts a tuple of index arrays into an array of flat indices , applying boundary modes to the multi-index . With arguments `multi_index`, `dims`.", "question_id": 7790},
{"snippet": "numpy.ravel_multi_index(multi_index, dims, mode='raise')", "intent": "Converts a tuple of index arrays into an array of flat indices , applying boundary modes to the multi-index . With arguments `multi_index`, `dims`, `mode`.", "question_id": 7791},
{"snippet": "numpy.ravel_multi_index(multi_index, dims, order='C')", "intent": "Converts a tuple of index arrays into an array of flat indices , applying boundary modes to the multi-index . With arguments `multi_index`, `dims`, `order`.", "question_id": 7792},
{"snippet": "numpy.ravel_multi_index(multi_index, dims, mode='raise', order='C')", "intent": "Converts a tuple of index arrays into an array of flat indices , applying boundary modes to the multi-index . With arguments `multi_index`, `dims`, `mode`, `order`.", "question_id": 7793},
{"snippet": "ndarray.T", "intent": "The transposed array.", "question_id": 7794},
{"snippet": "random.Generator.bit_generator", "intent": "Gets the bit generator instance used by the generator", "question_id": 7795},
{"snippet": "numpy.vsplit(ary, indices_or_sections)", "intent": "Split an array into multiple sub-arrays vertically ( row-wise ) . With arguments `ary`, `indices_or_sections`.", "question_id": 7796},
{"snippet": "char.chararray.tolist()", "intent": "Return the array as an a.ndim-levels deep nested list of Python scalars .", "question_id": 7797},
{"snippet": "chararray.byteswap()", "intent": "Swap the bytes of the array elements", "question_id": 7798},
{"snippet": "chararray.byteswap(inplace=False)", "intent": "Swap the bytes of the array elements With arguments `inplace`.", "question_id": 7799},
{"snippet": "record.cumsum()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 7800},
{"snippet": "memmap.resize(new_shape)", "intent": "Change shape and size of array in-place . With arguments `new_shape`.", "question_id": 7801},
{"snippet": "memmap.resize(new_shape, refcheck=True)", "intent": "Change shape and size of array in-place . However , reference counts can increase in other ways so if you are sure that you have not shared the memory for this array with another Python object , then you may safely set `refcheck` to False . With arguments `new_shape`.", "question_id": 7802},
{"snippet": "numpy.diag_indices(n)", "intent": "Return the indices to access the main diagonal of an array . This returns a tuple of indices that can be used to access the main diagonal of an array a with a.ndim > = 2 dimensions and shape ( `n` , n , \u2026 , n ) .", "question_id": 7803},
{"snippet": "numpy.diag_indices(n, ndim=2)", "intent": "Return the indices to access the main diagonal of an array . This returns a tuple of indices that can be used to access the main diagonal of an array a with a.ndim > = 2 dimensions and shape ( `n` , n , \u2026 , n ) . With arguments `ndim`.", "question_id": 7804},
{"snippet": "ma.MaskedArray.__array_wrap__(obj)", "intent": "Special hook for ufuncs . With arguments `obj`.", "question_id": 7805},
{"snippet": "ma.MaskedArray.__array_wrap__(obj, context=None)", "intent": "Special hook for ufuncs . Wraps the numpy array and sets the mask according to `context` . With arguments `obj`.", "question_id": 7806},
{"snippet": "numpy.cross(a, b)", "intent": "Return the cross product of two ( arrays of ) vectors . The cross product of `a` and `b` in \\ ( R^3\\ ) is a vector perpendicular to both a and b .", "question_id": 7807},
{"snippet": "numpy.cross(a, b, axisa=- 1)", "intent": "Return the cross product of two ( arrays of ) vectors . The cross product of `a` and `b` in \\ ( R^3\\ ) is a vector perpendicular to both a and b . Change the vector definition of x and y using `axisa` and `axisb` .", "question_id": 7808},
{"snippet": "numpy.cross(a, b, axisb=- 1)", "intent": "Return the cross product of two ( arrays of ) vectors . The cross product of `a` and `b` in \\ ( R^3\\ ) is a vector perpendicular to both a and b . Change the vector definition of x and y using `axisa` and `axisb` .", "question_id": 7809},
{"snippet": "numpy.cross(a, b, axisc=- 1)", "intent": "Return the cross product of two ( arrays of ) vectors . The cross product of `a` and `b` in \\ ( R^3\\ ) is a vector perpendicular to both a and b . The orientation of c can be changed using the `axisc` keyword .", "question_id": 7810},
{"snippet": "numpy.cross(a, b, axis=None)", "intent": "Return the cross product of two ( arrays of ) vectors . The cross product of `a` and `b` in \\ ( R^3\\ ) is a vector perpendicular to both a and b . If a and b are arrays of vectors , the vectors are defined by the last `axis` of a and b by default , and these axes can have dimensions 2 or 3 .", "question_id": 7811},
{"snippet": "numpy.cross(a, b, axisa=- 1, axisb=- 1)", "intent": "Return the cross product of two ( arrays of ) vectors . The cross product of `a` and `b` in \\ ( R^3\\ ) is a vector perpendicular to both a and b . Change the vector definition of x and y using `axisa` and `axisb` .", "question_id": 7812},
{"snippet": "numpy.cross(a, b, axisa=- 1, axisc=- 1)", "intent": "Return the cross product of two ( arrays of ) vectors . The cross product of `a` and `b` in \\ ( R^3\\ ) is a vector perpendicular to both a and b . Change the vector definition of x and y using `axisa` and `axisb` . The orientation of c can be changed using the `axisc` keyword .", "question_id": 7813},
{"snippet": "numpy.cross(a, b, axisa=- 1, axis=None)", "intent": "Return the cross product of two ( arrays of ) vectors . The cross product of `a` and `b` in \\ ( R^3\\ ) is a vector perpendicular to both a and b . Change the vector definition of x and y using `axisa` and `axisb` . If a and b are arrays of vectors , the vectors are defined by the last `axis` of a and b by default , and these axes can have dimensions 2 or 3 .", "question_id": 7814},
{"snippet": "numpy.cross(a, b, axisb=- 1, axisc=- 1)", "intent": "Return the cross product of two ( arrays of ) vectors . The cross product of `a` and `b` in \\ ( R^3\\ ) is a vector perpendicular to both a and b . Change the vector definition of x and y using `axisa` and `axisb` . The orientation of c can be changed using the `axisc` keyword .", "question_id": 7815},
{"snippet": "numpy.cross(a, b, axisb=- 1, axis=None)", "intent": "Return the cross product of two ( arrays of ) vectors . The cross product of `a` and `b` in \\ ( R^3\\ ) is a vector perpendicular to both a and b . Change the vector definition of x and y using `axisa` and `axisb` . If a and b are arrays of vectors , the vectors are defined by the last `axis` of a and b by default , and these axes can have dimensions 2 or 3 .", "question_id": 7816},
{"snippet": "polynomial.hermite_e.HermiteE.identity()", "intent": "Identity function .", "question_id": 7817},
{"snippet": "polynomial.hermite_e.HermiteE.identity(domain=None)", "intent": "Identity function . With arguments `domain`.", "question_id": 7818},
{"snippet": "polynomial.hermite_e.HermiteE.identity(window=None)", "intent": "Identity function . With arguments `window`.", "question_id": 7819},
{"snippet": "polynomial.hermite_e.HermiteE.identity(domain=None, window=None)", "intent": "Identity function . With arguments `domain`, `window`.", "question_id": 7820},
{"snippet": "char.chararray.searchsorted(v)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order .", "question_id": 7821},
{"snippet": "char.chararray.searchsorted(v, side='left')", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`.", "question_id": 7822},
{"snippet": "char.chararray.searchsorted(v, sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `sorter`.", "question_id": 7823},
{"snippet": "char.chararray.searchsorted(v, side='left', sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`, `sorter`.", "question_id": 7824},
{"snippet": "ma.masked_array.flags", "intent": "Information about the memory layout of the array.", "question_id": 7825},
{"snippet": "linalg.matrix_rank(M)", "intent": "Return matrix rank of array using SVD method Imagine that there is a column in `M` that is an exact ( in floating point ) linear combination of other columns in M. Computing the SVD on M will not produce a singular value exactly equal to 0 in general : any difference of the smallest SVD value from 0 will be caused by numerical imprecision in the calculation of the SVD .", "question_id": 7826},
{"snippet": "linalg.matrix_rank(M, tol=None)", "intent": "Return matrix rank of array using SVD method Imagine that there is a column in `M` that is an exact ( in floating point ) linear combination of other columns in M. Computing the SVD on M will not produce a singular value exactly equal to 0 in general : any difference of the smallest SVD value from 0 will be caused by numerical imprecision in the calculation of the SVD . Rank of the array is the number of singular values of the array that are greater than `tol` .", "question_id": 7827},
{"snippet": "linalg.matrix_rank(M, hermitian=False)", "intent": "Return matrix rank of array using SVD method Imagine that there is a column in `M` that is an exact ( in floating point ) linear combination of other columns in M. Computing the SVD on M will not produce a singular value exactly equal to 0 in general : any difference of the smallest SVD value from 0 will be caused by numerical imprecision in the calculation of the SVD . With arguments `hermitian`.", "question_id": 7828},
{"snippet": "linalg.matrix_rank(M, tol=None, hermitian=False)", "intent": "Return matrix rank of array using SVD method Imagine that there is a column in `M` that is an exact ( in floating point ) linear combination of other columns in M. Computing the SVD on M will not produce a singular value exactly equal to 0 in general : any difference of the smallest SVD value from 0 will be caused by numerical imprecision in the calculation of the SVD . Rank of the array is the number of singular values of the array that are greater than `tol` . With arguments `hermitian`.", "question_id": 7829},
{"snippet": "numpy.asfortranarray(a)", "intent": "Return an array ( ndim > = 1 ) laid out in Fortran order in memory . With arguments `a`.", "question_id": 7830},
{"snippet": "numpy.asfortranarray(a, dtype=None)", "intent": "Return an array ( ndim > = 1 ) laid out in Fortran order in memory . With arguments `a`, `dtype`.", "question_id": 7831},
{"snippet": "numpy.asfortranarray(a, like=None)", "intent": "Return an array ( ndim > = 1 ) laid out in Fortran order in memory . With arguments `a`, `like`.", "question_id": 7832},
{"snippet": "numpy.asfortranarray(a, dtype=None, like=None)", "intent": "Return an array ( ndim > = 1 ) laid out in Fortran order in memory . With arguments `a`, `dtype`, `like`.", "question_id": 7833},
{"snippet": "record.all()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 7834},
{"snippet": "lib.format.write_array(fp, array)", "intent": "Write an `array` to an NPY file , including a header . With arguments `fp`.", "question_id": 7835},
{"snippet": "lib.format.write_array(fp, array, version=None)", "intent": "Write an `array` to an NPY file , including a header . With arguments `fp`, `version`.", "question_id": 7836},
{"snippet": "lib.format.write_array(fp, array, allow_pickle=True)", "intent": "Write an `array` to an NPY file , including a header . With arguments `fp`, `allow_pickle`.", "question_id": 7837},
{"snippet": "lib.format.write_array(fp, array, pickle_kwargs=None)", "intent": "Write an `array` to an NPY file , including a header . With arguments `fp`, `pickle_kwargs`.", "question_id": 7838},
{"snippet": "lib.format.write_array(fp, array, version=None, allow_pickle=True)", "intent": "Write an `array` to an NPY file , including a header . With arguments `fp`, `version`, `allow_pickle`.", "question_id": 7839},
{"snippet": "lib.format.write_array(fp, array, version=None, pickle_kwargs=None)", "intent": "Write an `array` to an NPY file , including a header . With arguments `fp`, `version`, `pickle_kwargs`.", "question_id": 7840},
{"snippet": "lib.format.write_array(fp, array, allow_pickle=True, pickle_kwargs=None)", "intent": "Write an `array` to an NPY file , including a header . With arguments `fp`, `allow_pickle`, `pickle_kwargs`.", "question_id": 7841},
{"snippet": "lib.format.write_array(fp, array, version=None, allow_pickle=True, pickle_kwargs=None)", "intent": "Write an `array` to an NPY file , including a header . With arguments `fp`, `version`, `allow_pickle`, `pickle_kwargs`.", "question_id": 7842},
{"snippet": "ma.MaskType.argmin()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 7843},
{"snippet": "ufunc.nin", "intent": "The number of inputs.", "question_id": 7844},
{"snippet": "polynomial.hermite_e.hermevander3d(x, y, z, deg)", "intent": "Pseudo-Vandermonde matrix of given degrees . Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points ( `x` , `y` , `z` ) .", "question_id": 7845},
{"snippet": "chararray.isalnum()", "intent": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character , false otherwise .", "question_id": 7846},
{"snippet": "dtype.isbuiltin", "intent": "Integer indicating how this dtype relates to the built-in dtypes.", "question_id": 7847},
{"snippet": "ma.MaskedArray.count()", "intent": "Count the non-masked elements of the array along the given `axis` .", "question_id": 7848},
{"snippet": "ma.MaskedArray.count(axis=None)", "intent": "Count the non-masked elements of the array along the given `axis` .", "question_id": 7849},
{"snippet": "ma.MaskedArray.count(keepdims=<no value>)", "intent": "Count the non-masked elements of the array along the given `axis` . With arguments `keepdims`.", "question_id": 7850},
{"snippet": "ma.MaskedArray.count(axis=None, keepdims=<no value>)", "intent": "Count the non-masked elements of the array along the given `axis` . With arguments `keepdims`.", "question_id": 7851},
{"snippet": "record.flat", "intent": "A 1-D view of the scalar.", "question_id": 7852},
{"snippet": "char.chararray.take(indices)", "intent": "Return an array formed from the elements of a at the given `indices` .", "question_id": 7853},
{"snippet": "char.chararray.take(indices, axis=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`.", "question_id": 7854},
{"snippet": "char.chararray.take(indices, out=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `out`.", "question_id": 7855},
{"snippet": "char.chararray.take(indices, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `mode`.", "question_id": 7856},
{"snippet": "char.chararray.take(indices, axis=None, out=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `out`.", "question_id": 7857},
{"snippet": "char.chararray.take(indices, axis=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `mode`.", "question_id": 7858},
{"snippet": "char.chararray.take(indices, out=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `out`, `mode`.", "question_id": 7859},
{"snippet": "char.chararray.take(indices, axis=None, out=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `out`, `mode`.", "question_id": 7860},
{"snippet": "distutils.ccompiler.CCompiler_spawn(self, cmd)", "intent": "Execute a command in a sub-process . With arguments `self`, `cmd`.", "question_id": 7861},
{"snippet": "distutils.ccompiler.CCompiler_spawn(self, cmd, display=None)", "intent": "Execute a command in a sub-process . With arguments `self`, `cmd`, `display`.", "question_id": 7862},
{"snippet": "polynomial.legendre.legval(x, c)", "intent": "Evaluate a Legendre series at points `x` . If `c` is of length n + 1 , this function returns the value :", "question_id": 7863},
{"snippet": "polynomial.legendre.legval(x, c, tensor=True)", "intent": "Evaluate a Legendre series at points `x` . If `c` is of length n + 1 , this function returns the value : If c is multidimensional , then the shape of the result depends on the value of `tensor` .", "question_id": 7864},
{"snippet": "ma.masked_array.itemset(*args)", "intent": "Insert scalar into an array ( scalar is cast to array \u2019 s dtype , if possible ) With arguments `*args`.", "question_id": 7865},
{"snippet": "char.chararray.repeat(repeats)", "intent": "Repeat elements of an array . With arguments `repeats`.", "question_id": 7866},
{"snippet": "char.chararray.repeat(repeats, axis=None)", "intent": "Repeat elements of an array . With arguments `repeats`, `axis`.", "question_id": 7867},
{"snippet": "ma.MaskedArray.sort()", "intent": "Sort the array , in-place", "question_id": 7868},
{"snippet": "ma.MaskedArray.sort(axis=- 1)", "intent": "Sort the array , in-place With arguments `axis`.", "question_id": 7869},
{"snippet": "ma.MaskedArray.sort(kind=None)", "intent": "Sort the array , in-place With arguments `kind`.", "question_id": 7870},
{"snippet": "ma.MaskedArray.sort(order=None)", "intent": "Sort the array , in-place With arguments `order`.", "question_id": 7871},
{"snippet": "ma.MaskedArray.sort(endwith=True)", "intent": "Sort the array , in-place With arguments `endwith`.", "question_id": 7872},
{"snippet": "ma.MaskedArray.sort(fill_value=None)", "intent": "Sort the array , in-place With arguments `fill_value`.", "question_id": 7873},
{"snippet": "ma.MaskedArray.sort(axis=- 1, kind=None)", "intent": "Sort the array , in-place With arguments `axis`, `kind`.", "question_id": 7874},
{"snippet": "ma.MaskedArray.sort(axis=- 1, order=None)", "intent": "Sort the array , in-place With arguments `axis`, `order`.", "question_id": 7875},
{"snippet": "ma.MaskedArray.sort(axis=- 1, endwith=True)", "intent": "Sort the array , in-place With arguments `axis`, `endwith`.", "question_id": 7876},
{"snippet": "ma.MaskedArray.sort(axis=- 1, fill_value=None)", "intent": "Sort the array , in-place With arguments `axis`, `fill_value`.", "question_id": 7877},
{"snippet": "char.endswith(a, suffix)", "intent": "Returns `a` boolean array which is True where the string element in a ends with `suffix` , otherwise False .", "question_id": 7878},
{"snippet": "char.endswith(a, suffix, start=0)", "intent": "Returns `a` boolean array which is True where the string element in a ends with `suffix` , otherwise False . With arguments `start`.", "question_id": 7879},
{"snippet": "char.endswith(a, suffix, end=None)", "intent": "Returns `a` boolean array which is True where the string element in a ends with `suffix` , otherwise False . With arguments `end`.", "question_id": 7880},
{"snippet": "char.endswith(a, suffix, start=0, end=None)", "intent": "Returns `a` boolean array which is True where the string element in a ends with `suffix` , otherwise False . With arguments `start`, `end`.", "question_id": 7881},
{"snippet": "ndarray.view(dtype, type)", "intent": "New view of array with the same data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) Viewing array data using a different `type` and dtype :", "question_id": 7882},
{"snippet": "ndarray.view(dtype)", "intent": "New view of array with the same data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . )", "question_id": 7883},
{"snippet": "ndarray.view()", "intent": "New view of array with the same data .", "question_id": 7884},
{"snippet": "numpy.tanh(x, /, signature, extobj)", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . With arguments `/`, `signature`, `extobj`.", "question_id": 7885},
{"snippet": "numpy.tanh(x, /, signature, extobj, out=None)", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `extobj`.", "question_id": 7886},
{"snippet": "numpy.tanh(x, /, signature, extobj, where=True)", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 7887},
{"snippet": "numpy.tanh(x, /, signature, extobj, casting='same_kind')", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 7888},
{"snippet": "numpy.tanh(x, /, signature, extobj, order='K')", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 7889},
{"snippet": "numpy.tanh(x, /, signature, extobj, dtype=None)", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 7890},
{"snippet": "numpy.tanh(x, /, signature, extobj, subok=True)", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 7891},
{"snippet": "numpy.tanh(x, /, signature, extobj, out=None, where=True)", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 7892},
{"snippet": "numpy.tanh(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 7893},
{"snippet": "numpy.tanh(x, /, signature, extobj, out=None, order='K')", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 7894},
{"snippet": "numpy.tanh(x, /, signature)", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . With arguments `/`, `signature`.", "question_id": 7895},
{"snippet": "numpy.tanh(x, /, signature, out=None)", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`.", "question_id": 7896},
{"snippet": "numpy.tanh(x, /, signature, where=True)", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . With arguments `/`, `signature`, `where`.", "question_id": 7897},
{"snippet": "numpy.tanh(x, /, signature, casting='same_kind')", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . With arguments `/`, `signature`, `casting`.", "question_id": 7898},
{"snippet": "numpy.tanh(x, /, signature, order='K')", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . With arguments `/`, `signature`, `order`.", "question_id": 7899},
{"snippet": "numpy.tanh(x, /, signature, dtype=None)", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . With arguments `/`, `signature`, `dtype`.", "question_id": 7900},
{"snippet": "numpy.tanh(x, /, signature, subok=True)", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . With arguments `/`, `signature`, `subok`.", "question_id": 7901},
{"snippet": "numpy.tanh(x, /, signature, out=None, where=True)", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `where`.", "question_id": 7902},
{"snippet": "numpy.tanh(x, /, signature, out=None, casting='same_kind')", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `casting`.", "question_id": 7903},
{"snippet": "numpy.tanh(x, /, signature, out=None, order='K')", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `order`.", "question_id": 7904},
{"snippet": "polynomial.laguerre.laggauss(deg)", "intent": "Gauss-Laguerre quadrature . These sample points and weights will correctly integrate polynomials of degree \\ ( 2 * `deg` - 1\\ ) or less over the interval \\ ( [ 0 , \\inf ] \\ ) with the weight function \\ ( f ( x ) = \\exp ( -x ) \\ ) .", "question_id": 7905},
{"snippet": "ma.MaskType.prod()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 7906},
{"snippet": "ufunc.reduceat(array, indices)", "intent": "Performs a ( local ) reduce with specified slices over a single `axis` . For i in range ( len ( `indices` ) ) , reduceat computes ufunc.reduce ( `array` [ indices [ i ] : indices [ i+1 ] ] ) , which becomes the i-th generalized \u201c row \u201d parallel to axis in the final result ( i.e. , in a 2-D array , for example , if axis = 0 , it becomes the i-th row , but if axis = 1 , it becomes the i-th column ) .", "question_id": 7907},
{"snippet": "ufunc.reduceat(array, indices, axis=0)", "intent": "Performs a ( local ) reduce with specified slices over a single `axis` . For i in range ( len ( `indices` ) ) , reduceat computes ufunc.reduce ( `array` [ indices [ i ] : indices [ i+1 ] ] ) , which becomes the i-th generalized \u201c row \u201d parallel to axis in the final result ( i.e. , in a 2-D array , for example , if axis = 0 , it becomes the i-th row , but if axis = 1 , it becomes the i-th column ) .", "question_id": 7908},
{"snippet": "ufunc.reduceat(array, indices, dtype=None)", "intent": "Performs a ( local ) reduce with specified slices over a single `axis` . For i in range ( len ( `indices` ) ) , reduceat computes ufunc.reduce ( `array` [ indices [ i ] : indices [ i+1 ] ] ) , which becomes the i-th generalized \u201c row \u201d parallel to axis in the final result ( i.e. , in a 2-D array , for example , if axis = 0 , it becomes the i-th row , but if axis = 1 , it becomes the i-th column ) . With arguments `dtype`.", "question_id": 7909},
{"snippet": "ufunc.reduceat(array, indices, out=None)", "intent": "Performs a ( local ) reduce with specified slices over a single `axis` . For i in range ( len ( `indices` ) ) , reduceat computes ufunc.reduce ( `array` [ indices [ i ] : indices [ i+1 ] ] ) , which becomes the i-th generalized \u201c row \u201d parallel to axis in the final result ( i.e. , in a 2-D array , for example , if axis = 0 , it becomes the i-th row , but if axis = 1 , it becomes the i-th column ) . With arguments `out`.", "question_id": 7910},
{"snippet": "ufunc.reduceat(array, indices, axis=0, dtype=None)", "intent": "Performs a ( local ) reduce with specified slices over a single `axis` . For i in range ( len ( `indices` ) ) , reduceat computes ufunc.reduce ( `array` [ indices [ i ] : indices [ i+1 ] ] ) , which becomes the i-th generalized \u201c row \u201d parallel to axis in the final result ( i.e. , in a 2-D array , for example , if axis = 0 , it becomes the i-th row , but if axis = 1 , it becomes the i-th column ) . With arguments `dtype`.", "question_id": 7911},
{"snippet": "ufunc.reduceat(array, indices, axis=0, out=None)", "intent": "Performs a ( local ) reduce with specified slices over a single `axis` . For i in range ( len ( `indices` ) ) , reduceat computes ufunc.reduce ( `array` [ indices [ i ] : indices [ i+1 ] ] ) , which becomes the i-th generalized \u201c row \u201d parallel to axis in the final result ( i.e. , in a 2-D array , for example , if axis = 0 , it becomes the i-th row , but if axis = 1 , it becomes the i-th column ) . With arguments `out`.", "question_id": 7912},
{"snippet": "ufunc.reduceat(array, indices, dtype=None, out=None)", "intent": "Performs a ( local ) reduce with specified slices over a single `axis` . For i in range ( len ( `indices` ) ) , reduceat computes ufunc.reduce ( `array` [ indices [ i ] : indices [ i+1 ] ] ) , which becomes the i-th generalized \u201c row \u201d parallel to axis in the final result ( i.e. , in a 2-D array , for example , if axis = 0 , it becomes the i-th row , but if axis = 1 , it becomes the i-th column ) . With arguments `dtype`, `out`.", "question_id": 7913},
{"snippet": "ufunc.reduceat(array, indices, axis=0, dtype=None, out=None)", "intent": "Performs a ( local ) reduce with specified slices over a single `axis` . For i in range ( len ( `indices` ) ) , reduceat computes ufunc.reduce ( `array` [ indices [ i ] : indices [ i+1 ] ] ) , which becomes the i-th generalized \u201c row \u201d parallel to axis in the final result ( i.e. , in a 2-D array , for example , if axis = 0 , it becomes the i-th row , but if axis = 1 , it becomes the i-th column ) . With arguments `dtype`, `out`.", "question_id": 7914},
{"snippet": "numpy.broadcast", "intent": "Produce an object that mimics broadcasting.", "question_id": 7915},
{"snippet": "random.Generator.choice(a)", "intent": "Generates `a` random sample from a given array", "question_id": 7916},
{"snippet": "random.Generator.choice(a, size=None)", "intent": "Generates `a` random sample from a given array Generate a uniform random sample from np.arange ( 5 ) of `size` 3 :", "question_id": 7917},
{"snippet": "random.Generator.choice(a, replace=True)", "intent": "Generates `a` random sample from a given array With arguments `replace`.", "question_id": 7918},
{"snippet": "random.Generator.choice(a, p=None)", "intent": "Generates `a` random sample from a given array Setting user-specified probabilities through `p` uses a more general but less efficient sampler than the default .", "question_id": 7919},
{"snippet": "random.Generator.choice(a, axis=0)", "intent": "Generates `a` random sample from a given array Generate a uniform random sample from a 2-D array along the first `axis` ( the default ) , without replacement :", "question_id": 7920},
{"snippet": "random.Generator.choice(a, shuffle=True)", "intent": "Generates `a` random sample from a given array With arguments `shuffle`.", "question_id": 7921},
{"snippet": "random.Generator.choice(a, size=None, replace=True)", "intent": "Generates `a` random sample from a given array Generate a uniform random sample from np.arange ( 5 ) of `size` 3 : With arguments `replace`.", "question_id": 7922},
{"snippet": "random.Generator.choice(a, size=None, p=None)", "intent": "Generates `a` random sample from a given array Generate a uniform random sample from np.arange ( 5 ) of `size` 3 : Setting user-specified probabilities through `p` uses a more general but less efficient sampler than the default .", "question_id": 7923},
{"snippet": "random.Generator.choice(a, size=None, axis=0)", "intent": "Generates `a` random sample from a given array Generate a uniform random sample from np.arange ( 5 ) of `size` 3 : Generate a uniform random sample from a 2-D array along the first `axis` ( the default ) , without replacement :", "question_id": 7924},
{"snippet": "random.Generator.choice(a, size=None, shuffle=True)", "intent": "Generates `a` random sample from a given array Generate a uniform random sample from np.arange ( 5 ) of `size` 3 : With arguments `shuffle`.", "question_id": 7925},
{"snippet": "random.standard_gamma(shape)", "intent": "Draw samples from a standard Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and scale=1 .", "question_id": 7926},
{"snippet": "random.standard_gamma(shape, size=None)", "intent": "Draw samples from a standard Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and scale=1 . With arguments `size`.", "question_id": 7927},
{"snippet": "numpy.in1d(ar1, ar2)", "intent": "Test whether each element of a 1-D array is also present in a second array . Returns a boolean array the same length as `ar1` that is True where an element of ar1 is in `ar2` and False otherwise .", "question_id": 7928},
{"snippet": "numpy.in1d(ar1, ar2, assume_unique=False)", "intent": "Test whether each element of a 1-D array is also present in a second array . Returns a boolean array the same length as `ar1` that is True where an element of ar1 is in `ar2` and False otherwise . With arguments `assume_unique`.", "question_id": 7929},
{"snippet": "numpy.in1d(ar1, ar2, invert=False)", "intent": "Test whether each element of a 1-D array is also present in a second array . Returns a boolean array the same length as `ar1` that is True where an element of ar1 is in `ar2` and False otherwise . With arguments `invert`.", "question_id": 7930},
{"snippet": "numpy.in1d(ar1, ar2, assume_unique=False, invert=False)", "intent": "Test whether each element of a 1-D array is also present in a second array . Returns a boolean array the same length as `ar1` that is True where an element of ar1 is in `ar2` and False otherwise . With arguments `assume_unique`, `invert`.", "question_id": 7931},
{"snippet": "numpy.ascontiguousarray(a)", "intent": "Return `a` contiguous array ( ndim > = 1 ) in memory ( C order ) .", "question_id": 7932},
{"snippet": "numpy.ascontiguousarray(a, dtype=None)", "intent": "Return `a` contiguous array ( ndim > = 1 ) in memory ( C order ) . With arguments `dtype`.", "question_id": 7933},
{"snippet": "numpy.ascontiguousarray(a, like=None)", "intent": "Return `a` contiguous array ( ndim > = 1 ) in memory ( C order ) . With arguments `like`.", "question_id": 7934},
{"snippet": "numpy.ascontiguousarray(a, dtype=None, like=None)", "intent": "Return `a` contiguous array ( ndim > = 1 ) in memory ( C order ) . With arguments `dtype`, `like`.", "question_id": 7935},
{"snippet": "polynomial.chebyshev.chebval2d(x, y, c)", "intent": "Evaluate a 2-D Chebyshev series at points ( `x` , `y` ) . In either case , either x and y or their elements must support multiplication and addition both with themselves and with the elements of `c` .", "question_id": 7936},
{"snippet": "random.RandomState.triangular(left, mode, right)", "intent": "Draw samples from the triangular distribution over the interval [ `left` , `right` ] . The triangular distribution is a continuous probability distribution with lower limit left , peak at `mode` , and upper limit right .", "question_id": 7937},
{"snippet": "random.RandomState.triangular(left, mode, right, size=None)", "intent": "Draw samples from the triangular distribution over the interval [ `left` , `right` ] . The triangular distribution is a continuous probability distribution with lower limit left , peak at `mode` , and upper limit right . With arguments `size`.", "question_id": 7938},
{"snippet": "ma.clip(a, a_min, a_max, **kwargs)", "intent": "Clip ( limit ) the values in an array . Equivalent to but faster than np.minimum ( `a_max` , np.maximum ( `a` , `a_min` ) ) . With arguments `**kwargs`.", "question_id": 7939},
{"snippet": "ma.clip(a, a_min, a_max, **kwargs, out=None)", "intent": "Clip ( limit ) the values in an array . Equivalent to but faster than np.minimum ( `a_max` , np.maximum ( `a` , `a_min` ) ) . With arguments `**kwargs`, `out`.", "question_id": 7940},
{"snippet": "polynomial.laguerre.laggrid3d(x, y, z, c)", "intent": "Evaluate a 3-D Laguerre series on the Cartesian product of `x` , `y` , and `z` . where the points ( a , b , `c` ) consist of all triples formed by taking a from x , b from y , and c from z .", "question_id": 7941},
{"snippet": "ma.MaskedArray.size", "intent": "Number of elements in the array.", "question_id": 7942},
{"snippet": "ma.masked_array.harden_mask()", "intent": "Force the mask to hard .", "question_id": 7943},
{"snippet": "polynomial.laguerre.Laguerre.identity()", "intent": "Identity function .", "question_id": 7944},
{"snippet": "polynomial.laguerre.Laguerre.identity(domain=None)", "intent": "Identity function . With arguments `domain`.", "question_id": 7945},
{"snippet": "polynomial.laguerre.Laguerre.identity(window=None)", "intent": "Identity function . With arguments `window`.", "question_id": 7946},
{"snippet": "polynomial.laguerre.Laguerre.identity(domain=None, window=None)", "intent": "Identity function . With arguments `domain`, `window`.", "question_id": 7947},
{"snippet": "random.Generator.standard_cauchy()", "intent": "Draw samples from a standard Cauchy distribution with mode = 0 .", "question_id": 7948},
{"snippet": "random.Generator.standard_cauchy(size=None)", "intent": "Draw samples from a standard Cauchy distribution with mode = 0 . With arguments `size`.", "question_id": 7949},
{"snippet": "char.chararray.strides", "intent": "Tuple of bytes to step in each dimension when traversing an array.", "question_id": 7950},
{"snippet": "ma.count_masked(arr)", "intent": "Count the number of masked elements along the given `axis` . With arguments `arr`.", "question_id": 7951},
{"snippet": "ma.count_masked(arr, axis=None)", "intent": "Count the number of masked elements along the given `axis` . With arguments `arr`.", "question_id": 7952},
{"snippet": "record.item()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 7953},
{"snippet": "char.chararray.getfield(dtype)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements .", "question_id": 7954},
{"snippet": "char.chararray.getfield(dtype, offset=0)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements . The values in the view are determined by the given type and the `offset` into the current array in bytes .", "question_id": 7955},
{"snippet": "ndarray.all()", "intent": "Returns True if all elements evaluate to True .", "question_id": 7956},
{"snippet": "ndarray.all(axis=None)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`.", "question_id": 7957},
{"snippet": "ndarray.all(out=None)", "intent": "Returns True if all elements evaluate to True . With arguments `out`.", "question_id": 7958},
{"snippet": "ndarray.all(keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `keepdims`.", "question_id": 7959},
{"snippet": "ndarray.all(where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `where`.", "question_id": 7960},
{"snippet": "ndarray.all(axis=None, out=None)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `out`.", "question_id": 7961},
{"snippet": "ndarray.all(axis=None, keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `keepdims`.", "question_id": 7962},
{"snippet": "ndarray.all(axis=None, where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `where`.", "question_id": 7963},
{"snippet": "ndarray.all(out=None, keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `out`, `keepdims`.", "question_id": 7964},
{"snippet": "ndarray.all(out=None, where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `out`, `where`.", "question_id": 7965},
{"snippet": "ma.ptp(obj)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `obj`.", "question_id": 7966},
{"snippet": "ma.ptp(obj, axis=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `obj`, `axis`.", "question_id": 7967},
{"snippet": "ma.ptp(obj, out=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `obj`, `out`.", "question_id": 7968},
{"snippet": "ma.ptp(obj, fill_value=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `obj`, `fill_value`.", "question_id": 7969},
{"snippet": "ma.ptp(obj, keepdims=<no value>)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `obj`, `keepdims`.", "question_id": 7970},
{"snippet": "ma.ptp(obj, axis=None, out=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `obj`, `axis`, `out`.", "question_id": 7971},
{"snippet": "ma.ptp(obj, axis=None, fill_value=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `obj`, `axis`, `fill_value`.", "question_id": 7972},
{"snippet": "ma.ptp(obj, axis=None, keepdims=<no value>)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `obj`, `axis`, `keepdims`.", "question_id": 7973},
{"snippet": "ma.ptp(obj, out=None, fill_value=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `obj`, `out`, `fill_value`.", "question_id": 7974},
{"snippet": "ma.ptp(obj, out=None, keepdims=<no value>)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `obj`, `out`, `keepdims`.", "question_id": 7975},
{"snippet": "ndarray.ptp()", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` .", "question_id": 7976},
{"snippet": "ndarray.ptp(axis=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` .", "question_id": 7977},
{"snippet": "ndarray.ptp(out=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`.", "question_id": 7978},
{"snippet": "ndarray.ptp(keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `keepdims`.", "question_id": 7979},
{"snippet": "ndarray.ptp(axis=None, out=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`.", "question_id": 7980},
{"snippet": "ndarray.ptp(axis=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `keepdims`.", "question_id": 7981},
{"snippet": "ndarray.ptp(out=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`, `keepdims`.", "question_id": 7982},
{"snippet": "ndarray.ptp(axis=None, out=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`, `keepdims`.", "question_id": 7983},
{"snippet": "char.chararray.tostring()", "intent": "A compatibility alias for tobytes , with exactly the same behavior .", "question_id": 7984},
{"snippet": "char.chararray.tostring(order='C')", "intent": "A compatibility alias for tobytes , with exactly the same behavior . With arguments `order`.", "question_id": 7985},
{"snippet": "numpy.polyder(p)", "intent": "Return the derivative of the specified order of a polynomial . With arguments `p`.", "question_id": 7986},
{"snippet": "numpy.polyder(p, m=1)", "intent": "Return the derivative of the specified order of a polynomial . With arguments `p`, `m`.", "question_id": 7987},
{"snippet": "numpy.flip(m)", "intent": "Reverse the order of elements in an array along the given `axis` . flip ( `m` , 0 ) is equivalent to flipud ( m ) .", "question_id": 7988},
{"snippet": "numpy.flip(m, axis=None)", "intent": "Reverse the order of elements in an array along the given `axis` . flip ( `m` , 0 ) is equivalent to flipud ( m ) .", "question_id": 7989},
{"snippet": "chararray.swapaxes(axis1, axis2)", "intent": "Return a view of the array with `axis1` and `axis2` interchanged .", "question_id": 7990},
{"snippet": "ma.MaskedArray.__ror__(value, /)", "intent": "Return value|self . With arguments `value`, `/`.", "question_id": 7991},
{"snippet": "recarray.tobytes()", "intent": "Construct Python bytes containing the raw data bytes in the array .", "question_id": 7992},
{"snippet": "recarray.tobytes(order='C')", "intent": "Construct Python bytes containing the raw data bytes in the array . This behavior is controlled by the `order` parameter .", "question_id": 7993},
{"snippet": "numpy.identity(n)", "intent": "Return the identity array . With arguments `n`.", "question_id": 7994},
{"snippet": "numpy.identity(n, dtype=None)", "intent": "Return the identity array . With arguments `n`, `dtype`.", "question_id": 7995},
{"snippet": "numpy.identity(n, like=None)", "intent": "Return the identity array . With arguments `n`, `like`.", "question_id": 7996},
{"snippet": "numpy.identity(n, dtype=None, like=None)", "intent": "Return the identity array . With arguments `n`, `dtype`, `like`.", "question_id": 7997},
{"snippet": "char.chararray.sum()", "intent": "Return the sum of the array elements over the given `axis` .", "question_id": 7998},
{"snippet": "char.chararray.sum(axis=None)", "intent": "Return the sum of the array elements over the given `axis` .", "question_id": 7999},
{"snippet": "char.chararray.sum(dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 8000},
{"snippet": "char.chararray.sum(out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`.", "question_id": 8001},
{"snippet": "char.chararray.sum(keepdims=False)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`.", "question_id": 8002},
{"snippet": "char.chararray.sum(initial=0)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `initial`.", "question_id": 8003},
{"snippet": "char.chararray.sum(where=True)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `where`.", "question_id": 8004},
{"snippet": "char.chararray.sum(axis=None, dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`.", "question_id": 8005},
{"snippet": "char.chararray.sum(axis=None, out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`.", "question_id": 8006},
{"snippet": "char.chararray.sum(axis=None, keepdims=False)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`.", "question_id": 8007},
{"snippet": "polynomial.hermite.hermvander2d(x, y, deg)", "intent": "Pseudo-Vandermonde matrix of given degrees . Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points ( `x` , `y` ) .", "question_id": 8008},
{"snippet": "ndarray.__copy__()", "intent": "Used if copy.copy is called on an array .", "question_id": 8009},
{"snippet": "ma.masked_array.any()", "intent": "Returns True if any of the elements of a evaluate to True .", "question_id": 8010},
{"snippet": "ma.masked_array.any(axis=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`.", "question_id": 8011},
{"snippet": "ma.masked_array.any(out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`.", "question_id": 8012},
{"snippet": "ma.masked_array.any(keepdims=<no value>)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `keepdims`.", "question_id": 8013},
{"snippet": "ma.masked_array.any(axis=None, out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `out`.", "question_id": 8014},
{"snippet": "ma.masked_array.any(axis=None, keepdims=<no value>)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `keepdims`.", "question_id": 8015},
{"snippet": "ma.masked_array.any(out=None, keepdims=<no value>)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`, `keepdims`.", "question_id": 8016},
{"snippet": "ma.masked_array.any(axis=None, out=None, keepdims=<no value>)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `out`, `keepdims`.", "question_id": 8017},
{"snippet": "ndarray.reshape(shape)", "intent": "Returns an array containing the same data with a new `shape` .", "question_id": 8018},
{"snippet": "ndarray.reshape(shape, order='C')", "intent": "Returns an array containing the same data with a new `shape` . With arguments `order`.", "question_id": 8019},
{"snippet": "chararray.split()", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string .", "question_id": 8020},
{"snippet": "chararray.split(sep=None)", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string .", "question_id": 8021},
{"snippet": "chararray.split(maxsplit=None)", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string . With arguments `maxsplit`.", "question_id": 8022},
{"snippet": "chararray.split(sep=None, maxsplit=None)", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string . With arguments `maxsplit`.", "question_id": 8023},
{"snippet": "chararray.decode()", "intent": "Calls str.decode element-wise .", "question_id": 8024},
{"snippet": "chararray.decode(encoding=None)", "intent": "Calls str.decode element-wise . With arguments `encoding`.", "question_id": 8025},
{"snippet": "chararray.decode(errors=None)", "intent": "Calls str.decode element-wise . With arguments `errors`.", "question_id": 8026},
{"snippet": "chararray.decode(encoding=None, errors=None)", "intent": "Calls str.decode element-wise . With arguments `encoding`, `errors`.", "question_id": 8027},
{"snippet": "distutils.ccompiler.CCompiler_get_version(self)", "intent": "Return compiler version , or None if compiler is not available . With arguments `self`.", "question_id": 8028},
{"snippet": "distutils.ccompiler.CCompiler_get_version(self, force=False)", "intent": "Return compiler version , or None if compiler is not available . With arguments `self`, `force`.", "question_id": 8029},
{"snippet": "distutils.ccompiler.CCompiler_get_version(self, ok_status=0)", "intent": "Return compiler version , or None if compiler is not available . With arguments `self`, `ok_status`.", "question_id": 8030},
{"snippet": "distutils.ccompiler.CCompiler_get_version(self, force=False, ok_status=0)", "intent": "Return compiler version , or None if compiler is not available . With arguments `self`, `force`, `ok_status`.", "question_id": 8031},
{"snippet": "distutils.ccompiler.CCompiler_get_version()", "intent": "Return compiler version , or None if compiler is not available .", "question_id": 8032},
{"snippet": "distutils.ccompiler.CCompiler_get_version(force=False)", "intent": "Return compiler version , or None if compiler is not available . With arguments `force`.", "question_id": 8033},
{"snippet": "distutils.ccompiler.CCompiler_get_version(ok_status=0)", "intent": "Return compiler version , or None if compiler is not available . With arguments `ok_status`.", "question_id": 8034},
{"snippet": "distutils.ccompiler.CCompiler_get_version(force=False, ok_status=0)", "intent": "Return compiler version , or None if compiler is not available . With arguments `force`, `ok_status`.", "question_id": 8035},
{"snippet": "testing.assert_raises_regex(exception_class, expected_regexp, callable, *args, **kwargs) assert_raises_regex(exception_class, expected_regexp)", "intent": "Fail unless an exception of class `exception_class` and with message that matches `expected_regexp` is thrown by `callable` when invoked with arguments args and keyword arguments kwargs . With arguments `*args`, `**kwargs) assert_raises_regex(exception_class`.", "question_id": 8036},
{"snippet": "numpy.copyto(dst, src)", "intent": "Copies values from one array to another , broadcasting as necessary . With arguments `dst`, `src`.", "question_id": 8037},
{"snippet": "numpy.copyto(dst, src, casting='same_kind')", "intent": "Copies values from one array to another , broadcasting as necessary . Raises a TypeError if the `casting` rule is violated , and if `where` is provided , it selects which elements to copy . With arguments `dst`, `src`.", "question_id": 8038},
{"snippet": "numpy.copyto(dst, src, where=True)", "intent": "Copies values from one array to another , broadcasting as necessary . Raises a TypeError if the `casting` rule is violated , and if `where` is provided , it selects which elements to copy . With arguments `dst`, `src`.", "question_id": 8039},
{"snippet": "numpy.copyto(dst, src, casting='same_kind', where=True)", "intent": "Copies values from one array to another , broadcasting as necessary . Raises a TypeError if the `casting` rule is violated , and if `where` is provided , it selects which elements to copy . With arguments `dst`, `src`.", "question_id": 8040},
{"snippet": "polynomial.laguerre.lagtrim(c)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . With arguments `c`.", "question_id": 8041},
{"snippet": "polynomial.laguerre.lagtrim(c, tol=0)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . \u201c Small \u201d means \u201c small in absolute value \u201d and is controlled by the parameter `tol` ; \u201c trailing \u201d means highest order coefficient ( s ) , e.g. , in [ 0 , 1 , 1 , 0 , 0 ] ( which represents 0 + x + x * * 2 + 0 * x * * 3 + 0 * x * * 4 ) both the 3-rd and 4-th order coefficients would be \u201c trimmed . \u201d With arguments `c`.", "question_id": 8042},
{"snippet": "ma.array(data)", "intent": "An array class with possibly masked values . The `mask` can be initialized with an array of boolean values with the same shape as `data` .", "question_id": 8043},
{"snippet": "ma.array(data, dtype=None)", "intent": "An array class with possibly masked values . The `mask` can be initialized with an array of boolean values with the same shape as `data` . With arguments `dtype`.", "question_id": 8044},
{"snippet": "ma.array(data, copy=False)", "intent": "An array class with possibly masked values . The `mask` can be initialized with an array of boolean values with the same shape as `data` . With arguments `copy`.", "question_id": 8045},
{"snippet": "ma.array(data, order=None)", "intent": "An array class with possibly masked values . The `mask` can be initialized with an array of boolean values with the same shape as `data` . With arguments `order`.", "question_id": 8046},
{"snippet": "ma.array(data, mask=False)", "intent": "An array class with possibly masked values . The `mask` can be initialized with an array of boolean values with the same shape as `data` .", "question_id": 8047},
{"snippet": "ma.array(data, fill_value=None)", "intent": "An array class with possibly masked values . The `mask` can be initialized with an array of boolean values with the same shape as `data` . With arguments `fill_value`.", "question_id": 8048},
{"snippet": "ma.array(data, keep_mask=True)", "intent": "An array class with possibly masked values . The `mask` can be initialized with an array of boolean values with the same shape as `data` . With arguments `keep_mask`.", "question_id": 8049},
{"snippet": "ma.array(data, hard_mask=False)", "intent": "An array class with possibly masked values . The `mask` can be initialized with an array of boolean values with the same shape as `data` . With arguments `hard_mask`.", "question_id": 8050},
{"snippet": "ma.array(data, shrink=True)", "intent": "An array class with possibly masked values . The `mask` can be initialized with an array of boolean values with the same shape as `data` . With arguments `shrink`.", "question_id": 8051},
{"snippet": "ma.array(data, subok=True)", "intent": "An array class with possibly masked values . The `mask` can be initialized with an array of boolean values with the same shape as `data` . With arguments `subok`.", "question_id": 8052},
{"snippet": "polynomial.polynomial.Polynomial.mapparms()", "intent": "Return the mapping parameters .", "question_id": 8053},
{"snippet": "dtype.newbyteorder(/)", "intent": "Return a new dtype with a different byte order . With arguments `/`.", "question_id": 8054},
{"snippet": "dtype.newbyteorder(/, new_order='S')", "intent": "Return a new dtype with a different byte order . With arguments `/`, `new_order`.", "question_id": 8055},
{"snippet": "lib.format.descr_to_dtype(descr)", "intent": "Returns a dtype based off the given description . With arguments `descr`.", "question_id": 8056},
{"snippet": "numpy.log10(x, /, signature, extobj)", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `extobj`.", "question_id": 8057},
{"snippet": "numpy.log10(x, /, signature, extobj, out=None)", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 8058},
{"snippet": "numpy.log10(x, /, signature, extobj, where=True)", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 8059},
{"snippet": "numpy.log10(x, /, signature, extobj, casting='same_kind')", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 8060},
{"snippet": "numpy.log10(x, /, signature, extobj, order='K')", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 8061},
{"snippet": "numpy.log10(x, /, signature, extobj, dtype=None)", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 8062},
{"snippet": "numpy.log10(x, /, signature, extobj, subok=True)", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 8063},
{"snippet": "numpy.log10(x, /, signature, extobj, out=None, where=True)", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 8064},
{"snippet": "numpy.log10(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 8065},
{"snippet": "numpy.log10(x, /, signature, extobj, out=None, order='K')", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 8066},
{"snippet": "numpy.log10(x, /, signature)", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`.", "question_id": 8067},
{"snippet": "numpy.log10(x, /, signature, out=None)", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `out`.", "question_id": 8068},
{"snippet": "numpy.log10(x, /, signature, where=True)", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `where`.", "question_id": 8069},
{"snippet": "numpy.log10(x, /, signature, casting='same_kind')", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `casting`.", "question_id": 8070},
{"snippet": "numpy.log10(x, /, signature, order='K')", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `order`.", "question_id": 8071},
{"snippet": "numpy.log10(x, /, signature, dtype=None)", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `dtype`.", "question_id": 8072},
{"snippet": "numpy.log10(x, /, signature, subok=True)", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `subok`.", "question_id": 8073},
{"snippet": "numpy.log10(x, /, signature, out=None, where=True)", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `out`, `where`.", "question_id": 8074},
{"snippet": "numpy.log10(x, /, signature, out=None, casting='same_kind')", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 8075},
{"snippet": "numpy.log10(x, /, signature, out=None, order='K')", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `out`, `order`.", "question_id": 8076},
{"snippet": "polynomial.chebyshev.chebfromroots(roots)", "intent": "Generate a Chebyshev series with given `roots` .", "question_id": 8077},
{"snippet": "random.Generator.triangular(left, mode, right)", "intent": "Draw samples from the triangular distribution over the interval [ `left` , `right` ] . The triangular distribution is a continuous probability distribution with lower limit left , peak at `mode` , and upper limit right .", "question_id": 8078},
{"snippet": "random.Generator.triangular(left, mode, right, size=None)", "intent": "Draw samples from the triangular distribution over the interval [ `left` , `right` ] . The triangular distribution is a continuous probability distribution with lower limit left , peak at `mode` , and upper limit right . With arguments `size`.", "question_id": 8079},
{"snippet": "linalg.svd(a)", "intent": "Singular Value Decomposition . When `a` is a 2D array , it is factorized as u @ np.diag ( s ) @ vh = ( u * s ) @ vh , where u and vh are 2D unitary arrays and s is a 1D array of a \u2019 s singular values .", "question_id": 8080},
{"snippet": "linalg.svd(a, full_matrices=True)", "intent": "Singular Value Decomposition . When `a` is a 2D array , it is factorized as u @ np.diag ( s ) @ vh = ( u * s ) @ vh , where u and vh are 2D unitary arrays and s is a 1D array of a \u2019 s singular values . With arguments `full_matrices`.", "question_id": 8081},
{"snippet": "linalg.svd(a, compute_uv=True)", "intent": "Singular Value Decomposition . When `a` is a 2D array , it is factorized as u @ np.diag ( s ) @ vh = ( u * s ) @ vh , where u and vh are 2D unitary arrays and s is a 1D array of a \u2019 s singular values . With arguments `compute_uv`.", "question_id": 8082},
{"snippet": "linalg.svd(a, hermitian=False)", "intent": "Singular Value Decomposition . When `a` is a 2D array , it is factorized as u @ np.diag ( s ) @ vh = ( u * s ) @ vh , where u and vh are 2D unitary arrays and s is a 1D array of a \u2019 s singular values . With arguments `hermitian`.", "question_id": 8083},
{"snippet": "linalg.svd(a, full_matrices=True, compute_uv=True)", "intent": "Singular Value Decomposition . When `a` is a 2D array , it is factorized as u @ np.diag ( s ) @ vh = ( u * s ) @ vh , where u and vh are 2D unitary arrays and s is a 1D array of a \u2019 s singular values . With arguments `full_matrices`, `compute_uv`.", "question_id": 8084},
{"snippet": "linalg.svd(a, full_matrices=True, hermitian=False)", "intent": "Singular Value Decomposition . When `a` is a 2D array , it is factorized as u @ np.diag ( s ) @ vh = ( u * s ) @ vh , where u and vh are 2D unitary arrays and s is a 1D array of a \u2019 s singular values . With arguments `full_matrices`, `hermitian`.", "question_id": 8085},
{"snippet": "linalg.svd(a, compute_uv=True, hermitian=False)", "intent": "Singular Value Decomposition . When `a` is a 2D array , it is factorized as u @ np.diag ( s ) @ vh = ( u * s ) @ vh , where u and vh are 2D unitary arrays and s is a 1D array of a \u2019 s singular values . With arguments `compute_uv`, `hermitian`.", "question_id": 8086},
{"snippet": "linalg.svd(a, full_matrices=True, compute_uv=True, hermitian=False)", "intent": "Singular Value Decomposition . When `a` is a 2D array , it is factorized as u @ np.diag ( s ) @ vh = ( u * s ) @ vh , where u and vh are 2D unitary arrays and s is a 1D array of a \u2019 s singular values . With arguments `full_matrices`, `compute_uv`, `hermitian`.", "question_id": 8087},
{"snippet": "char.expandtabs(a)", "intent": "Return `a` copy of each string element where all tab characters are replaced by one or more spaces .", "question_id": 8088},
{"snippet": "char.expandtabs(a, tabsize=8)", "intent": "Return `a` copy of each string element where all tab characters are replaced by one or more spaces . Return a copy of each string element where all tab characters are replaced by one or more spaces , depending on the current column and the given `tabsize` .", "question_id": 8089},
{"snippet": "numpy.polysub(a1, a2)", "intent": "Difference ( subtraction ) of two polynomials . Given two polynomials `a1` and `a2` , returns a1 - a2 .", "question_id": 8090},
{"snippet": "recarray.data", "intent": "Python buffer object pointing to the start of the array\u2019s data.", "question_id": 8091},
{"snippet": "random.laplace()", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) .", "question_id": 8092},
{"snippet": "random.laplace(loc=0.0)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `loc`.", "question_id": 8093},
{"snippet": "random.laplace(scale=1.0)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) .", "question_id": 8094},
{"snippet": "random.laplace(size=None)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `size`.", "question_id": 8095},
{"snippet": "random.laplace(loc=0.0, scale=1.0)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `loc`.", "question_id": 8096},
{"snippet": "random.laplace(loc=0.0, size=None)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `loc`, `size`.", "question_id": 8097},
{"snippet": "random.laplace(scale=1.0, size=None)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `size`.", "question_id": 8098},
{"snippet": "random.laplace(loc=0.0, scale=1.0, size=None)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `loc`, `size`.", "question_id": 8099},
{"snippet": "ndarray.__iand__(value, /)", "intent": "Return self & =value . With arguments `value`, `/`.", "question_id": 8100},
{"snippet": "numpy.log2(x, /, signature, extobj)", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `extobj`.", "question_id": 8101},
{"snippet": "numpy.log2(x, /, signature, extobj, out=None)", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 8102},
{"snippet": "numpy.log2(x, /, signature, extobj, where=True)", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 8103},
{"snippet": "numpy.log2(x, /, signature, extobj, casting='same_kind')", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 8104},
{"snippet": "numpy.log2(x, /, signature, extobj, order='K')", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 8105},
{"snippet": "numpy.log2(x, /, signature, extobj, dtype=None)", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 8106},
{"snippet": "numpy.log2(x, /, signature, extobj, subok=True)", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 8107},
{"snippet": "numpy.log2(x, /, signature, extobj, out=None, where=True)", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 8108},
{"snippet": "numpy.log2(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 8109},
{"snippet": "numpy.log2(x, /, signature, extobj, out=None, order='K')", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 8110},
{"snippet": "numpy.log2(x, /, signature)", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`.", "question_id": 8111},
{"snippet": "numpy.log2(x, /, signature, out=None)", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `out`.", "question_id": 8112},
{"snippet": "numpy.log2(x, /, signature, where=True)", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `where`.", "question_id": 8113},
{"snippet": "numpy.log2(x, /, signature, casting='same_kind')", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `casting`.", "question_id": 8114},
{"snippet": "numpy.log2(x, /, signature, order='K')", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `order`.", "question_id": 8115},
{"snippet": "numpy.log2(x, /, signature, dtype=None)", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `dtype`.", "question_id": 8116},
{"snippet": "numpy.log2(x, /, signature, subok=True)", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `subok`.", "question_id": 8117},
{"snippet": "numpy.log2(x, /, signature, out=None, where=True)", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `out`, `where`.", "question_id": 8118},
{"snippet": "numpy.log2(x, /, signature, out=None, casting='same_kind')", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 8119},
{"snippet": "numpy.log2(x, /, signature, out=None, order='K')", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `out`, `order`.", "question_id": 8120},
{"snippet": "numpy.issubsctype(arg1, arg2)", "intent": "Determine if the first argument is a subclass of the second argument . With arguments `arg1`, `arg2`.", "question_id": 8121},
{"snippet": "char.rpartition(a, sep)", "intent": "Partition ( split ) each element around the right-most separator . For each element in `a` , split the element as the last occurrence of `sep` , and return 3 strings containing the part before the separator , the separator itself , and the part after the separator .", "question_id": 8122},
{"snippet": "random.Generator.permuted(x)", "intent": "Randomly permute `x` along `axis` axis .", "question_id": 8123},
{"snippet": "random.Generator.permuted(x, axis=None)", "intent": "Randomly permute `x` along `axis` axis .", "question_id": 8124},
{"snippet": "random.Generator.permuted(x, out=None)", "intent": "Randomly permute `x` along `axis` axis . To shuffle the rows of x in-place , pass x as the `out` parameter :", "question_id": 8125},
{"snippet": "random.Generator.permuted(x, axis=None, out=None)", "intent": "Randomly permute `x` along `axis` axis . To shuffle the rows of x in-place , pass x as the `out` parameter :", "question_id": 8126},
{"snippet": "numpy.log(x, /, signature, extobj)", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `extobj`.", "question_id": 8127},
{"snippet": "numpy.log(x, /, signature, extobj, out=None)", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 8128},
{"snippet": "numpy.log(x, /, signature, extobj, where=True)", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 8129},
{"snippet": "numpy.log(x, /, signature, extobj, casting='same_kind')", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 8130},
{"snippet": "numpy.log(x, /, signature, extobj, order='K')", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 8131},
{"snippet": "numpy.log(x, /, signature, extobj, dtype=None)", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 8132},
{"snippet": "numpy.log(x, /, signature, extobj, subok=True)", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 8133},
{"snippet": "numpy.log(x, /, signature, extobj, out=None, where=True)", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 8134},
{"snippet": "numpy.log(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 8135},
{"snippet": "numpy.log(x, /, signature, extobj, out=None, order='K')", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 8136},
{"snippet": "numpy.log(x, /, signature)", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`.", "question_id": 8137},
{"snippet": "numpy.log(x, /, signature, out=None)", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `out`.", "question_id": 8138},
{"snippet": "numpy.log(x, /, signature, where=True)", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `where`.", "question_id": 8139},
{"snippet": "numpy.log(x, /, signature, casting='same_kind')", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `casting`.", "question_id": 8140},
{"snippet": "numpy.log(x, /, signature, order='K')", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `order`.", "question_id": 8141},
{"snippet": "numpy.log(x, /, signature, dtype=None)", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `dtype`.", "question_id": 8142},
{"snippet": "numpy.log(x, /, signature, subok=True)", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `subok`.", "question_id": 8143},
{"snippet": "numpy.log(x, /, signature, out=None, where=True)", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `out`, `where`.", "question_id": 8144},
{"snippet": "numpy.log(x, /, signature, out=None, casting='same_kind')", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 8145},
{"snippet": "numpy.log(x, /, signature, out=None, order='K')", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `out`, `order`.", "question_id": 8146},
{"snippet": "polynomial.hermite_e.HermiteE.cutdeg(deg)", "intent": "Truncate series to the given degree . Reduce the degree of the series to `deg` by discarding the high order terms .", "question_id": 8147},
{"snippet": "polynomial.laguerre.lagline(off, scl)", "intent": "Laguerre series whose graph is a straight line . With arguments `off`, `scl`.", "question_id": 8148},
{"snippet": "linalg.inv(a)", "intent": "Compute the ( multiplicative ) inverse of `a` matrix .", "question_id": 8149},
{"snippet": "ma.mr_", "intent": "Translate slice objects to concatenation along the first axis.", "question_id": 8150},
{"snippet": "polynomial.chebyshev.Chebyshev.convert()", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 8151},
{"snippet": "polynomial.chebyshev.Chebyshev.convert(domain=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 8152},
{"snippet": "polynomial.chebyshev.Chebyshev.convert(kind=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 8153},
{"snippet": "polynomial.chebyshev.Chebyshev.convert(window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 8154},
{"snippet": "polynomial.chebyshev.Chebyshev.convert(domain=None, kind=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 8155},
{"snippet": "polynomial.chebyshev.Chebyshev.convert(domain=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 8156},
{"snippet": "polynomial.chebyshev.Chebyshev.convert(kind=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 8157},
{"snippet": "polynomial.chebyshev.Chebyshev.convert(domain=None, kind=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` .", "question_id": 8158},
{"snippet": "char.chararray.expandtabs()", "intent": "Return a copy of each string element where all tab characters are replaced by one or more spaces .", "question_id": 8159},
{"snippet": "char.chararray.expandtabs(tabsize=8)", "intent": "Return a copy of each string element where all tab characters are replaced by one or more spaces . With arguments `tabsize`.", "question_id": 8160},
{"snippet": "ufunc.reduce(array)", "intent": "Reduces `array` \u2019 s dimension by one , by applying ufunc along one `axis` .", "question_id": 8161},
{"snippet": "ufunc.reduce(array, axis=0)", "intent": "Reduces `array` \u2019 s dimension by one , by applying ufunc along one `axis` .", "question_id": 8162},
{"snippet": "ufunc.reduce(array, dtype=None)", "intent": "Reduces `array` \u2019 s dimension by one , by applying ufunc along one `axis` . With arguments `dtype`.", "question_id": 8163},
{"snippet": "ufunc.reduce(array, out=None)", "intent": "Reduces `array` \u2019 s dimension by one , by applying ufunc along one `axis` . With arguments `out`.", "question_id": 8164},
{"snippet": "ufunc.reduce(array, keepdims=False)", "intent": "Reduces `array` \u2019 s dimension by one , by applying ufunc along one `axis` . With arguments `keepdims`.", "question_id": 8165},
{"snippet": "ufunc.reduce(array, initial=<no value>)", "intent": "Reduces `array` \u2019 s dimension by one , by applying ufunc along one `axis` . You can use the `initial` keyword argument to initialize the reduction with a different value , and `where` to select specific elements to include :", "question_id": 8166},
{"snippet": "ufunc.reduce(array, where=True)", "intent": "Reduces `array` \u2019 s dimension by one , by applying ufunc along one `axis` . You can use the `initial` keyword argument to initialize the reduction with a different value , and `where` to select specific elements to include :", "question_id": 8167},
{"snippet": "ufunc.reduce(array, axis=0, dtype=None)", "intent": "Reduces `array` \u2019 s dimension by one , by applying ufunc along one `axis` . With arguments `dtype`.", "question_id": 8168},
{"snippet": "ufunc.reduce(array, axis=0, out=None)", "intent": "Reduces `array` \u2019 s dimension by one , by applying ufunc along one `axis` . With arguments `out`.", "question_id": 8169},
{"snippet": "ufunc.reduce(array, axis=0, keepdims=False)", "intent": "Reduces `array` \u2019 s dimension by one , by applying ufunc along one `axis` . With arguments `keepdims`.", "question_id": 8170},
{"snippet": "ma.masked_array.filled()", "intent": "Return a copy of self , with masked values filled with a given value .", "question_id": 8171},
{"snippet": "ma.masked_array.filled(fill_value=None)", "intent": "Return a copy of self , with masked values filled with a given value . With arguments `fill_value`.", "question_id": 8172},
{"snippet": "numpy.greater(x1, x2, /, signature, extobj)", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `extobj`.", "question_id": 8173},
{"snippet": "numpy.greater(x1, x2, /, signature, extobj, out=None)", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 8174},
{"snippet": "numpy.greater(x1, x2, /, signature, extobj, where=True)", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 8175},
{"snippet": "numpy.greater(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 8176},
{"snippet": "numpy.greater(x1, x2, /, signature, extobj, order='K')", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 8177},
{"snippet": "numpy.greater(x1, x2, /, signature, extobj, dtype=None)", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 8178},
{"snippet": "numpy.greater(x1, x2, /, signature, extobj, subok=True)", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 8179},
{"snippet": "numpy.greater(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 8180},
{"snippet": "numpy.greater(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 8181},
{"snippet": "numpy.greater(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 8182},
{"snippet": "numpy.greater(x1, x2, /, signature)", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`.", "question_id": 8183},
{"snippet": "numpy.greater(x1, x2, /, signature, out=None)", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `out`.", "question_id": 8184},
{"snippet": "numpy.greater(x1, x2, /, signature, where=True)", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `where`.", "question_id": 8185},
{"snippet": "numpy.greater(x1, x2, /, signature, casting='same_kind')", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `casting`.", "question_id": 8186},
{"snippet": "numpy.greater(x1, x2, /, signature, order='K')", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `order`.", "question_id": 8187},
{"snippet": "numpy.greater(x1, x2, /, signature, dtype=None)", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `dtype`.", "question_id": 8188},
{"snippet": "numpy.greater(x1, x2, /, signature, subok=True)", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `subok`.", "question_id": 8189},
{"snippet": "numpy.greater(x1, x2, /, signature, out=None, where=True)", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `out`, `where`.", "question_id": 8190},
{"snippet": "numpy.greater(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 8191},
{"snippet": "numpy.greater(x1, x2, /, signature, out=None, order='K')", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `out`, `order`.", "question_id": 8192},
{"snippet": "numpy.char.chararray(shape)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d .", "question_id": 8193},
{"snippet": "numpy.char.chararray(shape, itemsize=1)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . With arguments `itemsize`.", "question_id": 8194},
{"snippet": "numpy.char.chararray(shape, unicode=False)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d .", "question_id": 8195},
{"snippet": "numpy.char.chararray(shape, buffer=None)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . This constructor creates the array , using `buffer` ( with `offset` and `strides` ) if it is not None .", "question_id": 8196},
{"snippet": "numpy.char.chararray(shape, offset=0)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . This constructor creates the array , using `buffer` ( with `offset` and `strides` ) if it is not None .", "question_id": 8197},
{"snippet": "numpy.char.chararray(shape, strides=None)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . This constructor creates the array , using `buffer` ( with `offset` and `strides` ) if it is not None .", "question_id": 8198},
{"snippet": "numpy.char.chararray(shape, order=None)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d .", "question_id": 8199},
{"snippet": "numpy.char.chararray(shape, itemsize=1, unicode=False)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . With arguments `itemsize`.", "question_id": 8200},
{"snippet": "numpy.char.chararray(shape, itemsize=1, buffer=None)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . This constructor creates the array , using `buffer` ( with `offset` and `strides` ) if it is not None . With arguments `itemsize`.", "question_id": 8201},
{"snippet": "numpy.char.chararray(shape, itemsize=1, offset=0)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . This constructor creates the array , using `buffer` ( with `offset` and `strides` ) if it is not None . With arguments `itemsize`.", "question_id": 8202},
{"snippet": "chararray.resize(new_shape)", "intent": "Change shape and size of array in-place . With arguments `new_shape`.", "question_id": 8203},
{"snippet": "chararray.resize(new_shape, refcheck=True)", "intent": "Change shape and size of array in-place . However , reference counts can increase in other ways so if you are sure that you have not shared the memory for this array with another Python object , then you may safely set `refcheck` to False . With arguments `new_shape`.", "question_id": 8204},
{"snippet": "recarray.dtype", "intent": "Data-type of the array\u2019s elements.", "question_id": 8205},
{"snippet": "lib.scimath.log(x)", "intent": "Compute the natural logarithm of `x` .", "question_id": 8206},
{"snippet": "ndarray.squeeze()", "intent": "Remove axes of length one from a .", "question_id": 8207},
{"snippet": "ndarray.squeeze(axis=None)", "intent": "Remove axes of length one from a . With arguments `axis`.", "question_id": 8208},
{"snippet": "polynomial.polynomial.polyfromroots(roots)", "intent": "Generate a monic polynomial with given `roots` .", "question_id": 8209},
{"snippet": "lib.scimath.power(x, p)", "intent": "Return `x` to the power `p` , ( x * * p ) .", "question_id": 8210},
{"snippet": "polynomial.hermite_e.HermiteE.mapparms()", "intent": "Return the mapping parameters .", "question_id": 8211},
{"snippet": "polynomial.hermite.Hermite.fit(x, y, deg)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`.", "question_id": 8212},
{"snippet": "polynomial.hermite.Hermite.fit(x, y, deg, domain=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`.", "question_id": 8213},
{"snippet": "polynomial.hermite.Hermite.fit(x, y, deg, rcond=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `rcond`.", "question_id": 8214},
{"snippet": "polynomial.hermite.Hermite.fit(x, y, deg, full=False)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `full`.", "question_id": 8215},
{"snippet": "polynomial.hermite.Hermite.fit(x, y, deg, w=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `w`.", "question_id": 8216},
{"snippet": "polynomial.hermite.Hermite.fit(x, y, deg, window=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `window`.", "question_id": 8217},
{"snippet": "polynomial.hermite.Hermite.fit(x, y, deg, domain=None, rcond=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `rcond`.", "question_id": 8218},
{"snippet": "polynomial.hermite.Hermite.fit(x, y, deg, domain=None, full=False)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `full`.", "question_id": 8219},
{"snippet": "polynomial.hermite.Hermite.fit(x, y, deg, domain=None, w=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `w`.", "question_id": 8220},
{"snippet": "polynomial.hermite.Hermite.fit(x, y, deg, domain=None, window=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `window`.", "question_id": 8221},
{"snippet": "char.chararray.flat", "intent": "A 1-D iterator over the array.", "question_id": 8222},
{"snippet": "numpy.logical_not(x, /, signature, extobj)", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `extobj`.", "question_id": 8223},
{"snippet": "numpy.logical_not(x, /, signature, extobj, out=None)", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 8224},
{"snippet": "numpy.logical_not(x, /, signature, extobj, where=True)", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 8225},
{"snippet": "numpy.logical_not(x, /, signature, extobj, casting='same_kind')", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 8226},
{"snippet": "numpy.logical_not(x, /, signature, extobj, order='K')", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 8227},
{"snippet": "numpy.logical_not(x, /, signature, extobj, dtype=None)", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 8228},
{"snippet": "numpy.logical_not(x, /, signature, extobj, subok=True)", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 8229},
{"snippet": "numpy.logical_not(x, /, signature, extobj, out=None, where=True)", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 8230},
{"snippet": "numpy.logical_not(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 8231},
{"snippet": "numpy.logical_not(x, /, signature, extobj, out=None, order='K')", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 8232},
{"snippet": "numpy.logical_not(x, /, signature)", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`.", "question_id": 8233},
{"snippet": "numpy.logical_not(x, /, signature, out=None)", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `out`.", "question_id": 8234},
{"snippet": "numpy.logical_not(x, /, signature, where=True)", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `where`.", "question_id": 8235},
{"snippet": "numpy.logical_not(x, /, signature, casting='same_kind')", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `casting`.", "question_id": 8236},
{"snippet": "numpy.logical_not(x, /, signature, order='K')", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `order`.", "question_id": 8237},
{"snippet": "numpy.logical_not(x, /, signature, dtype=None)", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `dtype`.", "question_id": 8238},
{"snippet": "numpy.logical_not(x, /, signature, subok=True)", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `subok`.", "question_id": 8239},
{"snippet": "numpy.logical_not(x, /, signature, out=None, where=True)", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `out`, `where`.", "question_id": 8240},
{"snippet": "numpy.logical_not(x, /, signature, out=None, casting='same_kind')", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 8241},
{"snippet": "numpy.logical_not(x, /, signature, out=None, order='K')", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `out`, `order`.", "question_id": 8242},
{"snippet": "numpy.count_nonzero(a)", "intent": "Counts the number of non-zero values in the array `a` .", "question_id": 8243},
{"snippet": "numpy.count_nonzero(a, axis=None)", "intent": "Counts the number of non-zero values in the array `a` . With arguments `axis`.", "question_id": 8244},
{"snippet": "numpy.count_nonzero(a, keepdims=False)", "intent": "Counts the number of non-zero values in the array `a` . With arguments `keepdims`.", "question_id": 8245},
{"snippet": "numpy.count_nonzero(a, axis=None, keepdims=False)", "intent": "Counts the number of non-zero values in the array `a` . With arguments `axis`, `keepdims`.", "question_id": 8246},
{"snippet": "char.chararray.rsplit()", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string .", "question_id": 8247},
{"snippet": "char.chararray.rsplit(sep=None)", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string .", "question_id": 8248},
{"snippet": "char.chararray.rsplit(maxsplit=None)", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string . With arguments `maxsplit`.", "question_id": 8249},
{"snippet": "char.chararray.rsplit(sep=None, maxsplit=None)", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string . With arguments `maxsplit`.", "question_id": 8250},
{"snippet": "linalg.multi_dot(arrays)", "intent": "Compute the dot product of two or more `arrays` in a single function call , while automatically selecting the fastest evaluation order .", "question_id": 8251},
{"snippet": "linalg.multi_dot(arrays, out=None)", "intent": "Compute the dot product of two or more `arrays` in a single function call , while automatically selecting the fastest evaluation order . With arguments `out`.", "question_id": 8252},
{"snippet": "testing.Tester.bench()", "intent": "Run benchmarks for module using nose .", "question_id": 8253},
{"snippet": "testing.Tester.bench(label='fast')", "intent": "Run benchmarks for module using nose . With arguments `label`.", "question_id": 8254},
{"snippet": "testing.Tester.bench(verbose=1)", "intent": "Run benchmarks for module using nose . With arguments `verbose`.", "question_id": 8255},
{"snippet": "testing.Tester.bench(extra_argv=None)", "intent": "Run benchmarks for module using nose . With arguments `extra_argv`.", "question_id": 8256},
{"snippet": "testing.Tester.bench(label='fast', verbose=1)", "intent": "Run benchmarks for module using nose . With arguments `label`, `verbose`.", "question_id": 8257},
{"snippet": "testing.Tester.bench(label='fast', extra_argv=None)", "intent": "Run benchmarks for module using nose . With arguments `label`, `extra_argv`.", "question_id": 8258},
{"snippet": "testing.Tester.bench(verbose=1, extra_argv=None)", "intent": "Run benchmarks for module using nose . With arguments `verbose`, `extra_argv`.", "question_id": 8259},
{"snippet": "testing.Tester.bench(label='fast', verbose=1, extra_argv=None)", "intent": "Run benchmarks for module using nose . With arguments `label`, `verbose`, `extra_argv`.", "question_id": 8260},
{"snippet": "matrix.round()", "intent": "Return a with each element rounded to the given number of `decimals` .", "question_id": 8261},
{"snippet": "matrix.round(decimals=0)", "intent": "Return a with each element rounded to the given number of `decimals` .", "question_id": 8262},
{"snippet": "matrix.round(out=None)", "intent": "Return a with each element rounded to the given number of `decimals` . With arguments `out`.", "question_id": 8263},
{"snippet": "matrix.round(decimals=0, out=None)", "intent": "Return a with each element rounded to the given number of `decimals` . With arguments `out`.", "question_id": 8264},
{"snippet": "ma.MaskType.argsort()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 8265},
{"snippet": "numpy.cbrt(x, /, signature, extobj)", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`.", "question_id": 8266},
{"snippet": "numpy.cbrt(x, /, signature, extobj, out=None)", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`.", "question_id": 8267},
{"snippet": "numpy.cbrt(x, /, signature, extobj, where=True)", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `where`.", "question_id": 8268},
{"snippet": "numpy.cbrt(x, /, signature, extobj, casting='same_kind')", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `casting`.", "question_id": 8269},
{"snippet": "numpy.cbrt(x, /, signature, extobj, order='K')", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `order`.", "question_id": 8270},
{"snippet": "numpy.cbrt(x, /, signature, extobj, dtype=None)", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `dtype`.", "question_id": 8271},
{"snippet": "numpy.cbrt(x, /, signature, extobj, subok=True)", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `subok`.", "question_id": 8272},
{"snippet": "numpy.cbrt(x, /, signature, extobj, out=None, where=True)", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 8273},
{"snippet": "numpy.cbrt(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 8274},
{"snippet": "numpy.cbrt(x, /, signature, extobj, out=None, order='K')", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 8275},
{"snippet": "numpy.cbrt(x, /, signature)", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`.", "question_id": 8276},
{"snippet": "numpy.cbrt(x, /, signature, out=None)", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `out`.", "question_id": 8277},
{"snippet": "numpy.cbrt(x, /, signature, where=True)", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `where`.", "question_id": 8278},
{"snippet": "numpy.cbrt(x, /, signature, casting='same_kind')", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `casting`.", "question_id": 8279},
{"snippet": "numpy.cbrt(x, /, signature, order='K')", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `order`.", "question_id": 8280},
{"snippet": "numpy.cbrt(x, /, signature, dtype=None)", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `dtype`.", "question_id": 8281},
{"snippet": "numpy.cbrt(x, /, signature, subok=True)", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `subok`.", "question_id": 8282},
{"snippet": "numpy.cbrt(x, /, signature, out=None, where=True)", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `out`, `where`.", "question_id": 8283},
{"snippet": "numpy.cbrt(x, /, signature, out=None, casting='same_kind')", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `out`, `casting`.", "question_id": 8284},
{"snippet": "numpy.cbrt(x, /, signature, out=None, order='K')", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `out`, `order`.", "question_id": 8285},
{"snippet": "random.Generator.chisquare(df)", "intent": "Draw samples from a chi-square distribution . When `df` independent random variables , each with standard normal distributions ( mean 0 , variance 1 ) , are squared and summed , the resulting distribution is chi-square ( see Notes ) .", "question_id": 8286},
{"snippet": "random.Generator.chisquare(df, size=None)", "intent": "Draw samples from a chi-square distribution . When `df` independent random variables , each with standard normal distributions ( mean 0 , variance 1 ) , are squared and summed , the resulting distribution is chi-square ( see Notes ) . With arguments `size`.", "question_id": 8287},
{"snippet": "recarray.cumsum()", "intent": "Return the cumulative sum of the elements along the given `axis` .", "question_id": 8288},
{"snippet": "recarray.cumsum(axis=None)", "intent": "Return the cumulative sum of the elements along the given `axis` .", "question_id": 8289},
{"snippet": "recarray.cumsum(dtype=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`.", "question_id": 8290},
{"snippet": "recarray.cumsum(out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `out`.", "question_id": 8291},
{"snippet": "recarray.cumsum(axis=None, dtype=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`.", "question_id": 8292},
{"snippet": "recarray.cumsum(axis=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `out`.", "question_id": 8293},
{"snippet": "recarray.cumsum(dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 8294},
{"snippet": "recarray.cumsum(axis=None, dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 8295},
{"snippet": "recarray.conj()", "intent": "Complex-conjugate all elements .", "question_id": 8296},
{"snippet": "numpy.diag(v)", "intent": "Extract a diagonal or construct a diagonal array . With arguments `v`.", "question_id": 8297},
{"snippet": "numpy.diag(v, k=0)", "intent": "Extract a diagonal or construct a diagonal array . With arguments `v`, `k`.", "question_id": 8298},
{"snippet": "chararray.take(indices)", "intent": "Return an array formed from the elements of a at the given `indices` .", "question_id": 8299},
{"snippet": "chararray.take(indices, axis=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`.", "question_id": 8300},
{"snippet": "chararray.take(indices, out=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `out`.", "question_id": 8301},
{"snippet": "chararray.take(indices, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `mode`.", "question_id": 8302},
{"snippet": "chararray.take(indices, axis=None, out=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `out`.", "question_id": 8303},
{"snippet": "chararray.take(indices, axis=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `mode`.", "question_id": 8304},
{"snippet": "chararray.take(indices, out=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `out`, `mode`.", "question_id": 8305},
{"snippet": "chararray.take(indices, axis=None, out=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `out`, `mode`.", "question_id": 8306},
{"snippet": "numpy.argmax(a)", "intent": "Returns the indices of the maximum values along an `axis` . Indexes of the maximal elements of `a` N-dimensional array :", "question_id": 8307},
{"snippet": "numpy.argmax(a, axis=None)", "intent": "Returns the indices of the maximum values along an `axis` . Indexes of the maximal elements of `a` N-dimensional array :", "question_id": 8308},
{"snippet": "numpy.argmax(a, out=None)", "intent": "Returns the indices of the maximum values along an `axis` . Indexes of the maximal elements of `a` N-dimensional array : With arguments `out`.", "question_id": 8309},
{"snippet": "numpy.argmax(a, axis=None, out=None)", "intent": "Returns the indices of the maximum values along an `axis` . Indexes of the maximal elements of `a` N-dimensional array : With arguments `out`.", "question_id": 8310},
{"snippet": "polynomial.hermite.Hermite.copy()", "intent": "Return a copy .", "question_id": 8311},
{"snippet": "ndarray.__pow__(value, /)", "intent": "Return pow ( self , `value` , `mod` ) . With arguments `/`.", "question_id": 8312},
{"snippet": "ndarray.__pow__(value, /, mod=None)", "intent": "Return pow ( self , `value` , `mod` ) . With arguments `/`.", "question_id": 8313},
{"snippet": "distutils.ccompiler.CCompiler_compile(self, sources)", "intent": "Compile one or more source files . With arguments `self`, `sources`.", "question_id": 8314},
{"snippet": "distutils.ccompiler.CCompiler_compile(self, sources, output_dir=None)", "intent": "Compile one or more source files . With arguments `self`, `sources`, `output_dir`.", "question_id": 8315},
{"snippet": "distutils.ccompiler.CCompiler_compile(self, sources, macros=None)", "intent": "Compile one or more source files . With arguments `self`, `sources`, `macros`.", "question_id": 8316},
{"snippet": "distutils.ccompiler.CCompiler_compile(self, sources, include_dirs=None)", "intent": "Compile one or more source files . With arguments `self`, `sources`, `include_dirs`.", "question_id": 8317},
{"snippet": "distutils.ccompiler.CCompiler_compile(self, sources, debug=0)", "intent": "Compile one or more source files . With arguments `self`, `sources`, `debug`.", "question_id": 8318},
{"snippet": "distutils.ccompiler.CCompiler_compile(self, sources, extra_preargs=None)", "intent": "Compile one or more source files . With arguments `self`, `sources`, `extra_preargs`.", "question_id": 8319},
{"snippet": "distutils.ccompiler.CCompiler_compile(self, sources, extra_postargs=None)", "intent": "Compile one or more source files . With arguments `self`, `sources`, `extra_postargs`.", "question_id": 8320},
{"snippet": "distutils.ccompiler.CCompiler_compile(self, sources, depends=None)", "intent": "Compile one or more source files . With arguments `self`, `sources`, `depends`.", "question_id": 8321},
{"snippet": "distutils.ccompiler.CCompiler_compile(self, sources, output_dir=None, macros=None)", "intent": "Compile one or more source files . With arguments `self`, `sources`, `output_dir`, `macros`.", "question_id": 8322},
{"snippet": "distutils.ccompiler.CCompiler_compile(self, sources, output_dir=None, include_dirs=None)", "intent": "Compile one or more source files . With arguments `self`, `sources`, `output_dir`, `include_dirs`.", "question_id": 8323},
{"snippet": "polynomial.hermite.hermvander3d(x, y, z, deg)", "intent": "Pseudo-Vandermonde matrix of given degrees . Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points ( `x` , `y` , `z` ) .", "question_id": 8324},
{"snippet": "char.chararray.dump(file)", "intent": "Dump a pickle of the array to the specified `file` .", "question_id": 8325},
{"snippet": "polynomial.laguerre.Laguerre.has_samedomain(other)", "intent": "Check if domains match . With arguments `other`.", "question_id": 8326},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.cpu_baseline_flags()", "intent": "Returns a list of final CPU baseline compiler flags", "question_id": 8327},
{"snippet": "char.chararray.ctypes", "intent": "An object to simplify the interaction of the array with the ctypes module.", "question_id": 8328},
{"snippet": "_ctypes.data", "intent": "A pointer to the memory area of the array as a Python integer.", "question_id": 8329},
{"snippet": "_ctypes.shape", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the C-integer corresponding to dtype('p') on this platform.", "question_id": 8330},
{"snippet": "_ctypes.strides", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the same as for the shape attribute.", "question_id": 8331},
{"snippet": "_ctypes.data_as(obj)", "intent": "Return the data pointer cast to a particular c-types object . With arguments `obj`.", "question_id": 8332},
{"snippet": "_ctypes.shape_as(obj)", "intent": "Return the shape tuple as an array of some other c-types type . With arguments `obj`.", "question_id": 8333},
{"snippet": "_ctypes.strides_as(obj)", "intent": "Return the strides tuple as an array of some other c-types type . With arguments `obj`.", "question_id": 8334},
{"snippet": "polynomial.polynomial.polyval3d(x, y, z, c)", "intent": "Evaluate a 3-D polynomial at points ( `x` , `y` , `z` ) . In either case , either x , y , and z or their elements must support multiplication and addition both with themselves and with the elements of `c` .", "question_id": 8335},
{"snippet": "numpy.putmask(a, mask, values)", "intent": "Changes elements of an array based on conditional and input `values` . If values is not the same size as `a` and `mask` then it will repeat .", "question_id": 8336},
{"snippet": "recarray.size", "intent": "Number of elements in the array.", "question_id": 8337},
{"snippet": "generic.flags", "intent": "The integer value of flags.", "question_id": 8338},
{"snippet": "ma.prod(self)", "intent": "Return the product of the array elements over the given `axis` . With arguments `self`.", "question_id": 8339},
{"snippet": "ma.prod(self, axis=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `self`.", "question_id": 8340},
{"snippet": "ma.prod(self, dtype=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `self`, `dtype`.", "question_id": 8341},
{"snippet": "ma.prod(self, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `self`, `out`.", "question_id": 8342},
{"snippet": "ma.prod(self, keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `self`, `keepdims`.", "question_id": 8343},
{"snippet": "ma.prod(self, axis=None, dtype=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `self`, `dtype`.", "question_id": 8344},
{"snippet": "ma.prod(self, axis=None, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `self`, `out`.", "question_id": 8345},
{"snippet": "ma.prod(self, axis=None, keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `self`, `keepdims`.", "question_id": 8346},
{"snippet": "ma.prod(self, dtype=None, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `self`, `dtype`, `out`.", "question_id": 8347},
{"snippet": "ma.prod(self, dtype=None, keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `self`, `dtype`, `keepdims`.", "question_id": 8348},
{"snippet": "ma.fix_invalid(a)", "intent": "Return input with invalid data masked and replaced by `a` fill value .", "question_id": 8349},
{"snippet": "ma.fix_invalid(a, mask=False)", "intent": "Return input with invalid data masked and replaced by `a` fill value . With arguments `mask`.", "question_id": 8350},
{"snippet": "ma.fix_invalid(a, copy=True)", "intent": "Return input with invalid data masked and replaced by `a` fill value . A `copy` is performed by default .", "question_id": 8351},
{"snippet": "ma.fix_invalid(a, fill_value=None)", "intent": "Return input with invalid data masked and replaced by `a` fill value . With arguments `fill_value`.", "question_id": 8352},
{"snippet": "ma.fix_invalid(a, mask=False, copy=True)", "intent": "Return input with invalid data masked and replaced by `a` fill value . A `copy` is performed by default . With arguments `mask`.", "question_id": 8353},
{"snippet": "ma.fix_invalid(a, mask=False, fill_value=None)", "intent": "Return input with invalid data masked and replaced by `a` fill value . With arguments `mask`, `fill_value`.", "question_id": 8354},
{"snippet": "ma.fix_invalid(a, copy=True, fill_value=None)", "intent": "Return input with invalid data masked and replaced by `a` fill value . A `copy` is performed by default . With arguments `fill_value`.", "question_id": 8355},
{"snippet": "ma.fix_invalid(a, mask=False, copy=True, fill_value=None)", "intent": "Return input with invalid data masked and replaced by `a` fill value . A `copy` is performed by default . With arguments `mask`, `fill_value`.", "question_id": 8356},
{"snippet": "ma.mask_rows(a)", "intent": "Mask rows of `a` 2D array that contain masked values .", "question_id": 8357},
{"snippet": "ma.mask_rows(a, axis=<no value>)", "intent": "Mask rows of `a` 2D array that contain masked values . This function is a shortcut to mask_rowcols with `axis` equal to 0 .", "question_id": 8358},
{"snippet": "numpy.zeros_like(a)", "intent": "Return an array of zeros with the same `shape` and type as `a` given array .", "question_id": 8359},
{"snippet": "numpy.zeros_like(a, dtype=None)", "intent": "Return an array of zeros with the same `shape` and type as `a` given array . With arguments `dtype`.", "question_id": 8360},
{"snippet": "numpy.zeros_like(a, order='K')", "intent": "Return an array of zeros with the same `shape` and type as `a` given array . With arguments `order`.", "question_id": 8361},
{"snippet": "numpy.zeros_like(a, subok=True)", "intent": "Return an array of zeros with the same `shape` and type as `a` given array . With arguments `subok`.", "question_id": 8362},
{"snippet": "numpy.zeros_like(a, shape=None)", "intent": "Return an array of zeros with the same `shape` and type as `a` given array .", "question_id": 8363},
{"snippet": "numpy.zeros_like(a, dtype=None, order='K')", "intent": "Return an array of zeros with the same `shape` and type as `a` given array . With arguments `dtype`, `order`.", "question_id": 8364},
{"snippet": "numpy.zeros_like(a, dtype=None, subok=True)", "intent": "Return an array of zeros with the same `shape` and type as `a` given array . With arguments `dtype`, `subok`.", "question_id": 8365},
{"snippet": "numpy.zeros_like(a, dtype=None, shape=None)", "intent": "Return an array of zeros with the same `shape` and type as `a` given array . With arguments `dtype`.", "question_id": 8366},
{"snippet": "numpy.zeros_like(a, order='K', subok=True)", "intent": "Return an array of zeros with the same `shape` and type as `a` given array . With arguments `order`, `subok`.", "question_id": 8367},
{"snippet": "numpy.zeros_like(a, order='K', shape=None)", "intent": "Return an array of zeros with the same `shape` and type as `a` given array . With arguments `order`.", "question_id": 8368},
{"snippet": "matrix.conj()", "intent": "Complex-conjugate all elements .", "question_id": 8369},
{"snippet": "matrix.setfield(val, dtype)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field .", "question_id": 8370},
{"snippet": "matrix.setfield(val, dtype, offset=0)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field .", "question_id": 8371},
{"snippet": "numpy.fromiter(iter, dtype)", "intent": "Create a new 1-dimensional array from an iterable object . With arguments `iter`, `dtype`.", "question_id": 8372},
{"snippet": "numpy.fromiter(iter, dtype, count=- 1)", "intent": "Create a new 1-dimensional array from an iterable object . Specify `count` to improve performance . With arguments `iter`, `dtype`.", "question_id": 8373},
{"snippet": "numpy.fromiter(iter, dtype, like=None)", "intent": "Create a new 1-dimensional array from an iterable object . With arguments `iter`, `dtype`, `like`.", "question_id": 8374},
{"snippet": "numpy.fromiter(iter, dtype, count=- 1, like=None)", "intent": "Create a new 1-dimensional array from an iterable object . Specify `count` to improve performance . With arguments `iter`, `dtype`, `like`.", "question_id": 8375},
{"snippet": "memmap.transpose(*axes)", "intent": "Returns a view of the array with axes transposed . With arguments `*axes`.", "question_id": 8376},
{"snippet": "ma.MaskedArray.round()", "intent": "Return each element rounded to the given number of `decimals` .", "question_id": 8377},
{"snippet": "ma.MaskedArray.round(decimals=0)", "intent": "Return each element rounded to the given number of `decimals` .", "question_id": 8378},
{"snippet": "ma.MaskedArray.round(out=None)", "intent": "Return each element rounded to the given number of `decimals` . With arguments `out`.", "question_id": 8379},
{"snippet": "ma.MaskedArray.round(decimals=0, out=None)", "intent": "Return each element rounded to the given number of `decimals` . With arguments `out`.", "question_id": 8380},
{"snippet": "numpy.setdiff1d(ar1, ar2)", "intent": "Find the set difference of two arrays . Return the unique values in `ar1` that are not in `ar2` .", "question_id": 8381},
{"snippet": "numpy.setdiff1d(ar1, ar2, assume_unique=False)", "intent": "Find the set difference of two arrays . Return the unique values in `ar1` that are not in `ar2` . With arguments `assume_unique`.", "question_id": 8382},
{"snippet": "record.byteswap()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 8383},
{"snippet": "ma.MaskType.byteswap()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 8384},
{"snippet": "matrix.max()", "intent": "Return the maximum value along an `axis` .", "question_id": 8385},
{"snippet": "matrix.max(axis=None)", "intent": "Return the maximum value along an `axis` .", "question_id": 8386},
{"snippet": "matrix.max(out=None)", "intent": "Return the maximum value along an `axis` . With arguments `out`.", "question_id": 8387},
{"snippet": "matrix.max(axis=None, out=None)", "intent": "Return the maximum value along an `axis` . With arguments `out`.", "question_id": 8388},
{"snippet": "polynomial.chebyshev.Chebyshev.has_samewindow(other)", "intent": "Check if windows match . With arguments `other`.", "question_id": 8389},
{"snippet": "char.chararray.flags", "intent": "Information about the memory layout of the array.", "question_id": 8390},
{"snippet": "ma.MaskedArray.__itruediv__(other)", "intent": "True divide self by `other` in-place .", "question_id": 8391},
{"snippet": "numpy.float_power(x1, x2, /, signature, extobj)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`.", "question_id": 8392},
{"snippet": "numpy.float_power(x1, x2, /, signature, extobj, out=None)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 8393},
{"snippet": "numpy.float_power(x1, x2, /, signature, extobj, where=True)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 8394},
{"snippet": "numpy.float_power(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 8395},
{"snippet": "numpy.float_power(x1, x2, /, signature, extobj, order='K')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 8396},
{"snippet": "numpy.float_power(x1, x2, /, signature, extobj, dtype=None)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 8397},
{"snippet": "numpy.float_power(x1, x2, /, signature, extobj, subok=True)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 8398},
{"snippet": "numpy.float_power(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 8399},
{"snippet": "numpy.float_power(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 8400},
{"snippet": "numpy.float_power(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 8401},
{"snippet": "numpy.float_power(x1, x2, /, signature)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`.", "question_id": 8402},
{"snippet": "numpy.float_power(x1, x2, /, signature, out=None)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `out`.", "question_id": 8403},
{"snippet": "numpy.float_power(x1, x2, /, signature, where=True)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `where`.", "question_id": 8404},
{"snippet": "numpy.float_power(x1, x2, /, signature, casting='same_kind')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `casting`.", "question_id": 8405},
{"snippet": "numpy.float_power(x1, x2, /, signature, order='K')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `order`.", "question_id": 8406},
{"snippet": "numpy.float_power(x1, x2, /, signature, dtype=None)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `dtype`.", "question_id": 8407},
{"snippet": "numpy.float_power(x1, x2, /, signature, subok=True)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `subok`.", "question_id": 8408},
{"snippet": "numpy.float_power(x1, x2, /, signature, out=None, where=True)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `out`, `where`.", "question_id": 8409},
{"snippet": "numpy.float_power(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 8410},
{"snippet": "numpy.float_power(x1, x2, /, signature, out=None, order='K')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `out`, `order`.", "question_id": 8411},
{"snippet": "ma.ravel(self)", "intent": "Returns a 1D version of `self` , as a view .", "question_id": 8412},
{"snippet": "ma.ravel(self, order='C')", "intent": "Returns a 1D version of `self` , as a view . With arguments `order`.", "question_id": 8413},
{"snippet": "recarray.partition(kth)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array .", "question_id": 8414},
{"snippet": "recarray.partition(kth, axis=- 1)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`.", "question_id": 8415},
{"snippet": "recarray.partition(kth, kind='introselect')", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `kind`.", "question_id": 8416},
{"snippet": "recarray.partition(kth, order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `order`.", "question_id": 8417},
{"snippet": "recarray.partition(kth, axis=- 1, kind='introselect')", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `kind`.", "question_id": 8418},
{"snippet": "recarray.partition(kth, axis=- 1, order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `order`.", "question_id": 8419},
{"snippet": "recarray.partition(kth, kind='introselect', order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `kind`, `order`.", "question_id": 8420},
{"snippet": "recarray.partition(kth, axis=- 1, kind='introselect', order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `kind`, `order`.", "question_id": 8421},
{"snippet": "testing.rundocs()", "intent": "Run doctests found in the given file .", "question_id": 8422},
{"snippet": "testing.rundocs(filename=None)", "intent": "Run doctests found in the given file . With arguments `filename`.", "question_id": 8423},
{"snippet": "testing.rundocs(raise_on_error=True)", "intent": "Run doctests found in the given file . With arguments `raise_on_error`.", "question_id": 8424},
{"snippet": "testing.rundocs(filename=None, raise_on_error=True)", "intent": "Run doctests found in the given file . With arguments `filename`, `raise_on_error`.", "question_id": 8425},
{"snippet": "random.RandomState.binomial(n, p)", "intent": "Draw samples from a binomial distribution . Samples are drawn from a binomial distribution with specified parameters , `n` trials and `p` probability of success where n an integer > = 0 and p is in the interval [ 0,1 ] .", "question_id": 8426},
{"snippet": "random.RandomState.binomial(n, p, size=None)", "intent": "Draw samples from a binomial distribution . Samples are drawn from a binomial distribution with specified parameters , `n` trials and `p` probability of success where n an integer > = 0 and p is in the interval [ 0,1 ] . With arguments `size`.", "question_id": 8427},
{"snippet": "ndarray.__setitem__(key, value, /)", "intent": "Set self [ `key` ] to `value` . With arguments `/`.", "question_id": 8428},
{"snippet": "numpy.meshgrid(*xi)", "intent": "Return coordinate matrices from coordinate vectors . With arguments `*xi`.", "question_id": 8429},
{"snippet": "numpy.meshgrid(*xi, copy=True)", "intent": "Return coordinate matrices from coordinate vectors . With arguments `*xi`, `copy`.", "question_id": 8430},
{"snippet": "numpy.meshgrid(*xi, sparse=False)", "intent": "Return coordinate matrices from coordinate vectors . In the 1-D and 0-D case , the indexing and `sparse` keywords have no effect . With arguments `*xi`.", "question_id": 8431},
{"snippet": "numpy.meshgrid(*xi, indexing='xy')", "intent": "Return coordinate matrices from coordinate vectors . This function supports both `indexing` conventions through the indexing keyword argument . With arguments `*xi`.", "question_id": 8432},
{"snippet": "numpy.meshgrid(*xi, copy=True, sparse=False)", "intent": "Return coordinate matrices from coordinate vectors . In the 1-D and 0-D case , the indexing and `sparse` keywords have no effect . With arguments `*xi`, `copy`.", "question_id": 8433},
{"snippet": "numpy.meshgrid(*xi, copy=True, indexing='xy')", "intent": "Return coordinate matrices from coordinate vectors . This function supports both `indexing` conventions through the indexing keyword argument . With arguments `*xi`, `copy`.", "question_id": 8434},
{"snippet": "numpy.meshgrid(*xi, sparse=False, indexing='xy')", "intent": "Return coordinate matrices from coordinate vectors . In the 1-D and 0-D case , the indexing and `sparse` keywords have no effect . This function supports both `indexing` conventions through the indexing keyword argument . With arguments `*xi`.", "question_id": 8435},
{"snippet": "numpy.meshgrid(*xi, copy=True, sparse=False, indexing='xy')", "intent": "Return coordinate matrices from coordinate vectors . In the 1-D and 0-D case , the indexing and `sparse` keywords have no effect . This function supports both `indexing` conventions through the indexing keyword argument . With arguments `*xi`, `copy`.", "question_id": 8436},
{"snippet": "polynomial.chebyshev.poly2cheb(pol)", "intent": "Convert a polynomial to a Chebyshev series . With arguments `pol`.", "question_id": 8437},
{"snippet": "nditer.operands", "intent": "operands[Slice]", "question_id": 8438},
{"snippet": "char.chararray.istitle()", "intent": "Returns true for each element if the element is a titlecased string and there is at least one character , false otherwise .", "question_id": 8439},
{"snippet": "ndarray.flatten()", "intent": "Return a copy of the array collapsed into one dimension .", "question_id": 8440},
{"snippet": "ndarray.flatten(order='C')", "intent": "Return a copy of the array collapsed into one dimension . With arguments `order`.", "question_id": 8441},
{"snippet": "char.translate(a, table)", "intent": "For each element in `a` , return a copy of the string where all characters occurring in the optional argument `deletechars` are removed , and the remaining characters have been mapped through the given translation `table` .", "question_id": 8442},
{"snippet": "char.translate(a, table, deletechars=None)", "intent": "For each element in `a` , return a copy of the string where all characters occurring in the optional argument `deletechars` are removed , and the remaining characters have been mapped through the given translation `table` .", "question_id": 8443},
{"snippet": "ma.MaskedArray.__ifloordiv__(other)", "intent": "Floor divide self by `other` in-place .", "question_id": 8444},
{"snippet": "ndarray.__deepcopy__(memo, /)", "intent": "Used if copy.deepcopy is called on an array . With arguments `memo`, `/`.", "question_id": 8445},
{"snippet": "numpy.polyint(p)", "intent": "Return an antiderivative ( indefinite integral ) of a polynomial . The returned order `m` antiderivative P of polynomial `p` satisfies \\ ( \\frac { d^m } { dx^m } P ( x ) = p ( x ) \\ ) and is defined up to m - 1 integration constants k. The constants determine the low-order polynomial part", "question_id": 8446},
{"snippet": "numpy.polyint(p, m=1)", "intent": "Return an antiderivative ( indefinite integral ) of a polynomial . The returned order `m` antiderivative P of polynomial `p` satisfies \\ ( \\frac { d^m } { dx^m } P ( x ) = p ( x ) \\ ) and is defined up to m - 1 integration constants k. The constants determine the low-order polynomial part", "question_id": 8447},
{"snippet": "numpy.polyint(p, k=None)", "intent": "Return an antiderivative ( indefinite integral ) of a polynomial . The returned order `m` antiderivative P of polynomial `p` satisfies \\ ( \\frac { d^m } { dx^m } P ( x ) = p ( x ) \\ ) and is defined up to m - 1 integration constants k. The constants determine the low-order polynomial part With arguments `k`.", "question_id": 8448},
{"snippet": "numpy.polyint(p, m=1, k=None)", "intent": "Return an antiderivative ( indefinite integral ) of a polynomial . The returned order `m` antiderivative P of polynomial `p` satisfies \\ ( \\frac { d^m } { dx^m } P ( x ) = p ( x ) \\ ) and is defined up to m - 1 integration constants k. The constants determine the low-order polynomial part With arguments `k`.", "question_id": 8449},
{"snippet": "generic.imag", "intent": "The imaginary part of the scalar.", "question_id": 8450},
{"snippet": "numpy.prod(a)", "intent": "Return the product of array elements over `a` given `axis` .", "question_id": 8451},
{"snippet": "numpy.prod(a, axis=None)", "intent": "Return the product of array elements over `a` given `axis` .", "question_id": 8452},
{"snippet": "numpy.prod(a, dtype=None)", "intent": "Return the product of array elements over `a` given `axis` . With arguments `dtype`.", "question_id": 8453},
{"snippet": "numpy.prod(a, out=None)", "intent": "Return the product of array elements over `a` given `axis` . With arguments `out`.", "question_id": 8454},
{"snippet": "numpy.prod(a, keepdims=<no value>)", "intent": "Return the product of array elements over `a` given `axis` . With arguments `keepdims`.", "question_id": 8455},
{"snippet": "numpy.prod(a, initial=<no value>)", "intent": "Return the product of array elements over `a` given `axis` . With arguments `initial`.", "question_id": 8456},
{"snippet": "numpy.prod(a, where=<no value>)", "intent": "Return the product of array elements over `a` given `axis` . With arguments `where`.", "question_id": 8457},
{"snippet": "numpy.prod(a, axis=None, dtype=None)", "intent": "Return the product of array elements over `a` given `axis` . With arguments `dtype`.", "question_id": 8458},
{"snippet": "numpy.prod(a, axis=None, out=None)", "intent": "Return the product of array elements over `a` given `axis` . With arguments `out`.", "question_id": 8459},
{"snippet": "numpy.prod(a, axis=None, keepdims=<no value>)", "intent": "Return the product of array elements over `a` given `axis` . With arguments `keepdims`.", "question_id": 8460},
{"snippet": "broadcast.numiter", "intent": "Number of iterators possessed by the broadcasted result.", "question_id": 8461},
{"snippet": "memmap.conj()", "intent": "Complex-conjugate all elements .", "question_id": 8462},
{"snippet": "linalg.pinv(a)", "intent": "Compute the ( Moore-Penrose ) pseudo-inverse of `a` matrix .", "question_id": 8463},
{"snippet": "linalg.pinv(a, rcond=1e-15)", "intent": "Compute the ( Moore-Penrose ) pseudo-inverse of `a` matrix . With arguments `rcond`.", "question_id": 8464},
{"snippet": "linalg.pinv(a, hermitian=False)", "intent": "Compute the ( Moore-Penrose ) pseudo-inverse of `a` matrix . With arguments `hermitian`.", "question_id": 8465},
{"snippet": "linalg.pinv(a, rcond=1e-15, hermitian=False)", "intent": "Compute the ( Moore-Penrose ) pseudo-inverse of `a` matrix . With arguments `rcond`, `hermitian`.", "question_id": 8466},
{"snippet": "numpy.diff(a)", "intent": "Calculate the n-th discrete difference along the given `axis` . The first difference is given by out [ i ] = `a` [ i+1 ] - a [ i ] along the given axis , higher differences are calculated by using diff recursively .", "question_id": 8467},
{"snippet": "numpy.diff(a, n=1)", "intent": "Calculate the n-th discrete difference along the given `axis` . The first difference is given by out [ i ] = `a` [ i+1 ] - a [ i ] along the given axis , higher differences are calculated by using diff recursively . With arguments `n`.", "question_id": 8468},
{"snippet": "numpy.diff(a, axis=-1)", "intent": "Calculate the n-th discrete difference along the given `axis` . The first difference is given by out [ i ] = `a` [ i+1 ] - a [ i ] along the given axis , higher differences are calculated by using diff recursively .", "question_id": 8469},
{"snippet": "numpy.diff(a, prepend=<no value>)", "intent": "Calculate the n-th discrete difference along the given `axis` . The first difference is given by out [ i ] = `a` [ i+1 ] - a [ i ] along the given axis , higher differences are calculated by using diff recursively . With arguments `prepend`.", "question_id": 8470},
{"snippet": "numpy.diff(a, append=<no value>)", "intent": "Calculate the n-th discrete difference along the given `axis` . The first difference is given by out [ i ] = `a` [ i+1 ] - a [ i ] along the given axis , higher differences are calculated by using diff recursively . With arguments `append`.", "question_id": 8471},
{"snippet": "numpy.diff(a, n=1, axis=-1)", "intent": "Calculate the n-th discrete difference along the given `axis` . The first difference is given by out [ i ] = `a` [ i+1 ] - a [ i ] along the given axis , higher differences are calculated by using diff recursively . With arguments `n`.", "question_id": 8472},
{"snippet": "numpy.diff(a, n=1, prepend=<no value>)", "intent": "Calculate the n-th discrete difference along the given `axis` . The first difference is given by out [ i ] = `a` [ i+1 ] - a [ i ] along the given axis , higher differences are calculated by using diff recursively . With arguments `n`, `prepend`.", "question_id": 8473},
{"snippet": "numpy.diff(a, n=1, append=<no value>)", "intent": "Calculate the n-th discrete difference along the given `axis` . The first difference is given by out [ i ] = `a` [ i+1 ] - a [ i ] along the given axis , higher differences are calculated by using diff recursively . With arguments `n`, `append`.", "question_id": 8474},
{"snippet": "numpy.diff(a, axis=-1, prepend=<no value>)", "intent": "Calculate the n-th discrete difference along the given `axis` . The first difference is given by out [ i ] = `a` [ i+1 ] - a [ i ] along the given axis , higher differences are calculated by using diff recursively . With arguments `prepend`.", "question_id": 8475},
{"snippet": "numpy.diff(a, axis=-1, append=<no value>)", "intent": "Calculate the n-th discrete difference along the given `axis` . The first difference is given by out [ i ] = `a` [ i+1 ] - a [ i ] along the given axis , higher differences are calculated by using diff recursively . With arguments `append`.", "question_id": 8476},
{"snippet": "numpy.cosh(x, /, signature, extobj)", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `extobj`.", "question_id": 8477},
{"snippet": "numpy.cosh(x, /, signature, extobj, out=None)", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `out`.", "question_id": 8478},
{"snippet": "numpy.cosh(x, /, signature, extobj, where=True)", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `where`.", "question_id": 8479},
{"snippet": "numpy.cosh(x, /, signature, extobj, casting='same_kind')", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `casting`.", "question_id": 8480},
{"snippet": "numpy.cosh(x, /, signature, extobj, order='K')", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `order`.", "question_id": 8481},
{"snippet": "numpy.cosh(x, /, signature, extobj, dtype=None)", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `dtype`.", "question_id": 8482},
{"snippet": "numpy.cosh(x, /, signature, extobj, subok=True)", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `subok`.", "question_id": 8483},
{"snippet": "numpy.cosh(x, /, signature, extobj, out=None, where=True)", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `out`, `where`.", "question_id": 8484},
{"snippet": "numpy.cosh(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `out`, `casting`.", "question_id": 8485},
{"snippet": "numpy.cosh(x, /, signature, extobj, out=None, order='K')", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `out`, `order`.", "question_id": 8486},
{"snippet": "numpy.cosh(x, /, signature)", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`.", "question_id": 8487},
{"snippet": "numpy.cosh(x, /, signature, out=None)", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `out`.", "question_id": 8488},
{"snippet": "numpy.cosh(x, /, signature, where=True)", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `where`.", "question_id": 8489},
{"snippet": "numpy.cosh(x, /, signature, casting='same_kind')", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `casting`.", "question_id": 8490},
{"snippet": "numpy.cosh(x, /, signature, order='K')", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `order`.", "question_id": 8491},
{"snippet": "numpy.cosh(x, /, signature, dtype=None)", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `dtype`.", "question_id": 8492},
{"snippet": "numpy.cosh(x, /, signature, subok=True)", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `subok`.", "question_id": 8493},
{"snippet": "numpy.cosh(x, /, signature, out=None, where=True)", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `out`, `where`.", "question_id": 8494},
{"snippet": "numpy.cosh(x, /, signature, out=None, casting='same_kind')", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `out`, `casting`.", "question_id": 8495},
{"snippet": "numpy.cosh(x, /, signature, out=None, order='K')", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `out`, `order`.", "question_id": 8496},
{"snippet": "numpy.deprecate(*args, **kwargs)", "intent": "Issues a DeprecationWarning , adds warning to old_name \u2019 s docstring , rebinds old_name.__name__ and returns the new function object . With arguments `*args`, `**kwargs`.", "question_id": 8497},
{"snippet": "chararray.tostring()", "intent": "A compatibility alias for tobytes , with exactly the same behavior .", "question_id": 8498},
{"snippet": "chararray.tostring(order='C')", "intent": "A compatibility alias for tobytes , with exactly the same behavior . With arguments `order`.", "question_id": 8499},
{"snippet": "matrix.newbyteorder(/)", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`.", "question_id": 8500},
{"snippet": "matrix.newbyteorder(/, new_order='S')", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`, `new_order`.", "question_id": 8501},
{"snippet": "linalg.solve(a, b)", "intent": "Solve `a` linear matrix equation , or system of linear scalar equations . Computes the \u201c exact \u201d solution , x , of the well-determined , i.e. , full rank , linear matrix equation ax = `b` .", "question_id": 8502},
{"snippet": "memmap.trace()", "intent": "Return the sum along diagonals of the array .", "question_id": 8503},
{"snippet": "memmap.trace(offset=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`.", "question_id": 8504},
{"snippet": "memmap.trace(axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `axis1`.", "question_id": 8505},
{"snippet": "memmap.trace(axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `axis2`.", "question_id": 8506},
{"snippet": "memmap.trace(dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `dtype`.", "question_id": 8507},
{"snippet": "memmap.trace(out=None)", "intent": "Return the sum along diagonals of the array . With arguments `out`.", "question_id": 8508},
{"snippet": "memmap.trace(offset=0, axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis1`.", "question_id": 8509},
{"snippet": "memmap.trace(offset=0, axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis2`.", "question_id": 8510},
{"snippet": "memmap.trace(offset=0, dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `dtype`.", "question_id": 8511},
{"snippet": "memmap.trace(offset=0, out=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `out`.", "question_id": 8512},
{"snippet": "numpy.histogram_bin_edges(a)", "intent": "Function to calculate only the edges of the `bins` used by the histogram function . With arguments `a`.", "question_id": 8513},
{"snippet": "numpy.histogram_bin_edges(a, bins=10)", "intent": "Function to calculate only the edges of the `bins` used by the histogram function . With arguments `a`.", "question_id": 8514},
{"snippet": "numpy.histogram_bin_edges(a, range=None)", "intent": "Function to calculate only the edges of the `bins` used by the histogram function . The final bin count is obtained from np.round ( np.ceil ( `range` / h ) ) . With arguments `a`.", "question_id": 8515},
{"snippet": "numpy.histogram_bin_edges(a, weights=None)", "intent": "Function to calculate only the edges of the `bins` used by the histogram function . With arguments `a`, `weights`.", "question_id": 8516},
{"snippet": "numpy.histogram_bin_edges(a, bins=10, range=None)", "intent": "Function to calculate only the edges of the `bins` used by the histogram function . The final bin count is obtained from np.round ( np.ceil ( `range` / h ) ) . With arguments `a`.", "question_id": 8517},
{"snippet": "numpy.histogram_bin_edges(a, bins=10, weights=None)", "intent": "Function to calculate only the edges of the `bins` used by the histogram function . With arguments `a`, `weights`.", "question_id": 8518},
{"snippet": "numpy.histogram_bin_edges(a, range=None, weights=None)", "intent": "Function to calculate only the edges of the `bins` used by the histogram function . The final bin count is obtained from np.round ( np.ceil ( `range` / h ) ) . With arguments `a`, `weights`.", "question_id": 8519},
{"snippet": "numpy.histogram_bin_edges(a, bins=10, range=None, weights=None)", "intent": "Function to calculate only the edges of the `bins` used by the histogram function . The final bin count is obtained from np.round ( np.ceil ( `range` / h ) ) . With arguments `a`, `weights`.", "question_id": 8520},
{"snippet": "random.random()", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) .", "question_id": 8521},
{"snippet": "random.random(size=None)", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) . With arguments `size`.", "question_id": 8522},
{"snippet": "memmap.tolist()", "intent": "Return the array as an a.ndim-levels deep nested list of Python scalars .", "question_id": 8523},
{"snippet": "polynomial.hermite_e.hermeder(c)", "intent": "Differentiate a Hermite_e series . Returns the series coefficients `c` differentiated `m` times along `axis` .", "question_id": 8524},
{"snippet": "polynomial.hermite_e.hermeder(c, m=1)", "intent": "Differentiate a Hermite_e series . Returns the series coefficients `c` differentiated `m` times along `axis` .", "question_id": 8525},
{"snippet": "polynomial.hermite_e.hermeder(c, scl=1)", "intent": "Differentiate a Hermite_e series . Returns the series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) .", "question_id": 8526},
{"snippet": "polynomial.hermite_e.hermeder(c, axis=0)", "intent": "Differentiate a Hermite_e series . Returns the series coefficients `c` differentiated `m` times along `axis` .", "question_id": 8527},
{"snippet": "polynomial.hermite_e.hermeder(c, m=1, scl=1)", "intent": "Differentiate a Hermite_e series . Returns the series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) .", "question_id": 8528},
{"snippet": "polynomial.hermite_e.hermeder(c, m=1, axis=0)", "intent": "Differentiate a Hermite_e series . Returns the series coefficients `c` differentiated `m` times along `axis` .", "question_id": 8529},
{"snippet": "polynomial.hermite_e.hermeder(c, scl=1, axis=0)", "intent": "Differentiate a Hermite_e series . Returns the series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) .", "question_id": 8530},
{"snippet": "polynomial.hermite_e.hermeder(c, m=1, scl=1, axis=0)", "intent": "Differentiate a Hermite_e series . Returns the series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) .", "question_id": 8531},
{"snippet": "numpy.deprecate_with_doc(msg)", "intent": "Deprecates a function and includes the deprecation in its docstring . With arguments `msg`.", "question_id": 8532},
{"snippet": "memmap.flat", "intent": "A 1-D iterator over the array.", "question_id": 8533},
{"snippet": "matrix.squeeze()", "intent": "Return a possibly reshaped matrix .", "question_id": 8534},
{"snippet": "matrix.squeeze(axis=None)", "intent": "Return a possibly reshaped matrix . The returned matrix is always either m itself or a view into m. Supplying an `axis` keyword argument will not affect the returned matrix but it may cause an error to be raised .", "question_id": 8535},
{"snippet": "ma.masked_array.resize(newshape)", "intent": "This method is difficult to implement safely and may be deprecated in future releases of NumPy . With arguments `newshape`.", "question_id": 8536},
{"snippet": "ma.masked_array.resize(newshape, refcheck=True)", "intent": "This method is difficult to implement safely and may be deprecated in future releases of NumPy . With arguments `newshape`, `refcheck`.", "question_id": 8537},
{"snippet": "ma.masked_array.resize(newshape, order=False)", "intent": "This method is difficult to implement safely and may be deprecated in future releases of NumPy . With arguments `newshape`, `order`.", "question_id": 8538},
{"snippet": "ma.masked_array.resize(newshape, refcheck=True, order=False)", "intent": "This method is difficult to implement safely and may be deprecated in future releases of NumPy . With arguments `newshape`, `refcheck`, `order`.", "question_id": 8539},
{"snippet": "chararray.flags", "intent": "Information about the memory layout of the array.", "question_id": 8540},
{"snippet": "numpy.trace(a)", "intent": "Return the sum along diagonals of the array . If `a` is 2-D , the sum along its diagonal with the given `offset` is returned , i.e. , the sum of elements a [ i , i+offset ] for all i .", "question_id": 8541},
{"snippet": "numpy.trace(a, offset=0)", "intent": "Return the sum along diagonals of the array . If `a` is 2-D , the sum along its diagonal with the given `offset` is returned , i.e. , the sum of elements a [ i , i+offset ] for all i .", "question_id": 8542},
{"snippet": "numpy.trace(a, axis1=0)", "intent": "Return the sum along diagonals of the array . If `a` is 2-D , the sum along its diagonal with the given `offset` is returned , i.e. , the sum of elements a [ i , i+offset ] for all i . If a has more than two dimensions , then the axes specified by `axis1` and `axis2` are used to determine the 2-D sub-arrays whose traces are returned .", "question_id": 8543},
{"snippet": "numpy.trace(a, axis2=1)", "intent": "Return the sum along diagonals of the array . If `a` is 2-D , the sum along its diagonal with the given `offset` is returned , i.e. , the sum of elements a [ i , i+offset ] for all i . If a has more than two dimensions , then the axes specified by `axis1` and `axis2` are used to determine the 2-D sub-arrays whose traces are returned .", "question_id": 8544},
{"snippet": "numpy.trace(a, dtype=None)", "intent": "Return the sum along diagonals of the array . If `a` is 2-D , the sum along its diagonal with the given `offset` is returned , i.e. , the sum of elements a [ i , i+offset ] for all i . With arguments `dtype`.", "question_id": 8545},
{"snippet": "numpy.trace(a, out=None)", "intent": "Return the sum along diagonals of the array . If `a` is 2-D , the sum along its diagonal with the given `offset` is returned , i.e. , the sum of elements a [ i , i+offset ] for all i . With arguments `out`.", "question_id": 8546},
{"snippet": "numpy.trace(a, offset=0, axis1=0)", "intent": "Return the sum along diagonals of the array . If `a` is 2-D , the sum along its diagonal with the given `offset` is returned , i.e. , the sum of elements a [ i , i+offset ] for all i . If a has more than two dimensions , then the axes specified by `axis1` and `axis2` are used to determine the 2-D sub-arrays whose traces are returned .", "question_id": 8547},
{"snippet": "numpy.trace(a, offset=0, axis2=1)", "intent": "Return the sum along diagonals of the array . If `a` is 2-D , the sum along its diagonal with the given `offset` is returned , i.e. , the sum of elements a [ i , i+offset ] for all i . If a has more than two dimensions , then the axes specified by `axis1` and `axis2` are used to determine the 2-D sub-arrays whose traces are returned .", "question_id": 8548},
{"snippet": "numpy.trace(a, offset=0, dtype=None)", "intent": "Return the sum along diagonals of the array . If `a` is 2-D , the sum along its diagonal with the given `offset` is returned , i.e. , the sum of elements a [ i , i+offset ] for all i . With arguments `dtype`.", "question_id": 8549},
{"snippet": "numpy.trace(a, offset=0, out=None)", "intent": "Return the sum along diagonals of the array . If `a` is 2-D , the sum along its diagonal with the given `offset` is returned , i.e. , the sum of elements a [ i , i+offset ] for all i . With arguments `out`.", "question_id": 8550},
{"snippet": "numpy.seterrcall(func)", "intent": "Set the floating-point error callback function or log object . With arguments `func`.", "question_id": 8551},
{"snippet": "polynomial.polynomial.polymulx(c)", "intent": "Multiply a polynomial by x . Multiply the polynomial `c` by x , where x is the independent variable .", "question_id": 8552},
{"snippet": "numpy.cumsum(a)", "intent": "Return the cumulative sum of the elements along `a` given `axis` .", "question_id": 8553},
{"snippet": "numpy.cumsum(a, axis=None)", "intent": "Return the cumulative sum of the elements along `a` given `axis` .", "question_id": 8554},
{"snippet": "numpy.cumsum(a, dtype=None)", "intent": "Return the cumulative sum of the elements along `a` given `axis` . With arguments `dtype`.", "question_id": 8555},
{"snippet": "numpy.cumsum(a, out=None)", "intent": "Return the cumulative sum of the elements along `a` given `axis` . With arguments `out`.", "question_id": 8556},
{"snippet": "numpy.cumsum(a, axis=None, dtype=None)", "intent": "Return the cumulative sum of the elements along `a` given `axis` . With arguments `dtype`.", "question_id": 8557},
{"snippet": "numpy.cumsum(a, axis=None, out=None)", "intent": "Return the cumulative sum of the elements along `a` given `axis` . With arguments `out`.", "question_id": 8558},
{"snippet": "numpy.cumsum(a, dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along `a` given `axis` . With arguments `dtype`, `out`.", "question_id": 8559},
{"snippet": "numpy.cumsum(a, axis=None, dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along `a` given `axis` . With arguments `dtype`, `out`.", "question_id": 8560},
{"snippet": "ndarray.round()", "intent": "Return a with each element rounded to the given number of `decimals` .", "question_id": 8561},
{"snippet": "ndarray.round(decimals=0)", "intent": "Return a with each element rounded to the given number of `decimals` .", "question_id": 8562},
{"snippet": "ndarray.round(out=None)", "intent": "Return a with each element rounded to the given number of `decimals` . With arguments `out`.", "question_id": 8563},
{"snippet": "ndarray.round(decimals=0, out=None)", "intent": "Return a with each element rounded to the given number of `decimals` . With arguments `out`.", "question_id": 8564},
{"snippet": "ndarray.__invert__(/)", "intent": "~self With arguments `/`.", "question_id": 8565},
{"snippet": "chararray.view(dtype, type)", "intent": "New view of array with the same data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) Viewing array data using a different `type` and dtype :", "question_id": 8566},
{"snippet": "chararray.view(dtype)", "intent": "New view of array with the same data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . )", "question_id": 8567},
{"snippet": "chararray.view()", "intent": "New view of array with the same data .", "question_id": 8568},
{"snippet": "ndarray.__le__(value, /)", "intent": "Return self < =value . With arguments `value`, `/`.", "question_id": 8569},
{"snippet": "numpy.pad(array, pad_width, **kwargs)", "intent": "Pad an `array` . With arguments `pad_width`, `**kwargs`.", "question_id": 8570},
{"snippet": "numpy.pad(array, pad_width, **kwargs, mode='constant')", "intent": "Pad an `array` . With arguments `pad_width`, `**kwargs`, `mode`.", "question_id": 8571},
{"snippet": "numpy.nanargmax(a)", "intent": "Return the indices of the maximum values in the specified `axis` ignoring NaNs . Warning : the results can not be trusted if `a` slice contains only NaNs and -Infs .", "question_id": 8572},
{"snippet": "numpy.nanargmax(a, axis=None)", "intent": "Return the indices of the maximum values in the specified `axis` ignoring NaNs . Warning : the results can not be trusted if `a` slice contains only NaNs and -Infs .", "question_id": 8573},
{"snippet": "recarray.tolist()", "intent": "Return the array as an a.ndim-levels deep nested list of Python scalars .", "question_id": 8574},
{"snippet": "numpy.ogrid", "intent": "nd_grid instance which returns an open multi-dimensional \u201cmeshgrid\u201d.", "question_id": 8575},
{"snippet": "matrix.item(*args)", "intent": "Copy an element of an array to a standard Python scalar and return it . With arguments `*args`.", "question_id": 8576},
{"snippet": "chararray.zfill(width)", "intent": "Return the numeric string left-filled with zeros in a string of length `width` .", "question_id": 8577},
{"snippet": "memmap.cumprod()", "intent": "Return the cumulative product of the elements along the given `axis` .", "question_id": 8578},
{"snippet": "memmap.cumprod(axis=None)", "intent": "Return the cumulative product of the elements along the given `axis` .", "question_id": 8579},
{"snippet": "memmap.cumprod(dtype=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`.", "question_id": 8580},
{"snippet": "memmap.cumprod(out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `out`.", "question_id": 8581},
{"snippet": "memmap.cumprod(axis=None, dtype=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`.", "question_id": 8582},
{"snippet": "memmap.cumprod(axis=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `out`.", "question_id": 8583},
{"snippet": "memmap.cumprod(dtype=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 8584},
{"snippet": "memmap.cumprod(axis=None, dtype=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`, `out`.", "question_id": 8585},
{"snippet": "record.view()", "intent": "Scalar method identical to the corresponding array attribute .", "question_id": 8586},
{"snippet": "matrix.dtype", "intent": "Data-type of the array\u2019s elements.", "question_id": 8587},
{"snippet": "random.RandomState.laplace()", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) .", "question_id": 8588},
{"snippet": "random.RandomState.laplace(loc=0.0)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `loc`.", "question_id": 8589},
{"snippet": "random.RandomState.laplace(scale=1.0)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) .", "question_id": 8590},
{"snippet": "random.RandomState.laplace(size=None)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `size`.", "question_id": 8591},
{"snippet": "random.RandomState.laplace(loc=0.0, scale=1.0)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `loc`.", "question_id": 8592},
{"snippet": "random.RandomState.laplace(loc=0.0, size=None)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `loc`, `size`.", "question_id": 8593},
{"snippet": "random.RandomState.laplace(scale=1.0, size=None)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `size`.", "question_id": 8594},
{"snippet": "random.RandomState.laplace(loc=0.0, scale=1.0, size=None)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `loc`, `size`.", "question_id": 8595},
{"snippet": "ma.masked_array.count()", "intent": "Count the non-masked elements of the array along the given `axis` .", "question_id": 8596},
{"snippet": "ma.masked_array.count(axis=None)", "intent": "Count the non-masked elements of the array along the given `axis` .", "question_id": 8597},
{"snippet": "ma.masked_array.count(keepdims=<no value>)", "intent": "Count the non-masked elements of the array along the given `axis` . With arguments `keepdims`.", "question_id": 8598},
{"snippet": "ma.masked_array.count(axis=None, keepdims=<no value>)", "intent": "Count the non-masked elements of the array along the given `axis` . With arguments `keepdims`.", "question_id": 8599},
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.conf_features_partial()", "intent": "Return a dictionary of supported CPU features by the platform , and accumulate the rest of undefined options in conf_features , the returned dict has same rules and notes in class attribute conf_features , also its override any options that been set in \u2018 conf_features \u2019 .", "question_id": 8600},
{"snippet": "ma.MaskedArray.__or__(value, /)", "intent": "Return self|value . With arguments `value`, `/`.", "question_id": 8601},
{"snippet": "ma.MaskedArray.__ixor__(value, /)", "intent": "Return self^=value . With arguments `value`, `/`.", "question_id": 8602},
