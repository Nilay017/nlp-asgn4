{"snippet": "linalg.eigvals(a)", "intent": "Compute the eigenvalues of `a` general matrix . numpy", "question_id": 16000}
{"snippet": "numpy.fromfunction(function, shape, **kwargs)", "intent": "Construct an array by executing a `function` over each coordinate . With arguments `shape`, `**kwargs`. numpy", "question_id": 16001}
{"snippet": "numpy.fromfunction(function, shape, **kwargs, dtype=<class 'float'>)", "intent": "Construct an array by executing a `function` over each coordinate . Keywords other than `dtype` are passed to function . With arguments `shape`, `**kwargs`. numpy", "question_id": 16002}
{"snippet": "numpy.fromfunction(function, shape, **kwargs, like=None)", "intent": "Construct an array by executing a `function` over each coordinate . With arguments `shape`, `**kwargs`, `like`. numpy", "question_id": 16003}
{"snippet": "numpy.fromfunction(function, shape, **kwargs, dtype=<class 'float'>, like=None)", "intent": "Construct an array by executing a `function` over each coordinate . Keywords other than `dtype` are passed to function . With arguments `shape`, `**kwargs`, `like`. numpy", "question_id": 16004}
{"snippet": "numpy.greater_equal(x1, x2, /, signature, extobj)", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 16005}
{"snippet": "numpy.greater_equal(x1, x2, /, signature, extobj, out=None)", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 16006}
{"snippet": "numpy.greater_equal(x1, x2, /, signature, extobj, where=True)", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 16007}
{"snippet": "numpy.greater_equal(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 16008}
{"snippet": "numpy.greater_equal(x1, x2, /, signature, extobj, order='K')", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 16009}
{"snippet": "numpy.greater_equal(x1, x2, /, signature, extobj, dtype=None)", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 16010}
{"snippet": "numpy.greater_equal(x1, x2, /, signature, extobj, subok=True)", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 16011}
{"snippet": "numpy.greater_equal(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 16012}
{"snippet": "numpy.greater_equal(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 16013}
{"snippet": "numpy.greater_equal(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 16014}
{"snippet": "numpy.greater_equal(x1, x2, /, signature)", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`. numpy", "question_id": 16015}
{"snippet": "numpy.greater_equal(x1, x2, /, signature, out=None)", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `out`. numpy", "question_id": 16016}
{"snippet": "numpy.greater_equal(x1, x2, /, signature, where=True)", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `where`. numpy", "question_id": 16017}
{"snippet": "numpy.greater_equal(x1, x2, /, signature, casting='same_kind')", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `casting`. numpy", "question_id": 16018}
{"snippet": "numpy.greater_equal(x1, x2, /, signature, order='K')", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `order`. numpy", "question_id": 16019}
{"snippet": "numpy.greater_equal(x1, x2, /, signature, dtype=None)", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 16020}
{"snippet": "numpy.greater_equal(x1, x2, /, signature, subok=True)", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `subok`. numpy", "question_id": 16021}
{"snippet": "numpy.greater_equal(x1, x2, /, signature, out=None, where=True)", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 16022}
{"snippet": "numpy.greater_equal(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 16023}
{"snippet": "numpy.greater_equal(x1, x2, /, signature, out=None, order='K')", "intent": "Return the truth value of ( `x1` > = `x2` ) element-wise . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 16024}
{"snippet": "polynomial.polynomial.Polynomial.trim()", "intent": "Remove trailing coefficients numpy", "question_id": 16025}
{"snippet": "polynomial.polynomial.Polynomial.trim(tol=0)", "intent": "Remove trailing coefficients Remove trailing coefficients until a coefficient is reached whose absolute value greater than `tol` or the beginning of the series is reached . numpy", "question_id": 16026}
{"snippet": "memmap.itemset(*args)", "intent": "Insert scalar into an array ( scalar is cast to array \u2019 s dtype , if possible ) With arguments `*args`. numpy", "question_id": 16027}
{"snippet": "ndarray.size", "intent": "Number of elements in the array. numpy", "question_id": 16028}
{"snippet": "polynomial.polynomial.polyroots(c)", "intent": "Compute the roots of a polynomial . With arguments `c`. numpy", "question_id": 16029}
{"snippet": "generic.__array_priority__", "intent": "Array priority. numpy", "question_id": 16030}
{"snippet": "polynomial.polynomial.polyline(off, scl)", "intent": "Returns an array representing a linear polynomial . With arguments `off`, `scl`. numpy", "question_id": 16031}
{"snippet": "numpy.getbufsize()", "intent": "Return the size of the buffer used in ufuncs . numpy", "question_id": 16032}
{"snippet": "chararray.squeeze()", "intent": "Remove axes of length one from a . numpy", "question_id": 16033}
{"snippet": "chararray.squeeze(axis=None)", "intent": "Remove axes of length one from a . With arguments `axis`. numpy", "question_id": 16034}
{"snippet": "ma.MaskType.itemsize", "intent": "The length of one element in bytes. numpy", "question_id": 16035}
{"snippet": "char.isdecimal(a)", "intent": "For each element , return True if there are only decimal characters in the element . With arguments `a`. numpy", "question_id": 16036}
{"snippet": "polynomial.legendre.Legendre.fromroots(roots)", "intent": "Return series instance that has the specified `roots` . numpy", "question_id": 16037}
{"snippet": "polynomial.legendre.Legendre.fromroots(roots, domain=)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`. numpy", "question_id": 16038}
{"snippet": "polynomial.legendre.Legendre.fromroots(roots, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `window`. numpy", "question_id": 16039}
{"snippet": "polynomial.legendre.Legendre.fromroots(roots, domain=, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`, `window`. numpy", "question_id": 16040}
{"snippet": "polynomial.legendre.Legendre.fromroots()", "intent": "Return series instance that has the specified `roots` . numpy", "question_id": 16041}
{"snippet": "polynomial.legendre.Legendre.fromroots(domain=)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`. numpy", "question_id": 16042}
{"snippet": "polynomial.legendre.Legendre.fromroots(window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `window`. numpy", "question_id": 16043}
{"snippet": "polynomial.legendre.Legendre.fromroots(domain=, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`, `window`. numpy", "question_id": 16044}
{"snippet": "polynomial.hermite_e.hermepow(c, pow)", "intent": "Raise a Hermite series to a power . Returns the Hermite series `c` raised to the power `pow` . numpy", "question_id": 16045}
{"snippet": "polynomial.hermite_e.hermepow(c, pow, maxpower=16)", "intent": "Raise a Hermite series to a power . Returns the Hermite series `c` raised to the power `pow` . With arguments `maxpower`. numpy", "question_id": 16046}
{"snippet": "numpy.genfromtxt(fname)", "intent": "Load data from a text file , with missing values handled as specified . With arguments `fname`. numpy", "question_id": 16047}
{"snippet": "numpy.genfromtxt(fname, dtype=<class 'float'>)", "intent": "Load data from a text file , with missing values handled as specified . Comma delimited file with mixed `dtype` With arguments `fname`. numpy", "question_id": 16048}
{"snippet": "numpy.genfromtxt(fname, comments='#')", "intent": "Load data from a text file , with missing values handled as specified . Each line past the first `skip_header` lines is split at the `delimiter` character , and characters following the `comments` character are discarded . With arguments `fname`. numpy", "question_id": 16049}
{"snippet": "numpy.genfromtxt(fname, delimiter=None)", "intent": "Load data from a text file , with missing values handled as specified . Each line past the first `skip_header` lines is split at the `delimiter` character , and characters following the `comments` character are discarded . With arguments `fname`. numpy", "question_id": 16050}
{"snippet": "numpy.genfromtxt(fname, skip_header=0)", "intent": "Load data from a text file , with missing values handled as specified . Each line past the first `skip_header` lines is split at the `delimiter` character , and characters following the `comments` character are discarded . With arguments `fname`. numpy", "question_id": 16051}
{"snippet": "numpy.genfromtxt(fname, skip_footer=0)", "intent": "Load data from a text file , with missing values handled as specified . With arguments `fname`, `skip_footer`. numpy", "question_id": 16052}
{"snippet": "numpy.genfromtxt(fname, converters=None)", "intent": "Load data from a text file , with missing values handled as specified . With arguments `fname`, `converters`. numpy", "question_id": 16053}
{"snippet": "numpy.genfromtxt(fname, missing_values=None)", "intent": "Load data from a text file , with missing values handled as specified . With arguments `fname`, `missing_values`. numpy", "question_id": 16054}
{"snippet": "numpy.genfromtxt(fname, filling_values=None)", "intent": "Load data from a text file , with missing values handled as specified . With arguments `fname`, `filling_values`. numpy", "question_id": 16055}
{"snippet": "numpy.genfromtxt(fname, usecols=None)", "intent": "Load data from a text file , with missing values handled as specified . With arguments `fname`, `usecols`. numpy", "question_id": 16056}
{"snippet": "numpy.genfromtxt()", "intent": "Load data from a text file , with missing values handled as specified . numpy", "question_id": 16057}
{"snippet": "numpy.genfromtxt(dtype=<class 'float'>)", "intent": "Load data from a text file , with missing values handled as specified . Comma delimited file with mixed `dtype` numpy", "question_id": 16058}
{"snippet": "numpy.genfromtxt(comments='#')", "intent": "Load data from a text file , with missing values handled as specified . Each line past the first `skip_header` lines is split at the `delimiter` character , and characters following the `comments` character are discarded . numpy", "question_id": 16059}
{"snippet": "numpy.genfromtxt(delimiter=None)", "intent": "Load data from a text file , with missing values handled as specified . Each line past the first `skip_header` lines is split at the `delimiter` character , and characters following the `comments` character are discarded . numpy", "question_id": 16060}
{"snippet": "numpy.genfromtxt(skip_header=0)", "intent": "Load data from a text file , with missing values handled as specified . Each line past the first `skip_header` lines is split at the `delimiter` character , and characters following the `comments` character are discarded . numpy", "question_id": 16061}
{"snippet": "numpy.genfromtxt(skip_footer=0)", "intent": "Load data from a text file , with missing values handled as specified . With arguments `skip_footer`. numpy", "question_id": 16062}
{"snippet": "numpy.genfromtxt(converters=None)", "intent": "Load data from a text file , with missing values handled as specified . With arguments `converters`. numpy", "question_id": 16063}
{"snippet": "numpy.genfromtxt(missing_values=None)", "intent": "Load data from a text file , with missing values handled as specified . With arguments `missing_values`. numpy", "question_id": 16064}
{"snippet": "numpy.genfromtxt(filling_values=None)", "intent": "Load data from a text file , with missing values handled as specified . With arguments `filling_values`. numpy", "question_id": 16065}
{"snippet": "numpy.genfromtxt(usecols=None)", "intent": "Load data from a text file , with missing values handled as specified . With arguments `usecols`. numpy", "question_id": 16066}
{"snippet": "chararray.sum()", "intent": "Return the sum of the array elements over the given `axis` . numpy", "question_id": 16067}
{"snippet": "chararray.sum(axis=None)", "intent": "Return the sum of the array elements over the given `axis` . numpy", "question_id": 16068}
{"snippet": "chararray.sum(dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 16069}
{"snippet": "chararray.sum(out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`. numpy", "question_id": 16070}
{"snippet": "chararray.sum(keepdims=False)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`. numpy", "question_id": 16071}
{"snippet": "chararray.sum(initial=0)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `initial`. numpy", "question_id": 16072}
{"snippet": "chararray.sum(where=True)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `where`. numpy", "question_id": 16073}
{"snippet": "chararray.sum(axis=None, dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 16074}
{"snippet": "chararray.sum(axis=None, out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`. numpy", "question_id": 16075}
{"snippet": "chararray.sum(axis=None, keepdims=False)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`. numpy", "question_id": 16076}
{"snippet": "char.find(a, sub)", "intent": "For each element , return the lowest index in the string where substring `sub` is found . With arguments `a`. numpy", "question_id": 16077}
{"snippet": "char.find(a, sub, start=0)", "intent": "For each element , return the lowest index in the string where substring `sub` is found . For each element , return the lowest index in the string where substring sub is found , such that sub is contained in the range [ `start` , `end` ] . With arguments `a`. numpy", "question_id": 16078}
{"snippet": "char.find(a, sub, end=None)", "intent": "For each element , return the lowest index in the string where substring `sub` is found . For each element , return the lowest index in the string where substring sub is found , such that sub is contained in the range [ `start` , `end` ] . With arguments `a`. numpy", "question_id": 16079}
{"snippet": "char.find(a, sub, start=0, end=None)", "intent": "For each element , return the lowest index in the string where substring `sub` is found . For each element , return the lowest index in the string where substring sub is found , such that sub is contained in the range [ `start` , `end` ] . With arguments `a`. numpy", "question_id": 16080}
{"snippet": "ufunc.outer(A, B, /, **kwargs)", "intent": "Apply the ufunc op to all pairs ( a , b ) with a in `A` and b in `B` . With arguments `/`, `**kwargs`. numpy", "question_id": 16081}
{"snippet": "polynomial.hermite.herm2poly(c)", "intent": "Convert a Hermite series to a polynomial . With arguments `c`. numpy", "question_id": 16082}
{"snippet": "random.RandomState.rayleigh()", "intent": "Draw samples from a Rayleigh distribution . numpy", "question_id": 16083}
{"snippet": "random.RandomState.rayleigh(scale=1.0)", "intent": "Draw samples from a Rayleigh distribution . With arguments `scale`. numpy", "question_id": 16084}
{"snippet": "random.RandomState.rayleigh(size=None)", "intent": "Draw samples from a Rayleigh distribution . With arguments `size`. numpy", "question_id": 16085}
{"snippet": "random.RandomState.rayleigh(scale=1.0, size=None)", "intent": "Draw samples from a Rayleigh distribution . With arguments `scale`, `size`. numpy", "question_id": 16086}
{"snippet": "ma.MaskType.conjugate()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 16087}
{"snippet": "recarray.itemset(*args)", "intent": "Insert scalar into an array ( scalar is cast to array \u2019 s dtype , if possible ) With arguments `*args`. numpy", "question_id": 16088}
{"snippet": "polynomial.hermite.Hermite.truncate(size)", "intent": "Truncate series to length `size` . numpy", "question_id": 16089}
{"snippet": "random.Generator.power(a)", "intent": "Draws samples in [ 0 , 1 ] from `a` power distribution with positive exponent a - 1 . numpy", "question_id": 16090}
{"snippet": "random.Generator.power(a, size=None)", "intent": "Draws samples in [ 0 , 1 ] from `a` power distribution with positive exponent a - 1 . With arguments `size`. numpy", "question_id": 16091}
{"snippet": "ndarray.__divmod__(value, /)", "intent": "Return divmod ( self , `value` ) . With arguments `/`. numpy", "question_id": 16092}
{"snippet": "ma.argmax(self)", "intent": "Returns array of indices of the maximum values along the given `axis` . With arguments `self`. numpy", "question_id": 16093}
{"snippet": "ma.argmax(self, axis=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . With arguments `self`. numpy", "question_id": 16094}
{"snippet": "ma.argmax(self, fill_value=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . Masked values are treated as if they had the value `fill_value` . With arguments `self`. numpy", "question_id": 16095}
{"snippet": "ma.argmax(self, out=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . With arguments `self`, `out`. numpy", "question_id": 16096}
{"snippet": "ma.argmax(self, axis=None, fill_value=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . Masked values are treated as if they had the value `fill_value` . With arguments `self`. numpy", "question_id": 16097}
{"snippet": "ma.argmax(self, axis=None, out=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . With arguments `self`, `out`. numpy", "question_id": 16098}
{"snippet": "ma.argmax(self, fill_value=None, out=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . Masked values are treated as if they had the value `fill_value` . With arguments `self`, `out`. numpy", "question_id": 16099}
{"snippet": "ma.argmax(self, axis=None, fill_value=None, out=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . Masked values are treated as if they had the value `fill_value` . With arguments `self`, `out`. numpy", "question_id": 16100}
{"snippet": "numpy.empty_like(prototype)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`. numpy", "question_id": 16101}
{"snippet": "numpy.empty_like(prototype, dtype=None)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `dtype`. numpy", "question_id": 16102}
{"snippet": "numpy.empty_like(prototype, order='K')", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `order`. numpy", "question_id": 16103}
{"snippet": "numpy.empty_like(prototype, subok=True)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `subok`. numpy", "question_id": 16104}
{"snippet": "numpy.empty_like(prototype, shape=None)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`. numpy", "question_id": 16105}
{"snippet": "numpy.empty_like(prototype, dtype=None, order='K')", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `dtype`, `order`. numpy", "question_id": 16106}
{"snippet": "numpy.empty_like(prototype, dtype=None, subok=True)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `dtype`, `subok`. numpy", "question_id": 16107}
{"snippet": "numpy.empty_like(prototype, dtype=None, shape=None)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `dtype`. numpy", "question_id": 16108}
{"snippet": "numpy.empty_like(prototype, order='K', subok=True)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `order`, `subok`. numpy", "question_id": 16109}
{"snippet": "numpy.empty_like(prototype, order='K', shape=None)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `order`. numpy", "question_id": 16110}
{"snippet": "numpy.busdaycalendar()", "intent": "A business day calendar object that efficiently stores information defining valid days for the busday family of functions . numpy", "question_id": 16111}
{"snippet": "numpy.busdaycalendar(weekmask='1111100')", "intent": "A business day calendar object that efficiently stores information defining valid days for the busday family of functions . Once a busdaycalendar object is created , the `weekmask` and `holidays` can not be modified . numpy", "question_id": 16112}
{"snippet": "numpy.busdaycalendar(holidays=None)", "intent": "A business day calendar object that efficiently stores information defining valid days for the busday family of functions . Once a busdaycalendar object is created , the `weekmask` and `holidays` can not be modified . numpy", "question_id": 16113}
{"snippet": "numpy.busdaycalendar(weekmask='1111100', holidays=None)", "intent": "A business day calendar object that efficiently stores information defining valid days for the busday family of functions . Once a busdaycalendar object is created , the `weekmask` and `holidays` can not be modified . numpy", "question_id": 16114}
{"snippet": "char.chararray.view(dtype, type)", "intent": "New view of array with the same data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) Viewing array data using a different `type` and dtype : numpy", "question_id": 16115}
{"snippet": "char.chararray.view(dtype)", "intent": "New view of array with the same data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) numpy", "question_id": 16116}
{"snippet": "char.chararray.view()", "intent": "New view of array with the same data . numpy", "question_id": 16117}
{"snippet": "random.logistic()", "intent": "Draw samples from a logistic distribution . numpy", "question_id": 16118}
{"snippet": "random.logistic(loc=0.0)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . numpy", "question_id": 16119}
{"snippet": "random.logistic(scale=1.0)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . numpy", "question_id": 16120}
{"snippet": "random.logistic(size=None)", "intent": "Draw samples from a logistic distribution . With arguments `size`. numpy", "question_id": 16121}
{"snippet": "random.logistic(loc=0.0, scale=1.0)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . numpy", "question_id": 16122}
{"snippet": "random.logistic(loc=0.0, size=None)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . With arguments `size`. numpy", "question_id": 16123}
{"snippet": "random.logistic(scale=1.0, size=None)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . With arguments `size`. numpy", "question_id": 16124}
{"snippet": "random.logistic(loc=0.0, scale=1.0, size=None)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . With arguments `size`. numpy", "question_id": 16125}
{"snippet": "ma.shape(obj)", "intent": "Return the shape of an array . With arguments `obj`. numpy", "question_id": 16126}
{"snippet": "memmap.shape", "intent": "Tuple of array dimensions. numpy", "question_id": 16127}
{"snippet": "numpy.flipud(m)", "intent": "Reverse the order of elements along axis 0 ( up/down ) . Equivalent to `m` [ : :-1 , ... ] or np.flip ( m , axis=0 ) . numpy", "question_id": 16128}
{"snippet": "random.power(a)", "intent": "Draws samples in [ 0 , 1 ] from `a` power distribution with positive exponent a - 1 . numpy", "question_id": 16129}
{"snippet": "random.power(a, size=None)", "intent": "Draws samples in [ 0 , 1 ] from `a` power distribution with positive exponent a - 1 . With arguments `size`. numpy", "question_id": 16130}
{"snippet": "ndarray.__eq__(value, /)", "intent": "Return self==value . With arguments `value`, `/`. numpy", "question_id": 16131}
{"snippet": "matrix.searchsorted(v)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . numpy", "question_id": 16132}
{"snippet": "matrix.searchsorted(v, side='left')", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`. numpy", "question_id": 16133}
{"snippet": "matrix.searchsorted(v, sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `sorter`. numpy", "question_id": 16134}
{"snippet": "matrix.searchsorted(v, side='left', sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`, `sorter`. numpy", "question_id": 16135}
{"snippet": "record.max()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 16136}
{"snippet": "polynomial.legendre.leggrid2d(x, y, c)", "intent": "Evaluate a 2-D Legendre series on the Cartesian product of `x` and `y` . In either case , either x and y or their elements must support multiplication and addition both with themselves and with the elements of `c` . numpy", "question_id": 16137}
{"snippet": "ma.masked_array.nbytes", "intent": "Total bytes consumed by the elements of the array. numpy", "question_id": 16138}
{"snippet": "ma.nonzero(self)", "intent": "Return the indices of unmasked elements that are not zero . With arguments `self`. numpy", "question_id": 16139}
{"snippet": "memmap.reshape(shape)", "intent": "Returns an array containing the same data with a new `shape` . numpy", "question_id": 16140}
{"snippet": "memmap.reshape(shape, order='C')", "intent": "Returns an array containing the same data with a new `shape` . With arguments `order`. numpy", "question_id": 16141}
{"snippet": "ma.masked_outside(x, v1, v2)", "intent": "Mask an array outside a given interval . Shortcut to masked_where , where condition is True for `x` outside the interval [ `v1` , `v2` ] ( x < v1 ) | ( x > v2 ) . numpy", "question_id": 16142}
{"snippet": "ma.masked_outside(x, v1, v2, copy=True)", "intent": "Mask an array outside a given interval . Shortcut to masked_where , where condition is True for `x` outside the interval [ `v1` , `v2` ] ( x < v1 ) | ( x > v2 ) . With arguments `copy`. numpy", "question_id": 16143}
{"snippet": "numpy.nanquantile(a, q)", "intent": "Compute the qth quantile of the data along the specified `axis` , while ignoring nan values . With arguments `a`, `q`. numpy", "question_id": 16144}
{"snippet": "numpy.nanquantile(a, q, axis=None)", "intent": "Compute the qth quantile of the data along the specified `axis` , while ignoring nan values . With arguments `a`, `q`. numpy", "question_id": 16145}
{"snippet": "numpy.nanquantile(a, q, out=None)", "intent": "Compute the qth quantile of the data along the specified `axis` , while ignoring nan values . With arguments `a`, `q`, `out`. numpy", "question_id": 16146}
{"snippet": "numpy.nanquantile(a, q, overwrite_input=False)", "intent": "Compute the qth quantile of the data along the specified `axis` , while ignoring nan values . With arguments `a`, `q`, `overwrite_input`. numpy", "question_id": 16147}
{"snippet": "numpy.nanquantile(a, q, interpolation='linear')", "intent": "Compute the qth quantile of the data along the specified `axis` , while ignoring nan values . With arguments `a`, `q`, `interpolation`. numpy", "question_id": 16148}
{"snippet": "numpy.nanquantile(a, q, keepdims=<no value>)", "intent": "Compute the qth quantile of the data along the specified `axis` , while ignoring nan values . With arguments `a`, `q`, `keepdims`. numpy", "question_id": 16149}
{"snippet": "numpy.nanquantile(a, q, axis=None, out=None)", "intent": "Compute the qth quantile of the data along the specified `axis` , while ignoring nan values . With arguments `a`, `q`, `out`. numpy", "question_id": 16150}
{"snippet": "numpy.nanquantile(a, q, axis=None, overwrite_input=False)", "intent": "Compute the qth quantile of the data along the specified `axis` , while ignoring nan values . With arguments `a`, `q`, `overwrite_input`. numpy", "question_id": 16151}
{"snippet": "numpy.nanquantile(a, q, axis=None, interpolation='linear')", "intent": "Compute the qth quantile of the data along the specified `axis` , while ignoring nan values . With arguments `a`, `q`, `interpolation`. numpy", "question_id": 16152}
{"snippet": "numpy.nanquantile(a, q, axis=None, keepdims=<no value>)", "intent": "Compute the qth quantile of the data along the specified `axis` , while ignoring nan values . With arguments `a`, `q`, `keepdims`. numpy", "question_id": 16153}
{"snippet": "numpy.source(object)", "intent": "Print or write to a file the source code for a NumPy `object` . numpy", "question_id": 16154}
{"snippet": "numpy.source(object, output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>)", "intent": "Print or write to a file the source code for a NumPy `object` . With arguments `output`. numpy", "question_id": 16155}
{"snippet": "ma.masked_array.var()", "intent": "Compute the variance along the specified `axis` . numpy", "question_id": 16156}
{"snippet": "ma.masked_array.var(axis=None)", "intent": "Compute the variance along the specified `axis` . numpy", "question_id": 16157}
{"snippet": "ma.masked_array.var(dtype=None)", "intent": "Compute the variance along the specified `axis` . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue . numpy", "question_id": 16158}
{"snippet": "ma.masked_array.var(out=None)", "intent": "Compute the variance along the specified `axis` . With arguments `out`. numpy", "question_id": 16159}
{"snippet": "ma.masked_array.var(ddof=0)", "intent": "Compute the variance along the specified `axis` . If , however , `ddof` is specified , the divisor N - ddof is used instead . numpy", "question_id": 16160}
{"snippet": "ma.masked_array.var(keepdims=<no value>)", "intent": "Compute the variance along the specified `axis` . With arguments `keepdims`. numpy", "question_id": 16161}
{"snippet": "ma.masked_array.var(axis=None, dtype=None)", "intent": "Compute the variance along the specified `axis` . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue . numpy", "question_id": 16162}
{"snippet": "ma.masked_array.var(axis=None, out=None)", "intent": "Compute the variance along the specified `axis` . With arguments `out`. numpy", "question_id": 16163}
{"snippet": "ma.masked_array.var(axis=None, ddof=0)", "intent": "Compute the variance along the specified `axis` . If , however , `ddof` is specified , the divisor N - ddof is used instead . numpy", "question_id": 16164}
{"snippet": "ma.masked_array.var(axis=None, keepdims=<no value>)", "intent": "Compute the variance along the specified `axis` . With arguments `keepdims`. numpy", "question_id": 16165}
{"snippet": "ma.MaskType.cumprod()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 16166}
{"snippet": "dtype.flags", "intent": "Bit-flags describing how this data type is to be interpreted. numpy", "question_id": 16167}
{"snippet": "linalg.norm(x)", "intent": "Matrix or vector norm . With arguments `x`. numpy", "question_id": 16168}
{"snippet": "linalg.norm(x, ord=None)", "intent": "Matrix or vector norm . This function is able to return one of eight different matrix norms , or one of an infinite number of vector norms ( described below ) , depending on the value of the `ord` parameter . With arguments `x`. numpy", "question_id": 16169}
{"snippet": "linalg.norm(x, axis=None)", "intent": "Matrix or vector norm . Using the `axis` argument to compute vector norms : With arguments `x`. numpy", "question_id": 16170}
{"snippet": "linalg.norm(x, keepdims=False)", "intent": "Matrix or vector norm . With arguments `x`, `keepdims`. numpy", "question_id": 16171}
{"snippet": "linalg.norm(x, ord=None, axis=None)", "intent": "Matrix or vector norm . This function is able to return one of eight different matrix norms , or one of an infinite number of vector norms ( described below ) , depending on the value of the `ord` parameter . Using the `axis` argument to compute vector norms : With arguments `x`. numpy", "question_id": 16172}
{"snippet": "linalg.norm(x, ord=None, keepdims=False)", "intent": "Matrix or vector norm . This function is able to return one of eight different matrix norms , or one of an infinite number of vector norms ( described below ) , depending on the value of the `ord` parameter . With arguments `x`, `keepdims`. numpy", "question_id": 16173}
{"snippet": "linalg.norm(x, axis=None, keepdims=False)", "intent": "Matrix or vector norm . Using the `axis` argument to compute vector norms : With arguments `x`, `keepdims`. numpy", "question_id": 16174}
{"snippet": "linalg.norm(x, ord=None, axis=None, keepdims=False)", "intent": "Matrix or vector norm . This function is able to return one of eight different matrix norms , or one of an infinite number of vector norms ( described below ) , depending on the value of the `ord` parameter . Using the `axis` argument to compute vector norms : With arguments `x`, `keepdims`. numpy", "question_id": 16175}
{"snippet": "char.chararray.imag", "intent": "The imaginary part of the array. numpy", "question_id": 16176}
{"snippet": "numpy.ndindex(*shape)", "intent": "An N-dimensional iterator object to index arrays . With arguments `*shape`. numpy", "question_id": 16177}
{"snippet": "memmap.argmax()", "intent": "Return indices of the maximum values along the given `axis` . numpy", "question_id": 16178}
{"snippet": "memmap.argmax(axis=None)", "intent": "Return indices of the maximum values along the given `axis` . numpy", "question_id": 16179}
{"snippet": "memmap.argmax(out=None)", "intent": "Return indices of the maximum values along the given `axis` . With arguments `out`. numpy", "question_id": 16180}
{"snippet": "memmap.argmax(axis=None, out=None)", "intent": "Return indices of the maximum values along the given `axis` . With arguments `out`. numpy", "question_id": 16181}
{"snippet": "numpy.cos(x, /, signature, extobj)", "intent": "Cosine element-wise . With arguments `x`, `/`, `signature`, `extobj`. numpy", "question_id": 16182}
{"snippet": "numpy.cos(x, /, signature, extobj, out=None)", "intent": "Cosine element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `x`, `/`, `signature`, `extobj`. numpy", "question_id": 16183}
{"snippet": "numpy.cos(x, /, signature, extobj, where=True)", "intent": "Cosine element-wise . With arguments `x`, `/`, `signature`, `extobj`, `where`. numpy", "question_id": 16184}
{"snippet": "numpy.cos(x, /, signature, extobj, casting='same_kind')", "intent": "Cosine element-wise . With arguments `x`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 16185}
{"snippet": "numpy.cos(x, /, signature, extobj, order='K')", "intent": "Cosine element-wise . With arguments `x`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 16186}
{"snippet": "numpy.cos(x, /, signature, extobj, dtype=None)", "intent": "Cosine element-wise . With arguments `x`, `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 16187}
{"snippet": "numpy.cos(x, /, signature, extobj, subok=True)", "intent": "Cosine element-wise . With arguments `x`, `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 16188}
{"snippet": "numpy.cos(x, /, signature, extobj, out=None, where=True)", "intent": "Cosine element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `x`, `/`, `signature`, `extobj`, `where`. numpy", "question_id": 16189}
{"snippet": "numpy.cos(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Cosine element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `x`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 16190}
{"snippet": "numpy.cos(x, /, signature, extobj, out=None, order='K')", "intent": "Cosine element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `x`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 16191}
{"snippet": "numpy.cos(x, /, signature)", "intent": "Cosine element-wise . With arguments `x`, `/`, `signature`. numpy", "question_id": 16192}
{"snippet": "numpy.cos(x, /, signature, out=None)", "intent": "Cosine element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `x`, `/`, `signature`. numpy", "question_id": 16193}
{"snippet": "numpy.cos(x, /, signature, where=True)", "intent": "Cosine element-wise . With arguments `x`, `/`, `signature`, `where`. numpy", "question_id": 16194}
{"snippet": "numpy.cos(x, /, signature, casting='same_kind')", "intent": "Cosine element-wise . With arguments `x`, `/`, `signature`, `casting`. numpy", "question_id": 16195}
{"snippet": "numpy.cos(x, /, signature, order='K')", "intent": "Cosine element-wise . With arguments `x`, `/`, `signature`, `order`. numpy", "question_id": 16196}
{"snippet": "numpy.cos(x, /, signature, dtype=None)", "intent": "Cosine element-wise . With arguments `x`, `/`, `signature`, `dtype`. numpy", "question_id": 16197}
{"snippet": "numpy.cos(x, /, signature, subok=True)", "intent": "Cosine element-wise . With arguments `x`, `/`, `signature`, `subok`. numpy", "question_id": 16198}
{"snippet": "numpy.cos(x, /, signature, out=None, where=True)", "intent": "Cosine element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `x`, `/`, `signature`, `where`. numpy", "question_id": 16199}
{"snippet": "numpy.cos(x, /, signature, out=None, casting='same_kind')", "intent": "Cosine element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `x`, `/`, `signature`, `casting`. numpy", "question_id": 16200}
{"snippet": "numpy.cos(x, /, signature, out=None, order='K')", "intent": "Cosine element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `x`, `/`, `signature`, `order`. numpy", "question_id": 16201}
{"snippet": "ma.corrcoef(x)", "intent": "Return Pearson product-moment correlation coefficients . With arguments `x`. numpy", "question_id": 16202}
{"snippet": "ma.corrcoef(x, y=None)", "intent": "Return Pearson product-moment correlation coefficients . With arguments `x`, `y`. numpy", "question_id": 16203}
{"snippet": "ma.corrcoef(x, rowvar=True)", "intent": "Return Pearson product-moment correlation coefficients . With arguments `x`, `rowvar`. numpy", "question_id": 16204}
{"snippet": "ma.corrcoef(x, bias=<no value>)", "intent": "Return Pearson product-moment correlation coefficients . This function accepts but discards arguments `bias` and `ddof` . With arguments `x`. numpy", "question_id": 16205}
{"snippet": "ma.corrcoef(x, allow_masked=True)", "intent": "Return Pearson product-moment correlation coefficients . With arguments `x`, `allow_masked`. numpy", "question_id": 16206}
{"snippet": "ma.corrcoef(x, ddof=<no value>)", "intent": "Return Pearson product-moment correlation coefficients . This function accepts but discards arguments `bias` and `ddof` . With arguments `x`. numpy", "question_id": 16207}
{"snippet": "ma.corrcoef(x, y=None, rowvar=True)", "intent": "Return Pearson product-moment correlation coefficients . With arguments `x`, `y`, `rowvar`. numpy", "question_id": 16208}
{"snippet": "ma.corrcoef(x, y=None, bias=<no value>)", "intent": "Return Pearson product-moment correlation coefficients . This function accepts but discards arguments `bias` and `ddof` . With arguments `x`, `y`. numpy", "question_id": 16209}
{"snippet": "ma.corrcoef(x, y=None, allow_masked=True)", "intent": "Return Pearson product-moment correlation coefficients . With arguments `x`, `y`, `allow_masked`. numpy", "question_id": 16210}
{"snippet": "ma.corrcoef(x, y=None, ddof=<no value>)", "intent": "Return Pearson product-moment correlation coefficients . This function accepts but discards arguments `bias` and `ddof` . With arguments `x`, `y`. numpy", "question_id": 16211}
{"snippet": "ma.is_masked(x)", "intent": "Determine whether input has masked values . Always returns False if `x` isn \u2019 t a MaskedArray . numpy", "question_id": 16212}
{"snippet": "ndarray.strides", "intent": "Tuple of bytes to step in each dimension when traversing an array. numpy", "question_id": 16213}
{"snippet": "numpy.fromfile(file)", "intent": "Construct an array from data in a text or binary `file` . numpy", "question_id": 16214}
{"snippet": "numpy.fromfile(file, dtype=float)", "intent": "Construct an array from data in a text or binary `file` . With arguments `dtype`. numpy", "question_id": 16215}
{"snippet": "numpy.fromfile(file, count=- 1)", "intent": "Construct an array from data in a text or binary `file` . With arguments `count`. numpy", "question_id": 16216}
{"snippet": "numpy.fromfile(file, sep='')", "intent": "Construct an array from data in a text or binary `file` . With arguments `sep`. numpy", "question_id": 16217}
{"snippet": "numpy.fromfile(file, offset=0)", "intent": "Construct an array from data in a text or binary `file` . With arguments `offset`. numpy", "question_id": 16218}
{"snippet": "numpy.fromfile(file, like=None)", "intent": "Construct an array from data in a text or binary `file` . With arguments `like`. numpy", "question_id": 16219}
{"snippet": "numpy.fromfile(file, dtype=float, count=- 1)", "intent": "Construct an array from data in a text or binary `file` . With arguments `dtype`, `count`. numpy", "question_id": 16220}
{"snippet": "numpy.fromfile(file, dtype=float, sep='')", "intent": "Construct an array from data in a text or binary `file` . With arguments `dtype`, `sep`. numpy", "question_id": 16221}
{"snippet": "numpy.fromfile(file, dtype=float, offset=0)", "intent": "Construct an array from data in a text or binary `file` . With arguments `dtype`, `offset`. numpy", "question_id": 16222}
{"snippet": "numpy.fromfile(file, dtype=float, like=None)", "intent": "Construct an array from data in a text or binary `file` . With arguments `dtype`, `like`. numpy", "question_id": 16223}
{"snippet": "testing.assert_array_almost_equal_nulp(x, y)", "intent": "Compare two arrays relatively to their spacing . With arguments `x`, `y`. numpy", "question_id": 16224}
{"snippet": "testing.assert_array_almost_equal_nulp(x, y, nulp=1)", "intent": "Compare two arrays relatively to their spacing . With arguments `x`, `y`, `nulp`. numpy", "question_id": 16225}
{"snippet": "ma.var(self)", "intent": "Compute the variance along the specified `axis` . With arguments `self`. numpy", "question_id": 16226}
{"snippet": "ma.var(self, axis=None)", "intent": "Compute the variance along the specified `axis` . With arguments `self`. numpy", "question_id": 16227}
{"snippet": "ma.var(self, dtype=None)", "intent": "Compute the variance along the specified `axis` . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue . With arguments `self`. numpy", "question_id": 16228}
{"snippet": "ma.var(self, out=None)", "intent": "Compute the variance along the specified `axis` . With arguments `self`, `out`. numpy", "question_id": 16229}
{"snippet": "ma.var(self, ddof=0)", "intent": "Compute the variance along the specified `axis` . If , however , `ddof` is specified , the divisor N - ddof is used instead . With arguments `self`. numpy", "question_id": 16230}
{"snippet": "ma.var(self, keepdims=<no value>)", "intent": "Compute the variance along the specified `axis` . With arguments `self`, `keepdims`. numpy", "question_id": 16231}
{"snippet": "ma.var(self, axis=None, dtype=None)", "intent": "Compute the variance along the specified `axis` . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue . With arguments `self`. numpy", "question_id": 16232}
{"snippet": "ma.var(self, axis=None, out=None)", "intent": "Compute the variance along the specified `axis` . With arguments `self`, `out`. numpy", "question_id": 16233}
{"snippet": "ma.var(self, axis=None, ddof=0)", "intent": "Compute the variance along the specified `axis` . If , however , `ddof` is specified , the divisor N - ddof is used instead . With arguments `self`. numpy", "question_id": 16234}
{"snippet": "ma.var(self, axis=None, keepdims=<no value>)", "intent": "Compute the variance along the specified `axis` . With arguments `self`, `keepdims`. numpy", "question_id": 16235}
{"snippet": "polynomial.hermite_e.hermevander2d(x, y, deg)", "intent": "Pseudo-Vandermonde matrix of given degrees . Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points ( `x` , `y` ) . numpy", "question_id": 16236}
{"snippet": "numpy.hypot(x1, x2, /, signature, extobj)", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 16237}
{"snippet": "numpy.hypot(x1, x2, /, signature, extobj, out=None)", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 16238}
{"snippet": "numpy.hypot(x1, x2, /, signature, extobj, where=True)", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 16239}
{"snippet": "numpy.hypot(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 16240}
{"snippet": "numpy.hypot(x1, x2, /, signature, extobj, order='K')", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 16241}
{"snippet": "numpy.hypot(x1, x2, /, signature, extobj, dtype=None)", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 16242}
{"snippet": "numpy.hypot(x1, x2, /, signature, extobj, subok=True)", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 16243}
{"snippet": "numpy.hypot(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 16244}
{"snippet": "numpy.hypot(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 16245}
{"snippet": "numpy.hypot(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 16246}
{"snippet": "numpy.hypot(x1, x2, /, signature)", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`. numpy", "question_id": 16247}
{"snippet": "numpy.hypot(x1, x2, /, signature, out=None)", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `out`. numpy", "question_id": 16248}
{"snippet": "numpy.hypot(x1, x2, /, signature, where=True)", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `where`. numpy", "question_id": 16249}
{"snippet": "numpy.hypot(x1, x2, /, signature, casting='same_kind')", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `casting`. numpy", "question_id": 16250}
{"snippet": "numpy.hypot(x1, x2, /, signature, order='K')", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `order`. numpy", "question_id": 16251}
{"snippet": "numpy.hypot(x1, x2, /, signature, dtype=None)", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 16252}
{"snippet": "numpy.hypot(x1, x2, /, signature, subok=True)", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `subok`. numpy", "question_id": 16253}
{"snippet": "numpy.hypot(x1, x2, /, signature, out=None, where=True)", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 16254}
{"snippet": "numpy.hypot(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 16255}
{"snippet": "numpy.hypot(x1, x2, /, signature, out=None, order='K')", "intent": "Given the \u201c legs \u201d of a right triangle , return its hypotenuse . Equivalent to sqrt ( `x1` * * 2 + `x2` * * 2 ) , element-wise . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 16256}
{"snippet": "polynomial.legendre.legval2d(x, y, c)", "intent": "Evaluate a 2-D Legendre series at points ( `x` , `y` ) . In either case , either x and y or their elements must support multiplication and addition both with themselves and with the elements of `c` . numpy", "question_id": 16257}
{"snippet": "generic.byteswap()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 16258}
{"snippet": "ma.cov(x)", "intent": "Estimate the covariance matrix . If `x` and `y` have the same shape , a common mask is allocated : if x [ i , j ] is masked , then y [ i , j ] will also be masked . numpy", "question_id": 16259}
{"snippet": "ma.cov(x, y=None)", "intent": "Estimate the covariance matrix . If `x` and `y` have the same shape , a common mask is allocated : if x [ i , j ] is masked , then y [ i , j ] will also be masked . numpy", "question_id": 16260}
{"snippet": "ma.cov(x, rowvar=True)", "intent": "Estimate the covariance matrix . If `x` and `y` have the same shape , a common mask is allocated : if x [ i , j ] is masked , then y [ i , j ] will also be masked . With arguments `rowvar`. numpy", "question_id": 16261}
{"snippet": "ma.cov(x, bias=False)", "intent": "Estimate the covariance matrix . If `x` and `y` have the same shape , a common mask is allocated : if x [ i , j ] is masked , then y [ i , j ] will also be masked . With arguments `bias`. numpy", "question_id": 16262}
{"snippet": "ma.cov(x, allow_masked=True)", "intent": "Estimate the covariance matrix . If `x` and `y` have the same shape , a common mask is allocated : if x [ i , j ] is masked , then y [ i , j ] will also be masked . Setting `allow_masked` to False will raise an exception if values are missing in either of the input arrays . numpy", "question_id": 16263}
{"snippet": "ma.cov(x, ddof=None)", "intent": "Estimate the covariance matrix . If `x` and `y` have the same shape , a common mask is allocated : if x [ i , j ] is masked , then y [ i , j ] will also be masked . With arguments `ddof`. numpy", "question_id": 16264}
{"snippet": "ma.cov(x, y=None, rowvar=True)", "intent": "Estimate the covariance matrix . If `x` and `y` have the same shape , a common mask is allocated : if x [ i , j ] is masked , then y [ i , j ] will also be masked . With arguments `rowvar`. numpy", "question_id": 16265}
{"snippet": "ma.cov(x, y=None, bias=False)", "intent": "Estimate the covariance matrix . If `x` and `y` have the same shape , a common mask is allocated : if x [ i , j ] is masked , then y [ i , j ] will also be masked . With arguments `bias`. numpy", "question_id": 16266}
{"snippet": "ma.cov(x, y=None, allow_masked=True)", "intent": "Estimate the covariance matrix . If `x` and `y` have the same shape , a common mask is allocated : if x [ i , j ] is masked , then y [ i , j ] will also be masked . Setting `allow_masked` to False will raise an exception if values are missing in either of the input arrays . numpy", "question_id": 16267}
{"snippet": "ma.cov(x, y=None, ddof=None)", "intent": "Estimate the covariance matrix . If `x` and `y` have the same shape , a common mask is allocated : if x [ i , j ] is masked , then y [ i , j ] will also be masked . With arguments `ddof`. numpy", "question_id": 16268}
{"snippet": "random.randn(d0, d1, dn)", "intent": "Return a sample ( or samples ) from the \u201c standard normal \u201d distribution . If positive int_like arguments are provided , randn generates an array of shape ( `d0` , `d1` , ... , `dn` ) , filled with random floats sampled from a univariate \u201c normal \u201d ( Gaussian ) distribution of mean 0 and variance 1 . numpy", "question_id": 16269}
{"snippet": "ma.vstack(*args, **kwargs)", "intent": "Stack arrays in sequence vertically ( row wise ) . With arguments `*args`, `**kwargs`. numpy", "question_id": 16270}
{"snippet": "broadcast.nd", "intent": "Number of dimensions of broadcasted result. numpy", "question_id": 16271}
{"snippet": "ma.count(self)", "intent": "Count the non-masked elements of the array along the given `axis` . With arguments `self`. numpy", "question_id": 16272}
{"snippet": "ma.count(self, axis=None)", "intent": "Count the non-masked elements of the array along the given `axis` . With arguments `self`. numpy", "question_id": 16273}
{"snippet": "ma.count(self, keepdims=<no value>)", "intent": "Count the non-masked elements of the array along the given `axis` . With arguments `self`, `keepdims`. numpy", "question_id": 16274}
{"snippet": "ma.count(self, axis=None, keepdims=<no value>)", "intent": "Count the non-masked elements of the array along the given `axis` . With arguments `self`, `keepdims`. numpy", "question_id": 16275}
{"snippet": "chararray.argsort()", "intent": "Returns the indices that would sort this array . numpy", "question_id": 16276}
{"snippet": "chararray.argsort(axis=- 1)", "intent": "Returns the indices that would sort this array . With arguments `axis`. numpy", "question_id": 16277}
{"snippet": "chararray.argsort(kind=None)", "intent": "Returns the indices that would sort this array . With arguments `kind`. numpy", "question_id": 16278}
{"snippet": "chararray.argsort(order=None)", "intent": "Returns the indices that would sort this array . With arguments `order`. numpy", "question_id": 16279}
{"snippet": "chararray.argsort(axis=- 1, kind=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `kind`. numpy", "question_id": 16280}
{"snippet": "chararray.argsort(axis=- 1, order=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `order`. numpy", "question_id": 16281}
{"snippet": "chararray.argsort(kind=None, order=None)", "intent": "Returns the indices that would sort this array . With arguments `kind`, `order`. numpy", "question_id": 16282}
{"snippet": "chararray.argsort(axis=- 1, kind=None, order=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `kind`, `order`. numpy", "question_id": 16283}
{"snippet": "polynomial.hermite.Hermite.integ()", "intent": "Integrate . numpy", "question_id": 16284}
{"snippet": "polynomial.hermite.Hermite.integ(m=1)", "intent": "Integrate . With arguments `m`. numpy", "question_id": 16285}
{"snippet": "polynomial.hermite.Hermite.integ(k=)", "intent": "Integrate . With arguments `k`. numpy", "question_id": 16286}
{"snippet": "polynomial.hermite.Hermite.integ(lbnd=None)", "intent": "Integrate . With arguments `lbnd`. numpy", "question_id": 16287}
{"snippet": "polynomial.hermite.Hermite.integ(m=1, k=)", "intent": "Integrate . With arguments `m`, `k`. numpy", "question_id": 16288}
{"snippet": "polynomial.hermite.Hermite.integ(m=1, lbnd=None)", "intent": "Integrate . With arguments `m`, `lbnd`. numpy", "question_id": 16289}
{"snippet": "polynomial.hermite.Hermite.integ(k=, lbnd=None)", "intent": "Integrate . With arguments `k`, `lbnd`. numpy", "question_id": 16290}
{"snippet": "polynomial.hermite.Hermite.integ(m=1, k=, lbnd=None)", "intent": "Integrate . With arguments `m`, `k`, `lbnd`. numpy", "question_id": 16291}
{"snippet": "polynomial.hermite.Hermite.integ()", "intent": "Integrate . numpy", "question_id": 16292}
{"snippet": "polynomial.hermite.Hermite.integ(m=1)", "intent": "Integrate . With arguments `m`. numpy", "question_id": 16293}
{"snippet": "polynomial.hermite.Hermite.integ(k=)", "intent": "Integrate . With arguments `k`. numpy", "question_id": 16294}
{"snippet": "polynomial.hermite.Hermite.integ(lbnd=None)", "intent": "Integrate . With arguments `lbnd`. numpy", "question_id": 16295}
{"snippet": "polynomial.hermite.Hermite.integ(m=1, k=)", "intent": "Integrate . With arguments `m`, `k`. numpy", "question_id": 16296}
{"snippet": "polynomial.hermite.Hermite.integ(m=1, lbnd=None)", "intent": "Integrate . With arguments `m`, `lbnd`. numpy", "question_id": 16297}
{"snippet": "polynomial.hermite.Hermite.integ(k=, lbnd=None)", "intent": "Integrate . With arguments `k`, `lbnd`. numpy", "question_id": 16298}
{"snippet": "polynomial.hermite.Hermite.integ(m=1, k=, lbnd=None)", "intent": "Integrate . With arguments `m`, `k`, `lbnd`. numpy", "question_id": 16299}
{"snippet": "chararray.flat", "intent": "A 1-D iterator over the array. numpy", "question_id": 16300}
{"snippet": "char.chararray.any()", "intent": "Returns True if any of the elements of a evaluate to True . numpy", "question_id": 16301}
{"snippet": "char.chararray.any(axis=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`. numpy", "question_id": 16302}
{"snippet": "char.chararray.any(out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`. numpy", "question_id": 16303}
{"snippet": "char.chararray.any(keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `keepdims`. numpy", "question_id": 16304}
{"snippet": "char.chararray.any(where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `where`. numpy", "question_id": 16305}
{"snippet": "char.chararray.any(axis=None, out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `out`. numpy", "question_id": 16306}
{"snippet": "char.chararray.any(axis=None, keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `keepdims`. numpy", "question_id": 16307}
{"snippet": "char.chararray.any(axis=None, where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `where`. numpy", "question_id": 16308}
{"snippet": "char.chararray.any(out=None, keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`, `keepdims`. numpy", "question_id": 16309}
{"snippet": "char.chararray.any(out=None, where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`, `where`. numpy", "question_id": 16310}
{"snippet": "ma.MaskedArray.compress(condition)", "intent": "Return a where `condition` is True . numpy", "question_id": 16311}
{"snippet": "ma.MaskedArray.compress(condition, axis=None)", "intent": "Return a where `condition` is True . With arguments `axis`. numpy", "question_id": 16312}
{"snippet": "ma.MaskedArray.compress(condition, out=None)", "intent": "Return a where `condition` is True . With arguments `out`. numpy", "question_id": 16313}
{"snippet": "ma.MaskedArray.compress(condition, axis=None, out=None)", "intent": "Return a where `condition` is True . With arguments `axis`, `out`. numpy", "question_id": 16314}
{"snippet": "record.nbytes", "intent": "The length of the scalar in bytes. numpy", "question_id": 16315}
{"snippet": "matrix.compress(condition)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`. numpy", "question_id": 16316}
{"snippet": "matrix.compress(condition, axis=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`. numpy", "question_id": 16317}
{"snippet": "matrix.compress(condition, out=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`, `out`. numpy", "question_id": 16318}
{"snippet": "matrix.compress(condition, axis=None, out=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`, `out`. numpy", "question_id": 16319}
{"snippet": "ma.mean(self)", "intent": "Returns the average of the array elements along given `axis` . With arguments `self`. numpy", "question_id": 16320}
{"snippet": "ma.mean(self, axis=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `self`. numpy", "question_id": 16321}
{"snippet": "ma.mean(self, dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `self`, `dtype`. numpy", "question_id": 16322}
{"snippet": "ma.mean(self, out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `self`, `out`. numpy", "question_id": 16323}
{"snippet": "ma.mean(self, keepdims=<no value>)", "intent": "Returns the average of the array elements along given `axis` . With arguments `self`, `keepdims`. numpy", "question_id": 16324}
{"snippet": "ma.mean(self, axis=None, dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `self`, `dtype`. numpy", "question_id": 16325}
{"snippet": "ma.mean(self, axis=None, out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `self`, `out`. numpy", "question_id": 16326}
{"snippet": "ma.mean(self, axis=None, keepdims=<no value>)", "intent": "Returns the average of the array elements along given `axis` . With arguments `self`, `keepdims`. numpy", "question_id": 16327}
{"snippet": "ma.mean(self, dtype=None, out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `self`, `dtype`, `out`. numpy", "question_id": 16328}
{"snippet": "ma.mean(self, dtype=None, keepdims=<no value>)", "intent": "Returns the average of the array elements along given `axis` . With arguments `self`, `dtype`, `keepdims`. numpy", "question_id": 16329}
{"snippet": "recarray.ctypes", "intent": "An object to simplify the interaction of the array with the ctypes module. numpy", "question_id": 16330}
{"snippet": "_ctypes.data", "intent": "A pointer to the memory area of the array as a Python integer. numpy", "question_id": 16331}
{"snippet": "_ctypes.shape", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the C-integer corresponding to dtype('p') on this platform. numpy", "question_id": 16332}
{"snippet": "_ctypes.strides", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the same as for the shape attribute. numpy", "question_id": 16333}
{"snippet": "_ctypes.data_as(obj)", "intent": "Return the data pointer cast to a particular c-types object . With arguments `obj`. numpy", "question_id": 16334}
{"snippet": "_ctypes.shape_as(obj)", "intent": "Return the shape tuple as an array of some other c-types type . With arguments `obj`. numpy", "question_id": 16335}
{"snippet": "_ctypes.strides_as(obj)", "intent": "Return the strides tuple as an array of some other c-types type . With arguments `obj`. numpy", "question_id": 16336}
{"snippet": "numpy.polynomial.hermite_e.HermiteE(coef)", "intent": "An HermiteE series class . With arguments `coef`. numpy", "question_id": 16337}
{"snippet": "numpy.polynomial.hermite_e.HermiteE(coef, domain=None)", "intent": "An HermiteE series class . With arguments `coef`, `domain`. numpy", "question_id": 16338}
{"snippet": "numpy.polynomial.hermite_e.HermiteE(coef, window=None)", "intent": "An HermiteE series class . With arguments `coef`, `window`. numpy", "question_id": 16339}
{"snippet": "numpy.polynomial.hermite_e.HermiteE(coef, domain=None, window=None)", "intent": "An HermiteE series class . With arguments `coef`, `domain`, `window`. numpy", "question_id": 16340}
{"snippet": "random.Generator.multivariate_hypergeometric(colors, nsample)", "intent": "Generate variates from a multivariate hypergeometric distribution . N is the length of `colors` , and the values in colors are the number of occurrences of that type in the collection . Choose `nsample` items at random without replacement from a collection with N distinct types . numpy", "question_id": 16341}
{"snippet": "random.Generator.multivariate_hypergeometric(colors, nsample, size=None)", "intent": "Generate variates from a multivariate hypergeometric distribution . N is the length of `colors` , and the values in colors are the number of occurrences of that type in the collection . Choose `nsample` items at random without replacement from a collection with N distinct types . With arguments `size`. numpy", "question_id": 16342}
{"snippet": "random.Generator.multivariate_hypergeometric(colors, nsample, method='marginals')", "intent": "Generate variates from a multivariate hypergeometric distribution . N is the length of `colors` , and the values in colors are the number of occurrences of that type in the collection . Choose `nsample` items at random without replacement from a collection with N distinct types . The default `method` is \u201c marginals \u201d . numpy", "question_id": 16343}
{"snippet": "random.Generator.multivariate_hypergeometric(colors, nsample, size=None, method='marginals')", "intent": "Generate variates from a multivariate hypergeometric distribution . N is the length of `colors` , and the values in colors are the number of occurrences of that type in the collection . Choose `nsample` items at random without replacement from a collection with N distinct types . The default `method` is \u201c marginals \u201d . With arguments `size`. numpy", "question_id": 16344}
{"snippet": "memmap.any()", "intent": "Returns True if any of the elements of a evaluate to True . numpy", "question_id": 16345}
{"snippet": "memmap.any(axis=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`. numpy", "question_id": 16346}
{"snippet": "memmap.any(out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`. numpy", "question_id": 16347}
{"snippet": "memmap.any(keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `keepdims`. numpy", "question_id": 16348}
{"snippet": "memmap.any(where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `where`. numpy", "question_id": 16349}
{"snippet": "memmap.any(axis=None, out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `out`. numpy", "question_id": 16350}
{"snippet": "memmap.any(axis=None, keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `keepdims`. numpy", "question_id": 16351}
{"snippet": "memmap.any(axis=None, where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `where`. numpy", "question_id": 16352}
{"snippet": "memmap.any(out=None, keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`, `keepdims`. numpy", "question_id": 16353}
{"snippet": "memmap.any(out=None, where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`, `where`. numpy", "question_id": 16354}
{"snippet": "record.squeeze()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 16355}
{"snippet": "ma.masked_array.soften_mask()", "intent": "Force the mask to soft . numpy", "question_id": 16356}
{"snippet": "record.tofile()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 16357}
{"snippet": "ma.MaskType.repeat()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 16358}
{"snippet": "random.triangular(left, mode, right)", "intent": "Draw samples from the triangular distribution over the interval [ `left` , `right` ] . The triangular distribution is a continuous probability distribution with lower limit left , peak at `mode` , and upper limit right . numpy", "question_id": 16359}
{"snippet": "random.triangular(left, mode, right, size=None)", "intent": "Draw samples from the triangular distribution over the interval [ `left` , `right` ] . The triangular distribution is a continuous probability distribution with lower limit left , peak at `mode` , and upper limit right . With arguments `size`. numpy", "question_id": 16360}
{"snippet": "polynomial.hermite_e.hermegauss(deg)", "intent": "Gauss-HermiteE quadrature . These sample points and weights will correctly integrate polynomials of degree \\ ( 2 * `deg` - 1\\ ) or less over the interval \\ ( [ -\\inf , \\inf ] \\ ) with the weight function \\ ( f ( x ) = \\exp ( -x^2/2 ) \\ ) . numpy", "question_id": 16361}
{"snippet": "ma.MaskedArray.__setstate__(state)", "intent": "Restore the internal `state` of the masked array , for pickling purposes . numpy", "question_id": 16362}
{"snippet": "polynomial.laguerre.Laguerre.has_sametype(other)", "intent": "Check if types match . With arguments `other`. numpy", "question_id": 16363}
{"snippet": "numpy.amin(a)", "intent": "Return the minimum of an array or minimum along an `axis` . Don \u2019 t use amin for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , minimum ( `a` [ 0 ] , a [ 1 ] ) is faster than amin ( a , axis=0 ) . numpy", "question_id": 16364}
{"snippet": "numpy.amin(a, axis=None)", "intent": "Return the minimum of an array or minimum along an `axis` . Don \u2019 t use amin for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , minimum ( `a` [ 0 ] , a [ 1 ] ) is faster than amin ( a , axis=0 ) . numpy", "question_id": 16365}
{"snippet": "numpy.amin(a, out=None)", "intent": "Return the minimum of an array or minimum along an `axis` . Don \u2019 t use amin for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , minimum ( `a` [ 0 ] , a [ 1 ] ) is faster than amin ( a , axis=0 ) . With arguments `out`. numpy", "question_id": 16366}
{"snippet": "numpy.amin(a, keepdims=<no value>)", "intent": "Return the minimum of an array or minimum along an `axis` . Don \u2019 t use amin for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , minimum ( `a` [ 0 ] , a [ 1 ] ) is faster than amin ( a , axis=0 ) . With arguments `keepdims`. numpy", "question_id": 16367}
{"snippet": "numpy.amin(a, initial=<no value>)", "intent": "Return the minimum of an array or minimum along an `axis` . Don \u2019 t use amin for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , minimum ( `a` [ 0 ] , a [ 1 ] ) is faster than amin ( a , axis=0 ) . Notice that the `initial` value is used as one of the elements for which the minimum is determined , unlike for the default argument Python \u2019 s max function , which is only used for empty iterables . numpy", "question_id": 16368}
{"snippet": "numpy.amin(a, where=<no value>)", "intent": "Return the minimum of an array or minimum along an `axis` . Don \u2019 t use amin for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , minimum ( `a` [ 0 ] , a [ 1 ] ) is faster than amin ( a , axis=0 ) . With arguments `where`. numpy", "question_id": 16369}
{"snippet": "numpy.amin(a, axis=None, out=None)", "intent": "Return the minimum of an array or minimum along an `axis` . Don \u2019 t use amin for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , minimum ( `a` [ 0 ] , a [ 1 ] ) is faster than amin ( a , axis=0 ) . With arguments `out`. numpy", "question_id": 16370}
{"snippet": "numpy.amin(a, axis=None, keepdims=<no value>)", "intent": "Return the minimum of an array or minimum along an `axis` . Don \u2019 t use amin for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , minimum ( `a` [ 0 ] , a [ 1 ] ) is faster than amin ( a , axis=0 ) . With arguments `keepdims`. numpy", "question_id": 16371}
{"snippet": "numpy.amin(a, axis=None, initial=<no value>)", "intent": "Return the minimum of an array or minimum along an `axis` . Don \u2019 t use amin for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , minimum ( `a` [ 0 ] , a [ 1 ] ) is faster than amin ( a , axis=0 ) . Notice that the `initial` value is used as one of the elements for which the minimum is determined , unlike for the default argument Python \u2019 s max function , which is only used for empty iterables . numpy", "question_id": 16372}
{"snippet": "numpy.amin(a, axis=None, where=<no value>)", "intent": "Return the minimum of an array or minimum along an `axis` . Don \u2019 t use amin for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , minimum ( `a` [ 0 ] , a [ 1 ] ) is faster than amin ( a , axis=0 ) . With arguments `where`. numpy", "question_id": 16373}
{"snippet": "random.Generator.dirichlet(alpha)", "intent": "Draw samples from the Dirichlet distribution . With arguments `alpha`. numpy", "question_id": 16374}
{"snippet": "random.Generator.dirichlet(alpha, size=None)", "intent": "Draw samples from the Dirichlet distribution . Draw `size` samples of dimension k from a Dirichlet distribution . With arguments `alpha`. numpy", "question_id": 16375}
{"snippet": "polynomial.polynomial.polygrid2d(x, y, c)", "intent": "Evaluate a 2-D polynomial on the Cartesian product of `x` and `y` . In either case , either x and y or their elements must support multiplication and addition both with themselves and with the elements of `c` . numpy", "question_id": 16376}
{"snippet": "polynomial.hermite_e.hermemul(c1, c2)", "intent": "Multiply one Hermite series by another . Returns the product of two Hermite series `c1` * `c2` . numpy", "question_id": 16377}
{"snippet": "chararray.newbyteorder(/)", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`. numpy", "question_id": 16378}
{"snippet": "chararray.newbyteorder(/, new_order='S')", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`, `new_order`. numpy", "question_id": 16379}
{"snippet": "polynomial.polynomial.Polynomial.has_samecoef(other)", "intent": "Check if coefficients match . With arguments `other`. numpy", "question_id": 16380}
{"snippet": "numpy.mgrid", "intent": "nd_grid instance which returns a dense multi-dimensional \u201cmeshgrid\u201d. numpy", "question_id": 16381}
{"snippet": "polynomial.polynomial.Polynomial.identity()", "intent": "Identity function . numpy", "question_id": 16382}
{"snippet": "polynomial.polynomial.Polynomial.identity(domain=None)", "intent": "Identity function . With arguments `domain`. numpy", "question_id": 16383}
{"snippet": "polynomial.polynomial.Polynomial.identity(window=None)", "intent": "Identity function . With arguments `window`. numpy", "question_id": 16384}
{"snippet": "polynomial.polynomial.Polynomial.identity(domain=None, window=None)", "intent": "Identity function . With arguments `domain`, `window`. numpy", "question_id": 16385}
{"snippet": "random.randint(low)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . numpy", "question_id": 16386}
{"snippet": "random.randint(low, high=None)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . numpy", "question_id": 16387}
{"snippet": "random.randint(low, size=None)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . With arguments `size`. numpy", "question_id": 16388}
{"snippet": "random.randint(low, dtype=int)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . Return random integers from the \u201c discrete uniform \u201d distribution of the specified `dtype` in the \u201c half-open \u201d interval [ low , high ) . numpy", "question_id": 16389}
{"snippet": "random.randint(low, high=None, size=None)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . With arguments `size`. numpy", "question_id": 16390}
{"snippet": "random.randint(low, high=None, dtype=int)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . Return random integers from the \u201c discrete uniform \u201d distribution of the specified `dtype` in the \u201c half-open \u201d interval [ low , high ) . numpy", "question_id": 16391}
{"snippet": "random.randint(low, size=None, dtype=int)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . Return random integers from the \u201c discrete uniform \u201d distribution of the specified `dtype` in the \u201c half-open \u201d interval [ low , high ) . With arguments `size`. numpy", "question_id": 16392}
{"snippet": "random.randint(low, high=None, size=None, dtype=int)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . Return random integers from the \u201c discrete uniform \u201d distribution of the specified `dtype` in the \u201c half-open \u201d interval [ low , high ) . With arguments `size`. numpy", "question_id": 16393}
{"snippet": "flatiter.index", "intent": "Current flat index into the array. numpy", "question_id": 16394}
{"snippet": "ma.MaskedArray.astype(dtype)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`. numpy", "question_id": 16395}
{"snippet": "ma.MaskedArray.astype(dtype, order='K')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`. numpy", "question_id": 16396}
{"snippet": "ma.MaskedArray.astype(dtype, casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`. numpy", "question_id": 16397}
{"snippet": "ma.MaskedArray.astype(dtype, subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `subok`. numpy", "question_id": 16398}
{"snippet": "ma.MaskedArray.astype(dtype, copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `copy`. numpy", "question_id": 16399}
{"snippet": "ma.MaskedArray.astype(dtype, order='K', casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `casting`. numpy", "question_id": 16400}
{"snippet": "ma.MaskedArray.astype(dtype, order='K', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `subok`. numpy", "question_id": 16401}
{"snippet": "ma.MaskedArray.astype(dtype, order='K', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `copy`. numpy", "question_id": 16402}
{"snippet": "ma.MaskedArray.astype(dtype, casting='unsafe', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `subok`. numpy", "question_id": 16403}
{"snippet": "ma.MaskedArray.astype(dtype, casting='unsafe', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `copy`. numpy", "question_id": 16404}
{"snippet": "numpy.allclose(a, b)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b . numpy", "question_id": 16405}
{"snippet": "numpy.allclose(a, b, rtol=1e-05)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b . numpy", "question_id": 16406}
{"snippet": "numpy.allclose(a, b, atol=1e-08)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b . numpy", "question_id": 16407}
{"snippet": "numpy.allclose(a, b, equal_nan=False)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b . With arguments `equal_nan`. numpy", "question_id": 16408}
{"snippet": "numpy.allclose(a, b, rtol=1e-05, atol=1e-08)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b . numpy", "question_id": 16409}
{"snippet": "numpy.allclose(a, b, rtol=1e-05, equal_nan=False)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b . With arguments `equal_nan`. numpy", "question_id": 16410}
{"snippet": "numpy.allclose(a, b, atol=1e-08, equal_nan=False)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b . With arguments `equal_nan`. numpy", "question_id": 16411}
{"snippet": "numpy.allclose(a, b, rtol=1e-05, atol=1e-08, equal_nan=False)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b . With arguments `equal_nan`. numpy", "question_id": 16412}
{"snippet": "numpy.savez(file, *args, **kwds)", "intent": "Save several arrays into a single `file` in uncompressed .npz format . With arguments `*args`, `**kwds`. numpy", "question_id": 16413}
{"snippet": "random.Generator.exponential()", "intent": "Draw samples from an exponential distribution . numpy", "question_id": 16414}
{"snippet": "random.Generator.exponential(scale=1.0)", "intent": "Draw samples from an exponential distribution . \\ ( \\beta\\ ) is the `scale` parameter , which is the inverse of the rate parameter \\ ( \\lambda = 1/\\beta\\ ) . numpy", "question_id": 16415}
{"snippet": "random.Generator.exponential(size=None)", "intent": "Draw samples from an exponential distribution . It describes many common situations , such as the `size` of raindrops measured over many rainstorms [ 1 ] , or the time between page requests to Wikipedia [ 2 ] . numpy", "question_id": 16416}
{"snippet": "random.Generator.exponential(scale=1.0, size=None)", "intent": "Draw samples from an exponential distribution . \\ ( \\beta\\ ) is the `scale` parameter , which is the inverse of the rate parameter \\ ( \\lambda = 1/\\beta\\ ) . It describes many common situations , such as the `size` of raindrops measured over many rainstorms [ 1 ] , or the time between page requests to Wikipedia [ 2 ] . numpy", "question_id": 16417}
{"snippet": "ndarray.__getitem__(key, /)", "intent": "Return self [ `key` ] . With arguments `/`. numpy", "question_id": 16418}
{"snippet": "polynomial.chebyshev.Chebyshev.cast(series)", "intent": "Convert `series` to series of this class . numpy", "question_id": 16419}
{"snippet": "polynomial.chebyshev.Chebyshev.cast(series, domain=None)", "intent": "Convert `series` to series of this class . With arguments `domain`. numpy", "question_id": 16420}
{"snippet": "polynomial.chebyshev.Chebyshev.cast(series, window=None)", "intent": "Convert `series` to series of this class . With arguments `window`. numpy", "question_id": 16421}
{"snippet": "polynomial.chebyshev.Chebyshev.cast(series, domain=None, window=None)", "intent": "Convert `series` to series of this class . With arguments `domain`, `window`. numpy", "question_id": 16422}
{"snippet": "polynomial.legendre.legvander(x, deg)", "intent": "Pseudo-Vandermonde matrix of given degree . Returns the pseudo-Vandermonde matrix of degree `deg` and sample points `x` . numpy", "question_id": 16423}
{"snippet": "ndarray.flags", "intent": "Information about the memory layout of the array. numpy", "question_id": 16424}
{"snippet": "memmap.dtype", "intent": "Data-type of the array\u2019s elements. numpy", "question_id": 16425}
{"snippet": "random.RandomState.pareto(a)", "intent": "Draw samples from `a` Pareto II or Lomax distribution with specified shape . numpy", "question_id": 16426}
{"snippet": "random.RandomState.pareto(a, size=None)", "intent": "Draw samples from `a` Pareto II or Lomax distribution with specified shape . With arguments `size`. numpy", "question_id": 16427}
{"snippet": "numpy.equal(x1, x2, /, signature, extobj)", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 16428}
{"snippet": "numpy.equal(x1, x2, /, signature, extobj, out=None)", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 16429}
{"snippet": "numpy.equal(x1, x2, /, signature, extobj, where=True)", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 16430}
{"snippet": "numpy.equal(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 16431}
{"snippet": "numpy.equal(x1, x2, /, signature, extobj, order='K')", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 16432}
{"snippet": "numpy.equal(x1, x2, /, signature, extobj, dtype=None)", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 16433}
{"snippet": "numpy.equal(x1, x2, /, signature, extobj, subok=True)", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 16434}
{"snippet": "numpy.equal(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 16435}
{"snippet": "numpy.equal(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 16436}
{"snippet": "numpy.equal(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 16437}
{"snippet": "numpy.equal(x1, x2, /, signature)", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`. numpy", "question_id": 16438}
{"snippet": "numpy.equal(x1, x2, /, signature, out=None)", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `out`. numpy", "question_id": 16439}
{"snippet": "numpy.equal(x1, x2, /, signature, where=True)", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `where`. numpy", "question_id": 16440}
{"snippet": "numpy.equal(x1, x2, /, signature, casting='same_kind')", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `casting`. numpy", "question_id": 16441}
{"snippet": "numpy.equal(x1, x2, /, signature, order='K')", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `order`. numpy", "question_id": 16442}
{"snippet": "numpy.equal(x1, x2, /, signature, dtype=None)", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 16443}
{"snippet": "numpy.equal(x1, x2, /, signature, subok=True)", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `subok`. numpy", "question_id": 16444}
{"snippet": "numpy.equal(x1, x2, /, signature, out=None, where=True)", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 16445}
{"snippet": "numpy.equal(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 16446}
{"snippet": "numpy.equal(x1, x2, /, signature, out=None, order='K')", "intent": "Return ( `x1` == `x2` ) element-wise . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 16447}
{"snippet": "ma.masked_array.itemsize", "intent": "Length of one array element in bytes. numpy", "question_id": 16448}
{"snippet": "fft.irfftn(a)", "intent": "Computes the inverse of rfftn . In other words , irfftn ( rfftn ( `a` ) , a.shape ) == a to within numerical accuracy . numpy", "question_id": 16449}
{"snippet": "fft.irfftn(a, s=None)", "intent": "Computes the inverse of rfftn . In other words , irfftn ( rfftn ( `a` ) , a.shape ) == a to within numerical accuracy . With arguments `s`. numpy", "question_id": 16450}
{"snippet": "fft.irfftn(a, axes=None)", "intent": "Computes the inverse of rfftn . In other words , irfftn ( rfftn ( `a` ) , a.shape ) == a to within numerical accuracy . This function computes the inverse of the N-dimensional discrete Fourier Transform for real input over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . numpy", "question_id": 16451}
{"snippet": "fft.irfftn(a, norm=None)", "intent": "Computes the inverse of rfftn . In other words , irfftn ( rfftn ( `a` ) , a.shape ) == a to within numerical accuracy . With arguments `norm`. numpy", "question_id": 16452}
{"snippet": "fft.irfftn(a, s=None, axes=None)", "intent": "Computes the inverse of rfftn . In other words , irfftn ( rfftn ( `a` ) , a.shape ) == a to within numerical accuracy . This function computes the inverse of the N-dimensional discrete Fourier Transform for real input over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `s`. numpy", "question_id": 16453}
{"snippet": "fft.irfftn(a, s=None, norm=None)", "intent": "Computes the inverse of rfftn . In other words , irfftn ( rfftn ( `a` ) , a.shape ) == a to within numerical accuracy . With arguments `s`, `norm`. numpy", "question_id": 16454}
{"snippet": "fft.irfftn(a, axes=None, norm=None)", "intent": "Computes the inverse of rfftn . In other words , irfftn ( rfftn ( `a` ) , a.shape ) == a to within numerical accuracy . This function computes the inverse of the N-dimensional discrete Fourier Transform for real input over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `norm`. numpy", "question_id": 16455}
{"snippet": "fft.irfftn(a, s=None, axes=None, norm=None)", "intent": "Computes the inverse of rfftn . In other words , irfftn ( rfftn ( `a` ) , a.shape ) == a to within numerical accuracy . This function computes the inverse of the N-dimensional discrete Fourier Transform for real input over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `s`, `norm`. numpy", "question_id": 16456}
{"snippet": "numpy.median(a)", "intent": "Compute the median along the specified `axis` . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i e. , V_sorted [ ( N-1 ) /2 ] , when N is odd , and the average of the two middle values of V_sorted when N is even . numpy", "question_id": 16457}
{"snippet": "numpy.median(a, axis=None)", "intent": "Compute the median along the specified `axis` . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i e. , V_sorted [ ( N-1 ) /2 ] , when N is odd , and the average of the two middle values of V_sorted when N is even . numpy", "question_id": 16458}
{"snippet": "numpy.median(a, out=None)", "intent": "Compute the median along the specified `axis` . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i e. , V_sorted [ ( N-1 ) /2 ] , when N is odd , and the average of the two middle values of V_sorted when N is even . With arguments `out`. numpy", "question_id": 16459}
{"snippet": "numpy.median(a, overwrite_input=False)", "intent": "Compute the median along the specified `axis` . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i e. , V_sorted [ ( N-1 ) /2 ] , when N is odd , and the average of the two middle values of V_sorted when N is even . With arguments `overwrite_input`. numpy", "question_id": 16460}
{"snippet": "numpy.median(a, keepdims=False)", "intent": "Compute the median along the specified `axis` . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i e. , V_sorted [ ( N-1 ) /2 ] , when N is odd , and the average of the two middle values of V_sorted when N is even . With arguments `keepdims`. numpy", "question_id": 16461}
{"snippet": "numpy.median(a, axis=None, out=None)", "intent": "Compute the median along the specified `axis` . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i e. , V_sorted [ ( N-1 ) /2 ] , when N is odd , and the average of the two middle values of V_sorted when N is even . With arguments `out`. numpy", "question_id": 16462}
{"snippet": "numpy.median(a, axis=None, overwrite_input=False)", "intent": "Compute the median along the specified `axis` . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i e. , V_sorted [ ( N-1 ) /2 ] , when N is odd , and the average of the two middle values of V_sorted when N is even . With arguments `overwrite_input`. numpy", "question_id": 16463}
{"snippet": "numpy.median(a, axis=None, keepdims=False)", "intent": "Compute the median along the specified `axis` . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i e. , V_sorted [ ( N-1 ) /2 ] , when N is odd , and the average of the two middle values of V_sorted when N is even . With arguments `keepdims`. numpy", "question_id": 16464}
{"snippet": "numpy.median(a, out=None, overwrite_input=False)", "intent": "Compute the median along the specified `axis` . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i e. , V_sorted [ ( N-1 ) /2 ] , when N is odd , and the average of the two middle values of V_sorted when N is even . With arguments `out`, `overwrite_input`. numpy", "question_id": 16465}
{"snippet": "numpy.median(a, out=None, keepdims=False)", "intent": "Compute the median along the specified `axis` . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i e. , V_sorted [ ( N-1 ) /2 ] , when N is odd , and the average of the two middle values of V_sorted when N is even . With arguments `out`, `keepdims`. numpy", "question_id": 16466}
{"snippet": "random.poisson()", "intent": "Draw samples from a Poisson distribution . numpy", "question_id": 16467}
{"snippet": "random.poisson(lam=1.0)", "intent": "Draw samples from a Poisson distribution . Because the output is limited to the range of the C int64 type , a ValueError is raised when `lam` is within 10 sigma of the maximum representable value . numpy", "question_id": 16468}
{"snippet": "random.poisson(size=None)", "intent": "Draw samples from a Poisson distribution . With arguments `size`. numpy", "question_id": 16469}
{"snippet": "random.poisson(lam=1.0, size=None)", "intent": "Draw samples from a Poisson distribution . Because the output is limited to the range of the C int64 type , a ValueError is raised when `lam` is within 10 sigma of the maximum representable value . With arguments `size`. numpy", "question_id": 16470}
{"snippet": "polynomial.chebyshev.chebgrid2d(x, y, c)", "intent": "Evaluate a 2-D Chebyshev series on the Cartesian product of `x` and `y` . In either case , either x and y or their elements must support multiplication and addition both with themselves and with the elements of `c` . numpy", "question_id": 16471}
{"snippet": "numpy.piecewise(x, condlist, funclist, *args, **kw)", "intent": "Evaluate a piecewise-defined function . This is similar to choose or select , except that functions are evaluated on elements of `x` that satisfy the corresponding condition from `condlist` . With arguments `funclist`, `*args`, `**kw`. numpy", "question_id": 16472}
{"snippet": "ma.masked_array.ravel()", "intent": "Returns a 1D version of self , as a view . numpy", "question_id": 16473}
{"snippet": "ma.masked_array.ravel(order='C')", "intent": "Returns a 1D version of self , as a view . With arguments `order`. numpy", "question_id": 16474}
{"snippet": "numpy.fix(x)", "intent": "Round to nearest integer towards zero . With arguments `x`. numpy", "question_id": 16475}
{"snippet": "numpy.fix(x, out=None)", "intent": "Round to nearest integer towards zero . With arguments `x`, `out`. numpy", "question_id": 16476}
{"snippet": "numpy.logical_and(x1, x2, /, signature, extobj)", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 16477}
{"snippet": "numpy.logical_and(x1, x2, /, signature, extobj, out=None)", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 16478}
{"snippet": "numpy.logical_and(x1, x2, /, signature, extobj, where=True)", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 16479}
{"snippet": "numpy.logical_and(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 16480}
{"snippet": "numpy.logical_and(x1, x2, /, signature, extobj, order='K')", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 16481}
{"snippet": "numpy.logical_and(x1, x2, /, signature, extobj, dtype=None)", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 16482}
{"snippet": "numpy.logical_and(x1, x2, /, signature, extobj, subok=True)", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 16483}
{"snippet": "numpy.logical_and(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 16484}
{"snippet": "numpy.logical_and(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 16485}
{"snippet": "numpy.logical_and(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 16486}
{"snippet": "numpy.logical_and(x1, x2, /, signature)", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`. numpy", "question_id": 16487}
{"snippet": "numpy.logical_and(x1, x2, /, signature, out=None)", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `out`. numpy", "question_id": 16488}
{"snippet": "numpy.logical_and(x1, x2, /, signature, where=True)", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `where`. numpy", "question_id": 16489}
{"snippet": "numpy.logical_and(x1, x2, /, signature, casting='same_kind')", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `casting`. numpy", "question_id": 16490}
{"snippet": "numpy.logical_and(x1, x2, /, signature, order='K')", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `order`. numpy", "question_id": 16491}
{"snippet": "numpy.logical_and(x1, x2, /, signature, dtype=None)", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 16492}
{"snippet": "numpy.logical_and(x1, x2, /, signature, subok=True)", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `subok`. numpy", "question_id": 16493}
{"snippet": "numpy.logical_and(x1, x2, /, signature, out=None, where=True)", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 16494}
{"snippet": "numpy.logical_and(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 16495}
{"snippet": "numpy.logical_and(x1, x2, /, signature, out=None, order='K')", "intent": "Compute the truth value of `x1` AND `x2` element-wise . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 16496}
{"snippet": "ma.conjugate(x, /, signature, extobj)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`. numpy", "question_id": 16497}
{"snippet": "ma.conjugate(x, /, signature, extobj, out=None)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 16498}
{"snippet": "ma.conjugate(x, /, signature, extobj, where=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `where`. numpy", "question_id": 16499}
{"snippet": "ma.conjugate(x, /, signature, extobj, casting='same_kind')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 16500}
{"snippet": "ma.conjugate(x, /, signature, extobj, order='K')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 16501}
{"snippet": "ma.conjugate(x, /, signature, extobj, dtype=None)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 16502}
{"snippet": "ma.conjugate(x, /, signature, extobj, subok=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 16503}
{"snippet": "ma.conjugate(x, /, signature, extobj, out=None, where=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 16504}
{"snippet": "ma.conjugate(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 16505}
{"snippet": "ma.conjugate(x, /, signature, extobj, out=None, order='K')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 16506}
{"snippet": "ma.conjugate(x, /, signature)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`. numpy", "question_id": 16507}
{"snippet": "ma.conjugate(x, /, signature, out=None)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `out`. numpy", "question_id": 16508}
{"snippet": "ma.conjugate(x, /, signature, where=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `where`. numpy", "question_id": 16509}
{"snippet": "ma.conjugate(x, /, signature, casting='same_kind')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `casting`. numpy", "question_id": 16510}
{"snippet": "ma.conjugate(x, /, signature, order='K')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `order`. numpy", "question_id": 16511}
{"snippet": "ma.conjugate(x, /, signature, dtype=None)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `dtype`. numpy", "question_id": 16512}
{"snippet": "ma.conjugate(x, /, signature, subok=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `subok`. numpy", "question_id": 16513}
{"snippet": "ma.conjugate(x, /, signature, out=None, where=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `out`, `where`. numpy", "question_id": 16514}
{"snippet": "ma.conjugate(x, /, signature, out=None, casting='same_kind')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `out`, `casting`. numpy", "question_id": 16515}
{"snippet": "ma.conjugate(x, /, signature, out=None, order='K')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `out`, `order`. numpy", "question_id": 16516}
{"snippet": "testing.assert_raises(exception_class, callable, *args, **kwargs) assert_raises(exception_class)", "intent": "Fail unless an exception of class `exception_class` is thrown by `callable` when invoked with arguments args and keyword arguments kwargs . With arguments `*args`, `**kwargs) assert_raises(exception_class`. numpy", "question_id": 16517}
{"snippet": "testing.assert_raises(exception_class)", "intent": "Fail unless an exception of class `exception_class` is thrown by callable when invoked with arguments args and keyword arguments kwargs . numpy", "question_id": 16518}
{"snippet": "numpy.isneginf(x)", "intent": "Test element-wise for negative infinity , return result as bool array . Errors result if the second argument is also supplied when `x` is a scalar input , if first and second arguments have different shapes , or if the first argument has complex values . numpy", "question_id": 16519}
{"snippet": "numpy.isneginf(x, out=None)", "intent": "Test element-wise for negative infinity , return result as bool array . Errors result if the second argument is also supplied when `x` is a scalar input , if first and second arguments have different shapes , or if the first argument has complex values . With arguments `out`. numpy", "question_id": 16520}
{"snippet": "numpy.distutils.ccompiler_opt.CCompilerOpt(ccompiler)", "intent": "A helper class for CCompiler aims to provide extra build options to effectively control of compiler optimizations that are directly related to CPU features . With arguments `ccompiler`. numpy", "question_id": 16521}
{"snippet": "numpy.distutils.ccompiler_opt.CCompilerOpt(ccompiler, cpu_baseline='min')", "intent": "A helper class for CCompiler aims to provide extra build options to effectively control of compiler optimizations that are directly related to CPU features . With arguments `ccompiler`, `cpu_baseline`. numpy", "question_id": 16522}
{"snippet": "numpy.distutils.ccompiler_opt.CCompilerOpt(ccompiler, cpu_dispatch='max')", "intent": "A helper class for CCompiler aims to provide extra build options to effectively control of compiler optimizations that are directly related to CPU features . With arguments `ccompiler`, `cpu_dispatch`. numpy", "question_id": 16523}
{"snippet": "numpy.distutils.ccompiler_opt.CCompilerOpt(ccompiler, cache_path=None)", "intent": "A helper class for CCompiler aims to provide extra build options to effectively control of compiler optimizations that are directly related to CPU features . With arguments `ccompiler`, `cache_path`. numpy", "question_id": 16524}
{"snippet": "numpy.distutils.ccompiler_opt.CCompilerOpt(ccompiler, cpu_baseline='min', cpu_dispatch='max')", "intent": "A helper class for CCompiler aims to provide extra build options to effectively control of compiler optimizations that are directly related to CPU features . With arguments `ccompiler`, `cpu_baseline`, `cpu_dispatch`. numpy", "question_id": 16525}
{"snippet": "numpy.distutils.ccompiler_opt.CCompilerOpt(ccompiler, cpu_baseline='min', cache_path=None)", "intent": "A helper class for CCompiler aims to provide extra build options to effectively control of compiler optimizations that are directly related to CPU features . With arguments `ccompiler`, `cpu_baseline`, `cache_path`. numpy", "question_id": 16526}
{"snippet": "numpy.distutils.ccompiler_opt.CCompilerOpt(ccompiler, cpu_dispatch='max', cache_path=None)", "intent": "A helper class for CCompiler aims to provide extra build options to effectively control of compiler optimizations that are directly related to CPU features . With arguments `ccompiler`, `cpu_dispatch`, `cache_path`. numpy", "question_id": 16527}
{"snippet": "numpy.distutils.ccompiler_opt.CCompilerOpt(ccompiler, cpu_baseline='min', cpu_dispatch='max', cache_path=None)", "intent": "A helper class for CCompiler aims to provide extra build options to effectively control of compiler optimizations that are directly related to CPU features . With arguments `ccompiler`, `cpu_baseline`, `cpu_dispatch`, `cache_path`. numpy", "question_id": 16528}
{"snippet": "ma.masked_values(x, value)", "intent": "Mask using floating point equality . Return a MaskedArray , masked where the data in array `x` are approximately equal to `value` , determined using isclose . numpy", "question_id": 16529}
{"snippet": "ma.masked_values(x, value, rtol=1e-05)", "intent": "Mask using floating point equality . Return a MaskedArray , masked where the data in array `x` are approximately equal to `value` , determined using isclose . With arguments `rtol`. numpy", "question_id": 16530}
{"snippet": "ma.masked_values(x, value, atol=1e-08)", "intent": "Mask using floating point equality . Return a MaskedArray , masked where the data in array `x` are approximately equal to `value` , determined using isclose . With arguments `atol`. numpy", "question_id": 16531}
{"snippet": "ma.masked_values(x, value, copy=True)", "intent": "Mask using floating point equality . Return a MaskedArray , masked where the data in array `x` are approximately equal to `value` , determined using isclose . With arguments `copy`. numpy", "question_id": 16532}
{"snippet": "ma.masked_values(x, value, shrink=True)", "intent": "Mask using floating point equality . Return a MaskedArray , masked where the data in array `x` are approximately equal to `value` , determined using isclose . With arguments `shrink`. numpy", "question_id": 16533}
{"snippet": "ma.masked_values(x, value, rtol=1e-05, atol=1e-08)", "intent": "Mask using floating point equality . Return a MaskedArray , masked where the data in array `x` are approximately equal to `value` , determined using isclose . With arguments `rtol`, `atol`. numpy", "question_id": 16534}
{"snippet": "ma.masked_values(x, value, rtol=1e-05, copy=True)", "intent": "Mask using floating point equality . Return a MaskedArray , masked where the data in array `x` are approximately equal to `value` , determined using isclose . With arguments `rtol`, `copy`. numpy", "question_id": 16535}
{"snippet": "ma.masked_values(x, value, rtol=1e-05, shrink=True)", "intent": "Mask using floating point equality . Return a MaskedArray , masked where the data in array `x` are approximately equal to `value` , determined using isclose . With arguments `rtol`, `shrink`. numpy", "question_id": 16536}
{"snippet": "ma.masked_values(x, value, atol=1e-08, copy=True)", "intent": "Mask using floating point equality . Return a MaskedArray , masked where the data in array `x` are approximately equal to `value` , determined using isclose . With arguments `atol`, `copy`. numpy", "question_id": 16537}
{"snippet": "ma.masked_values(x, value, atol=1e-08, shrink=True)", "intent": "Mask using floating point equality . Return a MaskedArray , masked where the data in array `x` are approximately equal to `value` , determined using isclose . With arguments `atol`, `shrink`. numpy", "question_id": 16538}
{"snippet": "record.copy()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 16539}
{"snippet": "polynomial.chebyshev.Chebyshev.roots()", "intent": "Return the roots of the series polynomial . numpy", "question_id": 16540}
{"snippet": "linalg.eigh(a)", "intent": "Return the eigenvalues and eigenvectors of `a` complex Hermitian ( conjugate symmetric ) or a real symmetric matrix . numpy", "question_id": 16541}
{"snippet": "linalg.eigh(a, UPLO='L')", "intent": "Return the eigenvalues and eigenvectors of `a` complex Hermitian ( conjugate symmetric ) or a real symmetric matrix . With arguments `UPLO`. numpy", "question_id": 16542}
{"snippet": "ma.MaskedArray.argmax()", "intent": "Returns array of indices of the maximum values along the given `axis` . numpy", "question_id": 16543}
{"snippet": "ma.MaskedArray.argmax(axis=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . numpy", "question_id": 16544}
{"snippet": "ma.MaskedArray.argmax(fill_value=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . Masked values are treated as if they had the value `fill_value` . numpy", "question_id": 16545}
{"snippet": "ma.MaskedArray.argmax(out=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . With arguments `out`. numpy", "question_id": 16546}
{"snippet": "ma.MaskedArray.argmax(axis=None, fill_value=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . Masked values are treated as if they had the value `fill_value` . numpy", "question_id": 16547}
{"snippet": "ma.MaskedArray.argmax(axis=None, out=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . With arguments `out`. numpy", "question_id": 16548}
{"snippet": "ma.MaskedArray.argmax(fill_value=None, out=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . Masked values are treated as if they had the value `fill_value` . With arguments `out`. numpy", "question_id": 16549}
{"snippet": "ma.MaskedArray.argmax(axis=None, fill_value=None, out=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . Masked values are treated as if they had the value `fill_value` . With arguments `out`. numpy", "question_id": 16550}
{"snippet": "random.RandomState.beta(a, b)", "intent": "Draw samples from `a` Beta distribution . With arguments `b`. numpy", "question_id": 16551}
{"snippet": "random.RandomState.beta(a, b, size=None)", "intent": "Draw samples from `a` Beta distribution . With arguments `b`, `size`. numpy", "question_id": 16552}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.cache_flush()", "intent": "Force update the cache . numpy", "question_id": 16553}
{"snippet": "ma.MaskedArray.product()", "intent": "Return the product of the array elements over the given `axis` . numpy", "question_id": 16554}
{"snippet": "ma.MaskedArray.product(axis=None)", "intent": "Return the product of the array elements over the given `axis` . numpy", "question_id": 16555}
{"snippet": "ma.MaskedArray.product(dtype=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 16556}
{"snippet": "ma.MaskedArray.product(out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `out`. numpy", "question_id": 16557}
{"snippet": "ma.MaskedArray.product(keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `keepdims`. numpy", "question_id": 16558}
{"snippet": "ma.MaskedArray.product(axis=None, dtype=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 16559}
{"snippet": "ma.MaskedArray.product(axis=None, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `out`. numpy", "question_id": 16560}
{"snippet": "ma.MaskedArray.product(axis=None, keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `keepdims`. numpy", "question_id": 16561}
{"snippet": "ma.MaskedArray.product(dtype=None, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 16562}
{"snippet": "ma.MaskedArray.product(dtype=None, keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`, `keepdims`. numpy", "question_id": 16563}
{"snippet": "ma.masked_array.shrink_mask()", "intent": "Reduce a mask to nomask when possible . numpy", "question_id": 16564}
{"snippet": "memmap.flatten()", "intent": "Return a copy of the array collapsed into one dimension . numpy", "question_id": 16565}
{"snippet": "memmap.flatten(order='C')", "intent": "Return a copy of the array collapsed into one dimension . With arguments `order`. numpy", "question_id": 16566}
{"snippet": "ma.MaskedArray.compressed()", "intent": "Return all the non-masked data as a 1-D array . numpy", "question_id": 16567}
{"snippet": "polynomial.hermite_e.hermetrim(c)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . With arguments `c`. numpy", "question_id": 16568}
{"snippet": "polynomial.hermite_e.hermetrim(c, tol=0)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . \u201c Small \u201d means \u201c small in absolute value \u201d and is controlled by the parameter `tol` ; \u201c trailing \u201d means highest order coefficient ( s ) , e.g. , in [ 0 , 1 , 1 , 0 , 0 ] ( which represents 0 + x + x * * 2 + 0 * x * * 3 + 0 * x * * 4 ) both the 3-rd and 4-th order coefficients would be \u201c trimmed . \u201d With arguments `c`. numpy", "question_id": 16569}
{"snippet": "random.RandomState.uniform()", "intent": "Draw samples from a uniform distribution . numpy", "question_id": 16570}
{"snippet": "random.RandomState.uniform(low=0.0)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . numpy", "question_id": 16571}
{"snippet": "random.RandomState.uniform(high=1.0)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . numpy", "question_id": 16572}
{"snippet": "random.RandomState.uniform(size=None)", "intent": "Draw samples from a uniform distribution . With arguments `size`. numpy", "question_id": 16573}
{"snippet": "random.RandomState.uniform(low=0.0, high=1.0)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . numpy", "question_id": 16574}
{"snippet": "random.RandomState.uniform(low=0.0, size=None)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . With arguments `size`. numpy", "question_id": 16575}
{"snippet": "random.RandomState.uniform(high=1.0, size=None)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . With arguments `size`. numpy", "question_id": 16576}
{"snippet": "random.RandomState.uniform(low=0.0, high=1.0, size=None)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . With arguments `size`. numpy", "question_id": 16577}
{"snippet": "ma.MaskedArray.__divmod__(value, /)", "intent": "Return divmod ( self , `value` ) . With arguments `/`. numpy", "question_id": 16578}
{"snippet": "chararray.tobytes()", "intent": "Construct Python bytes containing the raw data bytes in the array . numpy", "question_id": 16579}
{"snippet": "chararray.tobytes(order='C')", "intent": "Construct Python bytes containing the raw data bytes in the array . This behavior is controlled by the `order` parameter . numpy", "question_id": 16580}
{"snippet": "record.searchsorted()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 16581}
{"snippet": "matrix.partition(kth)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . numpy", "question_id": 16582}
{"snippet": "matrix.partition(kth, axis=- 1)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`. numpy", "question_id": 16583}
{"snippet": "matrix.partition(kth, kind='introselect')", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `kind`. numpy", "question_id": 16584}
{"snippet": "matrix.partition(kth, order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `order`. numpy", "question_id": 16585}
{"snippet": "matrix.partition(kth, axis=- 1, kind='introselect')", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `kind`. numpy", "question_id": 16586}
{"snippet": "matrix.partition(kth, axis=- 1, order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `order`. numpy", "question_id": 16587}
{"snippet": "matrix.partition(kth, kind='introselect', order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `kind`, `order`. numpy", "question_id": 16588}
{"snippet": "matrix.partition(kth, axis=- 1, kind='introselect', order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `kind`, `order`. numpy", "question_id": 16589}
{"snippet": "polynomial.legendre.legval3d(x, y, z, c)", "intent": "Evaluate a 3-D Legendre series at points ( `x` , `y` , `z` ) . In either case , either x , y , and z or their elements must support multiplication and addition both with themselves and with the elements of `c` . numpy", "question_id": 16590}
{"snippet": "lib.format.open_memmap(filename)", "intent": "Open a .npy file as a memory-mapped array . With arguments `filename`. numpy", "question_id": 16591}
{"snippet": "lib.format.open_memmap(filename, mode='r+')", "intent": "Open a .npy file as a memory-mapped array . With arguments `filename`, `mode`. numpy", "question_id": 16592}
{"snippet": "lib.format.open_memmap(filename, dtype=None)", "intent": "Open a .npy file as a memory-mapped array . With arguments `filename`, `dtype`. numpy", "question_id": 16593}
{"snippet": "lib.format.open_memmap(filename, shape=None)", "intent": "Open a .npy file as a memory-mapped array . With arguments `filename`, `shape`. numpy", "question_id": 16594}
{"snippet": "lib.format.open_memmap(filename, fortran_order=False)", "intent": "Open a .npy file as a memory-mapped array . With arguments `filename`, `fortran_order`. numpy", "question_id": 16595}
{"snippet": "lib.format.open_memmap(filename, version=None)", "intent": "Open a .npy file as a memory-mapped array . With arguments `filename`, `version`. numpy", "question_id": 16596}
{"snippet": "lib.format.open_memmap(filename, mode='r+', dtype=None)", "intent": "Open a .npy file as a memory-mapped array . With arguments `filename`, `mode`, `dtype`. numpy", "question_id": 16597}
{"snippet": "lib.format.open_memmap(filename, mode='r+', shape=None)", "intent": "Open a .npy file as a memory-mapped array . With arguments `filename`, `mode`, `shape`. numpy", "question_id": 16598}
{"snippet": "lib.format.open_memmap(filename, mode='r+', fortran_order=False)", "intent": "Open a .npy file as a memory-mapped array . With arguments `filename`, `mode`, `fortran_order`. numpy", "question_id": 16599}
{"snippet": "lib.format.open_memmap(filename, mode='r+', version=None)", "intent": "Open a .npy file as a memory-mapped array . With arguments `filename`, `mode`, `version`. numpy", "question_id": 16600}
{"snippet": "ma.notmasked_edges(a)", "intent": "Find the indices of the first and last unmasked values along an `axis` . Otherwise , return `a` list of two tuples , corresponding to the indices of the first and last unmasked values respectively . numpy", "question_id": 16601}
{"snippet": "ma.notmasked_edges(a, axis=None)", "intent": "Find the indices of the first and last unmasked values along an `axis` . Otherwise , return `a` list of two tuples , corresponding to the indices of the first and last unmasked values respectively . numpy", "question_id": 16602}
{"snippet": "dtype.isalignedstruct", "intent": "Boolean indicating whether the dtype is a struct which maintains field alignment. numpy", "question_id": 16603}
{"snippet": "memmap.swapaxes(axis1, axis2)", "intent": "Return a view of the array with `axis1` and `axis2` interchanged . numpy", "question_id": 16604}
{"snippet": "ma.polyfit(x, y, deg)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . numpy", "question_id": 16605}
{"snippet": "ma.polyfit(x, y, deg, rcond=None)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious : including contributions from the small singular values can add numerical noise to the result . numpy", "question_id": 16606}
{"snippet": "ma.polyfit(x, y, deg, full=False)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . With arguments `full`. numpy", "question_id": 16607}
{"snippet": "ma.polyfit(x, y, deg, w=None)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . With arguments `w`. numpy", "question_id": 16608}
{"snippet": "ma.polyfit(x, y, deg, cov=False)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . With arguments `cov`. numpy", "question_id": 16609}
{"snippet": "ma.polyfit(x, y, deg, rcond=None, full=False)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious : including contributions from the small singular values can add numerical noise to the result . With arguments `full`. numpy", "question_id": 16610}
{"snippet": "ma.polyfit(x, y, deg, rcond=None, w=None)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious : including contributions from the small singular values can add numerical noise to the result . With arguments `w`. numpy", "question_id": 16611}
{"snippet": "ma.polyfit(x, y, deg, rcond=None, cov=False)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious : including contributions from the small singular values can add numerical noise to the result . With arguments `cov`. numpy", "question_id": 16612}
{"snippet": "ma.polyfit(x, y, deg, full=False, w=None)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . With arguments `full`, `w`. numpy", "question_id": 16613}
{"snippet": "ma.polyfit(x, y, deg, full=False, cov=False)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . With arguments `full`, `cov`. numpy", "question_id": 16614}
{"snippet": "ma.MaskedArray.conj()", "intent": "Complex-conjugate all elements . numpy", "question_id": 16615}
{"snippet": "polynomial.laguerre.Laguerre.fromroots(roots)", "intent": "Return series instance that has the specified `roots` . numpy", "question_id": 16616}
{"snippet": "polynomial.laguerre.Laguerre.fromroots(roots, domain=)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`. numpy", "question_id": 16617}
{"snippet": "polynomial.laguerre.Laguerre.fromroots(roots, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `window`. numpy", "question_id": 16618}
{"snippet": "polynomial.laguerre.Laguerre.fromroots(roots, domain=, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`, `window`. numpy", "question_id": 16619}
{"snippet": "polynomial.laguerre.Laguerre.fromroots()", "intent": "Return series instance that has the specified `roots` . numpy", "question_id": 16620}
{"snippet": "polynomial.laguerre.Laguerre.fromroots(domain=)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`. numpy", "question_id": 16621}
{"snippet": "polynomial.laguerre.Laguerre.fromroots(window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `window`. numpy", "question_id": 16622}
{"snippet": "polynomial.laguerre.Laguerre.fromroots(domain=, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`, `window`. numpy", "question_id": 16623}
{"snippet": "numpy.square(x, /, signature, extobj)", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `extobj`. numpy", "question_id": 16624}
{"snippet": "numpy.square(x, /, signature, extobj, out=None)", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 16625}
{"snippet": "numpy.square(x, /, signature, extobj, where=True)", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `extobj`, `where`. numpy", "question_id": 16626}
{"snippet": "numpy.square(x, /, signature, extobj, casting='same_kind')", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 16627}
{"snippet": "numpy.square(x, /, signature, extobj, order='K')", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 16628}
{"snippet": "numpy.square(x, /, signature, extobj, dtype=None)", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 16629}
{"snippet": "numpy.square(x, /, signature, extobj, subok=True)", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 16630}
{"snippet": "numpy.square(x, /, signature, extobj, out=None, where=True)", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 16631}
{"snippet": "numpy.square(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 16632}
{"snippet": "numpy.square(x, /, signature, extobj, out=None, order='K')", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 16633}
{"snippet": "numpy.square(x, /, signature)", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`. numpy", "question_id": 16634}
{"snippet": "numpy.square(x, /, signature, out=None)", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `out`. numpy", "question_id": 16635}
{"snippet": "numpy.square(x, /, signature, where=True)", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `where`. numpy", "question_id": 16636}
{"snippet": "numpy.square(x, /, signature, casting='same_kind')", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `casting`. numpy", "question_id": 16637}
{"snippet": "numpy.square(x, /, signature, order='K')", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `order`. numpy", "question_id": 16638}
{"snippet": "numpy.square(x, /, signature, dtype=None)", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `dtype`. numpy", "question_id": 16639}
{"snippet": "numpy.square(x, /, signature, subok=True)", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `subok`. numpy", "question_id": 16640}
{"snippet": "numpy.square(x, /, signature, out=None, where=True)", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `out`, `where`. numpy", "question_id": 16641}
{"snippet": "numpy.square(x, /, signature, out=None, casting='same_kind')", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `out`, `casting`. numpy", "question_id": 16642}
{"snippet": "numpy.square(x, /, signature, out=None, order='K')", "intent": "Return the element-wise square of the input . With arguments `x`, `/`, `signature`, `out`, `order`. numpy", "question_id": 16643}
{"snippet": "chararray.fill(value)", "intent": "Fill the array with a scalar `value` . numpy", "question_id": 16644}
{"snippet": "ma.MaskedArray.iscontiguous()", "intent": "Return a boolean indicating whether the data is contiguous . numpy", "question_id": 16645}
{"snippet": "distutils.ccompiler.CCompiler_show_customization(self)", "intent": "Print the compiler customizations to stdout . With arguments `self`. numpy", "question_id": 16646}
{"snippet": "random.RandomState.random_sample()", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) . numpy", "question_id": 16647}
{"snippet": "random.RandomState.random_sample(size=None)", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) . With arguments `size`. numpy", "question_id": 16648}
{"snippet": "ma.MaskType.dump()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 16649}
{"snippet": "ndarray.mean()", "intent": "Returns the average of the array elements along given `axis` . numpy", "question_id": 16650}
{"snippet": "ndarray.mean(axis=None)", "intent": "Returns the average of the array elements along given `axis` . numpy", "question_id": 16651}
{"snippet": "ndarray.mean(dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 16652}
{"snippet": "ndarray.mean(out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 16653}
{"snippet": "ndarray.mean(keepdims=False)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`. numpy", "question_id": 16654}
{"snippet": "ndarray.mean(where=True)", "intent": "Returns the average of the array elements along given `axis` . With arguments `where`. numpy", "question_id": 16655}
{"snippet": "ndarray.mean(axis=None, dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 16656}
{"snippet": "ndarray.mean(axis=None, out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 16657}
{"snippet": "ndarray.mean(axis=None, keepdims=False)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`. numpy", "question_id": 16658}
{"snippet": "ndarray.mean(axis=None, where=True)", "intent": "Returns the average of the array elements along given `axis` . With arguments `where`. numpy", "question_id": 16659}
{"snippet": "linalg.LinAlgError", "intent": "Generic Python-exception-derived object raised by linalg functions. numpy", "question_id": 16660}
{"snippet": "char.chararray.ndim", "intent": "Number of array dimensions. numpy", "question_id": 16661}
{"snippet": "numpy.is_busday(dates)", "intent": "Calculates which of the given `dates` are valid days , and which are not . numpy", "question_id": 16662}
{"snippet": "numpy.is_busday(dates, weekmask='1111100')", "intent": "Calculates which of the given `dates` are valid days , and which are not . With arguments `weekmask`. numpy", "question_id": 16663}
{"snippet": "numpy.is_busday(dates, holidays=None)", "intent": "Calculates which of the given `dates` are valid days , and which are not . With arguments `holidays`. numpy", "question_id": 16664}
{"snippet": "numpy.is_busday(dates, busdaycal=None)", "intent": "Calculates which of the given `dates` are valid days , and which are not . With arguments `busdaycal`. numpy", "question_id": 16665}
{"snippet": "numpy.is_busday(dates, out=None)", "intent": "Calculates which of the given `dates` are valid days , and which are not . With arguments `out`. numpy", "question_id": 16666}
{"snippet": "numpy.is_busday(dates, weekmask='1111100', holidays=None)", "intent": "Calculates which of the given `dates` are valid days , and which are not . With arguments `weekmask`, `holidays`. numpy", "question_id": 16667}
{"snippet": "numpy.is_busday(dates, weekmask='1111100', busdaycal=None)", "intent": "Calculates which of the given `dates` are valid days , and which are not . With arguments `weekmask`, `busdaycal`. numpy", "question_id": 16668}
{"snippet": "numpy.is_busday(dates, weekmask='1111100', out=None)", "intent": "Calculates which of the given `dates` are valid days , and which are not . With arguments `weekmask`, `out`. numpy", "question_id": 16669}
{"snippet": "numpy.is_busday(dates, holidays=None, busdaycal=None)", "intent": "Calculates which of the given `dates` are valid days , and which are not . With arguments `holidays`, `busdaycal`. numpy", "question_id": 16670}
{"snippet": "numpy.is_busday(dates, holidays=None, out=None)", "intent": "Calculates which of the given `dates` are valid days , and which are not . With arguments `holidays`, `out`. numpy", "question_id": 16671}
{"snippet": "chararray.nonzero()", "intent": "Return the indices of the elements that are non-zero . numpy", "question_id": 16672}
{"snippet": "ma.masked_array.iscontiguous()", "intent": "Return a boolean indicating whether the data is contiguous . numpy", "question_id": 16673}
{"snippet": "polynomial.legendre.legvander2d(x, y, deg)", "intent": "Pseudo-Vandermonde matrix of given degrees . Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points ( `x` , `y` ) . numpy", "question_id": 16674}
{"snippet": "numpy.savez_compressed(file, *args, **kwds)", "intent": "Save several arrays into a single `file` in compressed .npz format . With arguments `*args`, `**kwds`. numpy", "question_id": 16675}
{"snippet": "ma.MaskedArray.__sub__(other)", "intent": "Subtract `other` from self , and return a new masked array . numpy", "question_id": 16676}
{"snippet": "polynomial.legendre.Legendre.linspace()", "intent": "Return x , y values at equally spaced points in `domain` . numpy", "question_id": 16677}
{"snippet": "polynomial.legendre.Legendre.linspace(n=100)", "intent": "Return x , y values at equally spaced points in `domain` . Returns the x , y values at `n` linearly spaced points across the domain . numpy", "question_id": 16678}
{"snippet": "polynomial.legendre.Legendre.linspace(domain=None)", "intent": "Return x , y values at equally spaced points in `domain` . numpy", "question_id": 16679}
{"snippet": "polynomial.legendre.Legendre.linspace(n=100, domain=None)", "intent": "Return x , y values at equally spaced points in `domain` . Returns the x , y values at `n` linearly spaced points across the domain . numpy", "question_id": 16680}
{"snippet": "memmap.flush()", "intent": "Write any changes in the array to the file on disk . numpy", "question_id": 16681}
{"snippet": "char.chararray.nonzero()", "intent": "Return the indices of the elements that are non-zero . numpy", "question_id": 16682}
{"snippet": "record.sum()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 16683}
{"snippet": "char.chararray.isupper()", "intent": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character , false otherwise . numpy", "question_id": 16684}
{"snippet": "ma.masked_array.round()", "intent": "Return each element rounded to the given number of `decimals` . numpy", "question_id": 16685}
{"snippet": "ma.masked_array.round(decimals=0)", "intent": "Return each element rounded to the given number of `decimals` . numpy", "question_id": 16686}
{"snippet": "ma.masked_array.round(out=None)", "intent": "Return each element rounded to the given number of `decimals` . With arguments `out`. numpy", "question_id": 16687}
{"snippet": "ma.masked_array.round(decimals=0, out=None)", "intent": "Return each element rounded to the given number of `decimals` . With arguments `out`. numpy", "question_id": 16688}
{"snippet": "ma.masked_array.item(*args)", "intent": "Copy an element of an array to a standard Python scalar and return it . With arguments `*args`. numpy", "question_id": 16689}
{"snippet": "ma.MaskedArray.__lshift__(value, /)", "intent": "Return self < < `value` . With arguments `/`. numpy", "question_id": 16690}
{"snippet": "matrix.getH()", "intent": "Returns the ( complex ) conjugate transpose of self . numpy", "question_id": 16691}
{"snippet": "random.RandomState.seed(self)", "intent": "Reseed a legacy MT19937 BitGenerator With arguments `self`. numpy", "question_id": 16692}
{"snippet": "random.RandomState.seed(self, seed=None)", "intent": "Reseed a legacy MT19937 BitGenerator With arguments `self`, `seed`. numpy", "question_id": 16693}
{"snippet": "polynomial.hermite.Hermite.deriv()", "intent": "Differentiate . numpy", "question_id": 16694}
{"snippet": "polynomial.hermite.Hermite.deriv(m=1)", "intent": "Differentiate . With arguments `m`. numpy", "question_id": 16695}
{"snippet": "polynomial.polynomial.Polynomial.roots()", "intent": "Return the roots of the series polynomial . numpy", "question_id": 16696}
{"snippet": "ndarray.__setstate__(state, /)", "intent": "For unpickling . The `state` argument must be a sequence that contains the following elements : With arguments `/`. numpy", "question_id": 16697}
{"snippet": "recarray.take(indices)", "intent": "Return an array formed from the elements of a at the given `indices` . numpy", "question_id": 16698}
{"snippet": "recarray.take(indices, axis=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`. numpy", "question_id": 16699}
{"snippet": "recarray.take(indices, out=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `out`. numpy", "question_id": 16700}
{"snippet": "recarray.take(indices, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `mode`. numpy", "question_id": 16701}
{"snippet": "recarray.take(indices, axis=None, out=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `out`. numpy", "question_id": 16702}
{"snippet": "recarray.take(indices, axis=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `mode`. numpy", "question_id": 16703}
{"snippet": "recarray.take(indices, out=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `out`, `mode`. numpy", "question_id": 16704}
{"snippet": "recarray.take(indices, axis=None, out=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `out`, `mode`. numpy", "question_id": 16705}
{"snippet": "ndarray.__contains__(key, /)", "intent": "Return `key` in self . With arguments `/`. numpy", "question_id": 16706}
{"snippet": "ma.MaskedArray.item(*args)", "intent": "Copy an element of an array to a standard Python scalar and return it . With arguments `*args`. numpy", "question_id": 16707}
{"snippet": "numpy.atleast_2d(*arys)", "intent": "View inputs as arrays with at least two dimensions . With arguments `*arys`. numpy", "question_id": 16708}
{"snippet": "char.chararray.sort()", "intent": "Sort an array in-place . numpy", "question_id": 16709}
{"snippet": "char.chararray.sort(axis=- 1)", "intent": "Sort an array in-place . With arguments `axis`. numpy", "question_id": 16710}
{"snippet": "char.chararray.sort(kind=None)", "intent": "Sort an array in-place . With arguments `kind`. numpy", "question_id": 16711}
{"snippet": "char.chararray.sort(order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : numpy", "question_id": 16712}
{"snippet": "char.chararray.sort(axis=- 1, kind=None)", "intent": "Sort an array in-place . With arguments `axis`, `kind`. numpy", "question_id": 16713}
{"snippet": "char.chararray.sort(axis=- 1, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `axis`. numpy", "question_id": 16714}
{"snippet": "char.chararray.sort(kind=None, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `kind`. numpy", "question_id": 16715}
{"snippet": "char.chararray.sort(axis=- 1, kind=None, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `axis`, `kind`. numpy", "question_id": 16716}
{"snippet": "ma.MaskedArray.swapaxes(axis1, axis2)", "intent": "Return a view of the array with `axis1` and `axis2` interchanged . numpy", "question_id": 16717}
{"snippet": "char.chararray.capitalize()", "intent": "Return a copy of self with only the first character of each element capitalized . numpy", "question_id": 16718}
{"snippet": "ma.apply_along_axis(func1d, axis, arr, *args, **kwargs)", "intent": "Apply a function to 1-D slices along the given `axis` . Execute `func1d` ( a , * args , * * kwargs ) where func1d operates on 1-D arrays and a is a 1-D slice of `arr` along axis . With arguments `*args`, `**kwargs`. numpy", "question_id": 16719}
{"snippet": "numpy.tensordot(a, b)", "intent": "Compute tensor dot product along specified `axes` . Given two tensors , `a` and `b` , and an array_like object containing two array_like objects , ( a_axes , b_axes ) , sum the products of a \u2019 s and b \u2019 s elements ( components ) over the axes specified by a_axes and b_axes . numpy", "question_id": 16720}
{"snippet": "numpy.tensordot(a, b, axes=2)", "intent": "Compute tensor dot product along specified `axes` . Given two tensors , `a` and `b` , and an array_like object containing two array_like objects , ( a_axes , b_axes ) , sum the products of a \u2019 s and b \u2019 s elements ( components ) over the axes specified by a_axes and b_axes . numpy", "question_id": 16721}
{"snippet": "numpy.lib.mixins.NDArrayOperatorsMixin", "intent": "Mixin defining all operator special methods using __array_ufunc__. numpy", "question_id": 16722}
{"snippet": "matrix.data", "intent": "Python buffer object pointing to the start of the array\u2019s data. numpy", "question_id": 16723}
{"snippet": "ndarray.resize(new_shape)", "intent": "Change shape and size of array in-place . With arguments `new_shape`. numpy", "question_id": 16724}
{"snippet": "ndarray.resize(new_shape, refcheck=True)", "intent": "Change shape and size of array in-place . However , reference counts can increase in other ways so if you are sure that you have not shared the memory for this array with another Python object , then you may safely set `refcheck` to False . With arguments `new_shape`. numpy", "question_id": 16725}
{"snippet": "matrix.repeat(repeats)", "intent": "Repeat elements of an array . With arguments `repeats`. numpy", "question_id": 16726}
{"snippet": "matrix.repeat(repeats, axis=None)", "intent": "Repeat elements of an array . With arguments `repeats`, `axis`. numpy", "question_id": 16727}
{"snippet": "ma.MaskedArray.shrink_mask()", "intent": "Reduce a mask to nomask when possible . numpy", "question_id": 16728}
{"snippet": "ma.compress_cols(a)", "intent": "Suppress whole columns of `a` 2-D array that contain masked values . numpy", "question_id": 16729}
{"snippet": "matrix.shape", "intent": "Tuple of array dimensions. numpy", "question_id": 16730}
{"snippet": "random.RandomState.hypergeometric(ngood, nbad, nsample)", "intent": "Draw samples from a Hypergeometric distribution . Samples are drawn from a hypergeometric distribution with specified parameters , `ngood` ( ways to make a good selection ) , `nbad` ( ways to make a bad selection ) , and `nsample` ( number of items sampled , which is less than or equal to the sum ngood + nbad ) . numpy", "question_id": 16731}
{"snippet": "random.RandomState.hypergeometric(ngood, nbad, nsample, size=None)", "intent": "Draw samples from a Hypergeometric distribution . Samples are drawn from a hypergeometric distribution with specified parameters , `ngood` ( ways to make a good selection ) , `nbad` ( ways to make a bad selection ) , and `nsample` ( number of items sampled , which is less than or equal to the sum ngood + nbad ) . With arguments `size`. numpy", "question_id": 16732}
{"snippet": "recarray.sort()", "intent": "Sort an array in-place . numpy", "question_id": 16733}
{"snippet": "recarray.sort(axis=- 1)", "intent": "Sort an array in-place . With arguments `axis`. numpy", "question_id": 16734}
{"snippet": "recarray.sort(kind=None)", "intent": "Sort an array in-place . With arguments `kind`. numpy", "question_id": 16735}
{"snippet": "recarray.sort(order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : numpy", "question_id": 16736}
{"snippet": "recarray.sort(axis=- 1, kind=None)", "intent": "Sort an array in-place . With arguments `axis`, `kind`. numpy", "question_id": 16737}
{"snippet": "recarray.sort(axis=- 1, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `axis`. numpy", "question_id": 16738}
{"snippet": "recarray.sort(kind=None, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `kind`. numpy", "question_id": 16739}
{"snippet": "recarray.sort(axis=- 1, kind=None, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `axis`, `kind`. numpy", "question_id": 16740}
{"snippet": "numpy.add(x1, x2, /, signature, extobj)", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 16741}
{"snippet": "numpy.add(x1, x2, /, signature, extobj, out=None)", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 16742}
{"snippet": "numpy.add(x1, x2, /, signature, extobj, where=True)", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 16743}
{"snippet": "numpy.add(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 16744}
{"snippet": "numpy.add(x1, x2, /, signature, extobj, order='K')", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 16745}
{"snippet": "numpy.add(x1, x2, /, signature, extobj, dtype=None)", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 16746}
{"snippet": "numpy.add(x1, x2, /, signature, extobj, subok=True)", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 16747}
{"snippet": "numpy.add(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 16748}
{"snippet": "numpy.add(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 16749}
{"snippet": "numpy.add(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 16750}
{"snippet": "numpy.add(x1, x2, /, signature)", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`. numpy", "question_id": 16751}
{"snippet": "numpy.add(x1, x2, /, signature, out=None)", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `out`. numpy", "question_id": 16752}
{"snippet": "numpy.add(x1, x2, /, signature, where=True)", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `where`. numpy", "question_id": 16753}
{"snippet": "numpy.add(x1, x2, /, signature, casting='same_kind')", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `casting`. numpy", "question_id": 16754}
{"snippet": "numpy.add(x1, x2, /, signature, order='K')", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `order`. numpy", "question_id": 16755}
{"snippet": "numpy.add(x1, x2, /, signature, dtype=None)", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 16756}
{"snippet": "numpy.add(x1, x2, /, signature, subok=True)", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `subok`. numpy", "question_id": 16757}
{"snippet": "numpy.add(x1, x2, /, signature, out=None, where=True)", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 16758}
{"snippet": "numpy.add(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 16759}
{"snippet": "numpy.add(x1, x2, /, signature, out=None, order='K')", "intent": "Add arguments element-wise . Equivalent to `x1` + `x2` in terms of array broadcasting . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 16760}
{"snippet": "ndarray.__xor__(value, /)", "intent": "Return self^value . With arguments `value`, `/`. numpy", "question_id": 16761}
{"snippet": "chararray.upper()", "intent": "Return an array with the elements of self converted to uppercase . numpy", "question_id": 16762}
{"snippet": "ma.anom(self)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . With arguments `self`. numpy", "question_id": 16763}
{"snippet": "ma.anom(self, axis=None)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . With arguments `self`. numpy", "question_id": 16764}
{"snippet": "ma.anom(self, dtype=None)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . With arguments `self`, `dtype`. numpy", "question_id": 16765}
{"snippet": "ma.anom(self, axis=None, dtype=None)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . With arguments `self`, `dtype`. numpy", "question_id": 16766}
{"snippet": "ma.masked_array.get_real()", "intent": "The real part of the masked array . numpy", "question_id": 16767}
{"snippet": "random.RandomState.standard_normal()", "intent": "Draw samples from a standard Normal distribution ( mean=0 , stdev=1 ) . numpy", "question_id": 16768}
{"snippet": "random.RandomState.standard_normal(size=None)", "intent": "Draw samples from a standard Normal distribution ( mean=0 , stdev=1 ) . With arguments `size`. numpy", "question_id": 16769}
{"snippet": "ma.masked_less_equal(x, value)", "intent": "Mask an array where less than or equal to a given `value` . This function is a shortcut to masked_where , with condition = ( `x` < = value ) . numpy", "question_id": 16770}
{"snippet": "ma.masked_less_equal(x, value, copy=True)", "intent": "Mask an array where less than or equal to a given `value` . This function is a shortcut to masked_where , with condition = ( `x` < = value ) . With arguments `copy`. numpy", "question_id": 16771}
{"snippet": "numpy.nanmax(a)", "intent": "Return the maximum of an array or maximum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and NaN is returned for that slice . numpy", "question_id": 16772}
{"snippet": "numpy.nanmax(a, axis=None)", "intent": "Return the maximum of an array or maximum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and NaN is returned for that slice . numpy", "question_id": 16773}
{"snippet": "numpy.nanmax(a, out=None)", "intent": "Return the maximum of an array or maximum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and NaN is returned for that slice . With arguments `out`. numpy", "question_id": 16774}
{"snippet": "numpy.nanmax(a, keepdims=<no value>)", "intent": "Return the maximum of an array or maximum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and NaN is returned for that slice . With arguments `keepdims`. numpy", "question_id": 16775}
{"snippet": "numpy.nanmax(a, axis=None, out=None)", "intent": "Return the maximum of an array or maximum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and NaN is returned for that slice . With arguments `out`. numpy", "question_id": 16776}
{"snippet": "numpy.nanmax(a, axis=None, keepdims=<no value>)", "intent": "Return the maximum of an array or maximum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and NaN is returned for that slice . With arguments `keepdims`. numpy", "question_id": 16777}
{"snippet": "numpy.nanmax(a, out=None, keepdims=<no value>)", "intent": "Return the maximum of an array or maximum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and NaN is returned for that slice . With arguments `out`, `keepdims`. numpy", "question_id": 16778}
{"snippet": "numpy.nanmax(a, axis=None, out=None, keepdims=<no value>)", "intent": "Return the maximum of an array or maximum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and NaN is returned for that slice . With arguments `out`, `keepdims`. numpy", "question_id": 16779}
{"snippet": "chararray.size", "intent": "Number of elements in the array. numpy", "question_id": 16780}
{"snippet": "numpy.tan(x, /, signature, extobj)", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 16781}
{"snippet": "numpy.tan(x, /, signature, extobj, out=None)", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 16782}
{"snippet": "numpy.tan(x, /, signature, extobj, where=True)", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 16783}
{"snippet": "numpy.tan(x, /, signature, extobj, casting='same_kind')", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 16784}
{"snippet": "numpy.tan(x, /, signature, extobj, order='K')", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 16785}
{"snippet": "numpy.tan(x, /, signature, extobj, dtype=None)", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 16786}
{"snippet": "numpy.tan(x, /, signature, extobj, subok=True)", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 16787}
{"snippet": "numpy.tan(x, /, signature, extobj, out=None, where=True)", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 16788}
{"snippet": "numpy.tan(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 16789}
{"snippet": "numpy.tan(x, /, signature, extobj, out=None, order='K')", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 16790}
{"snippet": "numpy.tan(x, /, signature)", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . With arguments `/`, `signature`. numpy", "question_id": 16791}
{"snippet": "numpy.tan(x, /, signature, out=None)", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`. numpy", "question_id": 16792}
{"snippet": "numpy.tan(x, /, signature, where=True)", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . With arguments `/`, `signature`, `where`. numpy", "question_id": 16793}
{"snippet": "numpy.tan(x, /, signature, casting='same_kind')", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . With arguments `/`, `signature`, `casting`. numpy", "question_id": 16794}
{"snippet": "numpy.tan(x, /, signature, order='K')", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . With arguments `/`, `signature`, `order`. numpy", "question_id": 16795}
{"snippet": "numpy.tan(x, /, signature, dtype=None)", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 16796}
{"snippet": "numpy.tan(x, /, signature, subok=True)", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . With arguments `/`, `signature`, `subok`. numpy", "question_id": 16797}
{"snippet": "numpy.tan(x, /, signature, out=None, where=True)", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `where`. numpy", "question_id": 16798}
{"snippet": "numpy.tan(x, /, signature, out=None, casting='same_kind')", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `casting`. numpy", "question_id": 16799}
{"snippet": "numpy.tan(x, /, signature, out=None, order='K')", "intent": "Compute tangent element-wise . Equivalent to np.sin ( `x` ) /np.cos ( x ) element-wise . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `order`. numpy", "question_id": 16800}
{"snippet": "random.Generator.multinomial(n, pvals)", "intent": "Draw samples from a multinomial distribution . Each sample drawn from the distribution represents `n` such experiments . With arguments `pvals`. numpy", "question_id": 16801}
{"snippet": "random.Generator.multinomial(n, pvals, size=None)", "intent": "Draw samples from a multinomial distribution . Each sample drawn from the distribution represents `n` such experiments . With arguments `pvals`, `size`. numpy", "question_id": 16802}
{"snippet": "memmap.round()", "intent": "Return a with each element rounded to the given number of `decimals` . numpy", "question_id": 16803}
{"snippet": "memmap.round(decimals=0)", "intent": "Return a with each element rounded to the given number of `decimals` . numpy", "question_id": 16804}
{"snippet": "memmap.round(out=None)", "intent": "Return a with each element rounded to the given number of `decimals` . With arguments `out`. numpy", "question_id": 16805}
{"snippet": "memmap.round(decimals=0, out=None)", "intent": "Return a with each element rounded to the given number of `decimals` . With arguments `out`. numpy", "question_id": 16806}
{"snippet": "char.chararray.item(*args)", "intent": "Copy an element of an array to a standard Python scalar and return it . With arguments `*args`. numpy", "question_id": 16807}
{"snippet": "testing.dec.knownfailureif(fail_condition)", "intent": "Make function raise KnownFailureException exception if given condition is true . With arguments `fail_condition`. numpy", "question_id": 16808}
{"snippet": "testing.dec.knownfailureif(fail_condition, msg=None)", "intent": "Make function raise KnownFailureException exception if given condition is true . With arguments `fail_condition`, `msg`. numpy", "question_id": 16809}
{"snippet": "ma.compress_rows(a)", "intent": "Suppress whole rows of `a` 2-D array that contain masked values . numpy", "question_id": 16810}
{"snippet": "chararray.find(sub)", "intent": "For each element , return the lowest index in the string where substring `sub` is found . numpy", "question_id": 16811}
{"snippet": "chararray.find(sub, start=0)", "intent": "For each element , return the lowest index in the string where substring `sub` is found . With arguments `start`. numpy", "question_id": 16812}
{"snippet": "chararray.find(sub, end=None)", "intent": "For each element , return the lowest index in the string where substring `sub` is found . With arguments `end`. numpy", "question_id": 16813}
{"snippet": "chararray.find(sub, start=0, end=None)", "intent": "For each element , return the lowest index in the string where substring `sub` is found . With arguments `start`, `end`. numpy", "question_id": 16814}
{"snippet": "record.repeat()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 16815}
{"snippet": "lib.format.header_data_from_array_1_0(array)", "intent": "Get the dictionary of header metadata from a numpy.ndarray . With arguments `array`. numpy", "question_id": 16816}
{"snippet": "matrix.getI()", "intent": "Returns the ( multiplicative ) inverse of invertible self . numpy", "question_id": 16817}
{"snippet": "numpy.s_", "intent": "A nicer way to build up index tuples for arrays. numpy", "question_id": 16818}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, extobj)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`. numpy", "question_id": 16819}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, extobj, out=(None)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `out`. numpy", "question_id": 16820}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, extobj, where=True)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `where`. numpy", "question_id": 16821}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, extobj, casting='same_kind')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `casting`. numpy", "question_id": 16822}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, extobj, order='K')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `order`. numpy", "question_id": 16823}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, extobj, dtype=None)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `dtype`. numpy", "question_id": 16824}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, extobj, subok=True)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `subok`. numpy", "question_id": 16825}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, extobj, out=(None, where=True)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 16826}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, extobj, out=(None, casting='same_kind')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 16827}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, extobj, out=(None, order='K')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 16828}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`. numpy", "question_id": 16829}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, out=(None)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `out`. numpy", "question_id": 16830}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, where=True)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `where`. numpy", "question_id": 16831}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, casting='same_kind')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `casting`. numpy", "question_id": 16832}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, order='K')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `order`. numpy", "question_id": 16833}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, dtype=None)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `dtype`. numpy", "question_id": 16834}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, subok=True)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `subok`. numpy", "question_id": 16835}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, out=(None, where=True)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `out`, `where`. numpy", "question_id": 16836}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, out=(None, casting='same_kind')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `out`, `casting`. numpy", "question_id": 16837}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), signature, out=(None, order='K')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `signature`, `out`, `order`. numpy", "question_id": 16838}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None))", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`. numpy", "question_id": 16839}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), out=(None)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `out`. numpy", "question_id": 16840}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), where=True)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `where`. numpy", "question_id": 16841}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), casting='same_kind')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `casting`. numpy", "question_id": 16842}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), order='K')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `order`. numpy", "question_id": 16843}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), dtype=None)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `dtype`. numpy", "question_id": 16844}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), subok=True)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `subok`. numpy", "question_id": 16845}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), out=(None, where=True)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `out`, `where`. numpy", "question_id": 16846}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), out=(None, casting='same_kind')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `out`, `casting`. numpy", "question_id": 16847}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, None), out=(None, order='K')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `None)`, `out`, `order`. numpy", "question_id": 16848}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`. numpy", "question_id": 16849}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, out=(None)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `out`. numpy", "question_id": 16850}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, where=True)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `where`. numpy", "question_id": 16851}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, casting='same_kind')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `casting`. numpy", "question_id": 16852}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, order='K')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `order`. numpy", "question_id": 16853}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, dtype=None)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `dtype`. numpy", "question_id": 16854}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, subok=True)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `subok`. numpy", "question_id": 16855}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, out=(None, where=True)", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `out`, `where`. numpy", "question_id": 16856}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, out=(None, casting='same_kind')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `out`, `casting`. numpy", "question_id": 16857}
{"snippet": "numpy.divmod(x1, x2, out1, out2, /, out=(None, order='K')", "intent": "Return element-wise quotient and remainder simultaneously . With arguments `x1`, `x2`, `out1`, `out2`, `/`, `out`, `order`. numpy", "question_id": 16858}
{"snippet": "numpy.seterr()", "intent": "Set how floating-point errors are handled . numpy", "question_id": 16859}
{"snippet": "numpy.seterr(all=None)", "intent": "Set how floating-point errors are handled . With arguments `all`. numpy", "question_id": 16860}
{"snippet": "numpy.seterr(divide=None)", "intent": "Set how floating-point errors are handled . With arguments `divide`. numpy", "question_id": 16861}
{"snippet": "numpy.seterr(over=None)", "intent": "Set how floating-point errors are handled . With arguments `over`. numpy", "question_id": 16862}
{"snippet": "numpy.seterr(under=None)", "intent": "Set how floating-point errors are handled . With arguments `under`. numpy", "question_id": 16863}
{"snippet": "numpy.seterr(invalid=None)", "intent": "Set how floating-point errors are handled . With arguments `invalid`. numpy", "question_id": 16864}
{"snippet": "numpy.seterr(all=None, divide=None)", "intent": "Set how floating-point errors are handled . With arguments `all`, `divide`. numpy", "question_id": 16865}
{"snippet": "numpy.seterr(all=None, over=None)", "intent": "Set how floating-point errors are handled . With arguments `all`, `over`. numpy", "question_id": 16866}
{"snippet": "numpy.seterr(all=None, under=None)", "intent": "Set how floating-point errors are handled . With arguments `all`, `under`. numpy", "question_id": 16867}
{"snippet": "numpy.seterr(all=None, invalid=None)", "intent": "Set how floating-point errors are handled . With arguments `all`, `invalid`. numpy", "question_id": 16868}
{"snippet": "ma.average(a)", "intent": "Return the weighted average of array over the given `axis` . With arguments `a`. numpy", "question_id": 16869}
{"snippet": "ma.average(a, axis=None)", "intent": "Return the weighted average of array over the given `axis` . With arguments `a`. numpy", "question_id": 16870}
{"snippet": "ma.average(a, weights=None)", "intent": "Return the weighted average of array over the given `axis` . With arguments `a`, `weights`. numpy", "question_id": 16871}
{"snippet": "ma.average(a, returned=False)", "intent": "Return the weighted average of array over the given `axis` . With arguments `a`, `returned`. numpy", "question_id": 16872}
{"snippet": "ma.average(a, axis=None, weights=None)", "intent": "Return the weighted average of array over the given `axis` . With arguments `a`, `weights`. numpy", "question_id": 16873}
{"snippet": "ma.average(a, axis=None, returned=False)", "intent": "Return the weighted average of array over the given `axis` . With arguments `a`, `returned`. numpy", "question_id": 16874}
{"snippet": "ma.average(a, weights=None, returned=False)", "intent": "Return the weighted average of array over the given `axis` . With arguments `a`, `weights`, `returned`. numpy", "question_id": 16875}
{"snippet": "ma.average(a, axis=None, weights=None, returned=False)", "intent": "Return the weighted average of array over the given `axis` . With arguments `a`, `weights`, `returned`. numpy", "question_id": 16876}
{"snippet": "numpy.arccosh(x, /, signature, extobj)", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 16877}
{"snippet": "numpy.arccosh(x, /, signature, extobj, out=None)", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 16878}
{"snippet": "numpy.arccosh(x, /, signature, extobj, where=True)", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 16879}
{"snippet": "numpy.arccosh(x, /, signature, extobj, casting='same_kind')", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 16880}
{"snippet": "numpy.arccosh(x, /, signature, extobj, order='K')", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 16881}
{"snippet": "numpy.arccosh(x, /, signature, extobj, dtype=None)", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 16882}
{"snippet": "numpy.arccosh(x, /, signature, extobj, subok=True)", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 16883}
{"snippet": "numpy.arccosh(x, /, signature, extobj, out=None, where=True)", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 16884}
{"snippet": "numpy.arccosh(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 16885}
{"snippet": "numpy.arccosh(x, /, signature, extobj, out=None, order='K')", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 16886}
{"snippet": "numpy.arccosh(x, /, signature)", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`. numpy", "question_id": 16887}
{"snippet": "numpy.arccosh(x, /, signature, out=None)", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `out`. numpy", "question_id": 16888}
{"snippet": "numpy.arccosh(x, /, signature, where=True)", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `where`. numpy", "question_id": 16889}
{"snippet": "numpy.arccosh(x, /, signature, casting='same_kind')", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `casting`. numpy", "question_id": 16890}
{"snippet": "numpy.arccosh(x, /, signature, order='K')", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `order`. numpy", "question_id": 16891}
{"snippet": "numpy.arccosh(x, /, signature, dtype=None)", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 16892}
{"snippet": "numpy.arccosh(x, /, signature, subok=True)", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `subok`. numpy", "question_id": 16893}
{"snippet": "numpy.arccosh(x, /, signature, out=None, where=True)", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 16894}
{"snippet": "numpy.arccosh(x, /, signature, out=None, casting='same_kind')", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 16895}
{"snippet": "numpy.arccosh(x, /, signature, out=None, order='K')", "intent": "Inverse hyperbolic cosine , element-wise . arccosh is a multivalued function : for each `x` there are infinitely many numbers z such that cosh ( z ) = x . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 16896}
{"snippet": "ma.anomalies(self)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . With arguments `self`. numpy", "question_id": 16897}
{"snippet": "ma.anomalies(self, axis=None)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . With arguments `self`. numpy", "question_id": 16898}
{"snippet": "ma.anomalies(self, dtype=None)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . With arguments `self`, `dtype`. numpy", "question_id": 16899}
{"snippet": "ma.anomalies(self, axis=None, dtype=None)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . With arguments `self`, `dtype`. numpy", "question_id": 16900}
{"snippet": "memmap.dump(file)", "intent": "Dump a pickle of the array to the specified `file` . numpy", "question_id": 16901}
{"snippet": "recarray.tofile(fid)", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . numpy", "question_id": 16902}
{"snippet": "recarray.tofile(fid, sep='')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `sep`. numpy", "question_id": 16903}
{"snippet": "recarray.tofile(fid, format='%s')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `format`. numpy", "question_id": 16904}
{"snippet": "recarray.tofile(fid, sep='', format='%s')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `sep`, `format`. numpy", "question_id": 16905}
{"snippet": "polynomial.chebyshev.chebpts1(npts)", "intent": "Chebyshev points of the first kind . The Chebyshev points of the first kind are the points cos ( x ) , where x = [ pi * ( k + .5 ) /npts for k in range ( `npts` ) ] . numpy", "question_id": 16906}
{"snippet": "chararray.cumsum()", "intent": "Return the cumulative sum of the elements along the given `axis` . numpy", "question_id": 16907}
{"snippet": "chararray.cumsum(axis=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . numpy", "question_id": 16908}
{"snippet": "chararray.cumsum(dtype=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 16909}
{"snippet": "chararray.cumsum(out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `out`. numpy", "question_id": 16910}
{"snippet": "chararray.cumsum(axis=None, dtype=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 16911}
{"snippet": "chararray.cumsum(axis=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `out`. numpy", "question_id": 16912}
{"snippet": "chararray.cumsum(dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 16913}
{"snippet": "chararray.cumsum(axis=None, dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 16914}
{"snippet": "ndarray.__str__(/)", "intent": "Return str ( self ) . With arguments `/`. numpy", "question_id": 16915}
{"snippet": "char.encode(a)", "intent": "Calls str.encode element-wise . With arguments `a`. numpy", "question_id": 16916}
{"snippet": "char.encode(a, encoding=None)", "intent": "Calls str.encode element-wise . The type of the result will depend on the `encoding` specified . With arguments `a`. numpy", "question_id": 16917}
{"snippet": "char.encode(a, errors=None)", "intent": "Calls str.encode element-wise . With arguments `a`, `errors`. numpy", "question_id": 16918}
{"snippet": "char.encode(a, encoding=None, errors=None)", "intent": "Calls str.encode element-wise . The type of the result will depend on the `encoding` specified . With arguments `a`, `errors`. numpy", "question_id": 16919}
{"snippet": "matrix.take(indices)", "intent": "Return an array formed from the elements of a at the given `indices` . numpy", "question_id": 16920}
{"snippet": "matrix.take(indices, axis=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`. numpy", "question_id": 16921}
{"snippet": "matrix.take(indices, out=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `out`. numpy", "question_id": 16922}
{"snippet": "matrix.take(indices, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `mode`. numpy", "question_id": 16923}
{"snippet": "matrix.take(indices, axis=None, out=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `out`. numpy", "question_id": 16924}
{"snippet": "matrix.take(indices, axis=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `mode`. numpy", "question_id": 16925}
{"snippet": "matrix.take(indices, out=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `out`, `mode`. numpy", "question_id": 16926}
{"snippet": "matrix.take(indices, axis=None, out=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `out`, `mode`. numpy", "question_id": 16927}
{"snippet": "testing.assert_allclose(actual, desired)", "intent": "Raises an AssertionError if two objects are not equal up to `desired` tolerance . The test is equivalent to allclose ( `actual` , desired , `rtol` , `atol` ) ( note that allclose has different default values ) . numpy", "question_id": 16928}
{"snippet": "testing.assert_allclose(actual, desired, rtol=1e-07)", "intent": "Raises an AssertionError if two objects are not equal up to `desired` tolerance . The test is equivalent to allclose ( `actual` , desired , `rtol` , `atol` ) ( note that allclose has different default values ) . numpy", "question_id": 16929}
{"snippet": "testing.assert_allclose(actual, desired, atol=0)", "intent": "Raises an AssertionError if two objects are not equal up to `desired` tolerance . The test is equivalent to allclose ( `actual` , desired , `rtol` , `atol` ) ( note that allclose has different default values ) . numpy", "question_id": 16930}
{"snippet": "testing.assert_allclose(actual, desired, equal_nan=True)", "intent": "Raises an AssertionError if two objects are not equal up to `desired` tolerance . The test is equivalent to allclose ( `actual` , desired , `rtol` , `atol` ) ( note that allclose has different default values ) . With arguments `equal_nan`. numpy", "question_id": 16931}
{"snippet": "testing.assert_allclose(actual, desired, err_msg='')", "intent": "Raises an AssertionError if two objects are not equal up to `desired` tolerance . The test is equivalent to allclose ( `actual` , desired , `rtol` , `atol` ) ( note that allclose has different default values ) . With arguments `err_msg`. numpy", "question_id": 16932}
{"snippet": "testing.assert_allclose(actual, desired, verbose=True)", "intent": "Raises an AssertionError if two objects are not equal up to `desired` tolerance . The test is equivalent to allclose ( `actual` , desired , `rtol` , `atol` ) ( note that allclose has different default values ) . With arguments `verbose`. numpy", "question_id": 16933}
{"snippet": "testing.assert_allclose(actual, desired, rtol=1e-07, atol=0)", "intent": "Raises an AssertionError if two objects are not equal up to `desired` tolerance . The test is equivalent to allclose ( `actual` , desired , `rtol` , `atol` ) ( note that allclose has different default values ) . numpy", "question_id": 16934}
{"snippet": "testing.assert_allclose(actual, desired, rtol=1e-07, equal_nan=True)", "intent": "Raises an AssertionError if two objects are not equal up to `desired` tolerance . The test is equivalent to allclose ( `actual` , desired , `rtol` , `atol` ) ( note that allclose has different default values ) . With arguments `equal_nan`. numpy", "question_id": 16935}
{"snippet": "testing.assert_allclose(actual, desired, rtol=1e-07, err_msg='')", "intent": "Raises an AssertionError if two objects are not equal up to `desired` tolerance . The test is equivalent to allclose ( `actual` , desired , `rtol` , `atol` ) ( note that allclose has different default values ) . With arguments `err_msg`. numpy", "question_id": 16936}
{"snippet": "testing.assert_allclose(actual, desired, rtol=1e-07, verbose=True)", "intent": "Raises an AssertionError if two objects are not equal up to `desired` tolerance . The test is equivalent to allclose ( `actual` , desired , `rtol` , `atol` ) ( note that allclose has different default values ) . With arguments `verbose`. numpy", "question_id": 16937}
{"snippet": "distutils.ccompiler_opt.new_ccompiler_opt(compiler, dispatch_hpath, **kwargs)", "intent": "Create a new instance of \u2018 CCompilerOpt \u2019 and generate the dispatch header which contains the # definitions and headers of platform-specific instruction-sets for the enabled CPU baseline and dispatch-able features . With arguments `compiler`, `dispatch_hpath`, `**kwargs`. numpy", "question_id": 16938}
{"snippet": "ma.set_fill_value(a, fill_value)", "intent": "Set the filling value of `a` , if a is a masked array . With arguments `fill_value`. numpy", "question_id": 16939}
{"snippet": "char.chararray.std()", "intent": "Returns the standard deviation of the array elements along given `axis` . numpy", "question_id": 16940}
{"snippet": "char.chararray.std(axis=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . numpy", "question_id": 16941}
{"snippet": "char.chararray.std(dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 16942}
{"snippet": "char.chararray.std(out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 16943}
{"snippet": "char.chararray.std(ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`. numpy", "question_id": 16944}
{"snippet": "char.chararray.std(keepdims=False)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `keepdims`. numpy", "question_id": 16945}
{"snippet": "char.chararray.std(where=True)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `where`. numpy", "question_id": 16946}
{"snippet": "char.chararray.std(axis=None, dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 16947}
{"snippet": "char.chararray.std(axis=None, out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 16948}
{"snippet": "char.chararray.std(axis=None, ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`. numpy", "question_id": 16949}
{"snippet": "ma.MaskedArray.__lt__(value, /)", "intent": "Return self < `value` . With arguments `/`. numpy", "question_id": 16950}
{"snippet": "ma.MaskedArray.any()", "intent": "Returns True if any of the elements of a evaluate to True . numpy", "question_id": 16951}
{"snippet": "ma.MaskedArray.any(axis=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`. numpy", "question_id": 16952}
{"snippet": "ma.MaskedArray.any(out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`. numpy", "question_id": 16953}
{"snippet": "ma.MaskedArray.any(keepdims=<no value>)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `keepdims`. numpy", "question_id": 16954}
{"snippet": "ma.MaskedArray.any(axis=None, out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `out`. numpy", "question_id": 16955}
{"snippet": "ma.MaskedArray.any(axis=None, keepdims=<no value>)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `keepdims`. numpy", "question_id": 16956}
{"snippet": "ma.MaskedArray.any(out=None, keepdims=<no value>)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`, `keepdims`. numpy", "question_id": 16957}
{"snippet": "ma.MaskedArray.any(axis=None, out=None, keepdims=<no value>)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `out`, `keepdims`. numpy", "question_id": 16958}
{"snippet": "testing.assert_array_almost_equal(x, y)", "intent": "Raises an AssertionError if two objects are not equal up to desired precision . With arguments `x`, `y`. numpy", "question_id": 16959}
{"snippet": "testing.assert_array_almost_equal(x, y, decimal=6)", "intent": "Raises an AssertionError if two objects are not equal up to desired precision . With arguments `x`, `y`, `decimal`. numpy", "question_id": 16960}
{"snippet": "testing.assert_array_almost_equal(x, y, err_msg='')", "intent": "Raises an AssertionError if two objects are not equal up to desired precision . With arguments `x`, `y`, `err_msg`. numpy", "question_id": 16961}
{"snippet": "testing.assert_array_almost_equal(x, y, verbose=True)", "intent": "Raises an AssertionError if two objects are not equal up to desired precision . With arguments `x`, `y`, `verbose`. numpy", "question_id": 16962}
{"snippet": "testing.assert_array_almost_equal(x, y, decimal=6, err_msg='')", "intent": "Raises an AssertionError if two objects are not equal up to desired precision . With arguments `x`, `y`, `decimal`, `err_msg`. numpy", "question_id": 16963}
{"snippet": "testing.assert_array_almost_equal(x, y, decimal=6, verbose=True)", "intent": "Raises an AssertionError if two objects are not equal up to desired precision . With arguments `x`, `y`, `decimal`, `verbose`. numpy", "question_id": 16964}
{"snippet": "testing.assert_array_almost_equal(x, y, err_msg='', verbose=True)", "intent": "Raises an AssertionError if two objects are not equal up to desired precision . With arguments `x`, `y`, `err_msg`, `verbose`. numpy", "question_id": 16965}
{"snippet": "testing.assert_array_almost_equal(x, y, decimal=6, err_msg='', verbose=True)", "intent": "Raises an AssertionError if two objects are not equal up to desired precision . With arguments `x`, `y`, `decimal`, `err_msg`, `verbose`. numpy", "question_id": 16966}
{"snippet": "ma.MaskedArray.view()", "intent": "Return a view of the MaskedArray data . numpy", "question_id": 16967}
{"snippet": "ma.MaskedArray.view(dtype=None)", "intent": "Return a view of the MaskedArray data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) numpy", "question_id": 16968}
{"snippet": "ma.MaskedArray.view(type=None)", "intent": "Return a view of the MaskedArray data . With arguments `type`. numpy", "question_id": 16969}
{"snippet": "ma.MaskedArray.view(fill_value=None)", "intent": "Return a view of the MaskedArray data . If `fill_value` is not specified , but dtype is specified ( and is not an ndarray sub-class ) , the fill_value of the MaskedArray will be reset . numpy", "question_id": 16970}
{"snippet": "ma.MaskedArray.view(dtype=None, type=None)", "intent": "Return a view of the MaskedArray data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) With arguments `type`. numpy", "question_id": 16971}
{"snippet": "ma.MaskedArray.view(dtype=None, fill_value=None)", "intent": "Return a view of the MaskedArray data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) If `fill_value` is not specified , but dtype is specified ( and is not an ndarray sub-class ) , the fill_value of the MaskedArray will be reset . numpy", "question_id": 16972}
{"snippet": "ma.MaskedArray.view(type=None, fill_value=None)", "intent": "Return a view of the MaskedArray data . If `fill_value` is not specified , but dtype is specified ( and is not an ndarray sub-class ) , the fill_value of the MaskedArray will be reset . With arguments `type`. numpy", "question_id": 16973}
{"snippet": "ma.MaskedArray.view(dtype=None, type=None, fill_value=None)", "intent": "Return a view of the MaskedArray data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) If `fill_value` is not specified , but dtype is specified ( and is not an ndarray sub-class ) , the fill_value of the MaskedArray will be reset . With arguments `type`. numpy", "question_id": 16974}
{"snippet": "ma.masked_array.ptp()", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . numpy", "question_id": 16975}
{"snippet": "ma.masked_array.ptp(axis=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `axis`. numpy", "question_id": 16976}
{"snippet": "ma.masked_array.ptp(out=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `out`. numpy", "question_id": 16977}
{"snippet": "ma.masked_array.ptp(fill_value=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `fill_value`. numpy", "question_id": 16978}
{"snippet": "ma.masked_array.ptp(keepdims=False)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `keepdims`. numpy", "question_id": 16979}
{"snippet": "ma.masked_array.ptp(axis=None, out=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `axis`, `out`. numpy", "question_id": 16980}
{"snippet": "ma.masked_array.ptp(axis=None, fill_value=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `axis`, `fill_value`. numpy", "question_id": 16981}
{"snippet": "ma.masked_array.ptp(axis=None, keepdims=False)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `axis`, `keepdims`. numpy", "question_id": 16982}
{"snippet": "ma.masked_array.ptp(out=None, fill_value=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `out`, `fill_value`. numpy", "question_id": 16983}
{"snippet": "ma.masked_array.ptp(out=None, keepdims=False)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `out`, `keepdims`. numpy", "question_id": 16984}
{"snippet": "vectorize.__call__(*args, **kwargs)", "intent": "Return arrays with the results of pyfunc broadcast ( vectorized ) over args and kwargs not in excluded . With arguments `*args`, `**kwargs`. numpy", "question_id": 16985}
{"snippet": "polynomial.hermite_e.hermediv(c1, c2)", "intent": "Divide one Hermite series by another . Returns the quotient-with-remainder of two Hermite series `c1` / `c2` . numpy", "question_id": 16986}
{"snippet": "ma.MaskedArray.var()", "intent": "Compute the variance along the specified `axis` . numpy", "question_id": 16987}
{"snippet": "ma.MaskedArray.var(axis=None)", "intent": "Compute the variance along the specified `axis` . numpy", "question_id": 16988}
{"snippet": "ma.MaskedArray.var(dtype=None)", "intent": "Compute the variance along the specified `axis` . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue . numpy", "question_id": 16989}
{"snippet": "ma.MaskedArray.var(out=None)", "intent": "Compute the variance along the specified `axis` . With arguments `out`. numpy", "question_id": 16990}
{"snippet": "ma.MaskedArray.var(ddof=0)", "intent": "Compute the variance along the specified `axis` . If , however , `ddof` is specified , the divisor N - ddof is used instead . numpy", "question_id": 16991}
{"snippet": "ma.MaskedArray.var(keepdims=<no value>)", "intent": "Compute the variance along the specified `axis` . With arguments `keepdims`. numpy", "question_id": 16992}
{"snippet": "ma.MaskedArray.var(axis=None, dtype=None)", "intent": "Compute the variance along the specified `axis` . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue . numpy", "question_id": 16993}
{"snippet": "ma.MaskedArray.var(axis=None, out=None)", "intent": "Compute the variance along the specified `axis` . With arguments `out`. numpy", "question_id": 16994}
{"snippet": "ma.MaskedArray.var(axis=None, ddof=0)", "intent": "Compute the variance along the specified `axis` . If , however , `ddof` is specified , the divisor N - ddof is used instead . numpy", "question_id": 16995}
{"snippet": "ma.MaskedArray.var(axis=None, keepdims=<no value>)", "intent": "Compute the variance along the specified `axis` . With arguments `keepdims`. numpy", "question_id": 16996}
{"snippet": "random.Generator.geometric(p)", "intent": "Draw samples from the geometric distribution . where `p` is the probability of success of an individual trial . numpy", "question_id": 16997}
{"snippet": "random.Generator.geometric(p, size=None)", "intent": "Draw samples from the geometric distribution . where `p` is the probability of success of an individual trial . With arguments `size`. numpy", "question_id": 16998}
{"snippet": "random.RandomState.standard_gamma(shape)", "intent": "Draw samples from a standard Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and scale=1 . numpy", "question_id": 16999}
{"snippet": "random.RandomState.standard_gamma(shape, size=None)", "intent": "Draw samples from a standard Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and scale=1 . With arguments `size`. numpy", "question_id": 17000}
{"snippet": "ma.clump_unmasked(a)", "intent": "Return list of slices corresponding to the unmasked clumps of `a` 1-D array . numpy", "question_id": 17001}
{"snippet": "recarray.std()", "intent": "Returns the standard deviation of the array elements along given `axis` . numpy", "question_id": 17002}
{"snippet": "recarray.std(axis=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . numpy", "question_id": 17003}
{"snippet": "recarray.std(dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 17004}
{"snippet": "recarray.std(out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 17005}
{"snippet": "recarray.std(ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`. numpy", "question_id": 17006}
{"snippet": "recarray.std(keepdims=False)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `keepdims`. numpy", "question_id": 17007}
{"snippet": "recarray.std(where=True)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `where`. numpy", "question_id": 17008}
{"snippet": "recarray.std(axis=None, dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 17009}
{"snippet": "recarray.std(axis=None, out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 17010}
{"snippet": "recarray.std(axis=None, ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`. numpy", "question_id": 17011}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_ahead(names)", "intent": "Return list of features in \u2018 `names` \u2019 after remove any implied features and keep the origins . numpy", "question_id": 17012}
{"snippet": "matrix.tolist()", "intent": "Return the matrix as a ( possibly nested ) list . numpy", "question_id": 17013}
{"snippet": "testing.dec.slow(t)", "intent": "Label a test as \u2018 slow \u2019 . With arguments `t`. numpy", "question_id": 17014}
{"snippet": "numpy.frombuffer(buffer)", "intent": "Interpret a `buffer` as a 1-dimensional array . numpy", "question_id": 17015}
{"snippet": "numpy.frombuffer(buffer, dtype=float)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `dtype`. numpy", "question_id": 17016}
{"snippet": "numpy.frombuffer(buffer, count=- 1)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `count`. numpy", "question_id": 17017}
{"snippet": "numpy.frombuffer(buffer, offset=0)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `offset`. numpy", "question_id": 17018}
{"snippet": "numpy.frombuffer(buffer, like=None)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `like`. numpy", "question_id": 17019}
{"snippet": "numpy.frombuffer(buffer, dtype=float, count=- 1)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `dtype`, `count`. numpy", "question_id": 17020}
{"snippet": "numpy.frombuffer(buffer, dtype=float, offset=0)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `dtype`, `offset`. numpy", "question_id": 17021}
{"snippet": "numpy.frombuffer(buffer, dtype=float, like=None)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `dtype`, `like`. numpy", "question_id": 17022}
{"snippet": "numpy.frombuffer(buffer, count=- 1, offset=0)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `count`, `offset`. numpy", "question_id": 17023}
{"snippet": "numpy.frombuffer(buffer, count=- 1, like=None)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `count`, `like`. numpy", "question_id": 17024}
{"snippet": "random.binomial(n, p)", "intent": "Draw samples from a binomial distribution . Samples are drawn from a binomial distribution with specified parameters , `n` trials and `p` probability of success where n an integer > = 0 and p is in the interval [ 0,1 ] . numpy", "question_id": 17025}
{"snippet": "random.binomial(n, p, size=None)", "intent": "Draw samples from a binomial distribution . Samples are drawn from a binomial distribution with specified parameters , `n` trials and `p` probability of success where n an integer > = 0 and p is in the interval [ 0,1 ] . With arguments `size`. numpy", "question_id": 17026}
{"snippet": "numpy.quantile(a, q)", "intent": "Compute the q-th quantile of the data along the specified `axis` . Given `a` vector V of length N , the q-th quantile of V is the value `q` of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the quantile if the normalized ranking does not match the location of q exactly . numpy", "question_id": 17027}
{"snippet": "numpy.quantile(a, q, axis=None)", "intent": "Compute the q-th quantile of the data along the specified `axis` . Given `a` vector V of length N , the q-th quantile of V is the value `q` of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the quantile if the normalized ranking does not match the location of q exactly . numpy", "question_id": 17028}
{"snippet": "numpy.quantile(a, q, out=None)", "intent": "Compute the q-th quantile of the data along the specified `axis` . Given `a` vector V of length N , the q-th quantile of V is the value `q` of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the quantile if the normalized ranking does not match the location of q exactly . With arguments `out`. numpy", "question_id": 17029}
{"snippet": "numpy.quantile(a, q, overwrite_input=False)", "intent": "Compute the q-th quantile of the data along the specified `axis` . Given `a` vector V of length N , the q-th quantile of V is the value `q` of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the quantile if the normalized ranking does not match the location of q exactly . With arguments `overwrite_input`. numpy", "question_id": 17030}
{"snippet": "numpy.quantile(a, q, interpolation='linear')", "intent": "Compute the q-th quantile of the data along the specified `axis` . Given `a` vector V of length N , the q-th quantile of V is the value `q` of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the quantile if the normalized ranking does not match the location of q exactly . numpy", "question_id": 17031}
{"snippet": "numpy.quantile(a, q, keepdims=False)", "intent": "Compute the q-th quantile of the data along the specified `axis` . Given `a` vector V of length N , the q-th quantile of V is the value `q` of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the quantile if the normalized ranking does not match the location of q exactly . With arguments `keepdims`. numpy", "question_id": 17032}
{"snippet": "numpy.quantile(a, q, axis=None, out=None)", "intent": "Compute the q-th quantile of the data along the specified `axis` . Given `a` vector V of length N , the q-th quantile of V is the value `q` of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the quantile if the normalized ranking does not match the location of q exactly . With arguments `out`. numpy", "question_id": 17033}
{"snippet": "numpy.quantile(a, q, axis=None, overwrite_input=False)", "intent": "Compute the q-th quantile of the data along the specified `axis` . Given `a` vector V of length N , the q-th quantile of V is the value `q` of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the quantile if the normalized ranking does not match the location of q exactly . With arguments `overwrite_input`. numpy", "question_id": 17034}
{"snippet": "numpy.quantile(a, q, axis=None, interpolation='linear')", "intent": "Compute the q-th quantile of the data along the specified `axis` . Given `a` vector V of length N , the q-th quantile of V is the value `q` of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the quantile if the normalized ranking does not match the location of q exactly . numpy", "question_id": 17035}
{"snippet": "numpy.quantile(a, q, axis=None, keepdims=False)", "intent": "Compute the q-th quantile of the data along the specified `axis` . Given `a` vector V of length N , the q-th quantile of V is the value `q` of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the quantile if the normalized ranking does not match the location of q exactly . With arguments `keepdims`. numpy", "question_id": 17036}
{"snippet": "numpy.vander(x)", "intent": "Generate a Vandermonde matrix . With arguments `x`. numpy", "question_id": 17037}
{"snippet": "numpy.vander(x, N=None)", "intent": "Generate a Vandermonde matrix . Specifically , when increasing is False , the i-th output column is the input vector raised element-wise to the power of `N` - i - 1 . With arguments `x`. numpy", "question_id": 17038}
{"snippet": "numpy.vander(x, increasing=False)", "intent": "Generate a Vandermonde matrix . The order of the powers is determined by the `increasing` boolean argument . With arguments `x`. numpy", "question_id": 17039}
{"snippet": "numpy.vander(x, N=None, increasing=False)", "intent": "Generate a Vandermonde matrix . Specifically , when increasing is False , the i-th output column is the input vector raised element-wise to the power of `N` - i - 1 . The order of the powers is determined by the `increasing` boolean argument . With arguments `x`. numpy", "question_id": 17040}
{"snippet": "polynomial.laguerre.Laguerre.cutdeg(deg)", "intent": "Truncate series to the given degree . Reduce the degree of the series to `deg` by discarding the high order terms . numpy", "question_id": 17041}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.dist_log(*args)", "intent": "Print a console message With arguments `*args`. numpy", "question_id": 17042}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.dist_log(*args, stderr=False)", "intent": "Print a console message With arguments `*args`, `stderr`. numpy", "question_id": 17043}
{"snippet": "ma.MaskType.tofile()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 17044}
{"snippet": "ndarray.setfield(val, dtype)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field . numpy", "question_id": 17045}
{"snippet": "ndarray.setfield(val, dtype, offset=0)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field . numpy", "question_id": 17046}
{"snippet": "ndarray.itemsize", "intent": "Length of one array element in bytes. numpy", "question_id": 17047}
{"snippet": "recarray.imag", "intent": "The imaginary part of the array. numpy", "question_id": 17048}
{"snippet": "char.chararray.trace()", "intent": "Return the sum along diagonals of the array . numpy", "question_id": 17049}
{"snippet": "char.chararray.trace(offset=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`. numpy", "question_id": 17050}
{"snippet": "char.chararray.trace(axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `axis1`. numpy", "question_id": 17051}
{"snippet": "char.chararray.trace(axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `axis2`. numpy", "question_id": 17052}
{"snippet": "char.chararray.trace(dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `dtype`. numpy", "question_id": 17053}
{"snippet": "char.chararray.trace(out=None)", "intent": "Return the sum along diagonals of the array . With arguments `out`. numpy", "question_id": 17054}
{"snippet": "char.chararray.trace(offset=0, axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis1`. numpy", "question_id": 17055}
{"snippet": "char.chararray.trace(offset=0, axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis2`. numpy", "question_id": 17056}
{"snippet": "char.chararray.trace(offset=0, dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `dtype`. numpy", "question_id": 17057}
{"snippet": "char.chararray.trace(offset=0, out=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `out`. numpy", "question_id": 17058}
{"snippet": "numpy.broadcast_arrays(*args)", "intent": "Broadcast any number of arrays against each other . With arguments `*args`. numpy", "question_id": 17059}
{"snippet": "numpy.broadcast_arrays(*args, subok=False)", "intent": "Broadcast any number of arrays against each other . With arguments `*args`, `subok`. numpy", "question_id": 17060}
{"snippet": "char.chararray.title()", "intent": "For each element in self , return a titlecased version of the string : words start with uppercase characters , all remaining cased characters are lowercase . numpy", "question_id": 17061}
{"snippet": "record.ravel()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 17062}
{"snippet": "ma.outer(a, b)", "intent": "Compute the outer product of two vectors . Given two vectors , `a` = [ a0 , a1 , ... , aM ] and `b` = [ b0 , b1 , ... , bN ] , the outer product [ 1 ] is : numpy", "question_id": 17063}
{"snippet": "polynomial.polynomial.Polynomial.deriv()", "intent": "Differentiate . numpy", "question_id": 17064}
{"snippet": "polynomial.polynomial.Polynomial.deriv(m=1)", "intent": "Differentiate . With arguments `m`. numpy", "question_id": 17065}
{"snippet": "random.RandomState.gumbel()", "intent": "Draw samples from a Gumbel distribution . numpy", "question_id": 17066}
{"snippet": "random.RandomState.gumbel(loc=0.0)", "intent": "Draw samples from a Gumbel distribution . With arguments `loc`. numpy", "question_id": 17067}
{"snippet": "random.RandomState.gumbel(scale=1.0)", "intent": "Draw samples from a Gumbel distribution . Draw samples from a Gumbel distribution with specified location and `scale` . numpy", "question_id": 17068}
{"snippet": "random.RandomState.gumbel(size=None)", "intent": "Draw samples from a Gumbel distribution . With arguments `size`. numpy", "question_id": 17069}
{"snippet": "random.RandomState.gumbel(loc=0.0, scale=1.0)", "intent": "Draw samples from a Gumbel distribution . Draw samples from a Gumbel distribution with specified location and `scale` . With arguments `loc`. numpy", "question_id": 17070}
{"snippet": "random.RandomState.gumbel(loc=0.0, size=None)", "intent": "Draw samples from a Gumbel distribution . With arguments `loc`, `size`. numpy", "question_id": 17071}
{"snippet": "random.RandomState.gumbel(scale=1.0, size=None)", "intent": "Draw samples from a Gumbel distribution . Draw samples from a Gumbel distribution with specified location and `scale` . With arguments `size`. numpy", "question_id": 17072}
{"snippet": "random.RandomState.gumbel(loc=0.0, scale=1.0, size=None)", "intent": "Draw samples from a Gumbel distribution . Draw samples from a Gumbel distribution with specified location and `scale` . With arguments `loc`, `size`. numpy", "question_id": 17073}
{"snippet": "busdaycalendar.weekmask", "intent": "A copy of the seven-element boolean mask indicating valid days. numpy", "question_id": 17074}
{"snippet": "numpy.load(file)", "intent": "Load arrays or pickled objects from .npy , .npz or pickled files . With arguments `file`. numpy", "question_id": 17075}
{"snippet": "numpy.load(file, mmap_mode=None)", "intent": "Load arrays or pickled objects from .npy , .npz or pickled files . With arguments `file`, `mmap_mode`. numpy", "question_id": 17076}
{"snippet": "numpy.load(file, allow_pickle=False)", "intent": "Load arrays or pickled objects from .npy , .npz or pickled files . With arguments `file`, `allow_pickle`. numpy", "question_id": 17077}
{"snippet": "numpy.load(file, fix_imports=True)", "intent": "Load arrays or pickled objects from .npy , .npz or pickled files . With arguments `file`, `fix_imports`. numpy", "question_id": 17078}
{"snippet": "numpy.load(file, encoding='ASCII')", "intent": "Load arrays or pickled objects from .npy , .npz or pickled files . With arguments `file`, `encoding`. numpy", "question_id": 17079}
{"snippet": "numpy.load(file, mmap_mode=None, allow_pickle=False)", "intent": "Load arrays or pickled objects from .npy , .npz or pickled files . With arguments `file`, `mmap_mode`, `allow_pickle`. numpy", "question_id": 17080}
{"snippet": "numpy.load(file, mmap_mode=None, fix_imports=True)", "intent": "Load arrays or pickled objects from .npy , .npz or pickled files . With arguments `file`, `mmap_mode`, `fix_imports`. numpy", "question_id": 17081}
{"snippet": "numpy.load(file, mmap_mode=None, encoding='ASCII')", "intent": "Load arrays or pickled objects from .npy , .npz or pickled files . With arguments `file`, `mmap_mode`, `encoding`. numpy", "question_id": 17082}
{"snippet": "numpy.load(file, allow_pickle=False, fix_imports=True)", "intent": "Load arrays or pickled objects from .npy , .npz or pickled files . With arguments `file`, `allow_pickle`, `fix_imports`. numpy", "question_id": 17083}
{"snippet": "numpy.load(file, allow_pickle=False, encoding='ASCII')", "intent": "Load arrays or pickled objects from .npy , .npz or pickled files . With arguments `file`, `allow_pickle`, `encoding`. numpy", "question_id": 17084}
{"snippet": "testing.decorate_methods(cls, decorator)", "intent": "Apply a `decorator` to all methods in a class matching a regular expression . The given decorator is applied to all public methods of `cls` that are matched by the regular expression `testmatch` ( testmatch.search ( methodname ) ) . numpy", "question_id": 17085}
{"snippet": "testing.decorate_methods(cls, decorator, testmatch=None)", "intent": "Apply a `decorator` to all methods in a class matching a regular expression . The given decorator is applied to all public methods of `cls` that are matched by the regular expression `testmatch` ( testmatch.search ( methodname ) ) . numpy", "question_id": 17086}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_c_preprocessor(feature_name)", "intent": "Generate C preprocessor definitions and include headers of a CPU feature . With arguments `feature_name`. numpy", "question_id": 17087}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_c_preprocessor(feature_name, tabs=0)", "intent": "Generate C preprocessor definitions and include headers of a CPU feature . With arguments `feature_name`, `tabs`. numpy", "question_id": 17088}
{"snippet": "matlib.identity(n)", "intent": "Returns the square identity matrix of given size . With arguments `n`. numpy", "question_id": 17089}
{"snippet": "matlib.identity(n, dtype=None)", "intent": "Returns the square identity matrix of given size . With arguments `n`, `dtype`. numpy", "question_id": 17090}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.dist_info()", "intent": "Return a tuple containing info about ( platform , compiler , extra_args ) , required by the abstract class \u2018 _CCompiler \u2019 for discovering the platform environment . numpy", "question_id": 17091}
{"snippet": "memmap.copy()", "intent": "Return a copy of the array . numpy", "question_id": 17092}
{"snippet": "memmap.copy(order='C')", "intent": "Return a copy of the array . The function numpy.copy is similar , but it defaults to using `order` \u2018 K \u2019 , and will not pass sub-classes through by default . numpy", "question_id": 17093}
{"snippet": "numpy.average(a)", "intent": "Compute the weighted average along the specified `axis` . With arguments `a`. numpy", "question_id": 17094}
{"snippet": "numpy.average(a, axis=None)", "intent": "Compute the weighted average along the specified `axis` . With arguments `a`. numpy", "question_id": 17095}
{"snippet": "numpy.average(a, weights=None)", "intent": "Compute the weighted average along the specified `axis` . With arguments `a`, `weights`. numpy", "question_id": 17096}
{"snippet": "numpy.average(a, returned=False)", "intent": "Compute the weighted average along the specified `axis` . With arguments `a`, `returned`. numpy", "question_id": 17097}
{"snippet": "numpy.average(a, axis=None, weights=None)", "intent": "Compute the weighted average along the specified `axis` . With arguments `a`, `weights`. numpy", "question_id": 17098}
{"snippet": "numpy.average(a, axis=None, returned=False)", "intent": "Compute the weighted average along the specified `axis` . With arguments `a`, `returned`. numpy", "question_id": 17099}
{"snippet": "numpy.average(a, weights=None, returned=False)", "intent": "Compute the weighted average along the specified `axis` . With arguments `a`, `weights`, `returned`. numpy", "question_id": 17100}
{"snippet": "numpy.average(a, axis=None, weights=None, returned=False)", "intent": "Compute the weighted average along the specified `axis` . With arguments `a`, `weights`, `returned`. numpy", "question_id": 17101}
{"snippet": "random.noncentral_chisquare(df, nonc)", "intent": "Draw samples from a noncentral chi-square distribution . With arguments `df`, `nonc`. numpy", "question_id": 17102}
{"snippet": "random.noncentral_chisquare(df, nonc, size=None)", "intent": "Draw samples from a noncentral chi-square distribution . With arguments `df`, `nonc`, `size`. numpy", "question_id": 17103}
{"snippet": "ma.compressed(x)", "intent": "Return all the non-masked data as a 1-D array . With arguments `x`. numpy", "question_id": 17104}
{"snippet": "nditer.close()", "intent": "Resolve all writeback semantics in writeable operands . numpy", "question_id": 17105}
{"snippet": "ndarray.dot(b)", "intent": "Dot product of two arrays . With arguments `b`. numpy", "question_id": 17106}
{"snippet": "ndarray.dot(b, out=None)", "intent": "Dot product of two arrays . With arguments `b`, `out`. numpy", "question_id": 17107}
{"snippet": "ma.vander(x)", "intent": "Generate a Vandermonde matrix . With arguments `x`. numpy", "question_id": 17108}
{"snippet": "ma.vander(x, n=None)", "intent": "Generate a Vandermonde matrix . With arguments `x`, `n`. numpy", "question_id": 17109}
{"snippet": "memmap.dumps()", "intent": "Returns the pickle of the array as a string . numpy", "question_id": 17110}
{"snippet": "numpy.RankWarning", "intent": "Issued by polyfit when the Vandermonde matrix is rank deficient. numpy", "question_id": 17111}
{"snippet": "ma.masked_array.diagonal()", "intent": "Return specified diagonals . numpy", "question_id": 17112}
{"snippet": "ma.masked_array.diagonal(offset=0)", "intent": "Return specified diagonals . With arguments `offset`. numpy", "question_id": 17113}
{"snippet": "ma.masked_array.diagonal(axis1=0)", "intent": "Return specified diagonals . With arguments `axis1`. numpy", "question_id": 17114}
{"snippet": "ma.masked_array.diagonal(axis2=1)", "intent": "Return specified diagonals . With arguments `axis2`. numpy", "question_id": 17115}
{"snippet": "ma.masked_array.diagonal(offset=0, axis1=0)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`. numpy", "question_id": 17116}
{"snippet": "ma.masked_array.diagonal(offset=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis2`. numpy", "question_id": 17117}
{"snippet": "ma.masked_array.diagonal(axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `axis1`, `axis2`. numpy", "question_id": 17118}
{"snippet": "ma.masked_array.diagonal(offset=0, axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`, `axis2`. numpy", "question_id": 17119}
{"snippet": "polynomial.legendre.Legendre.has_samedomain(other)", "intent": "Check if domains match . With arguments `other`. numpy", "question_id": 17120}
{"snippet": "record.min()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 17121}
{"snippet": "generic.itemsize", "intent": "The length of one element in bytes. numpy", "question_id": 17122}
{"snippet": "numpy.polynomial.laguerre.Laguerre(coef)", "intent": "A Laguerre series class . With arguments `coef`. numpy", "question_id": 17123}
{"snippet": "numpy.polynomial.laguerre.Laguerre(coef, domain=None)", "intent": "A Laguerre series class . With arguments `coef`, `domain`. numpy", "question_id": 17124}
{"snippet": "numpy.polynomial.laguerre.Laguerre(coef, window=None)", "intent": "A Laguerre series class . With arguments `coef`, `window`. numpy", "question_id": 17125}
{"snippet": "numpy.polynomial.laguerre.Laguerre(coef, domain=None, window=None)", "intent": "A Laguerre series class . With arguments `coef`, `domain`, `window`. numpy", "question_id": 17126}
{"snippet": "memmap.partition(kth)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . numpy", "question_id": 17127}
{"snippet": "memmap.partition(kth, axis=- 1)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`. numpy", "question_id": 17128}
{"snippet": "memmap.partition(kth, kind='introselect')", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `kind`. numpy", "question_id": 17129}
{"snippet": "memmap.partition(kth, order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `order`. numpy", "question_id": 17130}
{"snippet": "memmap.partition(kth, axis=- 1, kind='introselect')", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `kind`. numpy", "question_id": 17131}
{"snippet": "memmap.partition(kth, axis=- 1, order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `order`. numpy", "question_id": 17132}
{"snippet": "memmap.partition(kth, kind='introselect', order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `kind`, `order`. numpy", "question_id": 17133}
{"snippet": "memmap.partition(kth, axis=- 1, kind='introselect', order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `kind`, `order`. numpy", "question_id": 17134}
{"snippet": "record.round()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 17135}
{"snippet": "ma.MaskedArray.sum()", "intent": "Return the sum of the array elements over the given `axis` . numpy", "question_id": 17136}
{"snippet": "ma.MaskedArray.sum(axis=None)", "intent": "Return the sum of the array elements over the given `axis` . numpy", "question_id": 17137}
{"snippet": "ma.MaskedArray.sum(dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 17138}
{"snippet": "ma.MaskedArray.sum(out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`. numpy", "question_id": 17139}
{"snippet": "ma.MaskedArray.sum(keepdims=<no value>)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`. numpy", "question_id": 17140}
{"snippet": "ma.MaskedArray.sum(axis=None, dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 17141}
{"snippet": "ma.MaskedArray.sum(axis=None, out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`. numpy", "question_id": 17142}
{"snippet": "ma.MaskedArray.sum(axis=None, keepdims=<no value>)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`. numpy", "question_id": 17143}
{"snippet": "ma.MaskedArray.sum(dtype=None, out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 17144}
{"snippet": "ma.MaskedArray.sum(dtype=None, keepdims=<no value>)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`, `keepdims`. numpy", "question_id": 17145}
{"snippet": "record.getfield()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 17146}
{"snippet": "numpy.get_printoptions()", "intent": "Return the current print options . numpy", "question_id": 17147}
{"snippet": "polynomial.chebyshev.Chebyshev.deriv()", "intent": "Differentiate . numpy", "question_id": 17148}
{"snippet": "polynomial.chebyshev.Chebyshev.deriv(m=1)", "intent": "Differentiate . With arguments `m`. numpy", "question_id": 17149}
{"snippet": "numpy.polydiv(u, v)", "intent": "Returns the quotient and remainder of polynomial division . Both `u` and `v` must be 0-d or 1-d ( ndim = 0 or 1 ) , but u.ndim need not equal v.ndim . numpy", "question_id": 17150}
{"snippet": "polynomial.legendre.leggauss(deg)", "intent": "Gauss-Legendre quadrature . These sample points and weights will correctly integrate polynomials of degree \\ ( 2 * `deg` - 1\\ ) or less over the interval \\ ( [ -1 , 1 ] \\ ) with the weight function \\ ( f ( x ) = 1\\ ) . numpy", "question_id": 17151}
{"snippet": "chararray.repeat(repeats)", "intent": "Repeat elements of an array . With arguments `repeats`. numpy", "question_id": 17152}
{"snippet": "chararray.repeat(repeats, axis=None)", "intent": "Repeat elements of an array . With arguments `repeats`, `axis`. numpy", "question_id": 17153}
{"snippet": "numpy.argpartition(a, kth)", "intent": "Perform an indirect partition along the given `axis` using the algorithm specified by the `kind` keyword . It returns an array of indices of the same shape as `a` that index data along the given axis in partitioned `order` . With arguments `kth`. numpy", "question_id": 17154}
{"snippet": "numpy.argpartition(a, kth, axis=- 1)", "intent": "Perform an indirect partition along the given `axis` using the algorithm specified by the `kind` keyword . It returns an array of indices of the same shape as `a` that index data along the given axis in partitioned `order` . With arguments `kth`. numpy", "question_id": 17155}
{"snippet": "numpy.argpartition(a, kth, kind='introselect')", "intent": "Perform an indirect partition along the given `axis` using the algorithm specified by the `kind` keyword . It returns an array of indices of the same shape as `a` that index data along the given axis in partitioned `order` . With arguments `kth`. numpy", "question_id": 17156}
{"snippet": "numpy.argpartition(a, kth, order=None)", "intent": "Perform an indirect partition along the given `axis` using the algorithm specified by the `kind` keyword . It returns an array of indices of the same shape as `a` that index data along the given axis in partitioned `order` . With arguments `kth`. numpy", "question_id": 17157}
{"snippet": "numpy.argpartition(a, kth, axis=- 1, kind='introselect')", "intent": "Perform an indirect partition along the given `axis` using the algorithm specified by the `kind` keyword . It returns an array of indices of the same shape as `a` that index data along the given axis in partitioned `order` . With arguments `kth`. numpy", "question_id": 17158}
{"snippet": "numpy.argpartition(a, kth, axis=- 1, order=None)", "intent": "Perform an indirect partition along the given `axis` using the algorithm specified by the `kind` keyword . It returns an array of indices of the same shape as `a` that index data along the given axis in partitioned `order` . With arguments `kth`. numpy", "question_id": 17159}
{"snippet": "numpy.argpartition(a, kth, kind='introselect', order=None)", "intent": "Perform an indirect partition along the given `axis` using the algorithm specified by the `kind` keyword . It returns an array of indices of the same shape as `a` that index data along the given axis in partitioned `order` . With arguments `kth`. numpy", "question_id": 17160}
{"snippet": "numpy.argpartition(a, kth, axis=- 1, kind='introselect', order=None)", "intent": "Perform an indirect partition along the given `axis` using the algorithm specified by the `kind` keyword . It returns an array of indices of the same shape as `a` that index data along the given axis in partitioned `order` . With arguments `kth`. numpy", "question_id": 17161}
{"snippet": "ma.MaskedArray.__str__()", "intent": "Return str ( self ) . numpy", "question_id": 17162}
{"snippet": "polynomial.hermite_e.HermiteE.has_samecoef(other)", "intent": "Check if coefficients match . With arguments `other`. numpy", "question_id": 17163}
{"snippet": "fft.fftn(a)", "intent": "Compute the N-dimensional discrete Fourier Transform . With arguments `a`. numpy", "question_id": 17164}
{"snippet": "fft.fftn(a, s=None)", "intent": "Compute the N-dimensional discrete Fourier Transform . With arguments `a`, `s`. numpy", "question_id": 17165}
{"snippet": "fft.fftn(a, axes=None)", "intent": "Compute the N-dimensional discrete Fourier Transform . This function computes the N-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `a`. numpy", "question_id": 17166}
{"snippet": "fft.fftn(a, norm=None)", "intent": "Compute the N-dimensional discrete Fourier Transform . With arguments `a`, `norm`. numpy", "question_id": 17167}
{"snippet": "fft.fftn(a, s=None, axes=None)", "intent": "Compute the N-dimensional discrete Fourier Transform . This function computes the N-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `a`, `s`. numpy", "question_id": 17168}
{"snippet": "fft.fftn(a, s=None, norm=None)", "intent": "Compute the N-dimensional discrete Fourier Transform . With arguments `a`, `s`, `norm`. numpy", "question_id": 17169}
{"snippet": "fft.fftn(a, axes=None, norm=None)", "intent": "Compute the N-dimensional discrete Fourier Transform . This function computes the N-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `a`, `norm`. numpy", "question_id": 17170}
{"snippet": "fft.fftn(a, s=None, axes=None, norm=None)", "intent": "Compute the N-dimensional discrete Fourier Transform . This function computes the N-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `a`, `s`, `norm`. numpy", "question_id": 17171}
{"snippet": "random.RandomState.multinomial(n, pvals)", "intent": "Draw samples from a multinomial distribution . Each sample drawn from the distribution represents `n` such experiments . With arguments `pvals`. numpy", "question_id": 17172}
{"snippet": "random.RandomState.multinomial(n, pvals, size=None)", "intent": "Draw samples from a multinomial distribution . Each sample drawn from the distribution represents `n` such experiments . With arguments `pvals`, `size`. numpy", "question_id": 17173}
{"snippet": "random.Generator.zipf(a)", "intent": "Draw samples from `a` Zipf distribution . numpy", "question_id": 17174}
{"snippet": "random.Generator.zipf(a, size=None)", "intent": "Draw samples from `a` Zipf distribution . With arguments `size`. numpy", "question_id": 17175}
{"snippet": "numpy.datetime_data(dtype, /)", "intent": "Get information about the step size of a date or time type . With arguments `dtype`, `/`. numpy", "question_id": 17176}
{"snippet": "numpy.atleast_1d(*arys)", "intent": "Convert inputs to arrays with at least one dimension . With arguments `*arys`. numpy", "question_id": 17177}
{"snippet": "char.swapcase(a)", "intent": "Return element-wise `a` copy of the string with uppercase characters converted to lowercase and vice versa . numpy", "question_id": 17178}
{"snippet": "char.chararray.itemset(*args)", "intent": "Insert scalar into an array ( scalar is cast to array \u2019 s dtype , if possible ) With arguments `*args`. numpy", "question_id": 17179}
{"snippet": "ndarray.fill(value)", "intent": "Fill the array with a scalar `value` . numpy", "question_id": 17180}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.dist_test(source, flags)", "intent": "Return True if \u2018 CCompiler.compile ( ) \u2019 able to compile a `source` file with certain `flags` . numpy", "question_id": 17181}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.dist_test(source, flags, macros=)", "intent": "Return True if \u2018 CCompiler.compile ( ) \u2019 able to compile a `source` file with certain `flags` . With arguments `macros`. numpy", "question_id": 17182}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.dist_test(source)", "intent": "Return True if \u2018 CCompiler.compile ( ) \u2019 able to compile a `source` file with certain `flags` . numpy", "question_id": 17183}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.dist_test(source, macros=)", "intent": "Return True if \u2018 CCompiler.compile ( ) \u2019 able to compile a `source` file with certain `flags` . With arguments `macros`. numpy", "question_id": 17184}
{"snippet": "polynomial.polynomial.Polynomial.has_samedomain(other)", "intent": "Check if domains match . With arguments `other`. numpy", "question_id": 17185}
{"snippet": "polynomial.hermite_e.hermeroots(c)", "intent": "Compute the roots of a HermiteE series . With arguments `c`. numpy", "question_id": 17186}
{"snippet": "chararray.rstrip()", "intent": "For each element in self , return a copy with the trailing characters removed . numpy", "question_id": 17187}
{"snippet": "chararray.rstrip(chars=None)", "intent": "For each element in self , return a copy with the trailing characters removed . With arguments `chars`. numpy", "question_id": 17188}
{"snippet": "ma.masked_less(x, value)", "intent": "Mask an array where less than a given `value` . This function is a shortcut to masked_where , with condition = ( `x` < value ) . numpy", "question_id": 17189}
{"snippet": "ma.masked_less(x, value, copy=True)", "intent": "Mask an array where less than a given `value` . This function is a shortcut to masked_where , with condition = ( `x` < value ) . With arguments `copy`. numpy", "question_id": 17190}
{"snippet": "record.setfield()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 17191}
{"snippet": "memmap.argsort()", "intent": "Returns the indices that would sort this array . numpy", "question_id": 17192}
{"snippet": "memmap.argsort(axis=- 1)", "intent": "Returns the indices that would sort this array . With arguments `axis`. numpy", "question_id": 17193}
{"snippet": "memmap.argsort(kind=None)", "intent": "Returns the indices that would sort this array . With arguments `kind`. numpy", "question_id": 17194}
{"snippet": "memmap.argsort(order=None)", "intent": "Returns the indices that would sort this array . With arguments `order`. numpy", "question_id": 17195}
{"snippet": "memmap.argsort(axis=- 1, kind=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `kind`. numpy", "question_id": 17196}
{"snippet": "memmap.argsort(axis=- 1, order=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `order`. numpy", "question_id": 17197}
{"snippet": "memmap.argsort(kind=None, order=None)", "intent": "Returns the indices that would sort this array . With arguments `kind`, `order`. numpy", "question_id": 17198}
{"snippet": "memmap.argsort(axis=- 1, kind=None, order=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `kind`, `order`. numpy", "question_id": 17199}
{"snippet": "ma.MaskedArray.byteswap()", "intent": "Swap the bytes of the array elements numpy", "question_id": 17200}
{"snippet": "ma.MaskedArray.byteswap(inplace=False)", "intent": "Swap the bytes of the array elements With arguments `inplace`. numpy", "question_id": 17201}
{"snippet": "polynomial.polynomial.Polynomial.cast(series)", "intent": "Convert `series` to series of this class . numpy", "question_id": 17202}
{"snippet": "polynomial.polynomial.Polynomial.cast(series, domain=None)", "intent": "Convert `series` to series of this class . With arguments `domain`. numpy", "question_id": 17203}
{"snippet": "polynomial.polynomial.Polynomial.cast(series, window=None)", "intent": "Convert `series` to series of this class . With arguments `window`. numpy", "question_id": 17204}
{"snippet": "polynomial.polynomial.Polynomial.cast(series, domain=None, window=None)", "intent": "Convert `series` to series of this class . With arguments `domain`, `window`. numpy", "question_id": 17205}
{"snippet": "char.rindex(a, sub)", "intent": "Like rfind , but raises ValueError when the substring `sub` is not found . With arguments `a`. numpy", "question_id": 17206}
{"snippet": "char.rindex(a, sub, start=0)", "intent": "Like rfind , but raises ValueError when the substring `sub` is not found . With arguments `a`, `start`. numpy", "question_id": 17207}
{"snippet": "char.rindex(a, sub, end=None)", "intent": "Like rfind , but raises ValueError when the substring `sub` is not found . With arguments `a`, `end`. numpy", "question_id": 17208}
{"snippet": "char.rindex(a, sub, start=0, end=None)", "intent": "Like rfind , but raises ValueError when the substring `sub` is not found . With arguments `a`, `start`, `end`. numpy", "question_id": 17209}
{"snippet": "numpy.isin(element, test_elements)", "intent": "Calculates `element` in `test_elements` , broadcasting over element only . numpy", "question_id": 17210}
{"snippet": "numpy.isin(element, test_elements, assume_unique=False)", "intent": "Calculates `element` in `test_elements` , broadcasting over element only . With arguments `assume_unique`. numpy", "question_id": 17211}
{"snippet": "numpy.isin(element, test_elements, invert=False)", "intent": "Calculates `element` in `test_elements` , broadcasting over element only . With arguments `invert`. numpy", "question_id": 17212}
{"snippet": "numpy.isin(element, test_elements, assume_unique=False, invert=False)", "intent": "Calculates `element` in `test_elements` , broadcasting over element only . With arguments `assume_unique`, `invert`. numpy", "question_id": 17213}
{"snippet": "polynomial.hermite_e.hermeweight(x)", "intent": "Weight function of the Hermite_e polynomials . With arguments `x`. numpy", "question_id": 17214}
{"snippet": "chararray.base", "intent": "Base object if memory is from some other object. numpy", "question_id": 17215}
{"snippet": "char.chararray.isalnum()", "intent": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character , false otherwise . numpy", "question_id": 17216}
{"snippet": "matrix.base", "intent": "Base object if memory is from some other object. numpy", "question_id": 17217}
{"snippet": "nditer.debug_print()", "intent": "Print the current state of the nditer instance and debug info to stdout . numpy", "question_id": 17218}
{"snippet": "chararray.argpartition(kth)", "intent": "Returns the indices that would partition this array . With arguments `kth`. numpy", "question_id": 17219}
{"snippet": "chararray.argpartition(kth, axis=- 1)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`. numpy", "question_id": 17220}
{"snippet": "chararray.argpartition(kth, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`. numpy", "question_id": 17221}
{"snippet": "chararray.argpartition(kth, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `order`. numpy", "question_id": 17222}
{"snippet": "chararray.argpartition(kth, axis=- 1, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`. numpy", "question_id": 17223}
{"snippet": "chararray.argpartition(kth, axis=- 1, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `order`. numpy", "question_id": 17224}
{"snippet": "chararray.argpartition(kth, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`, `order`. numpy", "question_id": 17225}
{"snippet": "chararray.argpartition(kth, axis=- 1, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`, `order`. numpy", "question_id": 17226}
{"snippet": "numpy.percentile(a, q)", "intent": "Compute the q-th percentile of the data along the specified `axis` . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . numpy", "question_id": 17227}
{"snippet": "numpy.percentile(a, q, axis=None)", "intent": "Compute the q-th percentile of the data along the specified `axis` . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . numpy", "question_id": 17228}
{"snippet": "numpy.percentile(a, q, out=None)", "intent": "Compute the q-th percentile of the data along the specified `axis` . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . With arguments `out`. numpy", "question_id": 17229}
{"snippet": "numpy.percentile(a, q, overwrite_input=False)", "intent": "Compute the q-th percentile of the data along the specified `axis` . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . With arguments `overwrite_input`. numpy", "question_id": 17230}
{"snippet": "numpy.percentile(a, q, interpolation='linear')", "intent": "Compute the q-th percentile of the data along the specified `axis` . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . numpy", "question_id": 17231}
{"snippet": "numpy.percentile(a, q, keepdims=False)", "intent": "Compute the q-th percentile of the data along the specified `axis` . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . With arguments `keepdims`. numpy", "question_id": 17232}
{"snippet": "numpy.percentile(a, q, axis=None, out=None)", "intent": "Compute the q-th percentile of the data along the specified `axis` . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . With arguments `out`. numpy", "question_id": 17233}
{"snippet": "numpy.percentile(a, q, axis=None, overwrite_input=False)", "intent": "Compute the q-th percentile of the data along the specified `axis` . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . With arguments `overwrite_input`. numpy", "question_id": 17234}
{"snippet": "numpy.percentile(a, q, axis=None, interpolation='linear')", "intent": "Compute the q-th percentile of the data along the specified `axis` . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . numpy", "question_id": 17235}
{"snippet": "numpy.percentile(a, q, axis=None, keepdims=False)", "intent": "Compute the q-th percentile of the data along the specified `axis` . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . With arguments `keepdims`. numpy", "question_id": 17236}
{"snippet": "numpy.flatiter", "intent": "Flat iterator object to iterate over arrays. numpy", "question_id": 17237}
{"snippet": "testing.Tester.prepare_test_args()", "intent": "Run tests for module using nose . numpy", "question_id": 17238}
{"snippet": "testing.Tester.prepare_test_args(label='fast')", "intent": "Run tests for module using nose . With arguments `label`. numpy", "question_id": 17239}
{"snippet": "testing.Tester.prepare_test_args(verbose=1)", "intent": "Run tests for module using nose . With arguments `verbose`. numpy", "question_id": 17240}
{"snippet": "testing.Tester.prepare_test_args(extra_argv=None)", "intent": "Run tests for module using nose . With arguments `extra_argv`. numpy", "question_id": 17241}
{"snippet": "testing.Tester.prepare_test_args(doctests=False)", "intent": "Run tests for module using nose . With arguments `doctests`. numpy", "question_id": 17242}
{"snippet": "testing.Tester.prepare_test_args(coverage=False)", "intent": "Run tests for module using nose . With arguments `coverage`. numpy", "question_id": 17243}
{"snippet": "testing.Tester.prepare_test_args(timer=False)", "intent": "Run tests for module using nose . With arguments `timer`. numpy", "question_id": 17244}
{"snippet": "testing.Tester.prepare_test_args(label='fast', verbose=1)", "intent": "Run tests for module using nose . With arguments `label`, `verbose`. numpy", "question_id": 17245}
{"snippet": "testing.Tester.prepare_test_args(label='fast', extra_argv=None)", "intent": "Run tests for module using nose . With arguments `label`, `extra_argv`. numpy", "question_id": 17246}
{"snippet": "testing.Tester.prepare_test_args(label='fast', doctests=False)", "intent": "Run tests for module using nose . With arguments `label`, `doctests`. numpy", "question_id": 17247}
{"snippet": "distutils.ccompiler.CCompiler_find_executables(self)", "intent": "Does nothing here , but is called by the get_version method and can be overridden by subclasses . With arguments `self`. numpy", "question_id": 17248}
{"snippet": "ma.compress_rowcols(x)", "intent": "Suppress the rows and/or columns of a 2-D array that contain masked values . With arguments `x`. numpy", "question_id": 17249}
{"snippet": "ma.compress_rowcols(x, axis=None)", "intent": "Suppress the rows and/or columns of a 2-D array that contain masked values . The suppression behavior is selected with the `axis` parameter . With arguments `x`. numpy", "question_id": 17250}
{"snippet": "ma.argsort(a)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `a`. numpy", "question_id": 17251}
{"snippet": "ma.argsort(a, axis=<no value>)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `a`. numpy", "question_id": 17252}
{"snippet": "ma.argsort(a, kind=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `a`, `kind`. numpy", "question_id": 17253}
{"snippet": "ma.argsort(a, order=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `a`, `order`. numpy", "question_id": 17254}
{"snippet": "ma.argsort(a, endwith=True)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `a`, `endwith`. numpy", "question_id": 17255}
{"snippet": "ma.argsort(a, fill_value=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . Masked values are filled beforehand to `fill_value` . With arguments `a`. numpy", "question_id": 17256}
{"snippet": "ma.argsort(a, axis=<no value>, kind=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `a`, `kind`. numpy", "question_id": 17257}
{"snippet": "ma.argsort(a, axis=<no value>, order=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `a`, `order`. numpy", "question_id": 17258}
{"snippet": "ma.argsort(a, axis=<no value>, endwith=True)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `a`, `endwith`. numpy", "question_id": 17259}
{"snippet": "ma.argsort(a, axis=<no value>, fill_value=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . Masked values are filled beforehand to `fill_value` . With arguments `a`. numpy", "question_id": 17260}
{"snippet": "char.chararray.cumprod()", "intent": "Return the cumulative product of the elements along the given `axis` . numpy", "question_id": 17261}
{"snippet": "char.chararray.cumprod(axis=None)", "intent": "Return the cumulative product of the elements along the given `axis` . numpy", "question_id": 17262}
{"snippet": "char.chararray.cumprod(dtype=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 17263}
{"snippet": "char.chararray.cumprod(out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `out`. numpy", "question_id": 17264}
{"snippet": "char.chararray.cumprod(axis=None, dtype=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 17265}
{"snippet": "char.chararray.cumprod(axis=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `out`. numpy", "question_id": 17266}
{"snippet": "char.chararray.cumprod(dtype=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 17267}
{"snippet": "char.chararray.cumprod(axis=None, dtype=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 17268}
{"snippet": "recarray.sum()", "intent": "Return the sum of the array elements over the given `axis` . numpy", "question_id": 17269}
{"snippet": "recarray.sum(axis=None)", "intent": "Return the sum of the array elements over the given `axis` . numpy", "question_id": 17270}
{"snippet": "recarray.sum(dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 17271}
{"snippet": "recarray.sum(out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`. numpy", "question_id": 17272}
{"snippet": "recarray.sum(keepdims=False)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`. numpy", "question_id": 17273}
{"snippet": "recarray.sum(initial=0)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `initial`. numpy", "question_id": 17274}
{"snippet": "recarray.sum(where=True)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `where`. numpy", "question_id": 17275}
{"snippet": "recarray.sum(axis=None, dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 17276}
{"snippet": "recarray.sum(axis=None, out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`. numpy", "question_id": 17277}
{"snippet": "recarray.sum(axis=None, keepdims=False)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`. numpy", "question_id": 17278}
{"snippet": "ma.MaskedArray.cumprod()", "intent": "Return the cumulative product of the array elements over the given `axis` . numpy", "question_id": 17279}
{"snippet": "ma.MaskedArray.cumprod(axis=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . numpy", "question_id": 17280}
{"snippet": "ma.MaskedArray.cumprod(dtype=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 17281}
{"snippet": "ma.MaskedArray.cumprod(out=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . The mask is lost if `out` is not a valid MaskedArray ! numpy", "question_id": 17282}
{"snippet": "ma.MaskedArray.cumprod(axis=None, dtype=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 17283}
{"snippet": "ma.MaskedArray.cumprod(axis=None, out=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . The mask is lost if `out` is not a valid MaskedArray ! numpy", "question_id": 17284}
{"snippet": "ma.MaskedArray.cumprod(dtype=None, out=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . The mask is lost if `out` is not a valid MaskedArray ! With arguments `dtype`. numpy", "question_id": 17285}
{"snippet": "ma.MaskedArray.cumprod(axis=None, dtype=None, out=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . The mask is lost if `out` is not a valid MaskedArray ! With arguments `dtype`. numpy", "question_id": 17286}
{"snippet": "polynomial.polynomial.polyfit(x, y, deg)", "intent": "Least-squares fit of a polynomial to data . Return the coefficients of a polynomial of degree `deg` that is the least squares fit to the data values `y` given at points `x` . numpy", "question_id": 17287}
{"snippet": "polynomial.polynomial.polyfit(x, y, deg, rcond=None)", "intent": "Least-squares fit of a polynomial to data . Return the coefficients of a polynomial of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . numpy", "question_id": 17288}
{"snippet": "polynomial.polynomial.polyfit(x, y, deg, full=False)", "intent": "Least-squares fit of a polynomial to data . Return the coefficients of a polynomial of degree `deg` that is the least squares fit to the data values `y` given at points `x` . If some of the singular values of V are so small that they are neglected ( and `full` == False ) , a RankWarning will be raised . numpy", "question_id": 17289}
{"snippet": "polynomial.polynomial.polyfit(x, y, deg, w=None)", "intent": "Least-squares fit of a polynomial to data . Return the coefficients of a polynomial of degree `deg` that is the least squares fit to the data values `y` given at points `x` . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values . numpy", "question_id": 17290}
{"snippet": "polynomial.polynomial.polyfit(x, y, deg, rcond=None, full=False)", "intent": "Least-squares fit of a polynomial to data . Return the coefficients of a polynomial of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . If some of the singular values of V are so small that they are neglected ( and `full` == False ) , a RankWarning will be raised . numpy", "question_id": 17291}
{"snippet": "polynomial.polynomial.polyfit(x, y, deg, rcond=None, w=None)", "intent": "Least-squares fit of a polynomial to data . Return the coefficients of a polynomial of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values . numpy", "question_id": 17292}
{"snippet": "polynomial.polynomial.polyfit(x, y, deg, full=False, w=None)", "intent": "Least-squares fit of a polynomial to data . Return the coefficients of a polynomial of degree `deg` that is the least squares fit to the data values `y` given at points `x` . If some of the singular values of V are so small that they are neglected ( and `full` == False ) , a RankWarning will be raised . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values . numpy", "question_id": 17293}
{"snippet": "polynomial.polynomial.polyfit(x, y, deg, rcond=None, full=False, w=None)", "intent": "Least-squares fit of a polynomial to data . Return the coefficients of a polynomial of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . If some of the singular values of V are so small that they are neglected ( and `full` == False ) , a RankWarning will be raised . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values . numpy", "question_id": 17294}
{"snippet": "char.chararray.lstrip()", "intent": "For each element in self , return a copy with the leading characters removed . numpy", "question_id": 17295}
{"snippet": "char.chararray.lstrip(chars=None)", "intent": "For each element in self , return a copy with the leading characters removed . With arguments `chars`. numpy", "question_id": 17296}
{"snippet": "numpy.lib.user_array.container(data)", "intent": "Standard container-class for easy multiple-inheritance . With arguments `data`. numpy", "question_id": 17297}
{"snippet": "numpy.lib.user_array.container(data, dtype=None)", "intent": "Standard container-class for easy multiple-inheritance . With arguments `data`, `dtype`. numpy", "question_id": 17298}
{"snippet": "numpy.lib.user_array.container(data, copy=True)", "intent": "Standard container-class for easy multiple-inheritance . With arguments `data`, `copy`. numpy", "question_id": 17299}
{"snippet": "numpy.lib.user_array.container(data, dtype=None, copy=True)", "intent": "Standard container-class for easy multiple-inheritance . With arguments `data`, `dtype`, `copy`. numpy", "question_id": 17300}
{"snippet": "numpy.tri(N)", "intent": "An array with ones at and below the given diagonal and zeros elsewhere . With arguments `N`. numpy", "question_id": 17301}
{"snippet": "numpy.tri(N, M=None)", "intent": "An array with ones at and below the given diagonal and zeros elsewhere . With arguments `N`, `M`. numpy", "question_id": 17302}
{"snippet": "numpy.tri(N, k=0)", "intent": "An array with ones at and below the given diagonal and zeros elsewhere . With arguments `N`, `k`. numpy", "question_id": 17303}
{"snippet": "numpy.tri(N, dtype=<class 'float'>)", "intent": "An array with ones at and below the given diagonal and zeros elsewhere . With arguments `N`, `dtype`. numpy", "question_id": 17304}
{"snippet": "numpy.tri(N, like=None)", "intent": "An array with ones at and below the given diagonal and zeros elsewhere . With arguments `N`, `like`. numpy", "question_id": 17305}
{"snippet": "numpy.tri(N, M=None, k=0)", "intent": "An array with ones at and below the given diagonal and zeros elsewhere . With arguments `N`, `M`, `k`. numpy", "question_id": 17306}
{"snippet": "numpy.tri(N, M=None, dtype=<class 'float'>)", "intent": "An array with ones at and below the given diagonal and zeros elsewhere . With arguments `N`, `M`, `dtype`. numpy", "question_id": 17307}
{"snippet": "numpy.tri(N, M=None, like=None)", "intent": "An array with ones at and below the given diagonal and zeros elsewhere . With arguments `N`, `M`, `like`. numpy", "question_id": 17308}
{"snippet": "numpy.tri(N, k=0, dtype=<class 'float'>)", "intent": "An array with ones at and below the given diagonal and zeros elsewhere . With arguments `N`, `k`, `dtype`. numpy", "question_id": 17309}
{"snippet": "numpy.tri(N, k=0, like=None)", "intent": "An array with ones at and below the given diagonal and zeros elsewhere . With arguments `N`, `k`, `like`. numpy", "question_id": 17310}
{"snippet": "ma.MaskedArray.__ior__(value, /)", "intent": "Return self|=value . With arguments `value`, `/`. numpy", "question_id": 17311}
{"snippet": "numpy.copy(a)", "intent": "Return an array copy of the given object . Create an array x , with `a` reference y and a copy z : numpy", "question_id": 17312}
{"snippet": "numpy.copy(a, order='K')", "intent": "Return an array copy of the given object . Create an array x , with `a` reference y and a copy z : With arguments `order`. numpy", "question_id": 17313}
{"snippet": "numpy.copy(a, subok=False)", "intent": "Return an array copy of the given object . Create an array x , with `a` reference y and a copy z : With arguments `subok`. numpy", "question_id": 17314}
{"snippet": "numpy.copy(a, order='K', subok=False)", "intent": "Return an array copy of the given object . Create an array x , with `a` reference y and a copy z : With arguments `order`, `subok`. numpy", "question_id": 17315}
{"snippet": "random.standard_normal()", "intent": "Draw samples from a standard Normal distribution ( mean=0 , stdev=1 ) . numpy", "question_id": 17316}
{"snippet": "random.standard_normal(size=None)", "intent": "Draw samples from a standard Normal distribution ( mean=0 , stdev=1 ) . With arguments `size`. numpy", "question_id": 17317}
{"snippet": "char.multiply(a, i)", "intent": "Return ( `a` * `i` ) , that is string multiple concatenation , element-wise . numpy", "question_id": 17318}
{"snippet": "ma.MaskedArray.min()", "intent": "Return the minimum along a given `axis` . numpy", "question_id": 17319}
{"snippet": "ma.MaskedArray.min(axis=None)", "intent": "Return the minimum along a given `axis` . numpy", "question_id": 17320}
{"snippet": "ma.MaskedArray.min(out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`. numpy", "question_id": 17321}
{"snippet": "ma.MaskedArray.min(fill_value=None)", "intent": "Return the minimum along a given `axis` . With arguments `fill_value`. numpy", "question_id": 17322}
{"snippet": "ma.MaskedArray.min(keepdims=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 17323}
{"snippet": "ma.MaskedArray.min(axis=None, out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`. numpy", "question_id": 17324}
{"snippet": "ma.MaskedArray.min(axis=None, fill_value=None)", "intent": "Return the minimum along a given `axis` . With arguments `fill_value`. numpy", "question_id": 17325}
{"snippet": "ma.MaskedArray.min(axis=None, keepdims=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 17326}
{"snippet": "ma.MaskedArray.min(out=None, fill_value=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`, `fill_value`. numpy", "question_id": 17327}
{"snippet": "ma.MaskedArray.min(out=None, keepdims=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `out`, `keepdims`. numpy", "question_id": 17328}
{"snippet": "polynomial.chebyshev.chebdiv(c1, c2)", "intent": "Divide one Chebyshev series by another . Returns the quotient-with-remainder of two Chebyshev series `c1` / `c2` . numpy", "question_id": 17329}
{"snippet": "nditer.remove_multi_index()", "intent": "When the \u201c multi_index \u201d flag was specified , this removes it , allowing the internal iteration structure to be optimized further . numpy", "question_id": 17330}
{"snippet": "polynomial.hermite.hermint(c)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 17331}
{"snippet": "polynomial.hermite.hermint(c, m=1)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 17332}
{"snippet": "polynomial.hermite.hermint(c, k=)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 17333}
{"snippet": "polynomial.hermite.hermint(c, lbnd=0)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 17334}
{"snippet": "polynomial.hermite.hermint(c, scl=1)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 17335}
{"snippet": "polynomial.hermite.hermint(c, axis=0)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 17336}
{"snippet": "polynomial.hermite.hermint(c, m=1, k=)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 17337}
{"snippet": "polynomial.hermite.hermint(c, m=1, lbnd=0)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 17338}
{"snippet": "polynomial.hermite.hermint(c, m=1, scl=1)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 17339}
{"snippet": "polynomial.hermite.hermint(c, m=1, axis=0)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 17340}
{"snippet": "polynomial.hermite.hermint()", "intent": "Integrate a Hermite series . numpy", "question_id": 17341}
{"snippet": "polynomial.hermite.hermint(m=1)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 17342}
{"snippet": "polynomial.hermite.hermint(k=)", "intent": "Integrate a Hermite series . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 17343}
{"snippet": "polynomial.hermite.hermint(lbnd=0)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 17344}
{"snippet": "polynomial.hermite.hermint(scl=1)", "intent": "Integrate a Hermite series . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 17345}
{"snippet": "polynomial.hermite.hermint(axis=0)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 17346}
{"snippet": "polynomial.hermite.hermint(m=1, k=)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 17347}
{"snippet": "polynomial.hermite.hermint(m=1, lbnd=0)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 17348}
{"snippet": "polynomial.hermite.hermint(m=1, scl=1)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 17349}
{"snippet": "polynomial.hermite.hermint(m=1, axis=0)", "intent": "Integrate a Hermite series . Returns the Hermite series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 17350}
{"snippet": "linalg.eigvalsh(a)", "intent": "Compute the eigenvalues of `a` complex Hermitian or real symmetric matrix . numpy", "question_id": 17351}
{"snippet": "linalg.eigvalsh(a, UPLO='L')", "intent": "Compute the eigenvalues of `a` complex Hermitian or real symmetric matrix . With arguments `UPLO`. numpy", "question_id": 17352}
{"snippet": "char.istitle(a)", "intent": "Returns true for each element if the element is `a` titlecased string and there is at least one character , false otherwise . numpy", "question_id": 17353}
{"snippet": "ma.common_fill_value(a, b)", "intent": "Return the common filling value of two masked arrays , if any . With arguments `a`, `b`. numpy", "question_id": 17354}
{"snippet": "polynomial.polynomial.polymul(c1, c2)", "intent": "Multiply one polynomial by another . Returns the product of two polynomials `c1` * `c2` . numpy", "question_id": 17355}
{"snippet": "polynomial.chebyshev.chebroots(c)", "intent": "Compute the roots of a Chebyshev series . With arguments `c`. numpy", "question_id": 17356}
{"snippet": "generic.ndim", "intent": "The number of array dimensions. numpy", "question_id": 17357}
{"snippet": "polynomial.laguerre.Laguerre.degree()", "intent": "The degree of the series . numpy", "question_id": 17358}
{"snippet": "ma.MaskedArray.strides", "intent": "Tuple of bytes to step in each dimension when traversing an array. numpy", "question_id": 17359}
{"snippet": "ma.all(self)", "intent": "Returns True if all elements evaluate to True . With arguments `self`. numpy", "question_id": 17360}
{"snippet": "ma.all(self, axis=None)", "intent": "Returns True if all elements evaluate to True . The output array is masked where all the values along the given `axis` are masked : if the output would have been a scalar and that all the values are masked , then the output is masked . With arguments `self`. numpy", "question_id": 17361}
{"snippet": "ma.all(self, out=None)", "intent": "Returns True if all elements evaluate to True . With arguments `self`, `out`. numpy", "question_id": 17362}
{"snippet": "ma.all(self, keepdims=<no value>)", "intent": "Returns True if all elements evaluate to True . With arguments `self`, `keepdims`. numpy", "question_id": 17363}
{"snippet": "ma.all(self, axis=None, out=None)", "intent": "Returns True if all elements evaluate to True . The output array is masked where all the values along the given `axis` are masked : if the output would have been a scalar and that all the values are masked , then the output is masked . With arguments `self`, `out`. numpy", "question_id": 17364}
{"snippet": "ma.all(self, axis=None, keepdims=<no value>)", "intent": "Returns True if all elements evaluate to True . The output array is masked where all the values along the given `axis` are masked : if the output would have been a scalar and that all the values are masked , then the output is masked . With arguments `self`, `keepdims`. numpy", "question_id": 17365}
{"snippet": "ma.all(self, out=None, keepdims=<no value>)", "intent": "Returns True if all elements evaluate to True . With arguments `self`, `out`, `keepdims`. numpy", "question_id": 17366}
{"snippet": "ma.all(self, axis=None, out=None, keepdims=<no value>)", "intent": "Returns True if all elements evaluate to True . The output array is masked where all the values along the given `axis` are masked : if the output would have been a scalar and that all the values are masked , then the output is masked . With arguments `self`, `out`, `keepdims`. numpy", "question_id": 17367}
{"snippet": "numpy.divide(x1, x2, /, signature, extobj)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`. numpy", "question_id": 17368}
{"snippet": "numpy.divide(x1, x2, /, signature, extobj, out=None)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `out`. numpy", "question_id": 17369}
{"snippet": "numpy.divide(x1, x2, /, signature, extobj, where=True)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `where`. numpy", "question_id": 17370}
{"snippet": "numpy.divide(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `casting`. numpy", "question_id": 17371}
{"snippet": "numpy.divide(x1, x2, /, signature, extobj, order='K')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `order`. numpy", "question_id": 17372}
{"snippet": "numpy.divide(x1, x2, /, signature, extobj, dtype=None)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `dtype`. numpy", "question_id": 17373}
{"snippet": "numpy.divide(x1, x2, /, signature, extobj, subok=True)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `subok`. numpy", "question_id": 17374}
{"snippet": "numpy.divide(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `out`, `where`. numpy", "question_id": 17375}
{"snippet": "numpy.divide(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 17376}
{"snippet": "numpy.divide(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `out`, `order`. numpy", "question_id": 17377}
{"snippet": "numpy.divide(x1, x2, /, signature)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`. numpy", "question_id": 17378}
{"snippet": "numpy.divide(x1, x2, /, signature, out=None)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `out`. numpy", "question_id": 17379}
{"snippet": "numpy.divide(x1, x2, /, signature, where=True)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `where`. numpy", "question_id": 17380}
{"snippet": "numpy.divide(x1, x2, /, signature, casting='same_kind')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `casting`. numpy", "question_id": 17381}
{"snippet": "numpy.divide(x1, x2, /, signature, order='K')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `order`. numpy", "question_id": 17382}
{"snippet": "numpy.divide(x1, x2, /, signature, dtype=None)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `dtype`. numpy", "question_id": 17383}
{"snippet": "numpy.divide(x1, x2, /, signature, subok=True)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `subok`. numpy", "question_id": 17384}
{"snippet": "numpy.divide(x1, x2, /, signature, out=None, where=True)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `out`, `where`. numpy", "question_id": 17385}
{"snippet": "numpy.divide(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `out`, `casting`. numpy", "question_id": 17386}
{"snippet": "numpy.divide(x1, x2, /, signature, out=None, order='K')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `out`, `order`. numpy", "question_id": 17387}
{"snippet": "chararray.index(sub)", "intent": "Like find , but raises ValueError when the substring is not found . With arguments `sub`. numpy", "question_id": 17388}
{"snippet": "chararray.index(sub, start=0)", "intent": "Like find , but raises ValueError when the substring is not found . With arguments `sub`, `start`. numpy", "question_id": 17389}
{"snippet": "chararray.index(sub, end=None)", "intent": "Like find , but raises ValueError when the substring is not found . With arguments `sub`, `end`. numpy", "question_id": 17390}
{"snippet": "chararray.index(sub, start=0, end=None)", "intent": "Like find , but raises ValueError when the substring is not found . With arguments `sub`, `start`, `end`. numpy", "question_id": 17391}
{"snippet": "memmap.min()", "intent": "Return the minimum along a given `axis` . numpy", "question_id": 17392}
{"snippet": "memmap.min(axis=None)", "intent": "Return the minimum along a given `axis` . numpy", "question_id": 17393}
{"snippet": "memmap.min(out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`. numpy", "question_id": 17394}
{"snippet": "memmap.min(keepdims=False)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 17395}
{"snippet": "memmap.min(initial=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `initial`. numpy", "question_id": 17396}
{"snippet": "memmap.min(where=True)", "intent": "Return the minimum along a given `axis` . With arguments `where`. numpy", "question_id": 17397}
{"snippet": "memmap.min(axis=None, out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`. numpy", "question_id": 17398}
{"snippet": "memmap.min(axis=None, keepdims=False)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 17399}
{"snippet": "memmap.min(axis=None, initial=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `initial`. numpy", "question_id": 17400}
{"snippet": "memmap.min(axis=None, where=True)", "intent": "Return the minimum along a given `axis` . With arguments `where`. numpy", "question_id": 17401}
{"snippet": "matrix.ndim", "intent": "Number of array dimensions. numpy", "question_id": 17402}
{"snippet": "random.Generator.bytes(length)", "intent": "Return random bytes . With arguments `length`. numpy", "question_id": 17403}
{"snippet": "chararray.put(indices, values)", "intent": "Set a.flat [ n ] = `values` [ n ] for all n in `indices` . numpy", "question_id": 17404}
{"snippet": "chararray.put(indices, values, mode='raise')", "intent": "Set a.flat [ n ] = `values` [ n ] for all n in `indices` . With arguments `mode`. numpy", "question_id": 17405}
{"snippet": "ndarray.__array__(dtype, /)", "intent": "Returns either a new reference to self if `dtype` is not given or a new array of provided data type if dtype is different from the current dtype of the array . With arguments `/`. numpy", "question_id": 17406}
{"snippet": "ndarray.__array__(dtype)", "intent": "Returns either a new reference to self if `dtype` is not given or a new array of provided data type if dtype is different from the current dtype of the array . numpy", "question_id": 17407}
{"snippet": "testing.assert_almost_equal(actual, desired)", "intent": "Raises an AssertionError if two items are not equal up to `desired` precision . The test verifies that the elements of `actual` and desired satisfy . numpy", "question_id": 17408}
{"snippet": "testing.assert_almost_equal(actual, desired, decimal=7)", "intent": "Raises an AssertionError if two items are not equal up to `desired` precision . The test verifies that the elements of `actual` and desired satisfy . With arguments `decimal`. numpy", "question_id": 17409}
{"snippet": "testing.assert_almost_equal(actual, desired, err_msg='')", "intent": "Raises an AssertionError if two items are not equal up to `desired` precision . The test verifies that the elements of `actual` and desired satisfy . With arguments `err_msg`. numpy", "question_id": 17410}
{"snippet": "testing.assert_almost_equal(actual, desired, verbose=True)", "intent": "Raises an AssertionError if two items are not equal up to `desired` precision . The test verifies that the elements of `actual` and desired satisfy . With arguments `verbose`. numpy", "question_id": 17411}
{"snippet": "testing.assert_almost_equal(actual, desired, decimal=7, err_msg='')", "intent": "Raises an AssertionError if two items are not equal up to `desired` precision . The test verifies that the elements of `actual` and desired satisfy . With arguments `decimal`, `err_msg`. numpy", "question_id": 17412}
{"snippet": "testing.assert_almost_equal(actual, desired, decimal=7, verbose=True)", "intent": "Raises an AssertionError if two items are not equal up to `desired` precision . The test verifies that the elements of `actual` and desired satisfy . With arguments `decimal`, `verbose`. numpy", "question_id": 17413}
{"snippet": "testing.assert_almost_equal(actual, desired, err_msg='', verbose=True)", "intent": "Raises an AssertionError if two items are not equal up to `desired` precision . The test verifies that the elements of `actual` and desired satisfy . With arguments `err_msg`, `verbose`. numpy", "question_id": 17414}
{"snippet": "testing.assert_almost_equal(actual, desired, decimal=7, err_msg='', verbose=True)", "intent": "Raises an AssertionError if two items are not equal up to `desired` precision . The test verifies that the elements of `actual` and desired satisfy . With arguments `decimal`, `err_msg`, `verbose`. numpy", "question_id": 17415}
{"snippet": "ma.MaskType.strides", "intent": "Tuple of bytes steps in each dimension. numpy", "question_id": 17416}
{"snippet": "polynomial.legendre.legdiv(c1, c2)", "intent": "Divide one Legendre series by another . Returns the quotient-with-remainder of two Legendre series `c1` / `c2` . numpy", "question_id": 17417}
{"snippet": "random.RandomState.permutation(x)", "intent": "Randomly permute a sequence , or return a permuted range . If `x` is a multi-dimensional array , it is only shuffled along its first index . numpy", "question_id": 17418}
{"snippet": "chararray.argmax()", "intent": "Return indices of the maximum values along the given `axis` . numpy", "question_id": 17419}
{"snippet": "chararray.argmax(axis=None)", "intent": "Return indices of the maximum values along the given `axis` . numpy", "question_id": 17420}
{"snippet": "chararray.argmax(out=None)", "intent": "Return indices of the maximum values along the given `axis` . With arguments `out`. numpy", "question_id": 17421}
{"snippet": "chararray.argmax(axis=None, out=None)", "intent": "Return indices of the maximum values along the given `axis` . With arguments `out`. numpy", "question_id": 17422}
{"snippet": "ndarray.__ior__(value, /)", "intent": "Return self|=value . With arguments `value`, `/`. numpy", "question_id": 17423}
{"snippet": "char.chararray.isalpha()", "intent": "Returns true for each element if all characters in the string are alphabetic and there is at least one character , false otherwise . numpy", "question_id": 17424}
{"snippet": "polynomial.hermite_e.HermiteE.cast(series)", "intent": "Convert `series` to series of this class . numpy", "question_id": 17425}
{"snippet": "polynomial.hermite_e.HermiteE.cast(series, domain=None)", "intent": "Convert `series` to series of this class . With arguments `domain`. numpy", "question_id": 17426}
{"snippet": "polynomial.hermite_e.HermiteE.cast(series, window=None)", "intent": "Convert `series` to series of this class . With arguments `window`. numpy", "question_id": 17427}
{"snippet": "polynomial.hermite_e.HermiteE.cast(series, domain=None, window=None)", "intent": "Convert `series` to series of this class . With arguments `domain`, `window`. numpy", "question_id": 17428}
{"snippet": "linalg.slogdet(a)", "intent": "Compute the sign and ( natural ) logarithm of the determinant of an array . If an array has `a` very small or very large determinant , then a call to det may overflow or underflow . numpy", "question_id": 17429}
{"snippet": "random.gumbel()", "intent": "Draw samples from a Gumbel distribution . numpy", "question_id": 17430}
{"snippet": "random.gumbel(loc=0.0)", "intent": "Draw samples from a Gumbel distribution . With arguments `loc`. numpy", "question_id": 17431}
{"snippet": "random.gumbel(scale=1.0)", "intent": "Draw samples from a Gumbel distribution . Draw samples from a Gumbel distribution with specified location and `scale` . numpy", "question_id": 17432}
{"snippet": "random.gumbel(size=None)", "intent": "Draw samples from a Gumbel distribution . With arguments `size`. numpy", "question_id": 17433}
{"snippet": "random.gumbel(loc=0.0, scale=1.0)", "intent": "Draw samples from a Gumbel distribution . Draw samples from a Gumbel distribution with specified location and `scale` . With arguments `loc`. numpy", "question_id": 17434}
{"snippet": "random.gumbel(loc=0.0, size=None)", "intent": "Draw samples from a Gumbel distribution . With arguments `loc`, `size`. numpy", "question_id": 17435}
{"snippet": "random.gumbel(scale=1.0, size=None)", "intent": "Draw samples from a Gumbel distribution . Draw samples from a Gumbel distribution with specified location and `scale` . With arguments `size`. numpy", "question_id": 17436}
{"snippet": "random.gumbel(loc=0.0, scale=1.0, size=None)", "intent": "Draw samples from a Gumbel distribution . Draw samples from a Gumbel distribution with specified location and `scale` . With arguments `loc`, `size`. numpy", "question_id": 17437}
{"snippet": "numpy.gradient(f, *varargs)", "intent": "Return the gradient of an N-dimensional array . By substituting \\ ( `f` ( x_ { i } + h_ { d } ) \\ ) and \\ ( f ( x_ { i } - h_ { s } ) \\ ) with their Taylor series expansion , this translates into solving the following the linear system : With arguments `*varargs`. numpy", "question_id": 17438}
{"snippet": "numpy.gradient(f, *varargs, axis=None)", "intent": "Return the gradient of an N-dimensional array . By substituting \\ ( `f` ( x_ { i } + h_ { d } ) \\ ) and \\ ( f ( x_ { i } - h_ { s } ) \\ ) with their Taylor series expansion , this translates into solving the following the linear system : For two dimensional arrays , the return will be two arrays ordered by `axis` . With arguments `*varargs`. numpy", "question_id": 17439}
{"snippet": "numpy.gradient(f, *varargs, edge_order=1)", "intent": "Return the gradient of an N-dimensional array . By substituting \\ ( `f` ( x_ { i } + h_ { d } ) \\ ) and \\ ( f ( x_ { i } - h_ { s } ) \\ ) with their Taylor series expansion , this translates into solving the following the linear system : It is possible to specify how boundaries are treated using `edge_order` With arguments `*varargs`. numpy", "question_id": 17440}
{"snippet": "numpy.gradient(f, *varargs, axis=None, edge_order=1)", "intent": "Return the gradient of an N-dimensional array . By substituting \\ ( `f` ( x_ { i } + h_ { d } ) \\ ) and \\ ( f ( x_ { i } - h_ { s } ) \\ ) with their Taylor series expansion , this translates into solving the following the linear system : For two dimensional arrays , the return will be two arrays ordered by `axis` . It is possible to specify how boundaries are treated using `edge_order` With arguments `*varargs`. numpy", "question_id": 17441}
{"snippet": "numpy.vectorize(pyfunc)", "intent": "Generalized function class . The vectorized function evaluates `pyfunc` over successive tuples of the input arrays like the python map function , except it uses the broadcasting rules of numpy . numpy", "question_id": 17442}
{"snippet": "numpy.vectorize(pyfunc, otypes=None)", "intent": "Generalized function class . The vectorized function evaluates `pyfunc` over successive tuples of the input arrays like the python map function , except it uses the broadcasting rules of numpy . This can be avoided by specifying the `otypes` argument . numpy", "question_id": 17443}
{"snippet": "numpy.vectorize(pyfunc, doc=None)", "intent": "Generalized function class . The vectorized function evaluates `pyfunc` over successive tuples of the input arrays like the python map function , except it uses the broadcasting rules of numpy . With arguments `doc`. numpy", "question_id": 17444}
{"snippet": "numpy.vectorize(pyfunc, excluded=None)", "intent": "Generalized function class . The vectorized function evaluates `pyfunc` over successive tuples of the input arrays like the python map function , except it uses the broadcasting rules of numpy . The new keyword argument interface and `excluded` argument support further degrades performance . numpy", "question_id": 17445}
{"snippet": "numpy.vectorize(pyfunc, cache=False)", "intent": "Generalized function class . The vectorized function evaluates `pyfunc` over successive tuples of the input arrays like the python map function , except it uses the broadcasting rules of numpy . The results of this call will be cached if `cache` is True to prevent calling the function twice . numpy", "question_id": 17446}
{"snippet": "numpy.vectorize(pyfunc, signature=None)", "intent": "Generalized function class . The vectorized function evaluates `pyfunc` over successive tuples of the input arrays like the python map function , except it uses the broadcasting rules of numpy . The `signature` argument allows for vectorizing functions that act on non-scalar arrays of fixed length . numpy", "question_id": 17447}
{"snippet": "numpy.vectorize(pyfunc, otypes=None, doc=None)", "intent": "Generalized function class . The vectorized function evaluates `pyfunc` over successive tuples of the input arrays like the python map function , except it uses the broadcasting rules of numpy . This can be avoided by specifying the `otypes` argument . With arguments `doc`. numpy", "question_id": 17448}
{"snippet": "numpy.vectorize(pyfunc, otypes=None, excluded=None)", "intent": "Generalized function class . The vectorized function evaluates `pyfunc` over successive tuples of the input arrays like the python map function , except it uses the broadcasting rules of numpy . This can be avoided by specifying the `otypes` argument . The new keyword argument interface and `excluded` argument support further degrades performance . numpy", "question_id": 17449}
{"snippet": "numpy.vectorize(pyfunc, otypes=None, cache=False)", "intent": "Generalized function class . The vectorized function evaluates `pyfunc` over successive tuples of the input arrays like the python map function , except it uses the broadcasting rules of numpy . This can be avoided by specifying the `otypes` argument . The results of this call will be cached if `cache` is True to prevent calling the function twice . numpy", "question_id": 17450}
{"snippet": "numpy.vectorize(pyfunc, otypes=None, signature=None)", "intent": "Generalized function class . The vectorized function evaluates `pyfunc` over successive tuples of the input arrays like the python map function , except it uses the broadcasting rules of numpy . This can be avoided by specifying the `otypes` argument . The `signature` argument allows for vectorizing functions that act on non-scalar arrays of fixed length . numpy", "question_id": 17451}
{"snippet": "ma.MaskedArray.std()", "intent": "Returns the standard deviation of the array elements along given `axis` . numpy", "question_id": 17452}
{"snippet": "ma.MaskedArray.std(axis=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . numpy", "question_id": 17453}
{"snippet": "ma.MaskedArray.std(dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 17454}
{"snippet": "ma.MaskedArray.std(out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 17455}
{"snippet": "ma.MaskedArray.std(ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`. numpy", "question_id": 17456}
{"snippet": "ma.MaskedArray.std(keepdims=<no value>)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `keepdims`. numpy", "question_id": 17457}
{"snippet": "ma.MaskedArray.std(axis=None, dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 17458}
{"snippet": "ma.MaskedArray.std(axis=None, out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 17459}
{"snippet": "ma.MaskedArray.std(axis=None, ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`. numpy", "question_id": 17460}
{"snippet": "ma.MaskedArray.std(axis=None, keepdims=<no value>)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `keepdims`. numpy", "question_id": 17461}
{"snippet": "chararray.sort()", "intent": "Sort an array in-place . numpy", "question_id": 17462}
{"snippet": "chararray.sort(axis=- 1)", "intent": "Sort an array in-place . With arguments `axis`. numpy", "question_id": 17463}
{"snippet": "chararray.sort(kind=None)", "intent": "Sort an array in-place . With arguments `kind`. numpy", "question_id": 17464}
{"snippet": "chararray.sort(order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : numpy", "question_id": 17465}
{"snippet": "chararray.sort(axis=- 1, kind=None)", "intent": "Sort an array in-place . With arguments `axis`, `kind`. numpy", "question_id": 17466}
{"snippet": "chararray.sort(axis=- 1, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `axis`. numpy", "question_id": 17467}
{"snippet": "chararray.sort(kind=None, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `kind`. numpy", "question_id": 17468}
{"snippet": "chararray.sort(axis=- 1, kind=None, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `axis`, `kind`. numpy", "question_id": 17469}
{"snippet": "polynomial.hermite_e.HermiteE.has_samedomain(other)", "intent": "Check if domains match . With arguments `other`. numpy", "question_id": 17470}
{"snippet": "char.chararray.rindex(sub)", "intent": "Like rfind , but raises ValueError when the substring `sub` is not found . numpy", "question_id": 17471}
{"snippet": "char.chararray.rindex(sub, start=0)", "intent": "Like rfind , but raises ValueError when the substring `sub` is not found . With arguments `start`. numpy", "question_id": 17472}
{"snippet": "char.chararray.rindex(sub, end=None)", "intent": "Like rfind , but raises ValueError when the substring `sub` is not found . With arguments `end`. numpy", "question_id": 17473}
{"snippet": "char.chararray.rindex(sub, start=0, end=None)", "intent": "Like rfind , but raises ValueError when the substring `sub` is not found . With arguments `start`, `end`. numpy", "question_id": 17474}
{"snippet": "numpy.deg2rad(x, /, signature, extobj)", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `extobj`. numpy", "question_id": 17475}
{"snippet": "numpy.deg2rad(x, /, signature, extobj, out=None)", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `extobj`, `out`. numpy", "question_id": 17476}
{"snippet": "numpy.deg2rad(x, /, signature, extobj, where=True)", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `extobj`, `where`. numpy", "question_id": 17477}
{"snippet": "numpy.deg2rad(x, /, signature, extobj, casting='same_kind')", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `extobj`, `casting`. numpy", "question_id": 17478}
{"snippet": "numpy.deg2rad(x, /, signature, extobj, order='K')", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `extobj`, `order`. numpy", "question_id": 17479}
{"snippet": "numpy.deg2rad(x, /, signature, extobj, dtype=None)", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `extobj`, `dtype`. numpy", "question_id": 17480}
{"snippet": "numpy.deg2rad(x, /, signature, extobj, subok=True)", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `extobj`, `subok`. numpy", "question_id": 17481}
{"snippet": "numpy.deg2rad(x, /, signature, extobj, out=None, where=True)", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `extobj`, `out`, `where`. numpy", "question_id": 17482}
{"snippet": "numpy.deg2rad(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 17483}
{"snippet": "numpy.deg2rad(x, /, signature, extobj, out=None, order='K')", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `extobj`, `out`, `order`. numpy", "question_id": 17484}
{"snippet": "numpy.deg2rad(x, /, signature)", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`. numpy", "question_id": 17485}
{"snippet": "numpy.deg2rad(x, /, signature, out=None)", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `out`. numpy", "question_id": 17486}
{"snippet": "numpy.deg2rad(x, /, signature, where=True)", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `where`. numpy", "question_id": 17487}
{"snippet": "numpy.deg2rad(x, /, signature, casting='same_kind')", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `casting`. numpy", "question_id": 17488}
{"snippet": "numpy.deg2rad(x, /, signature, order='K')", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `order`. numpy", "question_id": 17489}
{"snippet": "numpy.deg2rad(x, /, signature, dtype=None)", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `dtype`. numpy", "question_id": 17490}
{"snippet": "numpy.deg2rad(x, /, signature, subok=True)", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `subok`. numpy", "question_id": 17491}
{"snippet": "numpy.deg2rad(x, /, signature, out=None, where=True)", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `out`, `where`. numpy", "question_id": 17492}
{"snippet": "numpy.deg2rad(x, /, signature, out=None, casting='same_kind')", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `out`, `casting`. numpy", "question_id": 17493}
{"snippet": "numpy.deg2rad(x, /, signature, out=None, order='K')", "intent": "Convert angles from degrees to radians . deg2rad ( `x` ) is x * pi `/` 180 . With arguments `signature`, `out`, `order`. numpy", "question_id": 17494}
{"snippet": "numpy.hamming(M)", "intent": "Return the Hamming window . With arguments `M`. numpy", "question_id": 17495}
{"snippet": "recarray.T", "intent": "The transposed array. numpy", "question_id": 17496}
{"snippet": "ndarray.__ge__(value, /)", "intent": "Return self > =value . With arguments `value`, `/`. numpy", "question_id": 17497}
{"snippet": "ma.MaskedArray.__getstate__()", "intent": "Return the internal state of the masked array , for pickling purposes . numpy", "question_id": 17498}
{"snippet": "char.chararray.flatten()", "intent": "Return a copy of the array collapsed into one dimension . numpy", "question_id": 17499}
{"snippet": "char.chararray.flatten(order='C')", "intent": "Return a copy of the array collapsed into one dimension . With arguments `order`. numpy", "question_id": 17500}
{"snippet": "polynomial.legendre.legfromroots(roots)", "intent": "Generate a Legendre series with given `roots` . numpy", "question_id": 17501}
{"snippet": "ma.masked_array.squeeze()", "intent": "Remove axes of length one from a . numpy", "question_id": 17502}
{"snippet": "ma.masked_array.squeeze(axis=None)", "intent": "Remove axes of length one from a . With arguments `axis`. numpy", "question_id": 17503}
{"snippet": "numpy.format_float_positional(x)", "intent": "Format a floating-point scalar as a decimal string in positional notation . With arguments `x`. numpy", "question_id": 17504}
{"snippet": "numpy.format_float_positional(x, precision=None)", "intent": "Format a floating-point scalar as a decimal string in positional notation . With arguments `x`, `precision`. numpy", "question_id": 17505}
{"snippet": "numpy.format_float_positional(x, unique=True)", "intent": "Format a floating-point scalar as a decimal string in positional notation . With arguments `x`, `unique`. numpy", "question_id": 17506}
{"snippet": "numpy.format_float_positional(x, fractional=True)", "intent": "Format a floating-point scalar as a decimal string in positional notation . With arguments `x`, `fractional`. numpy", "question_id": 17507}
{"snippet": "numpy.format_float_positional(x, trim='k')", "intent": "Format a floating-point scalar as a decimal string in positional notation . With arguments `x`, `trim`. numpy", "question_id": 17508}
{"snippet": "numpy.format_float_positional(x, sign=False)", "intent": "Format a floating-point scalar as a decimal string in positional notation . With arguments `x`, `sign`. numpy", "question_id": 17509}
{"snippet": "numpy.format_float_positional(x, pad_left=None)", "intent": "Format a floating-point scalar as a decimal string in positional notation . With arguments `x`, `pad_left`. numpy", "question_id": 17510}
{"snippet": "numpy.format_float_positional(x, pad_right=None)", "intent": "Format a floating-point scalar as a decimal string in positional notation . With arguments `x`, `pad_right`. numpy", "question_id": 17511}
{"snippet": "numpy.format_float_positional(x, min_digits=None)", "intent": "Format a floating-point scalar as a decimal string in positional notation . With arguments `x`, `min_digits`. numpy", "question_id": 17512}
{"snippet": "numpy.format_float_positional(x, precision=None, unique=True)", "intent": "Format a floating-point scalar as a decimal string in positional notation . With arguments `x`, `precision`, `unique`. numpy", "question_id": 17513}
{"snippet": "recarray.tostring()", "intent": "A compatibility alias for tobytes , with exactly the same behavior . numpy", "question_id": 17514}
{"snippet": "recarray.tostring(order='C')", "intent": "A compatibility alias for tobytes , with exactly the same behavior . With arguments `order`. numpy", "question_id": 17515}
{"snippet": "numpy.isfortran(a)", "intent": "Check if the array is Fortran contiguous but not C contiguous . The transpose of `a` C-ordered array is a FORTRAN-ordered array . numpy", "question_id": 17516}
{"snippet": "random.Generator.poisson()", "intent": "Draw samples from a Poisson distribution . numpy", "question_id": 17517}
{"snippet": "random.Generator.poisson(lam=1.0)", "intent": "Draw samples from a Poisson distribution . Because the output is limited to the range of the C int64 type , a ValueError is raised when `lam` is within 10 sigma of the maximum representable value . numpy", "question_id": 17518}
{"snippet": "random.Generator.poisson(size=None)", "intent": "Draw samples from a Poisson distribution . With arguments `size`. numpy", "question_id": 17519}
{"snippet": "random.Generator.poisson(lam=1.0, size=None)", "intent": "Draw samples from a Poisson distribution . Because the output is limited to the range of the C int64 type , a ValueError is raised when `lam` is within 10 sigma of the maximum representable value . With arguments `size`. numpy", "question_id": 17520}
{"snippet": "ma.masked_array.prod()", "intent": "Return the product of the array elements over the given `axis` . numpy", "question_id": 17521}
{"snippet": "ma.masked_array.prod(axis=None)", "intent": "Return the product of the array elements over the given `axis` . numpy", "question_id": 17522}
{"snippet": "ma.masked_array.prod(dtype=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 17523}
{"snippet": "ma.masked_array.prod(out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `out`. numpy", "question_id": 17524}
{"snippet": "ma.masked_array.prod(keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `keepdims`. numpy", "question_id": 17525}
{"snippet": "ma.masked_array.prod(axis=None, dtype=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 17526}
{"snippet": "ma.masked_array.prod(axis=None, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `out`. numpy", "question_id": 17527}
{"snippet": "ma.masked_array.prod(axis=None, keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `keepdims`. numpy", "question_id": 17528}
{"snippet": "ma.masked_array.prod(dtype=None, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 17529}
{"snippet": "ma.masked_array.prod(dtype=None, keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`, `keepdims`. numpy", "question_id": 17530}
{"snippet": "matrix.tostring()", "intent": "A compatibility alias for tobytes , with exactly the same behavior . numpy", "question_id": 17531}
{"snippet": "matrix.tostring(order='C')", "intent": "A compatibility alias for tobytes , with exactly the same behavior . With arguments `order`. numpy", "question_id": 17532}
{"snippet": "record.put()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 17533}
{"snippet": "chararray.isdecimal()", "intent": "For each element in self , return True if there are only decimal characters in the element . numpy", "question_id": 17534}
{"snippet": "numpy.diagflat(v)", "intent": "Create a two-dimensional array with the flattened input as a diagonal . With arguments `v`. numpy", "question_id": 17535}
{"snippet": "numpy.diagflat(v, k=0)", "intent": "Create a two-dimensional array with the flattened input as a diagonal . With arguments `v`, `k`. numpy", "question_id": 17536}
{"snippet": "char.chararray.ptp()", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . numpy", "question_id": 17537}
{"snippet": "char.chararray.ptp(axis=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . numpy", "question_id": 17538}
{"snippet": "char.chararray.ptp(out=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`. numpy", "question_id": 17539}
{"snippet": "char.chararray.ptp(keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `keepdims`. numpy", "question_id": 17540}
{"snippet": "char.chararray.ptp(axis=None, out=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`. numpy", "question_id": 17541}
{"snippet": "char.chararray.ptp(axis=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `keepdims`. numpy", "question_id": 17542}
{"snippet": "char.chararray.ptp(out=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`, `keepdims`. numpy", "question_id": 17543}
{"snippet": "char.chararray.ptp(axis=None, out=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`, `keepdims`. numpy", "question_id": 17544}
{"snippet": "dtype.__reduce__()", "intent": "Helper for pickle . numpy", "question_id": 17545}
{"snippet": "numpy.arctan2(x1, x2, /, signature, extobj)", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 17546}
{"snippet": "numpy.arctan2(x1, x2, /, signature, extobj, out=None)", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 17547}
{"snippet": "numpy.arctan2(x1, x2, /, signature, extobj, where=True)", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 17548}
{"snippet": "numpy.arctan2(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 17549}
{"snippet": "numpy.arctan2(x1, x2, /, signature, extobj, order='K')", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . Note the `order` of the parameters . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 17550}
{"snippet": "numpy.arctan2(x1, x2, /, signature, extobj, dtype=None)", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 17551}
{"snippet": "numpy.arctan2(x1, x2, /, signature, extobj, subok=True)", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 17552}
{"snippet": "numpy.arctan2(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 17553}
{"snippet": "numpy.arctan2(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 17554}
{"snippet": "numpy.arctan2(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . Note the `order` of the parameters . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 17555}
{"snippet": "numpy.arctan2(x1, x2, /, signature)", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`. numpy", "question_id": 17556}
{"snippet": "numpy.arctan2(x1, x2, /, signature, out=None)", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `out`. numpy", "question_id": 17557}
{"snippet": "numpy.arctan2(x1, x2, /, signature, where=True)", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `where`. numpy", "question_id": 17558}
{"snippet": "numpy.arctan2(x1, x2, /, signature, casting='same_kind')", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `casting`. numpy", "question_id": 17559}
{"snippet": "numpy.arctan2(x1, x2, /, signature, order='K')", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . Note the `order` of the parameters . With arguments `/`, `signature`. numpy", "question_id": 17560}
{"snippet": "numpy.arctan2(x1, x2, /, signature, dtype=None)", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 17561}
{"snippet": "numpy.arctan2(x1, x2, /, signature, subok=True)", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `subok`. numpy", "question_id": 17562}
{"snippet": "numpy.arctan2(x1, x2, /, signature, out=None, where=True)", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 17563}
{"snippet": "numpy.arctan2(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 17564}
{"snippet": "numpy.arctan2(x1, x2, /, signature, out=None, order='K')", "intent": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly . The quadrant ( i.e. , branch ) is chosen so that arctan2 ( `x1` , `x2` ) is the signed angle in radians between the ray ending at the origin and passing through the point ( 1,0 ) , and the ray ending at the origin and passing through the point ( x2 , x1 ) . Note the `order` of the parameters . With arguments `/`, `signature`, `out`. numpy", "question_id": 17565}
{"snippet": "polynomial.hermite.hermval2d(x, y, c)", "intent": "Evaluate a 2-D Hermite series at points ( `x` , `y` ) . In either case , either x and y or their elements must support multiplication and addition both with themselves and with the elements of `c` . numpy", "question_id": 17566}
{"snippet": "ndarray.__matmul__(value, /)", "intent": "Return self @ `value` . With arguments `/`. numpy", "question_id": 17567}
{"snippet": "numpy.remainder(x1, x2, /, signature, extobj)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 17568}
{"snippet": "numpy.remainder(x1, x2, /, signature, extobj, out=None)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 17569}
{"snippet": "numpy.remainder(x1, x2, /, signature, extobj, where=True)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 17570}
{"snippet": "numpy.remainder(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 17571}
{"snippet": "numpy.remainder(x1, x2, /, signature, extobj, order='K')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 17572}
{"snippet": "numpy.remainder(x1, x2, /, signature, extobj, dtype=None)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 17573}
{"snippet": "numpy.remainder(x1, x2, /, signature, extobj, subok=True)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 17574}
{"snippet": "numpy.remainder(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 17575}
{"snippet": "numpy.remainder(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 17576}
{"snippet": "numpy.remainder(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 17577}
{"snippet": "numpy.remainder(x1, x2, /, signature)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`. numpy", "question_id": 17578}
{"snippet": "numpy.remainder(x1, x2, /, signature, out=None)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `out`. numpy", "question_id": 17579}
{"snippet": "numpy.remainder(x1, x2, /, signature, where=True)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `where`. numpy", "question_id": 17580}
{"snippet": "numpy.remainder(x1, x2, /, signature, casting='same_kind')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `casting`. numpy", "question_id": 17581}
{"snippet": "numpy.remainder(x1, x2, /, signature, order='K')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `order`. numpy", "question_id": 17582}
{"snippet": "numpy.remainder(x1, x2, /, signature, dtype=None)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 17583}
{"snippet": "numpy.remainder(x1, x2, /, signature, subok=True)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `subok`. numpy", "question_id": 17584}
{"snippet": "numpy.remainder(x1, x2, /, signature, out=None, where=True)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 17585}
{"snippet": "numpy.remainder(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 17586}
{"snippet": "numpy.remainder(x1, x2, /, signature, out=None, order='K')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 17587}
{"snippet": "ma.MaskedArray.__gt__(value, /)", "intent": "Return self > `value` . With arguments `/`. numpy", "question_id": 17588}
{"snippet": "polynomial.polynomial.polyvander(x, deg)", "intent": "Vandermonde matrix of given degree . Returns the Vandermonde matrix of degree `deg` and sample points `x` . numpy", "question_id": 17589}
{"snippet": "lib.format.read_magic(fp)", "intent": "Read the magic string to get the version of the file format . With arguments `fp`. numpy", "question_id": 17590}
{"snippet": "char.array(obj)", "intent": "Create a chararray . With arguments `obj`. numpy", "question_id": 17591}
{"snippet": "char.array(obj, itemsize=None)", "intent": "Create a chararray . With arguments `obj`, `itemsize`. numpy", "question_id": 17592}
{"snippet": "char.array(obj, copy=True)", "intent": "Create a chararray . With arguments `obj`, `copy`. numpy", "question_id": 17593}
{"snippet": "char.array(obj, unicode=None)", "intent": "Create a chararray . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`. numpy", "question_id": 17594}
{"snippet": "char.array(obj, order=None)", "intent": "Create a chararray . With arguments `obj`, `order`. numpy", "question_id": 17595}
{"snippet": "char.array(obj, itemsize=None, copy=True)", "intent": "Create a chararray . With arguments `obj`, `itemsize`, `copy`. numpy", "question_id": 17596}
{"snippet": "char.array(obj, itemsize=None, unicode=None)", "intent": "Create a chararray . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`, `itemsize`. numpy", "question_id": 17597}
{"snippet": "char.array(obj, itemsize=None, order=None)", "intent": "Create a chararray . With arguments `obj`, `itemsize`, `order`. numpy", "question_id": 17598}
{"snippet": "char.array(obj, copy=True, unicode=None)", "intent": "Create a chararray . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`, `copy`. numpy", "question_id": 17599}
{"snippet": "char.array(obj, copy=True, order=None)", "intent": "Create a chararray . With arguments `obj`, `copy`, `order`. numpy", "question_id": 17600}
{"snippet": "broadcast.size", "intent": "Total size of broadcasted result. numpy", "question_id": 17601}
{"snippet": "numpy.select(condlist, choicelist)", "intent": "Return an array drawn from elements in `choicelist` , depending on conditions . With arguments `condlist`. numpy", "question_id": 17602}
{"snippet": "numpy.select(condlist, choicelist, default=0)", "intent": "Return an array drawn from elements in `choicelist` , depending on conditions . With arguments `condlist`, `default`. numpy", "question_id": 17603}
{"snippet": "ndarray.sum()", "intent": "Return the sum of the array elements over the given `axis` . numpy", "question_id": 17604}
{"snippet": "ndarray.sum(axis=None)", "intent": "Return the sum of the array elements over the given `axis` . numpy", "question_id": 17605}
{"snippet": "ndarray.sum(dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 17606}
{"snippet": "ndarray.sum(out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`. numpy", "question_id": 17607}
{"snippet": "ndarray.sum(keepdims=False)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`. numpy", "question_id": 17608}
{"snippet": "ndarray.sum(initial=0)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `initial`. numpy", "question_id": 17609}
{"snippet": "ndarray.sum(where=True)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `where`. numpy", "question_id": 17610}
{"snippet": "ndarray.sum(axis=None, dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 17611}
{"snippet": "ndarray.sum(axis=None, out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`. numpy", "question_id": 17612}
{"snippet": "ndarray.sum(axis=None, keepdims=False)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`. numpy", "question_id": 17613}
{"snippet": "nditer.enable_external_loop()", "intent": "When the \u201c external_loop \u201d was not used during construction , but is desired , this modifies the iterator to behave as if the flag was specified . numpy", "question_id": 17614}
{"snippet": "char.join(sep, seq)", "intent": "Return a string which is the concatenation of the strings in the sequence `seq` . With arguments `sep`. numpy", "question_id": 17615}
{"snippet": "ma.MaskType.flatten()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 17616}
{"snippet": "ma.MaskType.setfield()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 17617}
{"snippet": "numpy.arange(start, stop, step)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . When using a non-integer `step` , such as 0.1 , the results will often not be consistent . numpy", "question_id": 17618}
{"snippet": "numpy.arange(start, stop, step, dtype=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . When using a non-integer `step` , such as 0.1 , the results will often not be consistent . With arguments `dtype`. numpy", "question_id": 17619}
{"snippet": "numpy.arange(start, stop, step, like=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . When using a non-integer `step` , such as 0.1 , the results will often not be consistent . With arguments `like`. numpy", "question_id": 17620}
{"snippet": "numpy.arange(start, stop, step, dtype=None, like=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . When using a non-integer `step` , such as 0.1 , the results will often not be consistent . With arguments `dtype`, `like`. numpy", "question_id": 17621}
{"snippet": "numpy.arange(start, stop)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . numpy", "question_id": 17622}
{"snippet": "numpy.arange(start, stop, dtype=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . With arguments `dtype`. numpy", "question_id": 17623}
{"snippet": "numpy.arange(start, stop, like=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . With arguments `like`. numpy", "question_id": 17624}
{"snippet": "numpy.arange(start, stop, dtype=None, like=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . With arguments `dtype`, `like`. numpy", "question_id": 17625}
{"snippet": "numpy.arange(start)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . numpy", "question_id": 17626}
{"snippet": "numpy.arange(start, dtype=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . With arguments `dtype`. numpy", "question_id": 17627}
{"snippet": "numpy.arange(start, like=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . With arguments `like`. numpy", "question_id": 17628}
{"snippet": "numpy.arange(start, dtype=None, like=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . With arguments `dtype`, `like`. numpy", "question_id": 17629}
{"snippet": "ma.MaskedArray.tobytes()", "intent": "Return the array data as a string containing the raw bytes in the array . numpy", "question_id": 17630}
{"snippet": "ma.MaskedArray.tobytes(fill_value=None)", "intent": "Return the array data as a string containing the raw bytes in the array . As for ndarray.tobytes , information about the shape , dtype , etc. , but also about `fill_value` , will be lost . numpy", "question_id": 17631}
{"snippet": "ma.MaskedArray.tobytes(order='C')", "intent": "Return the array data as a string containing the raw bytes in the array . With arguments `order`. numpy", "question_id": 17632}
{"snippet": "ma.MaskedArray.tobytes(fill_value=None, order='C')", "intent": "Return the array data as a string containing the raw bytes in the array . As for ndarray.tobytes , information about the shape , dtype , etc. , but also about `fill_value` , will be lost . With arguments `order`. numpy", "question_id": 17633}
{"snippet": "numpy.mean(a)", "intent": "Compute the arithmetic mean along the specified `axis` . Specifying `a` higher-precision accumulator using the `dtype` keyword can alleviate this issue . numpy", "question_id": 17634}
{"snippet": "numpy.mean(a, axis=None)", "intent": "Compute the arithmetic mean along the specified `axis` . Specifying `a` higher-precision accumulator using the `dtype` keyword can alleviate this issue . numpy", "question_id": 17635}
{"snippet": "numpy.mean(a, dtype=None)", "intent": "Compute the arithmetic mean along the specified `axis` . Specifying `a` higher-precision accumulator using the `dtype` keyword can alleviate this issue . numpy", "question_id": 17636}
{"snippet": "numpy.mean(a, out=None)", "intent": "Compute the arithmetic mean along the specified `axis` . Specifying `a` higher-precision accumulator using the `dtype` keyword can alleviate this issue . With arguments `out`. numpy", "question_id": 17637}
{"snippet": "numpy.mean(a, keepdims=<no value>)", "intent": "Compute the arithmetic mean along the specified `axis` . Specifying `a` higher-precision accumulator using the `dtype` keyword can alleviate this issue . With arguments `keepdims`. numpy", "question_id": 17638}
{"snippet": "numpy.mean(a, where=<no value>)", "intent": "Compute the arithmetic mean along the specified `axis` . Specifying `a` higher-precision accumulator using the `dtype` keyword can alleviate this issue . Specifying a `where` argument : > > > a = np.array ( [ [ 5 , 9 , 13 ] , [ 14 , 10 , 12 ] , [ 11 , 15 , 19 ] ] ) > > > np.mean ( a ) 12.0 > > > np.mean ( a , where= [ [ True ] , [ False ] , [ False ] ] ) 9.0 numpy", "question_id": 17639}
{"snippet": "numpy.mean(a, axis=None, dtype=None)", "intent": "Compute the arithmetic mean along the specified `axis` . Specifying `a` higher-precision accumulator using the `dtype` keyword can alleviate this issue . numpy", "question_id": 17640}
{"snippet": "numpy.mean(a, axis=None, out=None)", "intent": "Compute the arithmetic mean along the specified `axis` . Specifying `a` higher-precision accumulator using the `dtype` keyword can alleviate this issue . With arguments `out`. numpy", "question_id": 17641}
{"snippet": "numpy.mean(a, axis=None, keepdims=<no value>)", "intent": "Compute the arithmetic mean along the specified `axis` . Specifying `a` higher-precision accumulator using the `dtype` keyword can alleviate this issue . With arguments `keepdims`. numpy", "question_id": 17642}
{"snippet": "numpy.mean(a, axis=None, where=<no value>)", "intent": "Compute the arithmetic mean along the specified `axis` . Specifying `a` higher-precision accumulator using the `dtype` keyword can alleviate this issue . Specifying a `where` argument : > > > a = np.array ( [ [ 5 , 9 , 13 ] , [ 14 , 10 , 12 ] , [ 11 , 15 , 19 ] ] ) > > > np.mean ( a ) 12.0 > > > np.mean ( a , where= [ [ True ] , [ False ] , [ False ] ] ) 9.0 numpy", "question_id": 17643}
{"snippet": "ndarray.take(indices)", "intent": "Return an array formed from the elements of a at the given `indices` . numpy", "question_id": 17644}
{"snippet": "ndarray.take(indices, axis=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`. numpy", "question_id": 17645}
{"snippet": "ndarray.take(indices, out=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `out`. numpy", "question_id": 17646}
{"snippet": "ndarray.take(indices, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `mode`. numpy", "question_id": 17647}
{"snippet": "ndarray.take(indices, axis=None, out=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `out`. numpy", "question_id": 17648}
{"snippet": "ndarray.take(indices, axis=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `mode`. numpy", "question_id": 17649}
{"snippet": "ndarray.take(indices, out=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `out`, `mode`. numpy", "question_id": 17650}
{"snippet": "ndarray.take(indices, axis=None, out=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `out`, `mode`. numpy", "question_id": 17651}
{"snippet": "ma.identity(n)", "intent": "Return the identity array . With arguments `n`. numpy", "question_id": 17652}
{"snippet": "ma.identity(n, dtype=None)", "intent": "Return the identity array . With arguments `n`, `dtype`. numpy", "question_id": 17653}
{"snippet": "chararray.choose(choices)", "intent": "Use an index array to construct a new array from a set of `choices` . numpy", "question_id": 17654}
{"snippet": "chararray.choose(choices, out=None)", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`. numpy", "question_id": 17655}
{"snippet": "chararray.choose(choices, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `mode`. numpy", "question_id": 17656}
{"snippet": "chararray.choose(choices, out=None, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`, `mode`. numpy", "question_id": 17657}
{"snippet": "distutils.exec_command.filepath_from_subprocess_output(output)", "intent": "Convert bytes in the encoding used by a subprocess into a filesystem-appropriate str . With arguments `output`. numpy", "question_id": 17658}
{"snippet": "ma.MaskedArray.__new__(cls)", "intent": "Create a new masked array from scratch . With arguments `cls`. numpy", "question_id": 17659}
{"snippet": "ma.MaskedArray.__new__(cls, data=None)", "intent": "Create a new masked array from scratch . With arguments `cls`, `data`. numpy", "question_id": 17660}
{"snippet": "ma.MaskedArray.__new__(cls, mask=False)", "intent": "Create a new masked array from scratch . With arguments `cls`, `mask`. numpy", "question_id": 17661}
{"snippet": "ma.MaskedArray.__new__(cls, dtype=None)", "intent": "Create a new masked array from scratch . With arguments `cls`, `dtype`. numpy", "question_id": 17662}
{"snippet": "ma.MaskedArray.__new__(cls, copy=False)", "intent": "Create a new masked array from scratch . With arguments `cls`, `copy`. numpy", "question_id": 17663}
{"snippet": "ma.MaskedArray.__new__(cls, subok=True)", "intent": "Create a new masked array from scratch . With arguments `cls`, `subok`. numpy", "question_id": 17664}
{"snippet": "ma.MaskedArray.__new__(cls, ndmin=0)", "intent": "Create a new masked array from scratch . With arguments `cls`, `ndmin`. numpy", "question_id": 17665}
{"snippet": "ma.MaskedArray.__new__(cls, fill_value=None)", "intent": "Create a new masked array from scratch . With arguments `cls`, `fill_value`. numpy", "question_id": 17666}
{"snippet": "ma.MaskedArray.__new__(cls, keep_mask=True)", "intent": "Create a new masked array from scratch . With arguments `cls`, `keep_mask`. numpy", "question_id": 17667}
{"snippet": "ma.MaskedArray.__new__(cls, hard_mask=None)", "intent": "Create a new masked array from scratch . With arguments `cls`, `hard_mask`. numpy", "question_id": 17668}
{"snippet": "ma.masked_array.conjugate()", "intent": "Return the complex conjugate , element-wise . numpy", "question_id": 17669}
{"snippet": "testing.assert_warns(warning_class, *args, **kwargs)", "intent": "Fail unless the given callable throws the specified warning . A warning of class `warning_class` should be thrown by the callable when invoked with arguments args and keyword arguments kwargs . With arguments `*args`, `**kwargs`. numpy", "question_id": 17670}
{"snippet": "recarray.repeat(repeats)", "intent": "Repeat elements of an array . With arguments `repeats`. numpy", "question_id": 17671}
{"snippet": "recarray.repeat(repeats, axis=None)", "intent": "Repeat elements of an array . With arguments `repeats`, `axis`. numpy", "question_id": 17672}
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, extobj)", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 17673}
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, extobj, out=None)", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 17674}
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, extobj, where=True)", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 17675}
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 17676}
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, extobj, order='K')", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 17677}
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, extobj, dtype=None)", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 17678}
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, extobj, subok=True)", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 17679}
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 17680}
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 17681}
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 17682}
{"snippet": "numpy.logaddexp2(x1, x2, /, signature)", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`. numpy", "question_id": 17683}
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, out=None)", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `out`. numpy", "question_id": 17684}
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, where=True)", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `where`. numpy", "question_id": 17685}
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, casting='same_kind')", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `casting`. numpy", "question_id": 17686}
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, order='K')", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `order`. numpy", "question_id": 17687}
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, dtype=None)", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 17688}
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, subok=True)", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `subok`. numpy", "question_id": 17689}
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, out=None, where=True)", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 17690}
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 17691}
{"snippet": "numpy.logaddexp2(x1, x2, /, signature, out=None, order='K')", "intent": "Logarithm of the sum of exponentiations of the inputs in base-2 . Calculates log2 ( 2 * * `x1` + 2 * * `x2` ) . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 17692}
{"snippet": "chararray.data", "intent": "Python buffer object pointing to the start of the array\u2019s data. numpy", "question_id": 17693}
{"snippet": "numpy.positive(x, /, signature, extobj)", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `extobj`. numpy", "question_id": 17694}
{"snippet": "numpy.positive(x, /, signature, extobj, out=None)", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 17695}
{"snippet": "numpy.positive(x, /, signature, extobj, where=True)", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `where`. numpy", "question_id": 17696}
{"snippet": "numpy.positive(x, /, signature, extobj, casting='same_kind')", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 17697}
{"snippet": "numpy.positive(x, /, signature, extobj, order='K')", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 17698}
{"snippet": "numpy.positive(x, /, signature, extobj, dtype=None)", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 17699}
{"snippet": "numpy.positive(x, /, signature, extobj, subok=True)", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 17700}
{"snippet": "numpy.positive(x, /, signature, extobj, out=None, where=True)", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 17701}
{"snippet": "numpy.positive(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 17702}
{"snippet": "numpy.positive(x, /, signature, extobj, out=None, order='K')", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 17703}
{"snippet": "numpy.positive(x, /, signature)", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`. numpy", "question_id": 17704}
{"snippet": "numpy.positive(x, /, signature, out=None)", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `out`. numpy", "question_id": 17705}
{"snippet": "numpy.positive(x, /, signature, where=True)", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `where`. numpy", "question_id": 17706}
{"snippet": "numpy.positive(x, /, signature, casting='same_kind')", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `casting`. numpy", "question_id": 17707}
{"snippet": "numpy.positive(x, /, signature, order='K')", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `order`. numpy", "question_id": 17708}
{"snippet": "numpy.positive(x, /, signature, dtype=None)", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `dtype`. numpy", "question_id": 17709}
{"snippet": "numpy.positive(x, /, signature, subok=True)", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `subok`. numpy", "question_id": 17710}
{"snippet": "numpy.positive(x, /, signature, out=None, where=True)", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `out`, `where`. numpy", "question_id": 17711}
{"snippet": "numpy.positive(x, /, signature, out=None, casting='same_kind')", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `out`, `casting`. numpy", "question_id": 17712}
{"snippet": "numpy.positive(x, /, signature, out=None, order='K')", "intent": "Numerical positive , element-wise . With arguments `x`, `/`, `signature`, `out`, `order`. numpy", "question_id": 17713}
{"snippet": "chararray.imag", "intent": "The imaginary part of the array. numpy", "question_id": 17714}
{"snippet": "polynomial.laguerre.Laguerre.trim()", "intent": "Remove trailing coefficients numpy", "question_id": 17715}
{"snippet": "polynomial.laguerre.Laguerre.trim(tol=0)", "intent": "Remove trailing coefficients Remove trailing coefficients until a coefficient is reached whose absolute value greater than `tol` or the beginning of the series is reached . numpy", "question_id": 17716}
{"snippet": "memmap.size", "intent": "Number of elements in the array. numpy", "question_id": 17717}
{"snippet": "ma.masked_array.setflags()", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . numpy", "question_id": 17718}
{"snippet": "ma.masked_array.setflags(write=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`. numpy", "question_id": 17719}
{"snippet": "ma.masked_array.setflags(align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`. numpy", "question_id": 17720}
{"snippet": "ma.masked_array.setflags(uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `uic`. numpy", "question_id": 17721}
{"snippet": "ma.masked_array.setflags(write=None, align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`. numpy", "question_id": 17722}
{"snippet": "ma.masked_array.setflags(write=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `uic`. numpy", "question_id": 17723}
{"snippet": "ma.masked_array.setflags(align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`, `uic`. numpy", "question_id": 17724}
{"snippet": "ma.masked_array.setflags(write=None, align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`, `uic`. numpy", "question_id": 17725}
{"snippet": "chararray.rindex(sub)", "intent": "Like rfind , but raises ValueError when the substring `sub` is not found . numpy", "question_id": 17726}
{"snippet": "chararray.rindex(sub, start=0)", "intent": "Like rfind , but raises ValueError when the substring `sub` is not found . With arguments `start`. numpy", "question_id": 17727}
{"snippet": "chararray.rindex(sub, end=None)", "intent": "Like rfind , but raises ValueError when the substring `sub` is not found . With arguments `end`. numpy", "question_id": 17728}
{"snippet": "chararray.rindex(sub, start=0, end=None)", "intent": "Like rfind , but raises ValueError when the substring `sub` is not found . With arguments `start`, `end`. numpy", "question_id": 17729}
{"snippet": "ndarray.__repr__(/)", "intent": "Return repr ( self ) . With arguments `/`. numpy", "question_id": 17730}
{"snippet": "ma.MaskedArray.ptp()", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . numpy", "question_id": 17731}
{"snippet": "ma.MaskedArray.ptp(axis=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `axis`. numpy", "question_id": 17732}
{"snippet": "ma.MaskedArray.ptp(out=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `out`. numpy", "question_id": 17733}
{"snippet": "ma.MaskedArray.ptp(fill_value=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `fill_value`. numpy", "question_id": 17734}
{"snippet": "ma.MaskedArray.ptp(keepdims=False)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `keepdims`. numpy", "question_id": 17735}
{"snippet": "ma.MaskedArray.ptp(axis=None, out=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `axis`, `out`. numpy", "question_id": 17736}
{"snippet": "ma.MaskedArray.ptp(axis=None, fill_value=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `axis`, `fill_value`. numpy", "question_id": 17737}
{"snippet": "ma.MaskedArray.ptp(axis=None, keepdims=False)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `axis`, `keepdims`. numpy", "question_id": 17738}
{"snippet": "ma.MaskedArray.ptp(out=None, fill_value=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `out`, `fill_value`. numpy", "question_id": 17739}
{"snippet": "ma.MaskedArray.ptp(out=None, keepdims=False)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `out`, `keepdims`. numpy", "question_id": 17740}
{"snippet": "polynomial.polyutils.RankWarning", "intent": "Issued by chebfit when the design matrix is rank deficient. numpy", "question_id": 17741}
{"snippet": "random.random_integers(low)", "intent": "Random integers of type np.int_ between `low` and `high` , inclusive . numpy", "question_id": 17742}
{"snippet": "random.random_integers(low, high=None)", "intent": "Random integers of type np.int_ between `low` and `high` , inclusive . numpy", "question_id": 17743}
{"snippet": "random.random_integers(low, size=None)", "intent": "Random integers of type np.int_ between `low` and `high` , inclusive . With arguments `size`. numpy", "question_id": 17744}
{"snippet": "random.random_integers(low, high=None, size=None)", "intent": "Random integers of type np.int_ between `low` and `high` , inclusive . With arguments `size`. numpy", "question_id": 17745}
{"snippet": "matrix.sort()", "intent": "Sort an array in-place . numpy", "question_id": 17746}
{"snippet": "matrix.sort(axis=- 1)", "intent": "Sort an array in-place . With arguments `axis`. numpy", "question_id": 17747}
{"snippet": "matrix.sort(kind=None)", "intent": "Sort an array in-place . With arguments `kind`. numpy", "question_id": 17748}
{"snippet": "matrix.sort(order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : numpy", "question_id": 17749}
{"snippet": "matrix.sort(axis=- 1, kind=None)", "intent": "Sort an array in-place . With arguments `axis`, `kind`. numpy", "question_id": 17750}
{"snippet": "matrix.sort(axis=- 1, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `axis`. numpy", "question_id": 17751}
{"snippet": "matrix.sort(kind=None, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `kind`. numpy", "question_id": 17752}
{"snippet": "matrix.sort(axis=- 1, kind=None, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `axis`, `kind`. numpy", "question_id": 17753}
{"snippet": "ma.MaskType.put()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 17754}
{"snippet": "recarray.base", "intent": "Base object if memory is from some other object. numpy", "question_id": 17755}
{"snippet": "numpy.full_like(a, fill_value)", "intent": "Return `a` full array with the same `shape` and type as a given array . With arguments `fill_value`. numpy", "question_id": 17756}
{"snippet": "numpy.full_like(a, fill_value, dtype=None)", "intent": "Return `a` full array with the same `shape` and type as a given array . With arguments `fill_value`, `dtype`. numpy", "question_id": 17757}
{"snippet": "numpy.full_like(a, fill_value, order='K')", "intent": "Return `a` full array with the same `shape` and type as a given array . With arguments `fill_value`, `order`. numpy", "question_id": 17758}
{"snippet": "numpy.full_like(a, fill_value, subok=True)", "intent": "Return `a` full array with the same `shape` and type as a given array . With arguments `fill_value`, `subok`. numpy", "question_id": 17759}
{"snippet": "numpy.full_like(a, fill_value, shape=None)", "intent": "Return `a` full array with the same `shape` and type as a given array . With arguments `fill_value`. numpy", "question_id": 17760}
{"snippet": "numpy.full_like(a, fill_value, dtype=None, order='K')", "intent": "Return `a` full array with the same `shape` and type as a given array . With arguments `fill_value`, `dtype`, `order`. numpy", "question_id": 17761}
{"snippet": "numpy.full_like(a, fill_value, dtype=None, subok=True)", "intent": "Return `a` full array with the same `shape` and type as a given array . With arguments `fill_value`, `dtype`, `subok`. numpy", "question_id": 17762}
{"snippet": "numpy.full_like(a, fill_value, dtype=None, shape=None)", "intent": "Return `a` full array with the same `shape` and type as a given array . With arguments `fill_value`, `dtype`. numpy", "question_id": 17763}
{"snippet": "numpy.full_like(a, fill_value, order='K', subok=True)", "intent": "Return `a` full array with the same `shape` and type as a given array . With arguments `fill_value`, `order`, `subok`. numpy", "question_id": 17764}
{"snippet": "numpy.full_like(a, fill_value, order='K', shape=None)", "intent": "Return `a` full array with the same `shape` and type as a given array . With arguments `fill_value`, `order`. numpy", "question_id": 17765}
{"snippet": "polynomial.hermite.Hermite.__call__(arg)", "intent": "Call self as a function . With arguments `arg`. numpy", "question_id": 17766}
{"snippet": "generic.data", "intent": "Pointer to start of data. numpy", "question_id": 17767}
{"snippet": "char.isdigit(a)", "intent": "Returns true for each element if all characters in the string are digits and there is at least one character , false otherwise . With arguments `a`. numpy", "question_id": 17768}
{"snippet": "polynomial.polynomial.polyval(x, c)", "intent": "Evaluate a polynomial at points `x` . If `c` is of length n + 1 , this function returns the value numpy", "question_id": 17769}
{"snippet": "polynomial.polynomial.polyval(x, c, tensor=True)", "intent": "Evaluate a polynomial at points `x` . If `c` is of length n + 1 , this function returns the value If c is multidimensional , then the shape of the result depends on the value of `tensor` . numpy", "question_id": 17770}
{"snippet": "char.chararray.real", "intent": "The real part of the array. numpy", "question_id": 17771}
{"snippet": "ma.masked_array.trace()", "intent": "Return the sum along diagonals of the array . numpy", "question_id": 17772}
{"snippet": "ma.masked_array.trace(offset=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`. numpy", "question_id": 17773}
{"snippet": "ma.masked_array.trace(axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `axis1`. numpy", "question_id": 17774}
{"snippet": "ma.masked_array.trace(axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `axis2`. numpy", "question_id": 17775}
{"snippet": "ma.masked_array.trace(dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `dtype`. numpy", "question_id": 17776}
{"snippet": "ma.masked_array.trace(out=None)", "intent": "Return the sum along diagonals of the array . With arguments `out`. numpy", "question_id": 17777}
{"snippet": "ma.masked_array.trace(offset=0, axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis1`. numpy", "question_id": 17778}
{"snippet": "ma.masked_array.trace(offset=0, axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis2`. numpy", "question_id": 17779}
{"snippet": "ma.masked_array.trace(offset=0, dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `dtype`. numpy", "question_id": 17780}
{"snippet": "ma.masked_array.trace(offset=0, out=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `out`. numpy", "question_id": 17781}
{"snippet": "ma.masked_array.dot(b)", "intent": "Masked dot product of two arrays . With arguments `b`. numpy", "question_id": 17782}
{"snippet": "ma.masked_array.dot(b, out=None)", "intent": "Masked dot product of two arrays . Note that `out` and strict are located in different positions than in ma.dot . With arguments `b`. numpy", "question_id": 17783}
{"snippet": "numpy.geterr()", "intent": "Get the current way of handling floating-point errors . numpy", "question_id": 17784}
{"snippet": "random.Generator.normal()", "intent": "Draw random samples from a normal ( Gaussian ) distribution . numpy", "question_id": 17785}
{"snippet": "random.Generator.normal(loc=0.0)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `loc`. numpy", "question_id": 17786}
{"snippet": "random.Generator.normal(scale=1.0)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `scale`. numpy", "question_id": 17787}
{"snippet": "random.Generator.normal(size=None)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `size`. numpy", "question_id": 17788}
{"snippet": "random.Generator.normal(loc=0.0, scale=1.0)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `loc`, `scale`. numpy", "question_id": 17789}
{"snippet": "random.Generator.normal(loc=0.0, size=None)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `loc`, `size`. numpy", "question_id": 17790}
{"snippet": "random.Generator.normal(scale=1.0, size=None)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `scale`, `size`. numpy", "question_id": 17791}
{"snippet": "random.Generator.normal(loc=0.0, scale=1.0, size=None)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `loc`, `scale`, `size`. numpy", "question_id": 17792}
{"snippet": "recarray.view(dtype, type)", "intent": "New view of array with the same data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) Viewing array data using a different `type` and dtype : numpy", "question_id": 17793}
{"snippet": "recarray.view(dtype)", "intent": "New view of array with the same data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) numpy", "question_id": 17794}
{"snippet": "recarray.view()", "intent": "New view of array with the same data . numpy", "question_id": 17795}
{"snippet": "numpy.nextafter(x1, x2, /, signature, extobj)", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 17796}
{"snippet": "numpy.nextafter(x1, x2, /, signature, extobj, out=None)", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 17797}
{"snippet": "numpy.nextafter(x1, x2, /, signature, extobj, where=True)", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 17798}
{"snippet": "numpy.nextafter(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 17799}
{"snippet": "numpy.nextafter(x1, x2, /, signature, extobj, order='K')", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 17800}
{"snippet": "numpy.nextafter(x1, x2, /, signature, extobj, dtype=None)", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 17801}
{"snippet": "numpy.nextafter(x1, x2, /, signature, extobj, subok=True)", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 17802}
{"snippet": "numpy.nextafter(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 17803}
{"snippet": "numpy.nextafter(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 17804}
{"snippet": "numpy.nextafter(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 17805}
{"snippet": "numpy.nextafter(x1, x2, /, signature)", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`. numpy", "question_id": 17806}
{"snippet": "numpy.nextafter(x1, x2, /, signature, out=None)", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `out`. numpy", "question_id": 17807}
{"snippet": "numpy.nextafter(x1, x2, /, signature, where=True)", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `where`. numpy", "question_id": 17808}
{"snippet": "numpy.nextafter(x1, x2, /, signature, casting='same_kind')", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `casting`. numpy", "question_id": 17809}
{"snippet": "numpy.nextafter(x1, x2, /, signature, order='K')", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `order`. numpy", "question_id": 17810}
{"snippet": "numpy.nextafter(x1, x2, /, signature, dtype=None)", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 17811}
{"snippet": "numpy.nextafter(x1, x2, /, signature, subok=True)", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `subok`. numpy", "question_id": 17812}
{"snippet": "numpy.nextafter(x1, x2, /, signature, out=None, where=True)", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 17813}
{"snippet": "numpy.nextafter(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 17814}
{"snippet": "numpy.nextafter(x1, x2, /, signature, out=None, order='K')", "intent": "Return the next floating-point value after `x1` towards `x2` , element-wise . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 17815}
{"snippet": "numpy.invert(x, /, signature, extobj)", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `extobj`. numpy", "question_id": 17816}
{"snippet": "numpy.invert(x, /, signature, extobj, out=None)", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 17817}
{"snippet": "numpy.invert(x, /, signature, extobj, where=True)", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `where`. numpy", "question_id": 17818}
{"snippet": "numpy.invert(x, /, signature, extobj, casting='same_kind')", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 17819}
{"snippet": "numpy.invert(x, /, signature, extobj, order='K')", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 17820}
{"snippet": "numpy.invert(x, /, signature, extobj, dtype=None)", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 17821}
{"snippet": "numpy.invert(x, /, signature, extobj, subok=True)", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 17822}
{"snippet": "numpy.invert(x, /, signature, extobj, out=None, where=True)", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 17823}
{"snippet": "numpy.invert(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 17824}
{"snippet": "numpy.invert(x, /, signature, extobj, out=None, order='K')", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 17825}
{"snippet": "numpy.invert(x, /, signature)", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`. numpy", "question_id": 17826}
{"snippet": "numpy.invert(x, /, signature, out=None)", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `out`. numpy", "question_id": 17827}
{"snippet": "numpy.invert(x, /, signature, where=True)", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `where`. numpy", "question_id": 17828}
{"snippet": "numpy.invert(x, /, signature, casting='same_kind')", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `casting`. numpy", "question_id": 17829}
{"snippet": "numpy.invert(x, /, signature, order='K')", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `order`. numpy", "question_id": 17830}
{"snippet": "numpy.invert(x, /, signature, dtype=None)", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `dtype`. numpy", "question_id": 17831}
{"snippet": "numpy.invert(x, /, signature, subok=True)", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `subok`. numpy", "question_id": 17832}
{"snippet": "numpy.invert(x, /, signature, out=None, where=True)", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `out`, `where`. numpy", "question_id": 17833}
{"snippet": "numpy.invert(x, /, signature, out=None, casting='same_kind')", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `out`, `casting`. numpy", "question_id": 17834}
{"snippet": "numpy.invert(x, /, signature, out=None, order='K')", "intent": "Compute bit-wise inversion , or bit-wise NOT , element-wise . With arguments `x`, `/`, `signature`, `out`, `order`. numpy", "question_id": 17835}
{"snippet": "ma.masked_array.byteswap()", "intent": "Swap the bytes of the array elements numpy", "question_id": 17836}
{"snippet": "ma.masked_array.byteswap(inplace=False)", "intent": "Swap the bytes of the array elements With arguments `inplace`. numpy", "question_id": 17837}
{"snippet": "polynomial.chebyshev.chebadd(c1, c2)", "intent": "Add one Chebyshev series to another . Returns the sum of two Chebyshev series `c1` + `c2` . numpy", "question_id": 17838}
{"snippet": "numpy.packbits(a)", "intent": "Packs the elements of `a` binary-valued array into bits in a uint8 array . numpy", "question_id": 17839}
{"snippet": "numpy.packbits(a, axis=None)", "intent": "Packs the elements of `a` binary-valued array into bits in a uint8 array . With arguments `axis`. numpy", "question_id": 17840}
{"snippet": "numpy.packbits(a, bitorder='big')", "intent": "Packs the elements of `a` binary-valued array into bits in a uint8 array . With arguments `bitorder`. numpy", "question_id": 17841}
{"snippet": "numpy.packbits(a, axis=None, bitorder='big')", "intent": "Packs the elements of `a` binary-valued array into bits in a uint8 array . With arguments `axis`, `bitorder`. numpy", "question_id": 17842}
{"snippet": "record.setflags()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 17843}
{"snippet": "polynomial.chebyshev.chebgrid3d(x, y, z, c)", "intent": "Evaluate a 3-D Chebyshev series on the Cartesian product of `x` , `y` , and `z` . where the points ( a , b , `c` ) consist of all triples formed by taking a from x , b from y , and c from z . numpy", "question_id": 17844}
{"snippet": "matrix.flatten()", "intent": "Return a flattened copy of the matrix . numpy", "question_id": 17845}
{"snippet": "matrix.flatten(order='C')", "intent": "Return a flattened copy of the matrix . With arguments `order`. numpy", "question_id": 17846}
{"snippet": "random.RandomState.randint(low)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . numpy", "question_id": 17847}
{"snippet": "random.RandomState.randint(low, high=None)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . numpy", "question_id": 17848}
{"snippet": "random.RandomState.randint(low, size=None)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . With arguments `size`. numpy", "question_id": 17849}
{"snippet": "random.RandomState.randint(low, dtype=int)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . Return random integers from the \u201c discrete uniform \u201d distribution of the specified `dtype` in the \u201c half-open \u201d interval [ low , high ) . numpy", "question_id": 17850}
{"snippet": "random.RandomState.randint(low, high=None, size=None)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . With arguments `size`. numpy", "question_id": 17851}
{"snippet": "random.RandomState.randint(low, high=None, dtype=int)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . Return random integers from the \u201c discrete uniform \u201d distribution of the specified `dtype` in the \u201c half-open \u201d interval [ low , high ) . numpy", "question_id": 17852}
{"snippet": "random.RandomState.randint(low, size=None, dtype=int)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . Return random integers from the \u201c discrete uniform \u201d distribution of the specified `dtype` in the \u201c half-open \u201d interval [ low , high ) . With arguments `size`. numpy", "question_id": 17853}
{"snippet": "random.RandomState.randint(low, high=None, size=None, dtype=int)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) . Return random integers from the \u201c discrete uniform \u201d distribution of the specified `dtype` in the \u201c half-open \u201d interval [ low , high ) . With arguments `size`. numpy", "question_id": 17854}
{"snippet": "recarray.round()", "intent": "Return a with each element rounded to the given number of `decimals` . numpy", "question_id": 17855}
{"snippet": "recarray.round(decimals=0)", "intent": "Return a with each element rounded to the given number of `decimals` . numpy", "question_id": 17856}
{"snippet": "recarray.round(out=None)", "intent": "Return a with each element rounded to the given number of `decimals` . With arguments `out`. numpy", "question_id": 17857}
{"snippet": "recarray.round(decimals=0, out=None)", "intent": "Return a with each element rounded to the given number of `decimals` . With arguments `out`. numpy", "question_id": 17858}
{"snippet": "numpy.place(arr, mask, vals)", "intent": "Change elements of an array based on conditional and input values . Similar to np.copyto ( `arr` , `vals` , where=mask ) , the difference is that place uses the first N elements of vals , where N is the number of True values in `mask` , while copyto uses the elements where mask is True . numpy", "question_id": 17859}
{"snippet": "numpy.geterrobj()", "intent": "Return the current object that defines floating-point error handling . numpy", "question_id": 17860}
{"snippet": "dtype.itemsize", "intent": "The element size of this data-type object. numpy", "question_id": 17861}
{"snippet": "char.rsplit(a)", "intent": "For each element in `a` , return a list of the words in the string , using `sep` as the delimiter string . numpy", "question_id": 17862}
{"snippet": "char.rsplit(a, sep=None)", "intent": "For each element in `a` , return a list of the words in the string , using `sep` as the delimiter string . numpy", "question_id": 17863}
{"snippet": "char.rsplit(a, maxsplit=None)", "intent": "For each element in `a` , return a list of the words in the string , using `sep` as the delimiter string . With arguments `maxsplit`. numpy", "question_id": 17864}
{"snippet": "char.rsplit(a, sep=None, maxsplit=None)", "intent": "For each element in `a` , return a list of the words in the string , using `sep` as the delimiter string . With arguments `maxsplit`. numpy", "question_id": 17865}
{"snippet": "random.multinomial(n, pvals)", "intent": "Draw samples from a multinomial distribution . Each sample drawn from the distribution represents `n` such experiments . With arguments `pvals`. numpy", "question_id": 17866}
{"snippet": "random.multinomial(n, pvals, size=None)", "intent": "Draw samples from a multinomial distribution . Each sample drawn from the distribution represents `n` such experiments . With arguments `pvals`, `size`. numpy", "question_id": 17867}
{"snippet": "char.chararray.upper()", "intent": "Return an array with the elements of self converted to uppercase . numpy", "question_id": 17868}
{"snippet": "ma.MaskedArray.__rtruediv__(other)", "intent": "Divide self into `other` , and return a new masked array . numpy", "question_id": 17869}
{"snippet": "numpy.round_(a)", "intent": "Round an array to the given number of `decimals` . With arguments `a`. numpy", "question_id": 17870}
{"snippet": "numpy.round_(a, decimals=0)", "intent": "Round an array to the given number of `decimals` . With arguments `a`. numpy", "question_id": 17871}
{"snippet": "numpy.round_(a, out=None)", "intent": "Round an array to the given number of `decimals` . With arguments `a`, `out`. numpy", "question_id": 17872}
{"snippet": "numpy.round_(a, decimals=0, out=None)", "intent": "Round an array to the given number of `decimals` . With arguments `a`, `out`. numpy", "question_id": 17873}
{"snippet": "ma.MaskedArray.unshare_mask()", "intent": "Copy the mask and set the sharedmask flag to False . numpy", "question_id": 17874}
{"snippet": "char.upper(a)", "intent": "Return an array with the elements converted to uppercase . With arguments `a`. numpy", "question_id": 17875}
{"snippet": "random.ranf()", "intent": "This is an alias of random_sample . numpy", "question_id": 17876}
{"snippet": "ndarray.imag", "intent": "The imaginary part of the array. numpy", "question_id": 17877}
{"snippet": "numpy.concatenate((a1, a2, ...))", "intent": "Join a sequence of arrays along an existing `axis` . With arguments `(a1`, `a2`, `...)`. numpy", "question_id": 17878}
{"snippet": "numpy.concatenate((a1, a2, ...), axis=0)", "intent": "Join a sequence of arrays along an existing `axis` . With arguments `(a1`, `a2`, `...)`. numpy", "question_id": 17879}
{"snippet": "numpy.concatenate((a1, a2, ...), out=None)", "intent": "Join a sequence of arrays along an existing `axis` . With arguments `(a1`, `a2`, `...)`, `out`. numpy", "question_id": 17880}
{"snippet": "numpy.concatenate((a1, a2, ...), dtype=None)", "intent": "Join a sequence of arrays along an existing `axis` . With arguments `(a1`, `a2`, `...)`, `dtype`. numpy", "question_id": 17881}
{"snippet": "numpy.concatenate((a1, a2, ...), casting=\"same_kind\")", "intent": "Join a sequence of arrays along an existing `axis` . With arguments `(a1`, `a2`, `...)`, `casting`. numpy", "question_id": 17882}
{"snippet": "numpy.concatenate((a1, a2, ...), axis=0, out=None)", "intent": "Join a sequence of arrays along an existing `axis` . With arguments `(a1`, `a2`, `...)`, `out`. numpy", "question_id": 17883}
{"snippet": "numpy.concatenate((a1, a2, ...), axis=0, dtype=None)", "intent": "Join a sequence of arrays along an existing `axis` . With arguments `(a1`, `a2`, `...)`, `dtype`. numpy", "question_id": 17884}
{"snippet": "numpy.concatenate((a1, a2, ...), axis=0, casting=\"same_kind\")", "intent": "Join a sequence of arrays along an existing `axis` . With arguments `(a1`, `a2`, `...)`, `casting`. numpy", "question_id": 17885}
{"snippet": "numpy.concatenate((a1, a2, ...), out=None, dtype=None)", "intent": "Join a sequence of arrays along an existing `axis` . With arguments `(a1`, `a2`, `...)`, `out`, `dtype`. numpy", "question_id": 17886}
{"snippet": "numpy.concatenate((a1, a2, ...), out=None, casting=\"same_kind\")", "intent": "Join a sequence of arrays along an existing `axis` . With arguments `(a1`, `a2`, `...)`, `out`, `casting`. numpy", "question_id": 17887}
{"snippet": "numpy.tril(m)", "intent": "Lower triangle of an array . With arguments `m`. numpy", "question_id": 17888}
{"snippet": "numpy.tril(m, k=0)", "intent": "Lower triangle of an array . With arguments `m`, `k`. numpy", "question_id": 17889}
{"snippet": "polynomial.polynomial.polypow(c, pow)", "intent": "Raise a polynomial to a power . Returns the polynomial `c` raised to the power `pow` . numpy", "question_id": 17890}
{"snippet": "polynomial.polynomial.polypow(c, pow, maxpower=None)", "intent": "Raise a polynomial to a power . Returns the polynomial `c` raised to the power `pow` . With arguments `maxpower`. numpy", "question_id": 17891}
{"snippet": "matrix.flags", "intent": "Information about the memory layout of the array. numpy", "question_id": 17892}
{"snippet": "char.chararray.dumps()", "intent": "Returns the pickle of the array as a string . numpy", "question_id": 17893}
{"snippet": "char.chararray.tofile(fid)", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . numpy", "question_id": 17894}
{"snippet": "char.chararray.tofile(fid, sep='')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `sep`. numpy", "question_id": 17895}
{"snippet": "char.chararray.tofile(fid, format='%s')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `format`. numpy", "question_id": 17896}
{"snippet": "char.chararray.tofile(fid, sep='', format='%s')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `sep`, `format`. numpy", "question_id": 17897}
{"snippet": "ndarray.setflags()", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . numpy", "question_id": 17898}
{"snippet": "ndarray.setflags(write=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`. numpy", "question_id": 17899}
{"snippet": "ndarray.setflags(align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`. numpy", "question_id": 17900}
{"snippet": "ndarray.setflags(uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `uic`. numpy", "question_id": 17901}
{"snippet": "ndarray.setflags(write=None, align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`. numpy", "question_id": 17902}
{"snippet": "ndarray.setflags(write=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `uic`. numpy", "question_id": 17903}
{"snippet": "ndarray.setflags(align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`, `uic`. numpy", "question_id": 17904}
{"snippet": "ndarray.setflags(write=None, align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`, `uic`. numpy", "question_id": 17905}
{"snippet": "linalg.lstsq(a, b)", "intent": "Return the least-squares solution to `a` linear matrix equation . Computes the vector x that approximatively solves the equation a @ x = `b` . numpy", "question_id": 17906}
{"snippet": "linalg.lstsq(a, b, rcond='warn')", "intent": "Return the least-squares solution to `a` linear matrix equation . Computes the vector x that approximatively solves the equation a @ x = `b` . With arguments `rcond`. numpy", "question_id": 17907}
{"snippet": "matrix.reshape(shape)", "intent": "Returns an array containing the same data with a new `shape` . numpy", "question_id": 17908}
{"snippet": "matrix.reshape(shape, order='C')", "intent": "Returns an array containing the same data with a new `shape` . With arguments `order`. numpy", "question_id": 17909}
{"snippet": "polynomial.legendre.Legendre.has_samewindow(other)", "intent": "Check if windows match . With arguments `other`. numpy", "question_id": 17910}
{"snippet": "ndarray.byteswap()", "intent": "Swap the bytes of the array elements numpy", "question_id": 17911}
{"snippet": "ndarray.byteswap(inplace=False)", "intent": "Swap the bytes of the array elements With arguments `inplace`. numpy", "question_id": 17912}
{"snippet": "numpy.maximum(x1, x2, /, signature, extobj)", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 17913}
{"snippet": "numpy.maximum(x1, x2, /, signature, extobj, out=None)", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 17914}
{"snippet": "numpy.maximum(x1, x2, /, signature, extobj, where=True)", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 17915}
{"snippet": "numpy.maximum(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 17916}
{"snippet": "numpy.maximum(x1, x2, /, signature, extobj, order='K')", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 17917}
{"snippet": "numpy.maximum(x1, x2, /, signature, extobj, dtype=None)", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 17918}
{"snippet": "numpy.maximum(x1, x2, /, signature, extobj, subok=True)", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 17919}
{"snippet": "numpy.maximum(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 17920}
{"snippet": "numpy.maximum(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 17921}
{"snippet": "numpy.maximum(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 17922}
{"snippet": "numpy.maximum(x1, x2, /, signature)", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`. numpy", "question_id": 17923}
{"snippet": "numpy.maximum(x1, x2, /, signature, out=None)", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`. numpy", "question_id": 17924}
{"snippet": "numpy.maximum(x1, x2, /, signature, where=True)", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `where`. numpy", "question_id": 17925}
{"snippet": "numpy.maximum(x1, x2, /, signature, casting='same_kind')", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `casting`. numpy", "question_id": 17926}
{"snippet": "numpy.maximum(x1, x2, /, signature, order='K')", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `order`. numpy", "question_id": 17927}
{"snippet": "numpy.maximum(x1, x2, /, signature, dtype=None)", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 17928}
{"snippet": "numpy.maximum(x1, x2, /, signature, subok=True)", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `subok`. numpy", "question_id": 17929}
{"snippet": "numpy.maximum(x1, x2, /, signature, out=None, where=True)", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 17930}
{"snippet": "numpy.maximum(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 17931}
{"snippet": "numpy.maximum(x1, x2, /, signature, out=None, order='K')", "intent": "Element-wise maximum of array elements . The maximum is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are nans , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 17932}
{"snippet": "ma.notmasked_contiguous(a)", "intent": "Find contiguous unmasked data in `a` masked array along the given `axis` . numpy", "question_id": 17933}
{"snippet": "ma.notmasked_contiguous(a, axis=None)", "intent": "Find contiguous unmasked data in `a` masked array along the given `axis` . numpy", "question_id": 17934}
{"snippet": "ma.masked_array.partition(kth)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . numpy", "question_id": 17935}
{"snippet": "ma.masked_array.partition(kth, axis=- 1)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`. numpy", "question_id": 17936}
{"snippet": "ma.masked_array.partition(kth, kind='introselect')", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `kind`. numpy", "question_id": 17937}
{"snippet": "ma.masked_array.partition(kth, order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `order`. numpy", "question_id": 17938}
{"snippet": "ma.masked_array.partition(kth, axis=- 1, kind='introselect')", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `kind`. numpy", "question_id": 17939}
{"snippet": "ma.masked_array.partition(kth, axis=- 1, order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `order`. numpy", "question_id": 17940}
{"snippet": "ma.masked_array.partition(kth, kind='introselect', order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `kind`, `order`. numpy", "question_id": 17941}
{"snippet": "ma.masked_array.partition(kth, axis=- 1, kind='introselect', order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `kind`, `order`. numpy", "question_id": 17942}
{"snippet": "ma.dstack(*args, **kwargs)", "intent": "Stack arrays in sequence depth wise ( along third axis ) . With arguments `*args`, `**kwargs`. numpy", "question_id": 17943}
{"snippet": "ma.MaskType.transpose()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 17944}
{"snippet": "memmap.compress(condition)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`. numpy", "question_id": 17945}
{"snippet": "memmap.compress(condition, axis=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`. numpy", "question_id": 17946}
{"snippet": "memmap.compress(condition, out=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`, `out`. numpy", "question_id": 17947}
{"snippet": "memmap.compress(condition, axis=None, out=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`, `out`. numpy", "question_id": 17948}
{"snippet": "numpy.mask_indices(n, mask_func)", "intent": "Return the indices to access ( `n` , n ) arrays , given a masking function . Assume `mask_func` is a function that , for a square array a of size ( n , n ) with a possible offset argument `k` , when called as mask_func ( a , k ) returns a new array with zeros in certain locations ( functions like triu or tril do precisely this ) . numpy", "question_id": 17949}
{"snippet": "numpy.mask_indices(n, mask_func, k=0)", "intent": "Return the indices to access ( `n` , n ) arrays , given a masking function . Assume `mask_func` is a function that , for a square array a of size ( n , n ) with a possible offset argument `k` , when called as mask_func ( a , k ) returns a new array with zeros in certain locations ( functions like triu or tril do precisely this ) . numpy", "question_id": 17950}
{"snippet": "char.lower(a)", "intent": "Return an array with the elements converted to lowercase . With arguments `a`. numpy", "question_id": 17951}
{"snippet": "random.standard_exponential()", "intent": "Draw samples from the standard exponential distribution . numpy", "question_id": 17952}
{"snippet": "random.standard_exponential(size=None)", "intent": "Draw samples from the standard exponential distribution . With arguments `size`. numpy", "question_id": 17953}
{"snippet": "numpy.nested_iters()", "intent": "Create nditers for use in nested loops numpy", "question_id": 17954}
{"snippet": "ma.MaskedArray.tolist()", "intent": "Return the data portion of the masked array as a hierarchical Python list . numpy", "question_id": 17955}
{"snippet": "ma.MaskedArray.tolist(fill_value=None)", "intent": "Return the data portion of the masked array as a hierarchical Python list . Masked values are converted to `fill_value` . numpy", "question_id": 17956}
{"snippet": "numpy.take_along_axis(arr, indices, axis)", "intent": "Take values from the input array by matching 1d index and data slices . Functions returning an index along an axis , like argsort and argpartition , produce suitable `indices` for this function . This iterates over matching 1d slices oriented along the specified `axis` in the index and data arrays , and uses the former to look up values in the latter . With arguments `arr`. numpy", "question_id": 17957}
{"snippet": "ma.MaskedArray.__rshift__(value, /)", "intent": "Return self > > `value` . With arguments `/`. numpy", "question_id": 17958}
{"snippet": "char.chararray.argpartition(kth)", "intent": "Returns the indices that would partition this array . With arguments `kth`. numpy", "question_id": 17959}
{"snippet": "char.chararray.argpartition(kth, axis=- 1)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`. numpy", "question_id": 17960}
{"snippet": "char.chararray.argpartition(kth, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`. numpy", "question_id": 17961}
{"snippet": "char.chararray.argpartition(kth, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `order`. numpy", "question_id": 17962}
{"snippet": "char.chararray.argpartition(kth, axis=- 1, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`. numpy", "question_id": 17963}
{"snippet": "char.chararray.argpartition(kth, axis=- 1, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `order`. numpy", "question_id": 17964}
{"snippet": "char.chararray.argpartition(kth, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`, `order`. numpy", "question_id": 17965}
{"snippet": "char.chararray.argpartition(kth, axis=- 1, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`, `order`. numpy", "question_id": 17966}
{"snippet": "polynomial.polynomial.Polynomial.copy()", "intent": "Return a copy . numpy", "question_id": 17967}
{"snippet": "polynomial.laguerre.Laguerre.has_samecoef(other)", "intent": "Check if coefficients match . With arguments `other`. numpy", "question_id": 17968}
{"snippet": "ma.default_fill_value(obj)", "intent": "Return the default fill value for the argument object . With arguments `obj`. numpy", "question_id": 17969}
{"snippet": "numpy.intersect1d(ar1, ar2)", "intent": "Find the intersection of two arrays . With arguments `ar1`, `ar2`. numpy", "question_id": 17970}
{"snippet": "numpy.intersect1d(ar1, ar2, assume_unique=False)", "intent": "Find the intersection of two arrays . With arguments `ar1`, `ar2`, `assume_unique`. numpy", "question_id": 17971}
{"snippet": "numpy.intersect1d(ar1, ar2, return_indices=False)", "intent": "Find the intersection of two arrays . With arguments `ar1`, `ar2`, `return_indices`. numpy", "question_id": 17972}
{"snippet": "numpy.intersect1d(ar1, ar2, assume_unique=False, return_indices=False)", "intent": "Find the intersection of two arrays . With arguments `ar1`, `ar2`, `assume_unique`, `return_indices`. numpy", "question_id": 17973}
{"snippet": "polynomial.polynomial.polydiv(c1, c2)", "intent": "Divide one polynomial by another . Returns the quotient-with-remainder of two polynomials `c1` / `c2` . numpy", "question_id": 17974}
{"snippet": "numpy.diag_indices_from(arr)", "intent": "Return the indices to access the main diagonal of an n-dimensional array . With arguments `arr`. numpy", "question_id": 17975}
{"snippet": "numpy.polyval(p, x)", "intent": "Evaluate a polynomial at specific values . If `p` is of length N , this function returns the value : If `x` is a sequence , then p ( x ) is returned for each element of x . numpy", "question_id": 17976}
{"snippet": "ma.MaskedArray.clip(**kwargs)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 17977}
{"snippet": "ma.MaskedArray.clip(**kwargs, min=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 17978}
{"snippet": "ma.MaskedArray.clip(**kwargs, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 17979}
{"snippet": "ma.MaskedArray.clip(**kwargs, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 17980}
{"snippet": "ma.MaskedArray.clip(**kwargs, min=None, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 17981}
{"snippet": "ma.MaskedArray.clip(**kwargs, min=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 17982}
{"snippet": "ma.MaskedArray.clip(**kwargs, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 17983}
{"snippet": "ma.MaskedArray.clip(**kwargs, min=None, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 17984}
{"snippet": "broadcast.index", "intent": "current index in broadcasted result numpy", "question_id": 17985}
{"snippet": "chararray.capitalize()", "intent": "Return a copy of self with only the first character of each element capitalized . numpy", "question_id": 17986}
{"snippet": "ma.dot(a, b)", "intent": "Return the dot product of two arrays . With arguments `a`, `b`. numpy", "question_id": 17987}
{"snippet": "ma.dot(a, b, strict=False)", "intent": "Return the dot product of two arrays . Note that `strict` and `out` are in different position than in the method version . With arguments `a`, `b`. numpy", "question_id": 17988}
{"snippet": "ma.dot(a, b, out=None)", "intent": "Return the dot product of two arrays . Note that `strict` and `out` are in different position than in the method version . With arguments `a`, `b`. numpy", "question_id": 17989}
{"snippet": "ma.dot(a, b, strict=False, out=None)", "intent": "Return the dot product of two arrays . Note that `strict` and `out` are in different position than in the method version . With arguments `a`, `b`. numpy", "question_id": 17990}
{"snippet": "ndarray.std()", "intent": "Returns the standard deviation of the array elements along given `axis` . numpy", "question_id": 17991}
{"snippet": "ndarray.std(axis=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . numpy", "question_id": 17992}
{"snippet": "ndarray.std(dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 17993}
{"snippet": "ndarray.std(out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 17994}
{"snippet": "ndarray.std(ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`. numpy", "question_id": 17995}
{"snippet": "ndarray.std(keepdims=False)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `keepdims`. numpy", "question_id": 17996}
{"snippet": "ndarray.std(where=True)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `where`. numpy", "question_id": 17997}
{"snippet": "ndarray.std(axis=None, dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 17998}
{"snippet": "ndarray.std(axis=None, out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 17999}
{"snippet": "ndarray.std(axis=None, ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`. numpy", "question_id": 18000}
{"snippet": "recarray.searchsorted(v)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . numpy", "question_id": 18001}
{"snippet": "recarray.searchsorted(v, side='left')", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`. numpy", "question_id": 18002}
{"snippet": "recarray.searchsorted(v, sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `sorter`. numpy", "question_id": 18003}
{"snippet": "recarray.searchsorted(v, side='left', sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`, `sorter`. numpy", "question_id": 18004}
{"snippet": "matrix.mean()", "intent": "Returns the average of the matrix elements along the given `axis` . numpy", "question_id": 18005}
{"snippet": "matrix.mean(axis=None)", "intent": "Returns the average of the matrix elements along the given `axis` . numpy", "question_id": 18006}
{"snippet": "matrix.mean(dtype=None)", "intent": "Returns the average of the matrix elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 18007}
{"snippet": "matrix.mean(out=None)", "intent": "Returns the average of the matrix elements along the given `axis` . With arguments `out`. numpy", "question_id": 18008}
{"snippet": "matrix.mean(axis=None, dtype=None)", "intent": "Returns the average of the matrix elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 18009}
{"snippet": "matrix.mean(axis=None, out=None)", "intent": "Returns the average of the matrix elements along the given `axis` . With arguments `out`. numpy", "question_id": 18010}
{"snippet": "matrix.mean(dtype=None, out=None)", "intent": "Returns the average of the matrix elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 18011}
{"snippet": "matrix.mean(axis=None, dtype=None, out=None)", "intent": "Returns the average of the matrix elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 18012}
{"snippet": "memmap.std()", "intent": "Returns the standard deviation of the array elements along given `axis` . numpy", "question_id": 18013}
{"snippet": "memmap.std(axis=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . numpy", "question_id": 18014}
{"snippet": "memmap.std(dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 18015}
{"snippet": "memmap.std(out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 18016}
{"snippet": "memmap.std(ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`. numpy", "question_id": 18017}
{"snippet": "memmap.std(keepdims=False)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `keepdims`. numpy", "question_id": 18018}
{"snippet": "memmap.std(where=True)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `where`. numpy", "question_id": 18019}
{"snippet": "memmap.std(axis=None, dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 18020}
{"snippet": "memmap.std(axis=None, out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 18021}
{"snippet": "memmap.std(axis=None, ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`. numpy", "question_id": 18022}
{"snippet": "ndarray.data", "intent": "Python buffer object pointing to the start of the array\u2019s data. numpy", "question_id": 18023}
{"snippet": "polynomial.legendre.Legendre.mapparms()", "intent": "Return the mapping parameters . numpy", "question_id": 18024}
{"snippet": "generic.__array_wrap__()", "intent": "sc.__array_wrap__ ( obj ) return scalar from array numpy", "question_id": 18025}
{"snippet": "testing.assert_equal(actual, desired)", "intent": "Raises an AssertionError if two objects are not equal . When one of `actual` and `desired` is a scalar and the other is array_like , the function checks that each element of the array_like object is equal to the scalar . numpy", "question_id": 18026}
{"snippet": "testing.assert_equal(actual, desired, err_msg='')", "intent": "Raises an AssertionError if two objects are not equal . When one of `actual` and `desired` is a scalar and the other is array_like , the function checks that each element of the array_like object is equal to the scalar . With arguments `err_msg`. numpy", "question_id": 18027}
{"snippet": "testing.assert_equal(actual, desired, verbose=True)", "intent": "Raises an AssertionError if two objects are not equal . When one of `actual` and `desired` is a scalar and the other is array_like , the function checks that each element of the array_like object is equal to the scalar . With arguments `verbose`. numpy", "question_id": 18028}
{"snippet": "testing.assert_equal(actual, desired, err_msg='', verbose=True)", "intent": "Raises an AssertionError if two objects are not equal . When one of `actual` and `desired` is a scalar and the other is array_like , the function checks that each element of the array_like object is equal to the scalar . With arguments `err_msg`, `verbose`. numpy", "question_id": 18029}
{"snippet": "matrix.any()", "intent": "Test whether any array element along a given `axis` evaluates to True . numpy", "question_id": 18030}
{"snippet": "matrix.any(axis=None)", "intent": "Test whether any array element along a given `axis` evaluates to True . numpy", "question_id": 18031}
{"snippet": "matrix.any(out=None)", "intent": "Test whether any array element along a given `axis` evaluates to True . With arguments `out`. numpy", "question_id": 18032}
{"snippet": "matrix.any(axis=None, out=None)", "intent": "Test whether any array element along a given `axis` evaluates to True . With arguments `out`. numpy", "question_id": 18033}
{"snippet": "numpy.nanvar(a)", "intent": "Compute the variance along the specified `axis` , while ignoring NaNs . Returns the variance of the array elements , `a` measure of the spread of a distribution . numpy", "question_id": 18034}
{"snippet": "numpy.nanvar(a, axis=None)", "intent": "Compute the variance along the specified `axis` , while ignoring NaNs . Returns the variance of the array elements , `a` measure of the spread of a distribution . numpy", "question_id": 18035}
{"snippet": "numpy.nanvar(a, dtype=None)", "intent": "Compute the variance along the specified `axis` , while ignoring NaNs . Returns the variance of the array elements , `a` measure of the spread of a distribution . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue . numpy", "question_id": 18036}
{"snippet": "numpy.nanvar(a, out=None)", "intent": "Compute the variance along the specified `axis` , while ignoring NaNs . Returns the variance of the array elements , `a` measure of the spread of a distribution . With arguments `out`. numpy", "question_id": 18037}
{"snippet": "numpy.nanvar(a, ddof=0)", "intent": "Compute the variance along the specified `axis` , while ignoring NaNs . Returns the variance of the array elements , `a` measure of the spread of a distribution . If , however , `ddof` is specified , the divisor N - ddof is used instead . numpy", "question_id": 18038}
{"snippet": "numpy.nanvar(a, keepdims=<no value>)", "intent": "Compute the variance along the specified `axis` , while ignoring NaNs . Returns the variance of the array elements , `a` measure of the spread of a distribution . For this function to work on sub-classes of ndarray , they must define sum with the kwarg `keepdims` numpy", "question_id": 18039}
{"snippet": "numpy.nanvar(a, axis=None, dtype=None)", "intent": "Compute the variance along the specified `axis` , while ignoring NaNs . Returns the variance of the array elements , `a` measure of the spread of a distribution . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue . numpy", "question_id": 18040}
{"snippet": "numpy.nanvar(a, axis=None, out=None)", "intent": "Compute the variance along the specified `axis` , while ignoring NaNs . Returns the variance of the array elements , `a` measure of the spread of a distribution . With arguments `out`. numpy", "question_id": 18041}
{"snippet": "numpy.nanvar(a, axis=None, ddof=0)", "intent": "Compute the variance along the specified `axis` , while ignoring NaNs . Returns the variance of the array elements , `a` measure of the spread of a distribution . If , however , `ddof` is specified , the divisor N - ddof is used instead . numpy", "question_id": 18042}
{"snippet": "numpy.nanvar(a, axis=None, keepdims=<no value>)", "intent": "Compute the variance along the specified `axis` , while ignoring NaNs . Returns the variance of the array elements , `a` measure of the spread of a distribution . For this function to work on sub-classes of ndarray , they must define sum with the kwarg `keepdims` numpy", "question_id": 18043}
{"snippet": "numpy.sin(x, /, signature, extobj)", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `extobj`. numpy", "question_id": 18044}
{"snippet": "numpy.sin(x, /, signature, extobj, out=None)", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `extobj`, `out`. numpy", "question_id": 18045}
{"snippet": "numpy.sin(x, /, signature, extobj, where=True)", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `extobj`. numpy", "question_id": 18046}
{"snippet": "numpy.sin(x, /, signature, extobj, casting='same_kind')", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `extobj`, `casting`. numpy", "question_id": 18047}
{"snippet": "numpy.sin(x, /, signature, extobj, order='K')", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `extobj`, `order`. numpy", "question_id": 18048}
{"snippet": "numpy.sin(x, /, signature, extobj, dtype=None)", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `extobj`, `dtype`. numpy", "question_id": 18049}
{"snippet": "numpy.sin(x, /, signature, extobj, subok=True)", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `extobj`, `subok`. numpy", "question_id": 18050}
{"snippet": "numpy.sin(x, /, signature, extobj, out=None, where=True)", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `extobj`, `out`. numpy", "question_id": 18051}
{"snippet": "numpy.sin(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 18052}
{"snippet": "numpy.sin(x, /, signature, extobj, out=None, order='K')", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 18053}
{"snippet": "numpy.sin(x, /, signature)", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`. numpy", "question_id": 18054}
{"snippet": "numpy.sin(x, /, signature, out=None)", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `out`. numpy", "question_id": 18055}
{"snippet": "numpy.sin(x, /, signature, where=True)", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`. numpy", "question_id": 18056}
{"snippet": "numpy.sin(x, /, signature, casting='same_kind')", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `casting`. numpy", "question_id": 18057}
{"snippet": "numpy.sin(x, /, signature, order='K')", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `order`. numpy", "question_id": 18058}
{"snippet": "numpy.sin(x, /, signature, dtype=None)", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `dtype`. numpy", "question_id": 18059}
{"snippet": "numpy.sin(x, /, signature, subok=True)", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `subok`. numpy", "question_id": 18060}
{"snippet": "numpy.sin(x, /, signature, out=None, where=True)", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `out`. numpy", "question_id": 18061}
{"snippet": "numpy.sin(x, /, signature, out=None, casting='same_kind')", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `out`, `casting`. numpy", "question_id": 18062}
{"snippet": "numpy.sin(x, /, signature, out=None, order='K')", "intent": "Trigonometric sine , element-wise . It ranges from -1 for \\ ( x=3\\pi `/` 2\\ ) to +1 for \\ ( \\pi / 2.\\ ) The function has zeroes `where` the angle is a multiple of \\ ( \\pi\\ ) . With arguments `x`, `signature`, `out`, `order`. numpy", "question_id": 18063}
{"snippet": "recarray.item(*args)", "intent": "Copy an element of an array to a standard Python scalar and return it . With arguments `*args`. numpy", "question_id": 18064}
{"snippet": "numpy.expand_dims(a, axis)", "intent": "Expand the shape of an array . Insert `a` new `axis` that will appear at the axis position in the expanded array shape . numpy", "question_id": 18065}
{"snippet": "char.chararray.argmin()", "intent": "Return indices of the minimum values along the given `axis` . numpy", "question_id": 18066}
{"snippet": "char.chararray.argmin(axis=None)", "intent": "Return indices of the minimum values along the given `axis` . numpy", "question_id": 18067}
{"snippet": "char.chararray.argmin(out=None)", "intent": "Return indices of the minimum values along the given `axis` . With arguments `out`. numpy", "question_id": 18068}
{"snippet": "char.chararray.argmin(axis=None, out=None)", "intent": "Return indices of the minimum values along the given `axis` . With arguments `out`. numpy", "question_id": 18069}
{"snippet": "record.clip()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 18070}
{"snippet": "broadcast.reset()", "intent": "Reset the broadcasted result \u2019 s iterator ( s ) . numpy", "question_id": 18071}
{"snippet": "random.RandomState.standard_exponential()", "intent": "Draw samples from the standard exponential distribution . numpy", "question_id": 18072}
{"snippet": "random.RandomState.standard_exponential(size=None)", "intent": "Draw samples from the standard exponential distribution . With arguments `size`. numpy", "question_id": 18073}
{"snippet": "DataSource.abspath(path)", "intent": "Return absolute `path` of file in the DataSource directory . numpy", "question_id": 18074}
{"snippet": "numpy.stack(arrays)", "intent": "Join a sequence of `arrays` along a new `axis` . numpy", "question_id": 18075}
{"snippet": "numpy.stack(arrays, axis=0)", "intent": "Join a sequence of `arrays` along a new `axis` . numpy", "question_id": 18076}
{"snippet": "numpy.stack(arrays, out=None)", "intent": "Join a sequence of `arrays` along a new `axis` . With arguments `out`. numpy", "question_id": 18077}
{"snippet": "numpy.stack(arrays, axis=0, out=None)", "intent": "Join a sequence of `arrays` along a new `axis` . With arguments `out`. numpy", "question_id": 18078}
{"snippet": "ma.MaskedArray.__idiv__(other)", "intent": "Divide self by `other` in-place . numpy", "question_id": 18079}
{"snippet": "numpy.find_common_type(array_types, scalar_types)", "intent": "Determine common type following standard coercion rules . Complex is of a different type , so it up-casts the float in the `array_types` argument : With arguments `scalar_types`. numpy", "question_id": 18080}
{"snippet": "ma.MaskType.trace()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 18081}
{"snippet": "numpy.rad2deg(x, /, signature, extobj)", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `extobj`. numpy", "question_id": 18082}
{"snippet": "numpy.rad2deg(x, /, signature, extobj, out=None)", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `extobj`, `out`. numpy", "question_id": 18083}
{"snippet": "numpy.rad2deg(x, /, signature, extobj, where=True)", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `extobj`, `where`. numpy", "question_id": 18084}
{"snippet": "numpy.rad2deg(x, /, signature, extobj, casting='same_kind')", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `extobj`, `casting`. numpy", "question_id": 18085}
{"snippet": "numpy.rad2deg(x, /, signature, extobj, order='K')", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `extobj`, `order`. numpy", "question_id": 18086}
{"snippet": "numpy.rad2deg(x, /, signature, extobj, dtype=None)", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `extobj`, `dtype`. numpy", "question_id": 18087}
{"snippet": "numpy.rad2deg(x, /, signature, extobj, subok=True)", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `extobj`, `subok`. numpy", "question_id": 18088}
{"snippet": "numpy.rad2deg(x, /, signature, extobj, out=None, where=True)", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `extobj`, `out`, `where`. numpy", "question_id": 18089}
{"snippet": "numpy.rad2deg(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 18090}
{"snippet": "numpy.rad2deg(x, /, signature, extobj, out=None, order='K')", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `extobj`, `out`, `order`. numpy", "question_id": 18091}
{"snippet": "numpy.rad2deg(x, /, signature)", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`. numpy", "question_id": 18092}
{"snippet": "numpy.rad2deg(x, /, signature, out=None)", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `out`. numpy", "question_id": 18093}
{"snippet": "numpy.rad2deg(x, /, signature, where=True)", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `where`. numpy", "question_id": 18094}
{"snippet": "numpy.rad2deg(x, /, signature, casting='same_kind')", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `casting`. numpy", "question_id": 18095}
{"snippet": "numpy.rad2deg(x, /, signature, order='K')", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `order`. numpy", "question_id": 18096}
{"snippet": "numpy.rad2deg(x, /, signature, dtype=None)", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `dtype`. numpy", "question_id": 18097}
{"snippet": "numpy.rad2deg(x, /, signature, subok=True)", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `subok`. numpy", "question_id": 18098}
{"snippet": "numpy.rad2deg(x, /, signature, out=None, where=True)", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `out`, `where`. numpy", "question_id": 18099}
{"snippet": "numpy.rad2deg(x, /, signature, out=None, casting='same_kind')", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `out`, `casting`. numpy", "question_id": 18100}
{"snippet": "numpy.rad2deg(x, /, signature, out=None, order='K')", "intent": "Convert angles from radians to degrees . rad2deg ( `x` ) is 180 * x `/` pi . With arguments `signature`, `out`, `order`. numpy", "question_id": 18101}
{"snippet": "numpy.digitize(x, bins)", "intent": "Return the indices of the `bins` to which each value in input array belongs . If values in `x` are beyond the bounds of bins , 0 or len ( bins ) is returned as appropriate . numpy", "question_id": 18102}
{"snippet": "numpy.digitize(x, bins, right=False)", "intent": "Return the indices of the `bins` to which each value in input array belongs . If values in `x` are beyond the bounds of bins , 0 or len ( bins ) is returned as appropriate . With arguments `right`. numpy", "question_id": 18103}
{"snippet": "char.isupper(a)", "intent": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character , false otherwise . With arguments `a`. numpy", "question_id": 18104}
{"snippet": "polynomial.hermite.Hermite.has_samewindow(other)", "intent": "Check if windows match . With arguments `other`. numpy", "question_id": 18105}
{"snippet": "fft.fft(a)", "intent": "Compute the one-dimensional discrete Fourier Transform . FFT ( Fast Fourier Transform ) refers to `a` way the discrete Fourier Transform ( DFT ) can be calculated efficiently , by using symmetries in the calculated terms . numpy", "question_id": 18106}
{"snippet": "fft.fft(a, n=None)", "intent": "Compute the one-dimensional discrete Fourier Transform . FFT ( Fast Fourier Transform ) refers to `a` way the discrete Fourier Transform ( DFT ) can be calculated efficiently , by using symmetries in the calculated terms . The symmetry is highest when `n` is a power of 2 , and the transform is therefore most efficient for these sizes . numpy", "question_id": 18107}
{"snippet": "fft.fft(a, axis=- 1)", "intent": "Compute the one-dimensional discrete Fourier Transform . FFT ( Fast Fourier Transform ) refers to `a` way the discrete Fourier Transform ( DFT ) can be calculated efficiently , by using symmetries in the calculated terms . With arguments `axis`. numpy", "question_id": 18108}
{"snippet": "fft.fft(a, norm=None)", "intent": "Compute the one-dimensional discrete Fourier Transform . FFT ( Fast Fourier Transform ) refers to `a` way the discrete Fourier Transform ( DFT ) can be calculated efficiently , by using symmetries in the calculated terms . With arguments `norm`. numpy", "question_id": 18109}
{"snippet": "fft.fft(a, n=None, axis=- 1)", "intent": "Compute the one-dimensional discrete Fourier Transform . FFT ( Fast Fourier Transform ) refers to `a` way the discrete Fourier Transform ( DFT ) can be calculated efficiently , by using symmetries in the calculated terms . The symmetry is highest when `n` is a power of 2 , and the transform is therefore most efficient for these sizes . With arguments `axis`. numpy", "question_id": 18110}
{"snippet": "fft.fft(a, n=None, norm=None)", "intent": "Compute the one-dimensional discrete Fourier Transform . FFT ( Fast Fourier Transform ) refers to `a` way the discrete Fourier Transform ( DFT ) can be calculated efficiently , by using symmetries in the calculated terms . The symmetry is highest when `n` is a power of 2 , and the transform is therefore most efficient for these sizes . With arguments `norm`. numpy", "question_id": 18111}
{"snippet": "fft.fft(a, axis=- 1, norm=None)", "intent": "Compute the one-dimensional discrete Fourier Transform . FFT ( Fast Fourier Transform ) refers to `a` way the discrete Fourier Transform ( DFT ) can be calculated efficiently , by using symmetries in the calculated terms . With arguments `axis`, `norm`. numpy", "question_id": 18112}
{"snippet": "fft.fft(a, n=None, axis=- 1, norm=None)", "intent": "Compute the one-dimensional discrete Fourier Transform . FFT ( Fast Fourier Transform ) refers to `a` way the discrete Fourier Transform ( DFT ) can be calculated efficiently , by using symmetries in the calculated terms . The symmetry is highest when `n` is a power of 2 , and the transform is therefore most efficient for these sizes . With arguments `axis`, `norm`. numpy", "question_id": 18113}
{"snippet": "ma.median(a)", "intent": "Compute the median along the specified `axis` . Given `a` vector V with N non masked values , the median of V is the middle value of a sorted copy of V ( Vs ) - i.e . numpy", "question_id": 18114}
{"snippet": "ma.median(a, axis=None)", "intent": "Compute the median along the specified `axis` . Given `a` vector V with N non masked values , the median of V is the middle value of a sorted copy of V ( Vs ) - i.e . numpy", "question_id": 18115}
{"snippet": "ma.median(a, out=None)", "intent": "Compute the median along the specified `axis` . Given `a` vector V with N non masked values , the median of V is the middle value of a sorted copy of V ( Vs ) - i.e . With arguments `out`. numpy", "question_id": 18116}
{"snippet": "ma.median(a, overwrite_input=False)", "intent": "Compute the median along the specified `axis` . Given `a` vector V with N non masked values , the median of V is the middle value of a sorted copy of V ( Vs ) - i.e . With arguments `overwrite_input`. numpy", "question_id": 18117}
{"snippet": "ma.median(a, keepdims=False)", "intent": "Compute the median along the specified `axis` . Given `a` vector V with N non masked values , the median of V is the middle value of a sorted copy of V ( Vs ) - i.e . With arguments `keepdims`. numpy", "question_id": 18118}
{"snippet": "ma.median(a, axis=None, out=None)", "intent": "Compute the median along the specified `axis` . Given `a` vector V with N non masked values , the median of V is the middle value of a sorted copy of V ( Vs ) - i.e . With arguments `out`. numpy", "question_id": 18119}
{"snippet": "ma.median(a, axis=None, overwrite_input=False)", "intent": "Compute the median along the specified `axis` . Given `a` vector V with N non masked values , the median of V is the middle value of a sorted copy of V ( Vs ) - i.e . With arguments `overwrite_input`. numpy", "question_id": 18120}
{"snippet": "ma.median(a, axis=None, keepdims=False)", "intent": "Compute the median along the specified `axis` . Given `a` vector V with N non masked values , the median of V is the middle value of a sorted copy of V ( Vs ) - i.e . With arguments `keepdims`. numpy", "question_id": 18121}
{"snippet": "ma.median(a, out=None, overwrite_input=False)", "intent": "Compute the median along the specified `axis` . Given `a` vector V with N non masked values , the median of V is the middle value of a sorted copy of V ( Vs ) - i.e . With arguments `out`, `overwrite_input`. numpy", "question_id": 18122}
{"snippet": "ma.median(a, out=None, keepdims=False)", "intent": "Compute the median along the specified `axis` . Given `a` vector V with N non masked values , the median of V is the middle value of a sorted copy of V ( Vs ) - i.e . With arguments `out`, `keepdims`. numpy", "question_id": 18123}
{"snippet": "linalg.eig(a)", "intent": "Compute the eigenvalues and right eigenvectors of `a` square array . numpy", "question_id": 18124}
{"snippet": "numpy.transpose(a)", "intent": "Reverse or permute the `axes` of an array ; returns the modified array . For an array `a` with two axes , transpose ( a ) gives the matrix transpose . numpy", "question_id": 18125}
{"snippet": "numpy.transpose(a, axes=None)", "intent": "Reverse or permute the `axes` of an array ; returns the modified array . For an array `a` with two axes , transpose ( a ) gives the matrix transpose . numpy", "question_id": 18126}
{"snippet": "numpy.lookfor(what)", "intent": "Do a keyword search on docstrings . With arguments `what`. numpy", "question_id": 18127}
{"snippet": "numpy.lookfor(what, module=None)", "intent": "Do a keyword search on docstrings . With arguments `what`, `module`. numpy", "question_id": 18128}
{"snippet": "numpy.lookfor(what, import_modules=True)", "intent": "Do a keyword search on docstrings . With arguments `what`, `import_modules`. numpy", "question_id": 18129}
{"snippet": "numpy.lookfor(what, regenerate=False)", "intent": "Do a keyword search on docstrings . With arguments `what`, `regenerate`. numpy", "question_id": 18130}
{"snippet": "numpy.lookfor(what, output=None)", "intent": "Do a keyword search on docstrings . With arguments `what`, `output`. numpy", "question_id": 18131}
{"snippet": "numpy.lookfor(what, module=None, import_modules=True)", "intent": "Do a keyword search on docstrings . With arguments `what`, `module`, `import_modules`. numpy", "question_id": 18132}
{"snippet": "numpy.lookfor(what, module=None, regenerate=False)", "intent": "Do a keyword search on docstrings . With arguments `what`, `module`, `regenerate`. numpy", "question_id": 18133}
{"snippet": "numpy.lookfor(what, module=None, output=None)", "intent": "Do a keyword search on docstrings . With arguments `what`, `module`, `output`. numpy", "question_id": 18134}
{"snippet": "numpy.lookfor(what, import_modules=True, regenerate=False)", "intent": "Do a keyword search on docstrings . With arguments `what`, `import_modules`, `regenerate`. numpy", "question_id": 18135}
{"snippet": "numpy.lookfor(what, import_modules=True, output=None)", "intent": "Do a keyword search on docstrings . With arguments `what`, `import_modules`, `output`. numpy", "question_id": 18136}
{"snippet": "fft.rfftn(a)", "intent": "Compute the N-dimensional discrete Fourier Transform for real input . With arguments `a`. numpy", "question_id": 18137}
{"snippet": "fft.rfftn(a, s=None)", "intent": "Compute the N-dimensional discrete Fourier Transform for real input . With arguments `a`, `s`. numpy", "question_id": 18138}
{"snippet": "fft.rfftn(a, axes=None)", "intent": "Compute the N-dimensional discrete Fourier Transform for real input . This function computes the N-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional real array by means of the Fast Fourier Transform ( FFT ) . With arguments `a`. numpy", "question_id": 18139}
{"snippet": "fft.rfftn(a, norm=None)", "intent": "Compute the N-dimensional discrete Fourier Transform for real input . With arguments `a`, `norm`. numpy", "question_id": 18140}
{"snippet": "fft.rfftn(a, s=None, axes=None)", "intent": "Compute the N-dimensional discrete Fourier Transform for real input . This function computes the N-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional real array by means of the Fast Fourier Transform ( FFT ) . With arguments `a`, `s`. numpy", "question_id": 18141}
{"snippet": "fft.rfftn(a, s=None, norm=None)", "intent": "Compute the N-dimensional discrete Fourier Transform for real input . With arguments `a`, `s`, `norm`. numpy", "question_id": 18142}
{"snippet": "fft.rfftn(a, axes=None, norm=None)", "intent": "Compute the N-dimensional discrete Fourier Transform for real input . This function computes the N-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional real array by means of the Fast Fourier Transform ( FFT ) . With arguments `a`, `norm`. numpy", "question_id": 18143}
{"snippet": "fft.rfftn(a, s=None, axes=None, norm=None)", "intent": "Compute the N-dimensional discrete Fourier Transform for real input . This function computes the N-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional real array by means of the Fast Fourier Transform ( FFT ) . With arguments `a`, `s`, `norm`. numpy", "question_id": 18144}
{"snippet": "recarray.diagonal()", "intent": "Return specified diagonals . numpy", "question_id": 18145}
{"snippet": "recarray.diagonal(offset=0)", "intent": "Return specified diagonals . With arguments `offset`. numpy", "question_id": 18146}
{"snippet": "recarray.diagonal(axis1=0)", "intent": "Return specified diagonals . With arguments `axis1`. numpy", "question_id": 18147}
{"snippet": "recarray.diagonal(axis2=1)", "intent": "Return specified diagonals . With arguments `axis2`. numpy", "question_id": 18148}
{"snippet": "recarray.diagonal(offset=0, axis1=0)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`. numpy", "question_id": 18149}
{"snippet": "recarray.diagonal(offset=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis2`. numpy", "question_id": 18150}
{"snippet": "recarray.diagonal(axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `axis1`, `axis2`. numpy", "question_id": 18151}
{"snippet": "recarray.diagonal(offset=0, axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`, `axis2`. numpy", "question_id": 18152}
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, axis)", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `axis`. numpy", "question_id": 18153}
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, axis, out=None)", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `axis`, `out`. numpy", "question_id": 18154}
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, axis, casting='same_kind')", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `axis`, `casting`. numpy", "question_id": 18155}
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, axis, order='K')", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `axis`, `order`. numpy", "question_id": 18156}
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, axis, dtype=None)", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `axis`, `dtype`. numpy", "question_id": 18157}
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, axis, subok=True)", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `axis`, `subok`. numpy", "question_id": 18158}
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, axis, out=None, casting='same_kind')", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `axis`, `out`, `casting`. numpy", "question_id": 18159}
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, axis, out=None, order='K')", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `axis`, `out`, `order`. numpy", "question_id": 18160}
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, axis, out=None, dtype=None)", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `axis`, `out`, `dtype`. numpy", "question_id": 18161}
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, axis, out=None, subok=True)", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `axis`, `out`, `subok`. numpy", "question_id": 18162}
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes)", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`. numpy", "question_id": 18163}
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, out=None)", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `out`. numpy", "question_id": 18164}
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, casting='same_kind')", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `casting`. numpy", "question_id": 18165}
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, order='K')", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `order`. numpy", "question_id": 18166}
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, dtype=None)", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `dtype`. numpy", "question_id": 18167}
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, subok=True)", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `subok`. numpy", "question_id": 18168}
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, out=None, casting='same_kind')", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `out`, `casting`. numpy", "question_id": 18169}
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, out=None, order='K')", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `out`, `order`. numpy", "question_id": 18170}
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, out=None, dtype=None)", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `out`, `dtype`. numpy", "question_id": 18171}
{"snippet": "numpy.matmul(x1, x2, /, signature, extobj, axes, out=None, subok=True)", "intent": "Matrix product of two arrays . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `axes`, `out`, `subok`. numpy", "question_id": 18172}
{"snippet": "chararray.strides", "intent": "Tuple of bytes to step in each dimension when traversing an array. numpy", "question_id": 18173}
{"snippet": "numpy.histogram2d(x, y)", "intent": "Compute the bi-dimensional histogram of two data samples . Please note that the histogram does not follow the Cartesian convention where `x` values are on the abscissa and `y` values on the ordinate axis . numpy", "question_id": 18174}
{"snippet": "numpy.histogram2d(x, y, bins=10)", "intent": "Compute the bi-dimensional histogram of two data samples . Please note that the histogram does not follow the Cartesian convention where `x` values are on the abscissa and `y` values on the ordinate axis . When `normed` is True , then the returned histogram is the sample `density` , defined such that the sum over `bins` of the product bin_value * bin_area is 1 . numpy", "question_id": 18175}
{"snippet": "numpy.histogram2d(x, y, range=None)", "intent": "Compute the bi-dimensional histogram of two data samples . Please note that the histogram does not follow the Cartesian convention where `x` values are on the abscissa and `y` values on the ordinate axis . With arguments `range`. numpy", "question_id": 18176}
{"snippet": "numpy.histogram2d(x, y, normed=None)", "intent": "Compute the bi-dimensional histogram of two data samples . Please note that the histogram does not follow the Cartesian convention where `x` values are on the abscissa and `y` values on the ordinate axis . When `normed` is True , then the returned histogram is the sample `density` , defined such that the sum over `bins` of the product bin_value * bin_area is 1 . numpy", "question_id": 18177}
{"snippet": "numpy.histogram2d(x, y, weights=None)", "intent": "Compute the bi-dimensional histogram of two data samples . Please note that the histogram does not follow the Cartesian convention where `x` values are on the abscissa and `y` values on the ordinate axis . With arguments `weights`. numpy", "question_id": 18178}
{"snippet": "numpy.histogram2d(x, y, density=None)", "intent": "Compute the bi-dimensional histogram of two data samples . Please note that the histogram does not follow the Cartesian convention where `x` values are on the abscissa and `y` values on the ordinate axis . When `normed` is True , then the returned histogram is the sample `density` , defined such that the sum over `bins` of the product bin_value * bin_area is 1 . numpy", "question_id": 18179}
{"snippet": "numpy.histogram2d(x, y, bins=10, range=None)", "intent": "Compute the bi-dimensional histogram of two data samples . Please note that the histogram does not follow the Cartesian convention where `x` values are on the abscissa and `y` values on the ordinate axis . When `normed` is True , then the returned histogram is the sample `density` , defined such that the sum over `bins` of the product bin_value * bin_area is 1 . With arguments `range`. numpy", "question_id": 18180}
{"snippet": "numpy.histogram2d(x, y, bins=10, normed=None)", "intent": "Compute the bi-dimensional histogram of two data samples . Please note that the histogram does not follow the Cartesian convention where `x` values are on the abscissa and `y` values on the ordinate axis . When `normed` is True , then the returned histogram is the sample `density` , defined such that the sum over `bins` of the product bin_value * bin_area is 1 . numpy", "question_id": 18181}
{"snippet": "numpy.histogram2d(x, y, bins=10, weights=None)", "intent": "Compute the bi-dimensional histogram of two data samples . Please note that the histogram does not follow the Cartesian convention where `x` values are on the abscissa and `y` values on the ordinate axis . When `normed` is True , then the returned histogram is the sample `density` , defined such that the sum over `bins` of the product bin_value * bin_area is 1 . With arguments `weights`. numpy", "question_id": 18182}
{"snippet": "numpy.histogram2d(x, y, bins=10, density=None)", "intent": "Compute the bi-dimensional histogram of two data samples . Please note that the histogram does not follow the Cartesian convention where `x` values are on the abscissa and `y` values on the ordinate axis . When `normed` is True , then the returned histogram is the sample `density` , defined such that the sum over `bins` of the product bin_value * bin_area is 1 . numpy", "question_id": 18183}
{"snippet": "numpy.disp(mesg)", "intent": "Display a message on a `device` . With arguments `mesg`. numpy", "question_id": 18184}
{"snippet": "numpy.disp(mesg, device=None)", "intent": "Display a message on a `device` . With arguments `mesg`. numpy", "question_id": 18185}
{"snippet": "numpy.disp(mesg, linefeed=True)", "intent": "Display a message on a `device` . With arguments `mesg`, `linefeed`. numpy", "question_id": 18186}
{"snippet": "numpy.disp(mesg, device=None, linefeed=True)", "intent": "Display a message on a `device` . With arguments `mesg`, `linefeed`. numpy", "question_id": 18187}
{"snippet": "ndarray.argpartition(kth)", "intent": "Returns the indices that would partition this array . With arguments `kth`. numpy", "question_id": 18188}
{"snippet": "ndarray.argpartition(kth, axis=- 1)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`. numpy", "question_id": 18189}
{"snippet": "ndarray.argpartition(kth, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`. numpy", "question_id": 18190}
{"snippet": "ndarray.argpartition(kth, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `order`. numpy", "question_id": 18191}
{"snippet": "ndarray.argpartition(kth, axis=- 1, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`. numpy", "question_id": 18192}
{"snippet": "ndarray.argpartition(kth, axis=- 1, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `order`. numpy", "question_id": 18193}
{"snippet": "ndarray.argpartition(kth, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`, `order`. numpy", "question_id": 18194}
{"snippet": "ndarray.argpartition(kth, axis=- 1, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`, `order`. numpy", "question_id": 18195}
{"snippet": "char.chararray.conjugate()", "intent": "Return the complex conjugate , element-wise . numpy", "question_id": 18196}
{"snippet": "ma.MaskedArray.get_fill_value()", "intent": "The filling value of the masked array is a scalar . numpy", "question_id": 18197}
{"snippet": "ma.getmask(a)", "intent": "Return the mask of `a` masked array , or nomask . numpy", "question_id": 18198}
{"snippet": "polynomial.polynomial.polycompanion(c)", "intent": "Return the companion matrix of `c` . numpy", "question_id": 18199}
{"snippet": "ma.asanyarray(a)", "intent": "Convert the input to `a` masked array , conserving subclasses . numpy", "question_id": 18200}
{"snippet": "ma.asanyarray(a, dtype=None)", "intent": "Convert the input to `a` masked array , conserving subclasses . With arguments `dtype`. numpy", "question_id": 18201}
{"snippet": "linalg.matrix_power(a, n)", "intent": "Raise `a` square matrix to the ( integer ) power `n` . numpy", "question_id": 18202}
{"snippet": "char.chararray.encode()", "intent": "Calls str.encode element-wise . numpy", "question_id": 18203}
{"snippet": "char.chararray.encode(encoding=None)", "intent": "Calls str.encode element-wise . With arguments `encoding`. numpy", "question_id": 18204}
{"snippet": "char.chararray.encode(errors=None)", "intent": "Calls str.encode element-wise . With arguments `errors`. numpy", "question_id": 18205}
{"snippet": "char.chararray.encode(encoding=None, errors=None)", "intent": "Calls str.encode element-wise . With arguments `encoding`, `errors`. numpy", "question_id": 18206}
{"snippet": "lib.scimath.arccos(x)", "intent": "Compute the inverse cosine of `x` . numpy", "question_id": 18207}
{"snippet": "matrix.diagonal()", "intent": "Return specified diagonals . numpy", "question_id": 18208}
{"snippet": "matrix.diagonal(offset=0)", "intent": "Return specified diagonals . With arguments `offset`. numpy", "question_id": 18209}
{"snippet": "matrix.diagonal(axis1=0)", "intent": "Return specified diagonals . With arguments `axis1`. numpy", "question_id": 18210}
{"snippet": "matrix.diagonal(axis2=1)", "intent": "Return specified diagonals . With arguments `axis2`. numpy", "question_id": 18211}
{"snippet": "matrix.diagonal(offset=0, axis1=0)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`. numpy", "question_id": 18212}
{"snippet": "matrix.diagonal(offset=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis2`. numpy", "question_id": 18213}
{"snippet": "matrix.diagonal(axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `axis1`, `axis2`. numpy", "question_id": 18214}
{"snippet": "matrix.diagonal(offset=0, axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`, `axis2`. numpy", "question_id": 18215}
{"snippet": "ma.MaskType.getfield()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 18216}
{"snippet": "ndarray.__and__(value, /)", "intent": "Return self & `value` . With arguments `/`. numpy", "question_id": 18217}
{"snippet": "memmap.dot(b)", "intent": "Dot product of two arrays . With arguments `b`. numpy", "question_id": 18218}
{"snippet": "memmap.dot(b, out=None)", "intent": "Dot product of two arrays . With arguments `b`, `out`. numpy", "question_id": 18219}
{"snippet": "ma.maximum_fill_value(obj)", "intent": "Return the minimum value that can be represented by the dtype of an object . With arguments `obj`. numpy", "question_id": 18220}
{"snippet": "numpy.sign(x, /, signature, extobj)", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 18221}
{"snippet": "numpy.sign(x, /, signature, extobj, out=None)", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 18222}
{"snippet": "numpy.sign(x, /, signature, extobj, where=True)", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 18223}
{"snippet": "numpy.sign(x, /, signature, extobj, casting='same_kind')", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 18224}
{"snippet": "numpy.sign(x, /, signature, extobj, order='K')", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 18225}
{"snippet": "numpy.sign(x, /, signature, extobj, dtype=None)", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 18226}
{"snippet": "numpy.sign(x, /, signature, extobj, subok=True)", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 18227}
{"snippet": "numpy.sign(x, /, signature, extobj, out=None, where=True)", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 18228}
{"snippet": "numpy.sign(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 18229}
{"snippet": "numpy.sign(x, /, signature, extobj, out=None, order='K')", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 18230}
{"snippet": "numpy.sign(x, /, signature)", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`. numpy", "question_id": 18231}
{"snippet": "numpy.sign(x, /, signature, out=None)", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `out`. numpy", "question_id": 18232}
{"snippet": "numpy.sign(x, /, signature, where=True)", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `where`. numpy", "question_id": 18233}
{"snippet": "numpy.sign(x, /, signature, casting='same_kind')", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `casting`. numpy", "question_id": 18234}
{"snippet": "numpy.sign(x, /, signature, order='K')", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `order`. numpy", "question_id": 18235}
{"snippet": "numpy.sign(x, /, signature, dtype=None)", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 18236}
{"snippet": "numpy.sign(x, /, signature, subok=True)", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `subok`. numpy", "question_id": 18237}
{"snippet": "numpy.sign(x, /, signature, out=None, where=True)", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 18238}
{"snippet": "numpy.sign(x, /, signature, out=None, casting='same_kind')", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 18239}
{"snippet": "numpy.sign(x, /, signature, out=None, order='K')", "intent": "Returns an element-wise indication of the sign of a number . The sign function returns -1 if `x` < 0 , 0 if x==0 , 1 if x > 0. nan is returned for nan inputs . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 18240}
{"snippet": "ma.MaskType.take()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 18241}
{"snippet": "ndarray.cumsum()", "intent": "Return the cumulative sum of the elements along the given `axis` . numpy", "question_id": 18242}
{"snippet": "ndarray.cumsum(axis=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . numpy", "question_id": 18243}
{"snippet": "ndarray.cumsum(dtype=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 18244}
{"snippet": "ndarray.cumsum(out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `out`. numpy", "question_id": 18245}
{"snippet": "ndarray.cumsum(axis=None, dtype=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 18246}
{"snippet": "ndarray.cumsum(axis=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `out`. numpy", "question_id": 18247}
{"snippet": "ndarray.cumsum(dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 18248}
{"snippet": "ndarray.cumsum(axis=None, dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 18249}
{"snippet": "numpy.testing.suppress_warnings()", "intent": "Context manager and decorator doing much the same as warnings.catch_warnings . numpy", "question_id": 18250}
{"snippet": "numpy.testing.suppress_warnings(forwarding_rule='always')", "intent": "Context manager and decorator doing much the same as warnings.catch_warnings . With arguments `forwarding_rule`. numpy", "question_id": 18251}
{"snippet": "numpy.apply_along_axis(func1d, axis, arr, *args, **kwargs)", "intent": "Apply a function to 1-D slices along the given `axis` . Execute `func1d` ( a , * args , * * kwargs ) where func1d operates on 1-D arrays and a is a 1-D slice of `arr` along axis . With arguments `*args`, `**kwargs`. numpy", "question_id": 18252}
{"snippet": "polynomial.laguerre.Laguerre.truncate(size)", "intent": "Truncate series to length `size` . numpy", "question_id": 18253}
{"snippet": "numpy.any(a)", "intent": "Test whether any array element along `a` given `axis` evaluates to True . numpy", "question_id": 18254}
{"snippet": "numpy.any(a, axis=None)", "intent": "Test whether any array element along `a` given `axis` evaluates to True . numpy", "question_id": 18255}
{"snippet": "numpy.any(a, out=None)", "intent": "Test whether any array element along `a` given `axis` evaluates to True . With arguments `out`. numpy", "question_id": 18256}
{"snippet": "numpy.any(a, keepdims=<no value>)", "intent": "Test whether any array element along `a` given `axis` evaluates to True . With arguments `keepdims`. numpy", "question_id": 18257}
{"snippet": "numpy.any(a, where=<no value>)", "intent": "Test whether any array element along `a` given `axis` evaluates to True . With arguments `where`. numpy", "question_id": 18258}
{"snippet": "numpy.any(a, axis=None, out=None)", "intent": "Test whether any array element along `a` given `axis` evaluates to True . With arguments `out`. numpy", "question_id": 18259}
{"snippet": "numpy.any(a, axis=None, keepdims=<no value>)", "intent": "Test whether any array element along `a` given `axis` evaluates to True . With arguments `keepdims`. numpy", "question_id": 18260}
{"snippet": "numpy.any(a, axis=None, where=<no value>)", "intent": "Test whether any array element along `a` given `axis` evaluates to True . With arguments `where`. numpy", "question_id": 18261}
{"snippet": "numpy.any(a, out=None, keepdims=<no value>)", "intent": "Test whether any array element along `a` given `axis` evaluates to True . With arguments `out`, `keepdims`. numpy", "question_id": 18262}
{"snippet": "numpy.any(a, out=None, where=<no value>)", "intent": "Test whether any array element along `a` given `axis` evaluates to True . With arguments `out`, `where`. numpy", "question_id": 18263}
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, extobj)", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`. numpy", "question_id": 18264}
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, extobj, out=None)", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 18265}
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, extobj, where=True)", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `where`. numpy", "question_id": 18266}
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 18267}
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, extobj, order='K')", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 18268}
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, extobj, dtype=None)", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 18269}
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, extobj, subok=True)", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 18270}
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 18271}
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 18272}
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 18273}
{"snippet": "numpy.bitwise_or(x1, x2, /, signature)", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`. numpy", "question_id": 18274}
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, out=None)", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `out`. numpy", "question_id": 18275}
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, where=True)", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `where`. numpy", "question_id": 18276}
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, casting='same_kind')", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `casting`. numpy", "question_id": 18277}
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, order='K')", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `order`. numpy", "question_id": 18278}
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, dtype=None)", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `dtype`. numpy", "question_id": 18279}
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, subok=True)", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `subok`. numpy", "question_id": 18280}
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, out=None, where=True)", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `out`, `where`. numpy", "question_id": 18281}
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `out`, `casting`. numpy", "question_id": 18282}
{"snippet": "numpy.bitwise_or(x1, x2, /, signature, out=None, order='K')", "intent": "Compute the bit-wise OR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `out`, `order`. numpy", "question_id": 18283}
{"snippet": "ma.MaskType.nbytes", "intent": "The length of the scalar in bytes. numpy", "question_id": 18284}
{"snippet": "char.chararray.ravel(order)", "intent": "Return a flattened array . With arguments `order`. numpy", "question_id": 18285}
{"snippet": "char.chararray.ravel()", "intent": "Return a flattened array . numpy", "question_id": 18286}
{"snippet": "random.Generator.binomial(n, p)", "intent": "Draw samples from a binomial distribution . Samples are drawn from a binomial distribution with specified parameters , `n` trials and `p` probability of success where n an integer > = 0 and p is in the interval [ 0,1 ] . numpy", "question_id": 18287}
{"snippet": "random.Generator.binomial(n, p, size=None)", "intent": "Draw samples from a binomial distribution . Samples are drawn from a binomial distribution with specified parameters , `n` trials and `p` probability of success where n an integer > = 0 and p is in the interval [ 0,1 ] . With arguments `size`. numpy", "question_id": 18288}
{"snippet": "ma.flatnotmasked_edges(a)", "intent": "Find the indices of the first and last unmasked values . Expects `a` 1-D MaskedArray , returns None if all values are masked . numpy", "question_id": 18289}
{"snippet": "numpy.einsum_path(subscripts, *operands)", "intent": "Evaluates the lowest cost contraction order for an einsum expression by considering the creation of intermediate arrays . With arguments `subscripts`, `*operands`. numpy", "question_id": 18290}
{"snippet": "numpy.einsum_path(subscripts, *operands, optimize='greedy')", "intent": "Evaluates the lowest cost contraction order for an einsum expression by considering the creation of intermediate arrays . With arguments `subscripts`, `*operands`, `optimize`. numpy", "question_id": 18291}
{"snippet": "polynomial.laguerre.lagsub(c1, c2)", "intent": "Subtract one Laguerre series from another . Returns the difference of two Laguerre series `c1` - `c2` . numpy", "question_id": 18292}
{"snippet": "numpy.geomspace(start, stop)", "intent": "Return numbers spaced evenly on a log scale ( a geometric progression ) . With arguments `start`, `stop`. numpy", "question_id": 18293}
{"snippet": "numpy.geomspace(start, stop, num=50)", "intent": "Return numbers spaced evenly on a log scale ( a geometric progression ) . With arguments `start`, `stop`, `num`. numpy", "question_id": 18294}
{"snippet": "numpy.geomspace(start, stop, endpoint=True)", "intent": "Return numbers spaced evenly on a log scale ( a geometric progression ) . Graphical illustration of `endpoint` parameter : With arguments `start`, `stop`. numpy", "question_id": 18295}
{"snippet": "numpy.geomspace(start, stop, dtype=None)", "intent": "Return numbers spaced evenly on a log scale ( a geometric progression ) . If the inputs or `dtype` are complex , the output will follow a logarithmic spiral in the complex plane . With arguments `start`, `stop`. numpy", "question_id": 18296}
{"snippet": "numpy.geomspace(start, stop, axis=0)", "intent": "Return numbers spaced evenly on a log scale ( a geometric progression ) . With arguments `start`, `stop`, `axis`. numpy", "question_id": 18297}
{"snippet": "numpy.geomspace(start, stop, num=50, endpoint=True)", "intent": "Return numbers spaced evenly on a log scale ( a geometric progression ) . Graphical illustration of `endpoint` parameter : With arguments `start`, `stop`, `num`. numpy", "question_id": 18298}
{"snippet": "numpy.geomspace(start, stop, num=50, dtype=None)", "intent": "Return numbers spaced evenly on a log scale ( a geometric progression ) . If the inputs or `dtype` are complex , the output will follow a logarithmic spiral in the complex plane . With arguments `start`, `stop`, `num`. numpy", "question_id": 18299}
{"snippet": "numpy.geomspace(start, stop, num=50, axis=0)", "intent": "Return numbers spaced evenly on a log scale ( a geometric progression ) . With arguments `start`, `stop`, `num`, `axis`. numpy", "question_id": 18300}
{"snippet": "numpy.geomspace(start, stop, endpoint=True, dtype=None)", "intent": "Return numbers spaced evenly on a log scale ( a geometric progression ) . Graphical illustration of `endpoint` parameter : If the inputs or `dtype` are complex , the output will follow a logarithmic spiral in the complex plane . With arguments `start`, `stop`. numpy", "question_id": 18301}
{"snippet": "numpy.geomspace(start, stop, endpoint=True, axis=0)", "intent": "Return numbers spaced evenly on a log scale ( a geometric progression ) . Graphical illustration of `endpoint` parameter : With arguments `start`, `stop`, `axis`. numpy", "question_id": 18302}
{"snippet": "ma.MaskedArray.__imod__(value, /)", "intent": "Return self % =value . With arguments `value`, `/`. numpy", "question_id": 18303}
{"snippet": "char.chararray.astype(dtype)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`. numpy", "question_id": 18304}
{"snippet": "char.chararray.astype(dtype, order='K')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`. numpy", "question_id": 18305}
{"snippet": "char.chararray.astype(dtype, casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`. numpy", "question_id": 18306}
{"snippet": "char.chararray.astype(dtype, subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `subok`. numpy", "question_id": 18307}
{"snippet": "char.chararray.astype(dtype, copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `copy`. numpy", "question_id": 18308}
{"snippet": "char.chararray.astype(dtype, order='K', casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `casting`. numpy", "question_id": 18309}
{"snippet": "char.chararray.astype(dtype, order='K', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `subok`. numpy", "question_id": 18310}
{"snippet": "char.chararray.astype(dtype, order='K', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `copy`. numpy", "question_id": 18311}
{"snippet": "char.chararray.astype(dtype, casting='unsafe', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `subok`. numpy", "question_id": 18312}
{"snippet": "char.chararray.astype(dtype, casting='unsafe', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `copy`. numpy", "question_id": 18313}
{"snippet": "record.mean()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 18314}
{"snippet": "matrix.byteswap()", "intent": "Swap the bytes of the array elements numpy", "question_id": 18315}
{"snippet": "matrix.byteswap(inplace=False)", "intent": "Swap the bytes of the array elements With arguments `inplace`. numpy", "question_id": 18316}
{"snippet": "char.chararray.newbyteorder(/)", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`. numpy", "question_id": 18317}
{"snippet": "char.chararray.newbyteorder(/, new_order='S')", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`, `new_order`. numpy", "question_id": 18318}
{"snippet": "ma.masked_array.sum()", "intent": "Return the sum of the array elements over the given `axis` . numpy", "question_id": 18319}
{"snippet": "ma.masked_array.sum(axis=None)", "intent": "Return the sum of the array elements over the given `axis` . numpy", "question_id": 18320}
{"snippet": "ma.masked_array.sum(dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 18321}
{"snippet": "ma.masked_array.sum(out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`. numpy", "question_id": 18322}
{"snippet": "ma.masked_array.sum(keepdims=<no value>)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`. numpy", "question_id": 18323}
{"snippet": "ma.masked_array.sum(axis=None, dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 18324}
{"snippet": "ma.masked_array.sum(axis=None, out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`. numpy", "question_id": 18325}
{"snippet": "ma.masked_array.sum(axis=None, keepdims=<no value>)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`. numpy", "question_id": 18326}
{"snippet": "ma.masked_array.sum(dtype=None, out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 18327}
{"snippet": "ma.masked_array.sum(dtype=None, keepdims=<no value>)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`, `keepdims`. numpy", "question_id": 18328}
{"snippet": "ma.MaskedArray.base", "intent": "Base object if memory is from some other object. numpy", "question_id": 18329}
{"snippet": "polynomial.laguerre.lag2poly(c)", "intent": "Convert a Laguerre series to a polynomial . With arguments `c`. numpy", "question_id": 18330}
{"snippet": "nditer.copy()", "intent": "Get a copy of the iterator in its current state . numpy", "question_id": 18331}
{"snippet": "chararray.replace(old, new)", "intent": "For each element in self , return a copy of the string with all occurrences of substring `old` replaced by `new` . numpy", "question_id": 18332}
{"snippet": "chararray.replace(old, new, count=None)", "intent": "For each element in self , return a copy of the string with all occurrences of substring `old` replaced by `new` . With arguments `count`. numpy", "question_id": 18333}
{"snippet": "ma.copy(self, *args)", "intent": "Notes With arguments `self`, `*args`. numpy", "question_id": 18334}
{"snippet": "ma.copy(self, *args, **params) a.copy(order='C')", "intent": "Notes With arguments `self`, `*args`, `**params) a.copy(order`. numpy", "question_id": 18335}
{"snippet": "char.chararray.isspace()", "intent": "Returns true for each element if there are only whitespace characters in the string and there is at least one character , false otherwise . numpy", "question_id": 18336}
{"snippet": "char.chararray.zfill(width)", "intent": "Return the numeric string left-filled with zeros in a string of length `width` . numpy", "question_id": 18337}
{"snippet": "ma.masked_array.swapaxes(axis1, axis2)", "intent": "Return a view of the array with `axis1` and `axis2` interchanged . numpy", "question_id": 18338}
{"snippet": "char.chararray.diagonal()", "intent": "Return specified diagonals . numpy", "question_id": 18339}
{"snippet": "char.chararray.diagonal(offset=0)", "intent": "Return specified diagonals . With arguments `offset`. numpy", "question_id": 18340}
{"snippet": "char.chararray.diagonal(axis1=0)", "intent": "Return specified diagonals . With arguments `axis1`. numpy", "question_id": 18341}
{"snippet": "char.chararray.diagonal(axis2=1)", "intent": "Return specified diagonals . With arguments `axis2`. numpy", "question_id": 18342}
{"snippet": "char.chararray.diagonal(offset=0, axis1=0)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`. numpy", "question_id": 18343}
{"snippet": "char.chararray.diagonal(offset=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis2`. numpy", "question_id": 18344}
{"snippet": "char.chararray.diagonal(axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `axis1`, `axis2`. numpy", "question_id": 18345}
{"snippet": "char.chararray.diagonal(offset=0, axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`, `axis2`. numpy", "question_id": 18346}
{"snippet": "ma.masked_array.std()", "intent": "Returns the standard deviation of the array elements along given `axis` . numpy", "question_id": 18347}
{"snippet": "ma.masked_array.std(axis=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . numpy", "question_id": 18348}
{"snippet": "ma.masked_array.std(dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 18349}
{"snippet": "ma.masked_array.std(out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 18350}
{"snippet": "ma.masked_array.std(ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`. numpy", "question_id": 18351}
{"snippet": "ma.masked_array.std(keepdims=<no value>)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `keepdims`. numpy", "question_id": 18352}
{"snippet": "ma.masked_array.std(axis=None, dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 18353}
{"snippet": "ma.masked_array.std(axis=None, out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 18354}
{"snippet": "ma.masked_array.std(axis=None, ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`. numpy", "question_id": 18355}
{"snippet": "ma.masked_array.std(axis=None, keepdims=<no value>)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `keepdims`. numpy", "question_id": 18356}
{"snippet": "random.Generator.multivariate_normal(mean, cov)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . We can use a different method other than the default to factorize `cov` : > > > y = rng.multivariate_normal ( mean , cov , ( 3 , 3 ) , method= \u2019 cholesky \u2019 ) > > > y.shape ( 3 , 3 , 2 ) numpy", "question_id": 18357}
{"snippet": "random.Generator.multivariate_normal(mean, cov, size=None)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . We can use a different method other than the default to factorize `cov` : > > > y = rng.multivariate_normal ( mean , cov , ( 3 , 3 ) , method= \u2019 cholesky \u2019 ) > > > y.shape ( 3 , 3 , 2 ) With arguments `size`. numpy", "question_id": 18358}
{"snippet": "random.Generator.multivariate_normal(mean, cov, check_valid='warn')", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . We can use a different method other than the default to factorize `cov` : > > > y = rng.multivariate_normal ( mean , cov , ( 3 , 3 ) , method= \u2019 cholesky \u2019 ) > > > y.shape ( 3 , 3 , 2 ) With arguments `check_valid`. numpy", "question_id": 18359}
{"snippet": "random.Generator.multivariate_normal(mean, cov, tol=1e-8)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . We can use a different method other than the default to factorize `cov` : > > > y = rng.multivariate_normal ( mean , cov , ( 3 , 3 ) , method= \u2019 cholesky \u2019 ) > > > y.shape ( 3 , 3 , 2 ) With arguments `tol`. numpy", "question_id": 18360}
{"snippet": "random.Generator.multivariate_normal(mean, cov, method='svd')", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . We can use a different method other than the default to factorize `cov` : > > > y = rng.multivariate_normal ( mean , cov , ( 3 , 3 ) , method= \u2019 cholesky \u2019 ) > > > y.shape ( 3 , 3 , 2 ) Otherwise , the behavior of this `method` is undefined and backwards compatibility is not guaranteed . numpy", "question_id": 18361}
{"snippet": "random.Generator.multivariate_normal(mean, cov, size=None, check_valid='warn')", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . We can use a different method other than the default to factorize `cov` : > > > y = rng.multivariate_normal ( mean , cov , ( 3 , 3 ) , method= \u2019 cholesky \u2019 ) > > > y.shape ( 3 , 3 , 2 ) With arguments `size`, `check_valid`. numpy", "question_id": 18362}
{"snippet": "random.Generator.multivariate_normal(mean, cov, size=None, tol=1e-8)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . We can use a different method other than the default to factorize `cov` : > > > y = rng.multivariate_normal ( mean , cov , ( 3 , 3 ) , method= \u2019 cholesky \u2019 ) > > > y.shape ( 3 , 3 , 2 ) With arguments `size`, `tol`. numpy", "question_id": 18363}
{"snippet": "random.Generator.multivariate_normal(mean, cov, size=None, method='svd')", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . We can use a different method other than the default to factorize `cov` : > > > y = rng.multivariate_normal ( mean , cov , ( 3 , 3 ) , method= \u2019 cholesky \u2019 ) > > > y.shape ( 3 , 3 , 2 ) Otherwise , the behavior of this `method` is undefined and backwards compatibility is not guaranteed . With arguments `size`. numpy", "question_id": 18364}
{"snippet": "random.Generator.multivariate_normal(mean, cov, check_valid='warn', tol=1e-8)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . We can use a different method other than the default to factorize `cov` : > > > y = rng.multivariate_normal ( mean , cov , ( 3 , 3 ) , method= \u2019 cholesky \u2019 ) > > > y.shape ( 3 , 3 , 2 ) With arguments `check_valid`, `tol`. numpy", "question_id": 18365}
{"snippet": "random.Generator.multivariate_normal(mean, cov, check_valid='warn', method='svd')", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . We can use a different method other than the default to factorize `cov` : > > > y = rng.multivariate_normal ( mean , cov , ( 3 , 3 ) , method= \u2019 cholesky \u2019 ) > > > y.shape ( 3 , 3 , 2 ) Otherwise , the behavior of this `method` is undefined and backwards compatibility is not guaranteed . With arguments `check_valid`. numpy", "question_id": 18366}
{"snippet": "random.Generator.hypergeometric(ngood, nbad, nsample)", "intent": "Draw samples from a Hypergeometric distribution . Samples are drawn from a hypergeometric distribution with specified parameters , `ngood` ( ways to make a good selection ) , `nbad` ( ways to make a bad selection ) , and `nsample` ( number of items sampled , which is less than or equal to the sum ngood + nbad ) . numpy", "question_id": 18367}
{"snippet": "random.Generator.hypergeometric(ngood, nbad, nsample, size=None)", "intent": "Draw samples from a Hypergeometric distribution . Samples are drawn from a hypergeometric distribution with specified parameters , `ngood` ( ways to make a good selection ) , `nbad` ( ways to make a bad selection ) , and `nsample` ( number of items sampled , which is less than or equal to the sum ngood + nbad ) . With arguments `size`. numpy", "question_id": 18368}
{"snippet": "memmap.flags", "intent": "Information about the memory layout of the array. numpy", "question_id": 18369}
{"snippet": "char.chararray.T", "intent": "The transposed array. numpy", "question_id": 18370}
{"snippet": "random.RandomState.get_state()", "intent": "Return a tuple representing the internal state of the generator . numpy", "question_id": 18371}
{"snippet": "record.flags", "intent": "integer value of flags numpy", "question_id": 18372}
{"snippet": "recarray.choose(choices)", "intent": "Use an index array to construct a new array from a set of `choices` . numpy", "question_id": 18373}
{"snippet": "recarray.choose(choices, out=None)", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`. numpy", "question_id": 18374}
{"snippet": "recarray.choose(choices, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `mode`. numpy", "question_id": 18375}
{"snippet": "recarray.choose(choices, out=None, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`, `mode`. numpy", "question_id": 18376}
{"snippet": "ndarray.__ixor__(value, /)", "intent": "Return self^=value . With arguments `value`, `/`. numpy", "question_id": 18377}
{"snippet": "polynomial.laguerre.Laguerre.roots()", "intent": "Return the roots of the series polynomial . numpy", "question_id": 18378}
{"snippet": "polynomial.laguerre.poly2lag(pol)", "intent": "Convert a polynomial to a Laguerre series . With arguments `pol`. numpy", "question_id": 18379}
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, extobj)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `extobj`. numpy", "question_id": 18380}
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, extobj, out=(None)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `out`. numpy", "question_id": 18381}
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, extobj, where=True)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . Returns ( mantissa , exponent ) , `where` x = mantissa * 2 * * exponent ` . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `extobj`. numpy", "question_id": 18382}
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, extobj, casting='same_kind')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `casting`. numpy", "question_id": 18383}
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, extobj, order='K')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `order`. numpy", "question_id": 18384}
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, extobj, dtype=None)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `dtype`. numpy", "question_id": 18385}
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, extobj, subok=True)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `subok`. numpy", "question_id": 18386}
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, extobj, out=(None, where=True)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . Returns ( mantissa , exponent ) , `where` x = mantissa * 2 * * exponent ` . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `out`. numpy", "question_id": 18387}
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, extobj, out=(None, casting='same_kind')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 18388}
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, extobj, out=(None, order='K')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 18389}
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`. numpy", "question_id": 18390}
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, out=(None)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `out`. numpy", "question_id": 18391}
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, where=True)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . Returns ( mantissa , exponent ) , `where` x = mantissa * 2 * * exponent ` . With arguments `out1`, `out2`, `/`, `None)`, `signature`. numpy", "question_id": 18392}
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, casting='same_kind')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `casting`. numpy", "question_id": 18393}
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, order='K')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `order`. numpy", "question_id": 18394}
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, dtype=None)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `dtype`. numpy", "question_id": 18395}
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, subok=True)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `subok`. numpy", "question_id": 18396}
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, out=(None, where=True)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . Returns ( mantissa , exponent ) , `where` x = mantissa * 2 * * exponent ` . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `out`. numpy", "question_id": 18397}
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, out=(None, casting='same_kind')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `out`, `casting`. numpy", "question_id": 18398}
{"snippet": "numpy.frexp(x, out1, out2, /, None), signature, out=(None, order='K')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `signature`, `out`, `order`. numpy", "question_id": 18399}
{"snippet": "numpy.frexp(x, out1, out2, /, None))", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`. numpy", "question_id": 18400}
{"snippet": "numpy.frexp(x, out1, out2, /, None), out=(None)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `out`. numpy", "question_id": 18401}
{"snippet": "numpy.frexp(x, out1, out2, /, None), where=True)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . Returns ( mantissa , exponent ) , `where` x = mantissa * 2 * * exponent ` . With arguments `out1`, `out2`, `/`, `None)`. numpy", "question_id": 18402}
{"snippet": "numpy.frexp(x, out1, out2, /, None), casting='same_kind')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `casting`. numpy", "question_id": 18403}
{"snippet": "numpy.frexp(x, out1, out2, /, None), order='K')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `order`. numpy", "question_id": 18404}
{"snippet": "numpy.frexp(x, out1, out2, /, None), dtype=None)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `dtype`. numpy", "question_id": 18405}
{"snippet": "numpy.frexp(x, out1, out2, /, None), subok=True)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `subok`. numpy", "question_id": 18406}
{"snippet": "numpy.frexp(x, out1, out2, /, None), out=(None, where=True)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . Returns ( mantissa , exponent ) , `where` x = mantissa * 2 * * exponent ` . With arguments `out1`, `out2`, `/`, `None)`, `out`. numpy", "question_id": 18407}
{"snippet": "numpy.frexp(x, out1, out2, /, None), out=(None, casting='same_kind')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `out`, `casting`. numpy", "question_id": 18408}
{"snippet": "numpy.frexp(x, out1, out2, /, None), out=(None, order='K')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `None)`, `out`, `order`. numpy", "question_id": 18409}
{"snippet": "numpy.frexp(x, out1, out2, /)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`. numpy", "question_id": 18410}
{"snippet": "numpy.frexp(x, out1, out2, /, out=(None)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `out`. numpy", "question_id": 18411}
{"snippet": "numpy.frexp(x, out1, out2, /, where=True)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . Returns ( mantissa , exponent ) , `where` x = mantissa * 2 * * exponent ` . With arguments `out1`, `out2`, `/`. numpy", "question_id": 18412}
{"snippet": "numpy.frexp(x, out1, out2, /, casting='same_kind')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `casting`. numpy", "question_id": 18413}
{"snippet": "numpy.frexp(x, out1, out2, /, order='K')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `order`. numpy", "question_id": 18414}
{"snippet": "numpy.frexp(x, out1, out2, /, dtype=None)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `dtype`. numpy", "question_id": 18415}
{"snippet": "numpy.frexp(x, out1, out2, /, subok=True)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `subok`. numpy", "question_id": 18416}
{"snippet": "numpy.frexp(x, out1, out2, /, out=(None, where=True)", "intent": "Decompose the elements of `x` into mantissa and twos exponent . Returns ( mantissa , exponent ) , `where` x = mantissa * 2 * * exponent ` . With arguments `out1`, `out2`, `/`, `out`. numpy", "question_id": 18417}
{"snippet": "numpy.frexp(x, out1, out2, /, out=(None, casting='same_kind')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `out`, `casting`. numpy", "question_id": 18418}
{"snippet": "numpy.frexp(x, out1, out2, /, out=(None, order='K')", "intent": "Decompose the elements of `x` into mantissa and twos exponent . With arguments `out1`, `out2`, `/`, `out`, `order`. numpy", "question_id": 18419}
{"snippet": "random.Generator.logseries(p)", "intent": "Draw samples from a logarithmic series distribution . Samples are drawn from a log series distribution with specified shape parameter , 0 < `p` < 1 . numpy", "question_id": 18420}
{"snippet": "random.Generator.logseries(p, size=None)", "intent": "Draw samples from a logarithmic series distribution . Samples are drawn from a log series distribution with specified shape parameter , 0 < `p` < 1 . With arguments `size`. numpy", "question_id": 18421}
{"snippet": "ndarray.__new__(*args, **kwargs)", "intent": "Create and return a new object . With arguments `*args`, `**kwargs`. numpy", "question_id": 18422}
{"snippet": "recarray.ptp()", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . numpy", "question_id": 18423}
{"snippet": "recarray.ptp(axis=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . numpy", "question_id": 18424}
{"snippet": "recarray.ptp(out=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`. numpy", "question_id": 18425}
{"snippet": "recarray.ptp(keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `keepdims`. numpy", "question_id": 18426}
{"snippet": "recarray.ptp(axis=None, out=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`. numpy", "question_id": 18427}
{"snippet": "recarray.ptp(axis=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `keepdims`. numpy", "question_id": 18428}
{"snippet": "recarray.ptp(out=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`, `keepdims`. numpy", "question_id": 18429}
{"snippet": "recarray.ptp(axis=None, out=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`, `keepdims`. numpy", "question_id": 18430}
{"snippet": "ma.MaskedArray.__rlshift__(value, /)", "intent": "Return `value` < < self . With arguments `/`. numpy", "question_id": 18431}
{"snippet": "numpy.floor_divide(x1, x2, /, signature, extobj)", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `extobj`. numpy", "question_id": 18432}
{"snippet": "numpy.floor_divide(x1, x2, /, signature, extobj, out=None)", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 18433}
{"snippet": "numpy.floor_divide(x1, x2, /, signature, extobj, where=True)", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `where`. numpy", "question_id": 18434}
{"snippet": "numpy.floor_divide(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 18435}
{"snippet": "numpy.floor_divide(x1, x2, /, signature, extobj, order='K')", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 18436}
{"snippet": "numpy.floor_divide(x1, x2, /, signature, extobj, dtype=None)", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 18437}
{"snippet": "numpy.floor_divide(x1, x2, /, signature, extobj, subok=True)", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 18438}
{"snippet": "numpy.floor_divide(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 18439}
{"snippet": "numpy.floor_divide(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 18440}
{"snippet": "numpy.floor_divide(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 18441}
{"snippet": "numpy.floor_divide(x1, x2, /, signature)", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`. numpy", "question_id": 18442}
{"snippet": "numpy.floor_divide(x1, x2, /, signature, out=None)", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `out`. numpy", "question_id": 18443}
{"snippet": "numpy.floor_divide(x1, x2, /, signature, where=True)", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `where`. numpy", "question_id": 18444}
{"snippet": "numpy.floor_divide(x1, x2, /, signature, casting='same_kind')", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `casting`. numpy", "question_id": 18445}
{"snippet": "numpy.floor_divide(x1, x2, /, signature, order='K')", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `order`. numpy", "question_id": 18446}
{"snippet": "numpy.floor_divide(x1, x2, /, signature, dtype=None)", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `dtype`. numpy", "question_id": 18447}
{"snippet": "numpy.floor_divide(x1, x2, /, signature, subok=True)", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `subok`. numpy", "question_id": 18448}
{"snippet": "numpy.floor_divide(x1, x2, /, signature, out=None, where=True)", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `out`, `where`. numpy", "question_id": 18449}
{"snippet": "numpy.floor_divide(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `out`, `casting`. numpy", "question_id": 18450}
{"snippet": "numpy.floor_divide(x1, x2, /, signature, out=None, order='K')", "intent": "Return the largest integer smaller or equal to the division of the inputs . With arguments `x1`, `x2`, `/`, `signature`, `out`, `order`. numpy", "question_id": 18451}
{"snippet": "ma.MaskedArray.dump(file)", "intent": "Dump a pickle of the array to the specified `file` . numpy", "question_id": 18452}
{"snippet": "polynomial.polynomial.polyvander3d(x, y, z, deg)", "intent": "Pseudo-Vandermonde matrix of given degrees . Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points ( `x` , `y` , `z` ) . numpy", "question_id": 18453}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_untied(names)", "intent": "same as \u2018 feature_ahead ( ) \u2019 but if both features implied each other and keep the highest interest . With arguments `names`. numpy", "question_id": 18454}
{"snippet": "ma.MaskedArray.__rsub__(other)", "intent": "Subtract self from `other` , and return a new masked array . numpy", "question_id": 18455}
{"snippet": "polynomial.chebyshev.chebline(off, scl)", "intent": "Chebyshev series whose graph is a straight line . With arguments `off`, `scl`. numpy", "question_id": 18456}
{"snippet": "ma.MaskedArray.flatten()", "intent": "Return a copy of the array collapsed into one dimension . numpy", "question_id": 18457}
{"snippet": "ma.MaskedArray.flatten(order='C')", "intent": "Return a copy of the array collapsed into one dimension . With arguments `order`. numpy", "question_id": 18458}
{"snippet": "random.RandomState.standard_cauchy()", "intent": "Draw samples from a standard Cauchy distribution with mode = 0 . numpy", "question_id": 18459}
{"snippet": "random.RandomState.standard_cauchy(size=None)", "intent": "Draw samples from a standard Cauchy distribution with mode = 0 . With arguments `size`. numpy", "question_id": 18460}
{"snippet": "dtype.isnative", "intent": "Boolean indicating whether the byte order of this dtype is native to the platform. numpy", "question_id": 18461}
{"snippet": "random.RandomState.wald(mean, scale)", "intent": "Draw samples from a Wald , or inverse Gaussian , distribution . Some references claim that the Wald is an inverse Gaussian with `mean` equal to 1 , but this is by no means universal . As the `scale` approaches infinity , the distribution becomes more like a Gaussian . numpy", "question_id": 18462}
{"snippet": "random.RandomState.wald(mean, scale, size=None)", "intent": "Draw samples from a Wald , or inverse Gaussian , distribution . Some references claim that the Wald is an inverse Gaussian with `mean` equal to 1 , but this is by no means universal . As the `scale` approaches infinity , the distribution becomes more like a Gaussian . With arguments `size`. numpy", "question_id": 18463}
{"snippet": "ma.ones(shape)", "intent": "Return a new array of given `shape` and type , filled with ones . numpy", "question_id": 18464}
{"snippet": "ma.ones(shape, dtype=None)", "intent": "Return a new array of given `shape` and type , filled with ones . With arguments `dtype`. numpy", "question_id": 18465}
{"snippet": "ma.ones(shape, order='C')", "intent": "Return a new array of given `shape` and type , filled with ones . With arguments `order`. numpy", "question_id": 18466}
{"snippet": "ma.ones(shape, dtype=None, order='C')", "intent": "Return a new array of given `shape` and type , filled with ones . With arguments `dtype`, `order`. numpy", "question_id": 18467}
{"snippet": "numpy.unwrap(p)", "intent": "Unwrap by taking the complement of large deltas with respect to the `period` . This unwraps a signal `p` by changing elements which have an absolute difference from their predecessor of more than max ( `discont` , period/2 ) to their period-complementary values . numpy", "question_id": 18468}
{"snippet": "numpy.unwrap(p, discont=None)", "intent": "Unwrap by taking the complement of large deltas with respect to the `period` . This unwraps a signal `p` by changing elements which have an absolute difference from their predecessor of more than max ( `discont` , period/2 ) to their period-complementary values . numpy", "question_id": 18469}
{"snippet": "numpy.unwrap(p, axis=- 1)", "intent": "Unwrap by taking the complement of large deltas with respect to the `period` . This unwraps a signal `p` by changing elements which have an absolute difference from their predecessor of more than max ( `discont` , period/2 ) to their period-complementary values . With arguments `axis`. numpy", "question_id": 18470}
{"snippet": "numpy.unwrap(p, period=6.283185307179586)", "intent": "Unwrap by taking the complement of large deltas with respect to the `period` . This unwraps a signal `p` by changing elements which have an absolute difference from their predecessor of more than max ( `discont` , period/2 ) to their period-complementary values . numpy", "question_id": 18471}
{"snippet": "numpy.unwrap(p, discont=None, axis=- 1)", "intent": "Unwrap by taking the complement of large deltas with respect to the `period` . This unwraps a signal `p` by changing elements which have an absolute difference from their predecessor of more than max ( `discont` , period/2 ) to their period-complementary values . With arguments `axis`. numpy", "question_id": 18472}
{"snippet": "numpy.unwrap(p, discont=None, period=6.283185307179586)", "intent": "Unwrap by taking the complement of large deltas with respect to the `period` . This unwraps a signal `p` by changing elements which have an absolute difference from their predecessor of more than max ( `discont` , period/2 ) to their period-complementary values . numpy", "question_id": 18473}
{"snippet": "numpy.unwrap(p, axis=- 1, period=6.283185307179586)", "intent": "Unwrap by taking the complement of large deltas with respect to the `period` . This unwraps a signal `p` by changing elements which have an absolute difference from their predecessor of more than max ( `discont` , period/2 ) to their period-complementary values . With arguments `axis`. numpy", "question_id": 18474}
{"snippet": "numpy.unwrap(p, discont=None, axis=- 1, period=6.283185307179586)", "intent": "Unwrap by taking the complement of large deltas with respect to the `period` . This unwraps a signal `p` by changing elements which have an absolute difference from their predecessor of more than max ( `discont` , period/2 ) to their period-complementary values . With arguments `axis`. numpy", "question_id": 18475}
{"snippet": "polynomial.legendre.Legendre.cast(series)", "intent": "Convert `series` to series of this class . numpy", "question_id": 18476}
{"snippet": "polynomial.legendre.Legendre.cast(series, domain=None)", "intent": "Convert `series` to series of this class . With arguments `domain`. numpy", "question_id": 18477}
{"snippet": "polynomial.legendre.Legendre.cast(series, window=None)", "intent": "Convert `series` to series of this class . With arguments `window`. numpy", "question_id": 18478}
{"snippet": "polynomial.legendre.Legendre.cast(series, domain=None, window=None)", "intent": "Convert `series` to series of this class . With arguments `domain`, `window`. numpy", "question_id": 18479}
{"snippet": "numpy.argwhere(a)", "intent": "Find the indices of array elements that are non-zero , grouped by element . np.argwhere ( `a` ) is almost the same as np.transpose ( np.nonzero ( a ) ) , but produces a result of the correct shape for a 0D array . numpy", "question_id": 18480}
{"snippet": "ndarray.nonzero()", "intent": "Return the indices of the elements that are non-zero . numpy", "question_id": 18481}
{"snippet": "numpy.roll(a, shift)", "intent": "Roll array elements along `a` given `axis` . With arguments `shift`. numpy", "question_id": 18482}
{"snippet": "numpy.roll(a, shift, axis=None)", "intent": "Roll array elements along `a` given `axis` . With arguments `shift`. numpy", "question_id": 18483}
{"snippet": "numpy.true_divide(x1, x2, /, signature, extobj)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`. numpy", "question_id": 18484}
{"snippet": "numpy.true_divide(x1, x2, /, signature, extobj, out=None)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `out`. numpy", "question_id": 18485}
{"snippet": "numpy.true_divide(x1, x2, /, signature, extobj, where=True)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `where`. numpy", "question_id": 18486}
{"snippet": "numpy.true_divide(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `casting`. numpy", "question_id": 18487}
{"snippet": "numpy.true_divide(x1, x2, /, signature, extobj, order='K')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `order`. numpy", "question_id": 18488}
{"snippet": "numpy.true_divide(x1, x2, /, signature, extobj, dtype=None)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `dtype`. numpy", "question_id": 18489}
{"snippet": "numpy.true_divide(x1, x2, /, signature, extobj, subok=True)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `subok`. numpy", "question_id": 18490}
{"snippet": "numpy.true_divide(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `out`, `where`. numpy", "question_id": 18491}
{"snippet": "numpy.true_divide(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 18492}
{"snippet": "numpy.true_divide(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `extobj`, `out`, `order`. numpy", "question_id": 18493}
{"snippet": "numpy.true_divide(x1, x2, /, signature)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`. numpy", "question_id": 18494}
{"snippet": "numpy.true_divide(x1, x2, /, signature, out=None)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `out`. numpy", "question_id": 18495}
{"snippet": "numpy.true_divide(x1, x2, /, signature, where=True)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `where`. numpy", "question_id": 18496}
{"snippet": "numpy.true_divide(x1, x2, /, signature, casting='same_kind')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `casting`. numpy", "question_id": 18497}
{"snippet": "numpy.true_divide(x1, x2, /, signature, order='K')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `order`. numpy", "question_id": 18498}
{"snippet": "numpy.true_divide(x1, x2, /, signature, dtype=None)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `dtype`. numpy", "question_id": 18499}
{"snippet": "numpy.true_divide(x1, x2, /, signature, subok=True)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `subok`. numpy", "question_id": 18500}
{"snippet": "numpy.true_divide(x1, x2, /, signature, out=None, where=True)", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `out`, `where`. numpy", "question_id": 18501}
{"snippet": "numpy.true_divide(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `out`, `casting`. numpy", "question_id": 18502}
{"snippet": "numpy.true_divide(x1, x2, /, signature, out=None, order='K')", "intent": "Returns a true division of the inputs , element-wise . The true_divide ( `x1` , `x2` ) function is equivalent to true division in Python . In Python , // is the floor division operator and `/` the true division operator . With arguments `signature`, `out`, `order`. numpy", "question_id": 18503}
{"snippet": "ma.cumprod(self)", "intent": "Return the cumulative product of the array elements over the given `axis` . With arguments `self`. numpy", "question_id": 18504}
{"snippet": "ma.cumprod(self, axis=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . With arguments `self`. numpy", "question_id": 18505}
{"snippet": "ma.cumprod(self, dtype=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . With arguments `self`, `dtype`. numpy", "question_id": 18506}
{"snippet": "ma.cumprod(self, out=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . The mask is lost if `out` is not a valid MaskedArray ! With arguments `self`. numpy", "question_id": 18507}
{"snippet": "ma.cumprod(self, axis=None, dtype=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . With arguments `self`, `dtype`. numpy", "question_id": 18508}
{"snippet": "ma.cumprod(self, axis=None, out=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . The mask is lost if `out` is not a valid MaskedArray ! With arguments `self`. numpy", "question_id": 18509}
{"snippet": "ma.cumprod(self, dtype=None, out=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . The mask is lost if `out` is not a valid MaskedArray ! With arguments `self`, `dtype`. numpy", "question_id": 18510}
{"snippet": "ma.cumprod(self, axis=None, dtype=None, out=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . The mask is lost if `out` is not a valid MaskedArray ! With arguments `self`, `dtype`. numpy", "question_id": 18511}
{"snippet": "matrix.cumsum()", "intent": "Return the cumulative sum of the elements along the given `axis` . numpy", "question_id": 18512}
{"snippet": "matrix.cumsum(axis=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . numpy", "question_id": 18513}
{"snippet": "matrix.cumsum(dtype=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 18514}
{"snippet": "matrix.cumsum(out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `out`. numpy", "question_id": 18515}
{"snippet": "matrix.cumsum(axis=None, dtype=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 18516}
{"snippet": "matrix.cumsum(axis=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `out`. numpy", "question_id": 18517}
{"snippet": "matrix.cumsum(dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 18518}
{"snippet": "matrix.cumsum(axis=None, dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 18519}
{"snippet": "ma.MaskType.data", "intent": "Pointer to start of data. numpy", "question_id": 18520}
{"snippet": "ndarray.choose(choices)", "intent": "Use an index array to construct a new array from a set of `choices` . numpy", "question_id": 18521}
{"snippet": "ndarray.choose(choices, out=None)", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`. numpy", "question_id": 18522}
{"snippet": "ndarray.choose(choices, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `mode`. numpy", "question_id": 18523}
{"snippet": "ndarray.choose(choices, out=None, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`, `mode`. numpy", "question_id": 18524}
{"snippet": "memmap.nonzero()", "intent": "Return the indices of the elements that are non-zero . numpy", "question_id": 18525}
{"snippet": "numpy.searchsorted(a, v)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into `a` sorted array a such that , if the corresponding elements in `v` were inserted before the indices , the order of a would be preserved . numpy", "question_id": 18526}
{"snippet": "numpy.searchsorted(a, v, side='left')", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into `a` sorted array a such that , if the corresponding elements in `v` were inserted before the indices , the order of a would be preserved . With arguments `side`. numpy", "question_id": 18527}
{"snippet": "numpy.searchsorted(a, v, sorter=None)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into `a` sorted array a such that , if the corresponding elements in `v` were inserted before the indices , the order of a would be preserved . With arguments `sorter`. numpy", "question_id": 18528}
{"snippet": "numpy.searchsorted(a, v, side='left', sorter=None)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into `a` sorted array a such that , if the corresponding elements in `v` were inserted before the indices , the order of a would be preserved . With arguments `side`, `sorter`. numpy", "question_id": 18529}
{"snippet": "fft.rfft2(a, - 1))", "intent": "Compute the 2-dimensional FFT of `a` real array . With arguments `- 1)`. numpy", "question_id": 18530}
{"snippet": "fft.rfft2(a, - 1), s=None)", "intent": "Compute the 2-dimensional FFT of `a` real array . With arguments `- 1)`, `s`. numpy", "question_id": 18531}
{"snippet": "fft.rfft2(a, - 1), axes=(- 2)", "intent": "Compute the 2-dimensional FFT of `a` real array . With arguments `- 1)`, `axes`. numpy", "question_id": 18532}
{"snippet": "fft.rfft2(a, - 1), norm=None)", "intent": "Compute the 2-dimensional FFT of `a` real array . With arguments `- 1)`, `norm`. numpy", "question_id": 18533}
{"snippet": "fft.rfft2(a, - 1), s=None, axes=(- 2)", "intent": "Compute the 2-dimensional FFT of `a` real array . With arguments `- 1)`, `s`, `axes`. numpy", "question_id": 18534}
{"snippet": "fft.rfft2(a, - 1), s=None, norm=None)", "intent": "Compute the 2-dimensional FFT of `a` real array . With arguments `- 1)`, `s`, `norm`. numpy", "question_id": 18535}
{"snippet": "fft.rfft2(a, - 1), axes=(- 2, norm=None)", "intent": "Compute the 2-dimensional FFT of `a` real array . With arguments `- 1)`, `axes`, `norm`. numpy", "question_id": 18536}
{"snippet": "fft.rfft2(a, - 1), s=None, axes=(- 2, norm=None)", "intent": "Compute the 2-dimensional FFT of `a` real array . With arguments `- 1)`, `s`, `axes`, `norm`. numpy", "question_id": 18537}
{"snippet": "chararray.tolist()", "intent": "Return the array as an a.ndim-levels deep nested list of Python scalars . numpy", "question_id": 18538}
{"snippet": "chararray.ljust(width)", "intent": "Return an array with the elements of self left-justified in a string of length `width` . numpy", "question_id": 18539}
{"snippet": "chararray.ljust(width, fillchar=' ')", "intent": "Return an array with the elements of self left-justified in a string of length `width` . With arguments `fillchar`. numpy", "question_id": 18540}
{"snippet": "random.Generator.shuffle(x)", "intent": "Modify an array or sequence in-place by shuffling its contents . With arguments `x`. numpy", "question_id": 18541}
{"snippet": "random.Generator.shuffle(x, axis=0)", "intent": "Modify an array or sequence in-place by shuffling its contents . With arguments `x`, `axis`. numpy", "question_id": 18542}
{"snippet": "numpy.get_include()", "intent": "Return the directory that contains the NumPy * .h header files . numpy", "question_id": 18543}
{"snippet": "matlib.repmat(a, m, n)", "intent": "Repeat `a` 0-D to 2-D array or matrix MxN times . With arguments `m`, `n`. numpy", "question_id": 18544}
{"snippet": "random.Generator.gamma(shape)", "intent": "Draw samples from a Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and `scale` ( sometimes designated \u201c theta \u201d ) , where both parameters are > 0 . numpy", "question_id": 18545}
{"snippet": "random.Generator.gamma(shape, scale=1.0)", "intent": "Draw samples from a Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and `scale` ( sometimes designated \u201c theta \u201d ) , where both parameters are > 0 . numpy", "question_id": 18546}
{"snippet": "random.Generator.gamma(shape, size=None)", "intent": "Draw samples from a Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and `scale` ( sometimes designated \u201c theta \u201d ) , where both parameters are > 0 . With arguments `size`. numpy", "question_id": 18547}
{"snippet": "random.Generator.gamma(shape, scale=1.0, size=None)", "intent": "Draw samples from a Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and `scale` ( sometimes designated \u201c theta \u201d ) , where both parameters are > 0 . With arguments `size`. numpy", "question_id": 18548}
{"snippet": "char.chararray.max()", "intent": "Return the maximum along a given `axis` . numpy", "question_id": 18549}
{"snippet": "char.chararray.max(axis=None)", "intent": "Return the maximum along a given `axis` . numpy", "question_id": 18550}
{"snippet": "char.chararray.max(out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`. numpy", "question_id": 18551}
{"snippet": "char.chararray.max(keepdims=False)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 18552}
{"snippet": "char.chararray.max(initial=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `initial`. numpy", "question_id": 18553}
{"snippet": "char.chararray.max(where=True)", "intent": "Return the maximum along a given `axis` . With arguments `where`. numpy", "question_id": 18554}
{"snippet": "char.chararray.max(axis=None, out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`. numpy", "question_id": 18555}
{"snippet": "char.chararray.max(axis=None, keepdims=False)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 18556}
{"snippet": "char.chararray.max(axis=None, initial=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `initial`. numpy", "question_id": 18557}
{"snippet": "char.chararray.max(axis=None, where=True)", "intent": "Return the maximum along a given `axis` . With arguments `where`. numpy", "question_id": 18558}
{"snippet": "polynomial.hermite.hermpow(c, pow)", "intent": "Raise a Hermite series to a power . Returns the Hermite series `c` raised to the power `pow` . numpy", "question_id": 18559}
{"snippet": "polynomial.hermite.hermpow(c, pow, maxpower=16)", "intent": "Raise a Hermite series to a power . Returns the Hermite series `c` raised to the power `pow` . With arguments `maxpower`. numpy", "question_id": 18560}
{"snippet": "char.chararray.replace(old, new)", "intent": "For each element in self , return a copy of the string with all occurrences of substring `old` replaced by `new` . numpy", "question_id": 18561}
{"snippet": "char.chararray.replace(old, new, count=None)", "intent": "For each element in self , return a copy of the string with all occurrences of substring `old` replaced by `new` . With arguments `count`. numpy", "question_id": 18562}
{"snippet": "ma.masked_array.product()", "intent": "Return the product of the array elements over the given `axis` . numpy", "question_id": 18563}
{"snippet": "ma.masked_array.product(axis=None)", "intent": "Return the product of the array elements over the given `axis` . numpy", "question_id": 18564}
{"snippet": "ma.masked_array.product(dtype=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 18565}
{"snippet": "ma.masked_array.product(out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `out`. numpy", "question_id": 18566}
{"snippet": "ma.masked_array.product(keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `keepdims`. numpy", "question_id": 18567}
{"snippet": "ma.masked_array.product(axis=None, dtype=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 18568}
{"snippet": "ma.masked_array.product(axis=None, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `out`. numpy", "question_id": 18569}
{"snippet": "ma.masked_array.product(axis=None, keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `keepdims`. numpy", "question_id": 18570}
{"snippet": "ma.masked_array.product(dtype=None, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 18571}
{"snippet": "ma.masked_array.product(dtype=None, keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`, `keepdims`. numpy", "question_id": 18572}
{"snippet": "polynomial.chebyshev.chebmul(c1, c2)", "intent": "Multiply one Chebyshev series by another . Returns the product of two Chebyshev series `c1` * `c2` . numpy", "question_id": 18573}
{"snippet": "record.pprint()", "intent": "Pretty-print all fields . numpy", "question_id": 18574}
{"snippet": "chararray.astype(dtype)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`. numpy", "question_id": 18575}
{"snippet": "chararray.astype(dtype, order='K')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`. numpy", "question_id": 18576}
{"snippet": "chararray.astype(dtype, casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`. numpy", "question_id": 18577}
{"snippet": "chararray.astype(dtype, subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `subok`. numpy", "question_id": 18578}
{"snippet": "chararray.astype(dtype, copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `copy`. numpy", "question_id": 18579}
{"snippet": "chararray.astype(dtype, order='K', casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `casting`. numpy", "question_id": 18580}
{"snippet": "chararray.astype(dtype, order='K', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `subok`. numpy", "question_id": 18581}
{"snippet": "chararray.astype(dtype, order='K', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `copy`. numpy", "question_id": 18582}
{"snippet": "chararray.astype(dtype, casting='unsafe', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `subok`. numpy", "question_id": 18583}
{"snippet": "chararray.astype(dtype, casting='unsafe', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `copy`. numpy", "question_id": 18584}
{"snippet": "ufunc.types", "intent": "Returns a list with types grouped input->output. numpy", "question_id": 18585}
{"snippet": "ma.MaskedArray.itemsize", "intent": "Length of one array element in bytes. numpy", "question_id": 18586}
{"snippet": "chararray.expandtabs()", "intent": "Return a copy of each string element where all tab characters are replaced by one or more spaces . numpy", "question_id": 18587}
{"snippet": "chararray.expandtabs(tabsize=8)", "intent": "Return a copy of each string element where all tab characters are replaced by one or more spaces . With arguments `tabsize`. numpy", "question_id": 18588}
{"snippet": "record.conjugate()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 18589}
{"snippet": "polynomial.legendre.Legendre.fit(x, y, deg)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`. numpy", "question_id": 18590}
{"snippet": "polynomial.legendre.Legendre.fit(x, y, deg, domain=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`. numpy", "question_id": 18591}
{"snippet": "polynomial.legendre.Legendre.fit(x, y, deg, rcond=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `rcond`. numpy", "question_id": 18592}
{"snippet": "polynomial.legendre.Legendre.fit(x, y, deg, full=False)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `full`. numpy", "question_id": 18593}
{"snippet": "polynomial.legendre.Legendre.fit(x, y, deg, w=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `w`. numpy", "question_id": 18594}
{"snippet": "polynomial.legendre.Legendre.fit(x, y, deg, window=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `window`. numpy", "question_id": 18595}
{"snippet": "polynomial.legendre.Legendre.fit(x, y, deg, domain=None, rcond=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `rcond`. numpy", "question_id": 18596}
{"snippet": "polynomial.legendre.Legendre.fit(x, y, deg, domain=None, full=False)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `full`. numpy", "question_id": 18597}
{"snippet": "polynomial.legendre.Legendre.fit(x, y, deg, domain=None, w=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `w`. numpy", "question_id": 18598}
{"snippet": "polynomial.legendre.Legendre.fit(x, y, deg, domain=None, window=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `window`. numpy", "question_id": 18599}
{"snippet": "numpy.split(ary, indices_or_sections)", "intent": "Split an array into multiple sub-arrays as views into `ary` . With arguments `indices_or_sections`. numpy", "question_id": 18600}
{"snippet": "numpy.split(ary, indices_or_sections, axis=0)", "intent": "Split an array into multiple sub-arrays as views into `ary` . With arguments `indices_or_sections`, `axis`. numpy", "question_id": 18601}
{"snippet": "recarray.put(indices, values)", "intent": "Set a.flat [ n ] = `values` [ n ] for all n in `indices` . numpy", "question_id": 18602}
{"snippet": "recarray.put(indices, values, mode='raise')", "intent": "Set a.flat [ n ] = `values` [ n ] for all n in `indices` . With arguments `mode`. numpy", "question_id": 18603}
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, extobj)", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`. numpy", "question_id": 18604}
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, extobj, out=None)", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 18605}
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, extobj, where=True)", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `where`. numpy", "question_id": 18606}
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 18607}
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, extobj, order='K')", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 18608}
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, extobj, dtype=None)", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 18609}
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, extobj, subok=True)", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 18610}
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 18611}
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 18612}
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 18613}
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature)", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`. numpy", "question_id": 18614}
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, out=None)", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `out`. numpy", "question_id": 18615}
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, where=True)", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `where`. numpy", "question_id": 18616}
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, casting='same_kind')", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `casting`. numpy", "question_id": 18617}
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, order='K')", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `order`. numpy", "question_id": 18618}
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, dtype=None)", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `dtype`. numpy", "question_id": 18619}
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, subok=True)", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `subok`. numpy", "question_id": 18620}
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, out=None, where=True)", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `out`, `where`. numpy", "question_id": 18621}
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `out`, `casting`. numpy", "question_id": 18622}
{"snippet": "numpy.bitwise_xor(x1, x2, /, signature, out=None, order='K')", "intent": "Compute the bit-wise XOR of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `out`, `order`. numpy", "question_id": 18623}
{"snippet": "random.get_state()", "intent": "Return a tuple representing the internal state of the generator . numpy", "question_id": 18624}
{"snippet": "ma.MaskedArray.max()", "intent": "Return the maximum along a given `axis` . numpy", "question_id": 18625}
{"snippet": "ma.MaskedArray.max(axis=None)", "intent": "Return the maximum along a given `axis` . numpy", "question_id": 18626}
{"snippet": "ma.MaskedArray.max(out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`. numpy", "question_id": 18627}
{"snippet": "ma.MaskedArray.max(fill_value=None)", "intent": "Return the maximum along a given `axis` . With arguments `fill_value`. numpy", "question_id": 18628}
{"snippet": "ma.MaskedArray.max(keepdims=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 18629}
{"snippet": "ma.MaskedArray.max(axis=None, out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`. numpy", "question_id": 18630}
{"snippet": "ma.MaskedArray.max(axis=None, fill_value=None)", "intent": "Return the maximum along a given `axis` . With arguments `fill_value`. numpy", "question_id": 18631}
{"snippet": "ma.MaskedArray.max(axis=None, keepdims=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 18632}
{"snippet": "ma.MaskedArray.max(out=None, fill_value=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`, `fill_value`. numpy", "question_id": 18633}
{"snippet": "ma.MaskedArray.max(out=None, keepdims=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `out`, `keepdims`. numpy", "question_id": 18634}
{"snippet": "random.Generator.uniform()", "intent": "Draw samples from a uniform distribution . numpy", "question_id": 18635}
{"snippet": "random.Generator.uniform(low=0.0)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . numpy", "question_id": 18636}
{"snippet": "random.Generator.uniform(high=1.0)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . numpy", "question_id": 18637}
{"snippet": "random.Generator.uniform(size=None)", "intent": "Draw samples from a uniform distribution . With arguments `size`. numpy", "question_id": 18638}
{"snippet": "random.Generator.uniform(low=0.0, high=1.0)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . numpy", "question_id": 18639}
{"snippet": "random.Generator.uniform(low=0.0, size=None)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . With arguments `size`. numpy", "question_id": 18640}
{"snippet": "random.Generator.uniform(high=1.0, size=None)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . With arguments `size`. numpy", "question_id": 18641}
{"snippet": "random.Generator.uniform(low=0.0, high=1.0, size=None)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . With arguments `size`. numpy", "question_id": 18642}
{"snippet": "poly1d.__call__(val)", "intent": "Call self as a function . With arguments `val`. numpy", "question_id": 18643}
{"snippet": "char.decode(a)", "intent": "Calls str.decode element-wise . With arguments `a`. numpy", "question_id": 18644}
{"snippet": "char.decode(a, encoding=None)", "intent": "Calls str.decode element-wise . The type of the result will depend on the `encoding` specified . With arguments `a`. numpy", "question_id": 18645}
{"snippet": "char.decode(a, errors=None)", "intent": "Calls str.decode element-wise . With arguments `a`, `errors`. numpy", "question_id": 18646}
{"snippet": "char.decode(a, encoding=None, errors=None)", "intent": "Calls str.decode element-wise . The type of the result will depend on the `encoding` specified . With arguments `a`, `errors`. numpy", "question_id": 18647}
{"snippet": "numpy.ones_like(a)", "intent": "Return an array of ones with the same `shape` and type as `a` given array . numpy", "question_id": 18648}
{"snippet": "numpy.ones_like(a, dtype=None)", "intent": "Return an array of ones with the same `shape` and type as `a` given array . With arguments `dtype`. numpy", "question_id": 18649}
{"snippet": "numpy.ones_like(a, order='K')", "intent": "Return an array of ones with the same `shape` and type as `a` given array . With arguments `order`. numpy", "question_id": 18650}
{"snippet": "numpy.ones_like(a, subok=True)", "intent": "Return an array of ones with the same `shape` and type as `a` given array . With arguments `subok`. numpy", "question_id": 18651}
{"snippet": "numpy.ones_like(a, shape=None)", "intent": "Return an array of ones with the same `shape` and type as `a` given array . numpy", "question_id": 18652}
{"snippet": "numpy.ones_like(a, dtype=None, order='K')", "intent": "Return an array of ones with the same `shape` and type as `a` given array . With arguments `dtype`, `order`. numpy", "question_id": 18653}
{"snippet": "numpy.ones_like(a, dtype=None, subok=True)", "intent": "Return an array of ones with the same `shape` and type as `a` given array . With arguments `dtype`, `subok`. numpy", "question_id": 18654}
{"snippet": "numpy.ones_like(a, dtype=None, shape=None)", "intent": "Return an array of ones with the same `shape` and type as `a` given array . With arguments `dtype`. numpy", "question_id": 18655}
{"snippet": "numpy.ones_like(a, order='K', subok=True)", "intent": "Return an array of ones with the same `shape` and type as `a` given array . With arguments `order`, `subok`. numpy", "question_id": 18656}
{"snippet": "numpy.ones_like(a, order='K', shape=None)", "intent": "Return an array of ones with the same `shape` and type as `a` given array . With arguments `order`. numpy", "question_id": 18657}
{"snippet": "ndarray.conj()", "intent": "Complex-conjugate all elements . numpy", "question_id": 18658}
{"snippet": "memmap.ptp()", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . numpy", "question_id": 18659}
{"snippet": "memmap.ptp(axis=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . numpy", "question_id": 18660}
{"snippet": "memmap.ptp(out=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`. numpy", "question_id": 18661}
{"snippet": "memmap.ptp(keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `keepdims`. numpy", "question_id": 18662}
{"snippet": "memmap.ptp(axis=None, out=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`. numpy", "question_id": 18663}
{"snippet": "memmap.ptp(axis=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `keepdims`. numpy", "question_id": 18664}
{"snippet": "memmap.ptp(out=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`, `keepdims`. numpy", "question_id": 18665}
{"snippet": "memmap.ptp(axis=None, out=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`, `keepdims`. numpy", "question_id": 18666}
{"snippet": "random.Generator.lognormal()", "intent": "Draw samples from a log-normal distribution . numpy", "question_id": 18667}
{"snippet": "random.Generator.lognormal(mean=0.0)", "intent": "Draw samples from a log-normal distribution . Draw samples from a log-normal distribution with specified `mean` , standard deviation , and array shape . numpy", "question_id": 18668}
{"snippet": "random.Generator.lognormal(sigma=1.0)", "intent": "Draw samples from a log-normal distribution . With arguments `sigma`. numpy", "question_id": 18669}
{"snippet": "random.Generator.lognormal(size=None)", "intent": "Draw samples from a log-normal distribution . With arguments `size`. numpy", "question_id": 18670}
{"snippet": "random.Generator.lognormal(mean=0.0, sigma=1.0)", "intent": "Draw samples from a log-normal distribution . Draw samples from a log-normal distribution with specified `mean` , standard deviation , and array shape . With arguments `sigma`. numpy", "question_id": 18671}
{"snippet": "random.Generator.lognormal(mean=0.0, size=None)", "intent": "Draw samples from a log-normal distribution . Draw samples from a log-normal distribution with specified `mean` , standard deviation , and array shape . With arguments `size`. numpy", "question_id": 18672}
{"snippet": "random.Generator.lognormal(sigma=1.0, size=None)", "intent": "Draw samples from a log-normal distribution . With arguments `sigma`, `size`. numpy", "question_id": 18673}
{"snippet": "random.Generator.lognormal(mean=0.0, sigma=1.0, size=None)", "intent": "Draw samples from a log-normal distribution . Draw samples from a log-normal distribution with specified `mean` , standard deviation , and array shape . With arguments `sigma`, `size`. numpy", "question_id": 18674}
{"snippet": "numpy.dot(a, b)", "intent": "Dot product of two arrays . With arguments `a`, `b`. numpy", "question_id": 18675}
{"snippet": "numpy.dot(a, b, out=None)", "intent": "Dot product of two arrays . With arguments `a`, `b`, `out`. numpy", "question_id": 18676}
{"snippet": "char.isalnum(a)", "intent": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character , false otherwise . With arguments `a`. numpy", "question_id": 18677}
{"snippet": "numpy.printoptions(*args, **kwargs)", "intent": "Context manager for setting print options . With arguments `*args`, `**kwargs`. numpy", "question_id": 18678}
{"snippet": "ndarray.swapaxes(axis1, axis2)", "intent": "Return a view of the array with `axis1` and `axis2` interchanged . numpy", "question_id": 18679}
{"snippet": "chararray.partition(sep)", "intent": "Partition each element in self around `sep` . numpy", "question_id": 18680}
{"snippet": "chararray.endswith(suffix)", "intent": "Returns a boolean array which is True where the string element in self ends with `suffix` , otherwise False . numpy", "question_id": 18681}
{"snippet": "chararray.endswith(suffix, start=0)", "intent": "Returns a boolean array which is True where the string element in self ends with `suffix` , otherwise False . With arguments `start`. numpy", "question_id": 18682}
{"snippet": "chararray.endswith(suffix, end=None)", "intent": "Returns a boolean array which is True where the string element in self ends with `suffix` , otherwise False . With arguments `end`. numpy", "question_id": 18683}
{"snippet": "chararray.endswith(suffix, start=0, end=None)", "intent": "Returns a boolean array which is True where the string element in self ends with `suffix` , otherwise False . With arguments `start`, `end`. numpy", "question_id": 18684}
{"snippet": "numpy.nancumsum(a)", "intent": "Return the cumulative sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . numpy", "question_id": 18685}
{"snippet": "numpy.nancumsum(a, axis=None)", "intent": "Return the cumulative sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . numpy", "question_id": 18686}
{"snippet": "numpy.nancumsum(a, dtype=None)", "intent": "Return the cumulative sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `dtype`. numpy", "question_id": 18687}
{"snippet": "numpy.nancumsum(a, out=None)", "intent": "Return the cumulative sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `out`. numpy", "question_id": 18688}
{"snippet": "numpy.nancumsum(a, axis=None, dtype=None)", "intent": "Return the cumulative sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `dtype`. numpy", "question_id": 18689}
{"snippet": "numpy.nancumsum(a, axis=None, out=None)", "intent": "Return the cumulative sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `out`. numpy", "question_id": 18690}
{"snippet": "numpy.nancumsum(a, dtype=None, out=None)", "intent": "Return the cumulative sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `dtype`, `out`. numpy", "question_id": 18691}
{"snippet": "numpy.nancumsum(a, axis=None, dtype=None, out=None)", "intent": "Return the cumulative sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `dtype`, `out`. numpy", "question_id": 18692}
{"snippet": "dtype.num", "intent": "A unique number for each of the 21 different built-in types. numpy", "question_id": 18693}
{"snippet": "char.greater_equal(x1, x2)", "intent": "Return ( `x1` > = `x2` ) element-wise . numpy", "question_id": 18694}
{"snippet": "matrix.all()", "intent": "Test whether all matrix elements along a given `axis` evaluate to True . numpy", "question_id": 18695}
{"snippet": "matrix.all(axis=None)", "intent": "Test whether all matrix elements along a given `axis` evaluate to True . numpy", "question_id": 18696}
{"snippet": "matrix.all(out=None)", "intent": "Test whether all matrix elements along a given `axis` evaluate to True . With arguments `out`. numpy", "question_id": 18697}
{"snippet": "matrix.all(axis=None, out=None)", "intent": "Test whether all matrix elements along a given `axis` evaluate to True . With arguments `out`. numpy", "question_id": 18698}
{"snippet": "random.f(dfnum, dfden)", "intent": "Draw samples from an F distribution . Samples are drawn from an F distribution with specified parameters , `dfnum` ( degrees of freedom in numerator ) and `dfden` ( degrees of freedom in denominator ) , where both parameters must be greater than zero . numpy", "question_id": 18699}
{"snippet": "random.f(dfnum, dfden, size=None)", "intent": "Draw samples from an F distribution . Samples are drawn from an F distribution with specified parameters , `dfnum` ( degrees of freedom in numerator ) and `dfden` ( degrees of freedom in denominator ) , where both parameters must be greater than zero . With arguments `size`. numpy", "question_id": 18700}
{"snippet": "random.normal()", "intent": "Draw random samples from a normal ( Gaussian ) distribution . numpy", "question_id": 18701}
{"snippet": "random.normal(loc=0.0)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `loc`. numpy", "question_id": 18702}
{"snippet": "random.normal(scale=1.0)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `scale`. numpy", "question_id": 18703}
{"snippet": "random.normal(size=None)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `size`. numpy", "question_id": 18704}
{"snippet": "random.normal(loc=0.0, scale=1.0)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `loc`, `scale`. numpy", "question_id": 18705}
{"snippet": "random.normal(loc=0.0, size=None)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `loc`, `size`. numpy", "question_id": 18706}
{"snippet": "random.normal(scale=1.0, size=None)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `scale`, `size`. numpy", "question_id": 18707}
{"snippet": "random.normal(loc=0.0, scale=1.0, size=None)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `loc`, `scale`, `size`. numpy", "question_id": 18708}
{"snippet": "ndarray.argsort()", "intent": "Returns the indices that would sort this array . numpy", "question_id": 18709}
{"snippet": "ndarray.argsort(axis=- 1)", "intent": "Returns the indices that would sort this array . With arguments `axis`. numpy", "question_id": 18710}
{"snippet": "ndarray.argsort(kind=None)", "intent": "Returns the indices that would sort this array . With arguments `kind`. numpy", "question_id": 18711}
{"snippet": "ndarray.argsort(order=None)", "intent": "Returns the indices that would sort this array . With arguments `order`. numpy", "question_id": 18712}
{"snippet": "ndarray.argsort(axis=- 1, kind=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `kind`. numpy", "question_id": 18713}
{"snippet": "ndarray.argsort(axis=- 1, order=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `order`. numpy", "question_id": 18714}
{"snippet": "ndarray.argsort(kind=None, order=None)", "intent": "Returns the indices that would sort this array . With arguments `kind`, `order`. numpy", "question_id": 18715}
{"snippet": "ndarray.argsort(axis=- 1, kind=None, order=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `kind`, `order`. numpy", "question_id": 18716}
{"snippet": "recarray.conjugate()", "intent": "Return the complex conjugate , element-wise . numpy", "question_id": 18717}
{"snippet": "numpy.right_shift(x1, x2, /, signature, extobj)", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 18718}
{"snippet": "numpy.right_shift(x1, x2, /, signature, extobj, out=None)", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 18719}
{"snippet": "numpy.right_shift(x1, x2, /, signature, extobj, where=True)", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 18720}
{"snippet": "numpy.right_shift(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 18721}
{"snippet": "numpy.right_shift(x1, x2, /, signature, extobj, order='K')", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 18722}
{"snippet": "numpy.right_shift(x1, x2, /, signature, extobj, dtype=None)", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 18723}
{"snippet": "numpy.right_shift(x1, x2, /, signature, extobj, subok=True)", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 18724}
{"snippet": "numpy.right_shift(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 18725}
{"snippet": "numpy.right_shift(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 18726}
{"snippet": "numpy.right_shift(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 18727}
{"snippet": "numpy.right_shift(x1, x2, /, signature)", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`. numpy", "question_id": 18728}
{"snippet": "numpy.right_shift(x1, x2, /, signature, out=None)", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `out`. numpy", "question_id": 18729}
{"snippet": "numpy.right_shift(x1, x2, /, signature, where=True)", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `where`. numpy", "question_id": 18730}
{"snippet": "numpy.right_shift(x1, x2, /, signature, casting='same_kind')", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `casting`. numpy", "question_id": 18731}
{"snippet": "numpy.right_shift(x1, x2, /, signature, order='K')", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `order`. numpy", "question_id": 18732}
{"snippet": "numpy.right_shift(x1, x2, /, signature, dtype=None)", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 18733}
{"snippet": "numpy.right_shift(x1, x2, /, signature, subok=True)", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `subok`. numpy", "question_id": 18734}
{"snippet": "numpy.right_shift(x1, x2, /, signature, out=None, where=True)", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 18735}
{"snippet": "numpy.right_shift(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 18736}
{"snippet": "numpy.right_shift(x1, x2, /, signature, out=None, order='K')", "intent": "Shift the bits of an integer to the right . Because the internal representation of numbers is in binary format , this operation is equivalent to dividing `x1` by 2 * * x2 . Bits are shifted to the right `x2` . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 18737}
{"snippet": "generic.flat", "intent": "A 1-D view of the scalar. numpy", "question_id": 18738}
{"snippet": "char.ljust(a, width)", "intent": "Return an array with the elements of `a` left-justified in a string of length `width` . numpy", "question_id": 18739}
{"snippet": "char.ljust(a, width, fillchar=' ')", "intent": "Return an array with the elements of `a` left-justified in a string of length `width` . With arguments `fillchar`. numpy", "question_id": 18740}
{"snippet": "numpy.sum(a)", "intent": "Sum of array elements over `a` given `axis` . numpy", "question_id": 18741}
{"snippet": "numpy.sum(a, axis=None)", "intent": "Sum of array elements over `a` given `axis` . numpy", "question_id": 18742}
{"snippet": "numpy.sum(a, dtype=None)", "intent": "Sum of array elements over `a` given `axis` . With arguments `dtype`. numpy", "question_id": 18743}
{"snippet": "numpy.sum(a, out=None)", "intent": "Sum of array elements over `a` given `axis` . With arguments `out`. numpy", "question_id": 18744}
{"snippet": "numpy.sum(a, keepdims=<no value>)", "intent": "Sum of array elements over `a` given `axis` . With arguments `keepdims`. numpy", "question_id": 18745}
{"snippet": "numpy.sum(a, initial=<no value>)", "intent": "Sum of array elements over `a` given `axis` . With arguments `initial`. numpy", "question_id": 18746}
{"snippet": "numpy.sum(a, where=<no value>)", "intent": "Sum of array elements over `a` given `axis` . With arguments `where`. numpy", "question_id": 18747}
{"snippet": "numpy.sum(a, axis=None, dtype=None)", "intent": "Sum of array elements over `a` given `axis` . With arguments `dtype`. numpy", "question_id": 18748}
{"snippet": "numpy.sum(a, axis=None, out=None)", "intent": "Sum of array elements over `a` given `axis` . With arguments `out`. numpy", "question_id": 18749}
{"snippet": "numpy.sum(a, axis=None, keepdims=<no value>)", "intent": "Sum of array elements over `a` given `axis` . With arguments `keepdims`. numpy", "question_id": 18750}
{"snippet": "record.ptp()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 18751}
{"snippet": "ma.masked_array.choose(choices)", "intent": "Use an index array to construct a new array from a set of `choices` . numpy", "question_id": 18752}
{"snippet": "ma.masked_array.choose(choices, out=None)", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`. numpy", "question_id": 18753}
{"snippet": "ma.masked_array.choose(choices, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `mode`. numpy", "question_id": 18754}
{"snippet": "ma.masked_array.choose(choices, out=None, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`, `mode`. numpy", "question_id": 18755}
{"snippet": "ma.outerproduct(a, b)", "intent": "Compute the outer product of two vectors . Given two vectors , `a` = [ a0 , a1 , ... , aM ] and `b` = [ b0 , b1 , ... , bN ] , the outer product [ 1 ] is : numpy", "question_id": 18756}
{"snippet": "ndarray.newbyteorder(/)", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`. numpy", "question_id": 18757}
{"snippet": "ndarray.newbyteorder(/, new_order='S')", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`, `new_order`. numpy", "question_id": 18758}
{"snippet": "ma.masked_array.clip(**kwargs)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 18759}
{"snippet": "ma.masked_array.clip(**kwargs, min=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 18760}
{"snippet": "ma.masked_array.clip(**kwargs, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 18761}
{"snippet": "ma.masked_array.clip(**kwargs, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 18762}
{"snippet": "ma.masked_array.clip(**kwargs, min=None, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 18763}
{"snippet": "ma.masked_array.clip(**kwargs, min=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 18764}
{"snippet": "ma.masked_array.clip(**kwargs, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 18765}
{"snippet": "ma.masked_array.clip(**kwargs, min=None, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 18766}
{"snippet": "matrix.astype(dtype)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`. numpy", "question_id": 18767}
{"snippet": "matrix.astype(dtype, order='K')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`. numpy", "question_id": 18768}
{"snippet": "matrix.astype(dtype, casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`. numpy", "question_id": 18769}
{"snippet": "matrix.astype(dtype, subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `subok`. numpy", "question_id": 18770}
{"snippet": "matrix.astype(dtype, copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `copy`. numpy", "question_id": 18771}
{"snippet": "matrix.astype(dtype, order='K', casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `casting`. numpy", "question_id": 18772}
{"snippet": "matrix.astype(dtype, order='K', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `subok`. numpy", "question_id": 18773}
{"snippet": "matrix.astype(dtype, order='K', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `copy`. numpy", "question_id": 18774}
{"snippet": "matrix.astype(dtype, casting='unsafe', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `subok`. numpy", "question_id": 18775}
{"snippet": "matrix.astype(dtype, casting='unsafe', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `copy`. numpy", "question_id": 18776}
{"snippet": "ufunc.at(a, indices, /)", "intent": "Performs unbuffered in place operation on operand \u2018 `a` \u2019 for elements specified by \u2018 `indices` \u2019 . With arguments `/`. numpy", "question_id": 18777}
{"snippet": "ufunc.at(a, indices, /, b=None)", "intent": "Performs unbuffered in place operation on operand \u2018 `a` \u2019 for elements specified by \u2018 `indices` \u2019 . For addition ufunc , this method is equivalent to a [ indices ] += `b` , except that results are accumulated for elements that are indexed more than once . With arguments `/`. numpy", "question_id": 18778}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.generate_dispatch_header(header_path)", "intent": "Generate the dispatch header which contains the # definitions and headers for platform-specific instruction-sets for the enabled CPU baseline and dispatch-able features . With arguments `header_path`. numpy", "question_id": 18779}
{"snippet": "polynomial.hermite_e.hermefromroots(roots)", "intent": "Generate a HermiteE series with given `roots` . numpy", "question_id": 18780}
{"snippet": "ma.fromfunction(function, shape, **dtype)", "intent": "Construct an array by executing a `function` over each coordinate . With arguments `shape`, `**dtype`. numpy", "question_id": 18781}
{"snippet": "ma.MaskType.size", "intent": "The number of elements in the gentype. numpy", "question_id": 18782}
{"snippet": "polynomial.chebyshev.Chebyshev.cutdeg(deg)", "intent": "Truncate series to the given degree . Reduce the degree of the series to `deg` by discarding the high order terms . numpy", "question_id": 18783}
{"snippet": "numpy.nanmin(a)", "intent": "Return minimum of an array or minimum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and Nan is returned for that slice . numpy", "question_id": 18784}
{"snippet": "numpy.nanmin(a, axis=None)", "intent": "Return minimum of an array or minimum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and Nan is returned for that slice . numpy", "question_id": 18785}
{"snippet": "numpy.nanmin(a, out=None)", "intent": "Return minimum of an array or minimum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and Nan is returned for that slice . With arguments `out`. numpy", "question_id": 18786}
{"snippet": "numpy.nanmin(a, keepdims=<no value>)", "intent": "Return minimum of an array or minimum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and Nan is returned for that slice . With arguments `keepdims`. numpy", "question_id": 18787}
{"snippet": "numpy.nanmin(a, axis=None, out=None)", "intent": "Return minimum of an array or minimum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and Nan is returned for that slice . With arguments `out`. numpy", "question_id": 18788}
{"snippet": "numpy.nanmin(a, axis=None, keepdims=<no value>)", "intent": "Return minimum of an array or minimum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and Nan is returned for that slice . With arguments `keepdims`. numpy", "question_id": 18789}
{"snippet": "numpy.nanmin(a, out=None, keepdims=<no value>)", "intent": "Return minimum of an array or minimum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and Nan is returned for that slice . With arguments `out`, `keepdims`. numpy", "question_id": 18790}
{"snippet": "numpy.nanmin(a, axis=None, out=None, keepdims=<no value>)", "intent": "Return minimum of an array or minimum along an `axis` , ignoring any NaNs . When all-NaN slices are encountered `a` RuntimeWarning is raised and Nan is returned for that slice . With arguments `out`, `keepdims`. numpy", "question_id": 18791}
{"snippet": "random.choice(a)", "intent": "Generates `a` random sample from a given 1-D array numpy", "question_id": 18792}
{"snippet": "random.choice(a, size=None)", "intent": "Generates `a` random sample from a given 1-D array Generate a uniform random sample from np.arange ( 5 ) of `size` 3 : numpy", "question_id": 18793}
{"snippet": "random.choice(a, replace=True)", "intent": "Generates `a` random sample from a given 1-D array With arguments `replace`. numpy", "question_id": 18794}
{"snippet": "random.choice(a, p=None)", "intent": "Generates `a` random sample from a given 1-D array Setting user-specified probabilities through `p` uses a more general but less efficient sampler than the default . numpy", "question_id": 18795}
{"snippet": "random.choice(a, size=None, replace=True)", "intent": "Generates `a` random sample from a given 1-D array Generate a uniform random sample from np.arange ( 5 ) of `size` 3 : With arguments `replace`. numpy", "question_id": 18796}
{"snippet": "random.choice(a, size=None, p=None)", "intent": "Generates `a` random sample from a given 1-D array Generate a uniform random sample from np.arange ( 5 ) of `size` 3 : Setting user-specified probabilities through `p` uses a more general but less efficient sampler than the default . numpy", "question_id": 18797}
{"snippet": "random.choice(a, replace=True, p=None)", "intent": "Generates `a` random sample from a given 1-D array Setting user-specified probabilities through `p` uses a more general but less efficient sampler than the default . With arguments `replace`. numpy", "question_id": 18798}
{"snippet": "random.choice(a, size=None, replace=True, p=None)", "intent": "Generates `a` random sample from a given 1-D array Generate a uniform random sample from np.arange ( 5 ) of `size` 3 : Setting user-specified probabilities through `p` uses a more general but less efficient sampler than the default . With arguments `replace`. numpy", "question_id": 18799}
{"snippet": "numpy.delete(arr, obj)", "intent": "Return a new array with sub-arrays along an `axis` deleted . For a one dimensional array , this returns those entries not returned by `arr` [ `obj` ] . numpy", "question_id": 18800}
{"snippet": "numpy.delete(arr, obj, axis=None)", "intent": "Return a new array with sub-arrays along an `axis` deleted . For a one dimensional array , this returns those entries not returned by `arr` [ `obj` ] . numpy", "question_id": 18801}
{"snippet": "polynomial.legendre.poly2leg(pol)", "intent": "Convert a polynomial to a Legendre series . With arguments `pol`. numpy", "question_id": 18802}
{"snippet": "char.chararray.squeeze()", "intent": "Remove axes of length one from a . numpy", "question_id": 18803}
{"snippet": "char.chararray.squeeze(axis=None)", "intent": "Remove axes of length one from a . With arguments `axis`. numpy", "question_id": 18804}
{"snippet": "memmap.setfield(val, dtype)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field . numpy", "question_id": 18805}
{"snippet": "memmap.setfield(val, dtype, offset=0)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field . numpy", "question_id": 18806}
{"snippet": "matrix.resize(new_shape)", "intent": "Change shape and size of array in-place . With arguments `new_shape`. numpy", "question_id": 18807}
{"snippet": "matrix.resize(new_shape, refcheck=True)", "intent": "Change shape and size of array in-place . However , reference counts can increase in other ways so if you are sure that you have not shared the memory for this array with another Python object , then you may safely set `refcheck` to False . With arguments `new_shape`. numpy", "question_id": 18808}
{"snippet": "ma.MaskedArray.__copy__()", "intent": "Used if copy.copy is called on an array . numpy", "question_id": 18809}
{"snippet": "record.flatten()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 18810}
{"snippet": "random.set_state(state)", "intent": "Set the internal `state` of the generator from a tuple . numpy", "question_id": 18811}
{"snippet": "numpy.correlate(a, v)", "intent": "Cross-correlation of two 1-dimensional sequences . with `a` and `v` sequences being zero-padded where necessary and conj being the conjugate . numpy", "question_id": 18812}
{"snippet": "numpy.correlate(a, v, mode='valid')", "intent": "Cross-correlation of two 1-dimensional sequences . with `a` and `v` sequences being zero-padded where necessary and conj being the conjugate . With arguments `mode`. numpy", "question_id": 18813}
{"snippet": "polynomial.hermite.Hermite.fromroots(roots)", "intent": "Return series instance that has the specified `roots` . numpy", "question_id": 18814}
{"snippet": "polynomial.hermite.Hermite.fromroots(roots, domain=)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`. numpy", "question_id": 18815}
{"snippet": "polynomial.hermite.Hermite.fromroots(roots, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `window`. numpy", "question_id": 18816}
{"snippet": "polynomial.hermite.Hermite.fromroots(roots, domain=, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`, `window`. numpy", "question_id": 18817}
{"snippet": "polynomial.hermite.Hermite.fromroots()", "intent": "Return series instance that has the specified `roots` . numpy", "question_id": 18818}
{"snippet": "polynomial.hermite.Hermite.fromroots(domain=)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`. numpy", "question_id": 18819}
{"snippet": "polynomial.hermite.Hermite.fromroots(window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `window`. numpy", "question_id": 18820}
{"snippet": "polynomial.hermite.Hermite.fromroots(domain=, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`, `window`. numpy", "question_id": 18821}
{"snippet": "numpy.sqrt(x, /, signature, extobj)", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`. numpy", "question_id": 18822}
{"snippet": "numpy.sqrt(x, /, signature, extobj, out=None)", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 18823}
{"snippet": "numpy.sqrt(x, /, signature, extobj, where=True)", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `where`. numpy", "question_id": 18824}
{"snippet": "numpy.sqrt(x, /, signature, extobj, casting='same_kind')", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 18825}
{"snippet": "numpy.sqrt(x, /, signature, extobj, order='K')", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 18826}
{"snippet": "numpy.sqrt(x, /, signature, extobj, dtype=None)", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 18827}
{"snippet": "numpy.sqrt(x, /, signature, extobj, subok=True)", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 18828}
{"snippet": "numpy.sqrt(x, /, signature, extobj, out=None, where=True)", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 18829}
{"snippet": "numpy.sqrt(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 18830}
{"snippet": "numpy.sqrt(x, /, signature, extobj, out=None, order='K')", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 18831}
{"snippet": "numpy.sqrt(x, /, signature)", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`. numpy", "question_id": 18832}
{"snippet": "numpy.sqrt(x, /, signature, out=None)", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `out`. numpy", "question_id": 18833}
{"snippet": "numpy.sqrt(x, /, signature, where=True)", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `where`. numpy", "question_id": 18834}
{"snippet": "numpy.sqrt(x, /, signature, casting='same_kind')", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `casting`. numpy", "question_id": 18835}
{"snippet": "numpy.sqrt(x, /, signature, order='K')", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `order`. numpy", "question_id": 18836}
{"snippet": "numpy.sqrt(x, /, signature, dtype=None)", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `dtype`. numpy", "question_id": 18837}
{"snippet": "numpy.sqrt(x, /, signature, subok=True)", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `subok`. numpy", "question_id": 18838}
{"snippet": "numpy.sqrt(x, /, signature, out=None, where=True)", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `out`, `where`. numpy", "question_id": 18839}
{"snippet": "numpy.sqrt(x, /, signature, out=None, casting='same_kind')", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `out`, `casting`. numpy", "question_id": 18840}
{"snippet": "numpy.sqrt(x, /, signature, out=None, order='K')", "intent": "Return the non-negative square-root of an array , element-wise . With arguments `x`, `/`, `signature`, `out`, `order`. numpy", "question_id": 18841}
{"snippet": "numpy.where(condition, x, y)", "intent": "Return elements chosen from `x` or `y` depending on `condition` . numpy", "question_id": 18842}
{"snippet": "numpy.where(condition, x)", "intent": "Return elements chosen from `x` or `y` depending on `condition` . numpy", "question_id": 18843}
{"snippet": "numpy.linspace(start, stop)", "intent": "Return evenly spaced numbers over a specified interval . Returns `num` evenly spaced samples , calculated over the interval [ `start` , `stop` ] . numpy", "question_id": 18844}
{"snippet": "numpy.linspace(start, stop, num=50)", "intent": "Return evenly spaced numbers over a specified interval . Returns `num` evenly spaced samples , calculated over the interval [ `start` , `stop` ] . numpy", "question_id": 18845}
{"snippet": "numpy.linspace(start, stop, endpoint=True)", "intent": "Return evenly spaced numbers over a specified interval . Returns `num` evenly spaced samples , calculated over the interval [ `start` , `stop` ] . The `endpoint` of the interval can optionally be excluded . numpy", "question_id": 18846}
{"snippet": "numpy.linspace(start, stop, retstep=False)", "intent": "Return evenly spaced numbers over a specified interval . Returns `num` evenly spaced samples , calculated over the interval [ `start` , `stop` ] . With arguments `retstep`. numpy", "question_id": 18847}
{"snippet": "numpy.linspace(start, stop, dtype=None)", "intent": "Return evenly spaced numbers over a specified interval . Returns `num` evenly spaced samples , calculated over the interval [ `start` , `stop` ] . With arguments `dtype`. numpy", "question_id": 18848}
{"snippet": "numpy.linspace(start, stop, axis=0)", "intent": "Return evenly spaced numbers over a specified interval . Returns `num` evenly spaced samples , calculated over the interval [ `start` , `stop` ] . With arguments `axis`. numpy", "question_id": 18849}
{"snippet": "numpy.linspace(start, stop, num=50, endpoint=True)", "intent": "Return evenly spaced numbers over a specified interval . Returns `num` evenly spaced samples , calculated over the interval [ `start` , `stop` ] . The `endpoint` of the interval can optionally be excluded . numpy", "question_id": 18850}
{"snippet": "numpy.linspace(start, stop, num=50, retstep=False)", "intent": "Return evenly spaced numbers over a specified interval . Returns `num` evenly spaced samples , calculated over the interval [ `start` , `stop` ] . With arguments `retstep`. numpy", "question_id": 18851}
{"snippet": "numpy.linspace(start, stop, num=50, dtype=None)", "intent": "Return evenly spaced numbers over a specified interval . Returns `num` evenly spaced samples , calculated over the interval [ `start` , `stop` ] . With arguments `dtype`. numpy", "question_id": 18852}
{"snippet": "numpy.linspace(start, stop, num=50, axis=0)", "intent": "Return evenly spaced numbers over a specified interval . Returns `num` evenly spaced samples , calculated over the interval [ `start` , `stop` ] . With arguments `axis`. numpy", "question_id": 18853}
{"snippet": "polynomial.laguerre.lagmulx(c)", "intent": "Multiply a Laguerre series by x . Multiply the Laguerre series `c` by x , where x is the independent variable . numpy", "question_id": 18854}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.me(cb)", "intent": "A static method that can be treated as a decorator to dynamically cache certain methods . With arguments `cb`. numpy", "question_id": 18855}
{"snippet": "ma.MaskType.flat", "intent": "A 1-D view of the scalar. numpy", "question_id": 18856}
{"snippet": "record.argmin()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 18857}
{"snippet": "lib.scimath.logn(n, x)", "intent": "Take log base `n` of `x` . numpy", "question_id": 18858}
{"snippet": "random.Generator.rayleigh()", "intent": "Draw samples from a Rayleigh distribution . numpy", "question_id": 18859}
{"snippet": "random.Generator.rayleigh(scale=1.0)", "intent": "Draw samples from a Rayleigh distribution . With arguments `scale`. numpy", "question_id": 18860}
{"snippet": "random.Generator.rayleigh(size=None)", "intent": "Draw samples from a Rayleigh distribution . With arguments `size`. numpy", "question_id": 18861}
{"snippet": "random.Generator.rayleigh(scale=1.0, size=None)", "intent": "Draw samples from a Rayleigh distribution . With arguments `scale`, `size`. numpy", "question_id": 18862}
{"snippet": "numpy.bincount(x)", "intent": "Count number of occurrences of each value in array of non-negative ints . The number of bins ( of size 1 ) is one larger than the largest value in `x` . numpy", "question_id": 18863}
{"snippet": "numpy.bincount(x, weights=None)", "intent": "Count number of occurrences of each value in array of non-negative ints . The number of bins ( of size 1 ) is one larger than the largest value in `x` . If `weights` is specified the input array is weighted by it , i.e . numpy", "question_id": 18864}
{"snippet": "numpy.bincount(x, minlength=0)", "intent": "Count number of occurrences of each value in array of non-negative ints . The number of bins ( of size 1 ) is one larger than the largest value in `x` . If `minlength` is specified , there will be at least this number of bins in the output array ( though it will be longer if necessary , depending on the contents of x ) . numpy", "question_id": 18865}
{"snippet": "numpy.bincount(x, weights=None, minlength=0)", "intent": "Count number of occurrences of each value in array of non-negative ints . The number of bins ( of size 1 ) is one larger than the largest value in `x` . If `weights` is specified the input array is weighted by it , i.e . If `minlength` is specified , there will be at least this number of bins in the output array ( though it will be longer if necessary , depending on the contents of x ) . numpy", "question_id": 18866}
{"snippet": "numpy.ndarray(shape)", "intent": "An array object represents a multidimensional , homogeneous array of fixed-size items . With arguments `shape`. numpy", "question_id": 18867}
{"snippet": "numpy.ndarray(shape, dtype=float)", "intent": "An array object represents a multidimensional , homogeneous array of fixed-size items . With arguments `shape`, `dtype`. numpy", "question_id": 18868}
{"snippet": "numpy.ndarray(shape, buffer=None)", "intent": "An array object represents a multidimensional , homogeneous array of fixed-size items . First mode , `buffer` is None : With arguments `shape`. numpy", "question_id": 18869}
{"snippet": "numpy.ndarray(shape, offset=0)", "intent": "An array object represents a multidimensional , homogeneous array of fixed-size items . With arguments `shape`, `offset`. numpy", "question_id": 18870}
{"snippet": "numpy.ndarray(shape, strides=None)", "intent": "An array object represents a multidimensional , homogeneous array of fixed-size items . With arguments `shape`, `strides`. numpy", "question_id": 18871}
{"snippet": "numpy.ndarray(shape, order=None)", "intent": "An array object represents a multidimensional , homogeneous array of fixed-size items . With arguments `shape`, `order`. numpy", "question_id": 18872}
{"snippet": "numpy.ndarray(shape, dtype=float, buffer=None)", "intent": "An array object represents a multidimensional , homogeneous array of fixed-size items . First mode , `buffer` is None : With arguments `shape`, `dtype`. numpy", "question_id": 18873}
{"snippet": "numpy.ndarray(shape, dtype=float, offset=0)", "intent": "An array object represents a multidimensional , homogeneous array of fixed-size items . With arguments `shape`, `dtype`, `offset`. numpy", "question_id": 18874}
{"snippet": "numpy.ndarray(shape, dtype=float, strides=None)", "intent": "An array object represents a multidimensional , homogeneous array of fixed-size items . With arguments `shape`, `dtype`, `strides`. numpy", "question_id": 18875}
{"snippet": "numpy.ndarray(shape, dtype=float, order=None)", "intent": "An array object represents a multidimensional , homogeneous array of fixed-size items . With arguments `shape`, `dtype`, `order`. numpy", "question_id": 18876}
{"snippet": "ma.apply_over_axes(func, a, axes)", "intent": "Apply `a` function repeatedly over multiple `axes` . `func` is called as res = func ( a , axis ) , where axis is the first element of axes . numpy", "question_id": 18877}
{"snippet": "char.chararray.data", "intent": "Python buffer object pointing to the start of the array\u2019s data. numpy", "question_id": 18878}
{"snippet": "numpy.asarray(a)", "intent": "Convert the input to an array . Convert `a` list into an array : numpy", "question_id": 18879}
{"snippet": "numpy.asarray(a, dtype=None)", "intent": "Convert the input to an array . Convert `a` list into an array : If `dtype` is set , array is copied only if dtype does not match : numpy", "question_id": 18880}
{"snippet": "numpy.asarray(a, order=None)", "intent": "Convert the input to an array . Convert `a` list into an array : With arguments `order`. numpy", "question_id": 18881}
{"snippet": "numpy.asarray(a, like=None)", "intent": "Convert the input to an array . Convert `a` list into an array : With arguments `like`. numpy", "question_id": 18882}
{"snippet": "numpy.asarray(a, dtype=None, order=None)", "intent": "Convert the input to an array . Convert `a` list into an array : If `dtype` is set , array is copied only if dtype does not match : With arguments `order`. numpy", "question_id": 18883}
{"snippet": "numpy.asarray(a, dtype=None, like=None)", "intent": "Convert the input to an array . Convert `a` list into an array : If `dtype` is set , array is copied only if dtype does not match : With arguments `like`. numpy", "question_id": 18884}
{"snippet": "numpy.asarray(a, order=None, like=None)", "intent": "Convert the input to an array . Convert `a` list into an array : With arguments `order`, `like`. numpy", "question_id": 18885}
{"snippet": "numpy.asarray(a, dtype=None, order=None, like=None)", "intent": "Convert the input to an array . Convert `a` list into an array : If `dtype` is set , array is copied only if dtype does not match : With arguments `order`, `like`. numpy", "question_id": 18886}
{"snippet": "random.RandomState.power(a)", "intent": "Draws samples in [ 0 , 1 ] from `a` power distribution with positive exponent a - 1 . numpy", "question_id": 18887}
{"snippet": "random.RandomState.power(a, size=None)", "intent": "Draws samples in [ 0 , 1 ] from `a` power distribution with positive exponent a - 1 . With arguments `size`. numpy", "question_id": 18888}
{"snippet": "polynomial.hermite.Hermite.mapparms()", "intent": "Return the mapping parameters . numpy", "question_id": 18889}
{"snippet": "chararray.startswith(prefix)", "intent": "Returns a boolean array which is True where the string element in self starts with `prefix` , otherwise False . numpy", "question_id": 18890}
{"snippet": "chararray.startswith(prefix, start=0)", "intent": "Returns a boolean array which is True where the string element in self starts with `prefix` , otherwise False . With arguments `start`. numpy", "question_id": 18891}
{"snippet": "chararray.startswith(prefix, end=None)", "intent": "Returns a boolean array which is True where the string element in self starts with `prefix` , otherwise False . With arguments `end`. numpy", "question_id": 18892}
{"snippet": "chararray.startswith(prefix, start=0, end=None)", "intent": "Returns a boolean array which is True where the string element in self starts with `prefix` , otherwise False . With arguments `start`, `end`. numpy", "question_id": 18893}
{"snippet": "polynomial.legendre.Legendre.__call__(arg)", "intent": "Call self as a function . With arguments `arg`. numpy", "question_id": 18894}
{"snippet": "polynomial.laguerre.lagvander(x, deg)", "intent": "Pseudo-Vandermonde matrix of given degree . Returns the pseudo-Vandermonde matrix of degree `deg` and sample points `x` . numpy", "question_id": 18895}
{"snippet": "numpy.resize(a, new_shape)", "intent": "Return `a` new array with the specified shape . Note that this behavior is different from a.resize ( `new_shape` ) which fills with zeros instead of repeated copies of a . numpy", "question_id": 18896}
{"snippet": "random.RandomState.random_integers(low)", "intent": "Random integers of type np.int_ between `low` and `high` , inclusive . numpy", "question_id": 18897}
{"snippet": "random.RandomState.random_integers(low, high=None)", "intent": "Random integers of type np.int_ between `low` and `high` , inclusive . numpy", "question_id": 18898}
{"snippet": "random.RandomState.random_integers(low, size=None)", "intent": "Random integers of type np.int_ between `low` and `high` , inclusive . With arguments `size`. numpy", "question_id": 18899}
{"snippet": "random.RandomState.random_integers(low, high=None, size=None)", "intent": "Random integers of type np.int_ between `low` and `high` , inclusive . With arguments `size`. numpy", "question_id": 18900}
{"snippet": "record.trace()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 18901}
{"snippet": "random.RandomState.choice(a)", "intent": "Generates `a` random sample from a given 1-D array numpy", "question_id": 18902}
{"snippet": "random.RandomState.choice(a, size=None)", "intent": "Generates `a` random sample from a given 1-D array Generate a uniform random sample from np.arange ( 5 ) of `size` 3 : numpy", "question_id": 18903}
{"snippet": "random.RandomState.choice(a, replace=True)", "intent": "Generates `a` random sample from a given 1-D array With arguments `replace`. numpy", "question_id": 18904}
{"snippet": "random.RandomState.choice(a, p=None)", "intent": "Generates `a` random sample from a given 1-D array Setting user-specified probabilities through `p` uses a more general but less efficient sampler than the default . numpy", "question_id": 18905}
{"snippet": "random.RandomState.choice(a, size=None, replace=True)", "intent": "Generates `a` random sample from a given 1-D array Generate a uniform random sample from np.arange ( 5 ) of `size` 3 : With arguments `replace`. numpy", "question_id": 18906}
{"snippet": "random.RandomState.choice(a, size=None, p=None)", "intent": "Generates `a` random sample from a given 1-D array Generate a uniform random sample from np.arange ( 5 ) of `size` 3 : Setting user-specified probabilities through `p` uses a more general but less efficient sampler than the default . numpy", "question_id": 18907}
{"snippet": "random.RandomState.choice(a, replace=True, p=None)", "intent": "Generates `a` random sample from a given 1-D array Setting user-specified probabilities through `p` uses a more general but less efficient sampler than the default . With arguments `replace`. numpy", "question_id": 18908}
{"snippet": "random.RandomState.choice(a, size=None, replace=True, p=None)", "intent": "Generates `a` random sample from a given 1-D array Generate a uniform random sample from np.arange ( 5 ) of `size` 3 : Setting user-specified probabilities through `p` uses a more general but less efficient sampler than the default . With arguments `replace`. numpy", "question_id": 18909}
{"snippet": "char.chararray.mean()", "intent": "Returns the average of the array elements along given `axis` . numpy", "question_id": 18910}
{"snippet": "char.chararray.mean(axis=None)", "intent": "Returns the average of the array elements along given `axis` . numpy", "question_id": 18911}
{"snippet": "char.chararray.mean(dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 18912}
{"snippet": "char.chararray.mean(out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 18913}
{"snippet": "char.chararray.mean(keepdims=False)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`. numpy", "question_id": 18914}
{"snippet": "char.chararray.mean(where=True)", "intent": "Returns the average of the array elements along given `axis` . With arguments `where`. numpy", "question_id": 18915}
{"snippet": "char.chararray.mean(axis=None, dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 18916}
{"snippet": "char.chararray.mean(axis=None, out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 18917}
{"snippet": "char.chararray.mean(axis=None, keepdims=False)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`. numpy", "question_id": 18918}
{"snippet": "char.chararray.mean(axis=None, where=True)", "intent": "Returns the average of the array elements along given `axis` . With arguments `where`. numpy", "question_id": 18919}
{"snippet": "matrix.nbytes", "intent": "Total bytes consumed by the elements of the array. numpy", "question_id": 18920}
{"snippet": "ma.innerproduct(a, b)", "intent": "Inner product of two arrays . Ordinary inner product of vectors for 1-D arrays ( without complex conjugation ) , in higher dimensions `a` sum product over the last axes . More generally , if ndim ( a ) = r > 0 and ndim ( `b` ) = s > 0 : numpy", "question_id": 18921}
{"snippet": "fft.fftshift(x)", "intent": "Shift the zero-frequency component to the center of the spectrum . Note that y [ 0 ] is the Nyquist component only if len ( `x` ) is even . numpy", "question_id": 18922}
{"snippet": "fft.fftshift(x, axes=None)", "intent": "Shift the zero-frequency component to the center of the spectrum . Note that y [ 0 ] is the Nyquist component only if len ( `x` ) is even . This function swaps half-spaces for all `axes` listed ( defaults to all ) . numpy", "question_id": 18923}
{"snippet": "ndarray.min()", "intent": "Return the minimum along a given `axis` . numpy", "question_id": 18924}
{"snippet": "ndarray.min(axis=None)", "intent": "Return the minimum along a given `axis` . numpy", "question_id": 18925}
{"snippet": "ndarray.min(out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`. numpy", "question_id": 18926}
{"snippet": "ndarray.min(keepdims=False)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 18927}
{"snippet": "ndarray.min(initial=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `initial`. numpy", "question_id": 18928}
{"snippet": "ndarray.min(where=True)", "intent": "Return the minimum along a given `axis` . With arguments `where`. numpy", "question_id": 18929}
{"snippet": "ndarray.min(axis=None, out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`. numpy", "question_id": 18930}
{"snippet": "ndarray.min(axis=None, keepdims=False)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 18931}
{"snippet": "ndarray.min(axis=None, initial=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `initial`. numpy", "question_id": 18932}
{"snippet": "ndarray.min(axis=None, where=True)", "intent": "Return the minimum along a given `axis` . With arguments `where`. numpy", "question_id": 18933}
{"snippet": "ma.masked_array.argsort()", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . numpy", "question_id": 18934}
{"snippet": "ma.masked_array.argsort(axis=<no value>)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . numpy", "question_id": 18935}
{"snippet": "ma.masked_array.argsort(kind=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `kind`. numpy", "question_id": 18936}
{"snippet": "ma.masked_array.argsort(order=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `order`. numpy", "question_id": 18937}
{"snippet": "ma.masked_array.argsort(endwith=True)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `endwith`. numpy", "question_id": 18938}
{"snippet": "ma.masked_array.argsort(fill_value=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . Masked values are filled beforehand to `fill_value` . numpy", "question_id": 18939}
{"snippet": "ma.masked_array.argsort(axis=<no value>, kind=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `kind`. numpy", "question_id": 18940}
{"snippet": "ma.masked_array.argsort(axis=<no value>, order=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `order`. numpy", "question_id": 18941}
{"snippet": "ma.masked_array.argsort(axis=<no value>, endwith=True)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `endwith`. numpy", "question_id": 18942}
{"snippet": "ma.masked_array.argsort(axis=<no value>, fill_value=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . Masked values are filled beforehand to `fill_value` . numpy", "question_id": 18943}
{"snippet": "ndarray.__gt__(value, /)", "intent": "Return self > `value` . With arguments `/`. numpy", "question_id": 18944}
{"snippet": "polynomial.legendre.Legendre.copy()", "intent": "Return a copy . numpy", "question_id": 18945}
{"snippet": "ndarray.__isub__(value, /)", "intent": "Return self-=value . With arguments `value`, `/`. numpy", "question_id": 18946}
{"snippet": "lib.scimath.sqrt(x)", "intent": "Compute the square root of `x` . numpy", "question_id": 18947}
{"snippet": "numpy.bartlett(M)", "intent": "Return the Bartlett window . With arguments `M`. numpy", "question_id": 18948}
{"snippet": "ma.MaskedArray.ravel()", "intent": "Returns a 1D version of self , as a view . numpy", "question_id": 18949}
{"snippet": "ma.MaskedArray.ravel(order='C')", "intent": "Returns a 1D version of self , as a view . With arguments `order`. numpy", "question_id": 18950}
{"snippet": "numpy.unravel_index(indices, shape)", "intent": "Converts a flat index or array of flat `indices` into a tuple of coordinate arrays . With arguments `shape`. numpy", "question_id": 18951}
{"snippet": "numpy.unravel_index(indices, shape, order='C')", "intent": "Converts a flat index or array of flat `indices` into a tuple of coordinate arrays . With arguments `shape`, `order`. numpy", "question_id": 18952}
{"snippet": "chararray.getfield(dtype)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements . numpy", "question_id": 18953}
{"snippet": "chararray.getfield(dtype, offset=0)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements . The values in the view are determined by the given type and the `offset` into the current array in bytes . numpy", "question_id": 18954}
{"snippet": "recarray.resize(new_shape)", "intent": "Change shape and size of array in-place . With arguments `new_shape`. numpy", "question_id": 18955}
{"snippet": "recarray.resize(new_shape, refcheck=True)", "intent": "Change shape and size of array in-place . However , reference counts can increase in other ways so if you are sure that you have not shared the memory for this array with another Python object , then you may safely set `refcheck` to False . With arguments `new_shape`. numpy", "question_id": 18956}
{"snippet": "ma.MaskType.T", "intent": "Scalar attribute identical to the corresponding array attribute. numpy", "question_id": 18957}
{"snippet": "ndarray.cumprod()", "intent": "Return the cumulative product of the elements along the given `axis` . numpy", "question_id": 18958}
{"snippet": "ndarray.cumprod(axis=None)", "intent": "Return the cumulative product of the elements along the given `axis` . numpy", "question_id": 18959}
{"snippet": "ndarray.cumprod(dtype=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 18960}
{"snippet": "ndarray.cumprod(out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `out`. numpy", "question_id": 18961}
{"snippet": "ndarray.cumprod(axis=None, dtype=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 18962}
{"snippet": "ndarray.cumprod(axis=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `out`. numpy", "question_id": 18963}
{"snippet": "ndarray.cumprod(dtype=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 18964}
{"snippet": "ndarray.cumprod(axis=None, dtype=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 18965}
{"snippet": "polynomial.hermite.hermweight(x)", "intent": "Weight function of the Hermite polynomials . With arguments `x`. numpy", "question_id": 18966}
{"snippet": "polynomial.chebyshev.Chebyshev.truncate(size)", "intent": "Truncate series to length `size` . numpy", "question_id": 18967}
{"snippet": "errstate.__call__(func)", "intent": "Call self as a function . With arguments `func`. numpy", "question_id": 18968}
{"snippet": "numpy.minimum(x1, x2, /, signature, extobj)", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 18969}
{"snippet": "numpy.minimum(x1, x2, /, signature, extobj, out=None)", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 18970}
{"snippet": "numpy.minimum(x1, x2, /, signature, extobj, where=True)", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 18971}
{"snippet": "numpy.minimum(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 18972}
{"snippet": "numpy.minimum(x1, x2, /, signature, extobj, order='K')", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 18973}
{"snippet": "numpy.minimum(x1, x2, /, signature, extobj, dtype=None)", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 18974}
{"snippet": "numpy.minimum(x1, x2, /, signature, extobj, subok=True)", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 18975}
{"snippet": "numpy.minimum(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 18976}
{"snippet": "numpy.minimum(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 18977}
{"snippet": "numpy.minimum(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 18978}
{"snippet": "numpy.minimum(x1, x2, /, signature)", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`. numpy", "question_id": 18979}
{"snippet": "numpy.minimum(x1, x2, /, signature, out=None)", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`. numpy", "question_id": 18980}
{"snippet": "numpy.minimum(x1, x2, /, signature, where=True)", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `where`. numpy", "question_id": 18981}
{"snippet": "numpy.minimum(x1, x2, /, signature, casting='same_kind')", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `casting`. numpy", "question_id": 18982}
{"snippet": "numpy.minimum(x1, x2, /, signature, order='K')", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `order`. numpy", "question_id": 18983}
{"snippet": "numpy.minimum(x1, x2, /, signature, dtype=None)", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 18984}
{"snippet": "numpy.minimum(x1, x2, /, signature, subok=True)", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `subok`. numpy", "question_id": 18985}
{"snippet": "numpy.minimum(x1, x2, /, signature, out=None, where=True)", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 18986}
{"snippet": "numpy.minimum(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 18987}
{"snippet": "numpy.minimum(x1, x2, /, signature, out=None, order='K')", "intent": "Element-wise minimum of array elements . The minimum is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 18988}
{"snippet": "numpy.memmap(filename)", "intent": "Create a memory-map to an array stored in a binary file on disk . You would use a \u2018 normal \u2019 `filename` . numpy", "question_id": 18989}
{"snippet": "numpy.memmap(filename, dtype=<class 'numpy.ubyte'>)", "intent": "Create a memory-map to an array stored in a binary file on disk . You would use a \u2018 normal \u2019 `filename` . Create a memmap with `dtype` and `shape` that matches our data : numpy", "question_id": 18990}
{"snippet": "numpy.memmap(filename, mode='r+')", "intent": "Create a memory-map to an array stored in a binary file on disk . You would use a \u2018 normal \u2019 `filename` . With arguments `mode`. numpy", "question_id": 18991}
{"snippet": "numpy.memmap(filename, offset=0)", "intent": "Create a memory-map to an array stored in a binary file on disk . You would use a \u2018 normal \u2019 `filename` . With arguments `offset`. numpy", "question_id": 18992}
{"snippet": "numpy.memmap(filename, shape=None)", "intent": "Create a memory-map to an array stored in a binary file on disk . You would use a \u2018 normal \u2019 `filename` . Create a memmap with `dtype` and `shape` that matches our data : numpy", "question_id": 18993}
{"snippet": "numpy.memmap(filename, order='C')", "intent": "Create a memory-map to an array stored in a binary file on disk . You would use a \u2018 normal \u2019 `filename` . Flushes memory changes to disk in `order` to read them back numpy", "question_id": 18994}
{"snippet": "numpy.memmap(filename, dtype=<class 'numpy.ubyte'>, mode='r+')", "intent": "Create a memory-map to an array stored in a binary file on disk . You would use a \u2018 normal \u2019 `filename` . Create a memmap with `dtype` and `shape` that matches our data : With arguments `mode`. numpy", "question_id": 18995}
{"snippet": "numpy.memmap(filename, dtype=<class 'numpy.ubyte'>, offset=0)", "intent": "Create a memory-map to an array stored in a binary file on disk . You would use a \u2018 normal \u2019 `filename` . Create a memmap with `dtype` and `shape` that matches our data : With arguments `offset`. numpy", "question_id": 18996}
{"snippet": "numpy.memmap(filename, dtype=<class 'numpy.ubyte'>, shape=None)", "intent": "Create a memory-map to an array stored in a binary file on disk . You would use a \u2018 normal \u2019 `filename` . Create a memmap with `dtype` and `shape` that matches our data : numpy", "question_id": 18997}
{"snippet": "numpy.memmap(filename, dtype=<class 'numpy.ubyte'>, order='C')", "intent": "Create a memory-map to an array stored in a binary file on disk . You would use a \u2018 normal \u2019 `filename` . Create a memmap with `dtype` and `shape` that matches our data : Flushes memory changes to disk in `order` to read them back numpy", "question_id": 18998}
{"snippet": "polynomial.legendre.Legendre.cutdeg(deg)", "intent": "Truncate series to the given degree . Reduce the degree of the series to `deg` by discarding the high order terms . numpy", "question_id": 18999}
{"snippet": "memmap.conjugate()", "intent": "Return the complex conjugate , element-wise . numpy", "question_id": 19000}
{"snippet": "chararray.prod()", "intent": "Return the product of the array elements over the given `axis` numpy", "question_id": 19001}
{"snippet": "chararray.prod(axis=None)", "intent": "Return the product of the array elements over the given `axis` numpy", "question_id": 19002}
{"snippet": "chararray.prod(dtype=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `dtype`. numpy", "question_id": 19003}
{"snippet": "chararray.prod(out=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `out`. numpy", "question_id": 19004}
{"snippet": "chararray.prod(keepdims=False)", "intent": "Return the product of the array elements over the given `axis` With arguments `keepdims`. numpy", "question_id": 19005}
{"snippet": "chararray.prod(initial=1)", "intent": "Return the product of the array elements over the given `axis` With arguments `initial`. numpy", "question_id": 19006}
{"snippet": "chararray.prod(where=True)", "intent": "Return the product of the array elements over the given `axis` With arguments `where`. numpy", "question_id": 19007}
{"snippet": "chararray.prod(axis=None, dtype=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `dtype`. numpy", "question_id": 19008}
{"snippet": "chararray.prod(axis=None, out=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `out`. numpy", "question_id": 19009}
{"snippet": "chararray.prod(axis=None, keepdims=False)", "intent": "Return the product of the array elements over the given `axis` With arguments `keepdims`. numpy", "question_id": 19010}
{"snippet": "numpy.ediff1d(ary)", "intent": "The differences between consecutive elements of an array . With arguments `ary`. numpy", "question_id": 19011}
{"snippet": "numpy.ediff1d(ary, to_end=None)", "intent": "The differences between consecutive elements of an array . When applied to masked arrays , this function drops the mask information if the `to_begin` and/or `to_end` parameters are used . With arguments `ary`. numpy", "question_id": 19012}
{"snippet": "numpy.ediff1d(ary, to_begin=None)", "intent": "The differences between consecutive elements of an array . When applied to masked arrays , this function drops the mask information if the `to_begin` and/or `to_end` parameters are used . With arguments `ary`. numpy", "question_id": 19013}
{"snippet": "numpy.ediff1d(ary, to_end=None, to_begin=None)", "intent": "The differences between consecutive elements of an array . When applied to masked arrays , this function drops the mask information if the `to_begin` and/or `to_end` parameters are used . With arguments `ary`. numpy", "question_id": 19014}
{"snippet": "chararray.flatten()", "intent": "Return a copy of the array collapsed into one dimension . numpy", "question_id": 19015}
{"snippet": "chararray.flatten(order='C')", "intent": "Return a copy of the array collapsed into one dimension . With arguments `order`. numpy", "question_id": 19016}
{"snippet": "polynomial.polynomial.Polynomial.cutdeg(deg)", "intent": "Truncate series to the given degree . Reduce the degree of the series to `deg` by discarding the high order terms . numpy", "question_id": 19017}
{"snippet": "ma.masked_array.ctypes", "intent": "An object to simplify the interaction of the array with the ctypes module. numpy", "question_id": 19018}
{"snippet": "_ctypes.data", "intent": "A pointer to the memory area of the array as a Python integer. numpy", "question_id": 19019}
{"snippet": "_ctypes.shape", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the C-integer corresponding to dtype('p') on this platform. numpy", "question_id": 19020}
{"snippet": "_ctypes.strides", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the same as for the shape attribute. numpy", "question_id": 19021}
{"snippet": "_ctypes.data_as(obj)", "intent": "Return the data pointer cast to a particular c-types object . With arguments `obj`. numpy", "question_id": 19022}
{"snippet": "_ctypes.shape_as(obj)", "intent": "Return the shape tuple as an array of some other c-types type . With arguments `obj`. numpy", "question_id": 19023}
{"snippet": "_ctypes.strides_as(obj)", "intent": "Return the strides tuple as an array of some other c-types type . With arguments `obj`. numpy", "question_id": 19024}
{"snippet": "numpy.lib.NumpyVersion(vstring)", "intent": "Parse and compare numpy version strings . With arguments `vstring`. numpy", "question_id": 19025}
{"snippet": "ma.atleast_1d(*args, **kwargs)", "intent": "Convert inputs to arrays with at least one dimension . With arguments `*args`, `**kwargs`. numpy", "question_id": 19026}
{"snippet": "random.RandomState.dirichlet(alpha)", "intent": "Draw samples from the Dirichlet distribution . With arguments `alpha`. numpy", "question_id": 19027}
{"snippet": "random.RandomState.dirichlet(alpha, size=None)", "intent": "Draw samples from the Dirichlet distribution . Draw `size` samples of dimension k from a Dirichlet distribution . With arguments `alpha`. numpy", "question_id": 19028}
{"snippet": "ma.MaskType.dumps()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 19029}
{"snippet": "ma.MaskType.ndim", "intent": "The number of array dimensions. numpy", "question_id": 19030}
{"snippet": "polynomial.laguerre.lagder(c)", "intent": "Differentiate a Laguerre series . Returns the Laguerre series coefficients `c` differentiated `m` times along `axis` . numpy", "question_id": 19031}
{"snippet": "polynomial.laguerre.lagder(c, m=1)", "intent": "Differentiate a Laguerre series . Returns the Laguerre series coefficients `c` differentiated `m` times along `axis` . numpy", "question_id": 19032}
{"snippet": "polynomial.laguerre.lagder(c, scl=1)", "intent": "Differentiate a Laguerre series . Returns the Laguerre series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) . numpy", "question_id": 19033}
{"snippet": "polynomial.laguerre.lagder(c, axis=0)", "intent": "Differentiate a Laguerre series . Returns the Laguerre series coefficients `c` differentiated `m` times along `axis` . numpy", "question_id": 19034}
{"snippet": "polynomial.laguerre.lagder(c, m=1, scl=1)", "intent": "Differentiate a Laguerre series . Returns the Laguerre series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) . numpy", "question_id": 19035}
{"snippet": "polynomial.laguerre.lagder(c, m=1, axis=0)", "intent": "Differentiate a Laguerre series . Returns the Laguerre series coefficients `c` differentiated `m` times along `axis` . numpy", "question_id": 19036}
{"snippet": "polynomial.laguerre.lagder(c, scl=1, axis=0)", "intent": "Differentiate a Laguerre series . Returns the Laguerre series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) . numpy", "question_id": 19037}
{"snippet": "polynomial.laguerre.lagder(c, m=1, scl=1, axis=0)", "intent": "Differentiate a Laguerre series . Returns the Laguerre series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) . numpy", "question_id": 19038}
{"snippet": "char.chararray.isdecimal()", "intent": "For each element in self , return True if there are only decimal characters in the element . numpy", "question_id": 19039}
{"snippet": "numpy.cumprod(a)", "intent": "Return the cumulative product of elements along `a` given `axis` . numpy", "question_id": 19040}
{"snippet": "numpy.cumprod(a, axis=None)", "intent": "Return the cumulative product of elements along `a` given `axis` . numpy", "question_id": 19041}
{"snippet": "numpy.cumprod(a, dtype=None)", "intent": "Return the cumulative product of elements along `a` given `axis` . With arguments `dtype`. numpy", "question_id": 19042}
{"snippet": "numpy.cumprod(a, out=None)", "intent": "Return the cumulative product of elements along `a` given `axis` . With arguments `out`. numpy", "question_id": 19043}
{"snippet": "numpy.cumprod(a, axis=None, dtype=None)", "intent": "Return the cumulative product of elements along `a` given `axis` . With arguments `dtype`. numpy", "question_id": 19044}
{"snippet": "numpy.cumprod(a, axis=None, out=None)", "intent": "Return the cumulative product of elements along `a` given `axis` . With arguments `out`. numpy", "question_id": 19045}
{"snippet": "numpy.cumprod(a, dtype=None, out=None)", "intent": "Return the cumulative product of elements along `a` given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 19046}
{"snippet": "numpy.cumprod(a, axis=None, dtype=None, out=None)", "intent": "Return the cumulative product of elements along `a` given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 19047}
{"snippet": "ma.MaskedArray.__reduce__()", "intent": "Return a 3-tuple for pickling a MaskedArray . numpy", "question_id": 19048}
{"snippet": "numpy.isrealobj(x)", "intent": "Return True if `x` is a not complex type or an array of complex numbers . numpy", "question_id": 19049}
{"snippet": "polynomial.laguerre.lagint(c)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 19050}
{"snippet": "polynomial.laguerre.lagint(c, m=1)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 19051}
{"snippet": "polynomial.laguerre.lagint(c, k=)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 19052}
{"snippet": "polynomial.laguerre.lagint(c, lbnd=0)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 19053}
{"snippet": "polynomial.laguerre.lagint(c, scl=1)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 19054}
{"snippet": "polynomial.laguerre.lagint(c, axis=0)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 19055}
{"snippet": "polynomial.laguerre.lagint(c, m=1, k=)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 19056}
{"snippet": "polynomial.laguerre.lagint(c, m=1, lbnd=0)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 19057}
{"snippet": "polynomial.laguerre.lagint(c, m=1, scl=1)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 19058}
{"snippet": "polynomial.laguerre.lagint(c, m=1, axis=0)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 19059}
{"snippet": "polynomial.laguerre.lagint()", "intent": "Integrate a Laguerre series . numpy", "question_id": 19060}
{"snippet": "polynomial.laguerre.lagint(m=1)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 19061}
{"snippet": "polynomial.laguerre.lagint(k=)", "intent": "Integrate a Laguerre series . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 19062}
{"snippet": "polynomial.laguerre.lagint(lbnd=0)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 19063}
{"snippet": "polynomial.laguerre.lagint(scl=1)", "intent": "Integrate a Laguerre series . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 19064}
{"snippet": "polynomial.laguerre.lagint(axis=0)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 19065}
{"snippet": "polynomial.laguerre.lagint(m=1, k=)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 19066}
{"snippet": "polynomial.laguerre.lagint(m=1, lbnd=0)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 19067}
{"snippet": "polynomial.laguerre.lagint(m=1, scl=1)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 19068}
{"snippet": "polynomial.laguerre.lagint(m=1, axis=0)", "intent": "Integrate a Laguerre series . Returns the Laguerre series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 19069}
{"snippet": "random.Generator.f(dfnum, dfden)", "intent": "Draw samples from an F distribution . Samples are drawn from an F distribution with specified parameters , `dfnum` ( degrees of freedom in numerator ) and `dfden` ( degrees of freedom in denominator ) , where both parameters must be greater than zero . numpy", "question_id": 19070}
{"snippet": "random.Generator.f(dfnum, dfden, size=None)", "intent": "Draw samples from an F distribution . Samples are drawn from an F distribution with specified parameters , `dfnum` ( degrees of freedom in numerator ) and `dfden` ( degrees of freedom in denominator ) , where both parameters must be greater than zero . With arguments `size`. numpy", "question_id": 19071}
{"snippet": "polynomial.laguerre.Laguerre.mapparms()", "intent": "Return the mapping parameters . numpy", "question_id": 19072}
{"snippet": "numpy.einsum(subscripts, *operands)", "intent": "Evaluates the Einstein summation convention on the operands . The `subscripts` string is a comma-separated list of subscript labels , where each label refers to a dimension of the corresponding operand . With arguments `*operands`. numpy", "question_id": 19073}
{"snippet": "numpy.einsum(subscripts, *operands, out=None)", "intent": "Evaluates the Einstein summation convention on the operands . The `subscripts` string is a comma-separated list of subscript labels , where each label refers to a dimension of the corresponding operand . With arguments `*operands`, `out`. numpy", "question_id": 19074}
{"snippet": "numpy.einsum(subscripts, *operands, dtype=None)", "intent": "Evaluates the Einstein summation convention on the operands . The `subscripts` string is a comma-separated list of subscript labels , where each label refers to a dimension of the corresponding operand . With arguments `*operands`, `dtype`. numpy", "question_id": 19075}
{"snippet": "numpy.einsum(subscripts, *operands, order='K')", "intent": "Evaluates the Einstein summation convention on the operands . The `subscripts` string is a comma-separated list of subscript labels , where each label refers to a dimension of the corresponding operand . Additionally np.einsum ( 'ij , jh- > ih ' , a , b ) directly specifies the `order` of the output subscript labels and therefore returns matrix multiplication , unlike the example above in implicit mode . With arguments `*operands`. numpy", "question_id": 19076}
{"snippet": "numpy.einsum(subscripts, *operands, casting='safe')", "intent": "Evaluates the Einstein summation convention on the operands . The `subscripts` string is a comma-separated list of subscript labels , where each label refers to a dimension of the corresponding operand . With arguments `*operands`, `casting`. numpy", "question_id": 19077}
{"snippet": "numpy.einsum(subscripts, *operands, optimize=False)", "intent": "Evaluates the Einstein summation convention on the operands . The `subscripts` string is a comma-separated list of subscript labels , where each label refers to a dimension of the corresponding operand . Added the `optimize` argument which will optimize the contraction order of an einsum expression . With arguments `*operands`. numpy", "question_id": 19078}
{"snippet": "numpy.einsum(subscripts, *operands, out=None, dtype=None)", "intent": "Evaluates the Einstein summation convention on the operands . The `subscripts` string is a comma-separated list of subscript labels , where each label refers to a dimension of the corresponding operand . With arguments `*operands`, `out`, `dtype`. numpy", "question_id": 19079}
{"snippet": "numpy.einsum(subscripts, *operands, out=None, order='K')", "intent": "Evaluates the Einstein summation convention on the operands . The `subscripts` string is a comma-separated list of subscript labels , where each label refers to a dimension of the corresponding operand . Additionally np.einsum ( 'ij , jh- > ih ' , a , b ) directly specifies the `order` of the output subscript labels and therefore returns matrix multiplication , unlike the example above in implicit mode . With arguments `*operands`, `out`. numpy", "question_id": 19080}
{"snippet": "numpy.einsum(subscripts, *operands, out=None, casting='safe')", "intent": "Evaluates the Einstein summation convention on the operands . The `subscripts` string is a comma-separated list of subscript labels , where each label refers to a dimension of the corresponding operand . With arguments `*operands`, `out`, `casting`. numpy", "question_id": 19081}
{"snippet": "numpy.einsum(subscripts, *operands, out=None, optimize=False)", "intent": "Evaluates the Einstein summation convention on the operands . The `subscripts` string is a comma-separated list of subscript labels , where each label refers to a dimension of the corresponding operand . Added the `optimize` argument which will optimize the contraction order of an einsum expression . With arguments `*operands`, `out`. numpy", "question_id": 19082}
{"snippet": "chararray.trace()", "intent": "Return the sum along diagonals of the array . numpy", "question_id": 19083}
{"snippet": "chararray.trace(offset=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`. numpy", "question_id": 19084}
{"snippet": "chararray.trace(axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `axis1`. numpy", "question_id": 19085}
{"snippet": "chararray.trace(axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `axis2`. numpy", "question_id": 19086}
{"snippet": "chararray.trace(dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `dtype`. numpy", "question_id": 19087}
{"snippet": "chararray.trace(out=None)", "intent": "Return the sum along diagonals of the array . With arguments `out`. numpy", "question_id": 19088}
{"snippet": "chararray.trace(offset=0, axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis1`. numpy", "question_id": 19089}
{"snippet": "chararray.trace(offset=0, axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis2`. numpy", "question_id": 19090}
{"snippet": "chararray.trace(offset=0, dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `dtype`. numpy", "question_id": 19091}
{"snippet": "chararray.trace(offset=0, out=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `out`. numpy", "question_id": 19092}
{"snippet": "chararray.reshape(shape)", "intent": "Returns an array containing the same data with a new `shape` . numpy", "question_id": 19093}
{"snippet": "chararray.reshape(shape, order='C')", "intent": "Returns an array containing the same data with a new `shape` . With arguments `order`. numpy", "question_id": 19094}
{"snippet": "ma.masked_array.size", "intent": "Number of elements in the array. numpy", "question_id": 19095}
{"snippet": "ndarray.argmax()", "intent": "Return indices of the maximum values along the given `axis` . numpy", "question_id": 19096}
{"snippet": "ndarray.argmax(axis=None)", "intent": "Return indices of the maximum values along the given `axis` . numpy", "question_id": 19097}
{"snippet": "ndarray.argmax(out=None)", "intent": "Return indices of the maximum values along the given `axis` . With arguments `out`. numpy", "question_id": 19098}
{"snippet": "ndarray.argmax(axis=None, out=None)", "intent": "Return indices of the maximum values along the given `axis` . With arguments `out`. numpy", "question_id": 19099}
{"snippet": "recarray.ndim", "intent": "Number of array dimensions. numpy", "question_id": 19100}
{"snippet": "numpy.busday_count(begindates, enddates)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . numpy", "question_id": 19101}
{"snippet": "numpy.busday_count(begindates, enddates, weekmask='1111100')", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `weekmask`. numpy", "question_id": 19102}
{"snippet": "numpy.busday_count(begindates, enddates, holidays=)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `holidays`. numpy", "question_id": 19103}
{"snippet": "numpy.busday_count(begindates, enddates, busdaycal=None)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `busdaycal`. numpy", "question_id": 19104}
{"snippet": "numpy.busday_count(begindates, enddates, out=None)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `out`. numpy", "question_id": 19105}
{"snippet": "numpy.busday_count(begindates, enddates, weekmask='1111100', holidays=)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `weekmask`, `holidays`. numpy", "question_id": 19106}
{"snippet": "numpy.busday_count(begindates, enddates, weekmask='1111100', busdaycal=None)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `weekmask`, `busdaycal`. numpy", "question_id": 19107}
{"snippet": "numpy.busday_count(begindates, enddates, weekmask='1111100', out=None)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `weekmask`, `out`. numpy", "question_id": 19108}
{"snippet": "numpy.busday_count(begindates, enddates, holidays=, busdaycal=None)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `holidays`, `busdaycal`. numpy", "question_id": 19109}
{"snippet": "numpy.busday_count(begindates, enddates, holidays=, out=None)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `holidays`, `out`. numpy", "question_id": 19110}
{"snippet": "numpy.busday_count(begindates)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . numpy", "question_id": 19111}
{"snippet": "numpy.busday_count(begindates, weekmask='1111100')", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `weekmask`. numpy", "question_id": 19112}
{"snippet": "numpy.busday_count(begindates, holidays=)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `holidays`. numpy", "question_id": 19113}
{"snippet": "numpy.busday_count(begindates, busdaycal=None)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `busdaycal`. numpy", "question_id": 19114}
{"snippet": "numpy.busday_count(begindates, out=None)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `out`. numpy", "question_id": 19115}
{"snippet": "numpy.busday_count(begindates, weekmask='1111100', holidays=)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `weekmask`, `holidays`. numpy", "question_id": 19116}
{"snippet": "numpy.busday_count(begindates, weekmask='1111100', busdaycal=None)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `weekmask`, `busdaycal`. numpy", "question_id": 19117}
{"snippet": "numpy.busday_count(begindates, weekmask='1111100', out=None)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `weekmask`, `out`. numpy", "question_id": 19118}
{"snippet": "numpy.busday_count(begindates, holidays=, busdaycal=None)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `holidays`, `busdaycal`. numpy", "question_id": 19119}
{"snippet": "numpy.busday_count(begindates, holidays=, out=None)", "intent": "Counts the number of valid days between `begindates` and `enddates` , not including the day of enddates . With arguments `holidays`, `out`. numpy", "question_id": 19120}
{"snippet": "polynomial.legendre.legvander3d(x, y, z, deg)", "intent": "Pseudo-Vandermonde matrix of given degrees . Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points ( `x` , `y` , `z` ) . numpy", "question_id": 19121}
{"snippet": "char.chararray.dtype", "intent": "Data-type of the array\u2019s elements. numpy", "question_id": 19122}
{"snippet": "ma.MaskedArray.squeeze()", "intent": "Remove axes of length one from a . numpy", "question_id": 19123}
{"snippet": "ma.MaskedArray.squeeze(axis=None)", "intent": "Remove axes of length one from a . With arguments `axis`. numpy", "question_id": 19124}
{"snippet": "ma.MaskType.searchsorted()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 19125}
{"snippet": "polynomial.hermite_e.HermiteE.roots()", "intent": "Return the roots of the series polynomial . numpy", "question_id": 19126}
{"snippet": "chararray.isdigit()", "intent": "Returns true for each element if all characters in the string are digits and there is at least one character , false otherwise . numpy", "question_id": 19127}
{"snippet": "numpy.trapz(y)", "intent": "Integrate along the given `axis` using the composite trapezoidal rule . Integrate `y` ( x ) along each 1d slice on the given axis , compute \\ ( \\int y ( x ) dx\\ ) . numpy", "question_id": 19128}
{"snippet": "numpy.trapz(y, x=None)", "intent": "Integrate along the given `axis` using the composite trapezoidal rule . Integrate `y` ( x ) along each 1d slice on the given axis , compute \\ ( \\int y ( x ) dx\\ ) . If `x` is provided , the integration happens in sequence along its elements - they are not sorted . numpy", "question_id": 19129}
{"snippet": "numpy.trapz(y, dx=1.0)", "intent": "Integrate along the given `axis` using the composite trapezoidal rule . Integrate `y` ( x ) along each 1d slice on the given axis , compute \\ ( \\int y ( x ) dx\\ ) . When x is specified , this integrates along the parametric curve , computing \\ ( \\int_t y ( t ) dt = \\int_t y ( t ) \\left.\\frac { `dx` } { dt } \\right|_ { x=x ( t ) } dt\\ ) . numpy", "question_id": 19130}
{"snippet": "numpy.trapz(y, axis=- 1)", "intent": "Integrate along the given `axis` using the composite trapezoidal rule . Integrate `y` ( x ) along each 1d slice on the given axis , compute \\ ( \\int y ( x ) dx\\ ) . numpy", "question_id": 19131}
{"snippet": "numpy.trapz(y, x=None, dx=1.0)", "intent": "Integrate along the given `axis` using the composite trapezoidal rule . Integrate `y` ( x ) along each 1d slice on the given axis , compute \\ ( \\int y ( x ) dx\\ ) . If `x` is provided , the integration happens in sequence along its elements - they are not sorted . When x is specified , this integrates along the parametric curve , computing \\ ( \\int_t y ( t ) dt = \\int_t y ( t ) \\left.\\frac { `dx` } { dt } \\right|_ { x=x ( t ) } dt\\ ) . numpy", "question_id": 19132}
{"snippet": "numpy.trapz(y, x=None, axis=- 1)", "intent": "Integrate along the given `axis` using the composite trapezoidal rule . Integrate `y` ( x ) along each 1d slice on the given axis , compute \\ ( \\int y ( x ) dx\\ ) . If `x` is provided , the integration happens in sequence along its elements - they are not sorted . numpy", "question_id": 19133}
{"snippet": "numpy.trapz(y, dx=1.0, axis=- 1)", "intent": "Integrate along the given `axis` using the composite trapezoidal rule . Integrate `y` ( x ) along each 1d slice on the given axis , compute \\ ( \\int y ( x ) dx\\ ) . When x is specified , this integrates along the parametric curve , computing \\ ( \\int_t y ( t ) dt = \\int_t y ( t ) \\left.\\frac { `dx` } { dt } \\right|_ { x=x ( t ) } dt\\ ) . numpy", "question_id": 19134}
{"snippet": "numpy.trapz(y, x=None, dx=1.0, axis=- 1)", "intent": "Integrate along the given `axis` using the composite trapezoidal rule . Integrate `y` ( x ) along each 1d slice on the given axis , compute \\ ( \\int y ( x ) dx\\ ) . If `x` is provided , the integration happens in sequence along its elements - they are not sorted . When x is specified , this integrates along the parametric curve , computing \\ ( \\int_t y ( t ) dt = \\int_t y ( t ) \\left.\\frac { `dx` } { dt } \\right|_ { x=x ( t ) } dt\\ ) . numpy", "question_id": 19135}
{"snippet": "numpy.ones(shape)", "intent": "Return a new array of given `shape` and type , filled with ones . numpy", "question_id": 19136}
{"snippet": "numpy.ones(shape, dtype=None)", "intent": "Return a new array of given `shape` and type , filled with ones . With arguments `dtype`. numpy", "question_id": 19137}
{"snippet": "numpy.ones(shape, order='C')", "intent": "Return a new array of given `shape` and type , filled with ones . With arguments `order`. numpy", "question_id": 19138}
{"snippet": "numpy.ones(shape, like=None)", "intent": "Return a new array of given `shape` and type , filled with ones . With arguments `like`. numpy", "question_id": 19139}
{"snippet": "numpy.ones(shape, dtype=None, order='C')", "intent": "Return a new array of given `shape` and type , filled with ones . With arguments `dtype`, `order`. numpy", "question_id": 19140}
{"snippet": "numpy.ones(shape, dtype=None, like=None)", "intent": "Return a new array of given `shape` and type , filled with ones . With arguments `dtype`, `like`. numpy", "question_id": 19141}
{"snippet": "numpy.ones(shape, order='C', like=None)", "intent": "Return a new array of given `shape` and type , filled with ones . With arguments `order`, `like`. numpy", "question_id": 19142}
{"snippet": "numpy.ones(shape, dtype=None, order='C', like=None)", "intent": "Return a new array of given `shape` and type , filled with ones . With arguments `dtype`, `order`, `like`. numpy", "question_id": 19143}
{"snippet": "ma.MaskType.fill()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 19144}
{"snippet": "random.Generator.negative_binomial(n, p)", "intent": "Draw samples from a negative binomial distribution . Samples are drawn from a negative binomial distribution with specified parameters , `n` successes and `p` probability of success where n is > 0 and p is in the interval ( 0 , 1 ] . numpy", "question_id": 19145}
{"snippet": "random.Generator.negative_binomial(n, p, size=None)", "intent": "Draw samples from a negative binomial distribution . Samples are drawn from a negative binomial distribution with specified parameters , `n` successes and `p` probability of success where n is > 0 and p is in the interval ( 0 , 1 ] . With arguments `size`. numpy", "question_id": 19146}
{"snippet": "chararray.translate(table)", "intent": "For each element in self , return a copy of the string where all characters occurring in the optional argument `deletechars` are removed , and the remaining characters have been mapped through the given translation `table` . numpy", "question_id": 19147}
{"snippet": "chararray.translate(table, deletechars=None)", "intent": "For each element in self , return a copy of the string where all characters occurring in the optional argument `deletechars` are removed , and the remaining characters have been mapped through the given translation `table` . numpy", "question_id": 19148}
{"snippet": "record.argmax()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 19149}
{"snippet": "ma.MaskedArray.__div__(other)", "intent": "Divide `other` into self , and return a new masked array . numpy", "question_id": 19150}
{"snippet": "ma.MaskedArray.__rpow__(other)", "intent": "Raise `other` to the power self , masking the potential NaNs/Infs numpy", "question_id": 19151}
{"snippet": "ma.inner(a, b)", "intent": "Inner product of two arrays . Ordinary inner product of vectors for 1-D arrays ( without complex conjugation ) , in higher dimensions `a` sum product over the last axes . More generally , if ndim ( a ) = r > 0 and ndim ( `b` ) = s > 0 : numpy", "question_id": 19152}
{"snippet": "polynomial.legendre.Legendre.roots()", "intent": "Return the roots of the series polynomial . numpy", "question_id": 19153}
{"snippet": "random.lognormal()", "intent": "Draw samples from a log-normal distribution . numpy", "question_id": 19154}
{"snippet": "random.lognormal(mean=0.0)", "intent": "Draw samples from a log-normal distribution . Draw samples from a log-normal distribution with specified `mean` , standard deviation , and array shape . numpy", "question_id": 19155}
{"snippet": "random.lognormal(sigma=1.0)", "intent": "Draw samples from a log-normal distribution . With arguments `sigma`. numpy", "question_id": 19156}
{"snippet": "random.lognormal(size=None)", "intent": "Draw samples from a log-normal distribution . With arguments `size`. numpy", "question_id": 19157}
{"snippet": "random.lognormal(mean=0.0, sigma=1.0)", "intent": "Draw samples from a log-normal distribution . Draw samples from a log-normal distribution with specified `mean` , standard deviation , and array shape . With arguments `sigma`. numpy", "question_id": 19158}
{"snippet": "random.lognormal(mean=0.0, size=None)", "intent": "Draw samples from a log-normal distribution . Draw samples from a log-normal distribution with specified `mean` , standard deviation , and array shape . With arguments `size`. numpy", "question_id": 19159}
{"snippet": "random.lognormal(sigma=1.0, size=None)", "intent": "Draw samples from a log-normal distribution . With arguments `sigma`, `size`. numpy", "question_id": 19160}
{"snippet": "random.lognormal(mean=0.0, sigma=1.0, size=None)", "intent": "Draw samples from a log-normal distribution . Draw samples from a log-normal distribution with specified `mean` , standard deviation , and array shape . With arguments `sigma`, `size`. numpy", "question_id": 19161}
{"snippet": "matrix.cumprod()", "intent": "Return the cumulative product of the elements along the given `axis` . numpy", "question_id": 19162}
{"snippet": "matrix.cumprod(axis=None)", "intent": "Return the cumulative product of the elements along the given `axis` . numpy", "question_id": 19163}
{"snippet": "matrix.cumprod(dtype=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 19164}
{"snippet": "matrix.cumprod(out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `out`. numpy", "question_id": 19165}
{"snippet": "matrix.cumprod(axis=None, dtype=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 19166}
{"snippet": "matrix.cumprod(axis=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `out`. numpy", "question_id": 19167}
{"snippet": "matrix.cumprod(dtype=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 19168}
{"snippet": "matrix.cumprod(axis=None, dtype=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 19169}
{"snippet": "char.startswith(a, prefix)", "intent": "Returns `a` boolean array which is True where the string element in a starts with `prefix` , otherwise False . numpy", "question_id": 19170}
{"snippet": "char.startswith(a, prefix, start=0)", "intent": "Returns `a` boolean array which is True where the string element in a starts with `prefix` , otherwise False . With arguments `start`. numpy", "question_id": 19171}
{"snippet": "char.startswith(a, prefix, end=None)", "intent": "Returns `a` boolean array which is True where the string element in a starts with `prefix` , otherwise False . With arguments `end`. numpy", "question_id": 19172}
{"snippet": "char.startswith(a, prefix, start=0, end=None)", "intent": "Returns `a` boolean array which is True where the string element in a starts with `prefix` , otherwise False . With arguments `start`, `end`. numpy", "question_id": 19173}
{"snippet": "char.less_equal(x1, x2)", "intent": "Return ( `x1` < = `x2` ) element-wise . numpy", "question_id": 19174}
{"snippet": "lib.scimath.arctanh(x)", "intent": "Compute the inverse hyperbolic tangent of `x` . numpy", "question_id": 19175}
{"snippet": "ndarray.dtype", "intent": "Data-type of the array\u2019s elements. numpy", "question_id": 19176}
{"snippet": "testing.assert_string_equal(actual, desired)", "intent": "Test if two strings are equal . With arguments `actual`, `desired`. numpy", "question_id": 19177}
{"snippet": "numpy.arcsinh(x, /, signature, extobj)", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 19178}
{"snippet": "numpy.arcsinh(x, /, signature, extobj, out=None)", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 19179}
{"snippet": "numpy.arcsinh(x, /, signature, extobj, where=True)", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 19180}
{"snippet": "numpy.arcsinh(x, /, signature, extobj, casting='same_kind')", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 19181}
{"snippet": "numpy.arcsinh(x, /, signature, extobj, order='K')", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 19182}
{"snippet": "numpy.arcsinh(x, /, signature, extobj, dtype=None)", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 19183}
{"snippet": "numpy.arcsinh(x, /, signature, extobj, subok=True)", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 19184}
{"snippet": "numpy.arcsinh(x, /, signature, extobj, out=None, where=True)", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 19185}
{"snippet": "numpy.arcsinh(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 19186}
{"snippet": "numpy.arcsinh(x, /, signature, extobj, out=None, order='K')", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 19187}
{"snippet": "numpy.arcsinh(x, /, signature)", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`. numpy", "question_id": 19188}
{"snippet": "numpy.arcsinh(x, /, signature, out=None)", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `out`. numpy", "question_id": 19189}
{"snippet": "numpy.arcsinh(x, /, signature, where=True)", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `where`. numpy", "question_id": 19190}
{"snippet": "numpy.arcsinh(x, /, signature, casting='same_kind')", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `casting`. numpy", "question_id": 19191}
{"snippet": "numpy.arcsinh(x, /, signature, order='K')", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `order`. numpy", "question_id": 19192}
{"snippet": "numpy.arcsinh(x, /, signature, dtype=None)", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 19193}
{"snippet": "numpy.arcsinh(x, /, signature, subok=True)", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `subok`. numpy", "question_id": 19194}
{"snippet": "numpy.arcsinh(x, /, signature, out=None, where=True)", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 19195}
{"snippet": "numpy.arcsinh(x, /, signature, out=None, casting='same_kind')", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 19196}
{"snippet": "numpy.arcsinh(x, /, signature, out=None, order='K')", "intent": "Inverse hyperbolic sine element-wise . arcsinh is a multivalued function : for each `x` there are infinitely many numbers z such that sinh ( z ) = x . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 19197}
{"snippet": "record.any()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 19198}
{"snippet": "ma.MaskType.item()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 19199}
{"snippet": "ma.hsplit(*args, **kwargs)", "intent": "Split an array into multiple sub-arrays horizontally ( column-wise ) . With arguments `*args`, `**kwargs`. numpy", "question_id": 19200}
{"snippet": "numpy.exp(x, /, signature, extobj)", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 19201}
{"snippet": "numpy.exp(x, /, signature, extobj, out=None)", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 19202}
{"snippet": "numpy.exp(x, /, signature, extobj, where=True)", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 19203}
{"snippet": "numpy.exp(x, /, signature, extobj, casting='same_kind')", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 19204}
{"snippet": "numpy.exp(x, /, signature, extobj, order='K')", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 19205}
{"snippet": "numpy.exp(x, /, signature, extobj, dtype=None)", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 19206}
{"snippet": "numpy.exp(x, /, signature, extobj, subok=True)", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 19207}
{"snippet": "numpy.exp(x, /, signature, extobj, out=None, where=True)", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 19208}
{"snippet": "numpy.exp(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 19209}
{"snippet": "numpy.exp(x, /, signature, extobj, out=None, order='K')", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 19210}
{"snippet": "numpy.exp(x, /, signature)", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`. numpy", "question_id": 19211}
{"snippet": "numpy.exp(x, /, signature, out=None)", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `out`. numpy", "question_id": 19212}
{"snippet": "numpy.exp(x, /, signature, where=True)", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `where`. numpy", "question_id": 19213}
{"snippet": "numpy.exp(x, /, signature, casting='same_kind')", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `casting`. numpy", "question_id": 19214}
{"snippet": "numpy.exp(x, /, signature, order='K')", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `order`. numpy", "question_id": 19215}
{"snippet": "numpy.exp(x, /, signature, dtype=None)", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 19216}
{"snippet": "numpy.exp(x, /, signature, subok=True)", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `subok`. numpy", "question_id": 19217}
{"snippet": "numpy.exp(x, /, signature, out=None, where=True)", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 19218}
{"snippet": "numpy.exp(x, /, signature, out=None, casting='same_kind')", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 19219}
{"snippet": "numpy.exp(x, /, signature, out=None, order='K')", "intent": "Calculate the exponential of all elements in the input array . It is approximately 2.718281 , and is the base of the natural logarithm , ln ( this means that , if \\ ( `x` = \\ln y = \\log_e y\\ ) , then \\ ( e^x = y\\ ) . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 19220}
{"snippet": "char.mod(a, values)", "intent": "Return ( `a` % i ) , that is pre-Python 2.6 string formatting ( interpolation ) , element-wise for a pair of array_likes of str or unicode . With arguments `values`. numpy", "question_id": 19221}
{"snippet": "record.std()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 19222}
{"snippet": "numpy.isinf(x, /, signature, extobj)", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 19223}
{"snippet": "numpy.isinf(x, /, signature, extobj, out=None)", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 19224}
{"snippet": "numpy.isinf(x, /, signature, extobj, where=True)", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 19225}
{"snippet": "numpy.isinf(x, /, signature, extobj, casting='same_kind')", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 19226}
{"snippet": "numpy.isinf(x, /, signature, extobj, order='K')", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 19227}
{"snippet": "numpy.isinf(x, /, signature, extobj, dtype=None)", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 19228}
{"snippet": "numpy.isinf(x, /, signature, extobj, subok=True)", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 19229}
{"snippet": "numpy.isinf(x, /, signature, extobj, out=None, where=True)", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 19230}
{"snippet": "numpy.isinf(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 19231}
{"snippet": "numpy.isinf(x, /, signature, extobj, out=None, order='K')", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 19232}
{"snippet": "numpy.isinf(x, /, signature)", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`. numpy", "question_id": 19233}
{"snippet": "numpy.isinf(x, /, signature, out=None)", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `out`. numpy", "question_id": 19234}
{"snippet": "numpy.isinf(x, /, signature, where=True)", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`. numpy", "question_id": 19235}
{"snippet": "numpy.isinf(x, /, signature, casting='same_kind')", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `casting`. numpy", "question_id": 19236}
{"snippet": "numpy.isinf(x, /, signature, order='K')", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `order`. numpy", "question_id": 19237}
{"snippet": "numpy.isinf(x, /, signature, dtype=None)", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 19238}
{"snippet": "numpy.isinf(x, /, signature, subok=True)", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `subok`. numpy", "question_id": 19239}
{"snippet": "numpy.isinf(x, /, signature, out=None, where=True)", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `out`. numpy", "question_id": 19240}
{"snippet": "numpy.isinf(x, /, signature, out=None, casting='same_kind')", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 19241}
{"snippet": "numpy.isinf(x, /, signature, out=None, order='K')", "intent": "Test element-wise for positive or negative infinity . Returns a boolean array of the same shape as `x` , True `where` x == +/-inf , otherwise False . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 19242}
{"snippet": "ndarray.ctypes", "intent": "An object to simplify the interaction of the array with the ctypes module. numpy", "question_id": 19243}
{"snippet": "_ctypes.data", "intent": "A pointer to the memory area of the array as a Python integer. numpy", "question_id": 19244}
{"snippet": "_ctypes.shape", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the C-integer corresponding to dtype('p') on this platform. numpy", "question_id": 19245}
{"snippet": "_ctypes.strides", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the same as for the shape attribute. numpy", "question_id": 19246}
{"snippet": "_ctypes.data_as(obj)", "intent": "Return the data pointer cast to a particular c-types object . With arguments `obj`. numpy", "question_id": 19247}
{"snippet": "_ctypes.shape_as(obj)", "intent": "Return the shape tuple as an array of some other c-types type . With arguments `obj`. numpy", "question_id": 19248}
{"snippet": "_ctypes.strides_as(obj)", "intent": "Return the strides tuple as an array of some other c-types type . With arguments `obj`. numpy", "question_id": 19249}
{"snippet": "random.RandomState.rand(d0, d1, dn)", "intent": "Random values in a given shape . With arguments `d0`, `d1`, `dn`. numpy", "question_id": 19250}
{"snippet": "ma.masked_all_like(arr)", "intent": "Empty masked array with the properties of an existing array . Return an empty masked array of the same shape and dtype as the array `arr` , where all the data are masked . numpy", "question_id": 19251}
{"snippet": "polynomial.polynomial.polyval2d(x, y, c)", "intent": "Evaluate a 2-D polynomial at points ( `x` , `y` ) . In either case , either x and y or their elements must support multiplication and addition both with themselves and with the elements of `c` . numpy", "question_id": 19252}
{"snippet": "char.chararray.choose(choices)", "intent": "Use an index array to construct a new array from a set of `choices` . numpy", "question_id": 19253}
{"snippet": "char.chararray.choose(choices, out=None)", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`. numpy", "question_id": 19254}
{"snippet": "char.chararray.choose(choices, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `mode`. numpy", "question_id": 19255}
{"snippet": "char.chararray.choose(choices, out=None, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`, `mode`. numpy", "question_id": 19256}
{"snippet": "chararray.nbytes", "intent": "Total bytes consumed by the elements of the array. numpy", "question_id": 19257}
{"snippet": "ma.masked_array.tolist()", "intent": "Return the data portion of the masked array as a hierarchical Python list . numpy", "question_id": 19258}
{"snippet": "ma.masked_array.tolist(fill_value=None)", "intent": "Return the data portion of the masked array as a hierarchical Python list . Masked values are converted to `fill_value` . numpy", "question_id": 19259}
{"snippet": "ma.MaskType.std()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 19260}
{"snippet": "ma.MaskedArray.copy()", "intent": "Return a copy of the array . numpy", "question_id": 19261}
{"snippet": "ma.MaskedArray.copy(order='C')", "intent": "Return a copy of the array . The function numpy.copy is similar , but it defaults to using `order` \u2018 K \u2019 , and will not pass sub-classes through by default . numpy", "question_id": 19262}
{"snippet": "chararray.min()", "intent": "Return the minimum along a given `axis` . numpy", "question_id": 19263}
{"snippet": "chararray.min(axis=None)", "intent": "Return the minimum along a given `axis` . numpy", "question_id": 19264}
{"snippet": "chararray.min(out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`. numpy", "question_id": 19265}
{"snippet": "chararray.min(keepdims=False)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 19266}
{"snippet": "chararray.min(initial=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `initial`. numpy", "question_id": 19267}
{"snippet": "chararray.min(where=True)", "intent": "Return the minimum along a given `axis` . With arguments `where`. numpy", "question_id": 19268}
{"snippet": "chararray.min(axis=None, out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`. numpy", "question_id": 19269}
{"snippet": "chararray.min(axis=None, keepdims=False)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 19270}
{"snippet": "chararray.min(axis=None, initial=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `initial`. numpy", "question_id": 19271}
{"snippet": "chararray.min(axis=None, where=True)", "intent": "Return the minimum along a given `axis` . With arguments `where`. numpy", "question_id": 19272}
{"snippet": "recarray.argmax()", "intent": "Return indices of the maximum values along the given `axis` . numpy", "question_id": 19273}
{"snippet": "recarray.argmax(axis=None)", "intent": "Return indices of the maximum values along the given `axis` . numpy", "question_id": 19274}
{"snippet": "recarray.argmax(out=None)", "intent": "Return indices of the maximum values along the given `axis` . With arguments `out`. numpy", "question_id": 19275}
{"snippet": "recarray.argmax(axis=None, out=None)", "intent": "Return indices of the maximum values along the given `axis` . With arguments `out`. numpy", "question_id": 19276}
{"snippet": "ma.MaskedArray.torecords()", "intent": "Transforms a masked array into a flexible-type array . numpy", "question_id": 19277}
{"snippet": "recarray.copy()", "intent": "Return a copy of the array . numpy", "question_id": 19278}
{"snippet": "recarray.copy(order='C')", "intent": "Return a copy of the array . The function numpy.copy is similar , but it defaults to using `order` \u2018 K \u2019 , and will not pass sub-classes through by default . numpy", "question_id": 19279}
{"snippet": "random.RandomState.f(dfnum, dfden)", "intent": "Draw samples from an F distribution . Samples are drawn from an F distribution with specified parameters , `dfnum` ( degrees of freedom in numerator ) and `dfden` ( degrees of freedom in denominator ) , where both parameters must be greater than zero . numpy", "question_id": 19280}
{"snippet": "random.RandomState.f(dfnum, dfden, size=None)", "intent": "Draw samples from an F distribution . Samples are drawn from an F distribution with specified parameters , `dfnum` ( degrees of freedom in numerator ) and `dfden` ( degrees of freedom in denominator ) , where both parameters must be greater than zero . With arguments `size`. numpy", "question_id": 19281}
{"snippet": "ndarray.ravel(order)", "intent": "Return a flattened array . With arguments `order`. numpy", "question_id": 19282}
{"snippet": "ndarray.ravel()", "intent": "Return a flattened array . numpy", "question_id": 19283}
{"snippet": "char.chararray.count(sub)", "intent": "Returns an array with the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] . numpy", "question_id": 19284}
{"snippet": "char.chararray.count(sub, start=0)", "intent": "Returns an array with the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] . numpy", "question_id": 19285}
{"snippet": "char.chararray.count(sub, end=None)", "intent": "Returns an array with the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] . numpy", "question_id": 19286}
{"snippet": "char.chararray.count(sub, start=0, end=None)", "intent": "Returns an array with the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] . numpy", "question_id": 19287}
{"snippet": "ndarray.__rshift__(value, /)", "intent": "Return self > > `value` . With arguments `/`. numpy", "question_id": 19288}
{"snippet": "ma.flatnotmasked_contiguous(a)", "intent": "Find contiguous unmasked data in `a` masked array along the given axis . numpy", "question_id": 19289}
{"snippet": "ndarray.__iadd__(value, /)", "intent": "Return self+=value . With arguments `value`, `/`. numpy", "question_id": 19290}
{"snippet": "recarray.max()", "intent": "Return the maximum along a given `axis` . numpy", "question_id": 19291}
{"snippet": "recarray.max(axis=None)", "intent": "Return the maximum along a given `axis` . numpy", "question_id": 19292}
{"snippet": "recarray.max(out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`. numpy", "question_id": 19293}
{"snippet": "recarray.max(keepdims=False)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 19294}
{"snippet": "recarray.max(initial=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `initial`. numpy", "question_id": 19295}
{"snippet": "recarray.max(where=True)", "intent": "Return the maximum along a given `axis` . With arguments `where`. numpy", "question_id": 19296}
{"snippet": "recarray.max(axis=None, out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`. numpy", "question_id": 19297}
{"snippet": "recarray.max(axis=None, keepdims=False)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 19298}
{"snippet": "recarray.max(axis=None, initial=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `initial`. numpy", "question_id": 19299}
{"snippet": "recarray.max(axis=None, where=True)", "intent": "Return the maximum along a given `axis` . With arguments `where`. numpy", "question_id": 19300}
{"snippet": "recarray.dumps()", "intent": "Returns the pickle of the array as a string . numpy", "question_id": 19301}
{"snippet": "polynomial.polynomial.Polynomial.integ()", "intent": "Integrate . numpy", "question_id": 19302}
{"snippet": "polynomial.polynomial.Polynomial.integ(m=1)", "intent": "Integrate . With arguments `m`. numpy", "question_id": 19303}
{"snippet": "polynomial.polynomial.Polynomial.integ(k=)", "intent": "Integrate . With arguments `k`. numpy", "question_id": 19304}
{"snippet": "polynomial.polynomial.Polynomial.integ(lbnd=None)", "intent": "Integrate . With arguments `lbnd`. numpy", "question_id": 19305}
{"snippet": "polynomial.polynomial.Polynomial.integ(m=1, k=)", "intent": "Integrate . With arguments `m`, `k`. numpy", "question_id": 19306}
{"snippet": "polynomial.polynomial.Polynomial.integ(m=1, lbnd=None)", "intent": "Integrate . With arguments `m`, `lbnd`. numpy", "question_id": 19307}
{"snippet": "polynomial.polynomial.Polynomial.integ(k=, lbnd=None)", "intent": "Integrate . With arguments `k`, `lbnd`. numpy", "question_id": 19308}
{"snippet": "polynomial.polynomial.Polynomial.integ(m=1, k=, lbnd=None)", "intent": "Integrate . With arguments `m`, `k`, `lbnd`. numpy", "question_id": 19309}
{"snippet": "polynomial.polynomial.Polynomial.integ()", "intent": "Integrate . numpy", "question_id": 19310}
{"snippet": "polynomial.polynomial.Polynomial.integ(m=1)", "intent": "Integrate . With arguments `m`. numpy", "question_id": 19311}
{"snippet": "polynomial.polynomial.Polynomial.integ(k=)", "intent": "Integrate . With arguments `k`. numpy", "question_id": 19312}
{"snippet": "polynomial.polynomial.Polynomial.integ(lbnd=None)", "intent": "Integrate . With arguments `lbnd`. numpy", "question_id": 19313}
{"snippet": "polynomial.polynomial.Polynomial.integ(m=1, k=)", "intent": "Integrate . With arguments `m`, `k`. numpy", "question_id": 19314}
{"snippet": "polynomial.polynomial.Polynomial.integ(m=1, lbnd=None)", "intent": "Integrate . With arguments `m`, `lbnd`. numpy", "question_id": 19315}
{"snippet": "polynomial.polynomial.Polynomial.integ(k=, lbnd=None)", "intent": "Integrate . With arguments `k`, `lbnd`. numpy", "question_id": 19316}
{"snippet": "polynomial.polynomial.Polynomial.integ(m=1, k=, lbnd=None)", "intent": "Integrate . With arguments `m`, `k`, `lbnd`. numpy", "question_id": 19317}
{"snippet": "numpy.choose(a, choices)", "intent": "Construct an array from an index array and `a` list of arrays to choose from . Given an \u201c index \u201d array ( a ) of integers and a sequence of n arrays ( `choices` ) , a and each choice array are first broadcast , as necessary , to arrays of a common shape ; calling these Ba and Bchoices [ i ] , i = 0 , \u2026 , n-1 we have that , necessarily , Ba.shape == Bchoices [ i ] .shape for each i . numpy", "question_id": 19318}
{"snippet": "numpy.choose(a, choices, out=None)", "intent": "Construct an array from an index array and `a` list of arrays to choose from . Given an \u201c index \u201d array ( a ) of integers and a sequence of n arrays ( `choices` ) , a and each choice array are first broadcast , as necessary , to arrays of a common shape ; calling these Ba and Bchoices [ i ] , i = 0 , \u2026 , n-1 we have that , necessarily , Ba.shape == Bchoices [ i ] .shape for each i . With arguments `out`. numpy", "question_id": 19319}
{"snippet": "numpy.choose(a, choices, mode='raise')", "intent": "Construct an array from an index array and `a` list of arrays to choose from . Given an \u201c index \u201d array ( a ) of integers and a sequence of n arrays ( `choices` ) , a and each choice array are first broadcast , as necessary , to arrays of a common shape ; calling these Ba and Bchoices [ i ] , i = 0 , \u2026 , n-1 we have that , necessarily , Ba.shape == Bchoices [ i ] .shape for each i . With arguments `mode`. numpy", "question_id": 19320}
{"snippet": "numpy.choose(a, choices, out=None, mode='raise')", "intent": "Construct an array from an index array and `a` list of arrays to choose from . Given an \u201c index \u201d array ( a ) of integers and a sequence of n arrays ( `choices` ) , a and each choice array are first broadcast , as necessary , to arrays of a common shape ; calling these Ba and Bchoices [ i ] , i = 0 , \u2026 , n-1 we have that , necessarily , Ba.shape == Bchoices [ i ] .shape for each i . With arguments `out`, `mode`. numpy", "question_id": 19321}
{"snippet": "record.size", "intent": "The number of elements in the gentype. numpy", "question_id": 19322}
{"snippet": "char.chararray.isdigit()", "intent": "Returns true for each element if all characters in the string are digits and there is at least one character , false otherwise . numpy", "question_id": 19323}
{"snippet": "ma.masked_invalid(a)", "intent": "Mask an array where invalid values occur ( NaNs or infs ) . This function is `a` shortcut to masked_where , with condition = ~ ( np.isfinite ( a ) ) . numpy", "question_id": 19324}
{"snippet": "ma.masked_invalid(a, copy=True)", "intent": "Mask an array where invalid values occur ( NaNs or infs ) . This function is `a` shortcut to masked_where , with condition = ~ ( np.isfinite ( a ) ) . With arguments `copy`. numpy", "question_id": 19325}
{"snippet": "ma.atleast_3d(*args, **kwargs)", "intent": "View inputs as arrays with at least three dimensions . With arguments `*args`, `**kwargs`. numpy", "question_id": 19326}
{"snippet": "generic.__array_struct__", "intent": "Array protocol: struct numpy", "question_id": 19327}
{"snippet": "numpy.lib.Arrayterator(var)", "intent": "Buffered iterator for big arrays . With arguments `var`. numpy", "question_id": 19328}
{"snippet": "numpy.lib.Arrayterator(var, buf_size=None)", "intent": "Buffered iterator for big arrays . if `buf_size` is smaller than d1 , the first dimension will be used . With arguments `var`. numpy", "question_id": 19329}
{"snippet": "polynomial.laguerre.lagweight(x)", "intent": "Weight function of the Laguerre polynomials . With arguments `x`. numpy", "question_id": 19330}
{"snippet": "polynomial.chebyshev.chebpts2(npts)", "intent": "Chebyshev points of the second kind . The Chebyshev points of the second kind are the points cos ( x ) , where x = [ pi * k/ ( `npts` - 1 ) for k in range ( npts ) ] . numpy", "question_id": 19331}
{"snippet": "ma.MaskType.newbyteorder(/)", "intent": "Return a new dtype with a different byte order . With arguments `/`. numpy", "question_id": 19332}
{"snippet": "ma.MaskType.newbyteorder(/, new_order='S')", "intent": "Return a new dtype with a different byte order . The `new_order` code can be any from the following : With arguments `/`. numpy", "question_id": 19333}
{"snippet": "dtype.kind", "intent": "A character code (one of \u2018biufcmMOSUV\u2019) identifying the general kind of data. numpy", "question_id": 19334}
{"snippet": "polynomial.hermite_e.hermeval(x, c)", "intent": "Evaluate an HermiteE series at points `x` . If `c` is of length n + 1 , this function returns the value : numpy", "question_id": 19335}
{"snippet": "polynomial.hermite_e.hermeval(x, c, tensor=True)", "intent": "Evaluate an HermiteE series at points `x` . If `c` is of length n + 1 , this function returns the value : If c is multidimensional , then the shape of the result depends on the value of `tensor` . numpy", "question_id": 19336}
{"snippet": "random.RandomState.noncentral_f(dfnum, dfden, nonc)", "intent": "Draw samples from the noncentral F distribution . Samples are drawn from an F distribution with specified parameters , `dfnum` ( degrees of freedom in numerator ) and `dfden` ( degrees of freedom in denominator ) , where both parameters > 1. `nonc` is the non-centrality parameter . numpy", "question_id": 19337}
{"snippet": "random.RandomState.noncentral_f(dfnum, dfden, nonc, size=None)", "intent": "Draw samples from the noncentral F distribution . Samples are drawn from an F distribution with specified parameters , `dfnum` ( degrees of freedom in numerator ) and `dfden` ( degrees of freedom in denominator ) , where both parameters > 1. `nonc` is the non-centrality parameter . With arguments `size`. numpy", "question_id": 19338}
{"snippet": "recarray.prod()", "intent": "Return the product of the array elements over the given `axis` numpy", "question_id": 19339}
{"snippet": "recarray.prod(axis=None)", "intent": "Return the product of the array elements over the given `axis` numpy", "question_id": 19340}
{"snippet": "recarray.prod(dtype=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `dtype`. numpy", "question_id": 19341}
{"snippet": "recarray.prod(out=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `out`. numpy", "question_id": 19342}
{"snippet": "recarray.prod(keepdims=False)", "intent": "Return the product of the array elements over the given `axis` With arguments `keepdims`. numpy", "question_id": 19343}
{"snippet": "recarray.prod(initial=1)", "intent": "Return the product of the array elements over the given `axis` With arguments `initial`. numpy", "question_id": 19344}
{"snippet": "recarray.prod(where=True)", "intent": "Return the product of the array elements over the given `axis` With arguments `where`. numpy", "question_id": 19345}
{"snippet": "recarray.prod(axis=None, dtype=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `dtype`. numpy", "question_id": 19346}
{"snippet": "recarray.prod(axis=None, out=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `out`. numpy", "question_id": 19347}
{"snippet": "recarray.prod(axis=None, keepdims=False)", "intent": "Return the product of the array elements over the given `axis` With arguments `keepdims`. numpy", "question_id": 19348}
{"snippet": "numpy.nanargmin(a)", "intent": "Return the indices of the minimum values in the specified `axis` ignoring NaNs . Warning : the results can not be trusted if `a` slice contains only NaNs and Infs . numpy", "question_id": 19349}
{"snippet": "numpy.nanargmin(a, axis=None)", "intent": "Return the indices of the minimum values in the specified `axis` ignoring NaNs . Warning : the results can not be trusted if `a` slice contains only NaNs and Infs . numpy", "question_id": 19350}
{"snippet": "polynomial.hermite_e.hermemulx(c)", "intent": "Multiply a Hermite series by x . Multiply the Hermite series `c` by x , where x is the independent variable . numpy", "question_id": 19351}
{"snippet": "ndarray.prod()", "intent": "Return the product of the array elements over the given `axis` numpy", "question_id": 19352}
{"snippet": "ndarray.prod(axis=None)", "intent": "Return the product of the array elements over the given `axis` numpy", "question_id": 19353}
{"snippet": "ndarray.prod(dtype=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `dtype`. numpy", "question_id": 19354}
{"snippet": "ndarray.prod(out=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `out`. numpy", "question_id": 19355}
{"snippet": "ndarray.prod(keepdims=False)", "intent": "Return the product of the array elements over the given `axis` With arguments `keepdims`. numpy", "question_id": 19356}
{"snippet": "ndarray.prod(initial=1)", "intent": "Return the product of the array elements over the given `axis` With arguments `initial`. numpy", "question_id": 19357}
{"snippet": "ndarray.prod(where=True)", "intent": "Return the product of the array elements over the given `axis` With arguments `where`. numpy", "question_id": 19358}
{"snippet": "ndarray.prod(axis=None, dtype=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `dtype`. numpy", "question_id": 19359}
{"snippet": "ndarray.prod(axis=None, out=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `out`. numpy", "question_id": 19360}
{"snippet": "ndarray.prod(axis=None, keepdims=False)", "intent": "Return the product of the array elements over the given `axis` With arguments `keepdims`. numpy", "question_id": 19361}
{"snippet": "ndarray.__len__(/)", "intent": "Return len ( self ) . With arguments `/`. numpy", "question_id": 19362}
{"snippet": "polynomial.legendre.Legendre.deriv()", "intent": "Differentiate . numpy", "question_id": 19363}
{"snippet": "polynomial.legendre.Legendre.deriv(m=1)", "intent": "Differentiate . With arguments `m`. numpy", "question_id": 19364}
{"snippet": "numpy.outer(a, b)", "intent": "Compute the outer product of two vectors . Given two vectors , `a` = [ a0 , a1 , ... , aM ] and `b` = [ b0 , b1 , ... , bN ] , the outer product [ 1 ] is : numpy", "question_id": 19365}
{"snippet": "numpy.outer(a, b, out=None)", "intent": "Compute the outer product of two vectors . Given two vectors , `a` = [ a0 , a1 , ... , aM ] and `b` = [ b0 , b1 , ... , bN ] , the outer product [ 1 ] is : With arguments `out`. numpy", "question_id": 19366}
{"snippet": "matrix.setflags()", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . numpy", "question_id": 19367}
{"snippet": "matrix.setflags(write=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`. numpy", "question_id": 19368}
{"snippet": "matrix.setflags(align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`. numpy", "question_id": 19369}
{"snippet": "matrix.setflags(uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `uic`. numpy", "question_id": 19370}
{"snippet": "matrix.setflags(write=None, align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`. numpy", "question_id": 19371}
{"snippet": "matrix.setflags(write=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `uic`. numpy", "question_id": 19372}
{"snippet": "matrix.setflags(align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`, `uic`. numpy", "question_id": 19373}
{"snippet": "matrix.setflags(write=None, align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`, `uic`. numpy", "question_id": 19374}
{"snippet": "recarray.shape", "intent": "Tuple of array dimensions. numpy", "question_id": 19375}
{"snippet": "ndarray.max()", "intent": "Return the maximum along a given `axis` . numpy", "question_id": 19376}
{"snippet": "ndarray.max(axis=None)", "intent": "Return the maximum along a given `axis` . numpy", "question_id": 19377}
{"snippet": "ndarray.max(out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`. numpy", "question_id": 19378}
{"snippet": "ndarray.max(keepdims=False)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 19379}
{"snippet": "ndarray.max(initial=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `initial`. numpy", "question_id": 19380}
{"snippet": "ndarray.max(where=True)", "intent": "Return the maximum along a given `axis` . With arguments `where`. numpy", "question_id": 19381}
{"snippet": "ndarray.max(axis=None, out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`. numpy", "question_id": 19382}
{"snippet": "ndarray.max(axis=None, keepdims=False)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 19383}
{"snippet": "ndarray.max(axis=None, initial=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `initial`. numpy", "question_id": 19384}
{"snippet": "ndarray.max(axis=None, where=True)", "intent": "Return the maximum along a given `axis` . With arguments `where`. numpy", "question_id": 19385}
{"snippet": "recarray.clip(**kwargs)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 19386}
{"snippet": "recarray.clip(**kwargs, min=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 19387}
{"snippet": "recarray.clip(**kwargs, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 19388}
{"snippet": "recarray.clip(**kwargs, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 19389}
{"snippet": "recarray.clip(**kwargs, min=None, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 19390}
{"snippet": "recarray.clip(**kwargs, min=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 19391}
{"snippet": "recarray.clip(**kwargs, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 19392}
{"snippet": "recarray.clip(**kwargs, min=None, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 19393}
{"snippet": "memmap.argpartition(kth)", "intent": "Returns the indices that would partition this array . With arguments `kth`. numpy", "question_id": 19394}
{"snippet": "memmap.argpartition(kth, axis=- 1)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`. numpy", "question_id": 19395}
{"snippet": "memmap.argpartition(kth, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`. numpy", "question_id": 19396}
{"snippet": "memmap.argpartition(kth, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `order`. numpy", "question_id": 19397}
{"snippet": "memmap.argpartition(kth, axis=- 1, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`. numpy", "question_id": 19398}
{"snippet": "memmap.argpartition(kth, axis=- 1, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `order`. numpy", "question_id": 19399}
{"snippet": "memmap.argpartition(kth, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`, `order`. numpy", "question_id": 19400}
{"snippet": "memmap.argpartition(kth, axis=- 1, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`, `order`. numpy", "question_id": 19401}
{"snippet": "ma.masked_array.tofile(fid)", "intent": "Save a masked array to a file in binary `format` . With arguments `fid`. numpy", "question_id": 19402}
{"snippet": "ma.masked_array.tofile(fid, sep='')", "intent": "Save a masked array to a file in binary `format` . With arguments `fid`, `sep`. numpy", "question_id": 19403}
{"snippet": "ma.masked_array.tofile(fid, format='%s')", "intent": "Save a masked array to a file in binary `format` . With arguments `fid`. numpy", "question_id": 19404}
{"snippet": "ma.masked_array.tofile(fid, sep='', format='%s')", "intent": "Save a masked array to a file in binary `format` . With arguments `fid`, `sep`. numpy", "question_id": 19405}
{"snippet": "chararray.setflags()", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . numpy", "question_id": 19406}
{"snippet": "chararray.setflags(write=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`. numpy", "question_id": 19407}
{"snippet": "chararray.setflags(align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`. numpy", "question_id": 19408}
{"snippet": "chararray.setflags(uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `uic`. numpy", "question_id": 19409}
{"snippet": "chararray.setflags(write=None, align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`. numpy", "question_id": 19410}
{"snippet": "chararray.setflags(write=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `uic`. numpy", "question_id": 19411}
{"snippet": "chararray.setflags(align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`, `uic`. numpy", "question_id": 19412}
{"snippet": "chararray.setflags(write=None, align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`, `uic`. numpy", "question_id": 19413}
{"snippet": "random.shuffle(x)", "intent": "Modify a sequence in-place by shuffling its contents . With arguments `x`. numpy", "question_id": 19414}
{"snippet": "ma.MaskedArray.__floordiv__(other)", "intent": "Divide `other` into self , and return a new masked array . numpy", "question_id": 19415}
{"snippet": "matrix.itemset(*args)", "intent": "Insert scalar into an array ( scalar is cast to array \u2019 s dtype , if possible ) With arguments `*args`. numpy", "question_id": 19416}
{"snippet": "ma.masked_array.compressed()", "intent": "Return all the non-masked data as a 1-D array . numpy", "question_id": 19417}
{"snippet": "linalg.tensorsolve(a, b)", "intent": "Solve the tensor equation `a` x = `b` for x . numpy", "question_id": 19418}
{"snippet": "linalg.tensorsolve(a, b, axes=None)", "intent": "Solve the tensor equation `a` x = `b` for x . With arguments `axes`. numpy", "question_id": 19419}
{"snippet": "ma.MaskedArray.mean()", "intent": "Returns the average of the array elements along given `axis` . numpy", "question_id": 19420}
{"snippet": "ma.MaskedArray.mean(axis=None)", "intent": "Returns the average of the array elements along given `axis` . numpy", "question_id": 19421}
{"snippet": "ma.MaskedArray.mean(dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 19422}
{"snippet": "ma.MaskedArray.mean(out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 19423}
{"snippet": "ma.MaskedArray.mean(keepdims=<no value>)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`. numpy", "question_id": 19424}
{"snippet": "ma.MaskedArray.mean(axis=None, dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 19425}
{"snippet": "ma.MaskedArray.mean(axis=None, out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 19426}
{"snippet": "ma.MaskedArray.mean(axis=None, keepdims=<no value>)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`. numpy", "question_id": 19427}
{"snippet": "ma.MaskedArray.mean(dtype=None, out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 19428}
{"snippet": "ma.MaskedArray.mean(dtype=None, keepdims=<no value>)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`, `keepdims`. numpy", "question_id": 19429}
{"snippet": "random.seed(self)", "intent": "Reseed a legacy MT19937 BitGenerator With arguments `self`. numpy", "question_id": 19430}
{"snippet": "random.seed(self, seed=None)", "intent": "Reseed a legacy MT19937 BitGenerator With arguments `self`, `seed`. numpy", "question_id": 19431}
{"snippet": "ma.MaskType.flags", "intent": "The integer value of flags. numpy", "question_id": 19432}
{"snippet": "numpy.tile(A, reps)", "intent": "Construct an array by repeating `A` the number of times given by `reps` . numpy", "question_id": 19433}
{"snippet": "ma.MaskedArray.dumps()", "intent": "Returns the pickle of the array as a string . numpy", "question_id": 19434}
{"snippet": "numpy.angle(z)", "intent": "Return the angle of the complex argument . With arguments `z`. numpy", "question_id": 19435}
{"snippet": "numpy.angle(z, deg=False)", "intent": "Return the angle of the complex argument . With arguments `z`, `deg`. numpy", "question_id": 19436}
{"snippet": "numpy.swapaxes(a, axis1, axis2)", "intent": "Interchange two axes of an array . With arguments `a`, `axis1`, `axis2`. numpy", "question_id": 19437}
{"snippet": "matrix.ravel()", "intent": "Return a flattened matrix . numpy", "question_id": 19438}
{"snippet": "matrix.ravel(order='C')", "intent": "Return a flattened matrix . With arguments `order`. numpy", "question_id": 19439}
{"snippet": "flatiter.copy()", "intent": "Get a copy of the iterator as a 1-D array . numpy", "question_id": 19440}
{"snippet": "char.chararray.swapcase()", "intent": "For each element in self , return a copy of the string with uppercase characters converted to lowercase and vice versa . numpy", "question_id": 19441}
{"snippet": "polynomial.laguerre.Laguerre.linspace()", "intent": "Return x , y values at equally spaced points in `domain` . numpy", "question_id": 19442}
{"snippet": "polynomial.laguerre.Laguerre.linspace(n=100)", "intent": "Return x , y values at equally spaced points in `domain` . Returns the x , y values at `n` linearly spaced points across the domain . numpy", "question_id": 19443}
{"snippet": "polynomial.laguerre.Laguerre.linspace(domain=None)", "intent": "Return x , y values at equally spaced points in `domain` . numpy", "question_id": 19444}
{"snippet": "polynomial.laguerre.Laguerre.linspace(n=100, domain=None)", "intent": "Return x , y values at equally spaced points in `domain` . Returns the x , y values at `n` linearly spaced points across the domain . numpy", "question_id": 19445}
{"snippet": "random.permutation(x)", "intent": "Randomly permute a sequence , or return a permuted range . If `x` is a multi-dimensional array , it is only shuffled along its first index . numpy", "question_id": 19446}
{"snippet": "ma.MaskedArray.__contains__(key, /)", "intent": "Return `key` in self . With arguments `/`. numpy", "question_id": 19447}
{"snippet": "recarray.real", "intent": "The real part of the array. numpy", "question_id": 19448}
{"snippet": "polynomial.legendre.Legendre.truncate(size)", "intent": "Truncate series to length `size` . numpy", "question_id": 19449}
{"snippet": "ndarray.dump(file)", "intent": "Dump a pickle of the array to the specified `file` . numpy", "question_id": 19450}
{"snippet": "polynomial.laguerre.lagadd(c1, c2)", "intent": "Add one Laguerre series to another . Returns the sum of two Laguerre series `c1` + `c2` . numpy", "question_id": 19451}
{"snippet": "numpy.arctanh(x, /, signature, extobj)", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 19452}
{"snippet": "numpy.arctanh(x, /, signature, extobj, out=None)", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 19453}
{"snippet": "numpy.arctanh(x, /, signature, extobj, where=True)", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 19454}
{"snippet": "numpy.arctanh(x, /, signature, extobj, casting='same_kind')", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 19455}
{"snippet": "numpy.arctanh(x, /, signature, extobj, order='K')", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 19456}
{"snippet": "numpy.arctanh(x, /, signature, extobj, dtype=None)", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 19457}
{"snippet": "numpy.arctanh(x, /, signature, extobj, subok=True)", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 19458}
{"snippet": "numpy.arctanh(x, /, signature, extobj, out=None, where=True)", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 19459}
{"snippet": "numpy.arctanh(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 19460}
{"snippet": "numpy.arctanh(x, /, signature, extobj, out=None, order='K')", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 19461}
{"snippet": "numpy.arctanh(x, /, signature)", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`. numpy", "question_id": 19462}
{"snippet": "numpy.arctanh(x, /, signature, out=None)", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `out`. numpy", "question_id": 19463}
{"snippet": "numpy.arctanh(x, /, signature, where=True)", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `where`. numpy", "question_id": 19464}
{"snippet": "numpy.arctanh(x, /, signature, casting='same_kind')", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `casting`. numpy", "question_id": 19465}
{"snippet": "numpy.arctanh(x, /, signature, order='K')", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `order`. numpy", "question_id": 19466}
{"snippet": "numpy.arctanh(x, /, signature, dtype=None)", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 19467}
{"snippet": "numpy.arctanh(x, /, signature, subok=True)", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `subok`. numpy", "question_id": 19468}
{"snippet": "numpy.arctanh(x, /, signature, out=None, where=True)", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 19469}
{"snippet": "numpy.arctanh(x, /, signature, out=None, casting='same_kind')", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 19470}
{"snippet": "numpy.arctanh(x, /, signature, out=None, order='K')", "intent": "Inverse hyperbolic tangent element-wise . arctanh is a multivalued function : for each `x` there are infinitely many numbers z such that tanh ( z ) = x . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 19471}
{"snippet": "record.swapaxes()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 19472}
{"snippet": "matrix.size", "intent": "Number of elements in the array. numpy", "question_id": 19473}
{"snippet": "numpy.nancumprod(a)", "intent": "Return the cumulative product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as one . numpy", "question_id": 19474}
{"snippet": "numpy.nancumprod(a, axis=None)", "intent": "Return the cumulative product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as one . numpy", "question_id": 19475}
{"snippet": "numpy.nancumprod(a, dtype=None)", "intent": "Return the cumulative product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as one . With arguments `dtype`. numpy", "question_id": 19476}
{"snippet": "numpy.nancumprod(a, out=None)", "intent": "Return the cumulative product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as one . With arguments `out`. numpy", "question_id": 19477}
{"snippet": "numpy.nancumprod(a, axis=None, dtype=None)", "intent": "Return the cumulative product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as one . With arguments `dtype`. numpy", "question_id": 19478}
{"snippet": "numpy.nancumprod(a, axis=None, out=None)", "intent": "Return the cumulative product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as one . With arguments `out`. numpy", "question_id": 19479}
{"snippet": "numpy.nancumprod(a, dtype=None, out=None)", "intent": "Return the cumulative product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as one . With arguments `dtype`, `out`. numpy", "question_id": 19480}
{"snippet": "numpy.nancumprod(a, axis=None, dtype=None, out=None)", "intent": "Return the cumulative product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as one . With arguments `dtype`, `out`. numpy", "question_id": 19481}
{"snippet": "polynomial.polyutils.getdomain(x)", "intent": "Return a domain suitable for given abscissae . With arguments `x`. numpy", "question_id": 19482}
{"snippet": "numpy.ix_(*args)", "intent": "Construct an open mesh from multiple sequences . With arguments `*args`. numpy", "question_id": 19483}
{"snippet": "polynomial.laguerre.lagval3d(x, y, z, c)", "intent": "Evaluate a 3-D Laguerre series at points ( `x` , `y` , `z` ) . In either case , either x , y , and z or their elements must support multiplication and addition both with themselves and with the elements of `c` . numpy", "question_id": 19484}
{"snippet": "numpy.gcd(x1, x2, /, signature, extobj)", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`. numpy", "question_id": 19485}
{"snippet": "numpy.gcd(x1, x2, /, signature, extobj, out=None)", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 19486}
{"snippet": "numpy.gcd(x1, x2, /, signature, extobj, where=True)", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `where`. numpy", "question_id": 19487}
{"snippet": "numpy.gcd(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 19488}
{"snippet": "numpy.gcd(x1, x2, /, signature, extobj, order='K')", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 19489}
{"snippet": "numpy.gcd(x1, x2, /, signature, extobj, dtype=None)", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 19490}
{"snippet": "numpy.gcd(x1, x2, /, signature, extobj, subok=True)", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 19491}
{"snippet": "numpy.gcd(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 19492}
{"snippet": "numpy.gcd(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 19493}
{"snippet": "numpy.gcd(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 19494}
{"snippet": "numpy.gcd(x1, x2, /, signature)", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`. numpy", "question_id": 19495}
{"snippet": "numpy.gcd(x1, x2, /, signature, out=None)", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `out`. numpy", "question_id": 19496}
{"snippet": "numpy.gcd(x1, x2, /, signature, where=True)", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `where`. numpy", "question_id": 19497}
{"snippet": "numpy.gcd(x1, x2, /, signature, casting='same_kind')", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `casting`. numpy", "question_id": 19498}
{"snippet": "numpy.gcd(x1, x2, /, signature, order='K')", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `order`. numpy", "question_id": 19499}
{"snippet": "numpy.gcd(x1, x2, /, signature, dtype=None)", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `dtype`. numpy", "question_id": 19500}
{"snippet": "numpy.gcd(x1, x2, /, signature, subok=True)", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `subok`. numpy", "question_id": 19501}
{"snippet": "numpy.gcd(x1, x2, /, signature, out=None, where=True)", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `out`, `where`. numpy", "question_id": 19502}
{"snippet": "numpy.gcd(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `out`, `casting`. numpy", "question_id": 19503}
{"snippet": "numpy.gcd(x1, x2, /, signature, out=None, order='K')", "intent": "Returns the greatest common divisor of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `out`, `order`. numpy", "question_id": 19504}
{"snippet": "ma.masked_array.torecords()", "intent": "Transforms a masked array into a flexible-type array . numpy", "question_id": 19505}
{"snippet": "polynomial.chebyshev.Chebyshev.identity()", "intent": "Identity function . numpy", "question_id": 19506}
{"snippet": "polynomial.chebyshev.Chebyshev.identity(domain=None)", "intent": "Identity function . With arguments `domain`. numpy", "question_id": 19507}
{"snippet": "polynomial.chebyshev.Chebyshev.identity(window=None)", "intent": "Identity function . With arguments `window`. numpy", "question_id": 19508}
{"snippet": "polynomial.chebyshev.Chebyshev.identity(domain=None, window=None)", "intent": "Identity function . With arguments `domain`, `window`. numpy", "question_id": 19509}
{"snippet": "char.chararray.setflags()", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . numpy", "question_id": 19510}
{"snippet": "char.chararray.setflags(write=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`. numpy", "question_id": 19511}
{"snippet": "char.chararray.setflags(align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`. numpy", "question_id": 19512}
{"snippet": "char.chararray.setflags(uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `uic`. numpy", "question_id": 19513}
{"snippet": "char.chararray.setflags(write=None, align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`. numpy", "question_id": 19514}
{"snippet": "char.chararray.setflags(write=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `uic`. numpy", "question_id": 19515}
{"snippet": "char.chararray.setflags(align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`, `uic`. numpy", "question_id": 19516}
{"snippet": "char.chararray.setflags(write=None, align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`, `uic`. numpy", "question_id": 19517}
{"snippet": "dtype.name", "intent": "A bit-width name for this data-type. numpy", "question_id": 19518}
{"snippet": "numpy.issubclass_(arg1, arg2)", "intent": "Determine if a class is a subclass of a second class . With arguments `arg1`, `arg2`. numpy", "question_id": 19519}
{"snippet": "ma.resize(x, new_shape)", "intent": "Return a new masked array with the specified size and shape . The new array is filled with repeated copies of `x` ( in the order that the data are stored in memory ) . With arguments `new_shape`. numpy", "question_id": 19520}
{"snippet": "ma.expand_dims(a, axis)", "intent": "Expand the shape of an array . Insert `a` new `axis` that will appear at the axis position in the expanded array shape . numpy", "question_id": 19521}
{"snippet": "record.imag", "intent": "The imaginary part of the scalar. numpy", "question_id": 19522}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.is_cached()", "intent": "Returns True if the class loaded from the cache file numpy", "question_id": 19523}
{"snippet": "polynomial.hermite.hermadd(c1, c2)", "intent": "Add one Hermite series to another . Returns the sum of two Hermite series `c1` + `c2` . numpy", "question_id": 19524}
{"snippet": "numpy.vstack(tup)", "intent": "Stack arrays in sequence vertically ( row wise ) . With arguments `tup`. numpy", "question_id": 19525}
{"snippet": "polynomial.chebyshev.chebgauss(deg)", "intent": "Gauss-Chebyshev quadrature . These sample points and weights will correctly integrate polynomials of degree \\ ( 2 * `deg` - 1\\ ) or less over the interval \\ ( [ -1 , 1 ] \\ ) with the weight function \\ ( f ( x ) = 1/\\sqrt { 1 - x^2 } \\ ) . numpy", "question_id": 19526}
{"snippet": "polynomial.hermite.hermline(off, scl)", "intent": "Hermite series whose graph is a straight line . With arguments `off`, `scl`. numpy", "question_id": 19527}
{"snippet": "chararray.itemset(*args)", "intent": "Insert scalar into an array ( scalar is cast to array \u2019 s dtype , if possible ) With arguments `*args`. numpy", "question_id": 19528}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_get_til(names, keyisfalse)", "intent": "same as feature_implies_c ( ) but stop collecting implied features when feature \u2019 s option that provided through parameter \u2018 `keyisfalse` \u2019 is False , also sorting the returned features . With arguments `names`. numpy", "question_id": 19529}
{"snippet": "core.records.fromfile(fd)", "intent": "Create an array from binary file data With arguments `fd`. numpy", "question_id": 19530}
{"snippet": "core.records.fromfile(fd, dtype=None)", "intent": "Create an array from binary file data With arguments `fd`, `dtype`. numpy", "question_id": 19531}
{"snippet": "core.records.fromfile(fd, shape=None)", "intent": "Create an array from binary file data With arguments `fd`, `shape`. numpy", "question_id": 19532}
{"snippet": "core.records.fromfile(fd, offset=0)", "intent": "Create an array from binary file data With arguments `fd`, `offset`. numpy", "question_id": 19533}
{"snippet": "core.records.fromfile(fd, formats=None)", "intent": "Create an array from binary file data With arguments `fd`, `formats`. numpy", "question_id": 19534}
{"snippet": "core.records.fromfile(fd, names=None)", "intent": "Create an array from binary file data With arguments `fd`, `names`. numpy", "question_id": 19535}
{"snippet": "core.records.fromfile(fd, titles=None)", "intent": "Create an array from binary file data With arguments `fd`, `titles`. numpy", "question_id": 19536}
{"snippet": "core.records.fromfile(fd, aligned=False)", "intent": "Create an array from binary file data With arguments `fd`, `aligned`. numpy", "question_id": 19537}
{"snippet": "core.records.fromfile(fd, byteorder=None)", "intent": "Create an array from binary file data With arguments `fd`, `byteorder`. numpy", "question_id": 19538}
{"snippet": "core.records.fromfile(fd, dtype=None, shape=None)", "intent": "Create an array from binary file data With arguments `fd`, `dtype`, `shape`. numpy", "question_id": 19539}
{"snippet": "polynomial.polynomial.Polynomial.fit(x, y, deg)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`. numpy", "question_id": 19540}
{"snippet": "polynomial.polynomial.Polynomial.fit(x, y, deg, domain=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`. numpy", "question_id": 19541}
{"snippet": "polynomial.polynomial.Polynomial.fit(x, y, deg, rcond=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `rcond`. numpy", "question_id": 19542}
{"snippet": "polynomial.polynomial.Polynomial.fit(x, y, deg, full=False)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `full`. numpy", "question_id": 19543}
{"snippet": "polynomial.polynomial.Polynomial.fit(x, y, deg, w=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `w`. numpy", "question_id": 19544}
{"snippet": "polynomial.polynomial.Polynomial.fit(x, y, deg, window=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `window`. numpy", "question_id": 19545}
{"snippet": "polynomial.polynomial.Polynomial.fit(x, y, deg, domain=None, rcond=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `rcond`. numpy", "question_id": 19546}
{"snippet": "polynomial.polynomial.Polynomial.fit(x, y, deg, domain=None, full=False)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `full`. numpy", "question_id": 19547}
{"snippet": "polynomial.polynomial.Polynomial.fit(x, y, deg, domain=None, w=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `w`. numpy", "question_id": 19548}
{"snippet": "polynomial.polynomial.Polynomial.fit(x, y, deg, domain=None, window=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `window`. numpy", "question_id": 19549}
{"snippet": "char.chararray.translate(table)", "intent": "For each element in self , return a copy of the string where all characters occurring in the optional argument `deletechars` are removed , and the remaining characters have been mapped through the given translation `table` . numpy", "question_id": 19550}
{"snippet": "char.chararray.translate(table, deletechars=None)", "intent": "For each element in self , return a copy of the string where all characters occurring in the optional argument `deletechars` are removed , and the remaining characters have been mapped through the given translation `table` . numpy", "question_id": 19551}
{"snippet": "ma.MaskedArray.__mul__(other)", "intent": "Multiply self by `other` , and return a new masked array . numpy", "question_id": 19552}
{"snippet": "fft.rfft(a)", "intent": "Compute the one-dimensional discrete Fourier Transform for real input . This function computes the one-dimensional n-point discrete Fourier Transform ( DFT ) of `a` real-valued array by means of an efficient algorithm called the Fast Fourier Transform ( FFT ) . numpy", "question_id": 19553}
{"snippet": "fft.rfft(a, n=None)", "intent": "Compute the one-dimensional discrete Fourier Transform for real input . This function computes the one-dimensional n-point discrete Fourier Transform ( DFT ) of `a` real-valued array by means of an efficient algorithm called the Fast Fourier Transform ( FFT ) . If `n` is even , A [ -1 ] contains the term representing both positive and negative Nyquist frequency ( +fs/2 and -fs/2 ) , and must also be purely real . numpy", "question_id": 19554}
{"snippet": "fft.rfft(a, axis=- 1)", "intent": "Compute the one-dimensional discrete Fourier Transform for real input . This function computes the one-dimensional n-point discrete Fourier Transform ( DFT ) of `a` real-valued array by means of an efficient algorithm called the Fast Fourier Transform ( FFT ) . This function does not compute the negative frequency terms , and the length of the transformed `axis` of the output is therefore n//2 + 1 . numpy", "question_id": 19555}
{"snippet": "fft.rfft(a, norm=None)", "intent": "Compute the one-dimensional discrete Fourier Transform for real input . This function computes the one-dimensional n-point discrete Fourier Transform ( DFT ) of `a` real-valued array by means of an efficient algorithm called the Fast Fourier Transform ( FFT ) . With arguments `norm`. numpy", "question_id": 19556}
{"snippet": "fft.rfft(a, n=None, axis=- 1)", "intent": "Compute the one-dimensional discrete Fourier Transform for real input . This function computes the one-dimensional n-point discrete Fourier Transform ( DFT ) of `a` real-valued array by means of an efficient algorithm called the Fast Fourier Transform ( FFT ) . If `n` is even , A [ -1 ] contains the term representing both positive and negative Nyquist frequency ( +fs/2 and -fs/2 ) , and must also be purely real . This function does not compute the negative frequency terms , and the length of the transformed `axis` of the output is therefore n//2 + 1 . numpy", "question_id": 19557}
{"snippet": "fft.rfft(a, n=None, norm=None)", "intent": "Compute the one-dimensional discrete Fourier Transform for real input . This function computes the one-dimensional n-point discrete Fourier Transform ( DFT ) of `a` real-valued array by means of an efficient algorithm called the Fast Fourier Transform ( FFT ) . If `n` is even , A [ -1 ] contains the term representing both positive and negative Nyquist frequency ( +fs/2 and -fs/2 ) , and must also be purely real . With arguments `norm`. numpy", "question_id": 19558}
{"snippet": "fft.rfft(a, axis=- 1, norm=None)", "intent": "Compute the one-dimensional discrete Fourier Transform for real input . This function computes the one-dimensional n-point discrete Fourier Transform ( DFT ) of `a` real-valued array by means of an efficient algorithm called the Fast Fourier Transform ( FFT ) . This function does not compute the negative frequency terms , and the length of the transformed `axis` of the output is therefore n//2 + 1 . With arguments `norm`. numpy", "question_id": 19559}
{"snippet": "fft.rfft(a, n=None, axis=- 1, norm=None)", "intent": "Compute the one-dimensional discrete Fourier Transform for real input . This function computes the one-dimensional n-point discrete Fourier Transform ( DFT ) of `a` real-valued array by means of an efficient algorithm called the Fast Fourier Transform ( FFT ) . If `n` is even , A [ -1 ] contains the term representing both positive and negative Nyquist frequency ( +fs/2 and -fs/2 ) , and must also be purely real . This function does not compute the negative frequency terms , and the length of the transformed `axis` of the output is therefore n//2 + 1 . With arguments `norm`. numpy", "question_id": 19560}
{"snippet": "memmap.astype(dtype)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`. numpy", "question_id": 19561}
{"snippet": "memmap.astype(dtype, order='K')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`. numpy", "question_id": 19562}
{"snippet": "memmap.astype(dtype, casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`. numpy", "question_id": 19563}
{"snippet": "memmap.astype(dtype, subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `subok`. numpy", "question_id": 19564}
{"snippet": "memmap.astype(dtype, copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `copy`. numpy", "question_id": 19565}
{"snippet": "memmap.astype(dtype, order='K', casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `casting`. numpy", "question_id": 19566}
{"snippet": "memmap.astype(dtype, order='K', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `subok`. numpy", "question_id": 19567}
{"snippet": "memmap.astype(dtype, order='K', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `copy`. numpy", "question_id": 19568}
{"snippet": "memmap.astype(dtype, casting='unsafe', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `subok`. numpy", "question_id": 19569}
{"snippet": "memmap.astype(dtype, casting='unsafe', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `copy`. numpy", "question_id": 19570}
{"snippet": "matrix.imag", "intent": "The imaginary part of the array. numpy", "question_id": 19571}
{"snippet": "matrix.getfield(dtype)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements . numpy", "question_id": 19572}
{"snippet": "matrix.getfield(dtype, offset=0)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements . The values in the view are determined by the given type and the `offset` into the current array in bytes . numpy", "question_id": 19573}
{"snippet": "matrix.nonzero()", "intent": "Return the indices of the elements that are non-zero . numpy", "question_id": 19574}
{"snippet": "char.chararray.argmax()", "intent": "Return indices of the maximum values along the given `axis` . numpy", "question_id": 19575}
{"snippet": "char.chararray.argmax(axis=None)", "intent": "Return indices of the maximum values along the given `axis` . numpy", "question_id": 19576}
{"snippet": "char.chararray.argmax(out=None)", "intent": "Return indices of the maximum values along the given `axis` . With arguments `out`. numpy", "question_id": 19577}
{"snippet": "char.chararray.argmax(axis=None, out=None)", "intent": "Return indices of the maximum values along the given `axis` . With arguments `out`. numpy", "question_id": 19578}
{"snippet": "ma.masked_array.sort()", "intent": "Sort the array , in-place numpy", "question_id": 19579}
{"snippet": "ma.masked_array.sort(axis=- 1)", "intent": "Sort the array , in-place With arguments `axis`. numpy", "question_id": 19580}
{"snippet": "ma.masked_array.sort(kind=None)", "intent": "Sort the array , in-place With arguments `kind`. numpy", "question_id": 19581}
{"snippet": "ma.masked_array.sort(order=None)", "intent": "Sort the array , in-place With arguments `order`. numpy", "question_id": 19582}
{"snippet": "ma.masked_array.sort(endwith=True)", "intent": "Sort the array , in-place With arguments `endwith`. numpy", "question_id": 19583}
{"snippet": "ma.masked_array.sort(fill_value=None)", "intent": "Sort the array , in-place With arguments `fill_value`. numpy", "question_id": 19584}
{"snippet": "ma.masked_array.sort(axis=- 1, kind=None)", "intent": "Sort the array , in-place With arguments `axis`, `kind`. numpy", "question_id": 19585}
{"snippet": "ma.masked_array.sort(axis=- 1, order=None)", "intent": "Sort the array , in-place With arguments `axis`, `order`. numpy", "question_id": 19586}
{"snippet": "ma.masked_array.sort(axis=- 1, endwith=True)", "intent": "Sort the array , in-place With arguments `axis`, `endwith`. numpy", "question_id": 19587}
{"snippet": "ma.masked_array.sort(axis=- 1, fill_value=None)", "intent": "Sort the array , in-place With arguments `axis`, `fill_value`. numpy", "question_id": 19588}
{"snippet": "polynomial.legendre.Legendre.identity()", "intent": "Identity function . numpy", "question_id": 19589}
{"snippet": "polynomial.legendre.Legendre.identity(domain=None)", "intent": "Identity function . With arguments `domain`. numpy", "question_id": 19590}
{"snippet": "polynomial.legendre.Legendre.identity(window=None)", "intent": "Identity function . With arguments `window`. numpy", "question_id": 19591}
{"snippet": "polynomial.legendre.Legendre.identity(domain=None, window=None)", "intent": "Identity function . With arguments `domain`, `window`. numpy", "question_id": 19592}
{"snippet": "memmap.ctypes", "intent": "An object to simplify the interaction of the array with the ctypes module. numpy", "question_id": 19593}
{"snippet": "_ctypes.data", "intent": "A pointer to the memory area of the array as a Python integer. numpy", "question_id": 19594}
{"snippet": "_ctypes.shape", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the C-integer corresponding to dtype('p') on this platform. numpy", "question_id": 19595}
{"snippet": "_ctypes.strides", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the same as for the shape attribute. numpy", "question_id": 19596}
{"snippet": "_ctypes.data_as(obj)", "intent": "Return the data pointer cast to a particular c-types object . With arguments `obj`. numpy", "question_id": 19597}
{"snippet": "_ctypes.shape_as(obj)", "intent": "Return the shape tuple as an array of some other c-types type . With arguments `obj`. numpy", "question_id": 19598}
{"snippet": "_ctypes.strides_as(obj)", "intent": "Return the strides tuple as an array of some other c-types type . With arguments `obj`. numpy", "question_id": 19599}
{"snippet": "record.cumprod()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 19600}
{"snippet": "random.Generator.integers(low)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) , or if endpoint=True , low ( inclusive ) to high ( inclusive ) . numpy", "question_id": 19601}
{"snippet": "random.Generator.integers(low, high=None)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) , or if endpoint=True , low ( inclusive ) to high ( inclusive ) . numpy", "question_id": 19602}
{"snippet": "random.Generator.integers(low, size=None)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) , or if endpoint=True , low ( inclusive ) to high ( inclusive ) . With arguments `size`. numpy", "question_id": 19603}
{"snippet": "random.Generator.integers(low, dtype=np.int64)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) , or if endpoint=True , low ( inclusive ) to high ( inclusive ) . Return random integers from the \u201c discrete uniform \u201d distribution of the specified `dtype` . numpy", "question_id": 19604}
{"snippet": "random.Generator.integers(low, endpoint=False)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) , or if endpoint=True , low ( inclusive ) to high ( inclusive ) . With arguments `endpoint`. numpy", "question_id": 19605}
{"snippet": "random.Generator.integers(low, high=None, size=None)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) , or if endpoint=True , low ( inclusive ) to high ( inclusive ) . With arguments `size`. numpy", "question_id": 19606}
{"snippet": "random.Generator.integers(low, high=None, dtype=np.int64)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) , or if endpoint=True , low ( inclusive ) to high ( inclusive ) . Return random integers from the \u201c discrete uniform \u201d distribution of the specified `dtype` . numpy", "question_id": 19607}
{"snippet": "random.Generator.integers(low, high=None, endpoint=False)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) , or if endpoint=True , low ( inclusive ) to high ( inclusive ) . With arguments `endpoint`. numpy", "question_id": 19608}
{"snippet": "random.Generator.integers(low, size=None, dtype=np.int64)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) , or if endpoint=True , low ( inclusive ) to high ( inclusive ) . Return random integers from the \u201c discrete uniform \u201d distribution of the specified `dtype` . With arguments `size`. numpy", "question_id": 19609}
{"snippet": "random.Generator.integers(low, size=None, endpoint=False)", "intent": "Return random integers from `low` ( inclusive ) to `high` ( exclusive ) , or if endpoint=True , low ( inclusive ) to high ( inclusive ) . With arguments `size`, `endpoint`. numpy", "question_id": 19610}
{"snippet": "polynomial.chebyshev.chebvander2d(x, y, deg)", "intent": "Pseudo-Vandermonde matrix of given degrees . Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points ( `x` , `y` ) . numpy", "question_id": 19611}
{"snippet": "numpy.zeros(shape)", "intent": "Return a new array of given `shape` and type , filled with zeros . numpy", "question_id": 19612}
{"snippet": "numpy.zeros(shape, dtype=float)", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `dtype`. numpy", "question_id": 19613}
{"snippet": "numpy.zeros(shape, order='C')", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `order`. numpy", "question_id": 19614}
{"snippet": "numpy.zeros(shape, like=None)", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `like`. numpy", "question_id": 19615}
{"snippet": "numpy.zeros(shape, dtype=float, order='C')", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `dtype`, `order`. numpy", "question_id": 19616}
{"snippet": "numpy.zeros(shape, dtype=float, like=None)", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `dtype`, `like`. numpy", "question_id": 19617}
{"snippet": "numpy.zeros(shape, order='C', like=None)", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `order`, `like`. numpy", "question_id": 19618}
{"snippet": "numpy.zeros(shape, dtype=float, order='C', like=None)", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `dtype`, `order`, `like`. numpy", "question_id": 19619}
{"snippet": "polynomial.hermite_e.HermiteE.degree()", "intent": "The degree of the series . numpy", "question_id": 19620}
{"snippet": "polynomial.hermite_e.hermeline(off, scl)", "intent": "Hermite series whose graph is a straight line . With arguments `off`, `scl`. numpy", "question_id": 19621}
{"snippet": "numpy.nonzero(a)", "intent": "Return the indices of the elements that are non-zero . Returns `a` tuple of arrays , one for each dimension of a , containing the indices of the non-zero elements in that dimension . numpy", "question_id": 19622}
{"snippet": "polynomial.laguerre.Laguerre.__call__(arg)", "intent": "Call self as a function . With arguments `arg`. numpy", "question_id": 19623}
{"snippet": "ma.MaskedArray.put(indices, values)", "intent": "Set storage-indexed locations to corresponding `values` . Sets self._data.flat [ n ] = values [ n ] for each n in `indices` . numpy", "question_id": 19624}
{"snippet": "ma.MaskedArray.put(indices, values, mode='raise')", "intent": "Set storage-indexed locations to corresponding `values` . Sets self._data.flat [ n ] = values [ n ] for each n in `indices` . With arguments `mode`. numpy", "question_id": 19625}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_detect(names)", "intent": "Return a list of CPU features that required to be detected sorted from the lowest to highest interest . With arguments `names`. numpy", "question_id": 19626}
{"snippet": "testing.dec.deprecated()", "intent": "Filter deprecation warnings while running the test suite . numpy", "question_id": 19627}
{"snippet": "testing.dec.deprecated(conditional=True)", "intent": "Filter deprecation warnings while running the test suite . With arguments `conditional`. numpy", "question_id": 19628}
{"snippet": "fft.ifft2(a, - 1))", "intent": "Compute the 2-dimensional inverse discrete Fourier Transform . In other words , ifft2 ( fft2 ( `a` ) ) == a to within numerical accuracy . With arguments `- 1)`. numpy", "question_id": 19629}
{"snippet": "fft.ifft2(a, - 1), s=None)", "intent": "Compute the 2-dimensional inverse discrete Fourier Transform . In other words , ifft2 ( fft2 ( `a` ) ) == a to within numerical accuracy . With arguments `- 1)`, `s`. numpy", "question_id": 19630}
{"snippet": "fft.ifft2(a, - 1), axes=(- 2)", "intent": "Compute the 2-dimensional inverse discrete Fourier Transform . In other words , ifft2 ( fft2 ( `a` ) ) == a to within numerical accuracy . This function computes the inverse of the 2-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `- 1)`. numpy", "question_id": 19631}
{"snippet": "fft.ifft2(a, - 1), norm=None)", "intent": "Compute the 2-dimensional inverse discrete Fourier Transform . In other words , ifft2 ( fft2 ( `a` ) ) == a to within numerical accuracy . With arguments `- 1)`, `norm`. numpy", "question_id": 19632}
{"snippet": "fft.ifft2(a, - 1), s=None, axes=(- 2)", "intent": "Compute the 2-dimensional inverse discrete Fourier Transform . In other words , ifft2 ( fft2 ( `a` ) ) == a to within numerical accuracy . This function computes the inverse of the 2-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `- 1)`, `s`. numpy", "question_id": 19633}
{"snippet": "fft.ifft2(a, - 1), s=None, norm=None)", "intent": "Compute the 2-dimensional inverse discrete Fourier Transform . In other words , ifft2 ( fft2 ( `a` ) ) == a to within numerical accuracy . With arguments `- 1)`, `s`, `norm`. numpy", "question_id": 19634}
{"snippet": "fft.ifft2(a, - 1), axes=(- 2, norm=None)", "intent": "Compute the 2-dimensional inverse discrete Fourier Transform . In other words , ifft2 ( fft2 ( `a` ) ) == a to within numerical accuracy . This function computes the inverse of the 2-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `- 1)`, `norm`. numpy", "question_id": 19635}
{"snippet": "fft.ifft2(a, - 1), s=None, axes=(- 2, norm=None)", "intent": "Compute the 2-dimensional inverse discrete Fourier Transform . In other words , ifft2 ( fft2 ( `a` ) ) == a to within numerical accuracy . This function computes the inverse of the 2-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `- 1)`, `s`, `norm`. numpy", "question_id": 19636}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.dist_compile(sources, flags, **kwargs)", "intent": "Wrap CCompiler.compile ( ) With arguments `sources`, `flags`, `**kwargs`. numpy", "question_id": 19637}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.dist_compile(sources, flags, **kwargs, ccompiler=None)", "intent": "Wrap CCompiler.compile ( ) With arguments `sources`, `flags`, `**kwargs`, `ccompiler`. numpy", "question_id": 19638}
{"snippet": "polynomial.laguerre.lagvander2d(x, y, deg)", "intent": "Pseudo-Vandermonde matrix of given degrees . Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points ( `x` , `y` ) . numpy", "question_id": 19639}
{"snippet": "polynomial.hermite.Hermite.cast(series)", "intent": "Convert `series` to series of this class . numpy", "question_id": 19640}
{"snippet": "polynomial.hermite.Hermite.cast(series, domain=None)", "intent": "Convert `series` to series of this class . With arguments `domain`. numpy", "question_id": 19641}
{"snippet": "polynomial.hermite.Hermite.cast(series, window=None)", "intent": "Convert `series` to series of this class . With arguments `window`. numpy", "question_id": 19642}
{"snippet": "polynomial.hermite.Hermite.cast(series, domain=None, window=None)", "intent": "Convert `series` to series of this class . With arguments `domain`, `window`. numpy", "question_id": 19643}
{"snippet": "distutils.ccompiler.CCompiler_customize(self, dist)", "intent": "Do any platform-specific customization of a compiler instance . With arguments `self`, `dist`. numpy", "question_id": 19644}
{"snippet": "distutils.ccompiler.CCompiler_customize(self, dist, need_cxx=0)", "intent": "Do any platform-specific customization of a compiler instance . With arguments `self`, `dist`, `need_cxx`. numpy", "question_id": 19645}
{"snippet": "ma.MaskType.choose()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 19646}
{"snippet": "matrix.getA1()", "intent": "Return self as a flattened ndarray . numpy", "question_id": 19647}
{"snippet": "ndarray.any()", "intent": "Returns True if any of the elements of a evaluate to True . numpy", "question_id": 19648}
{"snippet": "ndarray.any(axis=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`. numpy", "question_id": 19649}
{"snippet": "ndarray.any(out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`. numpy", "question_id": 19650}
{"snippet": "ndarray.any(keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `keepdims`. numpy", "question_id": 19651}
{"snippet": "ndarray.any(where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `where`. numpy", "question_id": 19652}
{"snippet": "ndarray.any(axis=None, out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `out`. numpy", "question_id": 19653}
{"snippet": "ndarray.any(axis=None, keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `keepdims`. numpy", "question_id": 19654}
{"snippet": "ndarray.any(axis=None, where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `where`. numpy", "question_id": 19655}
{"snippet": "ndarray.any(out=None, keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`, `keepdims`. numpy", "question_id": 19656}
{"snippet": "ndarray.any(out=None, where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`, `where`. numpy", "question_id": 19657}
{"snippet": "polynomial.chebyshev.chebval(x, c)", "intent": "Evaluate a Chebyshev series at points `x` . If `c` is of length n + 1 , this function returns the value : numpy", "question_id": 19658}
{"snippet": "polynomial.chebyshev.chebval(x, c, tensor=True)", "intent": "Evaluate a Chebyshev series at points `x` . If `c` is of length n + 1 , this function returns the value : If c is multidimensional , then the shape of the result depends on the value of `tensor` . numpy", "question_id": 19659}
{"snippet": "ma.MaskedArray.__rdivmod__(value, /)", "intent": "Return divmod ( `value` , self ) . With arguments `/`. numpy", "question_id": 19660}
{"snippet": "ndarray.__imod__(value, /)", "intent": "Return self % =value . With arguments `value`, `/`. numpy", "question_id": 19661}
{"snippet": "ma.MaskType.view()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 19662}
{"snippet": "numpy.indices(dimensions)", "intent": "Return an array representing the indices of a grid . The output shape in the dense case is obtained by prepending the number of `dimensions` in front of the tuple of dimensions , i.e . numpy", "question_id": 19663}
{"snippet": "numpy.indices(dimensions, dtype=<class 'int'>)", "intent": "Return an array representing the indices of a grid . The output shape in the dense case is obtained by prepending the number of `dimensions` in front of the tuple of dimensions , i.e . With arguments `dtype`. numpy", "question_id": 19664}
{"snippet": "numpy.indices(dimensions, sparse=False)", "intent": "Return an array representing the indices of a grid . The output shape in the dense case is obtained by prepending the number of `dimensions` in front of the tuple of dimensions , i.e . If `sparse` is set to true , the grid will be returned in a sparse representation . numpy", "question_id": 19665}
{"snippet": "numpy.indices(dimensions, dtype=<class 'int'>, sparse=False)", "intent": "Return an array representing the indices of a grid . The output shape in the dense case is obtained by prepending the number of `dimensions` in front of the tuple of dimensions , i.e . If `sparse` is set to true , the grid will be returned in a sparse representation . With arguments `dtype`. numpy", "question_id": 19666}
{"snippet": "ma.MaskedArray.__and__(value, /)", "intent": "Return self & `value` . With arguments `/`. numpy", "question_id": 19667}
{"snippet": "numpy.format_parser(formats, names, titles)", "intent": "Class to convert `formats` , `names` , `titles` description to a dtype . numpy", "question_id": 19668}
{"snippet": "numpy.format_parser(formats, names, titles, aligned=False)", "intent": "Class to convert `formats` , `names` , `titles` description to a dtype . With arguments `aligned`. numpy", "question_id": 19669}
{"snippet": "numpy.format_parser(formats, names, titles, byteorder=None)", "intent": "Class to convert `formats` , `names` , `titles` description to a dtype . With arguments `byteorder`. numpy", "question_id": 19670}
{"snippet": "numpy.format_parser(formats, names, titles, aligned=False, byteorder=None)", "intent": "Class to convert `formats` , `names` , `titles` description to a dtype . With arguments `aligned`, `byteorder`. numpy", "question_id": 19671}
{"snippet": "polynomial.chebyshev.chebval3d(x, y, z, c)", "intent": "Evaluate a 3-D Chebyshev series at points ( `x` , `y` , `z` ) . In either case , either x , y , and z or their elements must support multiplication and addition both with themselves and with the elements of `c` . numpy", "question_id": 19672}
{"snippet": "numpy.ravel(a)", "intent": "Return `a` contiguous flattened array . numpy", "question_id": 19673}
{"snippet": "numpy.ravel(a, order='C')", "intent": "Return `a` contiguous flattened array . In row-major , C-style `order` , in two dimensions , the row index varies the slowest , and the column index the quickest . numpy", "question_id": 19674}
{"snippet": "char.strip(a)", "intent": "For each element in `a` , return a copy with the leading and trailing characters removed . numpy", "question_id": 19675}
{"snippet": "char.strip(a, chars=None)", "intent": "For each element in `a` , return a copy with the leading and trailing characters removed . With arguments `chars`. numpy", "question_id": 19676}
{"snippet": "ndarray.trace()", "intent": "Return the sum along diagonals of the array . numpy", "question_id": 19677}
{"snippet": "ndarray.trace(offset=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`. numpy", "question_id": 19678}
{"snippet": "ndarray.trace(axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `axis1`. numpy", "question_id": 19679}
{"snippet": "ndarray.trace(axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `axis2`. numpy", "question_id": 19680}
{"snippet": "ndarray.trace(dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `dtype`. numpy", "question_id": 19681}
{"snippet": "ndarray.trace(out=None)", "intent": "Return the sum along diagonals of the array . With arguments `out`. numpy", "question_id": 19682}
{"snippet": "ndarray.trace(offset=0, axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis1`. numpy", "question_id": 19683}
{"snippet": "ndarray.trace(offset=0, axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis2`. numpy", "question_id": 19684}
{"snippet": "ndarray.trace(offset=0, dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `dtype`. numpy", "question_id": 19685}
{"snippet": "ndarray.trace(offset=0, out=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `out`. numpy", "question_id": 19686}
{"snippet": "ufunc.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`. numpy", "question_id": 19687}
{"snippet": "polynomial.hermite.hermfromroots(roots)", "intent": "Generate a Hermite series with given `roots` . numpy", "question_id": 19688}
{"snippet": "ma.MaskedArray.all()", "intent": "Returns True if all elements evaluate to True . numpy", "question_id": 19689}
{"snippet": "ma.MaskedArray.all(axis=None)", "intent": "Returns True if all elements evaluate to True . The output array is masked where all the values along the given `axis` are masked : if the output would have been a scalar and that all the values are masked , then the output is masked . numpy", "question_id": 19690}
{"snippet": "ma.MaskedArray.all(out=None)", "intent": "Returns True if all elements evaluate to True . With arguments `out`. numpy", "question_id": 19691}
{"snippet": "ma.MaskedArray.all(keepdims=<no value>)", "intent": "Returns True if all elements evaluate to True . With arguments `keepdims`. numpy", "question_id": 19692}
{"snippet": "ma.MaskedArray.all(axis=None, out=None)", "intent": "Returns True if all elements evaluate to True . The output array is masked where all the values along the given `axis` are masked : if the output would have been a scalar and that all the values are masked , then the output is masked . With arguments `out`. numpy", "question_id": 19693}
{"snippet": "ma.MaskedArray.all(axis=None, keepdims=<no value>)", "intent": "Returns True if all elements evaluate to True . The output array is masked where all the values along the given `axis` are masked : if the output would have been a scalar and that all the values are masked , then the output is masked . With arguments `keepdims`. numpy", "question_id": 19694}
{"snippet": "ma.MaskedArray.all(out=None, keepdims=<no value>)", "intent": "Returns True if all elements evaluate to True . With arguments `out`, `keepdims`. numpy", "question_id": 19695}
{"snippet": "ma.MaskedArray.all(axis=None, out=None, keepdims=<no value>)", "intent": "Returns True if all elements evaluate to True . The output array is masked where all the values along the given `axis` are masked : if the output would have been a scalar and that all the values are masked , then the output is masked . With arguments `out`, `keepdims`. numpy", "question_id": 19696}
{"snippet": "char.chararray.transpose(*axes)", "intent": "Returns a view of the array with axes transposed . With arguments `*axes`. numpy", "question_id": 19697}
{"snippet": "numpy.tril_indices(n)", "intent": "Return the indices for the lower-triangle of an ( `n` , `m` ) array . numpy", "question_id": 19698}
{"snippet": "numpy.tril_indices(n, k=0)", "intent": "Return the indices for the lower-triangle of an ( `n` , `m` ) array . With arguments `k`. numpy", "question_id": 19699}
{"snippet": "numpy.tril_indices(n, m=None)", "intent": "Return the indices for the lower-triangle of an ( `n` , `m` ) array . numpy", "question_id": 19700}
{"snippet": "numpy.tril_indices(n, k=0, m=None)", "intent": "Return the indices for the lower-triangle of an ( `n` , `m` ) array . With arguments `k`. numpy", "question_id": 19701}
{"snippet": "char.str_len(a)", "intent": "Return len ( `a` ) element-wise . numpy", "question_id": 19702}
{"snippet": "numpy.iscomplexobj(x)", "intent": "Check for a complex type or an array of complex numbers . With arguments `x`. numpy", "question_id": 19703}
{"snippet": "numpy.result_type(*arrays_and_dtypes)", "intent": "Returns the type that results from applying the NumPy type promotion rules to the arguments . With arguments `*arrays_and_dtypes`. numpy", "question_id": 19704}
{"snippet": "matrix.min()", "intent": "Return the minimum value along an `axis` . numpy", "question_id": 19705}
{"snippet": "matrix.min(axis=None)", "intent": "Return the minimum value along an `axis` . numpy", "question_id": 19706}
{"snippet": "matrix.min(out=None)", "intent": "Return the minimum value along an `axis` . With arguments `out`. numpy", "question_id": 19707}
{"snippet": "matrix.min(axis=None, out=None)", "intent": "Return the minimum value along an `axis` . With arguments `out`. numpy", "question_id": 19708}
{"snippet": "char.chararray.index(sub)", "intent": "Like find , but raises ValueError when the substring is not found . With arguments `sub`. numpy", "question_id": 19709}
{"snippet": "char.chararray.index(sub, start=0)", "intent": "Like find , but raises ValueError when the substring is not found . With arguments `sub`, `start`. numpy", "question_id": 19710}
{"snippet": "char.chararray.index(sub, end=None)", "intent": "Like find , but raises ValueError when the substring is not found . With arguments `sub`, `end`. numpy", "question_id": 19711}
{"snippet": "char.chararray.index(sub, start=0, end=None)", "intent": "Like find , but raises ValueError when the substring is not found . With arguments `sub`, `start`, `end`. numpy", "question_id": 19712}
{"snippet": "ma.MaskedArray.__xor__(value, /)", "intent": "Return self^value . With arguments `value`, `/`. numpy", "question_id": 19713}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_sorted(names)", "intent": "Sort a list of CPU features ordered by the lowest interest . With arguments `names`. numpy", "question_id": 19714}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_sorted(names, reverse=False)", "intent": "Sort a list of CPU features ordered by the lowest interest . With arguments `names`, `reverse`. numpy", "question_id": 19715}
{"snippet": "record.var()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 19716}
{"snippet": "numpy.lcm(x1, x2, /, signature, extobj)", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`. numpy", "question_id": 19717}
{"snippet": "numpy.lcm(x1, x2, /, signature, extobj, out=None)", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 19718}
{"snippet": "numpy.lcm(x1, x2, /, signature, extobj, where=True)", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `where`. numpy", "question_id": 19719}
{"snippet": "numpy.lcm(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 19720}
{"snippet": "numpy.lcm(x1, x2, /, signature, extobj, order='K')", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 19721}
{"snippet": "numpy.lcm(x1, x2, /, signature, extobj, dtype=None)", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 19722}
{"snippet": "numpy.lcm(x1, x2, /, signature, extobj, subok=True)", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 19723}
{"snippet": "numpy.lcm(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 19724}
{"snippet": "numpy.lcm(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 19725}
{"snippet": "numpy.lcm(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 19726}
{"snippet": "numpy.lcm(x1, x2, /, signature)", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`. numpy", "question_id": 19727}
{"snippet": "numpy.lcm(x1, x2, /, signature, out=None)", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `out`. numpy", "question_id": 19728}
{"snippet": "numpy.lcm(x1, x2, /, signature, where=True)", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `where`. numpy", "question_id": 19729}
{"snippet": "numpy.lcm(x1, x2, /, signature, casting='same_kind')", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `casting`. numpy", "question_id": 19730}
{"snippet": "numpy.lcm(x1, x2, /, signature, order='K')", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `order`. numpy", "question_id": 19731}
{"snippet": "numpy.lcm(x1, x2, /, signature, dtype=None)", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `dtype`. numpy", "question_id": 19732}
{"snippet": "numpy.lcm(x1, x2, /, signature, subok=True)", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `subok`. numpy", "question_id": 19733}
{"snippet": "numpy.lcm(x1, x2, /, signature, out=None, where=True)", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `out`, `where`. numpy", "question_id": 19734}
{"snippet": "numpy.lcm(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `out`, `casting`. numpy", "question_id": 19735}
{"snippet": "numpy.lcm(x1, x2, /, signature, out=None, order='K')", "intent": "Returns the lowest common multiple of |x1| and |x2| With arguments `x1`, `x2`, `/`, `signature`, `out`, `order`. numpy", "question_id": 19736}
{"snippet": "numpy.moveaxis(a, source, destination)", "intent": "Move axes of an array to new positions . With arguments `a`, `source`, `destination`. numpy", "question_id": 19737}
{"snippet": "char.chararray.join(seq)", "intent": "Return a string which is the concatenation of the strings in the sequence `seq` . numpy", "question_id": 19738}
{"snippet": "numpy.append(arr, values)", "intent": "Append `values` to the end of an array . With arguments `arr`. numpy", "question_id": 19739}
{"snippet": "numpy.append(arr, values, axis=None)", "intent": "Append `values` to the end of an array . When `axis` is specified , values must have the correct shape . With arguments `arr`. numpy", "question_id": 19740}
{"snippet": "ndarray.__mod__(value, /)", "intent": "Return self % `value` . With arguments `/`. numpy", "question_id": 19741}
{"snippet": "ma.masked_array.searchsorted(v)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . numpy", "question_id": 19742}
{"snippet": "ma.masked_array.searchsorted(v, side='left')", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`. numpy", "question_id": 19743}
{"snippet": "ma.masked_array.searchsorted(v, sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `sorter`. numpy", "question_id": 19744}
{"snippet": "ma.masked_array.searchsorted(v, side='left', sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`, `sorter`. numpy", "question_id": 19745}
{"snippet": "ma.MaskedArray.resize(newshape)", "intent": "This method is difficult to implement safely and may be deprecated in future releases of NumPy . With arguments `newshape`. numpy", "question_id": 19746}
{"snippet": "ma.MaskedArray.resize(newshape, refcheck=True)", "intent": "This method is difficult to implement safely and may be deprecated in future releases of NumPy . With arguments `newshape`, `refcheck`. numpy", "question_id": 19747}
{"snippet": "ma.MaskedArray.resize(newshape, order=False)", "intent": "This method is difficult to implement safely and may be deprecated in future releases of NumPy . With arguments `newshape`, `order`. numpy", "question_id": 19748}
{"snippet": "ma.MaskedArray.resize(newshape, refcheck=True, order=False)", "intent": "This method is difficult to implement safely and may be deprecated in future releases of NumPy . With arguments `newshape`, `refcheck`, `order`. numpy", "question_id": 19749}
{"snippet": "ma.arange(start, stop, step)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . When using a non-integer `step` , such as 0.1 , the results will often not be consistent . numpy", "question_id": 19750}
{"snippet": "ma.arange(start, stop, step, dtype=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . When using a non-integer `step` , such as 0.1 , the results will often not be consistent . With arguments `dtype`. numpy", "question_id": 19751}
{"snippet": "ma.arange(start, stop, step, like=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . When using a non-integer `step` , such as 0.1 , the results will often not be consistent . With arguments `like`. numpy", "question_id": 19752}
{"snippet": "ma.arange(start, stop, step, dtype=None, like=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . When using a non-integer `step` , such as 0.1 , the results will often not be consistent . With arguments `dtype`, `like`. numpy", "question_id": 19753}
{"snippet": "ma.arange(start, stop)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . numpy", "question_id": 19754}
{"snippet": "ma.arange(start, stop, dtype=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . With arguments `dtype`. numpy", "question_id": 19755}
{"snippet": "ma.arange(start, stop, like=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . With arguments `like`. numpy", "question_id": 19756}
{"snippet": "ma.arange(start, stop, dtype=None, like=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . With arguments `dtype`, `like`. numpy", "question_id": 19757}
{"snippet": "ma.arange(start)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . numpy", "question_id": 19758}
{"snippet": "ma.arange(start, dtype=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . With arguments `dtype`. numpy", "question_id": 19759}
{"snippet": "ma.arange(start, like=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . With arguments `like`. numpy", "question_id": 19760}
{"snippet": "ma.arange(start, dtype=None, like=None)", "intent": "Return evenly spaced values within a given interval . Values are generated within the half-open interval [ `start` , `stop` ) ( in other words , the interval including start but excluding stop ) . With arguments `dtype`, `like`. numpy", "question_id": 19761}
{"snippet": "recarray.var()", "intent": "Returns the variance of the array elements , along given `axis` . numpy", "question_id": 19762}
{"snippet": "recarray.var(axis=None)", "intent": "Returns the variance of the array elements , along given `axis` . numpy", "question_id": 19763}
{"snippet": "recarray.var(dtype=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `dtype`. numpy", "question_id": 19764}
{"snippet": "recarray.var(out=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `out`. numpy", "question_id": 19765}
{"snippet": "recarray.var(ddof=0)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `ddof`. numpy", "question_id": 19766}
{"snippet": "recarray.var(keepdims=False)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `keepdims`. numpy", "question_id": 19767}
{"snippet": "recarray.var(where=True)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `where`. numpy", "question_id": 19768}
{"snippet": "recarray.var(axis=None, dtype=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `dtype`. numpy", "question_id": 19769}
{"snippet": "recarray.var(axis=None, out=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `out`. numpy", "question_id": 19770}
{"snippet": "recarray.var(axis=None, ddof=0)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `ddof`. numpy", "question_id": 19771}
{"snippet": "ma.squeeze(a)", "intent": "Remove axes of length one from `a` . numpy", "question_id": 19772}
{"snippet": "ma.squeeze(a, axis=None)", "intent": "Remove axes of length one from `a` . With arguments `axis`. numpy", "question_id": 19773}
{"snippet": "record.transpose()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 19774}
{"snippet": "matlib.zeros(shape)", "intent": "Return a matrix of given `shape` and type , filled with zeros . numpy", "question_id": 19775}
{"snippet": "matlib.zeros(shape, dtype=None)", "intent": "Return a matrix of given `shape` and type , filled with zeros . With arguments `dtype`. numpy", "question_id": 19776}
{"snippet": "matlib.zeros(shape, order='C')", "intent": "Return a matrix of given `shape` and type , filled with zeros . With arguments `order`. numpy", "question_id": 19777}
{"snippet": "matlib.zeros(shape, dtype=None, order='C')", "intent": "Return a matrix of given `shape` and type , filled with zeros . With arguments `dtype`, `order`. numpy", "question_id": 19778}
{"snippet": "recarray.fill(value)", "intent": "Fill the array with a scalar `value` . numpy", "question_id": 19779}
{"snippet": "ma.mask_or(m1, m2)", "intent": "Combine two masks with the logical_or operator . The result may be a view on `m1` or `m2` if the other is nomask ( i.e . numpy", "question_id": 19780}
{"snippet": "ma.mask_or(m1, m2, copy=False)", "intent": "Combine two masks with the logical_or operator . The result may be a view on `m1` or `m2` if the other is nomask ( i.e . With arguments `copy`. numpy", "question_id": 19781}
{"snippet": "ma.mask_or(m1, m2, shrink=True)", "intent": "Combine two masks with the logical_or operator . The result may be a view on `m1` or `m2` if the other is nomask ( i.e . With arguments `shrink`. numpy", "question_id": 19782}
{"snippet": "ma.mask_or(m1, m2, copy=False, shrink=True)", "intent": "Combine two masks with the logical_or operator . The result may be a view on `m1` or `m2` if the other is nomask ( i.e . With arguments `copy`, `shrink`. numpy", "question_id": 19783}
{"snippet": "char.chararray.put(indices, values)", "intent": "Set a.flat [ n ] = `values` [ n ] for all n in `indices` . numpy", "question_id": 19784}
{"snippet": "char.chararray.put(indices, values, mode='raise')", "intent": "Set a.flat [ n ] = `values` [ n ] for all n in `indices` . With arguments `mode`. numpy", "question_id": 19785}
{"snippet": "numpy.kron(a, b)", "intent": "Kronecker product of two arrays . Computes the Kronecker product , `a` composite array made of blocks of the second array scaled by the first . The function assumes that the number of dimensions of a and `b` are the same , if necessary prepending the smallest with ones . numpy", "question_id": 19786}
{"snippet": "char.chararray.swapaxes(axis1, axis2)", "intent": "Return a view of the array with `axis1` and `axis2` interchanged . numpy", "question_id": 19787}
{"snippet": "polynomial.polynomial.Polynomial.linspace()", "intent": "Return x , y values at equally spaced points in `domain` . numpy", "question_id": 19788}
{"snippet": "polynomial.polynomial.Polynomial.linspace(n=100)", "intent": "Return x , y values at equally spaced points in `domain` . Returns the x , y values at `n` linearly spaced points across the domain . numpy", "question_id": 19789}
{"snippet": "polynomial.polynomial.Polynomial.linspace(domain=None)", "intent": "Return x , y values at equally spaced points in `domain` . numpy", "question_id": 19790}
{"snippet": "polynomial.polynomial.Polynomial.linspace(n=100, domain=None)", "intent": "Return x , y values at equally spaced points in `domain` . Returns the x , y values at `n` linearly spaced points across the domain . numpy", "question_id": 19791}
{"snippet": "ufunc.nargs", "intent": "The number of arguments. numpy", "question_id": 19792}
{"snippet": "numpy.bmat(obj)", "intent": "Build a matrix object from a string , nested sequence , or array . With arguments `obj`. numpy", "question_id": 19793}
{"snippet": "numpy.bmat(obj, ldict=None)", "intent": "Build a matrix object from a string , nested sequence , or array . With arguments `obj`, `ldict`. numpy", "question_id": 19794}
{"snippet": "numpy.bmat(obj, gdict=None)", "intent": "Build a matrix object from a string , nested sequence , or array . With arguments `obj`, `gdict`. numpy", "question_id": 19795}
{"snippet": "numpy.bmat(obj, ldict=None, gdict=None)", "intent": "Build a matrix object from a string , nested sequence , or array . With arguments `obj`, `ldict`, `gdict`. numpy", "question_id": 19796}
{"snippet": "char.chararray.round()", "intent": "Return a with each element rounded to the given number of `decimals` . numpy", "question_id": 19797}
{"snippet": "char.chararray.round(decimals=0)", "intent": "Return a with each element rounded to the given number of `decimals` . numpy", "question_id": 19798}
{"snippet": "char.chararray.round(out=None)", "intent": "Return a with each element rounded to the given number of `decimals` . With arguments `out`. numpy", "question_id": 19799}
{"snippet": "char.chararray.round(decimals=0, out=None)", "intent": "Return a with each element rounded to the given number of `decimals` . With arguments `out`. numpy", "question_id": 19800}
{"snippet": "numpy.iscomplex(x)", "intent": "Returns a bool array , where True if input element is complex . With arguments `x`. numpy", "question_id": 19801}
{"snippet": "polynomial.hermite.Hermite.roots()", "intent": "Return the roots of the series polynomial . numpy", "question_id": 19802}
{"snippet": "ndarray.__itruediv__(value, /)", "intent": "Return self/=value . With arguments `value`, `/`. numpy", "question_id": 19803}
{"snippet": "numpy.fmod(x1, x2, /, signature, extobj)", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 19804}
{"snippet": "numpy.fmod(x1, x2, /, signature, extobj, out=None)", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 19805}
{"snippet": "numpy.fmod(x1, x2, /, signature, extobj, where=True)", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 19806}
{"snippet": "numpy.fmod(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 19807}
{"snippet": "numpy.fmod(x1, x2, /, signature, extobj, order='K')", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 19808}
{"snippet": "numpy.fmod(x1, x2, /, signature, extobj, dtype=None)", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 19809}
{"snippet": "numpy.fmod(x1, x2, /, signature, extobj, subok=True)", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 19810}
{"snippet": "numpy.fmod(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 19811}
{"snippet": "numpy.fmod(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 19812}
{"snippet": "numpy.fmod(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 19813}
{"snippet": "numpy.fmod(x1, x2, /, signature)", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`. numpy", "question_id": 19814}
{"snippet": "numpy.fmod(x1, x2, /, signature, out=None)", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `out`. numpy", "question_id": 19815}
{"snippet": "numpy.fmod(x1, x2, /, signature, where=True)", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `where`. numpy", "question_id": 19816}
{"snippet": "numpy.fmod(x1, x2, /, signature, casting='same_kind')", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `casting`. numpy", "question_id": 19817}
{"snippet": "numpy.fmod(x1, x2, /, signature, order='K')", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `order`. numpy", "question_id": 19818}
{"snippet": "numpy.fmod(x1, x2, /, signature, dtype=None)", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 19819}
{"snippet": "numpy.fmod(x1, x2, /, signature, subok=True)", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `subok`. numpy", "question_id": 19820}
{"snippet": "numpy.fmod(x1, x2, /, signature, out=None, where=True)", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 19821}
{"snippet": "numpy.fmod(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 19822}
{"snippet": "numpy.fmod(x1, x2, /, signature, out=None, order='K')", "intent": "Return the element-wise remainder of division . This is the NumPy implementation of the C library function fmod , the remainder has the same sign as the dividend `x1` . It is equivalent to the Matlab ( TM ) rem function and should not be confused with the Python modulus operator x1 % `x2` . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 19823}
{"snippet": "dtype.char", "intent": "A unique character code for each of the 21 different built-in types. numpy", "question_id": 19824}
{"snippet": "ma.MaskedArray.anom()", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . numpy", "question_id": 19825}
{"snippet": "ma.MaskedArray.anom(axis=None)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . numpy", "question_id": 19826}
{"snippet": "ma.MaskedArray.anom(dtype=None)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . With arguments `dtype`. numpy", "question_id": 19827}
{"snippet": "ma.MaskedArray.anom(axis=None, dtype=None)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . With arguments `dtype`. numpy", "question_id": 19828}
{"snippet": "ma.cumsum(self)", "intent": "Return the cumulative sum of the array elements over the given `axis` . With arguments `self`. numpy", "question_id": 19829}
{"snippet": "ma.cumsum(self, axis=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . With arguments `self`. numpy", "question_id": 19830}
{"snippet": "ma.cumsum(self, dtype=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . With arguments `self`, `dtype`. numpy", "question_id": 19831}
{"snippet": "ma.cumsum(self, out=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . The mask is lost if `out` is not a valid ma.MaskedArray ! With arguments `self`. numpy", "question_id": 19832}
{"snippet": "ma.cumsum(self, axis=None, dtype=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . With arguments `self`, `dtype`. numpy", "question_id": 19833}
{"snippet": "ma.cumsum(self, axis=None, out=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . The mask is lost if `out` is not a valid ma.MaskedArray ! With arguments `self`. numpy", "question_id": 19834}
{"snippet": "ma.cumsum(self, dtype=None, out=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . The mask is lost if `out` is not a valid ma.MaskedArray ! With arguments `self`, `dtype`. numpy", "question_id": 19835}
{"snippet": "ma.cumsum(self, axis=None, dtype=None, out=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . The mask is lost if `out` is not a valid ma.MaskedArray ! With arguments `self`, `dtype`. numpy", "question_id": 19836}
{"snippet": "fft.ifftshift(x)", "intent": "The inverse of fftshift . Although identical for even-length `x` , the functions differ by one sample for odd-length x . numpy", "question_id": 19837}
{"snippet": "fft.ifftshift(x, axes=None)", "intent": "The inverse of fftshift . Although identical for even-length `x` , the functions differ by one sample for odd-length x . With arguments `axes`. numpy", "question_id": 19838}
{"snippet": "polynomial.hermite_e.HermiteE.fit(x, y, deg)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`. numpy", "question_id": 19839}
{"snippet": "polynomial.hermite_e.HermiteE.fit(x, y, deg, domain=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`. numpy", "question_id": 19840}
{"snippet": "polynomial.hermite_e.HermiteE.fit(x, y, deg, rcond=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `rcond`. numpy", "question_id": 19841}
{"snippet": "polynomial.hermite_e.HermiteE.fit(x, y, deg, full=False)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `full`. numpy", "question_id": 19842}
{"snippet": "polynomial.hermite_e.HermiteE.fit(x, y, deg, w=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `w`. numpy", "question_id": 19843}
{"snippet": "polynomial.hermite_e.HermiteE.fit(x, y, deg, window=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `window`. numpy", "question_id": 19844}
{"snippet": "polynomial.hermite_e.HermiteE.fit(x, y, deg, domain=None, rcond=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `rcond`. numpy", "question_id": 19845}
{"snippet": "polynomial.hermite_e.HermiteE.fit(x, y, deg, domain=None, full=False)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `full`. numpy", "question_id": 19846}
{"snippet": "polynomial.hermite_e.HermiteE.fit(x, y, deg, domain=None, w=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `w`. numpy", "question_id": 19847}
{"snippet": "polynomial.hermite_e.HermiteE.fit(x, y, deg, domain=None, window=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `window`. numpy", "question_id": 19848}
{"snippet": "ma.MaskedArray.__le__(value, /)", "intent": "Return self < =value . With arguments `value`, `/`. numpy", "question_id": 19849}
{"snippet": "chararray.item(*args)", "intent": "Copy an element of an array to a standard Python scalar and return it . With arguments `*args`. numpy", "question_id": 19850}
{"snippet": "matrix.var()", "intent": "Returns the variance of the matrix elements , along the given `axis` . numpy", "question_id": 19851}
{"snippet": "matrix.var(axis=None)", "intent": "Returns the variance of the matrix elements , along the given `axis` . numpy", "question_id": 19852}
{"snippet": "matrix.var(dtype=None)", "intent": "Returns the variance of the matrix elements , along the given `axis` . With arguments `dtype`. numpy", "question_id": 19853}
{"snippet": "matrix.var(out=None)", "intent": "Returns the variance of the matrix elements , along the given `axis` . With arguments `out`. numpy", "question_id": 19854}
{"snippet": "matrix.var(ddof=0)", "intent": "Returns the variance of the matrix elements , along the given `axis` . With arguments `ddof`. numpy", "question_id": 19855}
{"snippet": "matrix.var(axis=None, dtype=None)", "intent": "Returns the variance of the matrix elements , along the given `axis` . With arguments `dtype`. numpy", "question_id": 19856}
{"snippet": "matrix.var(axis=None, out=None)", "intent": "Returns the variance of the matrix elements , along the given `axis` . With arguments `out`. numpy", "question_id": 19857}
{"snippet": "matrix.var(axis=None, ddof=0)", "intent": "Returns the variance of the matrix elements , along the given `axis` . With arguments `ddof`. numpy", "question_id": 19858}
{"snippet": "matrix.var(dtype=None, out=None)", "intent": "Returns the variance of the matrix elements , along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 19859}
{"snippet": "matrix.var(dtype=None, ddof=0)", "intent": "Returns the variance of the matrix elements , along the given `axis` . With arguments `dtype`, `ddof`. numpy", "question_id": 19860}
{"snippet": "ndarray.ndim", "intent": "Number of array dimensions. numpy", "question_id": 19861}
{"snippet": "testing.run_module_suite()", "intent": "Run a test module . numpy", "question_id": 19862}
{"snippet": "testing.run_module_suite(file_to_run=None)", "intent": "Run a test module . Equivalent to calling $ nosetests < `argv` > < `file_to_run` > from the command line numpy", "question_id": 19863}
{"snippet": "testing.run_module_suite(argv=None)", "intent": "Run a test module . Equivalent to calling $ nosetests < `argv` > < `file_to_run` > from the command line numpy", "question_id": 19864}
{"snippet": "testing.run_module_suite(file_to_run=None, argv=None)", "intent": "Run a test module . Equivalent to calling $ nosetests < `argv` > < `file_to_run` > from the command line numpy", "question_id": 19865}
{"snippet": "ma.isarray(x)", "intent": "Test whether input is an instance of MaskedArray . This function returns True if `x` is an instance of MaskedArray and returns False otherwise . numpy", "question_id": 19866}
{"snippet": "testing.suppress_warnings.record()", "intent": "Append a new recording filter or apply it if the state is entered . numpy", "question_id": 19867}
{"snippet": "testing.suppress_warnings.record(category=<class 'Warning'>)", "intent": "Append a new recording filter or apply it if the state is entered . With arguments `category`. numpy", "question_id": 19868}
{"snippet": "testing.suppress_warnings.record(message='')", "intent": "Append a new recording filter or apply it if the state is entered . With arguments `message`. numpy", "question_id": 19869}
{"snippet": "testing.suppress_warnings.record(module=None)", "intent": "Append a new recording filter or apply it if the state is entered . With arguments `module`. numpy", "question_id": 19870}
{"snippet": "testing.suppress_warnings.record(category=<class 'Warning'>, message='')", "intent": "Append a new recording filter or apply it if the state is entered . With arguments `category`, `message`. numpy", "question_id": 19871}
{"snippet": "testing.suppress_warnings.record(category=<class 'Warning'>, module=None)", "intent": "Append a new recording filter or apply it if the state is entered . With arguments `category`, `module`. numpy", "question_id": 19872}
{"snippet": "testing.suppress_warnings.record(message='', module=None)", "intent": "Append a new recording filter or apply it if the state is entered . With arguments `message`, `module`. numpy", "question_id": 19873}
{"snippet": "testing.suppress_warnings.record(category=<class 'Warning'>, message='', module=None)", "intent": "Append a new recording filter or apply it if the state is entered . With arguments `category`, `message`, `module`. numpy", "question_id": 19874}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_is_exist(name)", "intent": "Returns True if a certain feature is exist and covered within _Config.conf_features . With arguments `name`. numpy", "question_id": 19875}
{"snippet": "numpy.unpackbits(a)", "intent": "Unpacks elements of `a` uint8 array into a binary-valued output array . numpy", "question_id": 19876}
{"snippet": "numpy.unpackbits(a, axis=None)", "intent": "Unpacks elements of `a` uint8 array into a binary-valued output array . The shape of the output array is either 1-D ( if `axis` is None ) or the same shape as the input array with unpacking done along the axis specified . numpy", "question_id": 19877}
{"snippet": "numpy.unpackbits(a, count=None)", "intent": "Unpacks elements of `a` uint8 array into a binary-valued output array . With arguments `count`. numpy", "question_id": 19878}
{"snippet": "numpy.unpackbits(a, bitorder='big')", "intent": "Unpacks elements of `a` uint8 array into a binary-valued output array . With arguments `bitorder`. numpy", "question_id": 19879}
{"snippet": "numpy.unpackbits(a, axis=None, count=None)", "intent": "Unpacks elements of `a` uint8 array into a binary-valued output array . The shape of the output array is either 1-D ( if `axis` is None ) or the same shape as the input array with unpacking done along the axis specified . With arguments `count`. numpy", "question_id": 19880}
{"snippet": "numpy.unpackbits(a, axis=None, bitorder='big')", "intent": "Unpacks elements of `a` uint8 array into a binary-valued output array . The shape of the output array is either 1-D ( if `axis` is None ) or the same shape as the input array with unpacking done along the axis specified . With arguments `bitorder`. numpy", "question_id": 19881}
{"snippet": "numpy.unpackbits(a, count=None, bitorder='big')", "intent": "Unpacks elements of `a` uint8 array into a binary-valued output array . With arguments `count`, `bitorder`. numpy", "question_id": 19882}
{"snippet": "numpy.unpackbits(a, axis=None, count=None, bitorder='big')", "intent": "Unpacks elements of `a` uint8 array into a binary-valued output array . The shape of the output array is either 1-D ( if `axis` is None ) or the same shape as the input array with unpacking done along the axis specified . With arguments `count`, `bitorder`. numpy", "question_id": 19883}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_implies(names)", "intent": "Return a set of CPU features that implied by \u2018 `names` \u2019 numpy", "question_id": 19884}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_implies(names, keep_origins=False)", "intent": "Return a set of CPU features that implied by \u2018 `names` \u2019 With arguments `keep_origins`. numpy", "question_id": 19885}
{"snippet": "memmap.diagonal()", "intent": "Return specified diagonals . numpy", "question_id": 19886}
{"snippet": "memmap.diagonal(offset=0)", "intent": "Return specified diagonals . With arguments `offset`. numpy", "question_id": 19887}
{"snippet": "memmap.diagonal(axis1=0)", "intent": "Return specified diagonals . With arguments `axis1`. numpy", "question_id": 19888}
{"snippet": "memmap.diagonal(axis2=1)", "intent": "Return specified diagonals . With arguments `axis2`. numpy", "question_id": 19889}
{"snippet": "memmap.diagonal(offset=0, axis1=0)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`. numpy", "question_id": 19890}
{"snippet": "memmap.diagonal(offset=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis2`. numpy", "question_id": 19891}
{"snippet": "memmap.diagonal(axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `axis1`, `axis2`. numpy", "question_id": 19892}
{"snippet": "memmap.diagonal(offset=0, axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`, `axis2`. numpy", "question_id": 19893}
{"snippet": "polynomial.legendre.Legendre.convert()", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 19894}
{"snippet": "polynomial.legendre.Legendre.convert(domain=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 19895}
{"snippet": "polynomial.legendre.Legendre.convert(kind=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 19896}
{"snippet": "polynomial.legendre.Legendre.convert(window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 19897}
{"snippet": "polynomial.legendre.Legendre.convert(domain=None, kind=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 19898}
{"snippet": "polynomial.legendre.Legendre.convert(domain=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 19899}
{"snippet": "polynomial.legendre.Legendre.convert(kind=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 19900}
{"snippet": "polynomial.legendre.Legendre.convert(domain=None, kind=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 19901}
{"snippet": "char.chararray.endswith(suffix)", "intent": "Returns a boolean array which is True where the string element in self ends with `suffix` , otherwise False . numpy", "question_id": 19902}
{"snippet": "char.chararray.endswith(suffix, start=0)", "intent": "Returns a boolean array which is True where the string element in self ends with `suffix` , otherwise False . With arguments `start`. numpy", "question_id": 19903}
{"snippet": "char.chararray.endswith(suffix, end=None)", "intent": "Returns a boolean array which is True where the string element in self ends with `suffix` , otherwise False . With arguments `end`. numpy", "question_id": 19904}
{"snippet": "char.chararray.endswith(suffix, start=0, end=None)", "intent": "Returns a boolean array which is True where the string element in self ends with `suffix` , otherwise False . With arguments `start`, `end`. numpy", "question_id": 19905}
{"snippet": "numpy.conjugate(x, /, signature, extobj)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`. numpy", "question_id": 19906}
{"snippet": "numpy.conjugate(x, /, signature, extobj, out=None)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 19907}
{"snippet": "numpy.conjugate(x, /, signature, extobj, where=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `where`. numpy", "question_id": 19908}
{"snippet": "numpy.conjugate(x, /, signature, extobj, casting='same_kind')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 19909}
{"snippet": "numpy.conjugate(x, /, signature, extobj, order='K')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 19910}
{"snippet": "numpy.conjugate(x, /, signature, extobj, dtype=None)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 19911}
{"snippet": "numpy.conjugate(x, /, signature, extobj, subok=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 19912}
{"snippet": "numpy.conjugate(x, /, signature, extobj, out=None, where=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 19913}
{"snippet": "numpy.conjugate(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 19914}
{"snippet": "numpy.conjugate(x, /, signature, extobj, out=None, order='K')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 19915}
{"snippet": "numpy.conjugate(x, /, signature)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`. numpy", "question_id": 19916}
{"snippet": "numpy.conjugate(x, /, signature, out=None)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `out`. numpy", "question_id": 19917}
{"snippet": "numpy.conjugate(x, /, signature, where=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `where`. numpy", "question_id": 19918}
{"snippet": "numpy.conjugate(x, /, signature, casting='same_kind')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `casting`. numpy", "question_id": 19919}
{"snippet": "numpy.conjugate(x, /, signature, order='K')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `order`. numpy", "question_id": 19920}
{"snippet": "numpy.conjugate(x, /, signature, dtype=None)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `dtype`. numpy", "question_id": 19921}
{"snippet": "numpy.conjugate(x, /, signature, subok=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `subok`. numpy", "question_id": 19922}
{"snippet": "numpy.conjugate(x, /, signature, out=None, where=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `out`, `where`. numpy", "question_id": 19923}
{"snippet": "numpy.conjugate(x, /, signature, out=None, casting='same_kind')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `out`, `casting`. numpy", "question_id": 19924}
{"snippet": "numpy.conjugate(x, /, signature, out=None, order='K')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `out`, `order`. numpy", "question_id": 19925}
{"snippet": "recarray.setfield(val, dtype)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field . numpy", "question_id": 19926}
{"snippet": "recarray.setfield(val, dtype, offset=0)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field . numpy", "question_id": 19927}
{"snippet": "linalg.det(a)", "intent": "Compute the determinant of an array . The determinant of `a` 2-D array [ [ a , b ] , [ c , d ] ] is ad - bc : numpy", "question_id": 19928}
{"snippet": "lib.stride_tricks.as_strided(x)", "intent": "Create a view into the array with the given `shape` and `strides` . With arguments `x`. numpy", "question_id": 19929}
{"snippet": "lib.stride_tricks.as_strided(x, shape=None)", "intent": "Create a view into the array with the given `shape` and `strides` . With arguments `x`. numpy", "question_id": 19930}
{"snippet": "lib.stride_tricks.as_strided(x, strides=None)", "intent": "Create a view into the array with the given `shape` and `strides` . With arguments `x`. numpy", "question_id": 19931}
{"snippet": "lib.stride_tricks.as_strided(x, subok=False)", "intent": "Create a view into the array with the given `shape` and `strides` . With arguments `x`, `subok`. numpy", "question_id": 19932}
{"snippet": "lib.stride_tricks.as_strided(x, writeable=True)", "intent": "Create a view into the array with the given `shape` and `strides` . With arguments `x`, `writeable`. numpy", "question_id": 19933}
{"snippet": "lib.stride_tricks.as_strided(x, shape=None, strides=None)", "intent": "Create a view into the array with the given `shape` and `strides` . With arguments `x`. numpy", "question_id": 19934}
{"snippet": "lib.stride_tricks.as_strided(x, shape=None, subok=False)", "intent": "Create a view into the array with the given `shape` and `strides` . With arguments `x`, `subok`. numpy", "question_id": 19935}
{"snippet": "lib.stride_tricks.as_strided(x, shape=None, writeable=True)", "intent": "Create a view into the array with the given `shape` and `strides` . With arguments `x`, `writeable`. numpy", "question_id": 19936}
{"snippet": "lib.stride_tricks.as_strided(x, strides=None, subok=False)", "intent": "Create a view into the array with the given `shape` and `strides` . With arguments `x`, `subok`. numpy", "question_id": 19937}
{"snippet": "lib.stride_tricks.as_strided(x, strides=None, writeable=True)", "intent": "Create a view into the array with the given `shape` and `strides` . With arguments `x`, `writeable`. numpy", "question_id": 19938}
{"snippet": "dtype.base", "intent": "Returns dtype for the base element of the subarrays, regardless of their dimension or shape. numpy", "question_id": 19939}
{"snippet": "polynomial.chebyshev.Chebyshev.degree()", "intent": "The degree of the series . numpy", "question_id": 19940}
{"snippet": "numpy.shares_memory(a, b)", "intent": "Determine if two arrays share memory . Hence , `max_work` should generally be set to `a` finite number , as it is possible to construct examples that take extremely long to run : With arguments `b`. numpy", "question_id": 19941}
{"snippet": "numpy.shares_memory(a, b, max_work=None)", "intent": "Determine if two arrays share memory . Hence , `max_work` should generally be set to `a` finite number , as it is possible to construct examples that take extremely long to run : With arguments `b`. numpy", "question_id": 19942}
{"snippet": "ma.reshape(a, new_shape)", "intent": "Returns an array containing the same data with `a` new shape . With arguments `new_shape`. numpy", "question_id": 19943}
{"snippet": "ma.reshape(a, new_shape, order='C')", "intent": "Returns an array containing the same data with `a` new shape . With arguments `new_shape`, `order`. numpy", "question_id": 19944}
{"snippet": "char.chararray.center(width)", "intent": "Return a copy of self with its elements centered in a string of length `width` . numpy", "question_id": 19945}
{"snippet": "char.chararray.center(width, fillchar=' ')", "intent": "Return a copy of self with its elements centered in a string of length `width` . With arguments `fillchar`. numpy", "question_id": 19946}
{"snippet": "polynomial.hermite_e.HermiteE.fromroots(roots)", "intent": "Return series instance that has the specified `roots` . numpy", "question_id": 19947}
{"snippet": "polynomial.hermite_e.HermiteE.fromroots(roots, domain=)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`. numpy", "question_id": 19948}
{"snippet": "polynomial.hermite_e.HermiteE.fromroots(roots, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `window`. numpy", "question_id": 19949}
{"snippet": "polynomial.hermite_e.HermiteE.fromroots(roots, domain=, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`, `window`. numpy", "question_id": 19950}
{"snippet": "polynomial.hermite_e.HermiteE.fromroots()", "intent": "Return series instance that has the specified `roots` . numpy", "question_id": 19951}
{"snippet": "polynomial.hermite_e.HermiteE.fromroots(domain=)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`. numpy", "question_id": 19952}
{"snippet": "polynomial.hermite_e.HermiteE.fromroots(window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `window`. numpy", "question_id": 19953}
{"snippet": "polynomial.hermite_e.HermiteE.fromroots(domain=, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`, `window`. numpy", "question_id": 19954}
{"snippet": "memmap.prod()", "intent": "Return the product of the array elements over the given `axis` numpy", "question_id": 19955}
{"snippet": "memmap.prod(axis=None)", "intent": "Return the product of the array elements over the given `axis` numpy", "question_id": 19956}
{"snippet": "memmap.prod(dtype=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `dtype`. numpy", "question_id": 19957}
{"snippet": "memmap.prod(out=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `out`. numpy", "question_id": 19958}
{"snippet": "memmap.prod(keepdims=False)", "intent": "Return the product of the array elements over the given `axis` With arguments `keepdims`. numpy", "question_id": 19959}
{"snippet": "memmap.prod(initial=1)", "intent": "Return the product of the array elements over the given `axis` With arguments `initial`. numpy", "question_id": 19960}
{"snippet": "memmap.prod(where=True)", "intent": "Return the product of the array elements over the given `axis` With arguments `where`. numpy", "question_id": 19961}
{"snippet": "memmap.prod(axis=None, dtype=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `dtype`. numpy", "question_id": 19962}
{"snippet": "memmap.prod(axis=None, out=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `out`. numpy", "question_id": 19963}
{"snippet": "memmap.prod(axis=None, keepdims=False)", "intent": "Return the product of the array elements over the given `axis` With arguments `keepdims`. numpy", "question_id": 19964}
{"snippet": "polynomial.chebyshev.chebint(c)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 19965}
{"snippet": "polynomial.chebyshev.chebint(c, m=1)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 19966}
{"snippet": "polynomial.chebyshev.chebint(c, k=)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 19967}
{"snippet": "polynomial.chebyshev.chebint(c, lbnd=0)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 19968}
{"snippet": "polynomial.chebyshev.chebint(c, scl=1)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 19969}
{"snippet": "polynomial.chebyshev.chebint(c, axis=0)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 19970}
{"snippet": "polynomial.chebyshev.chebint(c, m=1, k=)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 19971}
{"snippet": "polynomial.chebyshev.chebint(c, m=1, lbnd=0)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 19972}
{"snippet": "polynomial.chebyshev.chebint(c, m=1, scl=1)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 19973}
{"snippet": "polynomial.chebyshev.chebint(c, m=1, axis=0)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 19974}
{"snippet": "polynomial.chebyshev.chebint()", "intent": "Integrate a Chebyshev series . numpy", "question_id": 19975}
{"snippet": "polynomial.chebyshev.chebint(m=1)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 19976}
{"snippet": "polynomial.chebyshev.chebint(k=)", "intent": "Integrate a Chebyshev series . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 19977}
{"snippet": "polynomial.chebyshev.chebint(lbnd=0)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 19978}
{"snippet": "polynomial.chebyshev.chebint(scl=1)", "intent": "Integrate a Chebyshev series . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 19979}
{"snippet": "polynomial.chebyshev.chebint(axis=0)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 19980}
{"snippet": "polynomial.chebyshev.chebint(m=1, k=)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 19981}
{"snippet": "polynomial.chebyshev.chebint(m=1, lbnd=0)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 19982}
{"snippet": "polynomial.chebyshev.chebint(m=1, scl=1)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 19983}
{"snippet": "polynomial.chebyshev.chebint(m=1, axis=0)", "intent": "Integrate a Chebyshev series . Returns the Chebyshev series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 19984}
{"snippet": "ma.MaskType.real", "intent": "The real part of the scalar. numpy", "question_id": 19985}
{"snippet": "numpy.blackman(M)", "intent": "Return the Blackman window . With arguments `M`. numpy", "question_id": 19986}
{"snippet": "testing.assert_array_equal(x, y)", "intent": "Raises an AssertionError if two array_like objects are not equal . When one of `x` and `y` is a scalar and the other is array_like , the function checks that each element of the array_like object is equal to the scalar . numpy", "question_id": 19987}
{"snippet": "testing.assert_array_equal(x, y, err_msg='')", "intent": "Raises an AssertionError if two array_like objects are not equal . When one of `x` and `y` is a scalar and the other is array_like , the function checks that each element of the array_like object is equal to the scalar . With arguments `err_msg`. numpy", "question_id": 19988}
{"snippet": "testing.assert_array_equal(x, y, verbose=True)", "intent": "Raises an AssertionError if two array_like objects are not equal . When one of `x` and `y` is a scalar and the other is array_like , the function checks that each element of the array_like object is equal to the scalar . With arguments `verbose`. numpy", "question_id": 19989}
{"snippet": "testing.assert_array_equal(x, y, err_msg='', verbose=True)", "intent": "Raises an AssertionError if two array_like objects are not equal . When one of `x` and `y` is a scalar and the other is array_like , the function checks that each element of the array_like object is equal to the scalar . With arguments `err_msg`, `verbose`. numpy", "question_id": 19990}
{"snippet": "char.chararray.find(sub)", "intent": "For each element , return the lowest index in the string where substring `sub` is found . numpy", "question_id": 19991}
{"snippet": "char.chararray.find(sub, start=0)", "intent": "For each element , return the lowest index in the string where substring `sub` is found . With arguments `start`. numpy", "question_id": 19992}
{"snippet": "char.chararray.find(sub, end=None)", "intent": "For each element , return the lowest index in the string where substring `sub` is found . With arguments `end`. numpy", "question_id": 19993}
{"snippet": "char.chararray.find(sub, start=0, end=None)", "intent": "For each element , return the lowest index in the string where substring `sub` is found . With arguments `start`, `end`. numpy", "question_id": 19994}
{"snippet": "numpy.min_scalar_type(a)", "intent": "For scalar `a` , returns the data type with the smallest size and smallest scalar kind which can hold its value . numpy", "question_id": 19995}
{"snippet": "numpy.mod(x1, x2, /, signature, extobj)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 19996}
{"snippet": "numpy.mod(x1, x2, /, signature, extobj, out=None)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 19997}
{"snippet": "numpy.mod(x1, x2, /, signature, extobj, where=True)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 19998}
{"snippet": "numpy.mod(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 19999}
{"snippet": "numpy.mod(x1, x2, /, signature, extobj, order='K')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 20000}
{"snippet": "numpy.mod(x1, x2, /, signature, extobj, dtype=None)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 20001}
{"snippet": "numpy.mod(x1, x2, /, signature, extobj, subok=True)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 20002}
{"snippet": "numpy.mod(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 20003}
{"snippet": "numpy.mod(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 20004}
{"snippet": "numpy.mod(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 20005}
{"snippet": "numpy.mod(x1, x2, /, signature)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`. numpy", "question_id": 20006}
{"snippet": "numpy.mod(x1, x2, /, signature, out=None)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `out`. numpy", "question_id": 20007}
{"snippet": "numpy.mod(x1, x2, /, signature, where=True)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `where`. numpy", "question_id": 20008}
{"snippet": "numpy.mod(x1, x2, /, signature, casting='same_kind')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `casting`. numpy", "question_id": 20009}
{"snippet": "numpy.mod(x1, x2, /, signature, order='K')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `order`. numpy", "question_id": 20010}
{"snippet": "numpy.mod(x1, x2, /, signature, dtype=None)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 20011}
{"snippet": "numpy.mod(x1, x2, /, signature, subok=True)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `subok`. numpy", "question_id": 20012}
{"snippet": "numpy.mod(x1, x2, /, signature, out=None, where=True)", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 20013}
{"snippet": "numpy.mod(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 20014}
{"snippet": "numpy.mod(x1, x2, /, signature, out=None, order='K')", "intent": "Return element-wise remainder of division . It is equivalent to the Python modulus operator `` `x1` % `x2` `` and has the same sign as the divisor x2 . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 20015}
{"snippet": "record.nonzero()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 20016}
{"snippet": "ma.choose(indices, choices)", "intent": "Use an index array to construct a new array from a list of `choices` . With arguments `indices`. numpy", "question_id": 20017}
{"snippet": "ma.choose(indices, choices, out=None)", "intent": "Use an index array to construct a new array from a list of `choices` . With arguments `indices`, `out`. numpy", "question_id": 20018}
{"snippet": "ma.choose(indices, choices, mode='raise')", "intent": "Use an index array to construct a new array from a list of `choices` . With arguments `indices`, `mode`. numpy", "question_id": 20019}
{"snippet": "ma.choose(indices, choices, out=None, mode='raise')", "intent": "Use an index array to construct a new array from a list of `choices` . With arguments `indices`, `out`, `mode`. numpy", "question_id": 20020}
{"snippet": "chararray.istitle()", "intent": "Returns true for each element if the element is a titlecased string and there is at least one character , false otherwise . numpy", "question_id": 20021}
{"snippet": "char.chararray.splitlines()", "intent": "For each element in self , return a list of the lines in the element , breaking at line boundaries . numpy", "question_id": 20022}
{"snippet": "char.chararray.splitlines(keepends=None)", "intent": "For each element in self , return a list of the lines in the element , breaking at line boundaries . With arguments `keepends`. numpy", "question_id": 20023}
{"snippet": "numpy.testing.Tester", "intent": "alias of numpy.testing._private.nosetester.NoseTester numpy", "question_id": 20024}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.dist_fatal(*args)", "intent": "Raise a distutils error With arguments `*args`. numpy", "question_id": 20025}
{"snippet": "ma.masked_array.cumsum()", "intent": "Return the cumulative sum of the array elements over the given `axis` . numpy", "question_id": 20026}
{"snippet": "ma.masked_array.cumsum(axis=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . numpy", "question_id": 20027}
{"snippet": "ma.masked_array.cumsum(dtype=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 20028}
{"snippet": "ma.masked_array.cumsum(out=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . The mask is lost if `out` is not a valid ma.MaskedArray ! numpy", "question_id": 20029}
{"snippet": "ma.masked_array.cumsum(axis=None, dtype=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 20030}
{"snippet": "ma.masked_array.cumsum(axis=None, out=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . The mask is lost if `out` is not a valid ma.MaskedArray ! numpy", "question_id": 20031}
{"snippet": "ma.masked_array.cumsum(dtype=None, out=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . The mask is lost if `out` is not a valid ma.MaskedArray ! With arguments `dtype`. numpy", "question_id": 20032}
{"snippet": "ma.masked_array.cumsum(axis=None, dtype=None, out=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . The mask is lost if `out` is not a valid ma.MaskedArray ! With arguments `dtype`. numpy", "question_id": 20033}
{"snippet": "polynomial.chebyshev.Chebyshev.has_samecoef(other)", "intent": "Check if coefficients match . With arguments `other`. numpy", "question_id": 20034}
{"snippet": "ndarray.__ne__(value, /)", "intent": "Return self ! =value . With arguments `value`, `/`. numpy", "question_id": 20035}
{"snippet": "random.Generator.noncentral_chisquare(df, nonc)", "intent": "Draw samples from a noncentral chi-square distribution . With arguments `df`, `nonc`. numpy", "question_id": 20036}
{"snippet": "random.Generator.noncentral_chisquare(df, nonc, size=None)", "intent": "Draw samples from a noncentral chi-square distribution . With arguments `df`, `nonc`, `size`. numpy", "question_id": 20037}
{"snippet": "polynomial.chebyshev.chebpow(c, pow)", "intent": "Raise a Chebyshev series to a power . Returns the Chebyshev series `c` raised to the power `pow` . numpy", "question_id": 20038}
{"snippet": "polynomial.chebyshev.chebpow(c, pow, maxpower=16)", "intent": "Raise a Chebyshev series to a power . Returns the Chebyshev series `c` raised to the power `pow` . With arguments `maxpower`. numpy", "question_id": 20039}
{"snippet": "ma.masked_object(x, value)", "intent": "Mask the array `x` where the data are exactly equal to `value` . numpy", "question_id": 20040}
{"snippet": "ma.masked_object(x, value, copy=True)", "intent": "Mask the array `x` where the data are exactly equal to `value` . With arguments `copy`. numpy", "question_id": 20041}
{"snippet": "ma.masked_object(x, value, shrink=True)", "intent": "Mask the array `x` where the data are exactly equal to `value` . With arguments `shrink`. numpy", "question_id": 20042}
{"snippet": "ma.masked_object(x, value, copy=True, shrink=True)", "intent": "Mask the array `x` where the data are exactly equal to `value` . With arguments `copy`, `shrink`. numpy", "question_id": 20043}
{"snippet": "polynomial.legendre.leg2poly(c)", "intent": "Convert a Legendre series to a polynomial . With arguments `c`. numpy", "question_id": 20044}
{"snippet": "ma.mask_cols(a)", "intent": "Mask columns of `a` 2D array that contain masked values . numpy", "question_id": 20045}
{"snippet": "ma.mask_cols(a, axis=<no value>)", "intent": "Mask columns of `a` 2D array that contain masked values . This function is a shortcut to mask_rowcols with `axis` equal to 1 . numpy", "question_id": 20046}
{"snippet": "chararray.shape", "intent": "Tuple of array dimensions. numpy", "question_id": 20047}
{"snippet": "ma.around", "intent": "Round an array to the given number of decimals. numpy", "question_id": 20048}
{"snippet": "memmap.tofile(fid)", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . numpy", "question_id": 20049}
{"snippet": "memmap.tofile(fid, sep='')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `sep`. numpy", "question_id": 20050}
{"snippet": "memmap.tofile(fid, format='%s')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `format`. numpy", "question_id": 20051}
{"snippet": "memmap.tofile(fid, sep='', format='%s')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `sep`, `format`. numpy", "question_id": 20052}
{"snippet": "ndarray.clip(**kwargs)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 20053}
{"snippet": "ndarray.clip(**kwargs, min=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 20054}
{"snippet": "ndarray.clip(**kwargs, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 20055}
{"snippet": "ndarray.clip(**kwargs, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 20056}
{"snippet": "ndarray.clip(**kwargs, min=None, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 20057}
{"snippet": "ndarray.clip(**kwargs, min=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 20058}
{"snippet": "ndarray.clip(**kwargs, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 20059}
{"snippet": "ndarray.clip(**kwargs, min=None, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 20060}
{"snippet": "polynomial.hermite_e.HermiteE.copy()", "intent": "Return a copy . numpy", "question_id": 20061}
{"snippet": "polynomial.legendre.legadd(c1, c2)", "intent": "Add one Legendre series to another . Returns the sum of two Legendre series `c1` + `c2` . numpy", "question_id": 20062}
{"snippet": "numpy.busday_offset(dates, offsets)", "intent": "First adjusts the date to fall on a valid day according to the `roll` rule , then applies `offsets` to the given `dates` counted in valid days . numpy", "question_id": 20063}
{"snippet": "numpy.busday_offset(dates, offsets, roll='raise')", "intent": "First adjusts the date to fall on a valid day according to the `roll` rule , then applies `offsets` to the given `dates` counted in valid days . numpy", "question_id": 20064}
{"snippet": "numpy.busday_offset(dates, offsets, weekmask='1111100')", "intent": "First adjusts the date to fall on a valid day according to the `roll` rule , then applies `offsets` to the given `dates` counted in valid days . With arguments `weekmask`. numpy", "question_id": 20065}
{"snippet": "numpy.busday_offset(dates, offsets, holidays=None)", "intent": "First adjusts the date to fall on a valid day according to the `roll` rule , then applies `offsets` to the given `dates` counted in valid days . With arguments `holidays`. numpy", "question_id": 20066}
{"snippet": "numpy.busday_offset(dates, offsets, busdaycal=None)", "intent": "First adjusts the date to fall on a valid day according to the `roll` rule , then applies `offsets` to the given `dates` counted in valid days . With arguments `busdaycal`. numpy", "question_id": 20067}
{"snippet": "numpy.busday_offset(dates, offsets, out=None)", "intent": "First adjusts the date to fall on a valid day according to the `roll` rule , then applies `offsets` to the given `dates` counted in valid days . With arguments `out`. numpy", "question_id": 20068}
{"snippet": "numpy.busday_offset(dates, offsets, roll='raise', weekmask='1111100')", "intent": "First adjusts the date to fall on a valid day according to the `roll` rule , then applies `offsets` to the given `dates` counted in valid days . With arguments `weekmask`. numpy", "question_id": 20069}
{"snippet": "numpy.busday_offset(dates, offsets, roll='raise', holidays=None)", "intent": "First adjusts the date to fall on a valid day according to the `roll` rule , then applies `offsets` to the given `dates` counted in valid days . With arguments `holidays`. numpy", "question_id": 20070}
{"snippet": "numpy.busday_offset(dates, offsets, roll='raise', busdaycal=None)", "intent": "First adjusts the date to fall on a valid day according to the `roll` rule , then applies `offsets` to the given `dates` counted in valid days . With arguments `busdaycal`. numpy", "question_id": 20071}
{"snippet": "numpy.busday_offset(dates, offsets, roll='raise', out=None)", "intent": "First adjusts the date to fall on a valid day according to the `roll` rule , then applies `offsets` to the given `dates` counted in valid days . With arguments `out`. numpy", "question_id": 20072}
{"snippet": "ndarray.__lshift__(value, /)", "intent": "Return self < < `value` . With arguments `/`. numpy", "question_id": 20073}
{"snippet": "core.defchararray.asarray(obj)", "intent": "Convert the input to a chararray , copying the data only if necessary . With arguments `obj`. numpy", "question_id": 20074}
{"snippet": "core.defchararray.asarray(obj, itemsize=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . With arguments `obj`, `itemsize`. numpy", "question_id": 20075}
{"snippet": "core.defchararray.asarray(obj, unicode=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`. numpy", "question_id": 20076}
{"snippet": "core.defchararray.asarray(obj, order=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . With arguments `obj`, `order`. numpy", "question_id": 20077}
{"snippet": "core.defchararray.asarray(obj, itemsize=None, unicode=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`, `itemsize`. numpy", "question_id": 20078}
{"snippet": "core.defchararray.asarray(obj, itemsize=None, order=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . With arguments `obj`, `itemsize`, `order`. numpy", "question_id": 20079}
{"snippet": "core.defchararray.asarray(obj, unicode=None, order=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`, `order`. numpy", "question_id": 20080}
{"snippet": "core.defchararray.asarray(obj, itemsize=None, unicode=None, order=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`, `itemsize`, `order`. numpy", "question_id": 20081}
{"snippet": "memmap.argmin()", "intent": "Return indices of the minimum values along the given `axis` . numpy", "question_id": 20082}
{"snippet": "memmap.argmin(axis=None)", "intent": "Return indices of the minimum values along the given `axis` . numpy", "question_id": 20083}
{"snippet": "memmap.argmin(out=None)", "intent": "Return indices of the minimum values along the given `axis` . With arguments `out`. numpy", "question_id": 20084}
{"snippet": "memmap.argmin(axis=None, out=None)", "intent": "Return indices of the minimum values along the given `axis` . With arguments `out`. numpy", "question_id": 20085}
{"snippet": "ma.MaskedArray.__truediv__(other)", "intent": "Divide `other` into self , and return a new masked array . numpy", "question_id": 20086}
{"snippet": "matrix.argmin()", "intent": "Indexes of the minimum values along an `axis` . numpy", "question_id": 20087}
{"snippet": "matrix.argmin(axis=None)", "intent": "Indexes of the minimum values along an `axis` . numpy", "question_id": 20088}
{"snippet": "matrix.argmin(out=None)", "intent": "Indexes of the minimum values along an `axis` . With arguments `out`. numpy", "question_id": 20089}
{"snippet": "matrix.argmin(axis=None, out=None)", "intent": "Indexes of the minimum values along an `axis` . With arguments `out`. numpy", "question_id": 20090}
{"snippet": "polynomial.legendre.Legendre.has_sametype(other)", "intent": "Check if types match . With arguments `other`. numpy", "question_id": 20091}
{"snippet": "random.RandomState.shuffle(x)", "intent": "Modify a sequence in-place by shuffling its contents . With arguments `x`. numpy", "question_id": 20092}
{"snippet": "testing.suppress_warnings.filter()", "intent": "Add a new suppressing filter or apply it if the state is entered . numpy", "question_id": 20093}
{"snippet": "testing.suppress_warnings.filter(category=<class 'Warning'>)", "intent": "Add a new suppressing filter or apply it if the state is entered . With arguments `category`. numpy", "question_id": 20094}
{"snippet": "testing.suppress_warnings.filter(message='')", "intent": "Add a new suppressing filter or apply it if the state is entered . With arguments `message`. numpy", "question_id": 20095}
{"snippet": "testing.suppress_warnings.filter(module=None)", "intent": "Add a new suppressing filter or apply it if the state is entered . With arguments `module`. numpy", "question_id": 20096}
{"snippet": "testing.suppress_warnings.filter(category=<class 'Warning'>, message='')", "intent": "Add a new suppressing filter or apply it if the state is entered . With arguments `category`, `message`. numpy", "question_id": 20097}
{"snippet": "testing.suppress_warnings.filter(category=<class 'Warning'>, module=None)", "intent": "Add a new suppressing filter or apply it if the state is entered . With arguments `category`, `module`. numpy", "question_id": 20098}
{"snippet": "testing.suppress_warnings.filter(message='', module=None)", "intent": "Add a new suppressing filter or apply it if the state is entered . With arguments `message`, `module`. numpy", "question_id": 20099}
{"snippet": "testing.suppress_warnings.filter(category=<class 'Warning'>, message='', module=None)", "intent": "Add a new suppressing filter or apply it if the state is entered . With arguments `category`, `message`, `module`. numpy", "question_id": 20100}
{"snippet": "char.index(a, sub)", "intent": "Like find , but raises ValueError when the substring is not found . With arguments `a`, `sub`. numpy", "question_id": 20101}
{"snippet": "char.index(a, sub, start=0)", "intent": "Like find , but raises ValueError when the substring is not found . With arguments `a`, `sub`, `start`. numpy", "question_id": 20102}
{"snippet": "char.index(a, sub, end=None)", "intent": "Like find , but raises ValueError when the substring is not found . With arguments `a`, `sub`, `end`. numpy", "question_id": 20103}
{"snippet": "char.index(a, sub, start=0, end=None)", "intent": "Like find , but raises ValueError when the substring is not found . With arguments `a`, `sub`, `start`, `end`. numpy", "question_id": 20104}
{"snippet": "matrix.choose(choices)", "intent": "Use an index array to construct a new array from a set of `choices` . numpy", "question_id": 20105}
{"snippet": "matrix.choose(choices, out=None)", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`. numpy", "question_id": 20106}
{"snippet": "matrix.choose(choices, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `mode`. numpy", "question_id": 20107}
{"snippet": "matrix.choose(choices, out=None, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`, `mode`. numpy", "question_id": 20108}
{"snippet": "numpy.diagonal(a)", "intent": "Return specified diagonals . If `a` is 2-D , returns the diagonal of a with the given `offset` , i.e. , the collection of elements of the form a [ i , i+offset ] . numpy", "question_id": 20109}
{"snippet": "numpy.diagonal(a, offset=0)", "intent": "Return specified diagonals . If `a` is 2-D , returns the diagonal of a with the given `offset` , i.e. , the collection of elements of the form a [ i , i+offset ] . numpy", "question_id": 20110}
{"snippet": "numpy.diagonal(a, axis1=0)", "intent": "Return specified diagonals . If `a` is 2-D , returns the diagonal of a with the given `offset` , i.e. , the collection of elements of the form a [ i , i+offset ] . If a has more than two dimensions , then the axes specified by `axis1` and `axis2` are used to determine the 2-D sub-array whose diagonal is returned . numpy", "question_id": 20111}
{"snippet": "numpy.diagonal(a, axis2=1)", "intent": "Return specified diagonals . If `a` is 2-D , returns the diagonal of a with the given `offset` , i.e. , the collection of elements of the form a [ i , i+offset ] . If a has more than two dimensions , then the axes specified by `axis1` and `axis2` are used to determine the 2-D sub-array whose diagonal is returned . numpy", "question_id": 20112}
{"snippet": "numpy.diagonal(a, offset=0, axis1=0)", "intent": "Return specified diagonals . If `a` is 2-D , returns the diagonal of a with the given `offset` , i.e. , the collection of elements of the form a [ i , i+offset ] . If a has more than two dimensions , then the axes specified by `axis1` and `axis2` are used to determine the 2-D sub-array whose diagonal is returned . numpy", "question_id": 20113}
{"snippet": "numpy.diagonal(a, offset=0, axis2=1)", "intent": "Return specified diagonals . If `a` is 2-D , returns the diagonal of a with the given `offset` , i.e. , the collection of elements of the form a [ i , i+offset ] . If a has more than two dimensions , then the axes specified by `axis1` and `axis2` are used to determine the 2-D sub-array whose diagonal is returned . numpy", "question_id": 20114}
{"snippet": "numpy.diagonal(a, axis1=0, axis2=1)", "intent": "Return specified diagonals . If `a` is 2-D , returns the diagonal of a with the given `offset` , i.e. , the collection of elements of the form a [ i , i+offset ] . If a has more than two dimensions , then the axes specified by `axis1` and `axis2` are used to determine the 2-D sub-array whose diagonal is returned . numpy", "question_id": 20115}
{"snippet": "numpy.diagonal(a, offset=0, axis1=0, axis2=1)", "intent": "Return specified diagonals . If `a` is 2-D , returns the diagonal of a with the given `offset` , i.e. , the collection of elements of the form a [ i , i+offset ] . If a has more than two dimensions , then the axes specified by `axis1` and `axis2` are used to determine the 2-D sub-array whose diagonal is returned . numpy", "question_id": 20116}
{"snippet": "polynomial.chebyshev.chebmulx(c)", "intent": "Multiply a Chebyshev series by x . Multiply the polynomial `c` by x , where x is the independent variable . numpy", "question_id": 20117}
{"snippet": "numpy.roots(p)", "intent": "Return the roots of a polynomial with coefficients given in `p` . numpy", "question_id": 20118}
{"snippet": "ma.masked_array.view()", "intent": "Return a view of the MaskedArray data . numpy", "question_id": 20119}
{"snippet": "ma.masked_array.view(dtype=None)", "intent": "Return a view of the MaskedArray data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) numpy", "question_id": 20120}
{"snippet": "ma.masked_array.view(type=None)", "intent": "Return a view of the MaskedArray data . With arguments `type`. numpy", "question_id": 20121}
{"snippet": "ma.masked_array.view(fill_value=None)", "intent": "Return a view of the MaskedArray data . If `fill_value` is not specified , but dtype is specified ( and is not an ndarray sub-class ) , the fill_value of the MaskedArray will be reset . numpy", "question_id": 20122}
{"snippet": "ma.masked_array.view(dtype=None, type=None)", "intent": "Return a view of the MaskedArray data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) With arguments `type`. numpy", "question_id": 20123}
{"snippet": "ma.masked_array.view(dtype=None, fill_value=None)", "intent": "Return a view of the MaskedArray data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) If `fill_value` is not specified , but dtype is specified ( and is not an ndarray sub-class ) , the fill_value of the MaskedArray will be reset . numpy", "question_id": 20124}
{"snippet": "ma.masked_array.view(type=None, fill_value=None)", "intent": "Return a view of the MaskedArray data . If `fill_value` is not specified , but dtype is specified ( and is not an ndarray sub-class ) , the fill_value of the MaskedArray will be reset . With arguments `type`. numpy", "question_id": 20125}
{"snippet": "ma.masked_array.view(dtype=None, type=None, fill_value=None)", "intent": "Return a view of the MaskedArray data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) If `fill_value` is not specified , but dtype is specified ( and is not an ndarray sub-class ) , the fill_value of the MaskedArray will be reset . With arguments `type`. numpy", "question_id": 20126}
{"snippet": "ndarray.var()", "intent": "Returns the variance of the array elements , along given `axis` . numpy", "question_id": 20127}
{"snippet": "ndarray.var(axis=None)", "intent": "Returns the variance of the array elements , along given `axis` . numpy", "question_id": 20128}
{"snippet": "ndarray.var(dtype=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `dtype`. numpy", "question_id": 20129}
{"snippet": "ndarray.var(out=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `out`. numpy", "question_id": 20130}
{"snippet": "ndarray.var(ddof=0)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `ddof`. numpy", "question_id": 20131}
{"snippet": "ndarray.var(keepdims=False)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `keepdims`. numpy", "question_id": 20132}
{"snippet": "ndarray.var(where=True)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `where`. numpy", "question_id": 20133}
{"snippet": "ndarray.var(axis=None, dtype=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `dtype`. numpy", "question_id": 20134}
{"snippet": "ndarray.var(axis=None, out=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `out`. numpy", "question_id": 20135}
{"snippet": "ndarray.var(axis=None, ddof=0)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `ddof`. numpy", "question_id": 20136}
{"snippet": "random.random_sample()", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) . numpy", "question_id": 20137}
{"snippet": "random.random_sample(size=None)", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) . With arguments `size`. numpy", "question_id": 20138}
{"snippet": "record.resize()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 20139}
{"snippet": "memmap.item(*args)", "intent": "Copy an element of an array to a standard Python scalar and return it . With arguments `*args`. numpy", "question_id": 20140}
{"snippet": "chararray.lower()", "intent": "Return an array with the elements of self converted to lowercase . numpy", "question_id": 20141}
{"snippet": "numpy.real_if_close(a)", "intent": "If input is complex with all imaginary parts close to zero , return real parts . \u201c Close to zero \u201d is defined as `tol` * ( machine epsilon of the type for `a` ) . numpy", "question_id": 20142}
{"snippet": "numpy.real_if_close(a, tol=100)", "intent": "If input is complex with all imaginary parts close to zero , return real parts . \u201c Close to zero \u201d is defined as `tol` * ( machine epsilon of the type for `a` ) . numpy", "question_id": 20143}
{"snippet": "chararray.swapcase()", "intent": "For each element in self , return a copy of the string with uppercase characters converted to lowercase and vice versa . numpy", "question_id": 20144}
{"snippet": "ma.MaskedArray.filled()", "intent": "Return a copy of self , with masked values filled with a given value . numpy", "question_id": 20145}
{"snippet": "ma.MaskedArray.filled(fill_value=None)", "intent": "Return a copy of self , with masked values filled with a given value . With arguments `fill_value`. numpy", "question_id": 20146}
{"snippet": "numpy.iinfo(type)", "intent": "Machine limits for integer types . With arguments `type`. numpy", "question_id": 20147}
{"snippet": "numpy.loadtxt(fname)", "intent": "Load data from a text file . With arguments `fname`. numpy", "question_id": 20148}
{"snippet": "numpy.loadtxt(fname, dtype=<class 'float'>)", "intent": "Load data from a text file . With arguments `fname`, `dtype`. numpy", "question_id": 20149}
{"snippet": "numpy.loadtxt(fname, comments='#')", "intent": "Load data from a text file . With arguments `fname`, `comments`. numpy", "question_id": 20150}
{"snippet": "numpy.loadtxt(fname, delimiter=None)", "intent": "Load data from a text file . With arguments `fname`, `delimiter`. numpy", "question_id": 20151}
{"snippet": "numpy.loadtxt(fname, converters=None)", "intent": "Load data from a text file . This example shows how `converters` can be used to convert a field with a trailing minus sign into a negative number . With arguments `fname`. numpy", "question_id": 20152}
{"snippet": "numpy.loadtxt(fname, skiprows=0)", "intent": "Load data from a text file . With arguments `fname`, `skiprows`. numpy", "question_id": 20153}
{"snippet": "numpy.loadtxt(fname, usecols=None)", "intent": "Load data from a text file . With arguments `fname`, `usecols`. numpy", "question_id": 20154}
{"snippet": "numpy.loadtxt(fname, unpack=False)", "intent": "Load data from a text file . With arguments `fname`, `unpack`. numpy", "question_id": 20155}
{"snippet": "numpy.loadtxt(fname, ndmin=0)", "intent": "Load data from a text file . With arguments `fname`, `ndmin`. numpy", "question_id": 20156}
{"snippet": "numpy.loadtxt(fname, encoding='bytes')", "intent": "Load data from a text file . With arguments `fname`, `encoding`. numpy", "question_id": 20157}
{"snippet": "ma.MaskedArray.conjugate()", "intent": "Return the complex conjugate , element-wise . numpy", "question_id": 20158}
{"snippet": "ndarray.__or__(value, /)", "intent": "Return self|value . With arguments `value`, `/`. numpy", "question_id": 20159}
{"snippet": "numpy.array_equal(a1, a2)", "intent": "True if two arrays have the same shape and elements , False otherwise . With arguments `a1`, `a2`. numpy", "question_id": 20160}
{"snippet": "numpy.array_equal(a1, a2, equal_nan=False)", "intent": "True if two arrays have the same shape and elements , False otherwise . When `equal_nan` is True , complex values with nan components are considered equal if either the real or the imaginary components are nan . With arguments `a1`, `a2`. numpy", "question_id": 20161}
{"snippet": "broadcast.ndim", "intent": "Number of dimensions of broadcasted result. numpy", "question_id": 20162}
{"snippet": "polynomial.hermite_e.HermiteE.basis(deg)", "intent": "Series basis polynomial of degree `deg` . numpy", "question_id": 20163}
{"snippet": "polynomial.hermite_e.HermiteE.basis(deg, domain=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `domain`. numpy", "question_id": 20164}
{"snippet": "polynomial.hermite_e.HermiteE.basis(deg, window=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `window`. numpy", "question_id": 20165}
{"snippet": "polynomial.hermite_e.HermiteE.basis(deg, domain=None, window=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `domain`, `window`. numpy", "question_id": 20166}
{"snippet": "chararray.encode()", "intent": "Calls str.encode element-wise . numpy", "question_id": 20167}
{"snippet": "chararray.encode(encoding=None)", "intent": "Calls str.encode element-wise . With arguments `encoding`. numpy", "question_id": 20168}
{"snippet": "chararray.encode(errors=None)", "intent": "Calls str.encode element-wise . With arguments `errors`. numpy", "question_id": 20169}
{"snippet": "chararray.encode(encoding=None, errors=None)", "intent": "Calls str.encode element-wise . With arguments `encoding`, `errors`. numpy", "question_id": 20170}
{"snippet": "ndarray.tostring()", "intent": "A compatibility alias for tobytes , with exactly the same behavior . numpy", "question_id": 20171}
{"snippet": "ndarray.tostring(order='C')", "intent": "A compatibility alias for tobytes , with exactly the same behavior . With arguments `order`. numpy", "question_id": 20172}
{"snippet": "random.geometric(p)", "intent": "Draw samples from the geometric distribution . where `p` is the probability of success of an individual trial . numpy", "question_id": 20173}
{"snippet": "random.geometric(p, size=None)", "intent": "Draw samples from the geometric distribution . where `p` is the probability of success of an individual trial . With arguments `size`. numpy", "question_id": 20174}
{"snippet": "ma.MaskType.dtype", "intent": "Get array data-descriptor. numpy", "question_id": 20175}
{"snippet": "memmap.strides", "intent": "Tuple of bytes to step in each dimension when traversing an array. numpy", "question_id": 20176}
{"snippet": "numpy.issubdtype(arg1, arg2)", "intent": "Returns True if first argument is a typecode lower/equal in type hierarchy . With arguments `arg1`, `arg2`. numpy", "question_id": 20177}
{"snippet": "ufunc.accumulate(array)", "intent": "Accumulate the result of applying the operator to all elements . For a one-dimensional `array` , accumulate produces results equivalent to : numpy", "question_id": 20178}
{"snippet": "ufunc.accumulate(array, axis=0)", "intent": "Accumulate the result of applying the operator to all elements . For a one-dimensional `array` , accumulate produces results equivalent to : For a multi-dimensional array , accumulate is applied along only one `axis` ( axis zero by default ; see Examples below ) so repeated use is necessary if one wants to accumulate over multiple axes . numpy", "question_id": 20179}
{"snippet": "ufunc.accumulate(array, dtype=None)", "intent": "Accumulate the result of applying the operator to all elements . For a one-dimensional `array` , accumulate produces results equivalent to : With arguments `dtype`. numpy", "question_id": 20180}
{"snippet": "ufunc.accumulate(array, out=None)", "intent": "Accumulate the result of applying the operator to all elements . For a one-dimensional `array` , accumulate produces results equivalent to : With arguments `out`. numpy", "question_id": 20181}
{"snippet": "ufunc.accumulate(array, axis=0, dtype=None)", "intent": "Accumulate the result of applying the operator to all elements . For a one-dimensional `array` , accumulate produces results equivalent to : For a multi-dimensional array , accumulate is applied along only one `axis` ( axis zero by default ; see Examples below ) so repeated use is necessary if one wants to accumulate over multiple axes . With arguments `dtype`. numpy", "question_id": 20182}
{"snippet": "ufunc.accumulate(array, axis=0, out=None)", "intent": "Accumulate the result of applying the operator to all elements . For a one-dimensional `array` , accumulate produces results equivalent to : For a multi-dimensional array , accumulate is applied along only one `axis` ( axis zero by default ; see Examples below ) so repeated use is necessary if one wants to accumulate over multiple axes . With arguments `out`. numpy", "question_id": 20183}
{"snippet": "ufunc.accumulate(array, dtype=None, out=None)", "intent": "Accumulate the result of applying the operator to all elements . For a one-dimensional `array` , accumulate produces results equivalent to : With arguments `dtype`, `out`. numpy", "question_id": 20184}
{"snippet": "ufunc.accumulate(array, axis=0, dtype=None, out=None)", "intent": "Accumulate the result of applying the operator to all elements . For a one-dimensional `array` , accumulate produces results equivalent to : For a multi-dimensional array , accumulate is applied along only one `axis` ( axis zero by default ; see Examples below ) so repeated use is necessary if one wants to accumulate over multiple axes . With arguments `dtype`, `out`. numpy", "question_id": 20185}
{"snippet": "generic.strides", "intent": "Tuple of bytes steps in each dimension. numpy", "question_id": 20186}
{"snippet": "ma.MaskType.shape", "intent": "Tuple of array dimensions. numpy", "question_id": 20187}
{"snippet": "numpy.polynomial.chebyshev.Chebyshev(coef)", "intent": "A Chebyshev series class . With arguments `coef`. numpy", "question_id": 20188}
{"snippet": "numpy.polynomial.chebyshev.Chebyshev(coef, domain=None)", "intent": "A Chebyshev series class . With arguments `coef`, `domain`. numpy", "question_id": 20189}
{"snippet": "numpy.polynomial.chebyshev.Chebyshev(coef, window=None)", "intent": "A Chebyshev series class . With arguments `coef`, `window`. numpy", "question_id": 20190}
{"snippet": "numpy.polynomial.chebyshev.Chebyshev(coef, domain=None, window=None)", "intent": "A Chebyshev series class . With arguments `coef`, `domain`, `window`. numpy", "question_id": 20191}
{"snippet": "memmap.var()", "intent": "Returns the variance of the array elements , along given `axis` . numpy", "question_id": 20192}
{"snippet": "memmap.var(axis=None)", "intent": "Returns the variance of the array elements , along given `axis` . numpy", "question_id": 20193}
{"snippet": "memmap.var(dtype=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `dtype`. numpy", "question_id": 20194}
{"snippet": "memmap.var(out=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `out`. numpy", "question_id": 20195}
{"snippet": "memmap.var(ddof=0)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `ddof`. numpy", "question_id": 20196}
{"snippet": "memmap.var(keepdims=False)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `keepdims`. numpy", "question_id": 20197}
{"snippet": "memmap.var(where=True)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `where`. numpy", "question_id": 20198}
{"snippet": "memmap.var(axis=None, dtype=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `dtype`. numpy", "question_id": 20199}
{"snippet": "memmap.var(axis=None, out=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `out`. numpy", "question_id": 20200}
{"snippet": "memmap.var(axis=None, ddof=0)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `ddof`. numpy", "question_id": 20201}
{"snippet": "numpy.inner(a, b)", "intent": "Inner product of two arrays . Ordinary inner product of vectors for 1-D arrays ( without complex conjugation ) , in higher dimensions `a` sum product over the last axes . More generally , if ndim ( a ) = r > 0 and ndim ( `b` ) = s > 0 : numpy", "question_id": 20202}
{"snippet": "random.Generator.weibull(a)", "intent": "Draw samples from `a` Weibull distribution . numpy", "question_id": 20203}
{"snippet": "random.Generator.weibull(a, size=None)", "intent": "Draw samples from `a` Weibull distribution . With arguments `size`. numpy", "question_id": 20204}
{"snippet": "polynomial.hermite_e.HermiteE.__call__(arg)", "intent": "Call self as a function . With arguments `arg`. numpy", "question_id": 20205}
{"snippet": "fft.irfft2(a, - 1))", "intent": "Computes the inverse of rfft2 . With arguments `a`, `- 1)`. numpy", "question_id": 20206}
{"snippet": "fft.irfft2(a, - 1), s=None)", "intent": "Computes the inverse of rfft2 . With arguments `a`, `- 1)`, `s`. numpy", "question_id": 20207}
{"snippet": "fft.irfft2(a, - 1), axes=(- 2)", "intent": "Computes the inverse of rfft2 . With arguments `a`, `- 1)`, `axes`. numpy", "question_id": 20208}
{"snippet": "fft.irfft2(a, - 1), norm=None)", "intent": "Computes the inverse of rfft2 . With arguments `a`, `- 1)`, `norm`. numpy", "question_id": 20209}
{"snippet": "fft.irfft2(a, - 1), s=None, axes=(- 2)", "intent": "Computes the inverse of rfft2 . With arguments `a`, `- 1)`, `s`, `axes`. numpy", "question_id": 20210}
{"snippet": "fft.irfft2(a, - 1), s=None, norm=None)", "intent": "Computes the inverse of rfft2 . With arguments `a`, `- 1)`, `s`, `norm`. numpy", "question_id": 20211}
{"snippet": "fft.irfft2(a, - 1), axes=(- 2, norm=None)", "intent": "Computes the inverse of rfft2 . With arguments `a`, `- 1)`, `axes`, `norm`. numpy", "question_id": 20212}
{"snippet": "fft.irfft2(a, - 1), s=None, axes=(- 2, norm=None)", "intent": "Computes the inverse of rfft2 . With arguments `a`, `- 1)`, `s`, `axes`, `norm`. numpy", "question_id": 20213}
{"snippet": "ma.getmaskarray(arr)", "intent": "Return the mask of a masked array , or full boolean array of False . Return the mask of `arr` as an ndarray if arr is a MaskedArray and the mask is not nomask , else return a full boolean array of False of the same shape as arr . numpy", "question_id": 20214}
{"snippet": "ma.masked_equal(x, value)", "intent": "Mask an array where equal to a given `value` . This function is a shortcut to masked_where , with condition = ( `x` == value ) . numpy", "question_id": 20215}
{"snippet": "ma.masked_equal(x, value, copy=True)", "intent": "Mask an array where equal to a given `value` . This function is a shortcut to masked_where , with condition = ( `x` == value ) . With arguments `copy`. numpy", "question_id": 20216}
{"snippet": "broadcast.iters", "intent": "tuple of iterators along self\u2019s \u201ccomponents.\u201d numpy", "question_id": 20217}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.cpu_baseline_names()", "intent": "return a list of final CPU baseline feature names numpy", "question_id": 20218}
{"snippet": "random.Generator.standard_t(df)", "intent": "Draw samples from a standard Student \u2019 s t distribution with `df` degrees of freedom . numpy", "question_id": 20219}
{"snippet": "random.Generator.standard_t(df, size=None)", "intent": "Draw samples from a standard Student \u2019 s t distribution with `df` degrees of freedom . With arguments `size`. numpy", "question_id": 20220}
{"snippet": "ma.MaskedArray.ids()", "intent": "Return the addresses of the data and mask areas . numpy", "question_id": 20221}
{"snippet": "ma.MaskedArray.__ipow__(other)", "intent": "Raise self to the power `other` , in place . numpy", "question_id": 20222}
{"snippet": "polynomial.chebyshev.chebinterpolate(func, deg)", "intent": "Interpolate a function at the Chebyshev points of the first kind . Returns the Chebyshev series that interpolates `func` at the Chebyshev points of the first kind in the interval [ -1 , 1 ] . The interpolating series tends to a minmax approximation to func with increasing `deg` if the function is continuous in the interval . numpy", "question_id": 20223}
{"snippet": "polynomial.chebyshev.chebinterpolate(func, deg, args=())", "intent": "Interpolate a function at the Chebyshev points of the first kind . Returns the Chebyshev series that interpolates `func` at the Chebyshev points of the first kind in the interval [ -1 , 1 ] . The interpolating series tends to a minmax approximation to func with increasing `deg` if the function is continuous in the interval . With arguments `args`. numpy", "question_id": 20224}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names()", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . numpy", "question_id": 20225}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(names=None)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . numpy", "question_id": 20226}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(force_flags=None)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . With arguments `force_flags`. numpy", "question_id": 20227}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(macros=)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . With arguments `macros`. numpy", "question_id": 20228}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(names=None, force_flags=None)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . With arguments `force_flags`. numpy", "question_id": 20229}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(names=None, macros=)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . With arguments `macros`. numpy", "question_id": 20230}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(force_flags=None, macros=)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . With arguments `force_flags`, `macros`. numpy", "question_id": 20231}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(names=None, force_flags=None, macros=)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . With arguments `force_flags`, `macros`. numpy", "question_id": 20232}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names()", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . numpy", "question_id": 20233}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(names=None)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . numpy", "question_id": 20234}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(force_flags=None)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . With arguments `force_flags`. numpy", "question_id": 20235}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(macros=)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . With arguments `macros`. numpy", "question_id": 20236}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(names=None, force_flags=None)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . With arguments `force_flags`. numpy", "question_id": 20237}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(names=None, macros=)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . With arguments `macros`. numpy", "question_id": 20238}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(force_flags=None, macros=)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . With arguments `force_flags`, `macros`. numpy", "question_id": 20239}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_names(names=None, force_flags=None, macros=)", "intent": "Returns a set of CPU feature `names` that supported by platform and the C compiler . With arguments `force_flags`, `macros`. numpy", "question_id": 20240}
{"snippet": "ndarray.tobytes()", "intent": "Construct Python bytes containing the raw data bytes in the array . numpy", "question_id": 20241}
{"snippet": "ndarray.tobytes(order='C')", "intent": "Construct Python bytes containing the raw data bytes in the array . This behavior is controlled by the `order` parameter . numpy", "question_id": 20242}
{"snippet": "chararray.ndim", "intent": "Number of array dimensions. numpy", "question_id": 20243}
{"snippet": "numpy.vdot(a, b)", "intent": "Return the dot product of two vectors . The vdot ( `a` , `b` ) function handles complex numbers differently than dot ( a , b ) . numpy", "question_id": 20244}
{"snippet": "polynomial.polyutils.mapparms(old, new)", "intent": "Linear map parameters between domains . Return the parameters of the linear map offset + scale * x that maps `old` to `new` such that old [ i ] - > new [ i ] , i = 0 , 1 . numpy", "question_id": 20245}
{"snippet": "numpy.common_type(*arrays)", "intent": "Return a scalar type which is common to the input arrays . With arguments `*arrays`. numpy", "question_id": 20246}
{"snippet": "testing.assert_approx_equal(actual, desired)", "intent": "Raises an AssertionError if two items are not equal up to `significant` digits . With arguments `actual`, `desired`. numpy", "question_id": 20247}
{"snippet": "testing.assert_approx_equal(actual, desired, significant=7)", "intent": "Raises an AssertionError if two items are not equal up to `significant` digits . With arguments `actual`, `desired`. numpy", "question_id": 20248}
{"snippet": "testing.assert_approx_equal(actual, desired, err_msg='')", "intent": "Raises an AssertionError if two items are not equal up to `significant` digits . With arguments `actual`, `desired`, `err_msg`. numpy", "question_id": 20249}
{"snippet": "testing.assert_approx_equal(actual, desired, verbose=True)", "intent": "Raises an AssertionError if two items are not equal up to `significant` digits . With arguments `actual`, `desired`, `verbose`. numpy", "question_id": 20250}
{"snippet": "testing.assert_approx_equal(actual, desired, significant=7, err_msg='')", "intent": "Raises an AssertionError if two items are not equal up to `significant` digits . With arguments `actual`, `desired`, `err_msg`. numpy", "question_id": 20251}
{"snippet": "testing.assert_approx_equal(actual, desired, significant=7, verbose=True)", "intent": "Raises an AssertionError if two items are not equal up to `significant` digits . With arguments `actual`, `desired`, `verbose`. numpy", "question_id": 20252}
{"snippet": "testing.assert_approx_equal(actual, desired, err_msg='', verbose=True)", "intent": "Raises an AssertionError if two items are not equal up to `significant` digits . With arguments `actual`, `desired`, `err_msg`, `verbose`. numpy", "question_id": 20253}
{"snippet": "testing.assert_approx_equal(actual, desired, significant=7, err_msg='', verbose=True)", "intent": "Raises an AssertionError if two items are not equal up to `significant` digits . With arguments `actual`, `desired`, `err_msg`, `verbose`. numpy", "question_id": 20254}
{"snippet": "char.chararray.compress(condition)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`. numpy", "question_id": 20255}
{"snippet": "char.chararray.compress(condition, axis=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`. numpy", "question_id": 20256}
{"snippet": "char.chararray.compress(condition, out=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`, `out`. numpy", "question_id": 20257}
{"snippet": "char.chararray.compress(condition, axis=None, out=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`, `out`. numpy", "question_id": 20258}
{"snippet": "core.records.fromarrays(arrayList)", "intent": "Create a record array from a ( flat ) list of arrays With arguments `arrayList`. numpy", "question_id": 20259}
{"snippet": "core.records.fromarrays(arrayList, dtype=None)", "intent": "Create a record array from a ( flat ) list of arrays With arguments `arrayList`, `dtype`. numpy", "question_id": 20260}
{"snippet": "core.records.fromarrays(arrayList, shape=None)", "intent": "Create a record array from a ( flat ) list of arrays With arguments `arrayList`, `shape`. numpy", "question_id": 20261}
{"snippet": "core.records.fromarrays(arrayList, formats=None)", "intent": "Create a record array from a ( flat ) list of arrays With arguments `arrayList`, `formats`. numpy", "question_id": 20262}
{"snippet": "core.records.fromarrays(arrayList, names=None)", "intent": "Create a record array from a ( flat ) list of arrays With arguments `arrayList`, `names`. numpy", "question_id": 20263}
{"snippet": "core.records.fromarrays(arrayList, titles=None)", "intent": "Create a record array from a ( flat ) list of arrays With arguments `arrayList`, `titles`. numpy", "question_id": 20264}
{"snippet": "core.records.fromarrays(arrayList, aligned=False)", "intent": "Create a record array from a ( flat ) list of arrays With arguments `arrayList`, `aligned`. numpy", "question_id": 20265}
{"snippet": "core.records.fromarrays(arrayList, byteorder=None)", "intent": "Create a record array from a ( flat ) list of arrays With arguments `arrayList`, `byteorder`. numpy", "question_id": 20266}
{"snippet": "core.records.fromarrays(arrayList, dtype=None, shape=None)", "intent": "Create a record array from a ( flat ) list of arrays With arguments `arrayList`, `dtype`, `shape`. numpy", "question_id": 20267}
{"snippet": "core.records.fromarrays(arrayList, dtype=None, formats=None)", "intent": "Create a record array from a ( flat ) list of arrays With arguments `arrayList`, `dtype`, `formats`. numpy", "question_id": 20268}
{"snippet": "chararray.any()", "intent": "Returns True if any of the elements of a evaluate to True . numpy", "question_id": 20269}
{"snippet": "chararray.any(axis=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`. numpy", "question_id": 20270}
{"snippet": "chararray.any(out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`. numpy", "question_id": 20271}
{"snippet": "chararray.any(keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `keepdims`. numpy", "question_id": 20272}
{"snippet": "chararray.any(where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `where`. numpy", "question_id": 20273}
{"snippet": "chararray.any(axis=None, out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `out`. numpy", "question_id": 20274}
{"snippet": "chararray.any(axis=None, keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `keepdims`. numpy", "question_id": 20275}
{"snippet": "chararray.any(axis=None, where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `where`. numpy", "question_id": 20276}
{"snippet": "chararray.any(out=None, keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`, `keepdims`. numpy", "question_id": 20277}
{"snippet": "chararray.any(out=None, where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`, `where`. numpy", "question_id": 20278}
{"snippet": "matrix.sum()", "intent": "Returns the sum of the matrix elements , along the given `axis` . numpy", "question_id": 20279}
{"snippet": "matrix.sum(axis=None)", "intent": "Returns the sum of the matrix elements , along the given `axis` . numpy", "question_id": 20280}
{"snippet": "matrix.sum(dtype=None)", "intent": "Returns the sum of the matrix elements , along the given `axis` . With arguments `dtype`. numpy", "question_id": 20281}
{"snippet": "matrix.sum(out=None)", "intent": "Returns the sum of the matrix elements , along the given `axis` . With arguments `out`. numpy", "question_id": 20282}
{"snippet": "matrix.sum(axis=None, dtype=None)", "intent": "Returns the sum of the matrix elements , along the given `axis` . With arguments `dtype`. numpy", "question_id": 20283}
{"snippet": "matrix.sum(axis=None, out=None)", "intent": "Returns the sum of the matrix elements , along the given `axis` . With arguments `out`. numpy", "question_id": 20284}
{"snippet": "matrix.sum(dtype=None, out=None)", "intent": "Returns the sum of the matrix elements , along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 20285}
{"snippet": "matrix.sum(axis=None, dtype=None, out=None)", "intent": "Returns the sum of the matrix elements , along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 20286}
{"snippet": "matlib.randn(*args)", "intent": "Return a random matrix with data from the \u201c standard normal \u201d distribution . With arguments `*args`. numpy", "question_id": 20287}
{"snippet": "random.RandomState.geometric(p)", "intent": "Draw samples from the geometric distribution . where `p` is the probability of success of an individual trial . numpy", "question_id": 20288}
{"snippet": "random.RandomState.geometric(p, size=None)", "intent": "Draw samples from the geometric distribution . where `p` is the probability of success of an individual trial . With arguments `size`. numpy", "question_id": 20289}
{"snippet": "memmap.fill(value)", "intent": "Fill the array with a scalar `value` . numpy", "question_id": 20290}
{"snippet": "ma.masked_array.argpartition(kth)", "intent": "Returns the indices that would partition this array . With arguments `kth`. numpy", "question_id": 20291}
{"snippet": "ma.masked_array.argpartition(kth, axis=- 1)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`. numpy", "question_id": 20292}
{"snippet": "ma.masked_array.argpartition(kth, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`. numpy", "question_id": 20293}
{"snippet": "ma.masked_array.argpartition(kth, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `order`. numpy", "question_id": 20294}
{"snippet": "ma.masked_array.argpartition(kth, axis=- 1, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`. numpy", "question_id": 20295}
{"snippet": "ma.masked_array.argpartition(kth, axis=- 1, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `order`. numpy", "question_id": 20296}
{"snippet": "ma.masked_array.argpartition(kth, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`, `order`. numpy", "question_id": 20297}
{"snippet": "ma.masked_array.argpartition(kth, axis=- 1, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`, `order`. numpy", "question_id": 20298}
{"snippet": "numpy.may_share_memory(a, b)", "intent": "Determine if two arrays might share memory Only the memory bounds of `a` and `b` are checked by default . numpy", "question_id": 20299}
{"snippet": "numpy.may_share_memory(a, b, max_work=None)", "intent": "Determine if two arrays might share memory Only the memory bounds of `a` and `b` are checked by default . With arguments `max_work`. numpy", "question_id": 20300}
{"snippet": "nditer.remove_axis(i)", "intent": "Removes axis `i` from the iterator . numpy", "question_id": 20301}
{"snippet": "core.records.array(obj)", "intent": "Construct a record array from a wide-variety of objects . If `obj` is None , then call the recarray constructor . numpy", "question_id": 20302}
{"snippet": "core.records.array(obj, dtype=None)", "intent": "Construct a record array from a wide-variety of objects . If `obj` is None , then call the recarray constructor . With arguments `dtype`. numpy", "question_id": 20303}
{"snippet": "core.records.array(obj, shape=None)", "intent": "Construct a record array from a wide-variety of objects . If `obj` is None , then call the recarray constructor . With arguments `shape`. numpy", "question_id": 20304}
{"snippet": "core.records.array(obj, offset=0)", "intent": "Construct a record array from a wide-variety of objects . If `obj` is None , then call the recarray constructor . With arguments `offset`. numpy", "question_id": 20305}
{"snippet": "core.records.array(obj, strides=None)", "intent": "Construct a record array from a wide-variety of objects . If `obj` is None , then call the recarray constructor . With arguments `strides`. numpy", "question_id": 20306}
{"snippet": "core.records.array(obj, formats=None)", "intent": "Construct a record array from a wide-variety of objects . If `obj` is None , then call the recarray constructor . If obj is a recarray , then make a `copy` of the data in the recarray ( if copy=True ) and use the new `formats` , `names` , and `titles` . numpy", "question_id": 20307}
{"snippet": "core.records.array(obj, names=None)", "intent": "Construct a record array from a wide-variety of objects . If `obj` is None , then call the recarray constructor . If obj is a recarray , then make a `copy` of the data in the recarray ( if copy=True ) and use the new `formats` , `names` , and `titles` . numpy", "question_id": 20308}
{"snippet": "core.records.array(obj, titles=None)", "intent": "Construct a record array from a wide-variety of objects . If `obj` is None , then call the recarray constructor . If obj is a recarray , then make a `copy` of the data in the recarray ( if copy=True ) and use the new `formats` , `names` , and `titles` . numpy", "question_id": 20309}
{"snippet": "core.records.array(obj, aligned=False)", "intent": "Construct a record array from a wide-variety of objects . If `obj` is None , then call the recarray constructor . With arguments `aligned`. numpy", "question_id": 20310}
{"snippet": "core.records.array(obj, byteorder=None)", "intent": "Construct a record array from a wide-variety of objects . If `obj` is None , then call the recarray constructor . With arguments `byteorder`. numpy", "question_id": 20311}
{"snippet": "ma.asarray(a)", "intent": "Convert the input to `a` masked array of the given data-type . numpy", "question_id": 20312}
{"snippet": "ma.asarray(a, dtype=None)", "intent": "Convert the input to `a` masked array of the given data-type . With arguments `dtype`. numpy", "question_id": 20313}
{"snippet": "ma.asarray(a, order=None)", "intent": "Convert the input to `a` masked array of the given data-type . With arguments `order`. numpy", "question_id": 20314}
{"snippet": "ma.asarray(a, dtype=None, order=None)", "intent": "Convert the input to `a` masked array of the given data-type . With arguments `dtype`, `order`. numpy", "question_id": 20315}
{"snippet": "numpy.trunc(x, /, signature, extobj)", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 20316}
{"snippet": "numpy.trunc(x, /, signature, extobj, out=None)", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 20317}
{"snippet": "numpy.trunc(x, /, signature, extobj, where=True)", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 20318}
{"snippet": "numpy.trunc(x, /, signature, extobj, casting='same_kind')", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 20319}
{"snippet": "numpy.trunc(x, /, signature, extobj, order='K')", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 20320}
{"snippet": "numpy.trunc(x, /, signature, extobj, dtype=None)", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 20321}
{"snippet": "numpy.trunc(x, /, signature, extobj, subok=True)", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 20322}
{"snippet": "numpy.trunc(x, /, signature, extobj, out=None, where=True)", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 20323}
{"snippet": "numpy.trunc(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 20324}
{"snippet": "numpy.trunc(x, /, signature, extobj, out=None, order='K')", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 20325}
{"snippet": "numpy.trunc(x, /, signature)", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`. numpy", "question_id": 20326}
{"snippet": "numpy.trunc(x, /, signature, out=None)", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `out`. numpy", "question_id": 20327}
{"snippet": "numpy.trunc(x, /, signature, where=True)", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `where`. numpy", "question_id": 20328}
{"snippet": "numpy.trunc(x, /, signature, casting='same_kind')", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `casting`. numpy", "question_id": 20329}
{"snippet": "numpy.trunc(x, /, signature, order='K')", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `order`. numpy", "question_id": 20330}
{"snippet": "numpy.trunc(x, /, signature, dtype=None)", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 20331}
{"snippet": "numpy.trunc(x, /, signature, subok=True)", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `subok`. numpy", "question_id": 20332}
{"snippet": "numpy.trunc(x, /, signature, out=None, where=True)", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 20333}
{"snippet": "numpy.trunc(x, /, signature, out=None, casting='same_kind')", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 20334}
{"snippet": "numpy.trunc(x, /, signature, out=None, order='K')", "intent": "Return the truncated value of the input , element-wise . The truncated value of the scalar `x` is the nearest integer i which is closer to zero than x is . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 20335}
{"snippet": "chararray.count(sub)", "intent": "Returns an array with the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] . numpy", "question_id": 20336}
{"snippet": "chararray.count(sub, start=0)", "intent": "Returns an array with the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] . numpy", "question_id": 20337}
{"snippet": "chararray.count(sub, end=None)", "intent": "Returns an array with the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] . numpy", "question_id": 20338}
{"snippet": "chararray.count(sub, start=0, end=None)", "intent": "Returns an array with the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] . numpy", "question_id": 20339}
{"snippet": "polynomial.hermite.hermfit(x, y, deg)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a Hermite series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . numpy", "question_id": 20340}
{"snippet": "polynomial.hermite.hermfit(x, y, deg, rcond=None)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a Hermite series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . numpy", "question_id": 20341}
{"snippet": "polynomial.hermite.hermfit(x, y, deg, full=False)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a Hermite series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . With arguments `full`. numpy", "question_id": 20342}
{"snippet": "polynomial.hermite.hermfit(x, y, deg, w=None)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a Hermite series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , y are the observed values . numpy", "question_id": 20343}
{"snippet": "polynomial.hermite.hermfit(x, y, deg, rcond=None, full=False)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a Hermite series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . With arguments `full`. numpy", "question_id": 20344}
{"snippet": "polynomial.hermite.hermfit(x, y, deg, rcond=None, w=None)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a Hermite series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , y are the observed values . numpy", "question_id": 20345}
{"snippet": "polynomial.hermite.hermfit(x, y, deg, full=False, w=None)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a Hermite series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , y are the observed values . With arguments `full`. numpy", "question_id": 20346}
{"snippet": "polynomial.hermite.hermfit(x, y, deg, rcond=None, full=False, w=None)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a Hermite series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , y are the observed values . With arguments `full`. numpy", "question_id": 20347}
{"snippet": "memmap.T", "intent": "The transposed array. numpy", "question_id": 20348}
{"snippet": "record.newbyteorder(/)", "intent": "Return a new dtype with a different byte order . With arguments `/`. numpy", "question_id": 20349}
{"snippet": "record.newbyteorder(/, new_order='S')", "intent": "Return a new dtype with a different byte order . The `new_order` code can be any from the following : With arguments `/`. numpy", "question_id": 20350}
{"snippet": "numpy.ufunc", "intent": "Functions that operate element by element on whole arrays. numpy", "question_id": 20351}
{"snippet": "numpy.DataSource()", "intent": "A generic data source file ( file , http , ftp , \u2026 ) . numpy", "question_id": 20352}
{"snippet": "numpy.DataSource(destpath='.')", "intent": "A generic data source file ( file , http , ftp , \u2026 ) . With arguments `destpath`. numpy", "question_id": 20353}
{"snippet": "generic.__reduce__()", "intent": "Helper for pickle . numpy", "question_id": 20354}
{"snippet": "ma.MaskedArray.fill(value)", "intent": "Fill the array with a scalar `value` . numpy", "question_id": 20355}
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, extobj)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`. numpy", "question_id": 20356}
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, extobj, out=(None)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `out`. numpy", "question_id": 20357}
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, extobj, where=True)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `where`. numpy", "question_id": 20358}
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, extobj, casting='same_kind')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `casting`. numpy", "question_id": 20359}
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, extobj, order='K')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `order`. numpy", "question_id": 20360}
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, extobj, dtype=None)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `dtype`. numpy", "question_id": 20361}
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, extobj, subok=True)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `subok`. numpy", "question_id": 20362}
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, extobj, out=(None, where=True)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 20363}
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, extobj, out=(None, casting='same_kind')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 20364}
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, extobj, out=(None, order='K')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 20365}
{"snippet": "numpy.modf(x, out1, out2, /, None), signature)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`. numpy", "question_id": 20366}
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, out=(None)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `out`. numpy", "question_id": 20367}
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, where=True)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `where`. numpy", "question_id": 20368}
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, casting='same_kind')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `casting`. numpy", "question_id": 20369}
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, order='K')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `order`. numpy", "question_id": 20370}
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, dtype=None)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `dtype`. numpy", "question_id": 20371}
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, subok=True)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `subok`. numpy", "question_id": 20372}
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, out=(None, where=True)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `out`, `where`. numpy", "question_id": 20373}
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, out=(None, casting='same_kind')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `out`, `casting`. numpy", "question_id": 20374}
{"snippet": "numpy.modf(x, out1, out2, /, None), signature, out=(None, order='K')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `signature`, `out`, `order`. numpy", "question_id": 20375}
{"snippet": "numpy.modf(x, out1, out2, /, None))", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`. numpy", "question_id": 20376}
{"snippet": "numpy.modf(x, out1, out2, /, None), out=(None)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `out`. numpy", "question_id": 20377}
{"snippet": "numpy.modf(x, out1, out2, /, None), where=True)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `where`. numpy", "question_id": 20378}
{"snippet": "numpy.modf(x, out1, out2, /, None), casting='same_kind')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `casting`. numpy", "question_id": 20379}
{"snippet": "numpy.modf(x, out1, out2, /, None), order='K')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `order`. numpy", "question_id": 20380}
{"snippet": "numpy.modf(x, out1, out2, /, None), dtype=None)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `dtype`. numpy", "question_id": 20381}
{"snippet": "numpy.modf(x, out1, out2, /, None), subok=True)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `subok`. numpy", "question_id": 20382}
{"snippet": "numpy.modf(x, out1, out2, /, None), out=(None, where=True)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `out`, `where`. numpy", "question_id": 20383}
{"snippet": "numpy.modf(x, out1, out2, /, None), out=(None, casting='same_kind')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `out`, `casting`. numpy", "question_id": 20384}
{"snippet": "numpy.modf(x, out1, out2, /, None), out=(None, order='K')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `None)`, `out`, `order`. numpy", "question_id": 20385}
{"snippet": "numpy.modf(x, out1, out2, /)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`. numpy", "question_id": 20386}
{"snippet": "numpy.modf(x, out1, out2, /, out=(None)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `out`. numpy", "question_id": 20387}
{"snippet": "numpy.modf(x, out1, out2, /, where=True)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `where`. numpy", "question_id": 20388}
{"snippet": "numpy.modf(x, out1, out2, /, casting='same_kind')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `casting`. numpy", "question_id": 20389}
{"snippet": "numpy.modf(x, out1, out2, /, order='K')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `order`. numpy", "question_id": 20390}
{"snippet": "numpy.modf(x, out1, out2, /, dtype=None)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `dtype`. numpy", "question_id": 20391}
{"snippet": "numpy.modf(x, out1, out2, /, subok=True)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `subok`. numpy", "question_id": 20392}
{"snippet": "numpy.modf(x, out1, out2, /, out=(None, where=True)", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `out`, `where`. numpy", "question_id": 20393}
{"snippet": "numpy.modf(x, out1, out2, /, out=(None, casting='same_kind')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `out`, `casting`. numpy", "question_id": 20394}
{"snippet": "numpy.modf(x, out1, out2, /, out=(None, order='K')", "intent": "Return the fractional and integral parts of an array , element-wise . With arguments `x`, `out1`, `out2`, `/`, `out`, `order`. numpy", "question_id": 20395}
{"snippet": "numpy.insert(arr, obj, values)", "intent": "Insert `values` along the given `axis` before the given indices . Note that for higher dimensional inserts obj=0 behaves very different from obj= [ 0 ] just like `arr` [ : ,0 , : ] = values is different from arr [ : , [ 0 ] , : ] = values . With arguments `obj`. numpy", "question_id": 20396}
{"snippet": "numpy.insert(arr, obj, values, axis=None)", "intent": "Insert `values` along the given `axis` before the given indices . Note that for higher dimensional inserts obj=0 behaves very different from obj= [ 0 ] just like `arr` [ : ,0 , : ] = values is different from arr [ : , [ 0 ] , : ] = values . With arguments `obj`. numpy", "question_id": 20397}
{"snippet": "numpy.isposinf(x)", "intent": "Test element-wise for positive infinity , return result as bool array . Errors result if the second argument is also supplied when `x` is a scalar input , if first and second arguments have different shapes , or if the first argument has complex values numpy", "question_id": 20398}
{"snippet": "numpy.isposinf(x, out=None)", "intent": "Test element-wise for positive infinity , return result as bool array . Errors result if the second argument is also supplied when `x` is a scalar input , if first and second arguments have different shapes , or if the first argument has complex values With arguments `out`. numpy", "question_id": 20399}
{"snippet": "ma.allequal(a, b)", "intent": "Return True if all entries of `a` and `b` are equal , using `fill_value` as a truth value where either or both are masked . numpy", "question_id": 20400}
{"snippet": "ma.allequal(a, b, fill_value=True)", "intent": "Return True if all entries of `a` and `b` are equal , using `fill_value` as a truth value where either or both are masked . numpy", "question_id": 20401}
{"snippet": "ma.MaskedArray.cumsum()", "intent": "Return the cumulative sum of the array elements over the given `axis` . numpy", "question_id": 20402}
{"snippet": "ma.MaskedArray.cumsum(axis=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . numpy", "question_id": 20403}
{"snippet": "ma.MaskedArray.cumsum(dtype=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 20404}
{"snippet": "ma.MaskedArray.cumsum(out=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . The mask is lost if `out` is not a valid ma.MaskedArray ! numpy", "question_id": 20405}
{"snippet": "ma.MaskedArray.cumsum(axis=None, dtype=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 20406}
{"snippet": "ma.MaskedArray.cumsum(axis=None, out=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . The mask is lost if `out` is not a valid ma.MaskedArray ! numpy", "question_id": 20407}
{"snippet": "ma.MaskedArray.cumsum(dtype=None, out=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . The mask is lost if `out` is not a valid ma.MaskedArray ! With arguments `dtype`. numpy", "question_id": 20408}
{"snippet": "ma.MaskedArray.cumsum(axis=None, dtype=None, out=None)", "intent": "Return the cumulative sum of the array elements over the given `axis` . The mask is lost if `out` is not a valid ma.MaskedArray ! With arguments `dtype`. numpy", "question_id": 20409}
{"snippet": "numpy.finfo(dtype)", "intent": "Machine limits for floating point types . With arguments `dtype`. numpy", "question_id": 20410}
{"snippet": "random.Generator.wald(mean, scale)", "intent": "Draw samples from a Wald , or inverse Gaussian , distribution . Some references claim that the Wald is an inverse Gaussian with `mean` equal to 1 , but this is by no means universal . As the `scale` approaches infinity , the distribution becomes more like a Gaussian . numpy", "question_id": 20411}
{"snippet": "random.Generator.wald(mean, scale, size=None)", "intent": "Draw samples from a Wald , or inverse Gaussian , distribution . Some references claim that the Wald is an inverse Gaussian with `mean` equal to 1 , but this is by no means universal . As the `scale` approaches infinity , the distribution becomes more like a Gaussian . With arguments `size`. numpy", "question_id": 20412}
{"snippet": "numpy.MachAr()", "intent": "Diagnosing machine parameters . numpy", "question_id": 20413}
{"snippet": "numpy.MachAr(float_conv=<class 'float'>)", "intent": "Diagnosing machine parameters . With arguments `float_conv`. numpy", "question_id": 20414}
{"snippet": "numpy.MachAr(int_conv=<class 'int'>)", "intent": "Diagnosing machine parameters . With arguments `int_conv`. numpy", "question_id": 20415}
{"snippet": "numpy.MachAr(float_to_float=<class 'float'>)", "intent": "Diagnosing machine parameters . With arguments `float_to_float`. numpy", "question_id": 20416}
{"snippet": "numpy.MachAr(float_to_str=<function MachAr.<lambda>>)", "intent": "Diagnosing machine parameters . With arguments `float_to_str`. numpy", "question_id": 20417}
{"snippet": "numpy.MachAr(title='Python floating point number')", "intent": "Diagnosing machine parameters . With arguments `title`. numpy", "question_id": 20418}
{"snippet": "numpy.MachAr(float_conv=<class 'float'>, int_conv=<class 'int'>)", "intent": "Diagnosing machine parameters . With arguments `float_conv`, `int_conv`. numpy", "question_id": 20419}
{"snippet": "numpy.MachAr(float_conv=<class 'float'>, float_to_float=<class 'float'>)", "intent": "Diagnosing machine parameters . With arguments `float_conv`, `float_to_float`. numpy", "question_id": 20420}
{"snippet": "numpy.MachAr(float_conv=<class 'float'>, float_to_str=<function MachAr.<lambda>>)", "intent": "Diagnosing machine parameters . With arguments `float_conv`, `float_to_str`. numpy", "question_id": 20421}
{"snippet": "numpy.MachAr(float_conv=<class 'float'>, title='Python floating point number')", "intent": "Diagnosing machine parameters . With arguments `float_conv`, `title`. numpy", "question_id": 20422}
{"snippet": "generic.real", "intent": "The real part of the scalar. numpy", "question_id": 20423}
{"snippet": "random.Generator.logistic()", "intent": "Draw samples from a logistic distribution . numpy", "question_id": 20424}
{"snippet": "random.Generator.logistic(loc=0.0)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . numpy", "question_id": 20425}
{"snippet": "random.Generator.logistic(scale=1.0)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . numpy", "question_id": 20426}
{"snippet": "random.Generator.logistic(size=None)", "intent": "Draw samples from a logistic distribution . With arguments `size`. numpy", "question_id": 20427}
{"snippet": "random.Generator.logistic(loc=0.0, scale=1.0)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . numpy", "question_id": 20428}
{"snippet": "random.Generator.logistic(loc=0.0, size=None)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . With arguments `size`. numpy", "question_id": 20429}
{"snippet": "random.Generator.logistic(scale=1.0, size=None)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . With arguments `size`. numpy", "question_id": 20430}
{"snippet": "random.Generator.logistic(loc=0.0, scale=1.0, size=None)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . With arguments `size`. numpy", "question_id": 20431}
{"snippet": "record.strides", "intent": "Tuple of bytes steps in each dimension. numpy", "question_id": 20432}
{"snippet": "record.take()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 20433}
{"snippet": "memmap.setflags()", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . numpy", "question_id": 20434}
{"snippet": "memmap.setflags(write=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`. numpy", "question_id": 20435}
{"snippet": "memmap.setflags(align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`. numpy", "question_id": 20436}
{"snippet": "memmap.setflags(uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `uic`. numpy", "question_id": 20437}
{"snippet": "memmap.setflags(write=None, align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`. numpy", "question_id": 20438}
{"snippet": "memmap.setflags(write=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `uic`. numpy", "question_id": 20439}
{"snippet": "memmap.setflags(align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`, `uic`. numpy", "question_id": 20440}
{"snippet": "memmap.setflags(write=None, align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`, `uic`. numpy", "question_id": 20441}
{"snippet": "polynomial.hermite.hermval3d(x, y, z, c)", "intent": "Evaluate a 3-D Hermite series at points ( `x` , `y` , `z` ) . In either case , either x , y , and z or their elements must support multiplication and addition both with themselves and with the elements of `c` . numpy", "question_id": 20442}
{"snippet": "numpy.rint(x, /, signature, extobj)", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `extobj`. numpy", "question_id": 20443}
{"snippet": "numpy.rint(x, /, signature, extobj, out=None)", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 20444}
{"snippet": "numpy.rint(x, /, signature, extobj, where=True)", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `extobj`, `where`. numpy", "question_id": 20445}
{"snippet": "numpy.rint(x, /, signature, extobj, casting='same_kind')", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 20446}
{"snippet": "numpy.rint(x, /, signature, extobj, order='K')", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 20447}
{"snippet": "numpy.rint(x, /, signature, extobj, dtype=None)", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 20448}
{"snippet": "numpy.rint(x, /, signature, extobj, subok=True)", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 20449}
{"snippet": "numpy.rint(x, /, signature, extobj, out=None, where=True)", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 20450}
{"snippet": "numpy.rint(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 20451}
{"snippet": "numpy.rint(x, /, signature, extobj, out=None, order='K')", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 20452}
{"snippet": "numpy.rint(x, /, signature)", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`. numpy", "question_id": 20453}
{"snippet": "numpy.rint(x, /, signature, out=None)", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `out`. numpy", "question_id": 20454}
{"snippet": "numpy.rint(x, /, signature, where=True)", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `where`. numpy", "question_id": 20455}
{"snippet": "numpy.rint(x, /, signature, casting='same_kind')", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `casting`. numpy", "question_id": 20456}
{"snippet": "numpy.rint(x, /, signature, order='K')", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `order`. numpy", "question_id": 20457}
{"snippet": "numpy.rint(x, /, signature, dtype=None)", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `dtype`. numpy", "question_id": 20458}
{"snippet": "numpy.rint(x, /, signature, subok=True)", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `subok`. numpy", "question_id": 20459}
{"snippet": "numpy.rint(x, /, signature, out=None, where=True)", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `out`, `where`. numpy", "question_id": 20460}
{"snippet": "numpy.rint(x, /, signature, out=None, casting='same_kind')", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `out`, `casting`. numpy", "question_id": 20461}
{"snippet": "numpy.rint(x, /, signature, out=None, order='K')", "intent": "Round elements of the array to the nearest integer . With arguments `x`, `/`, `signature`, `out`, `order`. numpy", "question_id": 20462}
{"snippet": "ma.MaskedArray.transpose(*axes)", "intent": "Returns a view of the array with axes transposed . With arguments `*axes`. numpy", "question_id": 20463}
{"snippet": "recarray.compress(condition)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`. numpy", "question_id": 20464}
{"snippet": "recarray.compress(condition, axis=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`. numpy", "question_id": 20465}
{"snippet": "recarray.compress(condition, out=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`, `out`. numpy", "question_id": 20466}
{"snippet": "recarray.compress(condition, axis=None, out=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`, `out`. numpy", "question_id": 20467}
{"snippet": "chararray.dumps()", "intent": "Returns the pickle of the array as a string . numpy", "question_id": 20468}
{"snippet": "memmap.ndim", "intent": "Number of array dimensions. numpy", "question_id": 20469}
{"snippet": "char.capitalize(a)", "intent": "Return `a` copy of a with only the first character of each element capitalized . numpy", "question_id": 20470}
{"snippet": "char.splitlines(a)", "intent": "For each element in `a` , return a list of the lines in the element , breaking at line boundaries . numpy", "question_id": 20471}
{"snippet": "char.splitlines(a, keepends=None)", "intent": "For each element in `a` , return a list of the lines in the element , breaking at line boundaries . With arguments `keepends`. numpy", "question_id": 20472}
{"snippet": "ndarray.argmin()", "intent": "Return indices of the minimum values along the given `axis` . numpy", "question_id": 20473}
{"snippet": "ndarray.argmin(axis=None)", "intent": "Return indices of the minimum values along the given `axis` . numpy", "question_id": 20474}
{"snippet": "ndarray.argmin(out=None)", "intent": "Return indices of the minimum values along the given `axis` . With arguments `out`. numpy", "question_id": 20475}
{"snippet": "ndarray.argmin(axis=None, out=None)", "intent": "Return indices of the minimum values along the given `axis` . With arguments `out`. numpy", "question_id": 20476}
{"snippet": "ndarray.sort()", "intent": "Sort an array in-place . numpy", "question_id": 20477}
{"snippet": "ndarray.sort(axis=- 1)", "intent": "Sort an array in-place . With arguments `axis`. numpy", "question_id": 20478}
{"snippet": "ndarray.sort(kind=None)", "intent": "Sort an array in-place . With arguments `kind`. numpy", "question_id": 20479}
{"snippet": "ndarray.sort(order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : numpy", "question_id": 20480}
{"snippet": "ndarray.sort(axis=- 1, kind=None)", "intent": "Sort an array in-place . With arguments `axis`, `kind`. numpy", "question_id": 20481}
{"snippet": "ndarray.sort(axis=- 1, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `axis`. numpy", "question_id": 20482}
{"snippet": "ndarray.sort(kind=None, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `kind`. numpy", "question_id": 20483}
{"snippet": "ndarray.sort(axis=- 1, kind=None, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `axis`, `kind`. numpy", "question_id": 20484}
{"snippet": "fft.irfft(a)", "intent": "Computes the inverse of rfft . In other words , irfft ( rfft ( `a` ) , len ( a ) ) == a to within numerical accuracy . numpy", "question_id": 20485}
{"snippet": "fft.irfft(a, n=None)", "intent": "Computes the inverse of rfft . In other words , irfft ( rfft ( `a` ) , len ( a ) ) == a to within numerical accuracy . `n` is the length of the result , not the input . numpy", "question_id": 20486}
{"snippet": "fft.irfft(a, axis=- 1)", "intent": "Computes the inverse of rfft . In other words , irfft ( rfft ( `a` ) , len ( a ) ) == a to within numerical accuracy . With arguments `axis`. numpy", "question_id": 20487}
{"snippet": "fft.irfft(a, norm=None)", "intent": "Computes the inverse of rfft . In other words , irfft ( rfft ( `a` ) , len ( a ) ) == a to within numerical accuracy . With arguments `norm`. numpy", "question_id": 20488}
{"snippet": "fft.irfft(a, n=None, axis=- 1)", "intent": "Computes the inverse of rfft . In other words , irfft ( rfft ( `a` ) , len ( a ) ) == a to within numerical accuracy . `n` is the length of the result , not the input . With arguments `axis`. numpy", "question_id": 20489}
{"snippet": "fft.irfft(a, n=None, norm=None)", "intent": "Computes the inverse of rfft . In other words , irfft ( rfft ( `a` ) , len ( a ) ) == a to within numerical accuracy . `n` is the length of the result , not the input . With arguments `norm`. numpy", "question_id": 20490}
{"snippet": "fft.irfft(a, axis=- 1, norm=None)", "intent": "Computes the inverse of rfft . In other words , irfft ( rfft ( `a` ) , len ( a ) ) == a to within numerical accuracy . With arguments `axis`, `norm`. numpy", "question_id": 20491}
{"snippet": "fft.irfft(a, n=None, axis=- 1, norm=None)", "intent": "Computes the inverse of rfft . In other words , irfft ( rfft ( `a` ) , len ( a ) ) == a to within numerical accuracy . `n` is the length of the result , not the input . With arguments `axis`, `norm`. numpy", "question_id": 20492}
{"snippet": "ma.MaskedArray.__iand__(value, /)", "intent": "Return self & =value . With arguments `value`, `/`. numpy", "question_id": 20493}
{"snippet": "numpy.asmatrix(data)", "intent": "Interpret the input as a matrix . Equivalent to matrix ( `data` , copy=False ) . numpy", "question_id": 20494}
{"snippet": "numpy.asmatrix(data, dtype=None)", "intent": "Interpret the input as a matrix . Equivalent to matrix ( `data` , copy=False ) . With arguments `dtype`. numpy", "question_id": 20495}
{"snippet": "char.chararray.nbytes", "intent": "Total bytes consumed by the elements of the array. numpy", "question_id": 20496}
{"snippet": "ma.make_mask_none(newshape)", "intent": "Return a boolean mask of the given shape , filled with False . With arguments `newshape`. numpy", "question_id": 20497}
{"snippet": "ma.make_mask_none(newshape, dtype=None)", "intent": "Return a boolean mask of the given shape , filled with False . If a complex `dtype` is specified , the type of each field is converted to a boolean type . With arguments `newshape`. numpy", "question_id": 20498}
{"snippet": "numpy.apply_over_axes(func, a, axes)", "intent": "Apply `a` function repeatedly over multiple `axes` . `func` is called as res = func ( a , axis ) , where axis is the first element of axes . numpy", "question_id": 20499}
{"snippet": "numpy.triu(m)", "intent": "Upper triangle of an array . With arguments `m`. numpy", "question_id": 20500}
{"snippet": "numpy.triu(m, k=0)", "intent": "Upper triangle of an array . With arguments `m`, `k`. numpy", "question_id": 20501}
{"snippet": "chararray.searchsorted(v)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . numpy", "question_id": 20502}
{"snippet": "chararray.searchsorted(v, side='left')", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`. numpy", "question_id": 20503}
{"snippet": "chararray.searchsorted(v, sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `sorter`. numpy", "question_id": 20504}
{"snippet": "chararray.searchsorted(v, side='left', sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`, `sorter`. numpy", "question_id": 20505}
{"snippet": "random.RandomState.negative_binomial(n, p)", "intent": "Draw samples from a negative binomial distribution . Samples are drawn from a negative binomial distribution with specified parameters , `n` successes and `p` probability of success where n is > 0 and p is in the interval [ 0 , 1 ] . numpy", "question_id": 20506}
{"snippet": "random.RandomState.negative_binomial(n, p, size=None)", "intent": "Draw samples from a negative binomial distribution . Samples are drawn from a negative binomial distribution with specified parameters , `n` successes and `p` probability of success where n is > 0 and p is in the interval [ 0 , 1 ] . With arguments `size`. numpy", "question_id": 20507}
{"snippet": "chararray.ptp()", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . numpy", "question_id": 20508}
{"snippet": "chararray.ptp(axis=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . numpy", "question_id": 20509}
{"snippet": "chararray.ptp(out=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`. numpy", "question_id": 20510}
{"snippet": "chararray.ptp(keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `keepdims`. numpy", "question_id": 20511}
{"snippet": "chararray.ptp(axis=None, out=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`. numpy", "question_id": 20512}
{"snippet": "chararray.ptp(axis=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `keepdims`. numpy", "question_id": 20513}
{"snippet": "chararray.ptp(out=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`, `keepdims`. numpy", "question_id": 20514}
{"snippet": "chararray.ptp(axis=None, out=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`, `keepdims`. numpy", "question_id": 20515}
{"snippet": "polynomial.hermite_e.hermefit(x, y, deg)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a HermiteE series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . numpy", "question_id": 20516}
{"snippet": "polynomial.hermite_e.hermefit(x, y, deg, rcond=None)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a HermiteE series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . numpy", "question_id": 20517}
{"snippet": "polynomial.hermite_e.hermefit(x, y, deg, full=False)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a HermiteE series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . With arguments `full`. numpy", "question_id": 20518}
{"snippet": "polynomial.hermite_e.hermefit(x, y, deg, w=None)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a HermiteE series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . Fits using HermiteE series are probably most useful when the data can be approximated by sqrt ( `w` ( x ) ) * p ( x ) , where w ( x ) is the HermiteE weight . numpy", "question_id": 20519}
{"snippet": "polynomial.hermite_e.hermefit(x, y, deg, rcond=None, full=False)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a HermiteE series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . With arguments `full`. numpy", "question_id": 20520}
{"snippet": "polynomial.hermite_e.hermefit(x, y, deg, rcond=None, w=None)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a HermiteE series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . Fits using HermiteE series are probably most useful when the data can be approximated by sqrt ( `w` ( x ) ) * p ( x ) , where w ( x ) is the HermiteE weight . numpy", "question_id": 20521}
{"snippet": "polynomial.hermite_e.hermefit(x, y, deg, full=False, w=None)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a HermiteE series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . Fits using HermiteE series are probably most useful when the data can be approximated by sqrt ( `w` ( x ) ) * p ( x ) , where w ( x ) is the HermiteE weight . With arguments `full`. numpy", "question_id": 20522}
{"snippet": "polynomial.hermite_e.hermefit(x, y, deg, rcond=None, full=False, w=None)", "intent": "Least squares fit of Hermite series to data . Return the coefficients of a HermiteE series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . Fits using HermiteE series are probably most useful when the data can be approximated by sqrt ( `w` ( x ) ) * p ( x ) , where w ( x ) is the HermiteE weight . With arguments `full`. numpy", "question_id": 20523}
{"snippet": "random.standard_cauchy()", "intent": "Draw samples from a standard Cauchy distribution with mode = 0 . numpy", "question_id": 20524}
{"snippet": "random.standard_cauchy(size=None)", "intent": "Draw samples from a standard Cauchy distribution with mode = 0 . With arguments `size`. numpy", "question_id": 20525}
{"snippet": "polynomial.laguerre.Laguerre.copy()", "intent": "Return a copy . numpy", "question_id": 20526}
{"snippet": "distutils.ccompiler.simple_version_match()", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . numpy", "question_id": 20527}
{"snippet": "distutils.ccompiler.simple_version_match(pat='-.\\\\d+')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `pat`. numpy", "question_id": 20528}
{"snippet": "distutils.ccompiler.simple_version_match(ignore='')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `ignore`. numpy", "question_id": 20529}
{"snippet": "distutils.ccompiler.simple_version_match(start='')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `start`. numpy", "question_id": 20530}
{"snippet": "distutils.ccompiler.simple_version_match(pat='-.\\\\d+', ignore='')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `pat`, `ignore`. numpy", "question_id": 20531}
{"snippet": "distutils.ccompiler.simple_version_match(pat='-.\\\\d+', start='')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `pat`, `start`. numpy", "question_id": 20532}
{"snippet": "distutils.ccompiler.simple_version_match(ignore='', start='')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `ignore`, `start`. numpy", "question_id": 20533}
{"snippet": "distutils.ccompiler.simple_version_match(pat='-.\\\\d+', ignore='', start='')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `pat`, `ignore`, `start`. numpy", "question_id": 20534}
{"snippet": "distutils.ccompiler.simple_version_match()", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . numpy", "question_id": 20535}
{"snippet": "distutils.ccompiler.simple_version_match(pat='-.\\\\d+')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `pat`. numpy", "question_id": 20536}
{"snippet": "distutils.ccompiler.simple_version_match(ignore='')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `ignore`. numpy", "question_id": 20537}
{"snippet": "distutils.ccompiler.simple_version_match(start='')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `start`. numpy", "question_id": 20538}
{"snippet": "distutils.ccompiler.simple_version_match(pat='-.\\\\d+', ignore='')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `pat`, `ignore`. numpy", "question_id": 20539}
{"snippet": "distutils.ccompiler.simple_version_match(pat='-.\\\\d+', start='')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `pat`, `start`. numpy", "question_id": 20540}
{"snippet": "distutils.ccompiler.simple_version_match(ignore='', start='')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `ignore`, `start`. numpy", "question_id": 20541}
{"snippet": "distutils.ccompiler.simple_version_match(pat='-.\\\\d+', ignore='', start='')", "intent": "Simple matching of version numbers , for use in CCompiler and FCompiler . With arguments `pat`, `ignore`, `start`. numpy", "question_id": 20542}
{"snippet": "char.chararray.tobytes()", "intent": "Construct Python bytes containing the raw data bytes in the array . numpy", "question_id": 20543}
{"snippet": "char.chararray.tobytes(order='C')", "intent": "Construct Python bytes containing the raw data bytes in the array . This behavior is controlled by the `order` parameter . numpy", "question_id": 20544}
{"snippet": "random.RandomState.lognormal()", "intent": "Draw samples from a log-normal distribution . numpy", "question_id": 20545}
{"snippet": "random.RandomState.lognormal(mean=0.0)", "intent": "Draw samples from a log-normal distribution . Draw samples from a log-normal distribution with specified `mean` , standard deviation , and array shape . numpy", "question_id": 20546}
{"snippet": "random.RandomState.lognormal(sigma=1.0)", "intent": "Draw samples from a log-normal distribution . With arguments `sigma`. numpy", "question_id": 20547}
{"snippet": "random.RandomState.lognormal(size=None)", "intent": "Draw samples from a log-normal distribution . With arguments `size`. numpy", "question_id": 20548}
{"snippet": "random.RandomState.lognormal(mean=0.0, sigma=1.0)", "intent": "Draw samples from a log-normal distribution . Draw samples from a log-normal distribution with specified `mean` , standard deviation , and array shape . With arguments `sigma`. numpy", "question_id": 20549}
{"snippet": "random.RandomState.lognormal(mean=0.0, size=None)", "intent": "Draw samples from a log-normal distribution . Draw samples from a log-normal distribution with specified `mean` , standard deviation , and array shape . With arguments `size`. numpy", "question_id": 20550}
{"snippet": "random.RandomState.lognormal(sigma=1.0, size=None)", "intent": "Draw samples from a log-normal distribution . With arguments `sigma`, `size`. numpy", "question_id": 20551}
{"snippet": "random.RandomState.lognormal(mean=0.0, sigma=1.0, size=None)", "intent": "Draw samples from a log-normal distribution . Draw samples from a log-normal distribution with specified `mean` , standard deviation , and array shape . With arguments `sigma`, `size`. numpy", "question_id": 20552}
{"snippet": "numpy.log1p(x, /, signature, extobj)", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 20553}
{"snippet": "numpy.log1p(x, /, signature, extobj, out=None)", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 20554}
{"snippet": "numpy.log1p(x, /, signature, extobj, where=True)", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 20555}
{"snippet": "numpy.log1p(x, /, signature, extobj, casting='same_kind')", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 20556}
{"snippet": "numpy.log1p(x, /, signature, extobj, order='K')", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 20557}
{"snippet": "numpy.log1p(x, /, signature, extobj, dtype=None)", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 20558}
{"snippet": "numpy.log1p(x, /, signature, extobj, subok=True)", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 20559}
{"snippet": "numpy.log1p(x, /, signature, extobj, out=None, where=True)", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 20560}
{"snippet": "numpy.log1p(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 20561}
{"snippet": "numpy.log1p(x, /, signature, extobj, out=None, order='K')", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 20562}
{"snippet": "numpy.log1p(x, /, signature)", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`. numpy", "question_id": 20563}
{"snippet": "numpy.log1p(x, /, signature, out=None)", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `out`. numpy", "question_id": 20564}
{"snippet": "numpy.log1p(x, /, signature, where=True)", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `where`. numpy", "question_id": 20565}
{"snippet": "numpy.log1p(x, /, signature, casting='same_kind')", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `casting`. numpy", "question_id": 20566}
{"snippet": "numpy.log1p(x, /, signature, order='K')", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `order`. numpy", "question_id": 20567}
{"snippet": "numpy.log1p(x, /, signature, dtype=None)", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 20568}
{"snippet": "numpy.log1p(x, /, signature, subok=True)", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `subok`. numpy", "question_id": 20569}
{"snippet": "numpy.log1p(x, /, signature, out=None, where=True)", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 20570}
{"snippet": "numpy.log1p(x, /, signature, out=None, casting='same_kind')", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 20571}
{"snippet": "numpy.log1p(x, /, signature, out=None, order='K')", "intent": "Return the natural logarithm of one plus the input array , element-wise . Calculates log ( 1 + `x` ) . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 20572}
{"snippet": "polynomial.hermite_e.HermiteE.convert()", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 20573}
{"snippet": "polynomial.hermite_e.HermiteE.convert(domain=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 20574}
{"snippet": "polynomial.hermite_e.HermiteE.convert(kind=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 20575}
{"snippet": "polynomial.hermite_e.HermiteE.convert(window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 20576}
{"snippet": "polynomial.hermite_e.HermiteE.convert(domain=None, kind=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 20577}
{"snippet": "polynomial.hermite_e.HermiteE.convert(domain=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 20578}
{"snippet": "polynomial.hermite_e.HermiteE.convert(kind=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 20579}
{"snippet": "polynomial.hermite_e.HermiteE.convert(domain=None, kind=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 20580}
{"snippet": "numpy.sort(a)", "intent": "Return `a` sorted copy of an array . numpy", "question_id": 20581}
{"snippet": "numpy.sort(a, axis=- 1)", "intent": "Return `a` sorted copy of an array . All the sort algorithms make temporary copies of the data when sorting along any but the last `axis` . numpy", "question_id": 20582}
{"snippet": "numpy.sort(a, kind=None)", "intent": "Return `a` sorted copy of an array . With arguments `kind`. numpy", "question_id": 20583}
{"snippet": "numpy.sort(a, order=None)", "intent": "Return `a` sorted copy of an array . A stable sort keeps items with the same key in the same relative `order` . numpy", "question_id": 20584}
{"snippet": "numpy.sort(a, axis=- 1, kind=None)", "intent": "Return `a` sorted copy of an array . All the sort algorithms make temporary copies of the data when sorting along any but the last `axis` . With arguments `kind`. numpy", "question_id": 20585}
{"snippet": "numpy.sort(a, axis=- 1, order=None)", "intent": "Return `a` sorted copy of an array . All the sort algorithms make temporary copies of the data when sorting along any but the last `axis` . A stable sort keeps items with the same key in the same relative `order` . numpy", "question_id": 20586}
{"snippet": "numpy.sort(a, kind=None, order=None)", "intent": "Return `a` sorted copy of an array . A stable sort keeps items with the same key in the same relative `order` . With arguments `kind`. numpy", "question_id": 20587}
{"snippet": "numpy.sort(a, axis=- 1, kind=None, order=None)", "intent": "Return `a` sorted copy of an array . All the sort algorithms make temporary copies of the data when sorting along any but the last `axis` . A stable sort keeps items with the same key in the same relative `order` . With arguments `kind`. numpy", "question_id": 20588}
{"snippet": "char.chararray.strip()", "intent": "For each element in self , return a copy with the leading and trailing characters removed . numpy", "question_id": 20589}
{"snippet": "char.chararray.strip(chars=None)", "intent": "For each element in self , return a copy with the leading and trailing characters removed . With arguments `chars`. numpy", "question_id": 20590}
{"snippet": "numpy.polyfit(x, y, deg)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . numpy", "question_id": 20591}
{"snippet": "numpy.polyfit(x, y, deg, rcond=None)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious : including contributions from the small singular values can add numerical noise to the result . numpy", "question_id": 20592}
{"snippet": "numpy.polyfit(x, y, deg, full=False)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . With arguments `full`. numpy", "question_id": 20593}
{"snippet": "numpy.polyfit(x, y, deg, w=None)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . With arguments `w`. numpy", "question_id": 20594}
{"snippet": "numpy.polyfit(x, y, deg, cov=False)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . With arguments `cov`. numpy", "question_id": 20595}
{"snippet": "numpy.polyfit(x, y, deg, rcond=None, full=False)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious : including contributions from the small singular values can add numerical noise to the result . With arguments `full`. numpy", "question_id": 20596}
{"snippet": "numpy.polyfit(x, y, deg, rcond=None, w=None)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious : including contributions from the small singular values can add numerical noise to the result . With arguments `w`. numpy", "question_id": 20597}
{"snippet": "numpy.polyfit(x, y, deg, rcond=None, cov=False)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious : including contributions from the small singular values can add numerical noise to the result . With arguments `cov`. numpy", "question_id": 20598}
{"snippet": "numpy.polyfit(x, y, deg, full=False, w=None)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . With arguments `full`, `w`. numpy", "question_id": 20599}
{"snippet": "numpy.polyfit(x, y, deg, full=False, cov=False)", "intent": "Least squares polynomial fit . Fit a polynomial p ( `x` ) = p [ 0 ] * x * * `deg` + ... + p [ deg ] of degree deg to points ( x , `y` ) . With arguments `full`, `cov`. numpy", "question_id": 20600}
{"snippet": "record.diagonal()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 20601}
{"snippet": "numpy.ldexp(x1, x2, /, signature, extobj)", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 20602}
{"snippet": "numpy.ldexp(x1, x2, /, signature, extobj, out=None)", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 20603}
{"snippet": "numpy.ldexp(x1, x2, /, signature, extobj, where=True)", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 20604}
{"snippet": "numpy.ldexp(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 20605}
{"snippet": "numpy.ldexp(x1, x2, /, signature, extobj, order='K')", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 20606}
{"snippet": "numpy.ldexp(x1, x2, /, signature, extobj, dtype=None)", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 20607}
{"snippet": "numpy.ldexp(x1, x2, /, signature, extobj, subok=True)", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 20608}
{"snippet": "numpy.ldexp(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 20609}
{"snippet": "numpy.ldexp(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 20610}
{"snippet": "numpy.ldexp(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 20611}
{"snippet": "numpy.ldexp(x1, x2, /, signature)", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`. numpy", "question_id": 20612}
{"snippet": "numpy.ldexp(x1, x2, /, signature, out=None)", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `out`. numpy", "question_id": 20613}
{"snippet": "numpy.ldexp(x1, x2, /, signature, where=True)", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `where`. numpy", "question_id": 20614}
{"snippet": "numpy.ldexp(x1, x2, /, signature, casting='same_kind')", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `casting`. numpy", "question_id": 20615}
{"snippet": "numpy.ldexp(x1, x2, /, signature, order='K')", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `order`. numpy", "question_id": 20616}
{"snippet": "numpy.ldexp(x1, x2, /, signature, dtype=None)", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 20617}
{"snippet": "numpy.ldexp(x1, x2, /, signature, subok=True)", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `subok`. numpy", "question_id": 20618}
{"snippet": "numpy.ldexp(x1, x2, /, signature, out=None, where=True)", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 20619}
{"snippet": "numpy.ldexp(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 20620}
{"snippet": "numpy.ldexp(x1, x2, /, signature, out=None, order='K')", "intent": "Returns `x1` * 2 * * `x2` , element-wise . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 20621}
{"snippet": "numpy.cov(m)", "intent": "Estimate a covariance matrix , given data and weights . Assume that the observations are in the columns of the observation array `m` and let f = `fweights` and a = `aweights` for brevity . numpy", "question_id": 20622}
{"snippet": "numpy.cov(m, y=None)", "intent": "Estimate a covariance matrix , given data and weights . Assume that the observations are in the columns of the observation array `m` and let f = `fweights` and a = `aweights` for brevity . Further , note how x and `y` are combined : numpy", "question_id": 20623}
{"snippet": "numpy.cov(m, rowvar=True)", "intent": "Estimate a covariance matrix , given data and weights . Assume that the observations are in the columns of the observation array `m` and let f = `fweights` and a = `aweights` for brevity . With arguments `rowvar`. numpy", "question_id": 20624}
{"snippet": "numpy.cov(m, bias=False)", "intent": "Estimate a covariance matrix , given data and weights . Assume that the observations are in the columns of the observation array `m` and let f = `fweights` and a = `aweights` for brevity . With arguments `bias`. numpy", "question_id": 20625}
{"snippet": "numpy.cov(m, ddof=None)", "intent": "Estimate a covariance matrix , given data and weights . Assume that the observations are in the columns of the observation array `m` and let f = `fweights` and a = `aweights` for brevity . Note that when a == 1 , the normalization factor v1 / ( v1 * * 2 - `ddof` * v2 ) goes over to 1 / ( np.sum ( f ) - ddof ) as it should . numpy", "question_id": 20626}
{"snippet": "numpy.cov(m, fweights=None)", "intent": "Estimate a covariance matrix , given data and weights . Assume that the observations are in the columns of the observation array `m` and let f = `fweights` and a = `aweights` for brevity . numpy", "question_id": 20627}
{"snippet": "numpy.cov(m, aweights=None)", "intent": "Estimate a covariance matrix , given data and weights . Assume that the observations are in the columns of the observation array `m` and let f = `fweights` and a = `aweights` for brevity . numpy", "question_id": 20628}
{"snippet": "numpy.cov(m, dtype=None)", "intent": "Estimate a covariance matrix , given data and weights . Assume that the observations are in the columns of the observation array `m` and let f = `fweights` and a = `aweights` for brevity . With arguments `dtype`. numpy", "question_id": 20629}
{"snippet": "numpy.cov(m, y=None, rowvar=True)", "intent": "Estimate a covariance matrix , given data and weights . Assume that the observations are in the columns of the observation array `m` and let f = `fweights` and a = `aweights` for brevity . Further , note how x and `y` are combined : With arguments `rowvar`. numpy", "question_id": 20630}
{"snippet": "numpy.cov(m, y=None, bias=False)", "intent": "Estimate a covariance matrix , given data and weights . Assume that the observations are in the columns of the observation array `m` and let f = `fweights` and a = `aweights` for brevity . Further , note how x and `y` are combined : With arguments `bias`. numpy", "question_id": 20631}
{"snippet": "lib.format.read_array(fp)", "intent": "Read an array from an NPY file . With arguments `fp`. numpy", "question_id": 20632}
{"snippet": "lib.format.read_array(fp, allow_pickle=False)", "intent": "Read an array from an NPY file . With arguments `fp`, `allow_pickle`. numpy", "question_id": 20633}
{"snippet": "lib.format.read_array(fp, pickle_kwargs=None)", "intent": "Read an array from an NPY file . With arguments `fp`, `pickle_kwargs`. numpy", "question_id": 20634}
{"snippet": "lib.format.read_array(fp, allow_pickle=False, pickle_kwargs=None)", "intent": "Read an array from an NPY file . With arguments `fp`, `allow_pickle`, `pickle_kwargs`. numpy", "question_id": 20635}
{"snippet": "numpy.savetxt(fname, X)", "intent": "Save an array to a text file . With arguments `fname`, `X`. numpy", "question_id": 20636}
{"snippet": "numpy.savetxt(fname, X, fmt='%.18e')", "intent": "Save an array to a text file . Further explanation of the `fmt` parameter ( % [ flag ] width [ .precision ] specifier ) : With arguments `fname`, `X`. numpy", "question_id": 20637}
{"snippet": "numpy.savetxt(fname, X, delimiter=' ')", "intent": "Save an array to a text file . With arguments `fname`, `X`, `delimiter`. numpy", "question_id": 20638}
{"snippet": "numpy.savetxt(fname, X, newline='\\n')", "intent": "Save an array to a text file . With arguments `fname`, `X`, `newline`. numpy", "question_id": 20639}
{"snippet": "numpy.savetxt(fname, X, header='')", "intent": "Save an array to a text file . With arguments `fname`, `X`, `header`. numpy", "question_id": 20640}
{"snippet": "numpy.savetxt(fname, X, footer='')", "intent": "Save an array to a text file . With arguments `fname`, `X`, `footer`. numpy", "question_id": 20641}
{"snippet": "numpy.savetxt(fname, X, comments='# ')", "intent": "Save an array to a text file . With arguments `fname`, `X`, `comments`. numpy", "question_id": 20642}
{"snippet": "numpy.savetxt(fname, X, encoding=None)", "intent": "Save an array to a text file . With arguments `fname`, `X`, `encoding`. numpy", "question_id": 20643}
{"snippet": "numpy.savetxt(fname, X, fmt='%.18e', delimiter=' ')", "intent": "Save an array to a text file . Further explanation of the `fmt` parameter ( % [ flag ] width [ .precision ] specifier ) : With arguments `fname`, `X`, `delimiter`. numpy", "question_id": 20644}
{"snippet": "numpy.savetxt(fname, X, fmt='%.18e', newline='\\n')", "intent": "Save an array to a text file . Further explanation of the `fmt` parameter ( % [ flag ] width [ .precision ] specifier ) : With arguments `fname`, `X`, `newline`. numpy", "question_id": 20645}
{"snippet": "numpy.rot90(m, 1))", "intent": "Rotate an array by 90 degrees in the plane specified by `axes` . rot90 ( `m` , k=1 , axes= ( 1,0 ) ) is the reverse of rot90 ( m , k=1 , axes= ( 0,1 ) ) rot90 ( m , k=1 , axes= ( 1,0 ) ) is equivalent to rot90 ( m , k=-1 , axes= ( 0,1 ) ) With arguments `1)`. numpy", "question_id": 20646}
{"snippet": "numpy.rot90(m, 1), k=1)", "intent": "Rotate an array by 90 degrees in the plane specified by `axes` . rot90 ( `m` , k=1 , axes= ( 1,0 ) ) is the reverse of rot90 ( m , k=1 , axes= ( 0,1 ) ) rot90 ( m , k=1 , axes= ( 1,0 ) ) is equivalent to rot90 ( m , k=-1 , axes= ( 0,1 ) ) With arguments `1)`, `k`. numpy", "question_id": 20647}
{"snippet": "numpy.rot90(m, 1), axes=(0)", "intent": "Rotate an array by 90 degrees in the plane specified by `axes` . rot90 ( `m` , k=1 , axes= ( 1,0 ) ) is the reverse of rot90 ( m , k=1 , axes= ( 0,1 ) ) rot90 ( m , k=1 , axes= ( 1,0 ) ) is equivalent to rot90 ( m , k=-1 , axes= ( 0,1 ) ) With arguments `1)`. numpy", "question_id": 20648}
{"snippet": "numpy.rot90(m, 1), k=1, axes=(0)", "intent": "Rotate an array by 90 degrees in the plane specified by `axes` . rot90 ( `m` , k=1 , axes= ( 1,0 ) ) is the reverse of rot90 ( m , k=1 , axes= ( 0,1 ) ) rot90 ( m , k=1 , axes= ( 1,0 ) ) is equivalent to rot90 ( m , k=-1 , axes= ( 0,1 ) ) With arguments `1)`, `k`. numpy", "question_id": 20649}
{"snippet": "polynomial.hermite.Hermite.has_samecoef(other)", "intent": "Check if coefficients match . With arguments `other`. numpy", "question_id": 20650}
{"snippet": "numpy.array2string(a)", "intent": "Return `a` string representation of an array . numpy", "question_id": 20651}
{"snippet": "numpy.array2string(a, max_line_width=None)", "intent": "Return `a` string representation of an array . With arguments `max_line_width`. numpy", "question_id": 20652}
{"snippet": "numpy.array2string(a, precision=None)", "intent": "Return `a` string representation of an array . If a `formatter` is specified for a certain type , the `precision` keyword is ignored for that type . numpy", "question_id": 20653}
{"snippet": "numpy.array2string(a, suppress_small=None)", "intent": "Return `a` string representation of an array . With arguments `suppress_small`. numpy", "question_id": 20654}
{"snippet": "numpy.array2string(a, separator=' ')", "intent": "Return `a` string representation of an array . With arguments `separator`. numpy", "question_id": 20655}
{"snippet": "numpy.array2string(a, prefix='')", "intent": "Return `a` string representation of an array . With arguments `prefix`. numpy", "question_id": 20656}
{"snippet": "numpy.array2string(a, style=<no value>)", "intent": "Return `a` string representation of an array . With arguments `style`. numpy", "question_id": 20657}
{"snippet": "numpy.array2string(a, formatter=None)", "intent": "Return `a` string representation of an array . If a `formatter` is specified for a certain type , the `precision` keyword is ignored for that type . numpy", "question_id": 20658}
{"snippet": "numpy.array2string(a, threshold=None)", "intent": "Return `a` string representation of an array . With arguments `threshold`. numpy", "question_id": 20659}
{"snippet": "numpy.array2string(a, edgeitems=None)", "intent": "Return `a` string representation of an array . With arguments `edgeitems`. numpy", "question_id": 20660}
{"snippet": "ma.masked_array.compress(condition)", "intent": "Return a where `condition` is True . numpy", "question_id": 20661}
{"snippet": "ma.masked_array.compress(condition, axis=None)", "intent": "Return a where `condition` is True . With arguments `axis`. numpy", "question_id": 20662}
{"snippet": "ma.masked_array.compress(condition, out=None)", "intent": "Return a where `condition` is True . With arguments `out`. numpy", "question_id": 20663}
{"snippet": "ma.masked_array.compress(condition, axis=None, out=None)", "intent": "Return a where `condition` is True . With arguments `axis`, `out`. numpy", "question_id": 20664}
{"snippet": "polynomial.hermite.Hermite.degree()", "intent": "The degree of the series . numpy", "question_id": 20665}
{"snippet": "numpy.polynomial.polynomial.Polynomial(coef)", "intent": "A power series class . With arguments `coef`. numpy", "question_id": 20666}
{"snippet": "numpy.polynomial.polynomial.Polynomial(coef, domain=None)", "intent": "A power series class . With arguments `coef`, `domain`. numpy", "question_id": 20667}
{"snippet": "numpy.polynomial.polynomial.Polynomial(coef, window=None)", "intent": "A power series class . With arguments `coef`, `window`. numpy", "question_id": 20668}
{"snippet": "numpy.polynomial.polynomial.Polynomial(coef, domain=None, window=None)", "intent": "A power series class . With arguments `coef`, `domain`, `window`. numpy", "question_id": 20669}
{"snippet": "random.Generator.standard_exponential()", "intent": "Draw samples from the standard exponential distribution . numpy", "question_id": 20670}
{"snippet": "random.Generator.standard_exponential(size=None)", "intent": "Draw samples from the standard exponential distribution . With arguments `size`. numpy", "question_id": 20671}
{"snippet": "random.Generator.standard_exponential(dtype=np.float64)", "intent": "Draw samples from the standard exponential distribution . With arguments `dtype`. numpy", "question_id": 20672}
{"snippet": "random.Generator.standard_exponential(method='zig')", "intent": "Draw samples from the standard exponential distribution . With arguments `method`. numpy", "question_id": 20673}
{"snippet": "random.Generator.standard_exponential(out=None)", "intent": "Draw samples from the standard exponential distribution . With arguments `out`. numpy", "question_id": 20674}
{"snippet": "random.Generator.standard_exponential(size=None, dtype=np.float64)", "intent": "Draw samples from the standard exponential distribution . With arguments `size`, `dtype`. numpy", "question_id": 20675}
{"snippet": "random.Generator.standard_exponential(size=None, method='zig')", "intent": "Draw samples from the standard exponential distribution . With arguments `size`, `method`. numpy", "question_id": 20676}
{"snippet": "random.Generator.standard_exponential(size=None, out=None)", "intent": "Draw samples from the standard exponential distribution . With arguments `size`, `out`. numpy", "question_id": 20677}
{"snippet": "random.Generator.standard_exponential(dtype=np.float64, method='zig')", "intent": "Draw samples from the standard exponential distribution . With arguments `dtype`, `method`. numpy", "question_id": 20678}
{"snippet": "random.Generator.standard_exponential(dtype=np.float64, out=None)", "intent": "Draw samples from the standard exponential distribution . With arguments `dtype`, `out`. numpy", "question_id": 20679}
{"snippet": "ma.zeros(shape)", "intent": "Return a new array of given `shape` and type , filled with zeros . numpy", "question_id": 20680}
{"snippet": "ma.zeros(shape, dtype=float)", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `dtype`. numpy", "question_id": 20681}
{"snippet": "ma.zeros(shape, order='C')", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `order`. numpy", "question_id": 20682}
{"snippet": "ma.zeros(shape, like=None)", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `like`. numpy", "question_id": 20683}
{"snippet": "ma.zeros(shape, dtype=float, order='C')", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `dtype`, `order`. numpy", "question_id": 20684}
{"snippet": "ma.zeros(shape, dtype=float, like=None)", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `dtype`, `like`. numpy", "question_id": 20685}
{"snippet": "ma.zeros(shape, order='C', like=None)", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `order`, `like`. numpy", "question_id": 20686}
{"snippet": "ma.zeros(shape, dtype=float, order='C', like=None)", "intent": "Return a new array of given `shape` and type , filled with zeros . With arguments `dtype`, `order`, `like`. numpy", "question_id": 20687}
{"snippet": "random.RandomState.poisson()", "intent": "Draw samples from a Poisson distribution . numpy", "question_id": 20688}
{"snippet": "random.RandomState.poisson(lam=1.0)", "intent": "Draw samples from a Poisson distribution . Because the output is limited to the range of the C int64 type , a ValueError is raised when `lam` is within 10 sigma of the maximum representable value . numpy", "question_id": 20689}
{"snippet": "random.RandomState.poisson(size=None)", "intent": "Draw samples from a Poisson distribution . With arguments `size`. numpy", "question_id": 20690}
{"snippet": "random.RandomState.poisson(lam=1.0, size=None)", "intent": "Draw samples from a Poisson distribution . Because the output is limited to the range of the C int64 type , a ValueError is raised when `lam` is within 10 sigma of the maximum representable value . With arguments `size`. numpy", "question_id": 20691}
{"snippet": "char.isnumeric(a)", "intent": "For each element , return True if there are only numeric characters in the element . With arguments `a`. numpy", "question_id": 20692}
{"snippet": "numpy.copysign(x1, x2, /, signature, extobj)", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 20693}
{"snippet": "numpy.copysign(x1, x2, /, signature, extobj, out=None)", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 20694}
{"snippet": "numpy.copysign(x1, x2, /, signature, extobj, where=True)", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 20695}
{"snippet": "numpy.copysign(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 20696}
{"snippet": "numpy.copysign(x1, x2, /, signature, extobj, order='K')", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 20697}
{"snippet": "numpy.copysign(x1, x2, /, signature, extobj, dtype=None)", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 20698}
{"snippet": "numpy.copysign(x1, x2, /, signature, extobj, subok=True)", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 20699}
{"snippet": "numpy.copysign(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 20700}
{"snippet": "numpy.copysign(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 20701}
{"snippet": "numpy.copysign(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 20702}
{"snippet": "numpy.copysign(x1, x2, /, signature)", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`. numpy", "question_id": 20703}
{"snippet": "numpy.copysign(x1, x2, /, signature, out=None)", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `out`. numpy", "question_id": 20704}
{"snippet": "numpy.copysign(x1, x2, /, signature, where=True)", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `where`. numpy", "question_id": 20705}
{"snippet": "numpy.copysign(x1, x2, /, signature, casting='same_kind')", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `casting`. numpy", "question_id": 20706}
{"snippet": "numpy.copysign(x1, x2, /, signature, order='K')", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `order`. numpy", "question_id": 20707}
{"snippet": "numpy.copysign(x1, x2, /, signature, dtype=None)", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 20708}
{"snippet": "numpy.copysign(x1, x2, /, signature, subok=True)", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `subok`. numpy", "question_id": 20709}
{"snippet": "numpy.copysign(x1, x2, /, signature, out=None, where=True)", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 20710}
{"snippet": "numpy.copysign(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 20711}
{"snippet": "numpy.copysign(x1, x2, /, signature, out=None, order='K')", "intent": "Change the sign of `x1` to that of `x2` , element-wise . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 20712}
{"snippet": "chararray.argmin()", "intent": "Return indices of the minimum values along the given `axis` . numpy", "question_id": 20713}
{"snippet": "chararray.argmin(axis=None)", "intent": "Return indices of the minimum values along the given `axis` . numpy", "question_id": 20714}
{"snippet": "chararray.argmin(out=None)", "intent": "Return indices of the minimum values along the given `axis` . With arguments `out`. numpy", "question_id": 20715}
{"snippet": "chararray.argmin(axis=None, out=None)", "intent": "Return indices of the minimum values along the given `axis` . With arguments `out`. numpy", "question_id": 20716}
{"snippet": "numpy.setxor1d(ar1, ar2)", "intent": "Find the set exclusive-or of two arrays . With arguments `ar1`, `ar2`. numpy", "question_id": 20717}
{"snippet": "numpy.setxor1d(ar1, ar2, assume_unique=False)", "intent": "Find the set exclusive-or of two arrays . With arguments `ar1`, `ar2`, `assume_unique`. numpy", "question_id": 20718}
{"snippet": "ma.MaskedArray.__setitem__(indx, value)", "intent": "x.__setitem__ ( i , y ) < == > x [ i ] =y If `value` is masked , masks those locations . With arguments `indx`. numpy", "question_id": 20719}
{"snippet": "chararray.rsplit()", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string . numpy", "question_id": 20720}
{"snippet": "chararray.rsplit(sep=None)", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string . numpy", "question_id": 20721}
{"snippet": "chararray.rsplit(maxsplit=None)", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string . With arguments `maxsplit`. numpy", "question_id": 20722}
{"snippet": "chararray.rsplit(sep=None, maxsplit=None)", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string . With arguments `maxsplit`. numpy", "question_id": 20723}
{"snippet": "char.zfill(a, width)", "intent": "Return the numeric string left-filled with zeros With arguments `a`, `width`. numpy", "question_id": 20724}
{"snippet": "numpy.save(file, arr)", "intent": "Save an array to a binary `file` in NumPy .npy format . With arguments `arr`. numpy", "question_id": 20725}
{"snippet": "numpy.save(file, arr, allow_pickle=True)", "intent": "Save an array to a binary `file` in NumPy .npy format . With arguments `arr`, `allow_pickle`. numpy", "question_id": 20726}
{"snippet": "numpy.save(file, arr, fix_imports=True)", "intent": "Save an array to a binary `file` in NumPy .npy format . With arguments `arr`, `fix_imports`. numpy", "question_id": 20727}
{"snippet": "numpy.save(file, arr, allow_pickle=True, fix_imports=True)", "intent": "Save an array to a binary `file` in NumPy .npy format . With arguments `arr`, `allow_pickle`, `fix_imports`. numpy", "question_id": 20728}
{"snippet": "matrix.flat", "intent": "A 1-D iterator over the array. numpy", "question_id": 20729}
{"snippet": "polynomial.hermite_e.hermeval3d(x, y, z, c)", "intent": "Evaluate a 3-D Hermite_e series at points ( `x` , `y` , `z` ) . In either case , either x , y , and z or their elements must support multiplication and addition both with themselves and with the elements of `c` . numpy", "question_id": 20730}
{"snippet": "random.logseries(p)", "intent": "Draw samples from a logarithmic series distribution . Samples are drawn from a log series distribution with specified shape parameter , 0 < `p` < 1 . numpy", "question_id": 20731}
{"snippet": "random.logseries(p, size=None)", "intent": "Draw samples from a logarithmic series distribution . Samples are drawn from a log series distribution with specified shape parameter , 0 < `p` < 1 . With arguments `size`. numpy", "question_id": 20732}
{"snippet": "ma.min(obj)", "intent": "Return the minimum along a given `axis` . With arguments `obj`. numpy", "question_id": 20733}
{"snippet": "ma.min(obj, axis=None)", "intent": "Return the minimum along a given `axis` . With arguments `obj`. numpy", "question_id": 20734}
{"snippet": "ma.min(obj, out=None)", "intent": "Return the minimum along a given `axis` . With arguments `obj`, `out`. numpy", "question_id": 20735}
{"snippet": "ma.min(obj, fill_value=None)", "intent": "Return the minimum along a given `axis` . With arguments `obj`, `fill_value`. numpy", "question_id": 20736}
{"snippet": "ma.min(obj, keepdims=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `obj`, `keepdims`. numpy", "question_id": 20737}
{"snippet": "ma.min(obj, axis=None, out=None)", "intent": "Return the minimum along a given `axis` . With arguments `obj`, `out`. numpy", "question_id": 20738}
{"snippet": "ma.min(obj, axis=None, fill_value=None)", "intent": "Return the minimum along a given `axis` . With arguments `obj`, `fill_value`. numpy", "question_id": 20739}
{"snippet": "ma.min(obj, axis=None, keepdims=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `obj`, `keepdims`. numpy", "question_id": 20740}
{"snippet": "ma.min(obj, out=None, fill_value=None)", "intent": "Return the minimum along a given `axis` . With arguments `obj`, `out`, `fill_value`. numpy", "question_id": 20741}
{"snippet": "ma.min(obj, out=None, keepdims=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `obj`, `out`, `keepdims`. numpy", "question_id": 20742}
{"snippet": "random.chisquare(df)", "intent": "Draw samples from a chi-square distribution . When `df` independent random variables , each with standard normal distributions ( mean 0 , variance 1 ) , are squared and summed , the resulting distribution is chi-square ( see Notes ) . numpy", "question_id": 20743}
{"snippet": "random.chisquare(df, size=None)", "intent": "Draw samples from a chi-square distribution . When `df` independent random variables , each with standard normal distributions ( mean 0 , variance 1 ) , are squared and summed , the resulting distribution is chi-square ( see Notes ) . With arguments `size`. numpy", "question_id": 20744}
{"snippet": "numpy.column_stack(tup)", "intent": "Stack 1-D arrays as columns into a 2-D array . With arguments `tup`. numpy", "question_id": 20745}
{"snippet": "ndarray.__sub__(value, /)", "intent": "Return self-value . With arguments `value`, `/`. numpy", "question_id": 20746}
{"snippet": "ma.isMA(x)", "intent": "Test whether input is an instance of MaskedArray . This function returns True if `x` is an instance of MaskedArray and returns False otherwise . numpy", "question_id": 20747}
{"snippet": "random.rayleigh()", "intent": "Draw samples from a Rayleigh distribution . numpy", "question_id": 20748}
{"snippet": "random.rayleigh(scale=1.0)", "intent": "Draw samples from a Rayleigh distribution . With arguments `scale`. numpy", "question_id": 20749}
{"snippet": "random.rayleigh(size=None)", "intent": "Draw samples from a Rayleigh distribution . With arguments `size`. numpy", "question_id": 20750}
{"snippet": "random.rayleigh(scale=1.0, size=None)", "intent": "Draw samples from a Rayleigh distribution . With arguments `scale`, `size`. numpy", "question_id": 20751}
{"snippet": "chararray.mean()", "intent": "Returns the average of the array elements along given `axis` . numpy", "question_id": 20752}
{"snippet": "chararray.mean(axis=None)", "intent": "Returns the average of the array elements along given `axis` . numpy", "question_id": 20753}
{"snippet": "chararray.mean(dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 20754}
{"snippet": "chararray.mean(out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 20755}
{"snippet": "chararray.mean(keepdims=False)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`. numpy", "question_id": 20756}
{"snippet": "chararray.mean(where=True)", "intent": "Returns the average of the array elements along given `axis` . With arguments `where`. numpy", "question_id": 20757}
{"snippet": "chararray.mean(axis=None, dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 20758}
{"snippet": "chararray.mean(axis=None, out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 20759}
{"snippet": "chararray.mean(axis=None, keepdims=False)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`. numpy", "question_id": 20760}
{"snippet": "chararray.mean(axis=None, where=True)", "intent": "Returns the average of the array elements along given `axis` . With arguments `where`. numpy", "question_id": 20761}
{"snippet": "ma.masked_array.get_fill_value()", "intent": "The filling value of the masked array is a scalar . numpy", "question_id": 20762}
{"snippet": "numpy.polynomial.legendre.Legendre(coef)", "intent": "A Legendre series class . With arguments `coef`. numpy", "question_id": 20763}
{"snippet": "numpy.polynomial.legendre.Legendre(coef, domain=None)", "intent": "A Legendre series class . With arguments `coef`, `domain`. numpy", "question_id": 20764}
{"snippet": "numpy.polynomial.legendre.Legendre(coef, window=None)", "intent": "A Legendre series class . With arguments `coef`, `window`. numpy", "question_id": 20765}
{"snippet": "numpy.polynomial.legendre.Legendre(coef, domain=None, window=None)", "intent": "A Legendre series class . With arguments `coef`, `domain`, `window`. numpy", "question_id": 20766}
{"snippet": "polynomial.legendre.legsub(c1, c2)", "intent": "Subtract one Legendre series from another . Returns the difference of two Legendre series `c1` - `c2` . numpy", "question_id": 20767}
{"snippet": "polynomial.legendre.legmulx(c)", "intent": "Multiply a Legendre series by x . Multiply the Legendre series `c` by x , where x is the independent variable . numpy", "question_id": 20768}
{"snippet": "ma.MaskType.tolist()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 20769}
{"snippet": "DataSource.exists(path)", "intent": "Test if `path` exists . numpy", "question_id": 20770}
{"snippet": "flatiter.base", "intent": "A reference to the array that is iterated over. numpy", "question_id": 20771}
{"snippet": "ma.masked_array.min()", "intent": "Return the minimum along a given `axis` . numpy", "question_id": 20772}
{"snippet": "ma.masked_array.min(axis=None)", "intent": "Return the minimum along a given `axis` . numpy", "question_id": 20773}
{"snippet": "ma.masked_array.min(out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`. numpy", "question_id": 20774}
{"snippet": "ma.masked_array.min(fill_value=None)", "intent": "Return the minimum along a given `axis` . With arguments `fill_value`. numpy", "question_id": 20775}
{"snippet": "ma.masked_array.min(keepdims=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 20776}
{"snippet": "ma.masked_array.min(axis=None, out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`. numpy", "question_id": 20777}
{"snippet": "ma.masked_array.min(axis=None, fill_value=None)", "intent": "Return the minimum along a given `axis` . With arguments `fill_value`. numpy", "question_id": 20778}
{"snippet": "ma.masked_array.min(axis=None, keepdims=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 20779}
{"snippet": "ma.masked_array.min(out=None, fill_value=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`, `fill_value`. numpy", "question_id": 20780}
{"snippet": "ma.masked_array.min(out=None, keepdims=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `out`, `keepdims`. numpy", "question_id": 20781}
{"snippet": "random.Generator.pareto(a)", "intent": "Draw samples from `a` Pareto II or Lomax distribution with specified shape . numpy", "question_id": 20782}
{"snippet": "random.Generator.pareto(a, size=None)", "intent": "Draw samples from `a` Pareto II or Lomax distribution with specified shape . With arguments `size`. numpy", "question_id": 20783}
{"snippet": "ma.MaskType.argmax()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 20784}
{"snippet": "char.chararray.rstrip()", "intent": "For each element in self , return a copy with the trailing characters removed . numpy", "question_id": 20785}
{"snippet": "char.chararray.rstrip(chars=None)", "intent": "For each element in self , return a copy with the trailing characters removed . With arguments `chars`. numpy", "question_id": 20786}
{"snippet": "recarray.byteswap()", "intent": "Swap the bytes of the array elements numpy", "question_id": 20787}
{"snippet": "recarray.byteswap(inplace=False)", "intent": "Swap the bytes of the array elements With arguments `inplace`. numpy", "question_id": 20788}
{"snippet": "ndarray.__truediv__(value, /)", "intent": "Return self/value . With arguments `value`, `/`. numpy", "question_id": 20789}
{"snippet": "matrix.ctypes", "intent": "An object to simplify the interaction of the array with the ctypes module. numpy", "question_id": 20790}
{"snippet": "_ctypes.data", "intent": "A pointer to the memory area of the array as a Python integer. numpy", "question_id": 20791}
{"snippet": "_ctypes.shape", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the C-integer corresponding to dtype('p') on this platform. numpy", "question_id": 20792}
{"snippet": "_ctypes.strides", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the same as for the shape attribute. numpy", "question_id": 20793}
{"snippet": "_ctypes.data_as(obj)", "intent": "Return the data pointer cast to a particular c-types object . With arguments `obj`. numpy", "question_id": 20794}
{"snippet": "_ctypes.shape_as(obj)", "intent": "Return the shape tuple as an array of some other c-types type . With arguments `obj`. numpy", "question_id": 20795}
{"snippet": "_ctypes.strides_as(obj)", "intent": "Return the strides tuple as an array of some other c-types type . With arguments `obj`. numpy", "question_id": 20796}
{"snippet": "ma.atleast_2d(*args, **kwargs)", "intent": "View inputs as arrays with at least two dimensions . With arguments `*args`, `**kwargs`. numpy", "question_id": 20797}
{"snippet": "ma.masked_array.mini()", "intent": "Return the array minimum along the specified `axis` . numpy", "question_id": 20798}
{"snippet": "ma.masked_array.mini(axis=None)", "intent": "Return the array minimum along the specified `axis` . numpy", "question_id": 20799}
{"snippet": "numpy.seterrobj(errobj)", "intent": "Set the object that defines floating-point error handling . With arguments `errobj`. numpy", "question_id": 20800}
{"snippet": "char.chararray.decode()", "intent": "Calls str.decode element-wise . numpy", "question_id": 20801}
{"snippet": "char.chararray.decode(encoding=None)", "intent": "Calls str.decode element-wise . With arguments `encoding`. numpy", "question_id": 20802}
{"snippet": "char.chararray.decode(errors=None)", "intent": "Calls str.decode element-wise . With arguments `errors`. numpy", "question_id": 20803}
{"snippet": "char.chararray.decode(encoding=None, errors=None)", "intent": "Calls str.decode element-wise . With arguments `encoding`, `errors`. numpy", "question_id": 20804}
{"snippet": "random.bytes(length)", "intent": "Return random bytes . With arguments `length`. numpy", "question_id": 20805}
{"snippet": "polynomial.polynomial.Polynomial.convert()", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 20806}
{"snippet": "polynomial.polynomial.Polynomial.convert(domain=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 20807}
{"snippet": "polynomial.polynomial.Polynomial.convert(kind=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 20808}
{"snippet": "polynomial.polynomial.Polynomial.convert(window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 20809}
{"snippet": "polynomial.polynomial.Polynomial.convert(domain=None, kind=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 20810}
{"snippet": "polynomial.polynomial.Polynomial.convert(domain=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 20811}
{"snippet": "polynomial.polynomial.Polynomial.convert(kind=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 20812}
{"snippet": "polynomial.polynomial.Polynomial.convert(domain=None, kind=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 20813}
{"snippet": "ndarray.diagonal()", "intent": "Return specified diagonals . numpy", "question_id": 20814}
{"snippet": "ndarray.diagonal(offset=0)", "intent": "Return specified diagonals . With arguments `offset`. numpy", "question_id": 20815}
{"snippet": "ndarray.diagonal(axis1=0)", "intent": "Return specified diagonals . With arguments `axis1`. numpy", "question_id": 20816}
{"snippet": "ndarray.diagonal(axis2=1)", "intent": "Return specified diagonals . With arguments `axis2`. numpy", "question_id": 20817}
{"snippet": "ndarray.diagonal(offset=0, axis1=0)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`. numpy", "question_id": 20818}
{"snippet": "ndarray.diagonal(offset=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis2`. numpy", "question_id": 20819}
{"snippet": "ndarray.diagonal(axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `axis1`, `axis2`. numpy", "question_id": 20820}
{"snippet": "ndarray.diagonal(offset=0, axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`, `axis2`. numpy", "question_id": 20821}
{"snippet": "numpy.sctype2char(sctype)", "intent": "Return the string representation of a scalar dtype . With arguments `sctype`. numpy", "question_id": 20822}
{"snippet": "polynomial.polynomial.Polynomial.degree()", "intent": "The degree of the series . numpy", "question_id": 20823}
{"snippet": "chararray.lstrip()", "intent": "For each element in self , return a copy with the leading characters removed . numpy", "question_id": 20824}
{"snippet": "chararray.lstrip(chars=None)", "intent": "For each element in self , return a copy with the leading characters removed . With arguments `chars`. numpy", "question_id": 20825}
{"snippet": "ndarray.__reduce__()", "intent": "For pickling . numpy", "question_id": 20826}
{"snippet": "broadcast.shape", "intent": "Shape of broadcasted result. numpy", "question_id": 20827}
{"snippet": "nditer.iternext()", "intent": "Check whether iterations are left , and perform a single internal iteration without returning the result . numpy", "question_id": 20828}
{"snippet": "ma.clump_masked(a)", "intent": "Returns `a` list of slices corresponding to the masked clumps of a 1-D array . numpy", "question_id": 20829}
{"snippet": "numpy.convolve(a, v)", "intent": "Returns the discrete , linear convolution of two one-dimensional sequences . The convolution operator is often seen in signal processing , where it models the effect of `a` linear time-invariant system on a signal [ 1 ] . If `v` is longer than a , the arrays are swapped before computation . numpy", "question_id": 20830}
{"snippet": "numpy.convolve(a, v, mode='full')", "intent": "Returns the discrete , linear convolution of two one-dimensional sequences . The convolution operator is often seen in signal processing , where it models the effect of `a` linear time-invariant system on a signal [ 1 ] . If `v` is longer than a , the arrays are swapped before computation . With arguments `mode`. numpy", "question_id": 20831}
{"snippet": "numpy.conj(x, /, signature, extobj)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`. numpy", "question_id": 20832}
{"snippet": "numpy.conj(x, /, signature, extobj, out=None)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 20833}
{"snippet": "numpy.conj(x, /, signature, extobj, where=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `where`. numpy", "question_id": 20834}
{"snippet": "numpy.conj(x, /, signature, extobj, casting='same_kind')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 20835}
{"snippet": "numpy.conj(x, /, signature, extobj, order='K')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 20836}
{"snippet": "numpy.conj(x, /, signature, extobj, dtype=None)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 20837}
{"snippet": "numpy.conj(x, /, signature, extobj, subok=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 20838}
{"snippet": "numpy.conj(x, /, signature, extobj, out=None, where=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 20839}
{"snippet": "numpy.conj(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 20840}
{"snippet": "numpy.conj(x, /, signature, extobj, out=None, order='K')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 20841}
{"snippet": "numpy.conj(x, /, signature)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`. numpy", "question_id": 20842}
{"snippet": "numpy.conj(x, /, signature, out=None)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `out`. numpy", "question_id": 20843}
{"snippet": "numpy.conj(x, /, signature, where=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `where`. numpy", "question_id": 20844}
{"snippet": "numpy.conj(x, /, signature, casting='same_kind')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `casting`. numpy", "question_id": 20845}
{"snippet": "numpy.conj(x, /, signature, order='K')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `order`. numpy", "question_id": 20846}
{"snippet": "numpy.conj(x, /, signature, dtype=None)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `dtype`. numpy", "question_id": 20847}
{"snippet": "numpy.conj(x, /, signature, subok=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `subok`. numpy", "question_id": 20848}
{"snippet": "numpy.conj(x, /, signature, out=None, where=True)", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `out`, `where`. numpy", "question_id": 20849}
{"snippet": "numpy.conj(x, /, signature, out=None, casting='same_kind')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `out`, `casting`. numpy", "question_id": 20850}
{"snippet": "numpy.conj(x, /, signature, out=None, order='K')", "intent": "Return the complex conjugate , element-wise . With arguments `x`, `/`, `signature`, `out`, `order`. numpy", "question_id": 20851}
{"snippet": "polynomial.polynomial.Polynomial.__call__(arg)", "intent": "Call self as a function . With arguments `arg`. numpy", "question_id": 20852}
{"snippet": "nditer.reset()", "intent": "Reset the iterator to its initial state . numpy", "question_id": 20853}
{"snippet": "polynomial.polynomial.Polynomial.fromroots(roots)", "intent": "Return series instance that has the specified `roots` . numpy", "question_id": 20854}
{"snippet": "polynomial.polynomial.Polynomial.fromroots(roots, domain=)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`. numpy", "question_id": 20855}
{"snippet": "polynomial.polynomial.Polynomial.fromroots(roots, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `window`. numpy", "question_id": 20856}
{"snippet": "polynomial.polynomial.Polynomial.fromroots(roots, domain=, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`, `window`. numpy", "question_id": 20857}
{"snippet": "polynomial.polynomial.Polynomial.fromroots()", "intent": "Return series instance that has the specified `roots` . numpy", "question_id": 20858}
{"snippet": "polynomial.polynomial.Polynomial.fromroots(domain=)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`. numpy", "question_id": 20859}
{"snippet": "polynomial.polynomial.Polynomial.fromroots(window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `window`. numpy", "question_id": 20860}
{"snippet": "polynomial.polynomial.Polynomial.fromroots(domain=, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`, `window`. numpy", "question_id": 20861}
{"snippet": "numpy.fabs(x, /, signature, extobj)", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 20862}
{"snippet": "numpy.fabs(x, /, signature, extobj, out=None)", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 20863}
{"snippet": "numpy.fabs(x, /, signature, extobj, where=True)", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 20864}
{"snippet": "numpy.fabs(x, /, signature, extobj, casting='same_kind')", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 20865}
{"snippet": "numpy.fabs(x, /, signature, extobj, order='K')", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 20866}
{"snippet": "numpy.fabs(x, /, signature, extobj, dtype=None)", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 20867}
{"snippet": "numpy.fabs(x, /, signature, extobj, subok=True)", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 20868}
{"snippet": "numpy.fabs(x, /, signature, extobj, out=None, where=True)", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 20869}
{"snippet": "numpy.fabs(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 20870}
{"snippet": "numpy.fabs(x, /, signature, extobj, out=None, order='K')", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 20871}
{"snippet": "numpy.fabs(x, /, signature)", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`. numpy", "question_id": 20872}
{"snippet": "numpy.fabs(x, /, signature, out=None)", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `out`. numpy", "question_id": 20873}
{"snippet": "numpy.fabs(x, /, signature, where=True)", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `where`. numpy", "question_id": 20874}
{"snippet": "numpy.fabs(x, /, signature, casting='same_kind')", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `casting`. numpy", "question_id": 20875}
{"snippet": "numpy.fabs(x, /, signature, order='K')", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `order`. numpy", "question_id": 20876}
{"snippet": "numpy.fabs(x, /, signature, dtype=None)", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 20877}
{"snippet": "numpy.fabs(x, /, signature, subok=True)", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `subok`. numpy", "question_id": 20878}
{"snippet": "numpy.fabs(x, /, signature, out=None, where=True)", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 20879}
{"snippet": "numpy.fabs(x, /, signature, out=None, casting='same_kind')", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 20880}
{"snippet": "numpy.fabs(x, /, signature, out=None, order='K')", "intent": "Compute the absolute values element-wise . This function returns the absolute values ( positive magnitude ) of the data in `x` . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 20881}
{"snippet": "dtype.byteorder", "intent": "A character indicating the byte-order of this data-type object. numpy", "question_id": 20882}
{"snippet": "numpy.histogram(a)", "intent": "Compute the histogram of `a` dataset . numpy", "question_id": 20883}
{"snippet": "numpy.histogram(a, bins=10)", "intent": "Compute the histogram of `a` dataset . In other words , if `bins` is : numpy", "question_id": 20884}
{"snippet": "numpy.histogram(a, range=None)", "intent": "Compute the histogram of `a` dataset . With arguments `range`. numpy", "question_id": 20885}
{"snippet": "numpy.histogram(a, normed=None)", "intent": "Compute the histogram of `a` dataset . With arguments `normed`. numpy", "question_id": 20886}
{"snippet": "numpy.histogram(a, weights=None)", "intent": "Compute the histogram of `a` dataset . With arguments `weights`. numpy", "question_id": 20887}
{"snippet": "numpy.histogram(a, density=None)", "intent": "Compute the histogram of `a` dataset . With arguments `density`. numpy", "question_id": 20888}
{"snippet": "numpy.histogram(a, bins=10, range=None)", "intent": "Compute the histogram of `a` dataset . In other words , if `bins` is : With arguments `range`. numpy", "question_id": 20889}
{"snippet": "numpy.histogram(a, bins=10, normed=None)", "intent": "Compute the histogram of `a` dataset . In other words , if `bins` is : With arguments `normed`. numpy", "question_id": 20890}
{"snippet": "numpy.histogram(a, bins=10, weights=None)", "intent": "Compute the histogram of `a` dataset . In other words , if `bins` is : With arguments `weights`. numpy", "question_id": 20891}
{"snippet": "numpy.histogram(a, bins=10, density=None)", "intent": "Compute the histogram of `a` dataset . In other words , if `bins` is : With arguments `density`. numpy", "question_id": 20892}
{"snippet": "numpy.histogramdd(sample)", "intent": "Compute the multidimensional histogram of some data . With arguments `sample`. numpy", "question_id": 20893}
{"snippet": "numpy.histogramdd(sample, bins=10)", "intent": "Compute the multidimensional histogram of some data . With arguments `sample`, `bins`. numpy", "question_id": 20894}
{"snippet": "numpy.histogramdd(sample, range=None)", "intent": "Compute the multidimensional histogram of some data . With arguments `sample`, `range`. numpy", "question_id": 20895}
{"snippet": "numpy.histogramdd(sample, normed=None)", "intent": "Compute the multidimensional histogram of some data . With arguments `sample`, `normed`. numpy", "question_id": 20896}
{"snippet": "numpy.histogramdd(sample, weights=None)", "intent": "Compute the multidimensional histogram of some data . With arguments `sample`, `weights`. numpy", "question_id": 20897}
{"snippet": "numpy.histogramdd(sample, density=None)", "intent": "Compute the multidimensional histogram of some data . With arguments `sample`, `density`. numpy", "question_id": 20898}
{"snippet": "numpy.histogramdd(sample, bins=10, range=None)", "intent": "Compute the multidimensional histogram of some data . With arguments `sample`, `bins`, `range`. numpy", "question_id": 20899}
{"snippet": "numpy.histogramdd(sample, bins=10, normed=None)", "intent": "Compute the multidimensional histogram of some data . With arguments `sample`, `bins`, `normed`. numpy", "question_id": 20900}
{"snippet": "numpy.histogramdd(sample, bins=10, weights=None)", "intent": "Compute the multidimensional histogram of some data . With arguments `sample`, `bins`, `weights`. numpy", "question_id": 20901}
{"snippet": "numpy.histogramdd(sample, bins=10, density=None)", "intent": "Compute the multidimensional histogram of some data . With arguments `sample`, `bins`, `density`. numpy", "question_id": 20902}
{"snippet": "numpy.unique(ar)", "intent": "Find the unique elements of an array . With arguments `ar`. numpy", "question_id": 20903}
{"snippet": "numpy.unique(ar, return_index=False)", "intent": "Find the unique elements of an array . With arguments `ar`, `return_index`. numpy", "question_id": 20904}
{"snippet": "numpy.unique(ar, return_inverse=False)", "intent": "Find the unique elements of an array . With arguments `ar`, `return_inverse`. numpy", "question_id": 20905}
{"snippet": "numpy.unique(ar, return_counts=False)", "intent": "Find the unique elements of an array . With arguments `ar`, `return_counts`. numpy", "question_id": 20906}
{"snippet": "numpy.unique(ar, axis=None)", "intent": "Find the unique elements of an array . When an `axis` is specified the subarrays indexed by the axis are sorted . With arguments `ar`. numpy", "question_id": 20907}
{"snippet": "numpy.unique(ar, return_index=False, return_inverse=False)", "intent": "Find the unique elements of an array . With arguments `ar`, `return_index`, `return_inverse`. numpy", "question_id": 20908}
{"snippet": "numpy.unique(ar, return_index=False, return_counts=False)", "intent": "Find the unique elements of an array . With arguments `ar`, `return_index`, `return_counts`. numpy", "question_id": 20909}
{"snippet": "numpy.unique(ar, return_index=False, axis=None)", "intent": "Find the unique elements of an array . When an `axis` is specified the subarrays indexed by the axis are sorted . With arguments `ar`, `return_index`. numpy", "question_id": 20910}
{"snippet": "numpy.unique(ar, return_inverse=False, return_counts=False)", "intent": "Find the unique elements of an array . With arguments `ar`, `return_inverse`, `return_counts`. numpy", "question_id": 20911}
{"snippet": "numpy.unique(ar, return_inverse=False, axis=None)", "intent": "Find the unique elements of an array . When an `axis` is specified the subarrays indexed by the axis are sorted . With arguments `ar`, `return_inverse`. numpy", "question_id": 20912}
{"snippet": "ma.MaskedArray.soften_mask()", "intent": "Force the mask to soft . numpy", "question_id": 20913}
{"snippet": "numpy.triu_indices(n)", "intent": "Return the indices for the upper-triangle of an ( `n` , `m` ) array . numpy", "question_id": 20914}
{"snippet": "numpy.triu_indices(n, k=0)", "intent": "Return the indices for the upper-triangle of an ( `n` , `m` ) array . With arguments `k`. numpy", "question_id": 20915}
{"snippet": "numpy.triu_indices(n, m=None)", "intent": "Return the indices for the upper-triangle of an ( `n` , `m` ) array . numpy", "question_id": 20916}
{"snippet": "numpy.triu_indices(n, k=0, m=None)", "intent": "Return the indices for the upper-triangle of an ( `n` , `m` ) array . With arguments `k`. numpy", "question_id": 20917}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.cpu_dispatch_names()", "intent": "return a list of final CPU dispatch feature names numpy", "question_id": 20918}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.cc_normalize_flags(flags)", "intent": "Remove the conflicts that caused due gathering implied features `flags` . numpy", "question_id": 20919}
{"snippet": "numpy.less(x1, x2, /, signature, extobj)", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 20920}
{"snippet": "numpy.less(x1, x2, /, signature, extobj, out=None)", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 20921}
{"snippet": "numpy.less(x1, x2, /, signature, extobj, where=True)", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 20922}
{"snippet": "numpy.less(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 20923}
{"snippet": "numpy.less(x1, x2, /, signature, extobj, order='K')", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 20924}
{"snippet": "numpy.less(x1, x2, /, signature, extobj, dtype=None)", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 20925}
{"snippet": "numpy.less(x1, x2, /, signature, extobj, subok=True)", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 20926}
{"snippet": "numpy.less(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 20927}
{"snippet": "numpy.less(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 20928}
{"snippet": "numpy.less(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 20929}
{"snippet": "numpy.less(x1, x2, /, signature)", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`. numpy", "question_id": 20930}
{"snippet": "numpy.less(x1, x2, /, signature, out=None)", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `out`. numpy", "question_id": 20931}
{"snippet": "numpy.less(x1, x2, /, signature, where=True)", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `where`. numpy", "question_id": 20932}
{"snippet": "numpy.less(x1, x2, /, signature, casting='same_kind')", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `casting`. numpy", "question_id": 20933}
{"snippet": "numpy.less(x1, x2, /, signature, order='K')", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `order`. numpy", "question_id": 20934}
{"snippet": "numpy.less(x1, x2, /, signature, dtype=None)", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 20935}
{"snippet": "numpy.less(x1, x2, /, signature, subok=True)", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `subok`. numpy", "question_id": 20936}
{"snippet": "numpy.less(x1, x2, /, signature, out=None, where=True)", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 20937}
{"snippet": "numpy.less(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 20938}
{"snippet": "numpy.less(x1, x2, /, signature, out=None, order='K')", "intent": "Return the truth value of ( `x1` < `x2` ) element-wise . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 20939}
{"snippet": "numpy.take(a, indices)", "intent": "Take elements from an array along an `axis` . When axis is not None , this function does the same thing as \u201c fancy \u201d indexing ( indexing arrays using arrays ) ; however , it can be easier to use if you need elements along `a` given axis . A call such as np.take ( arr , `indices` , axis=3 ) is equivalent to arr [ : , : , : ,indices , ... ] . numpy", "question_id": 20940}
{"snippet": "numpy.take(a, indices, axis=None)", "intent": "Take elements from an array along an `axis` . When axis is not None , this function does the same thing as \u201c fancy \u201d indexing ( indexing arrays using arrays ) ; however , it can be easier to use if you need elements along `a` given axis . A call such as np.take ( arr , `indices` , axis=3 ) is equivalent to arr [ : , : , : ,indices , ... ] . numpy", "question_id": 20941}
{"snippet": "numpy.take(a, indices, out=None)", "intent": "Take elements from an array along an `axis` . When axis is not None , this function does the same thing as \u201c fancy \u201d indexing ( indexing arrays using arrays ) ; however , it can be easier to use if you need elements along `a` given axis . A call such as np.take ( arr , `indices` , axis=3 ) is equivalent to arr [ : , : , : ,indices , ... ] . With arguments `out`. numpy", "question_id": 20942}
{"snippet": "numpy.take(a, indices, mode='raise')", "intent": "Take elements from an array along an `axis` . When axis is not None , this function does the same thing as \u201c fancy \u201d indexing ( indexing arrays using arrays ) ; however , it can be easier to use if you need elements along `a` given axis . A call such as np.take ( arr , `indices` , axis=3 ) is equivalent to arr [ : , : , : ,indices , ... ] . With arguments `mode`. numpy", "question_id": 20943}
{"snippet": "numpy.take(a, indices, axis=None, out=None)", "intent": "Take elements from an array along an `axis` . When axis is not None , this function does the same thing as \u201c fancy \u201d indexing ( indexing arrays using arrays ) ; however , it can be easier to use if you need elements along `a` given axis . A call such as np.take ( arr , `indices` , axis=3 ) is equivalent to arr [ : , : , : ,indices , ... ] . With arguments `out`. numpy", "question_id": 20944}
{"snippet": "numpy.take(a, indices, axis=None, mode='raise')", "intent": "Take elements from an array along an `axis` . When axis is not None , this function does the same thing as \u201c fancy \u201d indexing ( indexing arrays using arrays ) ; however , it can be easier to use if you need elements along `a` given axis . A call such as np.take ( arr , `indices` , axis=3 ) is equivalent to arr [ : , : , : ,indices , ... ] . With arguments `mode`. numpy", "question_id": 20945}
{"snippet": "numpy.take(a, indices, out=None, mode='raise')", "intent": "Take elements from an array along an `axis` . When axis is not None , this function does the same thing as \u201c fancy \u201d indexing ( indexing arrays using arrays ) ; however , it can be easier to use if you need elements along `a` given axis . A call such as np.take ( arr , `indices` , axis=3 ) is equivalent to arr [ : , : , : ,indices , ... ] . With arguments `out`, `mode`. numpy", "question_id": 20946}
{"snippet": "numpy.take(a, indices, axis=None, out=None, mode='raise')", "intent": "Take elements from an array along an `axis` . When axis is not None , this function does the same thing as \u201c fancy \u201d indexing ( indexing arrays using arrays ) ; however , it can be easier to use if you need elements along `a` given axis . A call such as np.take ( arr , `indices` , axis=3 ) is equivalent to arr [ : , : , : ,indices , ... ] . With arguments `out`, `mode`. numpy", "question_id": 20947}
{"snippet": "testing.dec.skipif(skip_condition)", "intent": "Make function raise SkipTest exception if a given condition is true . With arguments `skip_condition`. numpy", "question_id": 20948}
{"snippet": "testing.dec.skipif(skip_condition, msg=None)", "intent": "Make function raise SkipTest exception if a given condition is true . With arguments `skip_condition`, `msg`. numpy", "question_id": 20949}
{"snippet": "numpy.absolute(x, /, signature, extobj)", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `extobj`. numpy", "question_id": 20950}
{"snippet": "numpy.absolute(x, /, signature, extobj, out=None)", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 20951}
{"snippet": "numpy.absolute(x, /, signature, extobj, where=True)", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `extobj`, `where`. numpy", "question_id": 20952}
{"snippet": "numpy.absolute(x, /, signature, extobj, casting='same_kind')", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 20953}
{"snippet": "numpy.absolute(x, /, signature, extobj, order='K')", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 20954}
{"snippet": "numpy.absolute(x, /, signature, extobj, dtype=None)", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 20955}
{"snippet": "numpy.absolute(x, /, signature, extobj, subok=True)", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 20956}
{"snippet": "numpy.absolute(x, /, signature, extobj, out=None, where=True)", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 20957}
{"snippet": "numpy.absolute(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 20958}
{"snippet": "numpy.absolute(x, /, signature, extobj, out=None, order='K')", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 20959}
{"snippet": "numpy.absolute(x, /, signature)", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`. numpy", "question_id": 20960}
{"snippet": "numpy.absolute(x, /, signature, out=None)", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `out`. numpy", "question_id": 20961}
{"snippet": "numpy.absolute(x, /, signature, where=True)", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `where`. numpy", "question_id": 20962}
{"snippet": "numpy.absolute(x, /, signature, casting='same_kind')", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `casting`. numpy", "question_id": 20963}
{"snippet": "numpy.absolute(x, /, signature, order='K')", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `order`. numpy", "question_id": 20964}
{"snippet": "numpy.absolute(x, /, signature, dtype=None)", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `dtype`. numpy", "question_id": 20965}
{"snippet": "numpy.absolute(x, /, signature, subok=True)", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `subok`. numpy", "question_id": 20966}
{"snippet": "numpy.absolute(x, /, signature, out=None, where=True)", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `out`, `where`. numpy", "question_id": 20967}
{"snippet": "numpy.absolute(x, /, signature, out=None, casting='same_kind')", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `out`, `casting`. numpy", "question_id": 20968}
{"snippet": "numpy.absolute(x, /, signature, out=None, order='K')", "intent": "Calculate the absolute value element-wise . With arguments `x`, `/`, `signature`, `out`, `order`. numpy", "question_id": 20969}
{"snippet": "recarray.squeeze()", "intent": "Remove axes of length one from a . numpy", "question_id": 20970}
{"snippet": "recarray.squeeze(axis=None)", "intent": "Remove axes of length one from a . With arguments `axis`. numpy", "question_id": 20971}
{"snippet": "numpy.put_along_axis(arr, indices, values, axis)", "intent": "Put `values` into the destination array by matching 1d index and data slices . Functions returning an index along an axis , like argsort and argpartition , produce suitable `indices` for this function . This iterates over matching 1d slices oriented along the specified `axis` in the index and data arrays , and uses the former to place values into the latter . With arguments `arr`. numpy", "question_id": 20972}
{"snippet": "polynomial.legendre.legint(c)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 20973}
{"snippet": "polynomial.legendre.legint(c, m=1)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 20974}
{"snippet": "polynomial.legendre.legint(c, k=)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 20975}
{"snippet": "polynomial.legendre.legint(c, lbnd=0)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 20976}
{"snippet": "polynomial.legendre.legint(c, scl=1)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 20977}
{"snippet": "polynomial.legendre.legint(c, axis=0)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 20978}
{"snippet": "polynomial.legendre.legint(c, m=1, k=)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 20979}
{"snippet": "polynomial.legendre.legint(c, m=1, lbnd=0)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 20980}
{"snippet": "polynomial.legendre.legint(c, m=1, scl=1)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 20981}
{"snippet": "polynomial.legendre.legint(c, m=1, axis=0)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 20982}
{"snippet": "polynomial.legendre.legint()", "intent": "Integrate a Legendre series . numpy", "question_id": 20983}
{"snippet": "polynomial.legendre.legint(m=1)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 20984}
{"snippet": "polynomial.legendre.legint(k=)", "intent": "Integrate a Legendre series . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 20985}
{"snippet": "polynomial.legendre.legint(lbnd=0)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 20986}
{"snippet": "polynomial.legendre.legint(scl=1)", "intent": "Integrate a Legendre series . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 20987}
{"snippet": "polynomial.legendre.legint(axis=0)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 20988}
{"snippet": "polynomial.legendre.legint(m=1, k=)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 20989}
{"snippet": "polynomial.legendre.legint(m=1, lbnd=0)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 20990}
{"snippet": "polynomial.legendre.legint(m=1, scl=1)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 20991}
{"snippet": "polynomial.legendre.legint(m=1, axis=0)", "intent": "Integrate a Legendre series . Returns the Legendre series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 20992}
{"snippet": "polynomial.legendre.legfit(x, y, deg)", "intent": "Least squares fit of Legendre series to data . Return the coefficients of a Legendre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . numpy", "question_id": 20993}
{"snippet": "polynomial.legendre.legfit(x, y, deg, rcond=None)", "intent": "Least squares fit of Legendre series to data . Return the coefficients of a Legendre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . numpy", "question_id": 20994}
{"snippet": "polynomial.legendre.legfit(x, y, deg, full=False)", "intent": "Least squares fit of Legendre series to data . Return the coefficients of a Legendre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . With arguments `full`. numpy", "question_id": 20995}
{"snippet": "polynomial.legendre.legfit(x, y, deg, w=None)", "intent": "Least squares fit of Legendre series to data . Return the coefficients of a Legendre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values . numpy", "question_id": 20996}
{"snippet": "polynomial.legendre.legfit(x, y, deg, rcond=None, full=False)", "intent": "Least squares fit of Legendre series to data . Return the coefficients of a Legendre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . With arguments `full`. numpy", "question_id": 20997}
{"snippet": "polynomial.legendre.legfit(x, y, deg, rcond=None, w=None)", "intent": "Least squares fit of Legendre series to data . Return the coefficients of a Legendre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values . numpy", "question_id": 20998}
{"snippet": "polynomial.legendre.legfit(x, y, deg, full=False, w=None)", "intent": "Least squares fit of Legendre series to data . Return the coefficients of a Legendre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values . With arguments `full`. numpy", "question_id": 20999}
{"snippet": "polynomial.legendre.legfit(x, y, deg, rcond=None, full=False, w=None)", "intent": "Least squares fit of Legendre series to data . Return the coefficients of a Legendre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values . With arguments `full`. numpy", "question_id": 21000}
{"snippet": "numpy.distutils.core.Extension(name, sources)", "intent": "Methods With arguments `name`, `sources`. numpy", "question_id": 21001}
{"snippet": "numpy.distutils.core.Extension(name, sources, include_dirs=None)", "intent": "Methods With arguments `name`, `sources`, `include_dirs`. numpy", "question_id": 21002}
{"snippet": "numpy.distutils.core.Extension(name, sources, define_macros=None)", "intent": "Methods With arguments `name`, `sources`, `define_macros`. numpy", "question_id": 21003}
{"snippet": "numpy.distutils.core.Extension(name, sources, undef_macros=None)", "intent": "Methods With arguments `name`, `sources`, `undef_macros`. numpy", "question_id": 21004}
{"snippet": "numpy.distutils.core.Extension(name, sources, library_dirs=None)", "intent": "Methods With arguments `name`, `sources`, `library_dirs`. numpy", "question_id": 21005}
{"snippet": "numpy.distutils.core.Extension(name, sources, libraries=None)", "intent": "Methods With arguments `name`, `sources`, `libraries`. numpy", "question_id": 21006}
{"snippet": "numpy.distutils.core.Extension(name, sources, runtime_library_dirs=None)", "intent": "Methods With arguments `name`, `sources`, `runtime_library_dirs`. numpy", "question_id": 21007}
{"snippet": "numpy.distutils.core.Extension(name, sources, extra_objects=None)", "intent": "Methods With arguments `name`, `sources`, `extra_objects`. numpy", "question_id": 21008}
{"snippet": "numpy.distutils.core.Extension(name, sources, extra_compile_args=None)", "intent": "Methods With arguments `name`, `sources`, `extra_compile_args`. numpy", "question_id": 21009}
{"snippet": "numpy.distutils.core.Extension(name, sources, extra_link_args=None)", "intent": "Methods With arguments `name`, `sources`, `extra_link_args`. numpy", "question_id": 21010}
{"snippet": "matrix.argpartition(kth)", "intent": "Returns the indices that would partition this array . With arguments `kth`. numpy", "question_id": 21011}
{"snippet": "matrix.argpartition(kth, axis=- 1)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`. numpy", "question_id": 21012}
{"snippet": "matrix.argpartition(kth, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`. numpy", "question_id": 21013}
{"snippet": "matrix.argpartition(kth, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `order`. numpy", "question_id": 21014}
{"snippet": "matrix.argpartition(kth, axis=- 1, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`. numpy", "question_id": 21015}
{"snippet": "matrix.argpartition(kth, axis=- 1, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `order`. numpy", "question_id": 21016}
{"snippet": "matrix.argpartition(kth, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`, `order`. numpy", "question_id": 21017}
{"snippet": "matrix.argpartition(kth, axis=- 1, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`, `order`. numpy", "question_id": 21018}
{"snippet": "numpy.corrcoef(x)", "intent": "Return Pearson product-moment correlation coefficients . With arguments `x`. numpy", "question_id": 21019}
{"snippet": "numpy.corrcoef(x, y=None)", "intent": "Return Pearson product-moment correlation coefficients . With arguments `x`, `y`. numpy", "question_id": 21020}
{"snippet": "numpy.corrcoef(x, rowvar=True)", "intent": "Return Pearson product-moment correlation coefficients . In this example we generate two random arrays , xarr and yarr , and compute the row-wise and column-wise Pearson correlation coefficients , R. Since `rowvar` is true by default , we first find the row-wise Pearson correlation coefficients between the variables of xarr . With arguments `x`. numpy", "question_id": 21021}
{"snippet": "numpy.corrcoef(x, bias=<no value>)", "intent": "Return Pearson product-moment correlation coefficients . This function accepts but discards arguments `bias` and `ddof` . With arguments `x`. numpy", "question_id": 21022}
{"snippet": "numpy.corrcoef(x, ddof=<no value>)", "intent": "Return Pearson product-moment correlation coefficients . This function accepts but discards arguments `bias` and `ddof` . With arguments `x`. numpy", "question_id": 21023}
{"snippet": "numpy.corrcoef(x, dtype=None)", "intent": "Return Pearson product-moment correlation coefficients . With arguments `x`, `dtype`. numpy", "question_id": 21024}
{"snippet": "numpy.corrcoef(x, y=None, rowvar=True)", "intent": "Return Pearson product-moment correlation coefficients . In this example we generate two random arrays , xarr and yarr , and compute the row-wise and column-wise Pearson correlation coefficients , R. Since `rowvar` is true by default , we first find the row-wise Pearson correlation coefficients between the variables of xarr . With arguments `x`, `y`. numpy", "question_id": 21025}
{"snippet": "numpy.corrcoef(x, y=None, bias=<no value>)", "intent": "Return Pearson product-moment correlation coefficients . This function accepts but discards arguments `bias` and `ddof` . With arguments `x`, `y`. numpy", "question_id": 21026}
{"snippet": "numpy.corrcoef(x, y=None, ddof=<no value>)", "intent": "Return Pearson product-moment correlation coefficients . This function accepts but discards arguments `bias` and `ddof` . With arguments `x`, `y`. numpy", "question_id": 21027}
{"snippet": "numpy.corrcoef(x, y=None, dtype=None)", "intent": "Return Pearson product-moment correlation coefficients . With arguments `x`, `y`, `dtype`. numpy", "question_id": 21028}
{"snippet": "chararray.all()", "intent": "Returns True if all elements evaluate to True . numpy", "question_id": 21029}
{"snippet": "chararray.all(axis=None)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`. numpy", "question_id": 21030}
{"snippet": "chararray.all(out=None)", "intent": "Returns True if all elements evaluate to True . With arguments `out`. numpy", "question_id": 21031}
{"snippet": "chararray.all(keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `keepdims`. numpy", "question_id": 21032}
{"snippet": "chararray.all(where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `where`. numpy", "question_id": 21033}
{"snippet": "chararray.all(axis=None, out=None)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `out`. numpy", "question_id": 21034}
{"snippet": "chararray.all(axis=None, keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `keepdims`. numpy", "question_id": 21035}
{"snippet": "chararray.all(axis=None, where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `where`. numpy", "question_id": 21036}
{"snippet": "chararray.all(out=None, keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `out`, `keepdims`. numpy", "question_id": 21037}
{"snippet": "chararray.all(out=None, where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `out`, `where`. numpy", "question_id": 21038}
{"snippet": "ma.MaskType.reshape()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 21039}
{"snippet": "memmap.nbytes", "intent": "Total bytes consumed by the elements of the array. numpy", "question_id": 21040}
{"snippet": "record.astype()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 21041}
{"snippet": "ma.row_stack(*args, **kwargs)", "intent": "Stack arrays in sequence vertically ( row wise ) . With arguments `*args`, `**kwargs`. numpy", "question_id": 21042}
{"snippet": "generic.setflags()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 21043}
{"snippet": "polynomial.legendre.legroots(c)", "intent": "Compute the roots of a Legendre series . With arguments `c`. numpy", "question_id": 21044}
{"snippet": "char.compare_chararrays(a, b, cmp_op, rstrip)", "intent": "Performs element-wise comparison of two string arrays using the comparison operator specified by `cmp_op` . With arguments `a`, `b`, `rstrip`. numpy", "question_id": 21045}
{"snippet": "numpy.broadcast_to(array, shape)", "intent": "Broadcast an `array` to a new `shape` . numpy", "question_id": 21046}
{"snippet": "numpy.broadcast_to(array, shape, subok=False)", "intent": "Broadcast an `array` to a new `shape` . With arguments `subok`. numpy", "question_id": 21047}
{"snippet": "recarray.cumprod()", "intent": "Return the cumulative product of the elements along the given `axis` . numpy", "question_id": 21048}
{"snippet": "recarray.cumprod(axis=None)", "intent": "Return the cumulative product of the elements along the given `axis` . numpy", "question_id": 21049}
{"snippet": "recarray.cumprod(dtype=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 21050}
{"snippet": "recarray.cumprod(out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `out`. numpy", "question_id": 21051}
{"snippet": "recarray.cumprod(axis=None, dtype=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 21052}
{"snippet": "recarray.cumprod(axis=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `out`. numpy", "question_id": 21053}
{"snippet": "recarray.cumprod(dtype=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 21054}
{"snippet": "recarray.cumprod(axis=None, dtype=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 21055}
{"snippet": "polynomial.hermite.hermmulx(c)", "intent": "Multiply a Hermite series by x . Multiply the Hermite series `c` by x , where x is the independent variable . numpy", "question_id": 21056}
{"snippet": "ma.round(a)", "intent": "Return `a` copy of a , rounded to \u2018 `decimals` \u2019 places . numpy", "question_id": 21057}
{"snippet": "ma.round(a, decimals=0)", "intent": "Return `a` copy of a , rounded to \u2018 `decimals` \u2019 places . numpy", "question_id": 21058}
{"snippet": "ma.round(a, out=None)", "intent": "Return `a` copy of a , rounded to \u2018 `decimals` \u2019 places . If `out` is given and does not have a mask attribute , the mask of a is lost ! numpy", "question_id": 21059}
{"snippet": "ma.round(a, decimals=0, out=None)", "intent": "Return `a` copy of a , rounded to \u2018 `decimals` \u2019 places . If `out` is given and does not have a mask attribute , the mask of a is lost ! numpy", "question_id": 21060}
{"snippet": "dtype.metadata", "intent": "Either None or a readonly dictionary of metadata (mappingproxy). numpy", "question_id": 21061}
{"snippet": "ma.stack(*args, **kwargs)", "intent": "Join a sequence of arrays along a new axis . With arguments `*args`, `**kwargs`. numpy", "question_id": 21062}
{"snippet": "polynomial.laguerre.Laguerre.convert()", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 21063}
{"snippet": "polynomial.laguerre.Laguerre.convert(domain=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 21064}
{"snippet": "polynomial.laguerre.Laguerre.convert(kind=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 21065}
{"snippet": "polynomial.laguerre.Laguerre.convert(window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 21066}
{"snippet": "polynomial.laguerre.Laguerre.convert(domain=None, kind=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 21067}
{"snippet": "polynomial.laguerre.Laguerre.convert(domain=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 21068}
{"snippet": "polynomial.laguerre.Laguerre.convert(kind=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 21069}
{"snippet": "polynomial.laguerre.Laguerre.convert(domain=None, kind=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 21070}
{"snippet": "numpy.nan_to_num(x)", "intent": "Replace NaN with zero and infinity with large finite numbers ( default behaviour ) or with the numbers defined by the user using the `nan` , `posinf` and/or `neginf` keywords . If `x` is inexact , NaN is replaced by zero or by the user defined value in nan keyword , infinity is replaced by the largest finite floating point values representable by x.dtype or by the user defined value in posinf keyword and -infinity is replaced by the most negative finite floating point values representable by x.dtype or by the user defined value in neginf keyword . numpy", "question_id": 21071}
{"snippet": "numpy.nan_to_num(x, copy=True)", "intent": "Replace NaN with zero and infinity with large finite numbers ( default behaviour ) or with the numbers defined by the user using the `nan` , `posinf` and/or `neginf` keywords . If `x` is inexact , NaN is replaced by zero or by the user defined value in nan keyword , infinity is replaced by the largest finite floating point values representable by x.dtype or by the user defined value in posinf keyword and -infinity is replaced by the most negative finite floating point values representable by x.dtype or by the user defined value in neginf keyword . With arguments `copy`. numpy", "question_id": 21072}
{"snippet": "numpy.nan_to_num(x, nan=0.0)", "intent": "Replace NaN with zero and infinity with large finite numbers ( default behaviour ) or with the numbers defined by the user using the `nan` , `posinf` and/or `neginf` keywords . If `x` is inexact , NaN is replaced by zero or by the user defined value in nan keyword , infinity is replaced by the largest finite floating point values representable by x.dtype or by the user defined value in posinf keyword and -infinity is replaced by the most negative finite floating point values representable by x.dtype or by the user defined value in neginf keyword . numpy", "question_id": 21073}
{"snippet": "numpy.nan_to_num(x, posinf=None)", "intent": "Replace NaN with zero and infinity with large finite numbers ( default behaviour ) or with the numbers defined by the user using the `nan` , `posinf` and/or `neginf` keywords . If `x` is inexact , NaN is replaced by zero or by the user defined value in nan keyword , infinity is replaced by the largest finite floating point values representable by x.dtype or by the user defined value in posinf keyword and -infinity is replaced by the most negative finite floating point values representable by x.dtype or by the user defined value in neginf keyword . numpy", "question_id": 21074}
{"snippet": "numpy.nan_to_num(x, neginf=None)", "intent": "Replace NaN with zero and infinity with large finite numbers ( default behaviour ) or with the numbers defined by the user using the `nan` , `posinf` and/or `neginf` keywords . If `x` is inexact , NaN is replaced by zero or by the user defined value in nan keyword , infinity is replaced by the largest finite floating point values representable by x.dtype or by the user defined value in posinf keyword and -infinity is replaced by the most negative finite floating point values representable by x.dtype or by the user defined value in neginf keyword . numpy", "question_id": 21075}
{"snippet": "numpy.nan_to_num(x, copy=True, nan=0.0)", "intent": "Replace NaN with zero and infinity with large finite numbers ( default behaviour ) or with the numbers defined by the user using the `nan` , `posinf` and/or `neginf` keywords . If `x` is inexact , NaN is replaced by zero or by the user defined value in nan keyword , infinity is replaced by the largest finite floating point values representable by x.dtype or by the user defined value in posinf keyword and -infinity is replaced by the most negative finite floating point values representable by x.dtype or by the user defined value in neginf keyword . With arguments `copy`. numpy", "question_id": 21076}
{"snippet": "numpy.nan_to_num(x, copy=True, posinf=None)", "intent": "Replace NaN with zero and infinity with large finite numbers ( default behaviour ) or with the numbers defined by the user using the `nan` , `posinf` and/or `neginf` keywords . If `x` is inexact , NaN is replaced by zero or by the user defined value in nan keyword , infinity is replaced by the largest finite floating point values representable by x.dtype or by the user defined value in posinf keyword and -infinity is replaced by the most negative finite floating point values representable by x.dtype or by the user defined value in neginf keyword . With arguments `copy`. numpy", "question_id": 21077}
{"snippet": "numpy.nan_to_num(x, copy=True, neginf=None)", "intent": "Replace NaN with zero and infinity with large finite numbers ( default behaviour ) or with the numbers defined by the user using the `nan` , `posinf` and/or `neginf` keywords . If `x` is inexact , NaN is replaced by zero or by the user defined value in nan keyword , infinity is replaced by the largest finite floating point values representable by x.dtype or by the user defined value in posinf keyword and -infinity is replaced by the most negative finite floating point values representable by x.dtype or by the user defined value in neginf keyword . With arguments `copy`. numpy", "question_id": 21078}
{"snippet": "numpy.nan_to_num(x, nan=0.0, posinf=None)", "intent": "Replace NaN with zero and infinity with large finite numbers ( default behaviour ) or with the numbers defined by the user using the `nan` , `posinf` and/or `neginf` keywords . If `x` is inexact , NaN is replaced by zero or by the user defined value in nan keyword , infinity is replaced by the largest finite floating point values representable by x.dtype or by the user defined value in posinf keyword and -infinity is replaced by the most negative finite floating point values representable by x.dtype or by the user defined value in neginf keyword . numpy", "question_id": 21079}
{"snippet": "numpy.nan_to_num(x, nan=0.0, neginf=None)", "intent": "Replace NaN with zero and infinity with large finite numbers ( default behaviour ) or with the numbers defined by the user using the `nan` , `posinf` and/or `neginf` keywords . If `x` is inexact , NaN is replaced by zero or by the user defined value in nan keyword , infinity is replaced by the largest finite floating point values representable by x.dtype or by the user defined value in posinf keyword and -infinity is replaced by the most negative finite floating point values representable by x.dtype or by the user defined value in neginf keyword . numpy", "question_id": 21080}
{"snippet": "record.tostring()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 21081}
{"snippet": "random.sample()", "intent": "This is an alias of random_sample . numpy", "question_id": 21082}
{"snippet": "record.shape", "intent": "Tuple of array dimensions. numpy", "question_id": 21083}
{"snippet": "generic.__array__()", "intent": "sc.__array__ ( dtype ) return 0-dim array from scalar with specified dtype numpy", "question_id": 21084}
{"snippet": "numpy.extract(condition, arr)", "intent": "Return the elements of an array that satisfy some `condition` . This is equivalent to np.compress ( ravel ( condition ) , ravel ( `arr` ) ) . numpy", "question_id": 21085}
{"snippet": "numpy.put(a, ind, v)", "intent": "Replaces specified elements of an array with given values . With arguments `a`, `ind`, `v`. numpy", "question_id": 21086}
{"snippet": "numpy.put(a, ind, v, mode='raise')", "intent": "Replaces specified elements of an array with given values . With arguments `a`, `ind`, `v`, `mode`. numpy", "question_id": 21087}
{"snippet": "ma.concatenate(arrays)", "intent": "Concatenate a sequence of `arrays` along the given `axis` . numpy", "question_id": 21088}
{"snippet": "ma.concatenate(arrays, axis=0)", "intent": "Concatenate a sequence of `arrays` along the given `axis` . numpy", "question_id": 21089}
{"snippet": "char.chararray.split()", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string . numpy", "question_id": 21090}
{"snippet": "char.chararray.split(sep=None)", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string . numpy", "question_id": 21091}
{"snippet": "char.chararray.split(maxsplit=None)", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string . With arguments `maxsplit`. numpy", "question_id": 21092}
{"snippet": "char.chararray.split(sep=None, maxsplit=None)", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string . With arguments `maxsplit`. numpy", "question_id": 21093}
{"snippet": "polynomial.chebyshev.chebvander3d(x, y, z, deg)", "intent": "Pseudo-Vandermonde matrix of given degrees . Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points ( `x` , `y` , `z` ) . numpy", "question_id": 21094}
{"snippet": "dtype.ndim", "intent": "Number of dimensions of the sub-array if this data type describes a sub-array, and 0 otherwise. numpy", "question_id": 21095}
{"snippet": "memmap.imag", "intent": "The imaginary part of the array. numpy", "question_id": 21096}
{"snippet": "ma.MaskType.cumsum()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 21097}
{"snippet": "numpy.issctype(rep)", "intent": "Determines whether the given object represents a scalar data-type . With arguments `rep`. numpy", "question_id": 21098}
{"snippet": "numpy.isnan(x, /, signature, extobj)", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`. numpy", "question_id": 21099}
{"snippet": "numpy.isnan(x, /, signature, extobj, out=None)", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 21100}
{"snippet": "numpy.isnan(x, /, signature, extobj, where=True)", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `where`. numpy", "question_id": 21101}
{"snippet": "numpy.isnan(x, /, signature, extobj, casting='same_kind')", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 21102}
{"snippet": "numpy.isnan(x, /, signature, extobj, order='K')", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 21103}
{"snippet": "numpy.isnan(x, /, signature, extobj, dtype=None)", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 21104}
{"snippet": "numpy.isnan(x, /, signature, extobj, subok=True)", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 21105}
{"snippet": "numpy.isnan(x, /, signature, extobj, out=None, where=True)", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 21106}
{"snippet": "numpy.isnan(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 21107}
{"snippet": "numpy.isnan(x, /, signature, extobj, out=None, order='K')", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 21108}
{"snippet": "numpy.isnan(x, /, signature)", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`. numpy", "question_id": 21109}
{"snippet": "numpy.isnan(x, /, signature, out=None)", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `out`. numpy", "question_id": 21110}
{"snippet": "numpy.isnan(x, /, signature, where=True)", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `where`. numpy", "question_id": 21111}
{"snippet": "numpy.isnan(x, /, signature, casting='same_kind')", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `casting`. numpy", "question_id": 21112}
{"snippet": "numpy.isnan(x, /, signature, order='K')", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `order`. numpy", "question_id": 21113}
{"snippet": "numpy.isnan(x, /, signature, dtype=None)", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `dtype`. numpy", "question_id": 21114}
{"snippet": "numpy.isnan(x, /, signature, subok=True)", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `subok`. numpy", "question_id": 21115}
{"snippet": "numpy.isnan(x, /, signature, out=None, where=True)", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `out`, `where`. numpy", "question_id": 21116}
{"snippet": "numpy.isnan(x, /, signature, out=None, casting='same_kind')", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `out`, `casting`. numpy", "question_id": 21117}
{"snippet": "numpy.isnan(x, /, signature, out=None, order='K')", "intent": "Test element-wise for NaN and return result as a boolean array . With arguments `x`, `/`, `signature`, `out`, `order`. numpy", "question_id": 21118}
{"snippet": "ndarray.shape", "intent": "Tuple of array dimensions. numpy", "question_id": 21119}
{"snippet": "polynomial.chebyshev.Chebyshev.has_samedomain(other)", "intent": "Check if domains match . With arguments `other`. numpy", "question_id": 21120}
{"snippet": "numpy.partition(a, kth)", "intent": "Return `a` partitioned copy of an array . With arguments `kth`. numpy", "question_id": 21121}
{"snippet": "numpy.partition(a, kth, axis=- 1)", "intent": "Return `a` partitioned copy of an array . All the partition algorithms make temporary copies of the data when partitioning along any but the last `axis` . With arguments `kth`. numpy", "question_id": 21122}
{"snippet": "numpy.partition(a, kth, kind='introselect')", "intent": "Return `a` partitioned copy of an array . With arguments `kth`, `kind`. numpy", "question_id": 21123}
{"snippet": "numpy.partition(a, kth, order=None)", "intent": "Return `a` partitioned copy of an array . A stable sort keeps items with the same key in the same relative `order` . With arguments `kth`. numpy", "question_id": 21124}
{"snippet": "numpy.partition(a, kth, axis=- 1, kind='introselect')", "intent": "Return `a` partitioned copy of an array . All the partition algorithms make temporary copies of the data when partitioning along any but the last `axis` . With arguments `kth`, `kind`. numpy", "question_id": 21125}
{"snippet": "numpy.partition(a, kth, axis=- 1, order=None)", "intent": "Return `a` partitioned copy of an array . All the partition algorithms make temporary copies of the data when partitioning along any but the last `axis` . A stable sort keeps items with the same key in the same relative `order` . With arguments `kth`. numpy", "question_id": 21126}
{"snippet": "numpy.partition(a, kth, kind='introselect', order=None)", "intent": "Return `a` partitioned copy of an array . A stable sort keeps items with the same key in the same relative `order` . With arguments `kth`, `kind`. numpy", "question_id": 21127}
{"snippet": "numpy.partition(a, kth, axis=- 1, kind='introselect', order=None)", "intent": "Return `a` partitioned copy of an array . All the partition algorithms make temporary copies of the data when partitioning along any but the last `axis` . A stable sort keeps items with the same key in the same relative `order` . With arguments `kth`, `kind`. numpy", "question_id": 21128}
{"snippet": "polynomial.legendre.Legendre.has_samecoef(other)", "intent": "Check if coefficients match . With arguments `other`. numpy", "question_id": 21129}
{"snippet": "random.Generator.permutation(x)", "intent": "Randomly permute a sequence , or return a permuted range . With arguments `x`. numpy", "question_id": 21130}
{"snippet": "random.Generator.permutation(x, axis=0)", "intent": "Randomly permute a sequence , or return a permuted range . With arguments `x`, `axis`. numpy", "question_id": 21131}
{"snippet": "ndarray.__neg__(/)", "intent": "-self With arguments `/`. numpy", "question_id": 21132}
{"snippet": "numpy.nanmean(a)", "intent": "Compute the arithmetic mean along the specified `axis` , ignoring NaNs . For all-NaN slices , NaN is returned and `a` RuntimeWarning is raised . numpy", "question_id": 21133}
{"snippet": "numpy.nanmean(a, axis=None)", "intent": "Compute the arithmetic mean along the specified `axis` , ignoring NaNs . For all-NaN slices , NaN is returned and `a` RuntimeWarning is raised . numpy", "question_id": 21134}
{"snippet": "numpy.nanmean(a, dtype=None)", "intent": "Compute the arithmetic mean along the specified `axis` , ignoring NaNs . For all-NaN slices , NaN is returned and `a` RuntimeWarning is raised . Specifying a higher-precision accumulator using the `dtype` keyword can alleviate this issue . numpy", "question_id": 21135}
{"snippet": "numpy.nanmean(a, out=None)", "intent": "Compute the arithmetic mean along the specified `axis` , ignoring NaNs . For all-NaN slices , NaN is returned and `a` RuntimeWarning is raised . With arguments `out`. numpy", "question_id": 21136}
{"snippet": "numpy.nanmean(a, keepdims=<no value>)", "intent": "Compute the arithmetic mean along the specified `axis` , ignoring NaNs . For all-NaN slices , NaN is returned and `a` RuntimeWarning is raised . With arguments `keepdims`. numpy", "question_id": 21137}
{"snippet": "numpy.nanmean(a, axis=None, dtype=None)", "intent": "Compute the arithmetic mean along the specified `axis` , ignoring NaNs . For all-NaN slices , NaN is returned and `a` RuntimeWarning is raised . Specifying a higher-precision accumulator using the `dtype` keyword can alleviate this issue . numpy", "question_id": 21138}
{"snippet": "numpy.nanmean(a, axis=None, out=None)", "intent": "Compute the arithmetic mean along the specified `axis` , ignoring NaNs . For all-NaN slices , NaN is returned and `a` RuntimeWarning is raised . With arguments `out`. numpy", "question_id": 21139}
{"snippet": "numpy.nanmean(a, axis=None, keepdims=<no value>)", "intent": "Compute the arithmetic mean along the specified `axis` , ignoring NaNs . For all-NaN slices , NaN is returned and `a` RuntimeWarning is raised . With arguments `keepdims`. numpy", "question_id": 21140}
{"snippet": "numpy.nanmean(a, dtype=None, out=None)", "intent": "Compute the arithmetic mean along the specified `axis` , ignoring NaNs . For all-NaN slices , NaN is returned and `a` RuntimeWarning is raised . Specifying a higher-precision accumulator using the `dtype` keyword can alleviate this issue . With arguments `out`. numpy", "question_id": 21141}
{"snippet": "numpy.nanmean(a, dtype=None, keepdims=<no value>)", "intent": "Compute the arithmetic mean along the specified `axis` , ignoring NaNs . For all-NaN slices , NaN is returned and `a` RuntimeWarning is raised . Specifying a higher-precision accumulator using the `dtype` keyword can alleviate this issue . With arguments `keepdims`. numpy", "question_id": 21142}
{"snippet": "ma.MaskType.setflags()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 21143}
{"snippet": "numpy.obj2sctype(rep)", "intent": "Return the scalar dtype or NumPy equivalent of Python type of an object . With arguments `rep`. numpy", "question_id": 21144}
{"snippet": "numpy.obj2sctype(rep, default=None)", "intent": "Return the scalar dtype or NumPy equivalent of Python type of an object . With arguments `rep`, `default`. numpy", "question_id": 21145}
{"snippet": "numpy.array_str(a)", "intent": "Return `a` string representation of the data in an array . numpy", "question_id": 21146}
{"snippet": "numpy.array_str(a, max_line_width=None)", "intent": "Return `a` string representation of the data in an array . With arguments `max_line_width`. numpy", "question_id": 21147}
{"snippet": "numpy.array_str(a, precision=None)", "intent": "Return `a` string representation of the data in an array . With arguments `precision`. numpy", "question_id": 21148}
{"snippet": "numpy.array_str(a, suppress_small=None)", "intent": "Return `a` string representation of the data in an array . With arguments `suppress_small`. numpy", "question_id": 21149}
{"snippet": "numpy.array_str(a, max_line_width=None, precision=None)", "intent": "Return `a` string representation of the data in an array . With arguments `max_line_width`, `precision`. numpy", "question_id": 21150}
{"snippet": "numpy.array_str(a, max_line_width=None, suppress_small=None)", "intent": "Return `a` string representation of the data in an array . With arguments `max_line_width`, `suppress_small`. numpy", "question_id": 21151}
{"snippet": "numpy.array_str(a, precision=None, suppress_small=None)", "intent": "Return `a` string representation of the data in an array . With arguments `precision`, `suppress_small`. numpy", "question_id": 21152}
{"snippet": "numpy.array_str(a, max_line_width=None, precision=None, suppress_small=None)", "intent": "Return `a` string representation of the data in an array . With arguments `max_line_width`, `precision`, `suppress_small`. numpy", "question_id": 21153}
{"snippet": "polynomial.chebyshev.Chebyshev.fit(x, y, deg)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`. numpy", "question_id": 21154}
{"snippet": "polynomial.chebyshev.Chebyshev.fit(x, y, deg, domain=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`. numpy", "question_id": 21155}
{"snippet": "polynomial.chebyshev.Chebyshev.fit(x, y, deg, rcond=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `rcond`. numpy", "question_id": 21156}
{"snippet": "polynomial.chebyshev.Chebyshev.fit(x, y, deg, full=False)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `full`. numpy", "question_id": 21157}
{"snippet": "polynomial.chebyshev.Chebyshev.fit(x, y, deg, w=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `w`. numpy", "question_id": 21158}
{"snippet": "polynomial.chebyshev.Chebyshev.fit(x, y, deg, window=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `window`. numpy", "question_id": 21159}
{"snippet": "polynomial.chebyshev.Chebyshev.fit(x, y, deg, domain=None, rcond=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `rcond`. numpy", "question_id": 21160}
{"snippet": "polynomial.chebyshev.Chebyshev.fit(x, y, deg, domain=None, full=False)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `full`. numpy", "question_id": 21161}
{"snippet": "polynomial.chebyshev.Chebyshev.fit(x, y, deg, domain=None, w=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `w`. numpy", "question_id": 21162}
{"snippet": "polynomial.chebyshev.Chebyshev.fit(x, y, deg, domain=None, window=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `window`. numpy", "question_id": 21163}
{"snippet": "ma.MaskedArray.reshape(*s, **kwargs)", "intent": "Give a new shape to the array without changing its data . With arguments `*s`, `**kwargs`. numpy", "question_id": 21164}
{"snippet": "char.islower(a)", "intent": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character , false otherwise . With arguments `a`. numpy", "question_id": 21165}
{"snippet": "ma.power(a, b)", "intent": "Returns element-wise base array raised to power from second array . With arguments `a`, `b`. numpy", "question_id": 21166}
{"snippet": "ma.power(a, b, third=None)", "intent": "Returns element-wise base array raised to power from second array . The out argument to numpy.power is not supported , `third` has to be None . With arguments `a`, `b`. numpy", "question_id": 21167}
{"snippet": "numpy.real(val)", "intent": "Return the real part of the complex argument . With arguments `val`. numpy", "question_id": 21168}
{"snippet": "ma.MaskedArray.ctypes", "intent": "An object to simplify the interaction of the array with the ctypes module. numpy", "question_id": 21169}
{"snippet": "_ctypes.data", "intent": "A pointer to the memory area of the array as a Python integer. numpy", "question_id": 21170}
{"snippet": "_ctypes.shape", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the C-integer corresponding to dtype('p') on this platform. numpy", "question_id": 21171}
{"snippet": "_ctypes.strides", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the same as for the shape attribute. numpy", "question_id": 21172}
{"snippet": "_ctypes.data_as(obj)", "intent": "Return the data pointer cast to a particular c-types object . With arguments `obj`. numpy", "question_id": 21173}
{"snippet": "_ctypes.shape_as(obj)", "intent": "Return the shape tuple as an array of some other c-types type . With arguments `obj`. numpy", "question_id": 21174}
{"snippet": "_ctypes.strides_as(obj)", "intent": "Return the strides tuple as an array of some other c-types type . With arguments `obj`. numpy", "question_id": 21175}
{"snippet": "char.chararray.dot(b)", "intent": "Dot product of two arrays . With arguments `b`. numpy", "question_id": 21176}
{"snippet": "char.chararray.dot(b, out=None)", "intent": "Dot product of two arrays . With arguments `b`, `out`. numpy", "question_id": 21177}
{"snippet": "numpy.dstack(tup)", "intent": "Stack arrays in sequence depth wise ( along third axis ) . With arguments `tup`. numpy", "question_id": 21178}
{"snippet": "polynomial.legendre.Legendre.basis(deg)", "intent": "Series basis polynomial of degree `deg` . numpy", "question_id": 21179}
{"snippet": "polynomial.legendre.Legendre.basis(deg, domain=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `domain`. numpy", "question_id": 21180}
{"snippet": "polynomial.legendre.Legendre.basis(deg, window=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `window`. numpy", "question_id": 21181}
{"snippet": "polynomial.legendre.Legendre.basis(deg, domain=None, window=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `domain`, `window`. numpy", "question_id": 21182}
{"snippet": "ma.std(self)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `self`. numpy", "question_id": 21183}
{"snippet": "ma.std(self, axis=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `self`. numpy", "question_id": 21184}
{"snippet": "ma.std(self, dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `self`, `dtype`. numpy", "question_id": 21185}
{"snippet": "ma.std(self, out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `self`, `out`. numpy", "question_id": 21186}
{"snippet": "ma.std(self, ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `self`, `ddof`. numpy", "question_id": 21187}
{"snippet": "ma.std(self, keepdims=<no value>)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `self`, `keepdims`. numpy", "question_id": 21188}
{"snippet": "ma.std(self, axis=None, dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `self`, `dtype`. numpy", "question_id": 21189}
{"snippet": "ma.std(self, axis=None, out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `self`, `out`. numpy", "question_id": 21190}
{"snippet": "ma.std(self, axis=None, ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `self`, `ddof`. numpy", "question_id": 21191}
{"snippet": "ma.std(self, axis=None, keepdims=<no value>)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `self`, `keepdims`. numpy", "question_id": 21192}
{"snippet": "fft.ifftn(a)", "intent": "Compute the N-dimensional inverse discrete Fourier Transform . In other words , ifftn ( fftn ( `a` ) ) == a to within numerical accuracy . numpy", "question_id": 21193}
{"snippet": "fft.ifftn(a, s=None)", "intent": "Compute the N-dimensional inverse discrete Fourier Transform . In other words , ifftn ( fftn ( `a` ) ) == a to within numerical accuracy . With arguments `s`. numpy", "question_id": 21194}
{"snippet": "fft.ifftn(a, axes=None)", "intent": "Compute the N-dimensional inverse discrete Fourier Transform . In other words , ifftn ( fftn ( `a` ) ) == a to within numerical accuracy . This function computes the inverse of the N-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . numpy", "question_id": 21195}
{"snippet": "fft.ifftn(a, norm=None)", "intent": "Compute the N-dimensional inverse discrete Fourier Transform . In other words , ifftn ( fftn ( `a` ) ) == a to within numerical accuracy . With arguments `norm`. numpy", "question_id": 21196}
{"snippet": "fft.ifftn(a, s=None, axes=None)", "intent": "Compute the N-dimensional inverse discrete Fourier Transform . In other words , ifftn ( fftn ( `a` ) ) == a to within numerical accuracy . This function computes the inverse of the N-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `s`. numpy", "question_id": 21197}
{"snippet": "fft.ifftn(a, s=None, norm=None)", "intent": "Compute the N-dimensional inverse discrete Fourier Transform . In other words , ifftn ( fftn ( `a` ) ) == a to within numerical accuracy . With arguments `s`, `norm`. numpy", "question_id": 21198}
{"snippet": "fft.ifftn(a, axes=None, norm=None)", "intent": "Compute the N-dimensional inverse discrete Fourier Transform . In other words , ifftn ( fftn ( `a` ) ) == a to within numerical accuracy . This function computes the inverse of the N-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `norm`. numpy", "question_id": 21199}
{"snippet": "fft.ifftn(a, s=None, axes=None, norm=None)", "intent": "Compute the N-dimensional inverse discrete Fourier Transform . In other words , ifftn ( fftn ( `a` ) ) == a to within numerical accuracy . This function computes the inverse of the N-dimensional discrete Fourier Transform over any number of `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `s`, `norm`. numpy", "question_id": 21200}
{"snippet": "numpy.who()", "intent": "Print the NumPy arrays in the given dictionary . numpy", "question_id": 21201}
{"snippet": "numpy.who(vardict=None)", "intent": "Print the NumPy arrays in the given dictionary . If there is no dictionary passed in or `vardict` is None then returns NumPy arrays in the globals ( ) dictionary ( all NumPy arrays in the namespace ) . numpy", "question_id": 21202}
{"snippet": "ndarray.__mul__(value, /)", "intent": "Return self * `value` . With arguments `/`. numpy", "question_id": 21203}
{"snippet": "polynomial.polynomial.Polynomial.has_samewindow(other)", "intent": "Check if windows match . With arguments `other`. numpy", "question_id": 21204}
{"snippet": "numpy.empty(shape)", "intent": "Return a new array of given `shape` and type , without initializing entries . numpy", "question_id": 21205}
{"snippet": "numpy.empty(shape, dtype=float)", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `dtype`. numpy", "question_id": 21206}
{"snippet": "numpy.empty(shape, order='C')", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `order`. numpy", "question_id": 21207}
{"snippet": "numpy.empty(shape, like=None)", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `like`. numpy", "question_id": 21208}
{"snippet": "numpy.empty(shape, dtype=float, order='C')", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `dtype`, `order`. numpy", "question_id": 21209}
{"snippet": "numpy.empty(shape, dtype=float, like=None)", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `dtype`, `like`. numpy", "question_id": 21210}
{"snippet": "numpy.empty(shape, order='C', like=None)", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `order`, `like`. numpy", "question_id": 21211}
{"snippet": "numpy.empty(shape, dtype=float, order='C', like=None)", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `dtype`, `order`, `like`. numpy", "question_id": 21212}
{"snippet": "chararray.dot(b)", "intent": "Dot product of two arrays . With arguments `b`. numpy", "question_id": 21213}
{"snippet": "chararray.dot(b, out=None)", "intent": "Dot product of two arrays . With arguments `b`, `out`. numpy", "question_id": 21214}
{"snippet": "matrix.getT()", "intent": "Returns the transpose of the matrix . numpy", "question_id": 21215}
{"snippet": "numpy.base_repr(number)", "intent": "Return a string representation of a `number` in the given `base` system . numpy", "question_id": 21216}
{"snippet": "numpy.base_repr(number, base=2)", "intent": "Return a string representation of a `number` in the given `base` system . numpy", "question_id": 21217}
{"snippet": "numpy.base_repr(number, padding=0)", "intent": "Return a string representation of a `number` in the given `base` system . With arguments `padding`. numpy", "question_id": 21218}
{"snippet": "numpy.base_repr(number, base=2, padding=0)", "intent": "Return a string representation of a `number` in the given `base` system . With arguments `padding`. numpy", "question_id": 21219}
{"snippet": "numpy.flatnonzero(a)", "intent": "Return indices that are non-zero in the flattened version of `a` . numpy", "question_id": 21220}
{"snippet": "polynomial.chebyshev.Chebyshev.basis(deg)", "intent": "Series basis polynomial of degree `deg` . numpy", "question_id": 21221}
{"snippet": "polynomial.chebyshev.Chebyshev.basis(deg, domain=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `domain`. numpy", "question_id": 21222}
{"snippet": "polynomial.chebyshev.Chebyshev.basis(deg, window=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `window`. numpy", "question_id": 21223}
{"snippet": "polynomial.chebyshev.Chebyshev.basis(deg, domain=None, window=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `domain`, `window`. numpy", "question_id": 21224}
{"snippet": "matrix.std()", "intent": "Return the standard deviation of the array elements along the given `axis` . numpy", "question_id": 21225}
{"snippet": "matrix.std(axis=None)", "intent": "Return the standard deviation of the array elements along the given `axis` . numpy", "question_id": 21226}
{"snippet": "matrix.std(dtype=None)", "intent": "Return the standard deviation of the array elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 21227}
{"snippet": "matrix.std(out=None)", "intent": "Return the standard deviation of the array elements along the given `axis` . With arguments `out`. numpy", "question_id": 21228}
{"snippet": "matrix.std(ddof=0)", "intent": "Return the standard deviation of the array elements along the given `axis` . With arguments `ddof`. numpy", "question_id": 21229}
{"snippet": "matrix.std(axis=None, dtype=None)", "intent": "Return the standard deviation of the array elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 21230}
{"snippet": "matrix.std(axis=None, out=None)", "intent": "Return the standard deviation of the array elements along the given `axis` . With arguments `out`. numpy", "question_id": 21231}
{"snippet": "matrix.std(axis=None, ddof=0)", "intent": "Return the standard deviation of the array elements along the given `axis` . With arguments `ddof`. numpy", "question_id": 21232}
{"snippet": "matrix.std(dtype=None, out=None)", "intent": "Return the standard deviation of the array elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 21233}
{"snippet": "matrix.std(dtype=None, ddof=0)", "intent": "Return the standard deviation of the array elements along the given `axis` . With arguments `dtype`, `ddof`. numpy", "question_id": 21234}
{"snippet": "numpy.floor(x, /, signature, extobj)", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 21235}
{"snippet": "numpy.floor(x, /, signature, extobj, out=None)", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 21236}
{"snippet": "numpy.floor(x, /, signature, extobj, where=True)", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . Some spreadsheet programs calculate the \u201c floor-towards-zero \u201d , `where` floor ( -2.5 ) == -2 . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 21237}
{"snippet": "numpy.floor(x, /, signature, extobj, casting='same_kind')", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 21238}
{"snippet": "numpy.floor(x, /, signature, extobj, order='K')", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 21239}
{"snippet": "numpy.floor(x, /, signature, extobj, dtype=None)", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 21240}
{"snippet": "numpy.floor(x, /, signature, extobj, subok=True)", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 21241}
{"snippet": "numpy.floor(x, /, signature, extobj, out=None, where=True)", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . Some spreadsheet programs calculate the \u201c floor-towards-zero \u201d , `where` floor ( -2.5 ) == -2 . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 21242}
{"snippet": "numpy.floor(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 21243}
{"snippet": "numpy.floor(x, /, signature, extobj, out=None, order='K')", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 21244}
{"snippet": "numpy.floor(x, /, signature)", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`. numpy", "question_id": 21245}
{"snippet": "numpy.floor(x, /, signature, out=None)", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `out`. numpy", "question_id": 21246}
{"snippet": "numpy.floor(x, /, signature, where=True)", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . Some spreadsheet programs calculate the \u201c floor-towards-zero \u201d , `where` floor ( -2.5 ) == -2 . With arguments `/`, `signature`. numpy", "question_id": 21247}
{"snippet": "numpy.floor(x, /, signature, casting='same_kind')", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `casting`. numpy", "question_id": 21248}
{"snippet": "numpy.floor(x, /, signature, order='K')", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `order`. numpy", "question_id": 21249}
{"snippet": "numpy.floor(x, /, signature, dtype=None)", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 21250}
{"snippet": "numpy.floor(x, /, signature, subok=True)", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `subok`. numpy", "question_id": 21251}
{"snippet": "numpy.floor(x, /, signature, out=None, where=True)", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . Some spreadsheet programs calculate the \u201c floor-towards-zero \u201d , `where` floor ( -2.5 ) == -2 . With arguments `/`, `signature`, `out`. numpy", "question_id": 21252}
{"snippet": "numpy.floor(x, /, signature, out=None, casting='same_kind')", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 21253}
{"snippet": "numpy.floor(x, /, signature, out=None, order='K')", "intent": "Return the floor of the input , element-wise . The floor of the scalar `x` is the largest integer i , such that i < = x . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 21254}
{"snippet": "numpy.nanpercentile(a, q)", "intent": "Compute the qth percentile of the data along the specified `axis` , while ignoring nan values . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . numpy", "question_id": 21255}
{"snippet": "numpy.nanpercentile(a, q, axis=None)", "intent": "Compute the qth percentile of the data along the specified `axis` , while ignoring nan values . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . numpy", "question_id": 21256}
{"snippet": "numpy.nanpercentile(a, q, out=None)", "intent": "Compute the qth percentile of the data along the specified `axis` , while ignoring nan values . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . With arguments `out`. numpy", "question_id": 21257}
{"snippet": "numpy.nanpercentile(a, q, overwrite_input=False)", "intent": "Compute the qth percentile of the data along the specified `axis` , while ignoring nan values . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . With arguments `overwrite_input`. numpy", "question_id": 21258}
{"snippet": "numpy.nanpercentile(a, q, interpolation='linear')", "intent": "Compute the qth percentile of the data along the specified `axis` , while ignoring nan values . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . numpy", "question_id": 21259}
{"snippet": "numpy.nanpercentile(a, q, keepdims=<no value>)", "intent": "Compute the qth percentile of the data along the specified `axis` , while ignoring nan values . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . With arguments `keepdims`. numpy", "question_id": 21260}
{"snippet": "numpy.nanpercentile(a, q, axis=None, out=None)", "intent": "Compute the qth percentile of the data along the specified `axis` , while ignoring nan values . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . With arguments `out`. numpy", "question_id": 21261}
{"snippet": "numpy.nanpercentile(a, q, axis=None, overwrite_input=False)", "intent": "Compute the qth percentile of the data along the specified `axis` , while ignoring nan values . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . With arguments `overwrite_input`. numpy", "question_id": 21262}
{"snippet": "numpy.nanpercentile(a, q, axis=None, interpolation='linear')", "intent": "Compute the qth percentile of the data along the specified `axis` , while ignoring nan values . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . numpy", "question_id": 21263}
{"snippet": "numpy.nanpercentile(a, q, axis=None, keepdims=<no value>)", "intent": "Compute the qth percentile of the data along the specified `axis` , while ignoring nan values . Given `a` vector V of length N , the q-th percentile of V is the value q/100 of the way from the minimum to the maximum in a sorted copy of V. The values and distances of the two nearest neighbors as well as the `interpolation` parameter will determine the percentile if the normalized ranking does not match the location of `q` exactly . With arguments `keepdims`. numpy", "question_id": 21264}
{"snippet": "ma.MaskedArray.__float__()", "intent": "Convert to float . numpy", "question_id": 21265}
{"snippet": "ndarray.real", "intent": "The real part of the array. numpy", "question_id": 21266}
{"snippet": "memmap.choose(choices)", "intent": "Use an index array to construct a new array from a set of `choices` . numpy", "question_id": 21267}
{"snippet": "memmap.choose(choices, out=None)", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`. numpy", "question_id": 21268}
{"snippet": "memmap.choose(choices, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `mode`. numpy", "question_id": 21269}
{"snippet": "memmap.choose(choices, out=None, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`, `mode`. numpy", "question_id": 21270}
{"snippet": "memmap.tobytes()", "intent": "Construct Python bytes containing the raw data bytes in the array . numpy", "question_id": 21271}
{"snippet": "memmap.tobytes(order='C')", "intent": "Construct Python bytes containing the raw data bytes in the array . This behavior is controlled by the `order` parameter . numpy", "question_id": 21272}
{"snippet": "random.RandomState.standard_t(df)", "intent": "Draw samples from a standard Student \u2019 s t distribution with `df` degrees of freedom . numpy", "question_id": 21273}
{"snippet": "random.RandomState.standard_t(df, size=None)", "intent": "Draw samples from a standard Student \u2019 s t distribution with `df` degrees of freedom . With arguments `size`. numpy", "question_id": 21274}
{"snippet": "numpy.record", "intent": "A data-type scalar that allows field access as attribute lookup. numpy", "question_id": 21275}
{"snippet": "polynomial.polynomial.polyvalfromroots(x, r)", "intent": "Evaluate a polynomial specified by its roots at points `x` . If `r` is of length N , this function returns the value numpy", "question_id": 21276}
{"snippet": "polynomial.polynomial.polyvalfromroots(x, r, tensor=True)", "intent": "Evaluate a polynomial specified by its roots at points `x` . If `r` is of length N , this function returns the value If r is multidimensional , then the shape of the result depends on the value of `tensor` . numpy", "question_id": 21277}
{"snippet": "numpy.less_equal(x1, x2, /, signature, extobj)", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 21278}
{"snippet": "numpy.less_equal(x1, x2, /, signature, extobj, out=None)", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 21279}
{"snippet": "numpy.less_equal(x1, x2, /, signature, extobj, where=True)", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 21280}
{"snippet": "numpy.less_equal(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 21281}
{"snippet": "numpy.less_equal(x1, x2, /, signature, extobj, order='K')", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 21282}
{"snippet": "numpy.less_equal(x1, x2, /, signature, extobj, dtype=None)", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 21283}
{"snippet": "numpy.less_equal(x1, x2, /, signature, extobj, subok=True)", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 21284}
{"snippet": "numpy.less_equal(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 21285}
{"snippet": "numpy.less_equal(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 21286}
{"snippet": "numpy.less_equal(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 21287}
{"snippet": "numpy.less_equal(x1, x2, /, signature)", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`. numpy", "question_id": 21288}
{"snippet": "numpy.less_equal(x1, x2, /, signature, out=None)", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `out`. numpy", "question_id": 21289}
{"snippet": "numpy.less_equal(x1, x2, /, signature, where=True)", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `where`. numpy", "question_id": 21290}
{"snippet": "numpy.less_equal(x1, x2, /, signature, casting='same_kind')", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `casting`. numpy", "question_id": 21291}
{"snippet": "numpy.less_equal(x1, x2, /, signature, order='K')", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `order`. numpy", "question_id": 21292}
{"snippet": "numpy.less_equal(x1, x2, /, signature, dtype=None)", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 21293}
{"snippet": "numpy.less_equal(x1, x2, /, signature, subok=True)", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `subok`. numpy", "question_id": 21294}
{"snippet": "numpy.less_equal(x1, x2, /, signature, out=None, where=True)", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 21295}
{"snippet": "numpy.less_equal(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 21296}
{"snippet": "numpy.less_equal(x1, x2, /, signature, out=None, order='K')", "intent": "Return the truth value of ( `x1` < = `x2` ) element-wise . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 21297}
{"snippet": "polynomial.laguerre.Laguerre.cast(series)", "intent": "Convert `series` to series of this class . numpy", "question_id": 21298}
{"snippet": "polynomial.laguerre.Laguerre.cast(series, domain=None)", "intent": "Convert `series` to series of this class . With arguments `domain`. numpy", "question_id": 21299}
{"snippet": "polynomial.laguerre.Laguerre.cast(series, window=None)", "intent": "Convert `series` to series of this class . With arguments `window`. numpy", "question_id": 21300}
{"snippet": "polynomial.laguerre.Laguerre.cast(series, domain=None, window=None)", "intent": "Convert `series` to series of this class . With arguments `domain`, `window`. numpy", "question_id": 21301}
{"snippet": "polynomial.polynomial.Polynomial.basis(deg)", "intent": "Series basis polynomial of degree `deg` . numpy", "question_id": 21302}
{"snippet": "polynomial.polynomial.Polynomial.basis(deg, domain=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `domain`. numpy", "question_id": 21303}
{"snippet": "polynomial.polynomial.Polynomial.basis(deg, window=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `window`. numpy", "question_id": 21304}
{"snippet": "polynomial.polynomial.Polynomial.basis(deg, domain=None, window=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `domain`, `window`. numpy", "question_id": 21305}
{"snippet": "polynomial.polynomial.polysub(c1, c2)", "intent": "Subtract one polynomial from another . Returns the difference of two polynomials `c1` - `c2` . numpy", "question_id": 21306}
{"snippet": "numpy.not_equal(x1, x2, /, signature, extobj)", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 21307}
{"snippet": "numpy.not_equal(x1, x2, /, signature, extobj, out=None)", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 21308}
{"snippet": "numpy.not_equal(x1, x2, /, signature, extobj, where=True)", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 21309}
{"snippet": "numpy.not_equal(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 21310}
{"snippet": "numpy.not_equal(x1, x2, /, signature, extobj, order='K')", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 21311}
{"snippet": "numpy.not_equal(x1, x2, /, signature, extobj, dtype=None)", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 21312}
{"snippet": "numpy.not_equal(x1, x2, /, signature, extobj, subok=True)", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 21313}
{"snippet": "numpy.not_equal(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 21314}
{"snippet": "numpy.not_equal(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 21315}
{"snippet": "numpy.not_equal(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 21316}
{"snippet": "numpy.not_equal(x1, x2, /, signature)", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`. numpy", "question_id": 21317}
{"snippet": "numpy.not_equal(x1, x2, /, signature, out=None)", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `out`. numpy", "question_id": 21318}
{"snippet": "numpy.not_equal(x1, x2, /, signature, where=True)", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `where`. numpy", "question_id": 21319}
{"snippet": "numpy.not_equal(x1, x2, /, signature, casting='same_kind')", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `casting`. numpy", "question_id": 21320}
{"snippet": "numpy.not_equal(x1, x2, /, signature, order='K')", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `order`. numpy", "question_id": 21321}
{"snippet": "numpy.not_equal(x1, x2, /, signature, dtype=None)", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 21322}
{"snippet": "numpy.not_equal(x1, x2, /, signature, subok=True)", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `subok`. numpy", "question_id": 21323}
{"snippet": "numpy.not_equal(x1, x2, /, signature, out=None, where=True)", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 21324}
{"snippet": "numpy.not_equal(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 21325}
{"snippet": "numpy.not_equal(x1, x2, /, signature, out=None, order='K')", "intent": "Return ( `x1` ! = `x2` ) element-wise . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 21326}
{"snippet": "recarray.newbyteorder(/)", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`. numpy", "question_id": 21327}
{"snippet": "recarray.newbyteorder(/, new_order='S')", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`, `new_order`. numpy", "question_id": 21328}
{"snippet": "random.RandomState.logseries(p)", "intent": "Draw samples from a logarithmic series distribution . Samples are drawn from a log series distribution with specified shape parameter , 0 < `p` < 1 . numpy", "question_id": 21329}
{"snippet": "random.RandomState.logseries(p, size=None)", "intent": "Draw samples from a logarithmic series distribution . Samples are drawn from a log series distribution with specified shape parameter , 0 < `p` < 1 . With arguments `size`. numpy", "question_id": 21330}
{"snippet": "lib.format.magic(major, minor)", "intent": "Return the magic string for the given file format version . With arguments `major`, `minor`. numpy", "question_id": 21331}
{"snippet": "polynomial.chebyshev.chebsub(c1, c2)", "intent": "Subtract one Chebyshev series from another . Returns the difference of two Chebyshev series `c1` - `c2` . numpy", "question_id": 21332}
{"snippet": "char.chararray.cumsum()", "intent": "Return the cumulative sum of the elements along the given `axis` . numpy", "question_id": 21333}
{"snippet": "char.chararray.cumsum(axis=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . numpy", "question_id": 21334}
{"snippet": "char.chararray.cumsum(dtype=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 21335}
{"snippet": "char.chararray.cumsum(out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `out`. numpy", "question_id": 21336}
{"snippet": "char.chararray.cumsum(axis=None, dtype=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 21337}
{"snippet": "char.chararray.cumsum(axis=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `out`. numpy", "question_id": 21338}
{"snippet": "char.chararray.cumsum(dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 21339}
{"snippet": "char.chararray.cumsum(axis=None, dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 21340}
{"snippet": "polynomial.hermite_e.hermecompanion(c)", "intent": "Return the scaled companion matrix of `c` . numpy", "question_id": 21341}
{"snippet": "matrix.argmax()", "intent": "Indexes of the maximum values along an `axis` . numpy", "question_id": 21342}
{"snippet": "matrix.argmax(axis=None)", "intent": "Indexes of the maximum values along an `axis` . numpy", "question_id": 21343}
{"snippet": "matrix.argmax(out=None)", "intent": "Indexes of the maximum values along an `axis` . With arguments `out`. numpy", "question_id": 21344}
{"snippet": "matrix.argmax(axis=None, out=None)", "intent": "Indexes of the maximum values along an `axis` . With arguments `out`. numpy", "question_id": 21345}
{"snippet": "numpy.datetime_as_string(arr)", "intent": "Convert an array of datetimes into an array of strings . With arguments `arr`. numpy", "question_id": 21346}
{"snippet": "numpy.datetime_as_string(arr, unit=None)", "intent": "Convert an array of datetimes into an array of strings . Passing in a `unit` will change the precision With arguments `arr`. numpy", "question_id": 21347}
{"snippet": "numpy.datetime_as_string(arr, timezone='naive')", "intent": "Convert an array of datetimes into an array of strings . Setting the `timezone` to UTC shows the same information , but with a Z suffix With arguments `arr`. numpy", "question_id": 21348}
{"snippet": "numpy.datetime_as_string(arr, casting='same_kind')", "intent": "Convert an array of datetimes into an array of strings . \u2018 `casting` \u2019 can be used to specify whether precision can be changed With arguments `arr`. numpy", "question_id": 21349}
{"snippet": "numpy.datetime_as_string(arr, unit=None, timezone='naive')", "intent": "Convert an array of datetimes into an array of strings . Passing in a `unit` will change the precision Setting the `timezone` to UTC shows the same information , but with a Z suffix With arguments `arr`. numpy", "question_id": 21350}
{"snippet": "numpy.datetime_as_string(arr, unit=None, casting='same_kind')", "intent": "Convert an array of datetimes into an array of strings . Passing in a `unit` will change the precision \u2018 `casting` \u2019 can be used to specify whether precision can be changed With arguments `arr`. numpy", "question_id": 21351}
{"snippet": "numpy.datetime_as_string(arr, timezone='naive', casting='same_kind')", "intent": "Convert an array of datetimes into an array of strings . Setting the `timezone` to UTC shows the same information , but with a Z suffix \u2018 `casting` \u2019 can be used to specify whether precision can be changed With arguments `arr`. numpy", "question_id": 21352}
{"snippet": "numpy.datetime_as_string(arr, unit=None, timezone='naive', casting='same_kind')", "intent": "Convert an array of datetimes into an array of strings . Passing in a `unit` will change the precision Setting the `timezone` to UTC shows the same information , but with a Z suffix \u2018 `casting` \u2019 can be used to specify whether precision can be changed With arguments `arr`. numpy", "question_id": 21353}
{"snippet": "chararray.conjugate()", "intent": "Return the complex conjugate , element-wise . numpy", "question_id": 21354}
{"snippet": "polynomial.polynomial.polyvander2d(x, y, deg)", "intent": "Pseudo-Vandermonde matrix of given degrees . Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points ( `x` , `y` ) . numpy", "question_id": 21355}
{"snippet": "ma.MaskType.round()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 21356}
{"snippet": "random.zipf(a)", "intent": "Draw samples from `a` Zipf distribution . numpy", "question_id": 21357}
{"snippet": "random.zipf(a, size=None)", "intent": "Draw samples from `a` Zipf distribution . With arguments `size`. numpy", "question_id": 21358}
{"snippet": "numpy.sinh(x, /, signature, extobj)", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 21359}
{"snippet": "numpy.sinh(x, /, signature, extobj, out=None)", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 21360}
{"snippet": "numpy.sinh(x, /, signature, extobj, where=True)", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 21361}
{"snippet": "numpy.sinh(x, /, signature, extobj, casting='same_kind')", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 21362}
{"snippet": "numpy.sinh(x, /, signature, extobj, order='K')", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 21363}
{"snippet": "numpy.sinh(x, /, signature, extobj, dtype=None)", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 21364}
{"snippet": "numpy.sinh(x, /, signature, extobj, subok=True)", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 21365}
{"snippet": "numpy.sinh(x, /, signature, extobj, out=None, where=True)", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 21366}
{"snippet": "numpy.sinh(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 21367}
{"snippet": "numpy.sinh(x, /, signature, extobj, out=None, order='K')", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 21368}
{"snippet": "numpy.sinh(x, /, signature)", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . With arguments `/`, `signature`. numpy", "question_id": 21369}
{"snippet": "numpy.sinh(x, /, signature, out=None)", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`. numpy", "question_id": 21370}
{"snippet": "numpy.sinh(x, /, signature, where=True)", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . With arguments `/`, `signature`, `where`. numpy", "question_id": 21371}
{"snippet": "numpy.sinh(x, /, signature, casting='same_kind')", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . With arguments `/`, `signature`, `casting`. numpy", "question_id": 21372}
{"snippet": "numpy.sinh(x, /, signature, order='K')", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . With arguments `/`, `signature`, `order`. numpy", "question_id": 21373}
{"snippet": "numpy.sinh(x, /, signature, dtype=None)", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 21374}
{"snippet": "numpy.sinh(x, /, signature, subok=True)", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . With arguments `/`, `signature`, `subok`. numpy", "question_id": 21375}
{"snippet": "numpy.sinh(x, /, signature, out=None, where=True)", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `where`. numpy", "question_id": 21376}
{"snippet": "numpy.sinh(x, /, signature, out=None, casting='same_kind')", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `casting`. numpy", "question_id": 21377}
{"snippet": "numpy.sinh(x, /, signature, out=None, order='K')", "intent": "Hyperbolic sine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) - np.exp ( -x ) ) or -1j * np.sin ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `order`. numpy", "question_id": 21378}
{"snippet": "polynomial.hermite_e.hermeint(c)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 21379}
{"snippet": "polynomial.hermite_e.hermeint(c, m=1)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 21380}
{"snippet": "polynomial.hermite_e.hermeint(c, k=)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 21381}
{"snippet": "polynomial.hermite_e.hermeint(c, lbnd=0)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 21382}
{"snippet": "polynomial.hermite_e.hermeint(c, scl=1)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 21383}
{"snippet": "polynomial.hermite_e.hermeint(c, axis=0)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 21384}
{"snippet": "polynomial.hermite_e.hermeint(c, m=1, k=)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 21385}
{"snippet": "polynomial.hermite_e.hermeint(c, m=1, lbnd=0)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 21386}
{"snippet": "polynomial.hermite_e.hermeint(c, m=1, scl=1)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 21387}
{"snippet": "polynomial.hermite_e.hermeint(c, m=1, axis=0)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 21388}
{"snippet": "polynomial.hermite_e.hermeint()", "intent": "Integrate a Hermite_e series . numpy", "question_id": 21389}
{"snippet": "polynomial.hermite_e.hermeint(m=1)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 21390}
{"snippet": "polynomial.hermite_e.hermeint(k=)", "intent": "Integrate a Hermite_e series . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 21391}
{"snippet": "polynomial.hermite_e.hermeint(lbnd=0)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 21392}
{"snippet": "polynomial.hermite_e.hermeint(scl=1)", "intent": "Integrate a Hermite_e series . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 21393}
{"snippet": "polynomial.hermite_e.hermeint(axis=0)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 21394}
{"snippet": "polynomial.hermite_e.hermeint(m=1, k=)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 21395}
{"snippet": "polynomial.hermite_e.hermeint(m=1, lbnd=0)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 21396}
{"snippet": "polynomial.hermite_e.hermeint(m=1, scl=1)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 21397}
{"snippet": "polynomial.hermite_e.hermeint(m=1, axis=0)", "intent": "Integrate a Hermite_e series . Returns the Hermite_e series coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 21398}
{"snippet": "ma.isMaskedArray(x)", "intent": "Test whether input is an instance of MaskedArray . This function returns True if `x` is an instance of MaskedArray and returns False otherwise . numpy", "question_id": 21399}
{"snippet": "random.Generator.random()", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) . numpy", "question_id": 21400}
{"snippet": "random.Generator.random(size=None)", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) . With arguments `size`. numpy", "question_id": 21401}
{"snippet": "random.Generator.random(dtype=np.float64)", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) . With arguments `dtype`. numpy", "question_id": 21402}
{"snippet": "random.Generator.random(out=None)", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) . With arguments `out`. numpy", "question_id": 21403}
{"snippet": "random.Generator.random(size=None, dtype=np.float64)", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) . With arguments `size`, `dtype`. numpy", "question_id": 21404}
{"snippet": "random.Generator.random(size=None, out=None)", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) . With arguments `size`, `out`. numpy", "question_id": 21405}
{"snippet": "random.Generator.random(dtype=np.float64, out=None)", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) . With arguments `dtype`, `out`. numpy", "question_id": 21406}
{"snippet": "random.Generator.random(size=None, dtype=np.float64, out=None)", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) . With arguments `size`, `dtype`, `out`. numpy", "question_id": 21407}
{"snippet": "dtype.subdtype", "intent": "Tuple (item_dtype, shape) if this dtype describes a sub-array, and None otherwise. numpy", "question_id": 21408}
{"snippet": "numpy.format_float_scientific(x)", "intent": "Format a floating-point scalar as a decimal string in scientific notation . With arguments `x`. numpy", "question_id": 21409}
{"snippet": "numpy.format_float_scientific(x, precision=None)", "intent": "Format a floating-point scalar as a decimal string in scientific notation . With arguments `x`, `precision`. numpy", "question_id": 21410}
{"snippet": "numpy.format_float_scientific(x, unique=True)", "intent": "Format a floating-point scalar as a decimal string in scientific notation . With arguments `x`, `unique`. numpy", "question_id": 21411}
{"snippet": "numpy.format_float_scientific(x, trim='k')", "intent": "Format a floating-point scalar as a decimal string in scientific notation . With arguments `x`, `trim`. numpy", "question_id": 21412}
{"snippet": "numpy.format_float_scientific(x, sign=False)", "intent": "Format a floating-point scalar as a decimal string in scientific notation . With arguments `x`, `sign`. numpy", "question_id": 21413}
{"snippet": "numpy.format_float_scientific(x, pad_left=None)", "intent": "Format a floating-point scalar as a decimal string in scientific notation . With arguments `x`, `pad_left`. numpy", "question_id": 21414}
{"snippet": "numpy.format_float_scientific(x, exp_digits=None)", "intent": "Format a floating-point scalar as a decimal string in scientific notation . With arguments `x`, `exp_digits`. numpy", "question_id": 21415}
{"snippet": "numpy.format_float_scientific(x, min_digits=None)", "intent": "Format a floating-point scalar as a decimal string in scientific notation . With arguments `x`, `min_digits`. numpy", "question_id": 21416}
{"snippet": "numpy.format_float_scientific(x, precision=None, unique=True)", "intent": "Format a floating-point scalar as a decimal string in scientific notation . With arguments `x`, `precision`, `unique`. numpy", "question_id": 21417}
{"snippet": "numpy.format_float_scientific(x, precision=None, trim='k')", "intent": "Format a floating-point scalar as a decimal string in scientific notation . With arguments `x`, `precision`, `trim`. numpy", "question_id": 21418}
{"snippet": "random.RandomState.chisquare(df)", "intent": "Draw samples from a chi-square distribution . When `df` independent random variables , each with standard normal distributions ( mean 0 , variance 1 ) , are squared and summed , the resulting distribution is chi-square ( see Notes ) . numpy", "question_id": 21419}
{"snippet": "random.RandomState.chisquare(df, size=None)", "intent": "Draw samples from a chi-square distribution . When `df` independent random variables , each with standard normal distributions ( mean 0 , variance 1 ) , are squared and summed , the resulting distribution is chi-square ( see Notes ) . With arguments `size`. numpy", "question_id": 21420}
{"snippet": "ma.frombuffer(buffer)", "intent": "Interpret a `buffer` as a 1-dimensional array . numpy", "question_id": 21421}
{"snippet": "ma.frombuffer(buffer, dtype=float)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `dtype`. numpy", "question_id": 21422}
{"snippet": "ma.frombuffer(buffer, count=- 1)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `count`. numpy", "question_id": 21423}
{"snippet": "ma.frombuffer(buffer, offset=0)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `offset`. numpy", "question_id": 21424}
{"snippet": "ma.frombuffer(buffer, like=None)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `like`. numpy", "question_id": 21425}
{"snippet": "ma.frombuffer(buffer, dtype=float, count=- 1)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `dtype`, `count`. numpy", "question_id": 21426}
{"snippet": "ma.frombuffer(buffer, dtype=float, offset=0)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `dtype`, `offset`. numpy", "question_id": 21427}
{"snippet": "ma.frombuffer(buffer, dtype=float, like=None)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `dtype`, `like`. numpy", "question_id": 21428}
{"snippet": "ma.frombuffer(buffer, count=- 1, offset=0)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `count`, `offset`. numpy", "question_id": 21429}
{"snippet": "ma.frombuffer(buffer, count=- 1, like=None)", "intent": "Interpret a `buffer` as a 1-dimensional array . With arguments `count`, `like`. numpy", "question_id": 21430}
{"snippet": "numpy.poly1d(c_or_r)", "intent": "A one-dimensional polynomial class . With arguments `c_or_r`. numpy", "question_id": 21431}
{"snippet": "numpy.poly1d(c_or_r, r=False)", "intent": "A one-dimensional polynomial class . With arguments `c_or_r`, `r`. numpy", "question_id": 21432}
{"snippet": "numpy.poly1d(c_or_r, variable=None)", "intent": "A one-dimensional polynomial class . The `variable` used in the string representation of p can be modified , using the variable parameter : With arguments `c_or_r`. numpy", "question_id": 21433}
{"snippet": "numpy.poly1d(c_or_r, r=False, variable=None)", "intent": "A one-dimensional polynomial class . The `variable` used in the string representation of p can be modified , using the variable parameter : With arguments `c_or_r`, `r`. numpy", "question_id": 21434}
{"snippet": "ma.MaskType.swapaxes()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 21435}
{"snippet": "record.itemsize", "intent": "The length of one element in bytes. numpy", "question_id": 21436}
{"snippet": "ma.MaskedArray.__getitem__(indx)", "intent": "x.__getitem__ ( y ) < == > x [ y ] With arguments `indx`. numpy", "question_id": 21437}
{"snippet": "ma.MaskedArray.trace()", "intent": "Return the sum along diagonals of the array . numpy", "question_id": 21438}
{"snippet": "ma.MaskedArray.trace(offset=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`. numpy", "question_id": 21439}
{"snippet": "ma.MaskedArray.trace(axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `axis1`. numpy", "question_id": 21440}
{"snippet": "ma.MaskedArray.trace(axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `axis2`. numpy", "question_id": 21441}
{"snippet": "ma.MaskedArray.trace(dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `dtype`. numpy", "question_id": 21442}
{"snippet": "ma.MaskedArray.trace(out=None)", "intent": "Return the sum along diagonals of the array . With arguments `out`. numpy", "question_id": 21443}
{"snippet": "ma.MaskedArray.trace(offset=0, axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis1`. numpy", "question_id": 21444}
{"snippet": "ma.MaskedArray.trace(offset=0, axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis2`. numpy", "question_id": 21445}
{"snippet": "ma.MaskedArray.trace(offset=0, dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `dtype`. numpy", "question_id": 21446}
{"snippet": "ma.MaskedArray.trace(offset=0, out=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `out`. numpy", "question_id": 21447}
{"snippet": "polynomial.hermite_e.HermiteE.has_samewindow(other)", "intent": "Check if windows match . With arguments `other`. numpy", "question_id": 21448}
{"snippet": "polynomial.set_default_printstyle(style)", "intent": "Set the default format for the string representation of polynomials . Values for `style` must be valid inputs to __format__ , i.e . numpy", "question_id": 21449}
{"snippet": "dtype.alignment", "intent": "The required alignment (bytes) of this data-type according to the compiler. numpy", "question_id": 21450}
{"snippet": "chararray.conj()", "intent": "Complex-conjugate all elements . numpy", "question_id": 21451}
{"snippet": "polynomial.hermite_e.HermiteE.integ()", "intent": "Integrate . numpy", "question_id": 21452}
{"snippet": "polynomial.hermite_e.HermiteE.integ(m=1)", "intent": "Integrate . With arguments `m`. numpy", "question_id": 21453}
{"snippet": "polynomial.hermite_e.HermiteE.integ(k=)", "intent": "Integrate . With arguments `k`. numpy", "question_id": 21454}
{"snippet": "polynomial.hermite_e.HermiteE.integ(lbnd=None)", "intent": "Integrate . With arguments `lbnd`. numpy", "question_id": 21455}
{"snippet": "polynomial.hermite_e.HermiteE.integ(m=1, k=)", "intent": "Integrate . With arguments `m`, `k`. numpy", "question_id": 21456}
{"snippet": "polynomial.hermite_e.HermiteE.integ(m=1, lbnd=None)", "intent": "Integrate . With arguments `m`, `lbnd`. numpy", "question_id": 21457}
{"snippet": "polynomial.hermite_e.HermiteE.integ(k=, lbnd=None)", "intent": "Integrate . With arguments `k`, `lbnd`. numpy", "question_id": 21458}
{"snippet": "polynomial.hermite_e.HermiteE.integ(m=1, k=, lbnd=None)", "intent": "Integrate . With arguments `m`, `k`, `lbnd`. numpy", "question_id": 21459}
{"snippet": "polynomial.hermite_e.HermiteE.integ()", "intent": "Integrate . numpy", "question_id": 21460}
{"snippet": "polynomial.hermite_e.HermiteE.integ(m=1)", "intent": "Integrate . With arguments `m`. numpy", "question_id": 21461}
{"snippet": "polynomial.hermite_e.HermiteE.integ(k=)", "intent": "Integrate . With arguments `k`. numpy", "question_id": 21462}
{"snippet": "polynomial.hermite_e.HermiteE.integ(lbnd=None)", "intent": "Integrate . With arguments `lbnd`. numpy", "question_id": 21463}
{"snippet": "polynomial.hermite_e.HermiteE.integ(m=1, k=)", "intent": "Integrate . With arguments `m`, `k`. numpy", "question_id": 21464}
{"snippet": "polynomial.hermite_e.HermiteE.integ(m=1, lbnd=None)", "intent": "Integrate . With arguments `m`, `lbnd`. numpy", "question_id": 21465}
{"snippet": "polynomial.hermite_e.HermiteE.integ(k=, lbnd=None)", "intent": "Integrate . With arguments `k`, `lbnd`. numpy", "question_id": 21466}
{"snippet": "polynomial.hermite_e.HermiteE.integ(m=1, k=, lbnd=None)", "intent": "Integrate . With arguments `m`, `k`, `lbnd`. numpy", "question_id": 21467}
{"snippet": "numpy.tril_indices_from(arr)", "intent": "Return the indices for the lower-triangle of `arr` . numpy", "question_id": 21468}
{"snippet": "numpy.tril_indices_from(arr, k=0)", "intent": "Return the indices for the lower-triangle of `arr` . With arguments `k`. numpy", "question_id": 21469}
{"snippet": "char.split(a)", "intent": "For each element in `a` , return a list of the words in the string , using `sep` as the delimiter string . numpy", "question_id": 21470}
{"snippet": "char.split(a, sep=None)", "intent": "For each element in `a` , return a list of the words in the string , using `sep` as the delimiter string . numpy", "question_id": 21471}
{"snippet": "char.split(a, maxsplit=None)", "intent": "For each element in `a` , return a list of the words in the string , using `sep` as the delimiter string . With arguments `maxsplit`. numpy", "question_id": 21472}
{"snippet": "char.split(a, sep=None, maxsplit=None)", "intent": "For each element in `a` , return a list of the words in the string , using `sep` as the delimiter string . With arguments `maxsplit`. numpy", "question_id": 21473}
{"snippet": "ma.masked_array.reshape(*s, **kwargs)", "intent": "Give a new shape to the array without changing its data . With arguments `*s`, `**kwargs`. numpy", "question_id": 21474}
{"snippet": "char.chararray.conj()", "intent": "Complex-conjugate all elements . numpy", "question_id": 21475}
{"snippet": "numpy.fromstring(string)", "intent": "A new 1-D array initialized from text data in a `string` . numpy", "question_id": 21476}
{"snippet": "numpy.fromstring(string, dtype=float)", "intent": "A new 1-D array initialized from text data in a `string` . With arguments `dtype`. numpy", "question_id": 21477}
{"snippet": "numpy.fromstring(string, count=- 1)", "intent": "A new 1-D array initialized from text data in a `string` . With arguments `count`. numpy", "question_id": 21478}
{"snippet": "numpy.fromstring(string, sep='')", "intent": "A new 1-D array initialized from text data in a `string` . With arguments `sep`. numpy", "question_id": 21479}
{"snippet": "numpy.fromstring(string, like=None)", "intent": "A new 1-D array initialized from text data in a `string` . With arguments `like`. numpy", "question_id": 21480}
{"snippet": "numpy.fromstring(string, dtype=float, count=- 1)", "intent": "A new 1-D array initialized from text data in a `string` . With arguments `dtype`, `count`. numpy", "question_id": 21481}
{"snippet": "numpy.fromstring(string, dtype=float, sep='')", "intent": "A new 1-D array initialized from text data in a `string` . With arguments `dtype`, `sep`. numpy", "question_id": 21482}
{"snippet": "numpy.fromstring(string, dtype=float, like=None)", "intent": "A new 1-D array initialized from text data in a `string` . With arguments `dtype`, `like`. numpy", "question_id": 21483}
{"snippet": "numpy.fromstring(string, count=- 1, sep='')", "intent": "A new 1-D array initialized from text data in a `string` . With arguments `count`, `sep`. numpy", "question_id": 21484}
{"snippet": "numpy.fromstring(string, count=- 1, like=None)", "intent": "A new 1-D array initialized from text data in a `string` . With arguments `count`, `like`. numpy", "question_id": 21485}
{"snippet": "ma.MaskedArray.toflex()", "intent": "Transforms a masked array into a flexible-type array . numpy", "question_id": 21486}
{"snippet": "random.RandomState.weibull(a)", "intent": "Draw samples from `a` Weibull distribution . numpy", "question_id": 21487}
{"snippet": "random.RandomState.weibull(a, size=None)", "intent": "Draw samples from `a` Weibull distribution . With arguments `size`. numpy", "question_id": 21488}
{"snippet": "matrix.dumps()", "intent": "Returns the pickle of the array as a string . numpy", "question_id": 21489}
{"snippet": "polynomial.hermite_e.HermiteE.truncate(size)", "intent": "Truncate series to length `size` . numpy", "question_id": 21490}
{"snippet": "polynomial.chebyshev.chebtrim(c)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . With arguments `c`. numpy", "question_id": 21491}
{"snippet": "polynomial.chebyshev.chebtrim(c, tol=0)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . \u201c Small \u201d means \u201c small in absolute value \u201d and is controlled by the parameter `tol` ; \u201c trailing \u201d means highest order coefficient ( s ) , e.g. , in [ 0 , 1 , 1 , 0 , 0 ] ( which represents 0 + x + x * * 2 + 0 * x * * 3 + 0 * x * * 4 ) both the 3-rd and 4-th order coefficients would be \u201c trimmed . \u201d With arguments `c`. numpy", "question_id": 21492}
{"snippet": "numpy.heaviside(x1, x2, /, signature, extobj)", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `extobj`. numpy", "question_id": 21493}
{"snippet": "numpy.heaviside(x1, x2, /, signature, extobj, out=None)", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 21494}
{"snippet": "numpy.heaviside(x1, x2, /, signature, extobj, where=True)", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `extobj`. numpy", "question_id": 21495}
{"snippet": "numpy.heaviside(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 21496}
{"snippet": "numpy.heaviside(x1, x2, /, signature, extobj, order='K')", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 21497}
{"snippet": "numpy.heaviside(x1, x2, /, signature, extobj, dtype=None)", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 21498}
{"snippet": "numpy.heaviside(x1, x2, /, signature, extobj, subok=True)", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 21499}
{"snippet": "numpy.heaviside(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 21500}
{"snippet": "numpy.heaviside(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 21501}
{"snippet": "numpy.heaviside(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 21502}
{"snippet": "numpy.heaviside(x1, x2, /, signature)", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`. numpy", "question_id": 21503}
{"snippet": "numpy.heaviside(x1, x2, /, signature, out=None)", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `out`. numpy", "question_id": 21504}
{"snippet": "numpy.heaviside(x1, x2, /, signature, where=True)", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`. numpy", "question_id": 21505}
{"snippet": "numpy.heaviside(x1, x2, /, signature, casting='same_kind')", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `casting`. numpy", "question_id": 21506}
{"snippet": "numpy.heaviside(x1, x2, /, signature, order='K')", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `order`. numpy", "question_id": 21507}
{"snippet": "numpy.heaviside(x1, x2, /, signature, dtype=None)", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `dtype`. numpy", "question_id": 21508}
{"snippet": "numpy.heaviside(x1, x2, /, signature, subok=True)", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `subok`. numpy", "question_id": 21509}
{"snippet": "numpy.heaviside(x1, x2, /, signature, out=None, where=True)", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `out`. numpy", "question_id": 21510}
{"snippet": "numpy.heaviside(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `out`, `casting`. numpy", "question_id": 21511}
{"snippet": "numpy.heaviside(x1, x2, /, signature, out=None, order='K')", "intent": "Compute the Heaviside step function . `where` `x2` is often taken to be 0.5 , but 0 and 1 are also sometimes used . With arguments `x1`, `/`, `signature`, `out`, `order`. numpy", "question_id": 21512}
{"snippet": "polynomial.hermite_e.HermiteE.has_sametype(other)", "intent": "Check if types match . With arguments `other`. numpy", "question_id": 21513}
{"snippet": "numpy.array_split(ary, indices_or_sections)", "intent": "Split an array into multiple sub-arrays . The only difference between these functions is that array_split allows `indices_or_sections` to be an integer that does not equally divide the `axis` . With arguments `ary`. numpy", "question_id": 21514}
{"snippet": "numpy.array_split(ary, indices_or_sections, axis=0)", "intent": "Split an array into multiple sub-arrays . The only difference between these functions is that array_split allows `indices_or_sections` to be an integer that does not equally divide the `axis` . With arguments `ary`. numpy", "question_id": 21515}
{"snippet": "ma.MaskedArray.diagonal()", "intent": "Return specified diagonals . numpy", "question_id": 21516}
{"snippet": "ma.MaskedArray.diagonal(offset=0)", "intent": "Return specified diagonals . With arguments `offset`. numpy", "question_id": 21517}
{"snippet": "ma.MaskedArray.diagonal(axis1=0)", "intent": "Return specified diagonals . With arguments `axis1`. numpy", "question_id": 21518}
{"snippet": "ma.MaskedArray.diagonal(axis2=1)", "intent": "Return specified diagonals . With arguments `axis2`. numpy", "question_id": 21519}
{"snippet": "ma.MaskedArray.diagonal(offset=0, axis1=0)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`. numpy", "question_id": 21520}
{"snippet": "ma.MaskedArray.diagonal(offset=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis2`. numpy", "question_id": 21521}
{"snippet": "ma.MaskedArray.diagonal(axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `axis1`, `axis2`. numpy", "question_id": 21522}
{"snippet": "ma.MaskedArray.diagonal(offset=0, axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`, `axis2`. numpy", "question_id": 21523}
{"snippet": "ma.masked_array.toflex()", "intent": "Transforms a masked array into a flexible-type array . numpy", "question_id": 21524}
{"snippet": "chararray.tofile(fid)", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . numpy", "question_id": 21525}
{"snippet": "chararray.tofile(fid, sep='')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `sep`. numpy", "question_id": 21526}
{"snippet": "chararray.tofile(fid, format='%s')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `format`. numpy", "question_id": 21527}
{"snippet": "chararray.tofile(fid, sep='', format='%s')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `sep`, `format`. numpy", "question_id": 21528}
{"snippet": "distutils.exec_command.find_executable(exe)", "intent": "Return full `path` of a executable or None . With arguments `exe`. numpy", "question_id": 21529}
{"snippet": "distutils.exec_command.find_executable(exe, path=None)", "intent": "Return full `path` of a executable or None . With arguments `exe`. numpy", "question_id": 21530}
{"snippet": "distutils.exec_command.find_executable(exe, _cache={})", "intent": "Return full `path` of a executable or None . With arguments `exe`, `_cache`. numpy", "question_id": 21531}
{"snippet": "distutils.exec_command.find_executable(exe, path=None, _cache={})", "intent": "Return full `path` of a executable or None . With arguments `exe`, `_cache`. numpy", "question_id": 21532}
{"snippet": "char.chararray.startswith(prefix)", "intent": "Returns a boolean array which is True where the string element in self starts with `prefix` , otherwise False . numpy", "question_id": 21533}
{"snippet": "char.chararray.startswith(prefix, start=0)", "intent": "Returns a boolean array which is True where the string element in self starts with `prefix` , otherwise False . With arguments `start`. numpy", "question_id": 21534}
{"snippet": "char.chararray.startswith(prefix, end=None)", "intent": "Returns a boolean array which is True where the string element in self starts with `prefix` , otherwise False . With arguments `end`. numpy", "question_id": 21535}
{"snippet": "char.chararray.startswith(prefix, start=0, end=None)", "intent": "Returns a boolean array which is True where the string element in self starts with `prefix` , otherwise False . With arguments `start`, `end`. numpy", "question_id": 21536}
{"snippet": "matrix.real", "intent": "The real part of the array. numpy", "question_id": 21537}
{"snippet": "ma.MaskType.imag", "intent": "The imaginary part of the scalar. numpy", "question_id": 21538}
{"snippet": "polynomial.hermite_e.hermegrid2d(x, y, c)", "intent": "Evaluate a 2-D HermiteE series on the Cartesian product of `x` and `y` . In either case , either x and y or their elements must support multiplication and addition both with themselves and with the elements of `c` . numpy", "question_id": 21539}
{"snippet": "dtype.names", "intent": "Ordered list of field names, or None if there are no fields. numpy", "question_id": 21540}
{"snippet": "recarray.any()", "intent": "Returns True if any of the elements of a evaluate to True . numpy", "question_id": 21541}
{"snippet": "recarray.any(axis=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`. numpy", "question_id": 21542}
{"snippet": "recarray.any(out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`. numpy", "question_id": 21543}
{"snippet": "recarray.any(keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `keepdims`. numpy", "question_id": 21544}
{"snippet": "recarray.any(where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `where`. numpy", "question_id": 21545}
{"snippet": "recarray.any(axis=None, out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `out`. numpy", "question_id": 21546}
{"snippet": "recarray.any(axis=None, keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `keepdims`. numpy", "question_id": 21547}
{"snippet": "recarray.any(axis=None, where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `where`. numpy", "question_id": 21548}
{"snippet": "recarray.any(out=None, keepdims=False)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`, `keepdims`. numpy", "question_id": 21549}
{"snippet": "recarray.any(out=None, where=True)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`, `where`. numpy", "question_id": 21550}
{"snippet": "numpy.lexsort(keys)", "intent": "Perform an indirect stable sort using a sequence of `keys` . numpy", "question_id": 21551}
{"snippet": "numpy.lexsort(keys, axis=- 1)", "intent": "Perform an indirect stable sort using a sequence of `keys` . With arguments `axis`. numpy", "question_id": 21552}
{"snippet": "ma.MaskType.tostring()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 21553}
{"snippet": "polynomial.legendre.Legendre.degree()", "intent": "The degree of the series . numpy", "question_id": 21554}
{"snippet": "numpy.polynomial.hermite.Hermite(coef)", "intent": "An Hermite series class . With arguments `coef`. numpy", "question_id": 21555}
{"snippet": "numpy.polynomial.hermite.Hermite(coef, domain=None)", "intent": "An Hermite series class . With arguments `coef`, `domain`. numpy", "question_id": 21556}
{"snippet": "numpy.polynomial.hermite.Hermite(coef, window=None)", "intent": "An Hermite series class . With arguments `coef`, `window`. numpy", "question_id": 21557}
{"snippet": "numpy.polynomial.hermite.Hermite(coef, domain=None, window=None)", "intent": "An Hermite series class . With arguments `coef`, `domain`, `window`. numpy", "question_id": 21558}
{"snippet": "lib.format.read_array_header_2_0(fp)", "intent": "Read an array header from a filelike object using the 2.0 file format version . With arguments `fp`. numpy", "question_id": 21559}
{"snippet": "polynomial.hermite_e.HermiteE.linspace()", "intent": "Return x , y values at equally spaced points in `domain` . numpy", "question_id": 21560}
{"snippet": "polynomial.hermite_e.HermiteE.linspace(n=100)", "intent": "Return x , y values at equally spaced points in `domain` . Returns the x , y values at `n` linearly spaced points across the domain . numpy", "question_id": 21561}
{"snippet": "polynomial.hermite_e.HermiteE.linspace(domain=None)", "intent": "Return x , y values at equally spaced points in `domain` . numpy", "question_id": 21562}
{"snippet": "polynomial.hermite_e.HermiteE.linspace(n=100, domain=None)", "intent": "Return x , y values at equally spaced points in `domain` . Returns the x , y values at `n` linearly spaced points across the domain . numpy", "question_id": 21563}
{"snippet": "polynomial.polynomial.polyder(c)", "intent": "Differentiate a polynomial . Returns the polynomial coefficients `c` differentiated `m` times along `axis` . numpy", "question_id": 21564}
{"snippet": "polynomial.polynomial.polyder(c, m=1)", "intent": "Differentiate a polynomial . Returns the polynomial coefficients `c` differentiated `m` times along `axis` . numpy", "question_id": 21565}
{"snippet": "polynomial.polynomial.polyder(c, scl=1)", "intent": "Differentiate a polynomial . Returns the polynomial coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) . numpy", "question_id": 21566}
{"snippet": "polynomial.polynomial.polyder(c, axis=0)", "intent": "Differentiate a polynomial . Returns the polynomial coefficients `c` differentiated `m` times along `axis` . numpy", "question_id": 21567}
{"snippet": "polynomial.polynomial.polyder(c, m=1, scl=1)", "intent": "Differentiate a polynomial . Returns the polynomial coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) . numpy", "question_id": 21568}
{"snippet": "polynomial.polynomial.polyder(c, m=1, axis=0)", "intent": "Differentiate a polynomial . Returns the polynomial coefficients `c` differentiated `m` times along `axis` . numpy", "question_id": 21569}
{"snippet": "polynomial.polynomial.polyder(c, scl=1, axis=0)", "intent": "Differentiate a polynomial . Returns the polynomial coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) . numpy", "question_id": 21570}
{"snippet": "polynomial.polynomial.polyder(c, m=1, scl=1, axis=0)", "intent": "Differentiate a polynomial . Returns the polynomial coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) . numpy", "question_id": 21571}
{"snippet": "lib.stride_tricks.sliding_window_view(x, window_shape)", "intent": "Create a sliding window view into the array with the given window shape . With arguments `x`, `window_shape`. numpy", "question_id": 21572}
{"snippet": "lib.stride_tricks.sliding_window_view(x, window_shape, axis=None)", "intent": "Create a sliding window view into the array with the given window shape . The `axis` can be specified explicitly : With arguments `x`, `window_shape`. numpy", "question_id": 21573}
{"snippet": "lib.stride_tricks.sliding_window_view(x, window_shape, subok=False)", "intent": "Create a sliding window view into the array with the given window shape . With arguments `x`, `window_shape`, `subok`. numpy", "question_id": 21574}
{"snippet": "lib.stride_tricks.sliding_window_view(x, window_shape, writeable=False)", "intent": "Create a sliding window view into the array with the given window shape . With arguments `x`, `window_shape`, `writeable`. numpy", "question_id": 21575}
{"snippet": "lib.stride_tricks.sliding_window_view(x, window_shape, axis=None, subok=False)", "intent": "Create a sliding window view into the array with the given window shape . The `axis` can be specified explicitly : With arguments `x`, `window_shape`, `subok`. numpy", "question_id": 21576}
{"snippet": "lib.stride_tricks.sliding_window_view(x, window_shape, axis=None, writeable=False)", "intent": "Create a sliding window view into the array with the given window shape . The `axis` can be specified explicitly : With arguments `x`, `window_shape`, `writeable`. numpy", "question_id": 21577}
{"snippet": "lib.stride_tricks.sliding_window_view(x, window_shape, subok=False, writeable=False)", "intent": "Create a sliding window view into the array with the given window shape . With arguments `x`, `window_shape`, `subok`, `writeable`. numpy", "question_id": 21578}
{"snippet": "lib.stride_tricks.sliding_window_view(x, window_shape, axis=None, subok=False, writeable=False)", "intent": "Create a sliding window view into the array with the given window shape . The `axis` can be specified explicitly : With arguments `x`, `window_shape`, `subok`, `writeable`. numpy", "question_id": 21579}
{"snippet": "polynomial.laguerre.Laguerre.fit(x, y, deg)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`. numpy", "question_id": 21580}
{"snippet": "polynomial.laguerre.Laguerre.fit(x, y, deg, domain=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`. numpy", "question_id": 21581}
{"snippet": "polynomial.laguerre.Laguerre.fit(x, y, deg, rcond=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `rcond`. numpy", "question_id": 21582}
{"snippet": "polynomial.laguerre.Laguerre.fit(x, y, deg, full=False)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `full`. numpy", "question_id": 21583}
{"snippet": "polynomial.laguerre.Laguerre.fit(x, y, deg, w=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `w`. numpy", "question_id": 21584}
{"snippet": "polynomial.laguerre.Laguerre.fit(x, y, deg, window=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `window`. numpy", "question_id": 21585}
{"snippet": "polynomial.laguerre.Laguerre.fit(x, y, deg, domain=None, rcond=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `rcond`. numpy", "question_id": 21586}
{"snippet": "polynomial.laguerre.Laguerre.fit(x, y, deg, domain=None, full=False)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `full`. numpy", "question_id": 21587}
{"snippet": "polynomial.laguerre.Laguerre.fit(x, y, deg, domain=None, w=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `w`. numpy", "question_id": 21588}
{"snippet": "polynomial.laguerre.Laguerre.fit(x, y, deg, domain=None, window=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `window`. numpy", "question_id": 21589}
{"snippet": "polynomial.hermite.hermsub(c1, c2)", "intent": "Subtract one Hermite series from another . Returns the difference of two Hermite series `c1` - `c2` . numpy", "question_id": 21590}
{"snippet": "numpy.logaddexp(x1, x2, /, signature, extobj)", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 21591}
{"snippet": "numpy.logaddexp(x1, x2, /, signature, extobj, out=None)", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 21592}
{"snippet": "numpy.logaddexp(x1, x2, /, signature, extobj, where=True)", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . This function is useful in statistics `where` the calculated probabilities of events may be so small as to exceed the range of normal floating point numbers . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 21593}
{"snippet": "numpy.logaddexp(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 21594}
{"snippet": "numpy.logaddexp(x1, x2, /, signature, extobj, order='K')", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 21595}
{"snippet": "numpy.logaddexp(x1, x2, /, signature, extobj, dtype=None)", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 21596}
{"snippet": "numpy.logaddexp(x1, x2, /, signature, extobj, subok=True)", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 21597}
{"snippet": "numpy.logaddexp(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . This function is useful in statistics `where` the calculated probabilities of events may be so small as to exceed the range of normal floating point numbers . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 21598}
{"snippet": "numpy.logaddexp(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 21599}
{"snippet": "numpy.logaddexp(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 21600}
{"snippet": "numpy.logaddexp(x1, x2, /, signature)", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`. numpy", "question_id": 21601}
{"snippet": "numpy.logaddexp(x1, x2, /, signature, out=None)", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `out`. numpy", "question_id": 21602}
{"snippet": "numpy.logaddexp(x1, x2, /, signature, where=True)", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . This function is useful in statistics `where` the calculated probabilities of events may be so small as to exceed the range of normal floating point numbers . With arguments `/`, `signature`. numpy", "question_id": 21603}
{"snippet": "numpy.logaddexp(x1, x2, /, signature, casting='same_kind')", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `casting`. numpy", "question_id": 21604}
{"snippet": "numpy.logaddexp(x1, x2, /, signature, order='K')", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `order`. numpy", "question_id": 21605}
{"snippet": "numpy.logaddexp(x1, x2, /, signature, dtype=None)", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 21606}
{"snippet": "numpy.logaddexp(x1, x2, /, signature, subok=True)", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `subok`. numpy", "question_id": 21607}
{"snippet": "numpy.logaddexp(x1, x2, /, signature, out=None, where=True)", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . This function is useful in statistics `where` the calculated probabilities of events may be so small as to exceed the range of normal floating point numbers . With arguments `/`, `signature`, `out`. numpy", "question_id": 21608}
{"snippet": "numpy.logaddexp(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 21609}
{"snippet": "numpy.logaddexp(x1, x2, /, signature, out=None, order='K')", "intent": "Logarithm of the sum of exponentiations of the inputs . Calculates log ( exp ( `x1` ) + exp ( `x2` ) ) . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 21610}
{"snippet": "polynomial.laguerre.lagroots(c)", "intent": "Compute the roots of a Laguerre series . With arguments `c`. numpy", "question_id": 21611}
{"snippet": "ma.MaskType.var()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 21612}
{"snippet": "polynomial.hermite.Hermite.basis(deg)", "intent": "Series basis polynomial of degree `deg` . numpy", "question_id": 21613}
{"snippet": "polynomial.hermite.Hermite.basis(deg, domain=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `domain`. numpy", "question_id": 21614}
{"snippet": "polynomial.hermite.Hermite.basis(deg, window=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `window`. numpy", "question_id": 21615}
{"snippet": "polynomial.hermite.Hermite.basis(deg, domain=None, window=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `domain`, `window`. numpy", "question_id": 21616}
{"snippet": "polynomial.polyutils.as_series(alist)", "intent": "Return argument as a list of 1-d arrays . With arguments `alist`. numpy", "question_id": 21617}
{"snippet": "polynomial.polyutils.as_series(alist, trim=True)", "intent": "Return argument as a list of 1-d arrays . With arguments `alist`, `trim`. numpy", "question_id": 21618}
{"snippet": "numpy.dsplit(ary, indices_or_sections)", "intent": "Split array into multiple sub-arrays along the 3rd axis ( depth ) . With arguments `ary`, `indices_or_sections`. numpy", "question_id": 21619}
{"snippet": "numpy.isclose(a, b)", "intent": "Returns `a` boolean array where two arrays are element-wise equal within a tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b . numpy", "question_id": 21620}
{"snippet": "numpy.isclose(a, b, rtol=1e-05)", "intent": "Returns `a` boolean array where two arrays are element-wise equal within a tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b . numpy", "question_id": 21621}
{"snippet": "numpy.isclose(a, b, atol=1e-08)", "intent": "Returns `a` boolean array where two arrays are element-wise equal within a tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b . numpy", "question_id": 21622}
{"snippet": "numpy.isclose(a, b, equal_nan=False)", "intent": "Returns `a` boolean array where two arrays are element-wise equal within a tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b . With arguments `equal_nan`. numpy", "question_id": 21623}
{"snippet": "numpy.isclose(a, b, rtol=1e-05, atol=1e-08)", "intent": "Returns `a` boolean array where two arrays are element-wise equal within a tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b . numpy", "question_id": 21624}
{"snippet": "numpy.isclose(a, b, rtol=1e-05, equal_nan=False)", "intent": "Returns `a` boolean array where two arrays are element-wise equal within a tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b . With arguments `equal_nan`. numpy", "question_id": 21625}
{"snippet": "numpy.isclose(a, b, atol=1e-08, equal_nan=False)", "intent": "Returns `a` boolean array where two arrays are element-wise equal within a tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b . With arguments `equal_nan`. numpy", "question_id": 21626}
{"snippet": "numpy.isclose(a, b, rtol=1e-05, atol=1e-08, equal_nan=False)", "intent": "Returns `a` boolean array where two arrays are element-wise equal within a tolerance . The relative difference ( `rtol` * abs ( `b` ) ) and the absolute difference `atol` are added together to compare against the absolute difference between a and b . With arguments `equal_nan`. numpy", "question_id": 21627}
{"snippet": "record.compress()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 21628}
{"snippet": "random.RandomState.randn(d0, d1, dn)", "intent": "Return a sample ( or samples ) from the \u201c standard normal \u201d distribution . If positive int_like arguments are provided , randn generates an array of shape ( `d0` , `d1` , ... , `dn` ) , filled with random floats sampled from a univariate \u201c normal \u201d ( Gaussian ) distribution of mean 0 and variance 1 . numpy", "question_id": 21629}
{"snippet": "ma.MaskType.ravel()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 21630}
{"snippet": "numpy.byte_bounds(a)", "intent": "Returns pointers to the end-points of an array . With arguments `a`. numpy", "question_id": 21631}
{"snippet": "random.RandomState.vonmises(mu, kappa)", "intent": "Draw samples from a von Mises distribution . Samples are drawn from a von Mises distribution with specified mode ( `mu` ) and dispersion ( `kappa` ) , on the interval [ -pi , pi ] . numpy", "question_id": 21632}
{"snippet": "random.RandomState.vonmises(mu, kappa, size=None)", "intent": "Draw samples from a von Mises distribution . Samples are drawn from a von Mises distribution with specified mode ( `mu` ) and dispersion ( `kappa` ) , on the interval [ -pi , pi ] . With arguments `size`. numpy", "question_id": 21633}
{"snippet": "ndarray.__ipow__(value, /)", "intent": "Return self * * =value . With arguments `value`, `/`. numpy", "question_id": 21634}
{"snippet": "record.sort()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 21635}
{"snippet": "chararray.dtype", "intent": "Data-type of the array\u2019s elements. numpy", "question_id": 21636}
{"snippet": "fft.ifft(a)", "intent": "Compute the one-dimensional inverse discrete Fourier Transform . In other words , ifft ( fft ( `a` ) ) == a to within numerical accuracy . numpy", "question_id": 21637}
{"snippet": "fft.ifft(a, n=None)", "intent": "Compute the one-dimensional inverse discrete Fourier Transform . In other words , ifft ( fft ( `a` ) ) == a to within numerical accuracy . If the input parameter `n` is larger than the size of the input , the input is padded by appending zeros at the end . numpy", "question_id": 21638}
{"snippet": "fft.ifft(a, axis=- 1)", "intent": "Compute the one-dimensional inverse discrete Fourier Transform . In other words , ifft ( fft ( `a` ) ) == a to within numerical accuracy . With arguments `axis`. numpy", "question_id": 21639}
{"snippet": "fft.ifft(a, norm=None)", "intent": "Compute the one-dimensional inverse discrete Fourier Transform . In other words , ifft ( fft ( `a` ) ) == a to within numerical accuracy . With arguments `norm`. numpy", "question_id": 21640}
{"snippet": "fft.ifft(a, n=None, axis=- 1)", "intent": "Compute the one-dimensional inverse discrete Fourier Transform . In other words , ifft ( fft ( `a` ) ) == a to within numerical accuracy . If the input parameter `n` is larger than the size of the input , the input is padded by appending zeros at the end . With arguments `axis`. numpy", "question_id": 21641}
{"snippet": "fft.ifft(a, n=None, norm=None)", "intent": "Compute the one-dimensional inverse discrete Fourier Transform . In other words , ifft ( fft ( `a` ) ) == a to within numerical accuracy . If the input parameter `n` is larger than the size of the input , the input is padded by appending zeros at the end . With arguments `norm`. numpy", "question_id": 21642}
{"snippet": "fft.ifft(a, axis=- 1, norm=None)", "intent": "Compute the one-dimensional inverse discrete Fourier Transform . In other words , ifft ( fft ( `a` ) ) == a to within numerical accuracy . With arguments `axis`, `norm`. numpy", "question_id": 21643}
{"snippet": "fft.ifft(a, n=None, axis=- 1, norm=None)", "intent": "Compute the one-dimensional inverse discrete Fourier Transform . In other words , ifft ( fft ( `a` ) ) == a to within numerical accuracy . If the input parameter `n` is larger than the size of the input , the input is padded by appending zeros at the end . With arguments `axis`, `norm`. numpy", "question_id": 21644}
{"snippet": "ufunc.nout", "intent": "The number of outputs. numpy", "question_id": 21645}
{"snippet": "numpy.fromregex(file, regexp, dtype)", "intent": "Construct an array from a text `file` , using regular expression parsing . With arguments `regexp`, `dtype`. numpy", "question_id": 21646}
{"snippet": "numpy.fromregex(file, regexp, dtype, encoding=None)", "intent": "Construct an array from a text `file` , using regular expression parsing . With arguments `regexp`, `dtype`, `encoding`. numpy", "question_id": 21647}
{"snippet": "char.chararray.clip(**kwargs)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 21648}
{"snippet": "char.chararray.clip(**kwargs, min=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 21649}
{"snippet": "char.chararray.clip(**kwargs, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 21650}
{"snippet": "char.chararray.clip(**kwargs, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 21651}
{"snippet": "char.chararray.clip(**kwargs, min=None, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 21652}
{"snippet": "char.chararray.clip(**kwargs, min=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 21653}
{"snippet": "char.chararray.clip(**kwargs, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 21654}
{"snippet": "char.chararray.clip(**kwargs, min=None, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 21655}
{"snippet": "chararray.ravel(order)", "intent": "Return a flattened array . With arguments `order`. numpy", "question_id": 21656}
{"snippet": "chararray.ravel()", "intent": "Return a flattened array . numpy", "question_id": 21657}
{"snippet": "chararray.ctypes", "intent": "An object to simplify the interaction of the array with the ctypes module. numpy", "question_id": 21658}
{"snippet": "_ctypes.data", "intent": "A pointer to the memory area of the array as a Python integer. numpy", "question_id": 21659}
{"snippet": "_ctypes.shape", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the C-integer corresponding to dtype('p') on this platform. numpy", "question_id": 21660}
{"snippet": "_ctypes.strides", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the same as for the shape attribute. numpy", "question_id": 21661}
{"snippet": "_ctypes.data_as(obj)", "intent": "Return the data pointer cast to a particular c-types object . With arguments `obj`. numpy", "question_id": 21662}
{"snippet": "_ctypes.shape_as(obj)", "intent": "Return the shape tuple as an array of some other c-types type . With arguments `obj`. numpy", "question_id": 21663}
{"snippet": "_ctypes.strides_as(obj)", "intent": "Return the strides tuple as an array of some other c-types type . With arguments `obj`. numpy", "question_id": 21664}
{"snippet": "numpy.hstack(tup)", "intent": "Stack arrays in sequence horizontally ( column wise ) . With arguments `tup`. numpy", "question_id": 21665}
{"snippet": "polynomial.hermite_e.hermevander(x, deg)", "intent": "Pseudo-Vandermonde matrix of given degree . Returns the pseudo-Vandermonde matrix of degree `deg` and sample points `x` . numpy", "question_id": 21666}
{"snippet": "char.chararray.isnumeric()", "intent": "For each element in self , return True if there are only numeric characters in the element . numpy", "question_id": 21667}
{"snippet": "ndarray.copy()", "intent": "Return a copy of the array . numpy", "question_id": 21668}
{"snippet": "ndarray.copy(order='C')", "intent": "Return a copy of the array . The function numpy.copy is similar , but it defaults to using `order` \u2018 K \u2019 , and will not pass sub-classes through by default . numpy", "question_id": 21669}
{"snippet": "chararray.islower()", "intent": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character , false otherwise . numpy", "question_id": 21670}
{"snippet": "numpy.sinc(x)", "intent": "Return the normalized sinc function . The sinc function is \\ ( \\sin ( \\pi `x` ) / ( \\pi x ) \\ ) . numpy", "question_id": 21671}
{"snippet": "matrix.conjugate()", "intent": "Return the complex conjugate , element-wise . numpy", "question_id": 21672}
{"snippet": "polynomial.chebyshev.Chebyshev.mapparms()", "intent": "Return the mapping parameters . numpy", "question_id": 21673}
{"snippet": "polynomial.hermite.Hermite.has_sametype(other)", "intent": "Check if types match . With arguments `other`. numpy", "question_id": 21674}
{"snippet": "recarray.astype(dtype)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`. numpy", "question_id": 21675}
{"snippet": "recarray.astype(dtype, order='K')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`. numpy", "question_id": 21676}
{"snippet": "recarray.astype(dtype, casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`. numpy", "question_id": 21677}
{"snippet": "recarray.astype(dtype, subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `subok`. numpy", "question_id": 21678}
{"snippet": "recarray.astype(dtype, copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `copy`. numpy", "question_id": 21679}
{"snippet": "recarray.astype(dtype, order='K', casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `casting`. numpy", "question_id": 21680}
{"snippet": "recarray.astype(dtype, order='K', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `subok`. numpy", "question_id": 21681}
{"snippet": "recarray.astype(dtype, order='K', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `copy`. numpy", "question_id": 21682}
{"snippet": "recarray.astype(dtype, casting='unsafe', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `subok`. numpy", "question_id": 21683}
{"snippet": "recarray.astype(dtype, casting='unsafe', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `copy`. numpy", "question_id": 21684}
{"snippet": "memmap.ravel(order)", "intent": "Return a flattened array . With arguments `order`. numpy", "question_id": 21685}
{"snippet": "memmap.ravel()", "intent": "Return a flattened array . numpy", "question_id": 21686}
{"snippet": "chararray.compress(condition)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`. numpy", "question_id": 21687}
{"snippet": "chararray.compress(condition, axis=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`. numpy", "question_id": 21688}
{"snippet": "chararray.compress(condition, out=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`, `out`. numpy", "question_id": 21689}
{"snippet": "chararray.compress(condition, axis=None, out=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`, `out`. numpy", "question_id": 21690}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.dist_error(*args)", "intent": "Raise a compiler error With arguments `*args`. numpy", "question_id": 21691}
{"snippet": "polynomial.laguerre.lagdiv(c1, c2)", "intent": "Divide one Laguerre series by another . Returns the quotient-with-remainder of two Laguerre series `c1` / `c2` . numpy", "question_id": 21692}
{"snippet": "numpy.dtype", "intent": "Methods numpy", "question_id": 21693}
{"snippet": "numpy.polymul(a1, a2)", "intent": "Find the product of two polynomials . With arguments `a1`, `a2`. numpy", "question_id": 21694}
{"snippet": "chararray.copy()", "intent": "Return a copy of the array . numpy", "question_id": 21695}
{"snippet": "chararray.copy(order='C')", "intent": "Return a copy of the array . The function numpy.copy is similar , but it defaults to using `order` \u2018 K \u2019 , and will not pass sub-classes through by default . numpy", "question_id": 21696}
{"snippet": "ma.MaskedArray.flags", "intent": "Information about the memory layout of the array. numpy", "question_id": 21697}
{"snippet": "polynomial.laguerre.Laguerre.basis(deg)", "intent": "Series basis polynomial of degree `deg` . numpy", "question_id": 21698}
{"snippet": "polynomial.laguerre.Laguerre.basis(deg, domain=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `domain`. numpy", "question_id": 21699}
{"snippet": "polynomial.laguerre.Laguerre.basis(deg, window=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `window`. numpy", "question_id": 21700}
{"snippet": "polynomial.laguerre.Laguerre.basis(deg, domain=None, window=None)", "intent": "Series basis polynomial of degree `deg` . With arguments `domain`, `window`. numpy", "question_id": 21701}
{"snippet": "record.ndim", "intent": "The number of array dimensions. numpy", "question_id": 21702}
{"snippet": "memmap.getfield(dtype)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements . numpy", "question_id": 21703}
{"snippet": "memmap.getfield(dtype, offset=0)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements . The values in the view are determined by the given type and the `offset` into the current array in bytes . numpy", "question_id": 21704}
{"snippet": "polynomial.chebyshev.chebfit(x, y, deg)", "intent": "Least squares fit of Chebyshev series to data . Return the coefficients of a Chebyshev series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . numpy", "question_id": 21705}
{"snippet": "polynomial.chebyshev.chebfit(x, y, deg, rcond=None)", "intent": "Least squares fit of Chebyshev series to data . Return the coefficients of a Chebyshev series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . numpy", "question_id": 21706}
{"snippet": "polynomial.chebyshev.chebfit(x, y, deg, full=False)", "intent": "Least squares fit of Chebyshev series to data . Return the coefficients of a Chebyshev series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . With arguments `full`. numpy", "question_id": 21707}
{"snippet": "polynomial.chebyshev.chebfit(x, y, deg, w=None)", "intent": "Least squares fit of Chebyshev series to data . Return the coefficients of a Chebyshev series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values . numpy", "question_id": 21708}
{"snippet": "polynomial.chebyshev.chebfit(x, y, deg, rcond=None, full=False)", "intent": "Least squares fit of Chebyshev series to data . Return the coefficients of a Chebyshev series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . With arguments `full`. numpy", "question_id": 21709}
{"snippet": "polynomial.chebyshev.chebfit(x, y, deg, rcond=None, w=None)", "intent": "Least squares fit of Chebyshev series to data . Return the coefficients of a Chebyshev series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values . numpy", "question_id": 21710}
{"snippet": "polynomial.chebyshev.chebfit(x, y, deg, full=False, w=None)", "intent": "Least squares fit of Chebyshev series to data . Return the coefficients of a Chebyshev series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values . With arguments `full`. numpy", "question_id": 21711}
{"snippet": "polynomial.chebyshev.chebfit(x, y, deg, rcond=None, full=False, w=None)", "intent": "Least squares fit of Chebyshev series to data . Return the coefficients of a Chebyshev series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values . With arguments `full`. numpy", "question_id": 21712}
{"snippet": "polynomial.legendre.legpow(c, pow)", "intent": "Raise a Legendre series to a power . Returns the Legendre series `c` raised to the power `pow` . numpy", "question_id": 21713}
{"snippet": "polynomial.legendre.legpow(c, pow, maxpower=16)", "intent": "Raise a Legendre series to a power . Returns the Legendre series `c` raised to the power `pow` . With arguments `maxpower`. numpy", "question_id": 21714}
{"snippet": "recarray.mean()", "intent": "Returns the average of the array elements along given `axis` . numpy", "question_id": 21715}
{"snippet": "recarray.mean(axis=None)", "intent": "Returns the average of the array elements along given `axis` . numpy", "question_id": 21716}
{"snippet": "recarray.mean(dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 21717}
{"snippet": "recarray.mean(out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 21718}
{"snippet": "recarray.mean(keepdims=False)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`. numpy", "question_id": 21719}
{"snippet": "recarray.mean(where=True)", "intent": "Returns the average of the array elements along given `axis` . With arguments `where`. numpy", "question_id": 21720}
{"snippet": "recarray.mean(axis=None, dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 21721}
{"snippet": "recarray.mean(axis=None, out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 21722}
{"snippet": "recarray.mean(axis=None, keepdims=False)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`. numpy", "question_id": 21723}
{"snippet": "recarray.mean(axis=None, where=True)", "intent": "Returns the average of the array elements along given `axis` . With arguments `where`. numpy", "question_id": 21724}
{"snippet": "polynomial.hermite.hermdiv(c1, c2)", "intent": "Divide one Hermite series by another . Returns the quotient-with-remainder of two Hermite series `c1` / `c2` . numpy", "question_id": 21725}
{"snippet": "numpy.kaiser(M, beta)", "intent": "Return the Kaiser window . The Kaiser can approximate many other windows by varying the `beta` parameter . With arguments `M`. numpy", "question_id": 21726}
{"snippet": "ma.MaskType.all()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 21727}
{"snippet": "polynomial.laguerre.lagmul(c1, c2)", "intent": "Multiply one Laguerre series by another . Returns the product of two Laguerre series `c1` * `c2` . numpy", "question_id": 21728}
{"snippet": "testing.assert_array_max_ulp(a, b)", "intent": "Check that all items of arrays differ in at most N Units in the Last Place . With arguments `a`, `b`. numpy", "question_id": 21729}
{"snippet": "testing.assert_array_max_ulp(a, b, maxulp=1)", "intent": "Check that all items of arrays differ in at most N Units in the Last Place . With arguments `a`, `b`, `maxulp`. numpy", "question_id": 21730}
{"snippet": "testing.assert_array_max_ulp(a, b, dtype=None)", "intent": "Check that all items of arrays differ in at most N Units in the Last Place . With arguments `a`, `b`, `dtype`. numpy", "question_id": 21731}
{"snippet": "testing.assert_array_max_ulp(a, b, maxulp=1, dtype=None)", "intent": "Check that all items of arrays differ in at most N Units in the Last Place . With arguments `a`, `b`, `maxulp`, `dtype`. numpy", "question_id": 21732}
{"snippet": "polynomial.chebyshev.Chebyshev.has_sametype(other)", "intent": "Check if types match . With arguments `other`. numpy", "question_id": 21733}
{"snippet": "chararray.join(seq)", "intent": "Return a string which is the concatenation of the strings in the sequence `seq` . numpy", "question_id": 21734}
{"snippet": "numpy.fmax(x1, x2, /, signature, extobj)", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 21735}
{"snippet": "numpy.fmax(x1, x2, /, signature, extobj, out=None)", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 21736}
{"snippet": "numpy.fmax(x1, x2, /, signature, extobj, where=True)", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 21737}
{"snippet": "numpy.fmax(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 21738}
{"snippet": "numpy.fmax(x1, x2, /, signature, extobj, order='K')", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 21739}
{"snippet": "numpy.fmax(x1, x2, /, signature, extobj, dtype=None)", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 21740}
{"snippet": "numpy.fmax(x1, x2, /, signature, extobj, subok=True)", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 21741}
{"snippet": "numpy.fmax(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 21742}
{"snippet": "numpy.fmax(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 21743}
{"snippet": "numpy.fmax(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 21744}
{"snippet": "numpy.fmax(x1, x2, /, signature)", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`. numpy", "question_id": 21745}
{"snippet": "numpy.fmax(x1, x2, /, signature, out=None)", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`. numpy", "question_id": 21746}
{"snippet": "numpy.fmax(x1, x2, /, signature, where=True)", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `where`. numpy", "question_id": 21747}
{"snippet": "numpy.fmax(x1, x2, /, signature, casting='same_kind')", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `casting`. numpy", "question_id": 21748}
{"snippet": "numpy.fmax(x1, x2, /, signature, order='K')", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `order`. numpy", "question_id": 21749}
{"snippet": "numpy.fmax(x1, x2, /, signature, dtype=None)", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 21750}
{"snippet": "numpy.fmax(x1, x2, /, signature, subok=True)", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `subok`. numpy", "question_id": 21751}
{"snippet": "numpy.fmax(x1, x2, /, signature, out=None, where=True)", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 21752}
{"snippet": "numpy.fmax(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 21753}
{"snippet": "numpy.fmax(x1, x2, /, signature, out=None, order='K')", "intent": "Element-wise maximum of array elements . The fmax is equivalent to np.where ( `x1` > = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 21754}
{"snippet": "ma.is_mask(m)", "intent": "Return True if `m` is a valid , standard mask . numpy", "question_id": 21755}
{"snippet": "polynomial.laguerre.lagpow(c, pow)", "intent": "Raise a Laguerre series to a power . Returns the Laguerre series `c` raised to the power `pow` . numpy", "question_id": 21756}
{"snippet": "polynomial.laguerre.lagpow(c, pow, maxpower=16)", "intent": "Raise a Laguerre series to a power . Returns the Laguerre series `c` raised to the power `pow` . With arguments `maxpower`. numpy", "question_id": 21757}
{"snippet": "matrix.dot(b)", "intent": "Dot product of two arrays . With arguments `b`. numpy", "question_id": 21758}
{"snippet": "matrix.dot(b, out=None)", "intent": "Dot product of two arrays . With arguments `b`, `out`. numpy", "question_id": 21759}
{"snippet": "char.isalpha(a)", "intent": "Returns true for each element if all characters in the string are alphabetic and there is at least one character , false otherwise . With arguments `a`. numpy", "question_id": 21760}
{"snippet": "char.chararray.setfield(val, dtype)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field . numpy", "question_id": 21761}
{"snippet": "char.chararray.setfield(val, dtype, offset=0)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field . numpy", "question_id": 21762}
{"snippet": "numpy.logspace(start, stop)", "intent": "Return numbers spaced evenly on a log scale . In linear space , the sequence starts at `base` * * `start` ( base to the power of start ) and ends with base * * `stop` ( see `endpoint` below ) . numpy", "question_id": 21763}
{"snippet": "numpy.logspace(start, stop, num=50)", "intent": "Return numbers spaced evenly on a log scale . In linear space , the sequence starts at `base` * * `start` ( base to the power of start ) and ends with base * * `stop` ( see `endpoint` below ) . With arguments `num`. numpy", "question_id": 21764}
{"snippet": "numpy.logspace(start, stop, endpoint=True)", "intent": "Return numbers spaced evenly on a log scale . In linear space , the sequence starts at `base` * * `start` ( base to the power of start ) and ends with base * * `stop` ( see `endpoint` below ) . numpy", "question_id": 21765}
{"snippet": "numpy.logspace(start, stop, base=10.0)", "intent": "Return numbers spaced evenly on a log scale . In linear space , the sequence starts at `base` * * `start` ( base to the power of start ) and ends with base * * `stop` ( see `endpoint` below ) . numpy", "question_id": 21766}
{"snippet": "numpy.logspace(start, stop, dtype=None)", "intent": "Return numbers spaced evenly on a log scale . In linear space , the sequence starts at `base` * * `start` ( base to the power of start ) and ends with base * * `stop` ( see `endpoint` below ) . With arguments `dtype`. numpy", "question_id": 21767}
{"snippet": "numpy.logspace(start, stop, axis=0)", "intent": "Return numbers spaced evenly on a log scale . In linear space , the sequence starts at `base` * * `start` ( base to the power of start ) and ends with base * * `stop` ( see `endpoint` below ) . With arguments `axis`. numpy", "question_id": 21768}
{"snippet": "numpy.logspace(start, stop, num=50, endpoint=True)", "intent": "Return numbers spaced evenly on a log scale . In linear space , the sequence starts at `base` * * `start` ( base to the power of start ) and ends with base * * `stop` ( see `endpoint` below ) . With arguments `num`. numpy", "question_id": 21769}
{"snippet": "numpy.logspace(start, stop, num=50, base=10.0)", "intent": "Return numbers spaced evenly on a log scale . In linear space , the sequence starts at `base` * * `start` ( base to the power of start ) and ends with base * * `stop` ( see `endpoint` below ) . With arguments `num`. numpy", "question_id": 21770}
{"snippet": "numpy.logspace(start, stop, num=50, dtype=None)", "intent": "Return numbers spaced evenly on a log scale . In linear space , the sequence starts at `base` * * `start` ( base to the power of start ) and ends with base * * `stop` ( see `endpoint` below ) . With arguments `num`, `dtype`. numpy", "question_id": 21771}
{"snippet": "numpy.logspace(start, stop, num=50, axis=0)", "intent": "Return numbers spaced evenly on a log scale . In linear space , the sequence starts at `base` * * `start` ( base to the power of start ) and ends with base * * `stop` ( see `endpoint` below ) . With arguments `num`, `axis`. numpy", "question_id": 21772}
{"snippet": "numpy.fill_diagonal(a, val)", "intent": "Fill the main diagonal of the given array of any dimensionality . For an array `a` with a.ndim > = 2 , the diagonal is the list of locations with indices a [ i , ... , i ] all identical . With arguments `val`. numpy", "question_id": 21773}
{"snippet": "numpy.fill_diagonal(a, val, wrap=False)", "intent": "Fill the main diagonal of the given array of any dimensionality . For an array `a` with a.ndim > = 2 , the diagonal is the list of locations with indices a [ i , ... , i ] all identical . The `wrap` option affects only tall matrices : With arguments `val`. numpy", "question_id": 21774}
{"snippet": "record.reshape()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 21775}
{"snippet": "memmap.repeat(repeats)", "intent": "Repeat elements of an array . With arguments `repeats`. numpy", "question_id": 21776}
{"snippet": "memmap.repeat(repeats, axis=None)", "intent": "Repeat elements of an array . With arguments `repeats`, `axis`. numpy", "question_id": 21777}
{"snippet": "ma.MaskedArray.prod()", "intent": "Return the product of the array elements over the given `axis` . numpy", "question_id": 21778}
{"snippet": "ma.MaskedArray.prod(axis=None)", "intent": "Return the product of the array elements over the given `axis` . numpy", "question_id": 21779}
{"snippet": "ma.MaskedArray.prod(dtype=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 21780}
{"snippet": "ma.MaskedArray.prod(out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `out`. numpy", "question_id": 21781}
{"snippet": "ma.MaskedArray.prod(keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `keepdims`. numpy", "question_id": 21782}
{"snippet": "ma.MaskedArray.prod(axis=None, dtype=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 21783}
{"snippet": "ma.MaskedArray.prod(axis=None, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `out`. numpy", "question_id": 21784}
{"snippet": "ma.MaskedArray.prod(axis=None, keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `keepdims`. numpy", "question_id": 21785}
{"snippet": "ma.MaskedArray.prod(dtype=None, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 21786}
{"snippet": "ma.MaskedArray.prod(dtype=None, keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`, `keepdims`. numpy", "question_id": 21787}
{"snippet": "recarray.transpose(*axes)", "intent": "Returns a view of the array with axes transposed . With arguments `*axes`. numpy", "question_id": 21788}
{"snippet": "fft.fftfreq(n)", "intent": "Return the Discrete Fourier Transform sample frequencies . Given a window length `n` and a sample spacing `d` : numpy", "question_id": 21789}
{"snippet": "fft.fftfreq(n, d=1.0)", "intent": "Return the Discrete Fourier Transform sample frequencies . Given a window length `n` and a sample spacing `d` : numpy", "question_id": 21790}
{"snippet": "polynomial.hermite.Hermite.convert()", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 21791}
{"snippet": "polynomial.hermite.Hermite.convert(domain=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 21792}
{"snippet": "polynomial.hermite.Hermite.convert(kind=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 21793}
{"snippet": "polynomial.hermite.Hermite.convert(window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 21794}
{"snippet": "polynomial.hermite.Hermite.convert(domain=None, kind=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 21795}
{"snippet": "polynomial.hermite.Hermite.convert(domain=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 21796}
{"snippet": "polynomial.hermite.Hermite.convert(kind=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 21797}
{"snippet": "polynomial.hermite.Hermite.convert(domain=None, kind=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 21798}
{"snippet": "random.Generator.standard_gamma(shape)", "intent": "Draw samples from a standard Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and scale=1 . numpy", "question_id": 21799}
{"snippet": "random.Generator.standard_gamma(shape, size=None)", "intent": "Draw samples from a standard Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and scale=1 . With arguments `size`. numpy", "question_id": 21800}
{"snippet": "random.Generator.standard_gamma(shape, dtype=np.float64)", "intent": "Draw samples from a standard Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and scale=1 . With arguments `dtype`. numpy", "question_id": 21801}
{"snippet": "random.Generator.standard_gamma(shape, out=None)", "intent": "Draw samples from a standard Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and scale=1 . With arguments `out`. numpy", "question_id": 21802}
{"snippet": "random.Generator.standard_gamma(shape, size=None, dtype=np.float64)", "intent": "Draw samples from a standard Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and scale=1 . With arguments `size`, `dtype`. numpy", "question_id": 21803}
{"snippet": "random.Generator.standard_gamma(shape, size=None, out=None)", "intent": "Draw samples from a standard Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and scale=1 . With arguments `size`, `out`. numpy", "question_id": 21804}
{"snippet": "random.Generator.standard_gamma(shape, dtype=np.float64, out=None)", "intent": "Draw samples from a standard Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and scale=1 . With arguments `dtype`, `out`. numpy", "question_id": 21805}
{"snippet": "random.Generator.standard_gamma(shape, size=None, dtype=np.float64, out=None)", "intent": "Draw samples from a standard Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and scale=1 . With arguments `size`, `dtype`, `out`. numpy", "question_id": 21806}
{"snippet": "numpy.reciprocal(x, /, signature, extobj)", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `extobj`. numpy", "question_id": 21807}
{"snippet": "numpy.reciprocal(x, /, signature, extobj, out=None)", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 21808}
{"snippet": "numpy.reciprocal(x, /, signature, extobj, where=True)", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `where`. numpy", "question_id": 21809}
{"snippet": "numpy.reciprocal(x, /, signature, extobj, casting='same_kind')", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 21810}
{"snippet": "numpy.reciprocal(x, /, signature, extobj, order='K')", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 21811}
{"snippet": "numpy.reciprocal(x, /, signature, extobj, dtype=None)", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 21812}
{"snippet": "numpy.reciprocal(x, /, signature, extobj, subok=True)", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 21813}
{"snippet": "numpy.reciprocal(x, /, signature, extobj, out=None, where=True)", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 21814}
{"snippet": "numpy.reciprocal(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 21815}
{"snippet": "numpy.reciprocal(x, /, signature, extobj, out=None, order='K')", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 21816}
{"snippet": "numpy.reciprocal(x, /, signature)", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`. numpy", "question_id": 21817}
{"snippet": "numpy.reciprocal(x, /, signature, out=None)", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `out`. numpy", "question_id": 21818}
{"snippet": "numpy.reciprocal(x, /, signature, where=True)", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `where`. numpy", "question_id": 21819}
{"snippet": "numpy.reciprocal(x, /, signature, casting='same_kind')", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `casting`. numpy", "question_id": 21820}
{"snippet": "numpy.reciprocal(x, /, signature, order='K')", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `order`. numpy", "question_id": 21821}
{"snippet": "numpy.reciprocal(x, /, signature, dtype=None)", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `dtype`. numpy", "question_id": 21822}
{"snippet": "numpy.reciprocal(x, /, signature, subok=True)", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `subok`. numpy", "question_id": 21823}
{"snippet": "numpy.reciprocal(x, /, signature, out=None, where=True)", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `out`, `where`. numpy", "question_id": 21824}
{"snippet": "numpy.reciprocal(x, /, signature, out=None, casting='same_kind')", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `out`, `casting`. numpy", "question_id": 21825}
{"snippet": "numpy.reciprocal(x, /, signature, out=None, order='K')", "intent": "Return the reciprocal of the argument , element-wise . With arguments `x`, `/`, `signature`, `out`, `order`. numpy", "question_id": 21826}
{"snippet": "polynomial.hermite.poly2herm(pol)", "intent": "Convert a polynomial to a Hermite series . With arguments `pol`. numpy", "question_id": 21827}
{"snippet": "recarray.getfield(dtype)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements . numpy", "question_id": 21828}
{"snippet": "recarray.getfield(dtype, offset=0)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements . The values in the view are determined by the given type and the `offset` into the current array in bytes . numpy", "question_id": 21829}
{"snippet": "numpy.frompyfunc(func, nin, nout, identity)", "intent": "Takes an arbitrary Python function and returns a NumPy ufunc . With arguments `func`, `nin`, `nout`, `identity`. numpy", "question_id": 21830}
{"snippet": "numpy.frompyfunc(func, nin, nout)", "intent": "Takes an arbitrary Python function and returns a NumPy ufunc . With arguments `func`, `nin`, `nout`. numpy", "question_id": 21831}
{"snippet": "ma.MaskedArray.tofile(fid)", "intent": "Save a masked array to a file in binary `format` . With arguments `fid`. numpy", "question_id": 21832}
{"snippet": "ma.MaskedArray.tofile(fid, sep='')", "intent": "Save a masked array to a file in binary `format` . With arguments `fid`, `sep`. numpy", "question_id": 21833}
{"snippet": "ma.MaskedArray.tofile(fid, format='%s')", "intent": "Save a masked array to a file in binary `format` . With arguments `fid`. numpy", "question_id": 21834}
{"snippet": "ma.MaskedArray.tofile(fid, sep='', format='%s')", "intent": "Save a masked array to a file in binary `format` . With arguments `fid`, `sep`. numpy", "question_id": 21835}
{"snippet": "ma.masked_array.get_imag()", "intent": "The imaginary part of the masked array . numpy", "question_id": 21836}
{"snippet": "core.records.fromrecords(recList)", "intent": "Create a recarray from a list of records in text form . With arguments `recList`. numpy", "question_id": 21837}
{"snippet": "core.records.fromrecords(recList, dtype=None)", "intent": "Create a recarray from a list of records in text form . With arguments `recList`, `dtype`. numpy", "question_id": 21838}
{"snippet": "core.records.fromrecords(recList, shape=None)", "intent": "Create a recarray from a list of records in text form . With arguments `recList`, `shape`. numpy", "question_id": 21839}
{"snippet": "core.records.fromrecords(recList, formats=None)", "intent": "Create a recarray from a list of records in text form . With arguments `recList`, `formats`. numpy", "question_id": 21840}
{"snippet": "core.records.fromrecords(recList, names=None)", "intent": "Create a recarray from a list of records in text form . With arguments `recList`, `names`. numpy", "question_id": 21841}
{"snippet": "core.records.fromrecords(recList, titles=None)", "intent": "Create a recarray from a list of records in text form . With arguments `recList`, `titles`. numpy", "question_id": 21842}
{"snippet": "core.records.fromrecords(recList, aligned=False)", "intent": "Create a recarray from a list of records in text form . With arguments `recList`, `aligned`. numpy", "question_id": 21843}
{"snippet": "core.records.fromrecords(recList, byteorder=None)", "intent": "Create a recarray from a list of records in text form . With arguments `recList`, `byteorder`. numpy", "question_id": 21844}
{"snippet": "core.records.fromrecords(recList, dtype=None, shape=None)", "intent": "Create a recarray from a list of records in text form . With arguments `recList`, `dtype`, `shape`. numpy", "question_id": 21845}
{"snippet": "core.records.fromrecords(recList, dtype=None, formats=None)", "intent": "Create a recarray from a list of records in text form . With arguments `recList`, `dtype`, `formats`. numpy", "question_id": 21846}
{"snippet": "numpy.subtract(x1, x2, /, signature, extobj)", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 21847}
{"snippet": "numpy.subtract(x1, x2, /, signature, extobj, out=None)", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 21848}
{"snippet": "numpy.subtract(x1, x2, /, signature, extobj, where=True)", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 21849}
{"snippet": "numpy.subtract(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 21850}
{"snippet": "numpy.subtract(x1, x2, /, signature, extobj, order='K')", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 21851}
{"snippet": "numpy.subtract(x1, x2, /, signature, extobj, dtype=None)", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 21852}
{"snippet": "numpy.subtract(x1, x2, /, signature, extobj, subok=True)", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 21853}
{"snippet": "numpy.subtract(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 21854}
{"snippet": "numpy.subtract(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 21855}
{"snippet": "numpy.subtract(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 21856}
{"snippet": "numpy.subtract(x1, x2, /, signature)", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`. numpy", "question_id": 21857}
{"snippet": "numpy.subtract(x1, x2, /, signature, out=None)", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `out`. numpy", "question_id": 21858}
{"snippet": "numpy.subtract(x1, x2, /, signature, where=True)", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `where`. numpy", "question_id": 21859}
{"snippet": "numpy.subtract(x1, x2, /, signature, casting='same_kind')", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `casting`. numpy", "question_id": 21860}
{"snippet": "numpy.subtract(x1, x2, /, signature, order='K')", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `order`. numpy", "question_id": 21861}
{"snippet": "numpy.subtract(x1, x2, /, signature, dtype=None)", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 21862}
{"snippet": "numpy.subtract(x1, x2, /, signature, subok=True)", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `subok`. numpy", "question_id": 21863}
{"snippet": "numpy.subtract(x1, x2, /, signature, out=None, where=True)", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 21864}
{"snippet": "numpy.subtract(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 21865}
{"snippet": "numpy.subtract(x1, x2, /, signature, out=None, order='K')", "intent": "Subtract arguments , element-wise . Equivalent to `x1` - `x2` in terms of array broadcasting . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 21866}
{"snippet": "numpy.logical_xor(x1, x2, /, signature, extobj)", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 21867}
{"snippet": "numpy.logical_xor(x1, x2, /, signature, extobj, out=None)", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 21868}
{"snippet": "numpy.logical_xor(x1, x2, /, signature, extobj, where=True)", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 21869}
{"snippet": "numpy.logical_xor(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 21870}
{"snippet": "numpy.logical_xor(x1, x2, /, signature, extobj, order='K')", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 21871}
{"snippet": "numpy.logical_xor(x1, x2, /, signature, extobj, dtype=None)", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 21872}
{"snippet": "numpy.logical_xor(x1, x2, /, signature, extobj, subok=True)", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 21873}
{"snippet": "numpy.logical_xor(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 21874}
{"snippet": "numpy.logical_xor(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 21875}
{"snippet": "numpy.logical_xor(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 21876}
{"snippet": "numpy.logical_xor(x1, x2, /, signature)", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`. numpy", "question_id": 21877}
{"snippet": "numpy.logical_xor(x1, x2, /, signature, out=None)", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `out`. numpy", "question_id": 21878}
{"snippet": "numpy.logical_xor(x1, x2, /, signature, where=True)", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `where`. numpy", "question_id": 21879}
{"snippet": "numpy.logical_xor(x1, x2, /, signature, casting='same_kind')", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `casting`. numpy", "question_id": 21880}
{"snippet": "numpy.logical_xor(x1, x2, /, signature, order='K')", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `order`. numpy", "question_id": 21881}
{"snippet": "numpy.logical_xor(x1, x2, /, signature, dtype=None)", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 21882}
{"snippet": "numpy.logical_xor(x1, x2, /, signature, subok=True)", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `subok`. numpy", "question_id": 21883}
{"snippet": "numpy.logical_xor(x1, x2, /, signature, out=None, where=True)", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 21884}
{"snippet": "numpy.logical_xor(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 21885}
{"snippet": "numpy.logical_xor(x1, x2, /, signature, out=None, order='K')", "intent": "Compute the truth value of `x1` XOR `x2` , element-wise . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 21886}
{"snippet": "memmap.searchsorted(v)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . numpy", "question_id": 21887}
{"snippet": "memmap.searchsorted(v, side='left')", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`. numpy", "question_id": 21888}
{"snippet": "memmap.searchsorted(v, sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `sorter`. numpy", "question_id": 21889}
{"snippet": "memmap.searchsorted(v, side='left', sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`, `sorter`. numpy", "question_id": 21890}
{"snippet": "ma.empty_like(prototype)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`. numpy", "question_id": 21891}
{"snippet": "ma.empty_like(prototype, dtype=None)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `dtype`. numpy", "question_id": 21892}
{"snippet": "ma.empty_like(prototype, order='K')", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `order`. numpy", "question_id": 21893}
{"snippet": "ma.empty_like(prototype, subok=True)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `subok`. numpy", "question_id": 21894}
{"snippet": "ma.empty_like(prototype, shape=None)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`. numpy", "question_id": 21895}
{"snippet": "ma.empty_like(prototype, dtype=None, order='K')", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `dtype`, `order`. numpy", "question_id": 21896}
{"snippet": "ma.empty_like(prototype, dtype=None, subok=True)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `dtype`, `subok`. numpy", "question_id": 21897}
{"snippet": "ma.empty_like(prototype, dtype=None, shape=None)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `dtype`. numpy", "question_id": 21898}
{"snippet": "ma.empty_like(prototype, order='K', subok=True)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `order`, `subok`. numpy", "question_id": 21899}
{"snippet": "ma.empty_like(prototype, order='K', shape=None)", "intent": "Return a new array with the same `shape` and type as a given array . With arguments `prototype`, `order`. numpy", "question_id": 21900}
{"snippet": "numpy.typename(char)", "intent": "Return a description for the given data type code . With arguments `char`. numpy", "question_id": 21901}
{"snippet": "polynomial.hermite_e.hermeadd(c1, c2)", "intent": "Add one Hermite series to another . Returns the sum of two Hermite series `c1` + `c2` . numpy", "question_id": 21902}
{"snippet": "memmap.view(dtype, type)", "intent": "New view of array with the same data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) Viewing array data using a different `type` and dtype : numpy", "question_id": 21903}
{"snippet": "memmap.view(dtype)", "intent": "New view of array with the same data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) numpy", "question_id": 21904}
{"snippet": "memmap.view()", "intent": "New view of array with the same data . numpy", "question_id": 21905}
{"snippet": "ma.MaskedArray.__ne__(other)", "intent": "Check whether `other` does not equal self elementwise . numpy", "question_id": 21906}
{"snippet": "lib.format.dtype_to_descr(dtype)", "intent": "Get a serializable descriptor from the `dtype` . numpy", "question_id": 21907}
{"snippet": "generic.shape", "intent": "Tuple of array dimensions. numpy", "question_id": 21908}
{"snippet": "ma.make_mask_descr(ndtype)", "intent": "Construct a dtype description list from a given dtype . Returns a new dtype object , with the type of all fields in `ndtype` to a boolean type . numpy", "question_id": 21909}
{"snippet": "ma.MaskType.compress()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 21910}
{"snippet": "numpy.setbufsize(size)", "intent": "Set the `size` of the buffer used in ufuncs . numpy", "question_id": 21911}
{"snippet": "polynomial.polynomial.polyadd(c1, c2)", "intent": "Add one polynomial to another . Returns the sum of two polynomials `c1` + `c2` . numpy", "question_id": 21912}
{"snippet": "ma.MaskedArray.searchsorted(v)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . numpy", "question_id": 21913}
{"snippet": "ma.MaskedArray.searchsorted(v, side='left')", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`. numpy", "question_id": 21914}
{"snippet": "ma.MaskedArray.searchsorted(v, sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `sorter`. numpy", "question_id": 21915}
{"snippet": "ma.MaskedArray.searchsorted(v, side='left', sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`, `sorter`. numpy", "question_id": 21916}
{"snippet": "char.chararray.rfind(sub)", "intent": "For each element in self , return the highest index in the string where substring `sub` is found , such that sub is contained within [ `start` , `end` ] . numpy", "question_id": 21917}
{"snippet": "char.chararray.rfind(sub, start=0)", "intent": "For each element in self , return the highest index in the string where substring `sub` is found , such that sub is contained within [ `start` , `end` ] . numpy", "question_id": 21918}
{"snippet": "char.chararray.rfind(sub, end=None)", "intent": "For each element in self , return the highest index in the string where substring `sub` is found , such that sub is contained within [ `start` , `end` ] . numpy", "question_id": 21919}
{"snippet": "char.chararray.rfind(sub, start=0, end=None)", "intent": "For each element in self , return the highest index in the string where substring `sub` is found , such that sub is contained within [ `start` , `end` ] . numpy", "question_id": 21920}
{"snippet": "generic.size", "intent": "The number of elements in the gentype. numpy", "question_id": 21921}
{"snippet": "ma.max(obj)", "intent": "Return the maximum along a given `axis` . With arguments `obj`. numpy", "question_id": 21922}
{"snippet": "ma.max(obj, axis=None)", "intent": "Return the maximum along a given `axis` . With arguments `obj`. numpy", "question_id": 21923}
{"snippet": "ma.max(obj, out=None)", "intent": "Return the maximum along a given `axis` . With arguments `obj`, `out`. numpy", "question_id": 21924}
{"snippet": "ma.max(obj, fill_value=None)", "intent": "Return the maximum along a given `axis` . With arguments `obj`, `fill_value`. numpy", "question_id": 21925}
{"snippet": "ma.max(obj, keepdims=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `obj`, `keepdims`. numpy", "question_id": 21926}
{"snippet": "ma.max(obj, axis=None, out=None)", "intent": "Return the maximum along a given `axis` . With arguments `obj`, `out`. numpy", "question_id": 21927}
{"snippet": "ma.max(obj, axis=None, fill_value=None)", "intent": "Return the maximum along a given `axis` . With arguments `obj`, `fill_value`. numpy", "question_id": 21928}
{"snippet": "ma.max(obj, axis=None, keepdims=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `obj`, `keepdims`. numpy", "question_id": 21929}
{"snippet": "ma.max(obj, out=None, fill_value=None)", "intent": "Return the maximum along a given `axis` . With arguments `obj`, `out`, `fill_value`. numpy", "question_id": 21930}
{"snippet": "ma.max(obj, out=None, keepdims=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `obj`, `out`, `keepdims`. numpy", "question_id": 21931}
{"snippet": "polynomial.polynomial.Polynomial.has_sametype(other)", "intent": "Check if types match . With arguments `other`. numpy", "question_id": 21932}
{"snippet": "ma.MaskedArray.nbytes", "intent": "Total bytes consumed by the elements of the array. numpy", "question_id": 21933}
{"snippet": "flatiter.coords", "intent": "An N-dimensional tuple of current coordinates. numpy", "question_id": 21934}
{"snippet": "numpy.imag(val)", "intent": "Return the imaginary part of the complex argument . With arguments `val`. numpy", "question_id": 21935}
{"snippet": "chararray.splitlines()", "intent": "For each element in self , return a list of the lines in the element , breaking at line boundaries . numpy", "question_id": 21936}
{"snippet": "chararray.splitlines(keepends=None)", "intent": "For each element in self , return a list of the lines in the element , breaking at line boundaries . With arguments `keepends`. numpy", "question_id": 21937}
{"snippet": "ma.MaskedArray.__setmask__(mask)", "intent": "Set the `mask` . numpy", "question_id": 21938}
{"snippet": "ma.MaskedArray.__setmask__(mask, copy=False)", "intent": "Set the `mask` . With arguments `copy`. numpy", "question_id": 21939}
{"snippet": "numpy.spacing(x, /, signature, extobj)", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 21940}
{"snippet": "numpy.spacing(x, /, signature, extobj, out=None)", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 21941}
{"snippet": "numpy.spacing(x, /, signature, extobj, where=True)", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 21942}
{"snippet": "numpy.spacing(x, /, signature, extobj, casting='same_kind')", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 21943}
{"snippet": "numpy.spacing(x, /, signature, extobj, order='K')", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 21944}
{"snippet": "numpy.spacing(x, /, signature, extobj, dtype=None)", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 21945}
{"snippet": "numpy.spacing(x, /, signature, extobj, subok=True)", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 21946}
{"snippet": "numpy.spacing(x, /, signature, extobj, out=None, where=True)", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 21947}
{"snippet": "numpy.spacing(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 21948}
{"snippet": "numpy.spacing(x, /, signature, extobj, out=None, order='K')", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 21949}
{"snippet": "numpy.spacing(x, /, signature)", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`. numpy", "question_id": 21950}
{"snippet": "numpy.spacing(x, /, signature, out=None)", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `out`. numpy", "question_id": 21951}
{"snippet": "numpy.spacing(x, /, signature, where=True)", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `where`. numpy", "question_id": 21952}
{"snippet": "numpy.spacing(x, /, signature, casting='same_kind')", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `casting`. numpy", "question_id": 21953}
{"snippet": "numpy.spacing(x, /, signature, order='K')", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `order`. numpy", "question_id": 21954}
{"snippet": "numpy.spacing(x, /, signature, dtype=None)", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 21955}
{"snippet": "numpy.spacing(x, /, signature, subok=True)", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `subok`. numpy", "question_id": 21956}
{"snippet": "numpy.spacing(x, /, signature, out=None, where=True)", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 21957}
{"snippet": "numpy.spacing(x, /, signature, out=None, casting='same_kind')", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 21958}
{"snippet": "numpy.spacing(x, /, signature, out=None, order='K')", "intent": "Return the distance between `x` and the nearest adjacent number . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 21959}
{"snippet": "matrix.strides", "intent": "Tuple of bytes to step in each dimension when traversing an array. numpy", "question_id": 21960}
{"snippet": "polynomial.laguerre.Laguerre.has_samewindow(other)", "intent": "Check if windows match . With arguments `other`. numpy", "question_id": 21961}
{"snippet": "char.not_equal(x1, x2)", "intent": "Return ( `x1` ! = `x2` ) element-wise . numpy", "question_id": 21962}
{"snippet": "ma.masked_array.cumprod()", "intent": "Return the cumulative product of the array elements over the given `axis` . numpy", "question_id": 21963}
{"snippet": "ma.masked_array.cumprod(axis=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . numpy", "question_id": 21964}
{"snippet": "ma.masked_array.cumprod(dtype=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 21965}
{"snippet": "ma.masked_array.cumprod(out=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . The mask is lost if `out` is not a valid MaskedArray ! numpy", "question_id": 21966}
{"snippet": "ma.masked_array.cumprod(axis=None, dtype=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 21967}
{"snippet": "ma.masked_array.cumprod(axis=None, out=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . The mask is lost if `out` is not a valid MaskedArray ! numpy", "question_id": 21968}
{"snippet": "ma.masked_array.cumprod(dtype=None, out=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . The mask is lost if `out` is not a valid MaskedArray ! With arguments `dtype`. numpy", "question_id": 21969}
{"snippet": "ma.masked_array.cumprod(axis=None, dtype=None, out=None)", "intent": "Return the cumulative product of the array elements over the given `axis` . The mask is lost if `out` is not a valid MaskedArray ! With arguments `dtype`. numpy", "question_id": 21970}
{"snippet": "recarray.flags", "intent": "Information about the memory layout of the array. numpy", "question_id": 21971}
{"snippet": "ma.masked_array.base", "intent": "Base object if memory is from some other object. numpy", "question_id": 21972}
{"snippet": "ma.filled(a)", "intent": "Return input as an array with masked data replaced by `a` fill value . numpy", "question_id": 21973}
{"snippet": "ma.filled(a, fill_value=None)", "intent": "Return input as an array with masked data replaced by `a` fill value . If a is a MaskedArray and `fill_value` is None , fill_value is set to a.fill_value . numpy", "question_id": 21974}
{"snippet": "ma.MaskedArray.argmin()", "intent": "Return array of indices to the minimum values along the given `axis` . numpy", "question_id": 21975}
{"snippet": "ma.MaskedArray.argmin(axis=None)", "intent": "Return array of indices to the minimum values along the given `axis` . numpy", "question_id": 21976}
{"snippet": "ma.MaskedArray.argmin(fill_value=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `fill_value`. numpy", "question_id": 21977}
{"snippet": "ma.MaskedArray.argmin(out=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `out`. numpy", "question_id": 21978}
{"snippet": "ma.MaskedArray.argmin(axis=None, fill_value=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `fill_value`. numpy", "question_id": 21979}
{"snippet": "ma.MaskedArray.argmin(axis=None, out=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `out`. numpy", "question_id": 21980}
{"snippet": "ma.MaskedArray.argmin(fill_value=None, out=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `fill_value`, `out`. numpy", "question_id": 21981}
{"snippet": "ma.MaskedArray.argmin(axis=None, fill_value=None, out=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `fill_value`, `out`. numpy", "question_id": 21982}
{"snippet": "numpy.argmin(a)", "intent": "Returns the indices of the minimum values along an `axis` . Indices of the minimum elements of `a` N-dimensional array : numpy", "question_id": 21983}
{"snippet": "numpy.argmin(a, axis=None)", "intent": "Returns the indices of the minimum values along an `axis` . Indices of the minimum elements of `a` N-dimensional array : numpy", "question_id": 21984}
{"snippet": "numpy.argmin(a, out=None)", "intent": "Returns the indices of the minimum values along an `axis` . Indices of the minimum elements of `a` N-dimensional array : With arguments `out`. numpy", "question_id": 21985}
{"snippet": "numpy.argmin(a, axis=None, out=None)", "intent": "Returns the indices of the minimum values along an `axis` . Indices of the minimum elements of `a` N-dimensional array : With arguments `out`. numpy", "question_id": 21986}
{"snippet": "char.chararray.base", "intent": "Base object if memory is from some other object. numpy", "question_id": 21987}
{"snippet": "ma.MaskedArray.nonzero()", "intent": "Return the indices of unmasked elements that are not zero . numpy", "question_id": 21988}
{"snippet": "ufunc.identity", "intent": "The identity value. numpy", "question_id": 21989}
{"snippet": "ma.MaskedArray.argsort()", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . numpy", "question_id": 21990}
{"snippet": "ma.MaskedArray.argsort(axis=<no value>)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . numpy", "question_id": 21991}
{"snippet": "ma.MaskedArray.argsort(kind=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `kind`. numpy", "question_id": 21992}
{"snippet": "ma.MaskedArray.argsort(order=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `order`. numpy", "question_id": 21993}
{"snippet": "ma.MaskedArray.argsort(endwith=True)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `endwith`. numpy", "question_id": 21994}
{"snippet": "ma.MaskedArray.argsort(fill_value=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . Masked values are filled beforehand to `fill_value` . numpy", "question_id": 21995}
{"snippet": "ma.MaskedArray.argsort(axis=<no value>, kind=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `kind`. numpy", "question_id": 21996}
{"snippet": "ma.MaskedArray.argsort(axis=<no value>, order=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `order`. numpy", "question_id": 21997}
{"snippet": "ma.MaskedArray.argsort(axis=<no value>, endwith=True)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . With arguments `endwith`. numpy", "question_id": 21998}
{"snippet": "ma.MaskedArray.argsort(axis=<no value>, fill_value=None)", "intent": "Return an ndarray of indices that sort the array along the specified `axis` . Masked values are filled beforehand to `fill_value` . numpy", "question_id": 21999}
{"snippet": "ndarray.__floordiv__(value, /)", "intent": "Return self//value . With arguments `value`, `/`. numpy", "question_id": 22000}
{"snippet": "ma.masked_array.tobytes()", "intent": "Return the array data as a string containing the raw bytes in the array . numpy", "question_id": 22001}
{"snippet": "ma.masked_array.tobytes(fill_value=None)", "intent": "Return the array data as a string containing the raw bytes in the array . As for ndarray.tobytes , information about the shape , dtype , etc. , but also about `fill_value` , will be lost . numpy", "question_id": 22002}
{"snippet": "ma.masked_array.tobytes(order='C')", "intent": "Return the array data as a string containing the raw bytes in the array . With arguments `order`. numpy", "question_id": 22003}
{"snippet": "ma.masked_array.tobytes(fill_value=None, order='C')", "intent": "Return the array data as a string containing the raw bytes in the array . As for ndarray.tobytes , information about the shape , dtype , etc. , but also about `fill_value` , will be lost . With arguments `order`. numpy", "question_id": 22004}
{"snippet": "numpy.nansum(a)", "intent": "Return the sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . numpy", "question_id": 22005}
{"snippet": "numpy.nansum(a, axis=None)", "intent": "Return the sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . numpy", "question_id": 22006}
{"snippet": "numpy.nansum(a, dtype=None)", "intent": "Return the sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `dtype`. numpy", "question_id": 22007}
{"snippet": "numpy.nansum(a, out=None)", "intent": "Return the sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `out`. numpy", "question_id": 22008}
{"snippet": "numpy.nansum(a, keepdims=<no value>)", "intent": "Return the sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `keepdims`. numpy", "question_id": 22009}
{"snippet": "numpy.nansum(a, axis=None, dtype=None)", "intent": "Return the sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `dtype`. numpy", "question_id": 22010}
{"snippet": "numpy.nansum(a, axis=None, out=None)", "intent": "Return the sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `out`. numpy", "question_id": 22011}
{"snippet": "numpy.nansum(a, axis=None, keepdims=<no value>)", "intent": "Return the sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `keepdims`. numpy", "question_id": 22012}
{"snippet": "numpy.nansum(a, dtype=None, out=None)", "intent": "Return the sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `dtype`, `out`. numpy", "question_id": 22013}
{"snippet": "numpy.nansum(a, dtype=None, keepdims=<no value>)", "intent": "Return the sum of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as zero . With arguments `dtype`, `keepdims`. numpy", "question_id": 22014}
{"snippet": "chararray.setfield(val, dtype)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field . numpy", "question_id": 22015}
{"snippet": "chararray.setfield(val, dtype, offset=0)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field . numpy", "question_id": 22016}
{"snippet": "numpy.var(a)", "intent": "Compute the variance along the specified `axis` . Returns the variance of the array elements , `a` measure of the spread of a distribution . numpy", "question_id": 22017}
{"snippet": "numpy.var(a, axis=None)", "intent": "Compute the variance along the specified `axis` . Returns the variance of the array elements , `a` measure of the spread of a distribution . numpy", "question_id": 22018}
{"snippet": "numpy.var(a, dtype=None)", "intent": "Compute the variance along the specified `axis` . Returns the variance of the array elements , `a` measure of the spread of a distribution . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue . numpy", "question_id": 22019}
{"snippet": "numpy.var(a, out=None)", "intent": "Compute the variance along the specified `axis` . Returns the variance of the array elements , `a` measure of the spread of a distribution . With arguments `out`. numpy", "question_id": 22020}
{"snippet": "numpy.var(a, ddof=0)", "intent": "Compute the variance along the specified `axis` . Returns the variance of the array elements , `a` measure of the spread of a distribution . If , however , `ddof` is specified , the divisor N - ddof is used instead . numpy", "question_id": 22021}
{"snippet": "numpy.var(a, keepdims=<no value>)", "intent": "Compute the variance along the specified `axis` . Returns the variance of the array elements , `a` measure of the spread of a distribution . With arguments `keepdims`. numpy", "question_id": 22022}
{"snippet": "numpy.var(a, where=<no value>)", "intent": "Compute the variance along the specified `axis` . Returns the variance of the array elements , `a` measure of the spread of a distribution . The variance is the average of the squared deviations from the mean , i.e. , var = mean ( x ) , `where` x = abs ( a - a.mean ( ) ) * * 2 . numpy", "question_id": 22023}
{"snippet": "numpy.var(a, axis=None, dtype=None)", "intent": "Compute the variance along the specified `axis` . Returns the variance of the array elements , `a` measure of the spread of a distribution . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue . numpy", "question_id": 22024}
{"snippet": "numpy.var(a, axis=None, out=None)", "intent": "Compute the variance along the specified `axis` . Returns the variance of the array elements , `a` measure of the spread of a distribution . With arguments `out`. numpy", "question_id": 22025}
{"snippet": "numpy.var(a, axis=None, ddof=0)", "intent": "Compute the variance along the specified `axis` . Returns the variance of the array elements , `a` measure of the spread of a distribution . If , however , `ddof` is specified , the divisor N - ddof is used instead . numpy", "question_id": 22026}
{"snippet": "recarray.min()", "intent": "Return the minimum along a given `axis` . numpy", "question_id": 22027}
{"snippet": "recarray.min(axis=None)", "intent": "Return the minimum along a given `axis` . numpy", "question_id": 22028}
{"snippet": "recarray.min(out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`. numpy", "question_id": 22029}
{"snippet": "recarray.min(keepdims=False)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 22030}
{"snippet": "recarray.min(initial=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `initial`. numpy", "question_id": 22031}
{"snippet": "recarray.min(where=True)", "intent": "Return the minimum along a given `axis` . With arguments `where`. numpy", "question_id": 22032}
{"snippet": "recarray.min(axis=None, out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`. numpy", "question_id": 22033}
{"snippet": "recarray.min(axis=None, keepdims=False)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 22034}
{"snippet": "recarray.min(axis=None, initial=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `initial`. numpy", "question_id": 22035}
{"snippet": "recarray.min(axis=None, where=True)", "intent": "Return the minimum along a given `axis` . With arguments `where`. numpy", "question_id": 22036}
{"snippet": "ma.masked_array.newbyteorder(/)", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`. numpy", "question_id": 22037}
{"snippet": "ma.masked_array.newbyteorder(/, new_order='S')", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`, `new_order`. numpy", "question_id": 22038}
{"snippet": "numpy.eye(N)", "intent": "Return a 2-D array with ones on the diagonal and zeros elsewhere . With arguments `N`. numpy", "question_id": 22039}
{"snippet": "numpy.eye(N, M=None)", "intent": "Return a 2-D array with ones on the diagonal and zeros elsewhere . With arguments `N`, `M`. numpy", "question_id": 22040}
{"snippet": "numpy.eye(N, k=0)", "intent": "Return a 2-D array with ones on the diagonal and zeros elsewhere . With arguments `N`, `k`. numpy", "question_id": 22041}
{"snippet": "numpy.eye(N, dtype=<class 'float'>)", "intent": "Return a 2-D array with ones on the diagonal and zeros elsewhere . With arguments `N`, `dtype`. numpy", "question_id": 22042}
{"snippet": "numpy.eye(N, order='C')", "intent": "Return a 2-D array with ones on the diagonal and zeros elsewhere . With arguments `N`, `order`. numpy", "question_id": 22043}
{"snippet": "numpy.eye(N, like=None)", "intent": "Return a 2-D array with ones on the diagonal and zeros elsewhere . With arguments `N`, `like`. numpy", "question_id": 22044}
{"snippet": "numpy.eye(N, M=None, k=0)", "intent": "Return a 2-D array with ones on the diagonal and zeros elsewhere . With arguments `N`, `M`, `k`. numpy", "question_id": 22045}
{"snippet": "numpy.eye(N, M=None, dtype=<class 'float'>)", "intent": "Return a 2-D array with ones on the diagonal and zeros elsewhere . With arguments `N`, `M`, `dtype`. numpy", "question_id": 22046}
{"snippet": "numpy.eye(N, M=None, order='C')", "intent": "Return a 2-D array with ones on the diagonal and zeros elsewhere . With arguments `N`, `M`, `order`. numpy", "question_id": 22047}
{"snippet": "numpy.eye(N, M=None, like=None)", "intent": "Return a 2-D array with ones on the diagonal and zeros elsewhere . With arguments `N`, `M`, `like`. numpy", "question_id": 22048}
{"snippet": "ma.masked_array.astype(dtype)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`. numpy", "question_id": 22049}
{"snippet": "ma.masked_array.astype(dtype, order='K')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`. numpy", "question_id": 22050}
{"snippet": "ma.masked_array.astype(dtype, casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`. numpy", "question_id": 22051}
{"snippet": "ma.masked_array.astype(dtype, subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `subok`. numpy", "question_id": 22052}
{"snippet": "ma.masked_array.astype(dtype, copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `copy`. numpy", "question_id": 22053}
{"snippet": "ma.masked_array.astype(dtype, order='K', casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `casting`. numpy", "question_id": 22054}
{"snippet": "ma.masked_array.astype(dtype, order='K', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `subok`. numpy", "question_id": 22055}
{"snippet": "ma.masked_array.astype(dtype, order='K', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `copy`. numpy", "question_id": 22056}
{"snippet": "ma.masked_array.astype(dtype, casting='unsafe', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `subok`. numpy", "question_id": 22057}
{"snippet": "ma.masked_array.astype(dtype, casting='unsafe', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `copy`. numpy", "question_id": 22058}
{"snippet": "numpy.ma.masked_array", "intent": "alias of numpy.ma.core.MaskedArray numpy", "question_id": 22059}
{"snippet": "numpy.r_", "intent": "Translates slice objects to concatenation along the first axis. numpy", "question_id": 22060}
{"snippet": "ma.masked_array.unshare_mask()", "intent": "Copy the mask and set the sharedmask flag to False . numpy", "question_id": 22061}
{"snippet": "recarray.nbytes", "intent": "Total bytes consumed by the elements of the array. numpy", "question_id": 22062}
{"snippet": "numpy.info()", "intent": "Get help information for a function , class , or module . numpy", "question_id": 22063}
{"snippet": "numpy.info(object=None)", "intent": "Get help information for a function , class , or module . When used interactively with an `object` , np.info ( obj ) is equivalent to help ( obj ) on the Python prompt or obj ? numpy", "question_id": 22064}
{"snippet": "numpy.info(maxwidth=76)", "intent": "Get help information for a function , class , or module . With arguments `maxwidth`. numpy", "question_id": 22065}
{"snippet": "numpy.info(output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>)", "intent": "Get help information for a function , class , or module . With arguments `output`. numpy", "question_id": 22066}
{"snippet": "numpy.info(toplevel='numpy')", "intent": "Get help information for a function , class , or module . With arguments `toplevel`. numpy", "question_id": 22067}
{"snippet": "numpy.info(object=None, maxwidth=76)", "intent": "Get help information for a function , class , or module . When used interactively with an `object` , np.info ( obj ) is equivalent to help ( obj ) on the Python prompt or obj ? With arguments `maxwidth`. numpy", "question_id": 22068}
{"snippet": "numpy.info(object=None, output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>)", "intent": "Get help information for a function , class , or module . When used interactively with an `object` , np.info ( obj ) is equivalent to help ( obj ) on the Python prompt or obj ? With arguments `output`. numpy", "question_id": 22069}
{"snippet": "numpy.info(object=None, toplevel='numpy')", "intent": "Get help information for a function , class , or module . When used interactively with an `object` , np.info ( obj ) is equivalent to help ( obj ) on the Python prompt or obj ? With arguments `toplevel`. numpy", "question_id": 22070}
{"snippet": "numpy.info(maxwidth=76, output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>)", "intent": "Get help information for a function , class , or module . With arguments `maxwidth`, `output`. numpy", "question_id": 22071}
{"snippet": "numpy.info(maxwidth=76, toplevel='numpy')", "intent": "Get help information for a function , class , or module . With arguments `maxwidth`, `toplevel`. numpy", "question_id": 22072}
{"snippet": "numpy.union1d(ar1, ar2)", "intent": "Find the union of two arrays . With arguments `ar1`, `ar2`. numpy", "question_id": 22073}
{"snippet": "chararray.var()", "intent": "Returns the variance of the array elements , along given `axis` . numpy", "question_id": 22074}
{"snippet": "chararray.var(axis=None)", "intent": "Returns the variance of the array elements , along given `axis` . numpy", "question_id": 22075}
{"snippet": "chararray.var(dtype=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `dtype`. numpy", "question_id": 22076}
{"snippet": "chararray.var(out=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `out`. numpy", "question_id": 22077}
{"snippet": "chararray.var(ddof=0)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `ddof`. numpy", "question_id": 22078}
{"snippet": "chararray.var(keepdims=False)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `keepdims`. numpy", "question_id": 22079}
{"snippet": "chararray.var(where=True)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `where`. numpy", "question_id": 22080}
{"snippet": "chararray.var(axis=None, dtype=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `dtype`. numpy", "question_id": 22081}
{"snippet": "chararray.var(axis=None, out=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `out`. numpy", "question_id": 22082}
{"snippet": "chararray.var(axis=None, ddof=0)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `ddof`. numpy", "question_id": 22083}
{"snippet": "char.rfind(a, sub)", "intent": "For each element in `a` , return the highest index in the string where substring `sub` is found , such that sub is contained within [ `start` , `end` ] . numpy", "question_id": 22084}
{"snippet": "char.rfind(a, sub, start=0)", "intent": "For each element in `a` , return the highest index in the string where substring `sub` is found , such that sub is contained within [ `start` , `end` ] . numpy", "question_id": 22085}
{"snippet": "char.rfind(a, sub, end=None)", "intent": "For each element in `a` , return the highest index in the string where substring `sub` is found , such that sub is contained within [ `start` , `end` ] . numpy", "question_id": 22086}
{"snippet": "char.rfind(a, sub, start=0, end=None)", "intent": "For each element in `a` , return the highest index in the string where substring `sub` is found , such that sub is contained within [ `start` , `end` ] . numpy", "question_id": 22087}
{"snippet": "ma.MaskedArray.__isub__(other)", "intent": "Subtract `other` from self in-place . numpy", "question_id": 22088}
{"snippet": "ma.MaskedArray.__iadd__(other)", "intent": "Add `other` to self in-place . numpy", "question_id": 22089}
{"snippet": "char.chararray.reshape(shape)", "intent": "Returns an array containing the same data with a new `shape` . numpy", "question_id": 22090}
{"snippet": "char.chararray.reshape(shape, order='C')", "intent": "Returns an array containing the same data with a new `shape` . With arguments `order`. numpy", "question_id": 22091}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.feature_implies_c(names)", "intent": "same as feature_implies ( ) but combining \u2018 `names` \u2019 numpy", "question_id": 22092}
{"snippet": "char.chararray.prod()", "intent": "Return the product of the array elements over the given `axis` numpy", "question_id": 22093}
{"snippet": "char.chararray.prod(axis=None)", "intent": "Return the product of the array elements over the given `axis` numpy", "question_id": 22094}
{"snippet": "char.chararray.prod(dtype=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `dtype`. numpy", "question_id": 22095}
{"snippet": "char.chararray.prod(out=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `out`. numpy", "question_id": 22096}
{"snippet": "char.chararray.prod(keepdims=False)", "intent": "Return the product of the array elements over the given `axis` With arguments `keepdims`. numpy", "question_id": 22097}
{"snippet": "char.chararray.prod(initial=1)", "intent": "Return the product of the array elements over the given `axis` With arguments `initial`. numpy", "question_id": 22098}
{"snippet": "char.chararray.prod(where=True)", "intent": "Return the product of the array elements over the given `axis` With arguments `where`. numpy", "question_id": 22099}
{"snippet": "char.chararray.prod(axis=None, dtype=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `dtype`. numpy", "question_id": 22100}
{"snippet": "char.chararray.prod(axis=None, out=None)", "intent": "Return the product of the array elements over the given `axis` With arguments `out`. numpy", "question_id": 22101}
{"snippet": "char.chararray.prod(axis=None, keepdims=False)", "intent": "Return the product of the array elements over the given `axis` With arguments `keepdims`. numpy", "question_id": 22102}
{"snippet": "numpy.set_string_function(f)", "intent": "Set a Python function to be used when pretty printing arrays . With arguments `f`. numpy", "question_id": 22103}
{"snippet": "numpy.set_string_function(f, repr=True)", "intent": "Set a Python function to be used when pretty printing arrays . `repr` affects either pretty printing or normal string representation . With arguments `f`. numpy", "question_id": 22104}
{"snippet": "random.standard_t(df)", "intent": "Draw samples from a standard Student \u2019 s t distribution with `df` degrees of freedom . numpy", "question_id": 22105}
{"snippet": "random.standard_t(df, size=None)", "intent": "Draw samples from a standard Student \u2019 s t distribution with `df` degrees of freedom . With arguments `size`. numpy", "question_id": 22106}
{"snippet": "polynomial.polynomial.Polynomial.truncate(size)", "intent": "Truncate series to length `size` . numpy", "question_id": 22107}
{"snippet": "recarray.setflags()", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . numpy", "question_id": 22108}
{"snippet": "recarray.setflags(write=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`. numpy", "question_id": 22109}
{"snippet": "recarray.setflags(align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`. numpy", "question_id": 22110}
{"snippet": "recarray.setflags(uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `uic`. numpy", "question_id": 22111}
{"snippet": "recarray.setflags(write=None, align=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`. numpy", "question_id": 22112}
{"snippet": "recarray.setflags(write=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `uic`. numpy", "question_id": 22113}
{"snippet": "recarray.setflags(align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `align`, `uic`. numpy", "question_id": 22114}
{"snippet": "recarray.setflags(write=None, align=None, uic=None)", "intent": "Set array flags WRITEABLE , ALIGNED , ( WRITEBACKIFCOPY and UPDATEIFCOPY ) , respectively . With arguments `write`, `align`, `uic`. numpy", "question_id": 22115}
{"snippet": "ma.MaskedArray.repeat(repeats)", "intent": "Repeat elements of an array . With arguments `repeats`. numpy", "question_id": 22116}
{"snippet": "ma.MaskedArray.repeat(repeats, axis=None)", "intent": "Repeat elements of an array . With arguments `repeats`, `axis`. numpy", "question_id": 22117}
{"snippet": "core.records.fromstring(datastring)", "intent": "Create a record array from binary data With arguments `datastring`. numpy", "question_id": 22118}
{"snippet": "core.records.fromstring(datastring, dtype=None)", "intent": "Create a record array from binary data With arguments `datastring`, `dtype`. numpy", "question_id": 22119}
{"snippet": "core.records.fromstring(datastring, shape=None)", "intent": "Create a record array from binary data With arguments `datastring`, `shape`. numpy", "question_id": 22120}
{"snippet": "core.records.fromstring(datastring, offset=0)", "intent": "Create a record array from binary data With arguments `datastring`, `offset`. numpy", "question_id": 22121}
{"snippet": "core.records.fromstring(datastring, formats=None)", "intent": "Create a record array from binary data With arguments `datastring`, `formats`. numpy", "question_id": 22122}
{"snippet": "core.records.fromstring(datastring, names=None)", "intent": "Create a record array from binary data With arguments `datastring`, `names`. numpy", "question_id": 22123}
{"snippet": "core.records.fromstring(datastring, titles=None)", "intent": "Create a record array from binary data With arguments `datastring`, `titles`. numpy", "question_id": 22124}
{"snippet": "core.records.fromstring(datastring, aligned=False)", "intent": "Create a record array from binary data With arguments `datastring`, `aligned`. numpy", "question_id": 22125}
{"snippet": "core.records.fromstring(datastring, byteorder=None)", "intent": "Create a record array from binary data With arguments `datastring`, `byteorder`. numpy", "question_id": 22126}
{"snippet": "core.records.fromstring(datastring, dtype=None, shape=None)", "intent": "Create a record array from binary data With arguments `datastring`, `dtype`, `shape`. numpy", "question_id": 22127}
{"snippet": "ma.MaskType.nonzero()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 22128}
{"snippet": "numpy.logical_or(x1, x2, /, signature, extobj)", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 22129}
{"snippet": "numpy.logical_or(x1, x2, /, signature, extobj, out=None)", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 22130}
{"snippet": "numpy.logical_or(x1, x2, /, signature, extobj, where=True)", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 22131}
{"snippet": "numpy.logical_or(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 22132}
{"snippet": "numpy.logical_or(x1, x2, /, signature, extobj, order='K')", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 22133}
{"snippet": "numpy.logical_or(x1, x2, /, signature, extobj, dtype=None)", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 22134}
{"snippet": "numpy.logical_or(x1, x2, /, signature, extobj, subok=True)", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 22135}
{"snippet": "numpy.logical_or(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 22136}
{"snippet": "numpy.logical_or(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 22137}
{"snippet": "numpy.logical_or(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 22138}
{"snippet": "numpy.logical_or(x1, x2, /, signature)", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`. numpy", "question_id": 22139}
{"snippet": "numpy.logical_or(x1, x2, /, signature, out=None)", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `out`. numpy", "question_id": 22140}
{"snippet": "numpy.logical_or(x1, x2, /, signature, where=True)", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `where`. numpy", "question_id": 22141}
{"snippet": "numpy.logical_or(x1, x2, /, signature, casting='same_kind')", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `casting`. numpy", "question_id": 22142}
{"snippet": "numpy.logical_or(x1, x2, /, signature, order='K')", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `order`. numpy", "question_id": 22143}
{"snippet": "numpy.logical_or(x1, x2, /, signature, dtype=None)", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 22144}
{"snippet": "numpy.logical_or(x1, x2, /, signature, subok=True)", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `subok`. numpy", "question_id": 22145}
{"snippet": "numpy.logical_or(x1, x2, /, signature, out=None, where=True)", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 22146}
{"snippet": "numpy.logical_or(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 22147}
{"snippet": "numpy.logical_or(x1, x2, /, signature, out=None, order='K')", "intent": "Compute the truth value of `x1` OR `x2` element-wise . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 22148}
{"snippet": "ndarray.__irshift__(value, /)", "intent": "Return self > > =value . With arguments `value`, `/`. numpy", "question_id": 22149}
{"snippet": "polynomial.hermite.hermroots(c)", "intent": "Compute the roots of a Hermite series . With arguments `c`. numpy", "question_id": 22150}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.dist_load_module(name, path)", "intent": "Load a module from file , required by the abstract class \u2018 _Cache \u2019 . With arguments `name`, `path`. numpy", "question_id": 22151}
{"snippet": "numpy.reshape(a, newshape)", "intent": "Gives `a` new shape to an array without changing its data . With arguments `newshape`. numpy", "question_id": 22152}
{"snippet": "numpy.reshape(a, newshape, order='C')", "intent": "Gives `a` new shape to an array without changing its data . The `order` keyword gives the index ordering both for fetching the values from a , and then placing the values into the output array . With arguments `newshape`. numpy", "question_id": 22153}
{"snippet": "random.weibull(a)", "intent": "Draw samples from `a` Weibull distribution . numpy", "question_id": 22154}
{"snippet": "random.weibull(a, size=None)", "intent": "Draw samples from `a` Weibull distribution . With arguments `size`. numpy", "question_id": 22155}
{"snippet": "ma.MaskedArray.__bool__(/)", "intent": "self ! = 0 With arguments `/`. numpy", "question_id": 22156}
{"snippet": "char.add(x1, x2)", "intent": "Return element-wise string concatenation for two arrays of str or unicode . Arrays `x1` and `x2` must have the same shape . numpy", "question_id": 22157}
{"snippet": "ma.MaskedArray.__ge__(value, /)", "intent": "Return self > =value . With arguments `value`, `/`. numpy", "question_id": 22158}
{"snippet": "matrix.ptp()", "intent": "Peak-to-peak ( maximum - minimum ) value along the given `axis` . numpy", "question_id": 22159}
{"snippet": "matrix.ptp(axis=None)", "intent": "Peak-to-peak ( maximum - minimum ) value along the given `axis` . numpy", "question_id": 22160}
{"snippet": "matrix.ptp(out=None)", "intent": "Peak-to-peak ( maximum - minimum ) value along the given `axis` . With arguments `out`. numpy", "question_id": 22161}
{"snippet": "matrix.ptp(axis=None, out=None)", "intent": "Peak-to-peak ( maximum - minimum ) value along the given `axis` . With arguments `out`. numpy", "question_id": 22162}
{"snippet": "char.partition(a, sep)", "intent": "Partition each element in `a` around `sep` . numpy", "question_id": 22163}
{"snippet": "random.RandomState.set_state(state)", "intent": "Set the internal `state` of the generator from a tuple . numpy", "question_id": 22164}
{"snippet": "polynomial.laguerre.Laguerre.deriv()", "intent": "Differentiate . numpy", "question_id": 22165}
{"snippet": "polynomial.laguerre.Laguerre.deriv(m=1)", "intent": "Differentiate . With arguments `m`. numpy", "question_id": 22166}
{"snippet": "memmap.take(indices)", "intent": "Return an array formed from the elements of a at the given `indices` . numpy", "question_id": 22167}
{"snippet": "memmap.take(indices, axis=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`. numpy", "question_id": 22168}
{"snippet": "memmap.take(indices, out=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `out`. numpy", "question_id": 22169}
{"snippet": "memmap.take(indices, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `mode`. numpy", "question_id": 22170}
{"snippet": "memmap.take(indices, axis=None, out=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `out`. numpy", "question_id": 22171}
{"snippet": "memmap.take(indices, axis=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `mode`. numpy", "question_id": 22172}
{"snippet": "memmap.take(indices, out=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `out`, `mode`. numpy", "question_id": 22173}
{"snippet": "memmap.take(indices, axis=None, out=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `out`, `mode`. numpy", "question_id": 22174}
{"snippet": "char.equal(x1, x2)", "intent": "Return ( `x1` == `x2` ) element-wise . numpy", "question_id": 22175}
{"snippet": "numpy.repeat(a, repeats)", "intent": "Repeat elements of an array . With arguments `a`, `repeats`. numpy", "question_id": 22176}
{"snippet": "numpy.repeat(a, repeats, axis=None)", "intent": "Repeat elements of an array . With arguments `a`, `repeats`, `axis`. numpy", "question_id": 22177}
{"snippet": "numpy.trim_zeros(filt)", "intent": "Trim the leading and/or trailing zeros from a 1-D array or sequence . With arguments `filt`. numpy", "question_id": 22178}
{"snippet": "numpy.trim_zeros(filt, trim='fb')", "intent": "Trim the leading and/or trailing zeros from a 1-D array or sequence . With arguments `filt`, `trim`. numpy", "question_id": 22179}
{"snippet": "ma.MaskType.any()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 22180}
{"snippet": "ma.hstack(*args, **kwargs)", "intent": "Stack arrays in sequence horizontally ( column wise ) . With arguments `*args`, `**kwargs`. numpy", "question_id": 22181}
{"snippet": "numpy.asanyarray(a)", "intent": "Convert the input to an ndarray , but pass ndarray subclasses through . Convert `a` list into an array : numpy", "question_id": 22182}
{"snippet": "numpy.asanyarray(a, dtype=None)", "intent": "Convert the input to an ndarray , but pass ndarray subclasses through . Convert `a` list into an array : With arguments `dtype`. numpy", "question_id": 22183}
{"snippet": "numpy.asanyarray(a, order=None)", "intent": "Convert the input to an ndarray , but pass ndarray subclasses through . Convert `a` list into an array : With arguments `order`. numpy", "question_id": 22184}
{"snippet": "numpy.asanyarray(a, like=None)", "intent": "Convert the input to an ndarray , but pass ndarray subclasses through . Convert `a` list into an array : With arguments `like`. numpy", "question_id": 22185}
{"snippet": "numpy.asanyarray(a, dtype=None, order=None)", "intent": "Convert the input to an ndarray , but pass ndarray subclasses through . Convert `a` list into an array : With arguments `dtype`, `order`. numpy", "question_id": 22186}
{"snippet": "numpy.asanyarray(a, dtype=None, like=None)", "intent": "Convert the input to an ndarray , but pass ndarray subclasses through . Convert `a` list into an array : With arguments `dtype`, `like`. numpy", "question_id": 22187}
{"snippet": "numpy.asanyarray(a, order=None, like=None)", "intent": "Convert the input to an ndarray , but pass ndarray subclasses through . Convert `a` list into an array : With arguments `order`, `like`. numpy", "question_id": 22188}
{"snippet": "numpy.asanyarray(a, dtype=None, order=None, like=None)", "intent": "Convert the input to an ndarray , but pass ndarray subclasses through . Convert `a` list into an array : With arguments `dtype`, `order`, `like`. numpy", "question_id": 22189}
{"snippet": "char.chararray.islower()", "intent": "Returns true for each element if all cased characters in the string are lowercase and there is at least one cased character , false otherwise . numpy", "question_id": 22190}
{"snippet": "matrix.copy()", "intent": "Return a copy of the array . numpy", "question_id": 22191}
{"snippet": "matrix.copy(order='C')", "intent": "Return a copy of the array . The function numpy.copy is similar , but it defaults to using `order` \u2018 K \u2019 , and will not pass sub-classes through by default . numpy", "question_id": 22192}
{"snippet": "numpy.radians(x, /, signature, extobj)", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `extobj`. numpy", "question_id": 22193}
{"snippet": "numpy.radians(x, /, signature, extobj, out=None)", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 22194}
{"snippet": "numpy.radians(x, /, signature, extobj, where=True)", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `extobj`, `where`. numpy", "question_id": 22195}
{"snippet": "numpy.radians(x, /, signature, extobj, casting='same_kind')", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 22196}
{"snippet": "numpy.radians(x, /, signature, extobj, order='K')", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 22197}
{"snippet": "numpy.radians(x, /, signature, extobj, dtype=None)", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 22198}
{"snippet": "numpy.radians(x, /, signature, extobj, subok=True)", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 22199}
{"snippet": "numpy.radians(x, /, signature, extobj, out=None, where=True)", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 22200}
{"snippet": "numpy.radians(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 22201}
{"snippet": "numpy.radians(x, /, signature, extobj, out=None, order='K')", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 22202}
{"snippet": "numpy.radians(x, /, signature)", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`. numpy", "question_id": 22203}
{"snippet": "numpy.radians(x, /, signature, out=None)", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `out`. numpy", "question_id": 22204}
{"snippet": "numpy.radians(x, /, signature, where=True)", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `where`. numpy", "question_id": 22205}
{"snippet": "numpy.radians(x, /, signature, casting='same_kind')", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `casting`. numpy", "question_id": 22206}
{"snippet": "numpy.radians(x, /, signature, order='K')", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `order`. numpy", "question_id": 22207}
{"snippet": "numpy.radians(x, /, signature, dtype=None)", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `dtype`. numpy", "question_id": 22208}
{"snippet": "numpy.radians(x, /, signature, subok=True)", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `subok`. numpy", "question_id": 22209}
{"snippet": "numpy.radians(x, /, signature, out=None, where=True)", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `out`, `where`. numpy", "question_id": 22210}
{"snippet": "numpy.radians(x, /, signature, out=None, casting='same_kind')", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `out`, `casting`. numpy", "question_id": 22211}
{"snippet": "numpy.radians(x, /, signature, out=None, order='K')", "intent": "Convert angles from degrees to radians . With arguments `x`, `/`, `signature`, `out`, `order`. numpy", "question_id": 22212}
{"snippet": "ma.masked_array.dumps()", "intent": "Returns the pickle of the array as a string . numpy", "question_id": 22213}
{"snippet": "char.chararray.rjust(width)", "intent": "Return an array with the elements of self right-justified in a string of length `width` . numpy", "question_id": 22214}
{"snippet": "char.chararray.rjust(width, fillchar=' ')", "intent": "Return an array with the elements of self right-justified in a string of length `width` . With arguments `fillchar`. numpy", "question_id": 22215}
{"snippet": "polynomial.hermite.hermvander(x, deg)", "intent": "Pseudo-Vandermonde matrix of given degree . Returns the pseudo-Vandermonde matrix of degree `deg` and sample points `x` . numpy", "question_id": 22216}
{"snippet": "ma.masked_array.repeat(repeats)", "intent": "Repeat elements of an array . With arguments `repeats`. numpy", "question_id": 22217}
{"snippet": "ma.masked_array.repeat(repeats, axis=None)", "intent": "Repeat elements of an array . With arguments `repeats`, `axis`. numpy", "question_id": 22218}
{"snippet": "matlib.eye(n)", "intent": "Return a matrix with ones on the diagonal and zeros elsewhere . With arguments `n`. numpy", "question_id": 22219}
{"snippet": "matlib.eye(n, M=None)", "intent": "Return a matrix with ones on the diagonal and zeros elsewhere . With arguments `n`, `M`. numpy", "question_id": 22220}
{"snippet": "matlib.eye(n, k=0)", "intent": "Return a matrix with ones on the diagonal and zeros elsewhere . With arguments `n`, `k`. numpy", "question_id": 22221}
{"snippet": "matlib.eye(n, dtype=<class 'float'>)", "intent": "Return a matrix with ones on the diagonal and zeros elsewhere . With arguments `n`, `dtype`. numpy", "question_id": 22222}
{"snippet": "matlib.eye(n, order='C')", "intent": "Return a matrix with ones on the diagonal and zeros elsewhere . With arguments `n`, `order`. numpy", "question_id": 22223}
{"snippet": "matlib.eye(n, M=None, k=0)", "intent": "Return a matrix with ones on the diagonal and zeros elsewhere . With arguments `n`, `M`, `k`. numpy", "question_id": 22224}
{"snippet": "matlib.eye(n, M=None, dtype=<class 'float'>)", "intent": "Return a matrix with ones on the diagonal and zeros elsewhere . With arguments `n`, `M`, `dtype`. numpy", "question_id": 22225}
{"snippet": "matlib.eye(n, M=None, order='C')", "intent": "Return a matrix with ones on the diagonal and zeros elsewhere . With arguments `n`, `M`, `order`. numpy", "question_id": 22226}
{"snippet": "matlib.eye(n, k=0, dtype=<class 'float'>)", "intent": "Return a matrix with ones on the diagonal and zeros elsewhere . With arguments `n`, `k`, `dtype`. numpy", "question_id": 22227}
{"snippet": "matlib.eye(n, k=0, order='C')", "intent": "Return a matrix with ones on the diagonal and zeros elsewhere . With arguments `n`, `k`, `order`. numpy", "question_id": 22228}
{"snippet": "chararray.isupper()", "intent": "Returns true for each element if all cased characters in the string are uppercase and there is at least one character , false otherwise . numpy", "question_id": 22229}
{"snippet": "chararray.strip()", "intent": "For each element in self , return a copy with the leading and trailing characters removed . numpy", "question_id": 22230}
{"snippet": "chararray.strip(chars=None)", "intent": "For each element in self , return a copy with the leading and trailing characters removed . With arguments `chars`. numpy", "question_id": 22231}
{"snippet": "ufunc.ntypes", "intent": "The number of types. numpy", "question_id": 22232}
{"snippet": "polynomial.laguerre.lagfromroots(roots)", "intent": "Generate a Laguerre series with given `roots` . numpy", "question_id": 22233}
{"snippet": "numpy.all(a)", "intent": "Test whether all array elements along `a` given `axis` evaluate to True . numpy", "question_id": 22234}
{"snippet": "numpy.all(a, axis=None)", "intent": "Test whether all array elements along `a` given `axis` evaluate to True . numpy", "question_id": 22235}
{"snippet": "numpy.all(a, out=None)", "intent": "Test whether all array elements along `a` given `axis` evaluate to True . With arguments `out`. numpy", "question_id": 22236}
{"snippet": "numpy.all(a, keepdims=<no value>)", "intent": "Test whether all array elements along `a` given `axis` evaluate to True . With arguments `keepdims`. numpy", "question_id": 22237}
{"snippet": "numpy.all(a, where=<no value>)", "intent": "Test whether all array elements along `a` given `axis` evaluate to True . With arguments `where`. numpy", "question_id": 22238}
{"snippet": "numpy.all(a, axis=None, out=None)", "intent": "Test whether all array elements along `a` given `axis` evaluate to True . With arguments `out`. numpy", "question_id": 22239}
{"snippet": "numpy.all(a, axis=None, keepdims=<no value>)", "intent": "Test whether all array elements along `a` given `axis` evaluate to True . With arguments `keepdims`. numpy", "question_id": 22240}
{"snippet": "numpy.all(a, axis=None, where=<no value>)", "intent": "Test whether all array elements along `a` given `axis` evaluate to True . With arguments `where`. numpy", "question_id": 22241}
{"snippet": "numpy.all(a, out=None, keepdims=<no value>)", "intent": "Test whether all array elements along `a` given `axis` evaluate to True . With arguments `out`, `keepdims`. numpy", "question_id": 22242}
{"snippet": "numpy.all(a, out=None, where=<no value>)", "intent": "Test whether all array elements along `a` given `axis` evaluate to True . With arguments `out`, `where`. numpy", "question_id": 22243}
{"snippet": "char.chararray.shape", "intent": "Tuple of array dimensions. numpy", "question_id": 22244}
{"snippet": "ma.argmin(self)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `self`. numpy", "question_id": 22245}
{"snippet": "ma.argmin(self, axis=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `self`. numpy", "question_id": 22246}
{"snippet": "ma.argmin(self, fill_value=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `self`, `fill_value`. numpy", "question_id": 22247}
{"snippet": "ma.argmin(self, out=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `self`, `out`. numpy", "question_id": 22248}
{"snippet": "ma.argmin(self, axis=None, fill_value=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `self`, `fill_value`. numpy", "question_id": 22249}
{"snippet": "ma.argmin(self, axis=None, out=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `self`, `out`. numpy", "question_id": 22250}
{"snippet": "ma.argmin(self, fill_value=None, out=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `self`, `fill_value`, `out`. numpy", "question_id": 22251}
{"snippet": "ma.argmin(self, axis=None, fill_value=None, out=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `self`, `fill_value`, `out`. numpy", "question_id": 22252}
{"snippet": "memmap.cumsum()", "intent": "Return the cumulative sum of the elements along the given `axis` . numpy", "question_id": 22253}
{"snippet": "memmap.cumsum(axis=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . numpy", "question_id": 22254}
{"snippet": "memmap.cumsum(dtype=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 22255}
{"snippet": "memmap.cumsum(out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `out`. numpy", "question_id": 22256}
{"snippet": "memmap.cumsum(axis=None, dtype=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 22257}
{"snippet": "memmap.cumsum(axis=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `out`. numpy", "question_id": 22258}
{"snippet": "memmap.cumsum(dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 22259}
{"snippet": "memmap.cumsum(axis=None, dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 22260}
{"snippet": "numpy.nanmedian(a)", "intent": "Compute the median along the specified `axis` , while ignoring NaNs . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i.e. , V_sorted [ ( N-1 ) /2 ] , when N is odd and the average of the two middle values of V_sorted when N is even . numpy", "question_id": 22261}
{"snippet": "numpy.nanmedian(a, axis=None)", "intent": "Compute the median along the specified `axis` , while ignoring NaNs . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i.e. , V_sorted [ ( N-1 ) /2 ] , when N is odd and the average of the two middle values of V_sorted when N is even . numpy", "question_id": 22262}
{"snippet": "numpy.nanmedian(a, out=None)", "intent": "Compute the median along the specified `axis` , while ignoring NaNs . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i.e. , V_sorted [ ( N-1 ) /2 ] , when N is odd and the average of the two middle values of V_sorted when N is even . With arguments `out`. numpy", "question_id": 22263}
{"snippet": "numpy.nanmedian(a, overwrite_input=False)", "intent": "Compute the median along the specified `axis` , while ignoring NaNs . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i.e. , V_sorted [ ( N-1 ) /2 ] , when N is odd and the average of the two middle values of V_sorted when N is even . With arguments `overwrite_input`. numpy", "question_id": 22264}
{"snippet": "numpy.nanmedian(a, keepdims=<no value>)", "intent": "Compute the median along the specified `axis` , while ignoring NaNs . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i.e. , V_sorted [ ( N-1 ) /2 ] , when N is odd and the average of the two middle values of V_sorted when N is even . With arguments `keepdims`. numpy", "question_id": 22265}
{"snippet": "numpy.nanmedian(a, axis=None, out=None)", "intent": "Compute the median along the specified `axis` , while ignoring NaNs . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i.e. , V_sorted [ ( N-1 ) /2 ] , when N is odd and the average of the two middle values of V_sorted when N is even . With arguments `out`. numpy", "question_id": 22266}
{"snippet": "numpy.nanmedian(a, axis=None, overwrite_input=False)", "intent": "Compute the median along the specified `axis` , while ignoring NaNs . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i.e. , V_sorted [ ( N-1 ) /2 ] , when N is odd and the average of the two middle values of V_sorted when N is even . With arguments `overwrite_input`. numpy", "question_id": 22267}
{"snippet": "numpy.nanmedian(a, axis=None, keepdims=<no value>)", "intent": "Compute the median along the specified `axis` , while ignoring NaNs . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i.e. , V_sorted [ ( N-1 ) /2 ] , when N is odd and the average of the two middle values of V_sorted when N is even . With arguments `keepdims`. numpy", "question_id": 22268}
{"snippet": "numpy.nanmedian(a, out=None, overwrite_input=False)", "intent": "Compute the median along the specified `axis` , while ignoring NaNs . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i.e. , V_sorted [ ( N-1 ) /2 ] , when N is odd and the average of the two middle values of V_sorted when N is even . With arguments `out`, `overwrite_input`. numpy", "question_id": 22269}
{"snippet": "numpy.nanmedian(a, out=None, keepdims=<no value>)", "intent": "Compute the median along the specified `axis` , while ignoring NaNs . Given `a` vector V of length N , the median of V is the middle value of a sorted copy of V , V_sorted - i.e. , V_sorted [ ( N-1 ) /2 ] , when N is odd and the average of the two middle values of V_sorted when N is even . With arguments `out`, `keepdims`. numpy", "question_id": 22270}
{"snippet": "ma.masked_array.transpose(*axes)", "intent": "Returns a view of the array with axes transposed . With arguments `*axes`. numpy", "question_id": 22271}
{"snippet": "numpy.argsort(a)", "intent": "Returns the indices that would sort an array . It returns an array of indices of the same shape as `a` that index data along the given axis in sorted `order` . numpy", "question_id": 22272}
{"snippet": "numpy.argsort(a, axis=- 1)", "intent": "Returns the indices that would sort an array . It returns an array of indices of the same shape as `a` that index data along the given axis in sorted `order` . Perform an indirect sort along the given `axis` using the algorithm specified by the `kind` keyword . numpy", "question_id": 22273}
{"snippet": "numpy.argsort(a, kind=None)", "intent": "Returns the indices that would sort an array . It returns an array of indices of the same shape as `a` that index data along the given axis in sorted `order` . Perform an indirect sort along the given `axis` using the algorithm specified by the `kind` keyword . numpy", "question_id": 22274}
{"snippet": "numpy.argsort(a, order=None)", "intent": "Returns the indices that would sort an array . It returns an array of indices of the same shape as `a` that index data along the given axis in sorted `order` . numpy", "question_id": 22275}
{"snippet": "numpy.argsort(a, axis=- 1, kind=None)", "intent": "Returns the indices that would sort an array . It returns an array of indices of the same shape as `a` that index data along the given axis in sorted `order` . Perform an indirect sort along the given `axis` using the algorithm specified by the `kind` keyword . numpy", "question_id": 22276}
{"snippet": "numpy.argsort(a, axis=- 1, order=None)", "intent": "Returns the indices that would sort an array . It returns an array of indices of the same shape as `a` that index data along the given axis in sorted `order` . Perform an indirect sort along the given `axis` using the algorithm specified by the `kind` keyword . numpy", "question_id": 22277}
{"snippet": "numpy.argsort(a, kind=None, order=None)", "intent": "Returns the indices that would sort an array . It returns an array of indices of the same shape as `a` that index data along the given axis in sorted `order` . Perform an indirect sort along the given `axis` using the algorithm specified by the `kind` keyword . numpy", "question_id": 22278}
{"snippet": "numpy.argsort(a, axis=- 1, kind=None, order=None)", "intent": "Returns the indices that would sort an array . It returns an array of indices of the same shape as `a` that index data along the given axis in sorted `order` . Perform an indirect sort along the given `axis` using the algorithm specified by the `kind` keyword . numpy", "question_id": 22279}
{"snippet": "ma.MaskedArray.__int__()", "intent": "Convert to int . numpy", "question_id": 22280}
{"snippet": "ma.MaskedArray.__mod__(value, /)", "intent": "Return self % `value` . With arguments `/`. numpy", "question_id": 22281}
{"snippet": "polynomial.hermite.Hermite.trim()", "intent": "Remove trailing coefficients numpy", "question_id": 22282}
{"snippet": "polynomial.hermite.Hermite.trim(tol=0)", "intent": "Remove trailing coefficients Remove trailing coefficients until a coefficient is reached whose absolute value greater than `tol` or the beginning of the series is reached . numpy", "question_id": 22283}
{"snippet": "random.noncentral_f(dfnum, dfden, nonc)", "intent": "Draw samples from the noncentral F distribution . Samples are drawn from an F distribution with specified parameters , `dfnum` ( degrees of freedom in numerator ) and `dfden` ( degrees of freedom in denominator ) , where both parameters > 1. `nonc` is the non-centrality parameter . numpy", "question_id": 22284}
{"snippet": "random.noncentral_f(dfnum, dfden, nonc, size=None)", "intent": "Draw samples from the noncentral F distribution . Samples are drawn from an F distribution with specified parameters , `dfnum` ( degrees of freedom in numerator ) and `dfden` ( degrees of freedom in denominator ) , where both parameters > 1. `nonc` is the non-centrality parameter . With arguments `size`. numpy", "question_id": 22285}
{"snippet": "ma.diag(v)", "intent": "Extract a diagonal or construct a diagonal array . With arguments `v`. numpy", "question_id": 22286}
{"snippet": "ma.diag(v, k=0)", "intent": "Extract a diagonal or construct a diagonal array . With arguments `v`, `k`. numpy", "question_id": 22287}
{"snippet": "ndarray.tolist()", "intent": "Return the array as an a.ndim-levels deep nested list of Python scalars . numpy", "question_id": 22288}
{"snippet": "matrix.trace()", "intent": "Return the sum along diagonals of the array . numpy", "question_id": 22289}
{"snippet": "matrix.trace(offset=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`. numpy", "question_id": 22290}
{"snippet": "matrix.trace(axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `axis1`. numpy", "question_id": 22291}
{"snippet": "matrix.trace(axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `axis2`. numpy", "question_id": 22292}
{"snippet": "matrix.trace(dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `dtype`. numpy", "question_id": 22293}
{"snippet": "matrix.trace(out=None)", "intent": "Return the sum along diagonals of the array . With arguments `out`. numpy", "question_id": 22294}
{"snippet": "matrix.trace(offset=0, axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis1`. numpy", "question_id": 22295}
{"snippet": "matrix.trace(offset=0, axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis2`. numpy", "question_id": 22296}
{"snippet": "matrix.trace(offset=0, dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `dtype`. numpy", "question_id": 22297}
{"snippet": "matrix.trace(offset=0, out=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `out`. numpy", "question_id": 22298}
{"snippet": "poly1d.deriv()", "intent": "Return a derivative of this polynomial . numpy", "question_id": 22299}
{"snippet": "poly1d.deriv(m=1)", "intent": "Return a derivative of this polynomial . With arguments `m`. numpy", "question_id": 22300}
{"snippet": "numpy.isfinite(x, /, signature, extobj)", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 22301}
{"snippet": "numpy.isfinite(x, /, signature, extobj, out=None)", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 22302}
{"snippet": "numpy.isfinite(x, /, signature, extobj, where=True)", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 22303}
{"snippet": "numpy.isfinite(x, /, signature, extobj, casting='same_kind')", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 22304}
{"snippet": "numpy.isfinite(x, /, signature, extobj, order='K')", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 22305}
{"snippet": "numpy.isfinite(x, /, signature, extobj, dtype=None)", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 22306}
{"snippet": "numpy.isfinite(x, /, signature, extobj, subok=True)", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 22307}
{"snippet": "numpy.isfinite(x, /, signature, extobj, out=None, where=True)", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 22308}
{"snippet": "numpy.isfinite(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 22309}
{"snippet": "numpy.isfinite(x, /, signature, extobj, out=None, order='K')", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 22310}
{"snippet": "numpy.isfinite(x, /, signature)", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`. numpy", "question_id": 22311}
{"snippet": "numpy.isfinite(x, /, signature, out=None)", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `out`. numpy", "question_id": 22312}
{"snippet": "numpy.isfinite(x, /, signature, where=True)", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `where`. numpy", "question_id": 22313}
{"snippet": "numpy.isfinite(x, /, signature, casting='same_kind')", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `casting`. numpy", "question_id": 22314}
{"snippet": "numpy.isfinite(x, /, signature, order='K')", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `order`. numpy", "question_id": 22315}
{"snippet": "numpy.isfinite(x, /, signature, dtype=None)", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 22316}
{"snippet": "numpy.isfinite(x, /, signature, subok=True)", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `subok`. numpy", "question_id": 22317}
{"snippet": "numpy.isfinite(x, /, signature, out=None, where=True)", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 22318}
{"snippet": "numpy.isfinite(x, /, signature, out=None, casting='same_kind')", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 22319}
{"snippet": "numpy.isfinite(x, /, signature, out=None, order='K')", "intent": "Test element-wise for finiteness ( not infinity or not Not a Number ) . Errors result if the second argument is also supplied when `x` is a scalar input , or if first and second arguments have different shapes . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 22320}
{"snippet": "numpy.require(a)", "intent": "Return an ndarray of the provided type that satisfies `requirements` . The returned array will be guaranteed to have the listed requirements by making `a` copy if needed . numpy", "question_id": 22321}
{"snippet": "numpy.require(a, dtype=None)", "intent": "Return an ndarray of the provided type that satisfies `requirements` . The returned array will be guaranteed to have the listed requirements by making `a` copy if needed . With arguments `dtype`. numpy", "question_id": 22322}
{"snippet": "numpy.require(a, requirements=None)", "intent": "Return an ndarray of the provided type that satisfies `requirements` . The returned array will be guaranteed to have the listed requirements by making `a` copy if needed . numpy", "question_id": 22323}
{"snippet": "numpy.require(a, like=None)", "intent": "Return an ndarray of the provided type that satisfies `requirements` . The returned array will be guaranteed to have the listed requirements by making `a` copy if needed . With arguments `like`. numpy", "question_id": 22324}
{"snippet": "numpy.require(a, dtype=None, requirements=None)", "intent": "Return an ndarray of the provided type that satisfies `requirements` . The returned array will be guaranteed to have the listed requirements by making `a` copy if needed . With arguments `dtype`. numpy", "question_id": 22325}
{"snippet": "numpy.require(a, dtype=None, like=None)", "intent": "Return an ndarray of the provided type that satisfies `requirements` . The returned array will be guaranteed to have the listed requirements by making `a` copy if needed . With arguments `dtype`, `like`. numpy", "question_id": 22326}
{"snippet": "numpy.require(a, requirements=None, like=None)", "intent": "Return an ndarray of the provided type that satisfies `requirements` . The returned array will be guaranteed to have the listed requirements by making `a` copy if needed . With arguments `like`. numpy", "question_id": 22327}
{"snippet": "numpy.require(a, dtype=None, requirements=None, like=None)", "intent": "Return an ndarray of the provided type that satisfies `requirements` . The returned array will be guaranteed to have the listed requirements by making `a` copy if needed . With arguments `dtype`, `like`. numpy", "question_id": 22328}
{"snippet": "char.chararray.size", "intent": "Number of elements in the array. numpy", "question_id": 22329}
{"snippet": "memmap.data", "intent": "Python buffer object pointing to the start of the array\u2019s data. numpy", "question_id": 22330}
{"snippet": "ma.harden_mask(self)", "intent": "Force the mask to hard . With arguments `self`. numpy", "question_id": 22331}
{"snippet": "numpy.full(shape, fill_value)", "intent": "Return a new array of given `shape` and type , filled with `fill_value` . numpy", "question_id": 22332}
{"snippet": "numpy.full(shape, fill_value, dtype=None)", "intent": "Return a new array of given `shape` and type , filled with `fill_value` . With arguments `dtype`. numpy", "question_id": 22333}
{"snippet": "numpy.full(shape, fill_value, order='C')", "intent": "Return a new array of given `shape` and type , filled with `fill_value` . With arguments `order`. numpy", "question_id": 22334}
{"snippet": "numpy.full(shape, fill_value, like=None)", "intent": "Return a new array of given `shape` and type , filled with `fill_value` . With arguments `like`. numpy", "question_id": 22335}
{"snippet": "numpy.full(shape, fill_value, dtype=None, order='C')", "intent": "Return a new array of given `shape` and type , filled with `fill_value` . With arguments `dtype`, `order`. numpy", "question_id": 22336}
{"snippet": "numpy.full(shape, fill_value, dtype=None, like=None)", "intent": "Return a new array of given `shape` and type , filled with `fill_value` . With arguments `dtype`, `like`. numpy", "question_id": 22337}
{"snippet": "numpy.full(shape, fill_value, order='C', like=None)", "intent": "Return a new array of given `shape` and type , filled with `fill_value` . With arguments `order`, `like`. numpy", "question_id": 22338}
{"snippet": "numpy.full(shape, fill_value, dtype=None, order='C', like=None)", "intent": "Return a new array of given `shape` and type , filled with `fill_value` . With arguments `dtype`, `order`, `like`. numpy", "question_id": 22339}
{"snippet": "polynomial.hermite_e.HermiteE.trim()", "intent": "Remove trailing coefficients numpy", "question_id": 22340}
{"snippet": "polynomial.hermite_e.HermiteE.trim(tol=0)", "intent": "Remove trailing coefficients Remove trailing coefficients until a coefficient is reached whose absolute value greater than `tol` or the beginning of the series is reached . numpy", "question_id": 22341}
{"snippet": "matrix.getA()", "intent": "Return self as an ndarray object . numpy", "question_id": 22342}
{"snippet": "char.chararray.copy()", "intent": "Return a copy of the array . numpy", "question_id": 22343}
{"snippet": "char.chararray.copy(order='C')", "intent": "Return a copy of the array . The function numpy.copy is similar , but it defaults to using `order` \u2018 K \u2019 , and will not pass sub-classes through by default . numpy", "question_id": 22344}
{"snippet": "polynomial.chebyshev.chebweight(x)", "intent": "The weight function of the Chebyshev polynomials . With arguments `x`. numpy", "question_id": 22345}
{"snippet": "ma.masked_where(condition, a)", "intent": "Mask an array where `a` `condition` is met . numpy", "question_id": 22346}
{"snippet": "ma.masked_where(condition, a, copy=True)", "intent": "Mask an array where `a` `condition` is met . Effect of the `copy` argument . numpy", "question_id": 22347}
{"snippet": "numpy.arcsin(x, /, signature, extobj)", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 22348}
{"snippet": "numpy.arcsin(x, /, signature, extobj, out=None)", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 22349}
{"snippet": "numpy.arcsin(x, /, signature, extobj, where=True)", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 22350}
{"snippet": "numpy.arcsin(x, /, signature, extobj, casting='same_kind')", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 22351}
{"snippet": "numpy.arcsin(x, /, signature, extobj, order='K')", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 22352}
{"snippet": "numpy.arcsin(x, /, signature, extobj, dtype=None)", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 22353}
{"snippet": "numpy.arcsin(x, /, signature, extobj, subok=True)", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 22354}
{"snippet": "numpy.arcsin(x, /, signature, extobj, out=None, where=True)", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 22355}
{"snippet": "numpy.arcsin(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 22356}
{"snippet": "numpy.arcsin(x, /, signature, extobj, out=None, order='K')", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 22357}
{"snippet": "numpy.arcsin(x, /, signature)", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`. numpy", "question_id": 22358}
{"snippet": "numpy.arcsin(x, /, signature, out=None)", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `out`. numpy", "question_id": 22359}
{"snippet": "numpy.arcsin(x, /, signature, where=True)", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `where`. numpy", "question_id": 22360}
{"snippet": "numpy.arcsin(x, /, signature, casting='same_kind')", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `casting`. numpy", "question_id": 22361}
{"snippet": "numpy.arcsin(x, /, signature, order='K')", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `order`. numpy", "question_id": 22362}
{"snippet": "numpy.arcsin(x, /, signature, dtype=None)", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 22363}
{"snippet": "numpy.arcsin(x, /, signature, subok=True)", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `subok`. numpy", "question_id": 22364}
{"snippet": "numpy.arcsin(x, /, signature, out=None, where=True)", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 22365}
{"snippet": "numpy.arcsin(x, /, signature, out=None, casting='same_kind')", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 22366}
{"snippet": "numpy.arcsin(x, /, signature, out=None, order='K')", "intent": "Inverse sine , element-wise . arcsin is a multivalued function : for each `x` there are infinitely many numbers z such that \\ ( sin ( z ) = x\\ ) . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 22367}
{"snippet": "numpy.row_stack(tup)", "intent": "Stack arrays in sequence vertically ( row wise ) . With arguments `tup`. numpy", "question_id": 22368}
{"snippet": "polynomial.chebyshev.Chebyshev.trim()", "intent": "Remove trailing coefficients numpy", "question_id": 22369}
{"snippet": "polynomial.chebyshev.Chebyshev.trim(tol=0)", "intent": "Remove trailing coefficients Remove trailing coefficients until a coefficient is reached whose absolute value greater than `tol` or the beginning of the series is reached . numpy", "question_id": 22370}
{"snippet": "ma.MaskedArray.__eq__(other)", "intent": "Check whether `other` equals self elementwise . numpy", "question_id": 22371}
{"snippet": "polynomial.legendre.leggrid3d(x, y, z, c)", "intent": "Evaluate a 3-D Legendre series on the Cartesian product of `x` , `y` , and `z` . where the points ( a , b , `c` ) consist of all triples formed by taking a from x , b from y , and c from z . numpy", "question_id": 22372}
{"snippet": "random.RandomState.normal()", "intent": "Draw random samples from a normal ( Gaussian ) distribution . numpy", "question_id": 22373}
{"snippet": "random.RandomState.normal(loc=0.0)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `loc`. numpy", "question_id": 22374}
{"snippet": "random.RandomState.normal(scale=1.0)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `scale`. numpy", "question_id": 22375}
{"snippet": "random.RandomState.normal(size=None)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `size`. numpy", "question_id": 22376}
{"snippet": "random.RandomState.normal(loc=0.0, scale=1.0)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `loc`, `scale`. numpy", "question_id": 22377}
{"snippet": "random.RandomState.normal(loc=0.0, size=None)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `loc`, `size`. numpy", "question_id": 22378}
{"snippet": "random.RandomState.normal(scale=1.0, size=None)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `scale`, `size`. numpy", "question_id": 22379}
{"snippet": "random.RandomState.normal(loc=0.0, scale=1.0, size=None)", "intent": "Draw random samples from a normal ( Gaussian ) distribution . With arguments `loc`, `scale`, `size`. numpy", "question_id": 22380}
{"snippet": "numpy.c_", "intent": "Translates slice objects to concatenation along the second axis. numpy", "question_id": 22381}
{"snippet": "testing.assert_array_less(x, y)", "intent": "Raises an AssertionError if two array_like objects are not ordered by less than . With arguments `x`, `y`. numpy", "question_id": 22382}
{"snippet": "testing.assert_array_less(x, y, err_msg='')", "intent": "Raises an AssertionError if two array_like objects are not ordered by less than . With arguments `x`, `y`, `err_msg`. numpy", "question_id": 22383}
{"snippet": "testing.assert_array_less(x, y, verbose=True)", "intent": "Raises an AssertionError if two array_like objects are not ordered by less than . With arguments `x`, `y`, `verbose`. numpy", "question_id": 22384}
{"snippet": "testing.assert_array_less(x, y, err_msg='', verbose=True)", "intent": "Raises an AssertionError if two array_like objects are not ordered by less than . With arguments `x`, `y`, `err_msg`, `verbose`. numpy", "question_id": 22385}
{"snippet": "numpy.nditer(op)", "intent": "Efficient multi-dimensional iterator object to iterate over arrays . With arguments `op`. numpy", "question_id": 22386}
{"snippet": "numpy.nditer(op, flags=None)", "intent": "Efficient multi-dimensional iterator object to iterate over arrays . If operand `flags` \u201c writeonly \u201d or \u201c readwrite \u201d are used the operands may be views into the original data with the WRITEBACKIFCOPY flag . With arguments `op`. numpy", "question_id": 22387}
{"snippet": "numpy.nditer(op, op_flags=None)", "intent": "Efficient multi-dimensional iterator object to iterate over arrays . With arguments `op`, `op_flags`. numpy", "question_id": 22388}
{"snippet": "numpy.nditer(op, op_dtypes=None)", "intent": "Efficient multi-dimensional iterator object to iterate over arrays . With arguments `op`, `op_dtypes`. numpy", "question_id": 22389}
{"snippet": "numpy.nditer(op, order='K')", "intent": "Efficient multi-dimensional iterator object to iterate over arrays . With arguments `op`, `order`. numpy", "question_id": 22390}
{"snippet": "numpy.nditer(op, casting='safe')", "intent": "Efficient multi-dimensional iterator object to iterate over arrays . With arguments `op`, `casting`. numpy", "question_id": 22391}
{"snippet": "numpy.nditer(op, op_axes=None)", "intent": "Efficient multi-dimensional iterator object to iterate over arrays . With arguments `op`, `op_axes`. numpy", "question_id": 22392}
{"snippet": "numpy.nditer(op, itershape=None)", "intent": "Efficient multi-dimensional iterator object to iterate over arrays . With arguments `op`, `itershape`. numpy", "question_id": 22393}
{"snippet": "numpy.nditer(op, buffersize=0)", "intent": "Efficient multi-dimensional iterator object to iterate over arrays . With arguments `op`, `buffersize`. numpy", "question_id": 22394}
{"snippet": "numpy.nditer(op, flags=None, op_flags=None)", "intent": "Efficient multi-dimensional iterator object to iterate over arrays . If operand `flags` \u201c writeonly \u201d or \u201c readwrite \u201d are used the operands may be views into the original data with the WRITEBACKIFCOPY flag . With arguments `op`, `op_flags`. numpy", "question_id": 22395}
{"snippet": "chararray.real", "intent": "The real part of the array. numpy", "question_id": 22396}
{"snippet": "ma.MaskType.sort()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 22397}
{"snippet": "random.Generator.beta(a, b)", "intent": "Draw samples from `a` Beta distribution . With arguments `b`. numpy", "question_id": 22398}
{"snippet": "random.Generator.beta(a, b, size=None)", "intent": "Draw samples from `a` Beta distribution . With arguments `b`, `size`. numpy", "question_id": 22399}
{"snippet": "random.RandomState.exponential()", "intent": "Draw samples from an exponential distribution . numpy", "question_id": 22400}
{"snippet": "random.RandomState.exponential(scale=1.0)", "intent": "Draw samples from an exponential distribution . \\ ( \\beta\\ ) is the `scale` parameter , which is the inverse of the rate parameter \\ ( \\lambda = 1/\\beta\\ ) . numpy", "question_id": 22401}
{"snippet": "random.RandomState.exponential(size=None)", "intent": "Draw samples from an exponential distribution . It describes many common situations , such as the `size` of raindrops measured over many rainstorms [ 1 ] , or the time between page requests to Wikipedia [ 2 ] . numpy", "question_id": 22402}
{"snippet": "random.RandomState.exponential(scale=1.0, size=None)", "intent": "Draw samples from an exponential distribution . \\ ( \\beta\\ ) is the `scale` parameter , which is the inverse of the rate parameter \\ ( \\lambda = 1/\\beta\\ ) . It describes many common situations , such as the `size` of raindrops measured over many rainstorms [ 1 ] , or the time between page requests to Wikipedia [ 2 ] . numpy", "question_id": 22403}
{"snippet": "char.replace(a, old, new)", "intent": "For each element in `a` , return a copy of the string with all occurrences of substring `old` replaced by `new` . numpy", "question_id": 22404}
{"snippet": "char.replace(a, old, new, count=None)", "intent": "For each element in `a` , return a copy of the string with all occurrences of substring `old` replaced by `new` . With arguments `count`. numpy", "question_id": 22405}
{"snippet": "ma.soften_mask(self)", "intent": "Force the mask to soft . With arguments `self`. numpy", "question_id": 22406}
{"snippet": "recarray.flat", "intent": "A 1-D iterator over the array. numpy", "question_id": 22407}
{"snippet": "char.rjust(a, width)", "intent": "Return an array with the elements of `a` right-justified in a string of length `width` . numpy", "question_id": 22408}
{"snippet": "char.rjust(a, width, fillchar=' ')", "intent": "Return an array with the elements of `a` right-justified in a string of length `width` . With arguments `fillchar`. numpy", "question_id": 22409}
{"snippet": "numpy.mat(data)", "intent": "Interpret the input as a matrix . Equivalent to matrix ( `data` , copy=False ) . numpy", "question_id": 22410}
{"snippet": "numpy.mat(data, dtype=None)", "intent": "Interpret the input as a matrix . Equivalent to matrix ( `data` , copy=False ) . With arguments `dtype`. numpy", "question_id": 22411}
{"snippet": "polynomial.laguerre.lagfit(x, y, deg)", "intent": "Least squares fit of Laguerre series to data . Return the coefficients of a Laguerre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . numpy", "question_id": 22412}
{"snippet": "polynomial.laguerre.lagfit(x, y, deg, rcond=None)", "intent": "Least squares fit of Laguerre series to data . Return the coefficients of a Laguerre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . numpy", "question_id": 22413}
{"snippet": "polynomial.laguerre.lagfit(x, y, deg, full=False)", "intent": "Least squares fit of Laguerre series to data . Return the coefficients of a Laguerre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . With arguments `full`. numpy", "question_id": 22414}
{"snippet": "polynomial.laguerre.lagfit(x, y, deg, w=None)", "intent": "Least squares fit of Laguerre series to data . Return the coefficients of a Laguerre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values . numpy", "question_id": 22415}
{"snippet": "polynomial.laguerre.lagfit(x, y, deg, rcond=None, full=False)", "intent": "Least squares fit of Laguerre series to data . Return the coefficients of a Laguerre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . With arguments `full`. numpy", "question_id": 22416}
{"snippet": "polynomial.laguerre.lagfit(x, y, deg, rcond=None, w=None)", "intent": "Least squares fit of Laguerre series to data . Return the coefficients of a Laguerre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values . numpy", "question_id": 22417}
{"snippet": "polynomial.laguerre.lagfit(x, y, deg, full=False, w=None)", "intent": "Least squares fit of Laguerre series to data . Return the coefficients of a Laguerre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values . With arguments `full`. numpy", "question_id": 22418}
{"snippet": "polynomial.laguerre.lagfit(x, y, deg, rcond=None, full=False, w=None)", "intent": "Least squares fit of Laguerre series to data . Return the coefficients of a Laguerre series of degree `deg` that is the least squares fit to the data values `y` given at points `x` . The `rcond` parameter can also be set to a value smaller than its default , but the resulting fit may be spurious and have large contributions from roundoff error . where V is the weighted pseudo Vandermonde matrix of x , c are the coefficients to be solved for , `w` are the weights , and y are the observed values . With arguments `full`. numpy", "question_id": 22419}
{"snippet": "numpy.expm1(x, /, signature, extobj)", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 22420}
{"snippet": "numpy.expm1(x, /, signature, extobj, out=None)", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 22421}
{"snippet": "numpy.expm1(x, /, signature, extobj, where=True)", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 22422}
{"snippet": "numpy.expm1(x, /, signature, extobj, casting='same_kind')", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 22423}
{"snippet": "numpy.expm1(x, /, signature, extobj, order='K')", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 22424}
{"snippet": "numpy.expm1(x, /, signature, extobj, dtype=None)", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 22425}
{"snippet": "numpy.expm1(x, /, signature, extobj, subok=True)", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 22426}
{"snippet": "numpy.expm1(x, /, signature, extobj, out=None, where=True)", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 22427}
{"snippet": "numpy.expm1(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 22428}
{"snippet": "numpy.expm1(x, /, signature, extobj, out=None, order='K')", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 22429}
{"snippet": "numpy.expm1(x, /, signature)", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`. numpy", "question_id": 22430}
{"snippet": "numpy.expm1(x, /, signature, out=None)", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `out`. numpy", "question_id": 22431}
{"snippet": "numpy.expm1(x, /, signature, where=True)", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `where`. numpy", "question_id": 22432}
{"snippet": "numpy.expm1(x, /, signature, casting='same_kind')", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `casting`. numpy", "question_id": 22433}
{"snippet": "numpy.expm1(x, /, signature, order='K')", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `order`. numpy", "question_id": 22434}
{"snippet": "numpy.expm1(x, /, signature, dtype=None)", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 22435}
{"snippet": "numpy.expm1(x, /, signature, subok=True)", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `subok`. numpy", "question_id": 22436}
{"snippet": "numpy.expm1(x, /, signature, out=None, where=True)", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 22437}
{"snippet": "numpy.expm1(x, /, signature, out=None, casting='same_kind')", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 22438}
{"snippet": "numpy.expm1(x, /, signature, out=None, order='K')", "intent": "Calculate exp ( `x` ) - 1 for all elements in the array . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 22439}
{"snippet": "memmap.mean()", "intent": "Returns the average of the array elements along given `axis` . numpy", "question_id": 22440}
{"snippet": "memmap.mean(axis=None)", "intent": "Returns the average of the array elements along given `axis` . numpy", "question_id": 22441}
{"snippet": "memmap.mean(dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 22442}
{"snippet": "memmap.mean(out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 22443}
{"snippet": "memmap.mean(keepdims=False)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`. numpy", "question_id": 22444}
{"snippet": "memmap.mean(where=True)", "intent": "Returns the average of the array elements along given `axis` . With arguments `where`. numpy", "question_id": 22445}
{"snippet": "memmap.mean(axis=None, dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 22446}
{"snippet": "memmap.mean(axis=None, out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 22447}
{"snippet": "memmap.mean(axis=None, keepdims=False)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`. numpy", "question_id": 22448}
{"snippet": "memmap.mean(axis=None, where=True)", "intent": "Returns the average of the array elements along given `axis` . With arguments `where`. numpy", "question_id": 22449}
{"snippet": "lib.scimath.log10(x)", "intent": "Compute the logarithm base 10 of `x` . numpy", "question_id": 22450}
{"snippet": "ndarray.__add__(value, /)", "intent": "Return self+value . With arguments `value`, `/`. numpy", "question_id": 22451}
{"snippet": "ma.MaskType.sum()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 22452}
{"snippet": "dtype.str", "intent": "The array-protocol typestring of this data-type object. numpy", "question_id": 22453}
{"snippet": "numpy.degrees(x, /, signature, extobj)", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `extobj`. numpy", "question_id": 22454}
{"snippet": "numpy.degrees(x, /, signature, extobj, out=None)", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 22455}
{"snippet": "numpy.degrees(x, /, signature, extobj, where=True)", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `extobj`, `where`. numpy", "question_id": 22456}
{"snippet": "numpy.degrees(x, /, signature, extobj, casting='same_kind')", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 22457}
{"snippet": "numpy.degrees(x, /, signature, extobj, order='K')", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 22458}
{"snippet": "numpy.degrees(x, /, signature, extobj, dtype=None)", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 22459}
{"snippet": "numpy.degrees(x, /, signature, extobj, subok=True)", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 22460}
{"snippet": "numpy.degrees(x, /, signature, extobj, out=None, where=True)", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 22461}
{"snippet": "numpy.degrees(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 22462}
{"snippet": "numpy.degrees(x, /, signature, extobj, out=None, order='K')", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 22463}
{"snippet": "numpy.degrees(x, /, signature)", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`. numpy", "question_id": 22464}
{"snippet": "numpy.degrees(x, /, signature, out=None)", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `out`. numpy", "question_id": 22465}
{"snippet": "numpy.degrees(x, /, signature, where=True)", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `where`. numpy", "question_id": 22466}
{"snippet": "numpy.degrees(x, /, signature, casting='same_kind')", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `casting`. numpy", "question_id": 22467}
{"snippet": "numpy.degrees(x, /, signature, order='K')", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `order`. numpy", "question_id": 22468}
{"snippet": "numpy.degrees(x, /, signature, dtype=None)", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `dtype`. numpy", "question_id": 22469}
{"snippet": "numpy.degrees(x, /, signature, subok=True)", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `subok`. numpy", "question_id": 22470}
{"snippet": "numpy.degrees(x, /, signature, out=None, where=True)", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `out`, `where`. numpy", "question_id": 22471}
{"snippet": "numpy.degrees(x, /, signature, out=None, casting='same_kind')", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `out`, `casting`. numpy", "question_id": 22472}
{"snippet": "numpy.degrees(x, /, signature, out=None, order='K')", "intent": "Convert angles from radians to degrees . With arguments `x`, `/`, `signature`, `out`, `order`. numpy", "question_id": 22473}
{"snippet": "chararray.diagonal()", "intent": "Return specified diagonals . numpy", "question_id": 22474}
{"snippet": "chararray.diagonal(offset=0)", "intent": "Return specified diagonals . With arguments `offset`. numpy", "question_id": 22475}
{"snippet": "chararray.diagonal(axis1=0)", "intent": "Return specified diagonals . With arguments `axis1`. numpy", "question_id": 22476}
{"snippet": "chararray.diagonal(axis2=1)", "intent": "Return specified diagonals . With arguments `axis2`. numpy", "question_id": 22477}
{"snippet": "chararray.diagonal(offset=0, axis1=0)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`. numpy", "question_id": 22478}
{"snippet": "chararray.diagonal(offset=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis2`. numpy", "question_id": 22479}
{"snippet": "chararray.diagonal(axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `axis1`, `axis2`. numpy", "question_id": 22480}
{"snippet": "chararray.diagonal(offset=0, axis1=0, axis2=1)", "intent": "Return specified diagonals . With arguments `offset`, `axis1`, `axis2`. numpy", "question_id": 22481}
{"snippet": "ma.masked_array.mean()", "intent": "Returns the average of the array elements along given `axis` . numpy", "question_id": 22482}
{"snippet": "ma.masked_array.mean(axis=None)", "intent": "Returns the average of the array elements along given `axis` . numpy", "question_id": 22483}
{"snippet": "ma.masked_array.mean(dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 22484}
{"snippet": "ma.masked_array.mean(out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 22485}
{"snippet": "ma.masked_array.mean(keepdims=<no value>)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`. numpy", "question_id": 22486}
{"snippet": "ma.masked_array.mean(axis=None, dtype=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 22487}
{"snippet": "ma.masked_array.mean(axis=None, out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 22488}
{"snippet": "ma.masked_array.mean(axis=None, keepdims=<no value>)", "intent": "Returns the average of the array elements along given `axis` . With arguments `keepdims`. numpy", "question_id": 22489}
{"snippet": "ma.masked_array.mean(dtype=None, out=None)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 22490}
{"snippet": "ma.masked_array.mean(dtype=None, keepdims=<no value>)", "intent": "Returns the average of the array elements along given `axis` . With arguments `dtype`, `keepdims`. numpy", "question_id": 22491}
{"snippet": "ndarray.__pos__(/)", "intent": "+self With arguments `/`. numpy", "question_id": 22492}
{"snippet": "ma.masked_array.fill(value)", "intent": "Fill the array with a scalar `value` . numpy", "question_id": 22493}
{"snippet": "ma.masked_array.getfield(dtype)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements . numpy", "question_id": 22494}
{"snippet": "ma.masked_array.getfield(dtype, offset=0)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements . The values in the view are determined by the given type and the `offset` into the current array in bytes . numpy", "question_id": 22495}
{"snippet": "polynomial.polynomial.polygrid3d(x, y, z, c)", "intent": "Evaluate a 3-D polynomial on the Cartesian product of `x` , `y` and `z` . where the points ( a , b , `c` ) consist of all triples formed by taking a from x , b from y , and c from z . numpy", "question_id": 22496}
{"snippet": "dtype.fields", "intent": "Dictionary of named fields defined for this data type, or None. numpy", "question_id": 22497}
{"snippet": "ma.MaskedArray.__array__(dtype, /)", "intent": "Returns either a new reference to self if `dtype` is not given or a new array of provided data type if dtype is different from the current dtype of the array . With arguments `/`. numpy", "question_id": 22498}
{"snippet": "ma.MaskedArray.__array__(dtype)", "intent": "Returns either a new reference to self if `dtype` is not given or a new array of provided data type if dtype is different from the current dtype of the array . numpy", "question_id": 22499}
{"snippet": "generic.T", "intent": "Scalar attribute identical to the corresponding array attribute. numpy", "question_id": 22500}
{"snippet": "fft.rfftfreq(n)", "intent": "Return the Discrete Fourier Transform sample frequencies ( for usage with rfft , irfft ) . Given a window length `n` and a sample spacing `d` : numpy", "question_id": 22501}
{"snippet": "fft.rfftfreq(n, d=1.0)", "intent": "Return the Discrete Fourier Transform sample frequencies ( for usage with rfft , irfft ) . Given a window length `n` and a sample spacing `d` : numpy", "question_id": 22502}
{"snippet": "chararray.dump(file)", "intent": "Dump a pickle of the array to the specified `file` . numpy", "question_id": 22503}
{"snippet": "ma.masked_array.ids()", "intent": "Return the addresses of the data and mask areas . numpy", "question_id": 22504}
{"snippet": "numpy.array_repr(arr)", "intent": "Return the string representation of an array . With arguments `arr`. numpy", "question_id": 22505}
{"snippet": "numpy.array_repr(arr, max_line_width=None)", "intent": "Return the string representation of an array . With arguments `arr`, `max_line_width`. numpy", "question_id": 22506}
{"snippet": "numpy.array_repr(arr, precision=None)", "intent": "Return the string representation of an array . With arguments `arr`, `precision`. numpy", "question_id": 22507}
{"snippet": "numpy.array_repr(arr, suppress_small=None)", "intent": "Return the string representation of an array . With arguments `arr`, `suppress_small`. numpy", "question_id": 22508}
{"snippet": "numpy.array_repr(arr, max_line_width=None, precision=None)", "intent": "Return the string representation of an array . With arguments `arr`, `max_line_width`, `precision`. numpy", "question_id": 22509}
{"snippet": "numpy.array_repr(arr, max_line_width=None, suppress_small=None)", "intent": "Return the string representation of an array . With arguments `arr`, `max_line_width`, `suppress_small`. numpy", "question_id": 22510}
{"snippet": "numpy.array_repr(arr, precision=None, suppress_small=None)", "intent": "Return the string representation of an array . With arguments `arr`, `precision`, `suppress_small`. numpy", "question_id": 22511}
{"snippet": "numpy.array_repr(arr, max_line_width=None, precision=None, suppress_small=None)", "intent": "Return the string representation of an array . With arguments `arr`, `max_line_width`, `precision`, `suppress_small`. numpy", "question_id": 22512}
{"snippet": "random.Generator.gumbel()", "intent": "Draw samples from a Gumbel distribution . numpy", "question_id": 22513}
{"snippet": "random.Generator.gumbel(loc=0.0)", "intent": "Draw samples from a Gumbel distribution . With arguments `loc`. numpy", "question_id": 22514}
{"snippet": "random.Generator.gumbel(scale=1.0)", "intent": "Draw samples from a Gumbel distribution . Draw samples from a Gumbel distribution with specified location and `scale` . numpy", "question_id": 22515}
{"snippet": "random.Generator.gumbel(size=None)", "intent": "Draw samples from a Gumbel distribution . With arguments `size`. numpy", "question_id": 22516}
{"snippet": "random.Generator.gumbel(loc=0.0, scale=1.0)", "intent": "Draw samples from a Gumbel distribution . Draw samples from a Gumbel distribution with specified location and `scale` . With arguments `loc`. numpy", "question_id": 22517}
{"snippet": "random.Generator.gumbel(loc=0.0, size=None)", "intent": "Draw samples from a Gumbel distribution . With arguments `loc`, `size`. numpy", "question_id": 22518}
{"snippet": "random.Generator.gumbel(scale=1.0, size=None)", "intent": "Draw samples from a Gumbel distribution . Draw samples from a Gumbel distribution with specified location and `scale` . With arguments `size`. numpy", "question_id": 22519}
{"snippet": "random.Generator.gumbel(loc=0.0, scale=1.0, size=None)", "intent": "Draw samples from a Gumbel distribution . Draw samples from a Gumbel distribution with specified location and `scale` . With arguments `loc`, `size`. numpy", "question_id": 22520}
{"snippet": "polynomial.hermite.hermmul(c1, c2)", "intent": "Multiply one Hermite series by another . Returns the product of two Hermite series `c1` * `c2` . numpy", "question_id": 22521}
{"snippet": "ndarray.__ifloordiv__(value, /)", "intent": "Return self//=value . With arguments `value`, `/`. numpy", "question_id": 22522}
{"snippet": "ndarray.flat", "intent": "A 1-D iterator over the array. numpy", "question_id": 22523}
{"snippet": "chararray.clip(**kwargs)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 22524}
{"snippet": "chararray.clip(**kwargs, min=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 22525}
{"snippet": "chararray.clip(**kwargs, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 22526}
{"snippet": "chararray.clip(**kwargs, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 22527}
{"snippet": "chararray.clip(**kwargs, min=None, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 22528}
{"snippet": "chararray.clip(**kwargs, min=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 22529}
{"snippet": "chararray.clip(**kwargs, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 22530}
{"snippet": "chararray.clip(**kwargs, min=None, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 22531}
{"snippet": "char.center(a, width)", "intent": "Return `a` copy of a with its elements centered in a string of length `width` . numpy", "question_id": 22532}
{"snippet": "char.center(a, width, fillchar=' ')", "intent": "Return `a` copy of a with its elements centered in a string of length `width` . With arguments `fillchar`. numpy", "question_id": 22533}
{"snippet": "polynomial.polyutils.trimcoef(c)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . With arguments `c`. numpy", "question_id": 22534}
{"snippet": "polynomial.polyutils.trimcoef(c, tol=0)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . \u201c Small \u201d means \u201c small in absolute value \u201d and is controlled by the parameter `tol` ; \u201c trailing \u201d means highest order coefficient ( s ) , e.g. , in [ 0 , 1 , 1 , 0 , 0 ] ( which represents 0 + x + x * * 2 + 0 * x * * 3 + 0 * x * * 4 ) both the 3-rd and 4-th order coefficients would be \u201c trimmed . \u201d With arguments `c`. numpy", "question_id": 22535}
{"snippet": "chararray.transpose(*axes)", "intent": "Returns a view of the array with axes transposed . With arguments `*axes`. numpy", "question_id": 22536}
{"snippet": "polynomial.chebyshev.Chebyshev.integ()", "intent": "Integrate . numpy", "question_id": 22537}
{"snippet": "polynomial.chebyshev.Chebyshev.integ(m=1)", "intent": "Integrate . With arguments `m`. numpy", "question_id": 22538}
{"snippet": "polynomial.chebyshev.Chebyshev.integ(k=)", "intent": "Integrate . With arguments `k`. numpy", "question_id": 22539}
{"snippet": "polynomial.chebyshev.Chebyshev.integ(lbnd=None)", "intent": "Integrate . With arguments `lbnd`. numpy", "question_id": 22540}
{"snippet": "polynomial.chebyshev.Chebyshev.integ(m=1, k=)", "intent": "Integrate . With arguments `m`, `k`. numpy", "question_id": 22541}
{"snippet": "polynomial.chebyshev.Chebyshev.integ(m=1, lbnd=None)", "intent": "Integrate . With arguments `m`, `lbnd`. numpy", "question_id": 22542}
{"snippet": "polynomial.chebyshev.Chebyshev.integ(k=, lbnd=None)", "intent": "Integrate . With arguments `k`, `lbnd`. numpy", "question_id": 22543}
{"snippet": "polynomial.chebyshev.Chebyshev.integ(m=1, k=, lbnd=None)", "intent": "Integrate . With arguments `m`, `k`, `lbnd`. numpy", "question_id": 22544}
{"snippet": "polynomial.chebyshev.Chebyshev.integ()", "intent": "Integrate . numpy", "question_id": 22545}
{"snippet": "polynomial.chebyshev.Chebyshev.integ(m=1)", "intent": "Integrate . With arguments `m`. numpy", "question_id": 22546}
{"snippet": "polynomial.chebyshev.Chebyshev.integ(k=)", "intent": "Integrate . With arguments `k`. numpy", "question_id": 22547}
{"snippet": "polynomial.chebyshev.Chebyshev.integ(lbnd=None)", "intent": "Integrate . With arguments `lbnd`. numpy", "question_id": 22548}
{"snippet": "polynomial.chebyshev.Chebyshev.integ(m=1, k=)", "intent": "Integrate . With arguments `m`, `k`. numpy", "question_id": 22549}
{"snippet": "polynomial.chebyshev.Chebyshev.integ(m=1, lbnd=None)", "intent": "Integrate . With arguments `m`, `lbnd`. numpy", "question_id": 22550}
{"snippet": "polynomial.chebyshev.Chebyshev.integ(k=, lbnd=None)", "intent": "Integrate . With arguments `k`, `lbnd`. numpy", "question_id": 22551}
{"snippet": "polynomial.chebyshev.Chebyshev.integ(m=1, k=, lbnd=None)", "intent": "Integrate . With arguments `m`, `k`, `lbnd`. numpy", "question_id": 22552}
{"snippet": "char.chararray.min()", "intent": "Return the minimum along a given `axis` . numpy", "question_id": 22553}
{"snippet": "char.chararray.min(axis=None)", "intent": "Return the minimum along a given `axis` . numpy", "question_id": 22554}
{"snippet": "char.chararray.min(out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`. numpy", "question_id": 22555}
{"snippet": "char.chararray.min(keepdims=False)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 22556}
{"snippet": "char.chararray.min(initial=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `initial`. numpy", "question_id": 22557}
{"snippet": "char.chararray.min(where=True)", "intent": "Return the minimum along a given `axis` . With arguments `where`. numpy", "question_id": 22558}
{"snippet": "char.chararray.min(axis=None, out=None)", "intent": "Return the minimum along a given `axis` . With arguments `out`. numpy", "question_id": 22559}
{"snippet": "char.chararray.min(axis=None, keepdims=False)", "intent": "Return the minimum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 22560}
{"snippet": "char.chararray.min(axis=None, initial=<no value>)", "intent": "Return the minimum along a given `axis` . With arguments `initial`. numpy", "question_id": 22561}
{"snippet": "char.chararray.min(axis=None, where=True)", "intent": "Return the minimum along a given `axis` . With arguments `where`. numpy", "question_id": 22562}
{"snippet": "ndindex.ndincr()", "intent": "Increment the multi-dimensional index by one . numpy", "question_id": 22563}
{"snippet": "memmap.base", "intent": "Base object if memory is from some other object. numpy", "question_id": 22564}
{"snippet": "testing.Tester.test()", "intent": "Run tests for module using nose . numpy", "question_id": 22565}
{"snippet": "testing.Tester.test(label='fast')", "intent": "Run tests for module using nose . With arguments `label`. numpy", "question_id": 22566}
{"snippet": "testing.Tester.test(verbose=1)", "intent": "Run tests for module using nose . With arguments `verbose`. numpy", "question_id": 22567}
{"snippet": "testing.Tester.test(extra_argv=None)", "intent": "Run tests for module using nose . With arguments `extra_argv`. numpy", "question_id": 22568}
{"snippet": "testing.Tester.test(doctests=False)", "intent": "Run tests for module using nose . With arguments `doctests`. numpy", "question_id": 22569}
{"snippet": "testing.Tester.test(coverage=False)", "intent": "Run tests for module using nose . With arguments `coverage`. numpy", "question_id": 22570}
{"snippet": "testing.Tester.test(raise_warnings=None)", "intent": "Run tests for module using nose . With arguments `raise_warnings`. numpy", "question_id": 22571}
{"snippet": "testing.Tester.test(timer=False)", "intent": "Run tests for module using nose . With arguments `timer`. numpy", "question_id": 22572}
{"snippet": "testing.Tester.test(label='fast', verbose=1)", "intent": "Run tests for module using nose . With arguments `label`, `verbose`. numpy", "question_id": 22573}
{"snippet": "testing.Tester.test(label='fast', extra_argv=None)", "intent": "Run tests for module using nose . With arguments `label`, `extra_argv`. numpy", "question_id": 22574}
{"snippet": "ma.indices(dimensions)", "intent": "Return an array representing the indices of a grid . The output shape in the dense case is obtained by prepending the number of `dimensions` in front of the tuple of dimensions , i.e . numpy", "question_id": 22575}
{"snippet": "ma.indices(dimensions, dtype=<class 'int'>)", "intent": "Return an array representing the indices of a grid . The output shape in the dense case is obtained by prepending the number of `dimensions` in front of the tuple of dimensions , i.e . With arguments `dtype`. numpy", "question_id": 22576}
{"snippet": "ma.indices(dimensions, sparse=False)", "intent": "Return an array representing the indices of a grid . The output shape in the dense case is obtained by prepending the number of `dimensions` in front of the tuple of dimensions , i.e . If `sparse` is set to true , the grid will be returned in a sparse representation . numpy", "question_id": 22577}
{"snippet": "ma.indices(dimensions, dtype=<class 'int'>, sparse=False)", "intent": "Return an array representing the indices of a grid . The output shape in the dense case is obtained by prepending the number of `dimensions` in front of the tuple of dimensions , i.e . If `sparse` is set to true , the grid will be returned in a sparse representation . With arguments `dtype`. numpy", "question_id": 22578}
{"snippet": "recarray.nonzero()", "intent": "Return the indices of the elements that are non-zero . numpy", "question_id": 22579}
{"snippet": "numpy.ma.MaskType", "intent": "alias of numpy.bool_ numpy", "question_id": 22580}
{"snippet": "ma.MaskedArray.__rand__(value, /)", "intent": "Return `value` & self . With arguments `/`. numpy", "question_id": 22581}
{"snippet": "ma.masked_array.max()", "intent": "Return the maximum along a given `axis` . numpy", "question_id": 22582}
{"snippet": "ma.masked_array.max(axis=None)", "intent": "Return the maximum along a given `axis` . numpy", "question_id": 22583}
{"snippet": "ma.masked_array.max(out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`. numpy", "question_id": 22584}
{"snippet": "ma.masked_array.max(fill_value=None)", "intent": "Return the maximum along a given `axis` . With arguments `fill_value`. numpy", "question_id": 22585}
{"snippet": "ma.masked_array.max(keepdims=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 22586}
{"snippet": "ma.masked_array.max(axis=None, out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`. numpy", "question_id": 22587}
{"snippet": "ma.masked_array.max(axis=None, fill_value=None)", "intent": "Return the maximum along a given `axis` . With arguments `fill_value`. numpy", "question_id": 22588}
{"snippet": "ma.masked_array.max(axis=None, keepdims=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 22589}
{"snippet": "ma.masked_array.max(out=None, fill_value=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`, `fill_value`. numpy", "question_id": 22590}
{"snippet": "ma.masked_array.max(out=None, keepdims=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `out`, `keepdims`. numpy", "question_id": 22591}
{"snippet": "ma.MaskedArray.choose(choices)", "intent": "Use an index array to construct a new array from a set of `choices` . numpy", "question_id": 22592}
{"snippet": "ma.MaskedArray.choose(choices, out=None)", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`. numpy", "question_id": 22593}
{"snippet": "ma.MaskedArray.choose(choices, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `mode`. numpy", "question_id": 22594}
{"snippet": "ma.MaskedArray.choose(choices, out=None, mode='raise')", "intent": "Use an index array to construct a new array from a set of `choices` . With arguments `out`, `mode`. numpy", "question_id": 22595}
{"snippet": "recarray.ravel(order)", "intent": "Return a flattened array . With arguments `order`. numpy", "question_id": 22596}
{"snippet": "recarray.ravel()", "intent": "Return a flattened array . numpy", "question_id": 22597}
{"snippet": "memmap.clip(**kwargs)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 22598}
{"snippet": "memmap.clip(**kwargs, min=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 22599}
{"snippet": "memmap.clip(**kwargs, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 22600}
{"snippet": "memmap.clip(**kwargs, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 22601}
{"snippet": "memmap.clip(**kwargs, min=None, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 22602}
{"snippet": "memmap.clip(**kwargs, min=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 22603}
{"snippet": "memmap.clip(**kwargs, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 22604}
{"snippet": "memmap.clip(**kwargs, min=None, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 22605}
{"snippet": "ma.MaskedArray.__repr__()", "intent": "Literal string representation . numpy", "question_id": 22606}
{"snippet": "ma.MaskType.copy()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 22607}
{"snippet": "polynomial.hermite.hermgauss(deg)", "intent": "Gauss-Hermite quadrature . These sample points and weights will correctly integrate polynomials of degree \\ ( 2 * `deg` - 1\\ ) or less over the interval \\ ( [ -\\inf , \\inf ] \\ ) with the weight function \\ ( f ( x ) = \\exp ( -x^2 ) \\ ) . numpy", "question_id": 22608}
{"snippet": "recarray.reshape(shape)", "intent": "Returns an array containing the same data with a new `shape` . numpy", "question_id": 22609}
{"snippet": "recarray.reshape(shape, order='C')", "intent": "Returns an array containing the same data with a new `shape` . With arguments `order`. numpy", "question_id": 22610}
{"snippet": "random.gamma(shape)", "intent": "Draw samples from a Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and `scale` ( sometimes designated \u201c theta \u201d ) , where both parameters are > 0 . numpy", "question_id": 22611}
{"snippet": "random.gamma(shape, scale=1.0)", "intent": "Draw samples from a Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and `scale` ( sometimes designated \u201c theta \u201d ) , where both parameters are > 0 . numpy", "question_id": 22612}
{"snippet": "random.gamma(shape, size=None)", "intent": "Draw samples from a Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and `scale` ( sometimes designated \u201c theta \u201d ) , where both parameters are > 0 . With arguments `size`. numpy", "question_id": 22613}
{"snippet": "random.gamma(shape, scale=1.0, size=None)", "intent": "Draw samples from a Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and `scale` ( sometimes designated \u201c theta \u201d ) , where both parameters are > 0 . With arguments `size`. numpy", "question_id": 22614}
{"snippet": "numpy.ptp(a)", "intent": "Range of values ( maximum - minimum ) along an `axis` . This example shows that `a` negative value can be returned when the input is an array of signed integers . numpy", "question_id": 22615}
{"snippet": "numpy.ptp(a, axis=None)", "intent": "Range of values ( maximum - minimum ) along an `axis` . This example shows that `a` negative value can be returned when the input is an array of signed integers . numpy", "question_id": 22616}
{"snippet": "numpy.ptp(a, out=None)", "intent": "Range of values ( maximum - minimum ) along an `axis` . This example shows that `a` negative value can be returned when the input is an array of signed integers . With arguments `out`. numpy", "question_id": 22617}
{"snippet": "numpy.ptp(a, keepdims=<no value>)", "intent": "Range of values ( maximum - minimum ) along an `axis` . This example shows that `a` negative value can be returned when the input is an array of signed integers . With arguments `keepdims`. numpy", "question_id": 22618}
{"snippet": "numpy.ptp(a, axis=None, out=None)", "intent": "Range of values ( maximum - minimum ) along an `axis` . This example shows that `a` negative value can be returned when the input is an array of signed integers . With arguments `out`. numpy", "question_id": 22619}
{"snippet": "numpy.ptp(a, axis=None, keepdims=<no value>)", "intent": "Range of values ( maximum - minimum ) along an `axis` . This example shows that `a` negative value can be returned when the input is an array of signed integers . With arguments `keepdims`. numpy", "question_id": 22620}
{"snippet": "numpy.ptp(a, out=None, keepdims=<no value>)", "intent": "Range of values ( maximum - minimum ) along an `axis` . This example shows that `a` negative value can be returned when the input is an array of signed integers . With arguments `out`, `keepdims`. numpy", "question_id": 22621}
{"snippet": "numpy.ptp(a, axis=None, out=None, keepdims=<no value>)", "intent": "Range of values ( maximum - minimum ) along an `axis` . This example shows that `a` negative value can be returned when the input is an array of signed integers . With arguments `out`, `keepdims`. numpy", "question_id": 22622}
{"snippet": "dtype.descr", "intent": "__array_interface__ description of the data-type. numpy", "question_id": 22623}
{"snippet": "chararray.isnumeric()", "intent": "For each element in self , return True if there are only numeric characters in the element . numpy", "question_id": 22624}
{"snippet": "generic.__array_interface__", "intent": "Array protocol: Python side numpy", "question_id": 22625}
{"snippet": "ma.masked_array.setfield(val, dtype)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field . numpy", "question_id": 22626}
{"snippet": "ma.masked_array.setfield(val, dtype, offset=0)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field . numpy", "question_id": 22627}
{"snippet": "polynomial.legendre.legmul(c1, c2)", "intent": "Multiply one Legendre series by another . Returns the product of two Legendre series `c1` * `c2` . numpy", "question_id": 22628}
{"snippet": "numpy.nanstd(a)", "intent": "Compute the standard deviation along the specified `axis` , while ignoring NaNs . Returns the standard deviation , `a` measure of the spread of a distribution , of the non-NaN array elements . numpy", "question_id": 22629}
{"snippet": "numpy.nanstd(a, axis=None)", "intent": "Compute the standard deviation along the specified `axis` , while ignoring NaNs . Returns the standard deviation , `a` measure of the spread of a distribution , of the non-NaN array elements . numpy", "question_id": 22630}
{"snippet": "numpy.nanstd(a, dtype=None)", "intent": "Compute the standard deviation along the specified `axis` , while ignoring NaNs . Returns the standard deviation , `a` measure of the spread of a distribution , of the non-NaN array elements . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue . numpy", "question_id": 22631}
{"snippet": "numpy.nanstd(a, out=None)", "intent": "Compute the standard deviation along the specified `axis` , while ignoring NaNs . Returns the standard deviation , `a` measure of the spread of a distribution , of the non-NaN array elements . With arguments `out`. numpy", "question_id": 22632}
{"snippet": "numpy.nanstd(a, ddof=0)", "intent": "Compute the standard deviation along the specified `axis` , while ignoring NaNs . Returns the standard deviation , `a` measure of the spread of a distribution , of the non-NaN array elements . If , however , `ddof` is specified , the divisor N - ddof is used instead . numpy", "question_id": 22633}
{"snippet": "numpy.nanstd(a, keepdims=<no value>)", "intent": "Compute the standard deviation along the specified `axis` , while ignoring NaNs . Returns the standard deviation , `a` measure of the spread of a distribution , of the non-NaN array elements . With arguments `keepdims`. numpy", "question_id": 22634}
{"snippet": "numpy.nanstd(a, axis=None, dtype=None)", "intent": "Compute the standard deviation along the specified `axis` , while ignoring NaNs . Returns the standard deviation , `a` measure of the spread of a distribution , of the non-NaN array elements . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue . numpy", "question_id": 22635}
{"snippet": "numpy.nanstd(a, axis=None, out=None)", "intent": "Compute the standard deviation along the specified `axis` , while ignoring NaNs . Returns the standard deviation , `a` measure of the spread of a distribution , of the non-NaN array elements . With arguments `out`. numpy", "question_id": 22636}
{"snippet": "numpy.nanstd(a, axis=None, ddof=0)", "intent": "Compute the standard deviation along the specified `axis` , while ignoring NaNs . Returns the standard deviation , `a` measure of the spread of a distribution , of the non-NaN array elements . If , however , `ddof` is specified , the divisor N - ddof is used instead . numpy", "question_id": 22637}
{"snippet": "numpy.nanstd(a, axis=None, keepdims=<no value>)", "intent": "Compute the standard deviation along the specified `axis` , while ignoring NaNs . Returns the standard deviation , `a` measure of the spread of a distribution , of the non-NaN array elements . With arguments `keepdims`. numpy", "question_id": 22638}
{"snippet": "polynomial.chebyshev.Chebyshev.__call__(arg)", "intent": "Call self as a function . With arguments `arg`. numpy", "question_id": 22639}
{"snippet": "dtype.shape", "intent": "Shape tuple of the sub-array if this data type describes a sub-array, and () otherwise. numpy", "question_id": 22640}
{"snippet": "linalg.cholesky(a)", "intent": "Cholesky decomposition . Return the Cholesky decomposition , L * L.H , of the square matrix `a` , where L is lower-triangular and .H is the conjugate transpose operator ( which is the ordinary transpose if a is real-valued ) . numpy", "question_id": 22641}
{"snippet": "ma.masked_greater(x, value)", "intent": "Mask an array where greater than a given `value` . This function is a shortcut to masked_where , with condition = ( `x` > value ) . numpy", "question_id": 22642}
{"snippet": "ma.masked_greater(x, value, copy=True)", "intent": "Mask an array where greater than a given `value` . This function is a shortcut to masked_where , with condition = ( `x` > value ) . With arguments `copy`. numpy", "question_id": 22643}
{"snippet": "numpy.asscalar(a)", "intent": "Convert an array of size 1 to its scalar equivalent . With arguments `a`. numpy", "question_id": 22644}
{"snippet": "chararray.isspace()", "intent": "Returns true for each element if there are only whitespace characters in the string and there is at least one character , false otherwise . numpy", "question_id": 22645}
{"snippet": "distutils.system_info.get_standard_file(fname)", "intent": "Returns a list of files named \u2018 `fname` \u2019 from 1 ) System-wide directory ( directory-location of this module ) 2 ) Users HOME directory ( os.environ [ \u2018 HOME \u2019 ] ) 3 ) Local directory numpy", "question_id": 22646}
{"snippet": "numpy.maximum_sctype(t)", "intent": "Return the scalar type of highest precision of the same kind as the input . With arguments `t`. numpy", "question_id": 22647}
{"snippet": "ma.where(condition)", "intent": "Return a masked array with elements from `x` or `y` , depending on `condition` . numpy", "question_id": 22648}
{"snippet": "ma.where(condition, x=<no value>)", "intent": "Return a masked array with elements from `x` or `y` , depending on `condition` . numpy", "question_id": 22649}
{"snippet": "ma.where(condition, y=<no value>)", "intent": "Return a masked array with elements from `x` or `y` , depending on `condition` . numpy", "question_id": 22650}
{"snippet": "ma.where(condition, x=<no value>, y=<no value>)", "intent": "Return a masked array with elements from `x` or `y` , depending on `condition` . numpy", "question_id": 22651}
{"snippet": "polynomial.laguerre.Laguerre.integ()", "intent": "Integrate . numpy", "question_id": 22652}
{"snippet": "polynomial.laguerre.Laguerre.integ(m=1)", "intent": "Integrate . With arguments `m`. numpy", "question_id": 22653}
{"snippet": "polynomial.laguerre.Laguerre.integ(k=)", "intent": "Integrate . With arguments `k`. numpy", "question_id": 22654}
{"snippet": "polynomial.laguerre.Laguerre.integ(lbnd=None)", "intent": "Integrate . With arguments `lbnd`. numpy", "question_id": 22655}
{"snippet": "polynomial.laguerre.Laguerre.integ(m=1, k=)", "intent": "Integrate . With arguments `m`, `k`. numpy", "question_id": 22656}
{"snippet": "polynomial.laguerre.Laguerre.integ(m=1, lbnd=None)", "intent": "Integrate . With arguments `m`, `lbnd`. numpy", "question_id": 22657}
{"snippet": "polynomial.laguerre.Laguerre.integ(k=, lbnd=None)", "intent": "Integrate . With arguments `k`, `lbnd`. numpy", "question_id": 22658}
{"snippet": "polynomial.laguerre.Laguerre.integ(m=1, k=, lbnd=None)", "intent": "Integrate . With arguments `m`, `k`, `lbnd`. numpy", "question_id": 22659}
{"snippet": "polynomial.laguerre.Laguerre.integ()", "intent": "Integrate . numpy", "question_id": 22660}
{"snippet": "polynomial.laguerre.Laguerre.integ(m=1)", "intent": "Integrate . With arguments `m`. numpy", "question_id": 22661}
{"snippet": "polynomial.laguerre.Laguerre.integ(k=)", "intent": "Integrate . With arguments `k`. numpy", "question_id": 22662}
{"snippet": "polynomial.laguerre.Laguerre.integ(lbnd=None)", "intent": "Integrate . With arguments `lbnd`. numpy", "question_id": 22663}
{"snippet": "polynomial.laguerre.Laguerre.integ(m=1, k=)", "intent": "Integrate . With arguments `m`, `k`. numpy", "question_id": 22664}
{"snippet": "polynomial.laguerre.Laguerre.integ(m=1, lbnd=None)", "intent": "Integrate . With arguments `m`, `lbnd`. numpy", "question_id": 22665}
{"snippet": "polynomial.laguerre.Laguerre.integ(k=, lbnd=None)", "intent": "Integrate . With arguments `k`, `lbnd`. numpy", "question_id": 22666}
{"snippet": "polynomial.laguerre.Laguerre.integ(m=1, k=, lbnd=None)", "intent": "Integrate . With arguments `m`, `k`, `lbnd`. numpy", "question_id": 22667}
{"snippet": "ndarray.searchsorted(v)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . numpy", "question_id": 22668}
{"snippet": "ndarray.searchsorted(v, side='left')", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`. numpy", "question_id": 22669}
{"snippet": "ndarray.searchsorted(v, sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `sorter`. numpy", "question_id": 22670}
{"snippet": "ndarray.searchsorted(v, side='left', sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`, `sorter`. numpy", "question_id": 22671}
{"snippet": "polynomial.chebyshev.Chebyshev.fromroots(roots)", "intent": "Return series instance that has the specified `roots` . numpy", "question_id": 22672}
{"snippet": "polynomial.chebyshev.Chebyshev.fromroots(roots, domain=)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`. numpy", "question_id": 22673}
{"snippet": "polynomial.chebyshev.Chebyshev.fromroots(roots, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `window`. numpy", "question_id": 22674}
{"snippet": "polynomial.chebyshev.Chebyshev.fromroots(roots, domain=, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`, `window`. numpy", "question_id": 22675}
{"snippet": "polynomial.chebyshev.Chebyshev.fromroots()", "intent": "Return series instance that has the specified `roots` . numpy", "question_id": 22676}
{"snippet": "polynomial.chebyshev.Chebyshev.fromroots(domain=)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`. numpy", "question_id": 22677}
{"snippet": "polynomial.chebyshev.Chebyshev.fromroots(window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `window`. numpy", "question_id": 22678}
{"snippet": "polynomial.chebyshev.Chebyshev.fromroots(domain=, window=None)", "intent": "Return series instance that has the specified `roots` . With arguments `domain`, `window`. numpy", "question_id": 22679}
{"snippet": "distutils.exec_command.forward_bytes_to_stdout(val)", "intent": "Forward bytes from a subprocess call to the console , without attempting to decode them . With arguments `val`. numpy", "question_id": 22680}
{"snippet": "random.beta(a, b)", "intent": "Draw samples from `a` Beta distribution . With arguments `b`. numpy", "question_id": 22681}
{"snippet": "random.beta(a, b, size=None)", "intent": "Draw samples from `a` Beta distribution . With arguments `b`, `size`. numpy", "question_id": 22682}
{"snippet": "random.RandomState.zipf(a)", "intent": "Draw samples from `a` Zipf distribution . numpy", "question_id": 22683}
{"snippet": "random.RandomState.zipf(a, size=None)", "intent": "Draw samples from `a` Zipf distribution . With arguments `size`. numpy", "question_id": 22684}
{"snippet": "ma.empty(shape)", "intent": "Return a new array of given `shape` and type , without initializing entries . numpy", "question_id": 22685}
{"snippet": "ma.empty(shape, dtype=float)", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `dtype`. numpy", "question_id": 22686}
{"snippet": "ma.empty(shape, order='C')", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `order`. numpy", "question_id": 22687}
{"snippet": "ma.empty(shape, like=None)", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `like`. numpy", "question_id": 22688}
{"snippet": "ma.empty(shape, dtype=float, order='C')", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `dtype`, `order`. numpy", "question_id": 22689}
{"snippet": "ma.empty(shape, dtype=float, like=None)", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `dtype`, `like`. numpy", "question_id": 22690}
{"snippet": "ma.empty(shape, order='C', like=None)", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `order`, `like`. numpy", "question_id": 22691}
{"snippet": "ma.empty(shape, dtype=float, order='C', like=None)", "intent": "Return a new array of given `shape` and type , without initializing entries . With arguments `dtype`, `order`, `like`. numpy", "question_id": 22692}
{"snippet": "ma.masked_array.flatten()", "intent": "Return a copy of the array collapsed into one dimension . numpy", "question_id": 22693}
{"snippet": "ma.masked_array.flatten(order='C')", "intent": "Return a copy of the array collapsed into one dimension . With arguments `order`. numpy", "question_id": 22694}
{"snippet": "numpy.matrix(data)", "intent": "Returns a matrix from an array-like object , or from a string of `data` . numpy", "question_id": 22695}
{"snippet": "numpy.matrix(data, dtype=None)", "intent": "Returns a matrix from an array-like object , or from a string of `data` . With arguments `dtype`. numpy", "question_id": 22696}
{"snippet": "numpy.matrix(data, copy=True)", "intent": "Returns a matrix from an array-like object , or from a string of `data` . With arguments `copy`. numpy", "question_id": 22697}
{"snippet": "numpy.matrix(data, dtype=None, copy=True)", "intent": "Returns a matrix from an array-like object , or from a string of `data` . With arguments `dtype`, `copy`. numpy", "question_id": 22698}
{"snippet": "numpy.ceil(x, /, signature, extobj)", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 22699}
{"snippet": "numpy.ceil(x, /, signature, extobj, out=None)", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 22700}
{"snippet": "numpy.ceil(x, /, signature, extobj, where=True)", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 22701}
{"snippet": "numpy.ceil(x, /, signature, extobj, casting='same_kind')", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 22702}
{"snippet": "numpy.ceil(x, /, signature, extobj, order='K')", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 22703}
{"snippet": "numpy.ceil(x, /, signature, extobj, dtype=None)", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 22704}
{"snippet": "numpy.ceil(x, /, signature, extobj, subok=True)", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 22705}
{"snippet": "numpy.ceil(x, /, signature, extobj, out=None, where=True)", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 22706}
{"snippet": "numpy.ceil(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 22707}
{"snippet": "numpy.ceil(x, /, signature, extobj, out=None, order='K')", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 22708}
{"snippet": "numpy.ceil(x, /, signature)", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`. numpy", "question_id": 22709}
{"snippet": "numpy.ceil(x, /, signature, out=None)", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `out`. numpy", "question_id": 22710}
{"snippet": "numpy.ceil(x, /, signature, where=True)", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `where`. numpy", "question_id": 22711}
{"snippet": "numpy.ceil(x, /, signature, casting='same_kind')", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `casting`. numpy", "question_id": 22712}
{"snippet": "numpy.ceil(x, /, signature, order='K')", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `order`. numpy", "question_id": 22713}
{"snippet": "numpy.ceil(x, /, signature, dtype=None)", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 22714}
{"snippet": "numpy.ceil(x, /, signature, subok=True)", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `subok`. numpy", "question_id": 22715}
{"snippet": "numpy.ceil(x, /, signature, out=None, where=True)", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 22716}
{"snippet": "numpy.ceil(x, /, signature, out=None, casting='same_kind')", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 22717}
{"snippet": "numpy.ceil(x, /, signature, out=None, order='K')", "intent": "Return the ceiling of the input , element-wise . The ceil of the scalar `x` is the smallest integer i , such that i > = x . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 22718}
{"snippet": "random.RandomState.multivariate_normal(mean, cov)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`. numpy", "question_id": 22719}
{"snippet": "random.RandomState.multivariate_normal(mean, cov, size=None)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `size`. numpy", "question_id": 22720}
{"snippet": "random.RandomState.multivariate_normal(mean, cov, check_valid='warn')", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `check_valid`. numpy", "question_id": 22721}
{"snippet": "random.RandomState.multivariate_normal(mean, cov, tol=1e-8)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `tol`. numpy", "question_id": 22722}
{"snippet": "random.RandomState.multivariate_normal(mean, cov, size=None, check_valid='warn')", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `size`, `check_valid`. numpy", "question_id": 22723}
{"snippet": "random.RandomState.multivariate_normal(mean, cov, size=None, tol=1e-8)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `size`, `tol`. numpy", "question_id": 22724}
{"snippet": "random.RandomState.multivariate_normal(mean, cov, check_valid='warn', tol=1e-8)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `check_valid`, `tol`. numpy", "question_id": 22725}
{"snippet": "random.RandomState.multivariate_normal(mean, cov, size=None, check_valid='warn', tol=1e-8)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `size`, `check_valid`, `tol`. numpy", "question_id": 22726}
{"snippet": "char.title(a)", "intent": "Return element-wise title cased version of string or unicode . With arguments `a`. numpy", "question_id": 22727}
{"snippet": "numpy.fliplr(m)", "intent": "Reverse the order of elements along axis 1 ( left/right ) . Equivalent to `m` [ : , : :-1 ] or np.flip ( m , axis=1 ) . numpy", "question_id": 22728}
{"snippet": "numpy.fmin(x1, x2, /, signature, extobj)", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 22729}
{"snippet": "numpy.fmin(x1, x2, /, signature, extobj, out=None)", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 22730}
{"snippet": "numpy.fmin(x1, x2, /, signature, extobj, where=True)", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 22731}
{"snippet": "numpy.fmin(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 22732}
{"snippet": "numpy.fmin(x1, x2, /, signature, extobj, order='K')", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 22733}
{"snippet": "numpy.fmin(x1, x2, /, signature, extobj, dtype=None)", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 22734}
{"snippet": "numpy.fmin(x1, x2, /, signature, extobj, subok=True)", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 22735}
{"snippet": "numpy.fmin(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 22736}
{"snippet": "numpy.fmin(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 22737}
{"snippet": "numpy.fmin(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 22738}
{"snippet": "numpy.fmin(x1, x2, /, signature)", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`. numpy", "question_id": 22739}
{"snippet": "numpy.fmin(x1, x2, /, signature, out=None)", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`. numpy", "question_id": 22740}
{"snippet": "numpy.fmin(x1, x2, /, signature, where=True)", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `where`. numpy", "question_id": 22741}
{"snippet": "numpy.fmin(x1, x2, /, signature, casting='same_kind')", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `casting`. numpy", "question_id": 22742}
{"snippet": "numpy.fmin(x1, x2, /, signature, order='K')", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `order`. numpy", "question_id": 22743}
{"snippet": "numpy.fmin(x1, x2, /, signature, dtype=None)", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 22744}
{"snippet": "numpy.fmin(x1, x2, /, signature, subok=True)", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `subok`. numpy", "question_id": 22745}
{"snippet": "numpy.fmin(x1, x2, /, signature, out=None, where=True)", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 22746}
{"snippet": "numpy.fmin(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 22747}
{"snippet": "numpy.fmin(x1, x2, /, signature, out=None, order='K')", "intent": "Element-wise minimum of array elements . The fmin is equivalent to np.where ( `x1` < = `x2` , x1 , x2 ) when neither x1 nor x2 are NaNs , but it is faster and does proper broadcasting . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 22748}
{"snippet": "chararray.T", "intent": "The transposed array. numpy", "question_id": 22749}
{"snippet": "ma.MaskedArray.__radd__(other)", "intent": "Add `other` to self , and return a new masked array . numpy", "question_id": 22750}
{"snippet": "polynomial.laguerre.lagcompanion(c)", "intent": "Return the companion matrix of `c` . numpy", "question_id": 22751}
{"snippet": "ndarray.nbytes", "intent": "Total bytes consumed by the elements of the array. numpy", "question_id": 22752}
{"snippet": "polynomial.hermite_e.herme2poly(c)", "intent": "Convert a Hermite series to a polynomial . With arguments `c`. numpy", "question_id": 22753}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.try_dispatch(sources, **kwargs)", "intent": "Compile one or more dispatch-able `sources` and generates object files , also generates abstract C config headers and macros that used later for the final runtime dispatching process . With arguments `**kwargs`. numpy", "question_id": 22754}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.try_dispatch(sources, **kwargs, src_dir=None)", "intent": "Compile one or more dispatch-able `sources` and generates object files , also generates abstract C config headers and macros that used later for the final runtime dispatching process . With arguments `**kwargs`, `src_dir`. numpy", "question_id": 22755}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.try_dispatch(sources, **kwargs, ccompiler=None)", "intent": "Compile one or more dispatch-able `sources` and generates object files , also generates abstract C config headers and macros that used later for the final runtime dispatching process . With arguments `**kwargs`, `ccompiler`. numpy", "question_id": 22756}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.try_dispatch(sources, **kwargs, src_dir=None, ccompiler=None)", "intent": "Compile one or more dispatch-able `sources` and generates object files , also generates abstract C config headers and macros that used later for the final runtime dispatching process . With arguments `**kwargs`, `src_dir`, `ccompiler`. numpy", "question_id": 22757}
{"snippet": "char.chararray.resize(new_shape)", "intent": "Change shape and size of array in-place . With arguments `new_shape`. numpy", "question_id": 22758}
{"snippet": "char.chararray.resize(new_shape, refcheck=True)", "intent": "Change shape and size of array in-place . However , reference counts can increase in other ways so if you are sure that you have not shared the memory for this array with another Python object , then you may safely set `refcheck` to False . With arguments `new_shape`. numpy", "question_id": 22759}
{"snippet": "polynomial.chebyshev.Chebyshev.linspace()", "intent": "Return x , y values at equally spaced points in `domain` . numpy", "question_id": 22760}
{"snippet": "polynomial.chebyshev.Chebyshev.linspace(n=100)", "intent": "Return x , y values at equally spaced points in `domain` . Returns the x , y values at `n` linearly spaced points across the domain . numpy", "question_id": 22761}
{"snippet": "polynomial.chebyshev.Chebyshev.linspace(domain=None)", "intent": "Return x , y values at equally spaced points in `domain` . numpy", "question_id": 22762}
{"snippet": "polynomial.chebyshev.Chebyshev.linspace(n=100, domain=None)", "intent": "Return x , y values at equally spaced points in `domain` . Returns the x , y values at `n` linearly spaced points across the domain . numpy", "question_id": 22763}
{"snippet": "random.uniform()", "intent": "Draw samples from a uniform distribution . numpy", "question_id": 22764}
{"snippet": "random.uniform(low=0.0)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . numpy", "question_id": 22765}
{"snippet": "random.uniform(high=1.0)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . numpy", "question_id": 22766}
{"snippet": "random.uniform(size=None)", "intent": "Draw samples from a uniform distribution . With arguments `size`. numpy", "question_id": 22767}
{"snippet": "random.uniform(low=0.0, high=1.0)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . numpy", "question_id": 22768}
{"snippet": "random.uniform(low=0.0, size=None)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . With arguments `size`. numpy", "question_id": 22769}
{"snippet": "random.uniform(high=1.0, size=None)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . With arguments `size`. numpy", "question_id": 22770}
{"snippet": "random.uniform(low=0.0, high=1.0, size=None)", "intent": "Draw samples from a uniform distribution . Samples are uniformly distributed over the half-open interval [ `low` , `high` ) ( includes low , but excludes high ) . With arguments `size`. numpy", "question_id": 22771}
{"snippet": "polynomial.hermite_e.hermeval2d(x, y, c)", "intent": "Evaluate a 2-D HermiteE series at points ( `x` , `y` ) . In either case , either x and y or their elements must support multiplication and addition both with themselves and with the elements of `c` . numpy", "question_id": 22772}
{"snippet": "record.dtype", "intent": "dtype object numpy", "question_id": 22773}
{"snippet": "polynomial.laguerre.lagvander3d(x, y, z, deg)", "intent": "Pseudo-Vandermonde matrix of given degrees . Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points ( `x` , `y` , `z` ) . numpy", "question_id": 22774}
{"snippet": "numpy.block(arrays)", "intent": "Assemble an nd-array from nested lists of blocks . np.block ( [ [ a , b ] , [ c , d ] ] ) is not restricted to `arrays` of the form : numpy", "question_id": 22775}
{"snippet": "recarray.all()", "intent": "Returns True if all elements evaluate to True . numpy", "question_id": 22776}
{"snippet": "recarray.all(axis=None)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`. numpy", "question_id": 22777}
{"snippet": "recarray.all(out=None)", "intent": "Returns True if all elements evaluate to True . With arguments `out`. numpy", "question_id": 22778}
{"snippet": "recarray.all(keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `keepdims`. numpy", "question_id": 22779}
{"snippet": "recarray.all(where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `where`. numpy", "question_id": 22780}
{"snippet": "recarray.all(axis=None, out=None)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `out`. numpy", "question_id": 22781}
{"snippet": "recarray.all(axis=None, keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `keepdims`. numpy", "question_id": 22782}
{"snippet": "recarray.all(axis=None, where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `where`. numpy", "question_id": 22783}
{"snippet": "recarray.all(out=None, keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `out`, `keepdims`. numpy", "question_id": 22784}
{"snippet": "recarray.all(out=None, where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `out`, `where`. numpy", "question_id": 22785}
{"snippet": "polynomial.chebyshev.cheb2poly(c)", "intent": "Convert a Chebyshev series to a polynomial . With arguments `c`. numpy", "question_id": 22786}
{"snippet": "ma.MaskType.squeeze()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 22787}
{"snippet": "recarray.swapaxes(axis1, axis2)", "intent": "Return a view of the array with `axis1` and `axis2` interchanged . numpy", "question_id": 22788}
{"snippet": "testing.dec.setastest()", "intent": "Signals to nose that this function is or is not a test . numpy", "question_id": 22789}
{"snippet": "testing.dec.setastest(tf=True)", "intent": "Signals to nose that this function is or is not a test . With arguments `tf`. numpy", "question_id": 22790}
{"snippet": "ma.MaskType.clip()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 22791}
{"snippet": "polynomial.hermite.Hermite.identity()", "intent": "Identity function . numpy", "question_id": 22792}
{"snippet": "polynomial.hermite.Hermite.identity(domain=None)", "intent": "Identity function . With arguments `domain`. numpy", "question_id": 22793}
{"snippet": "polynomial.hermite.Hermite.identity(window=None)", "intent": "Identity function . With arguments `window`. numpy", "question_id": 22794}
{"snippet": "polynomial.hermite.Hermite.identity(domain=None, window=None)", "intent": "Identity function . With arguments `domain`, `window`. numpy", "question_id": 22795}
{"snippet": "numpy.i0(x)", "intent": "Modified Bessel function of the first kind , order 0 . With arguments `x`. numpy", "question_id": 22796}
{"snippet": "ndarray.transpose(*axes)", "intent": "Returns a view of the array with axes transposed . With arguments `*axes`. numpy", "question_id": 22797}
{"snippet": "matlib.rand(*args)", "intent": "Return a matrix of random values with given shape . With arguments `*args`. numpy", "question_id": 22798}
{"snippet": "polynomial.laguerre.lagval2d(x, y, c)", "intent": "Evaluate a 2-D Laguerre series at points ( `x` , `y` ) . In either case , either x and y or their elements must support multiplication and addition both with themselves and with the elements of `c` . numpy", "question_id": 22799}
{"snippet": "random.RandomState.noncentral_chisquare(df, nonc)", "intent": "Draw samples from a noncentral chi-square distribution . With arguments `df`, `nonc`. numpy", "question_id": 22800}
{"snippet": "random.RandomState.noncentral_chisquare(df, nonc, size=None)", "intent": "Draw samples from a noncentral chi-square distribution . With arguments `df`, `nonc`, `size`. numpy", "question_id": 22801}
{"snippet": "memmap.put(indices, values)", "intent": "Set a.flat [ n ] = `values` [ n ] for all n in `indices` . numpy", "question_id": 22802}
{"snippet": "memmap.put(indices, values, mode='raise')", "intent": "Set a.flat [ n ] = `values` [ n ] for all n in `indices` . With arguments `mode`. numpy", "question_id": 22803}
{"snippet": "char.chararray.itemsize", "intent": "Length of one array element in bytes. numpy", "question_id": 22804}
{"snippet": "numpy.shape(a)", "intent": "Return the shape of an array . With arguments `a`. numpy", "question_id": 22805}
{"snippet": "random.Generator.laplace()", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . numpy", "question_id": 22806}
{"snippet": "random.Generator.laplace(loc=0.0)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `loc`. numpy", "question_id": 22807}
{"snippet": "random.Generator.laplace(scale=1.0)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . numpy", "question_id": 22808}
{"snippet": "random.Generator.laplace(size=None)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `size`. numpy", "question_id": 22809}
{"snippet": "random.Generator.laplace(loc=0.0, scale=1.0)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `loc`. numpy", "question_id": 22810}
{"snippet": "random.Generator.laplace(loc=0.0, size=None)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `loc`, `size`. numpy", "question_id": 22811}
{"snippet": "random.Generator.laplace(scale=1.0, size=None)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `size`. numpy", "question_id": 22812}
{"snippet": "random.Generator.laplace(loc=0.0, scale=1.0, size=None)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `loc`, `size`. numpy", "question_id": 22813}
{"snippet": "ma.sum(self)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `self`. numpy", "question_id": 22814}
{"snippet": "ma.sum(self, axis=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `self`. numpy", "question_id": 22815}
{"snippet": "ma.sum(self, dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `self`, `dtype`. numpy", "question_id": 22816}
{"snippet": "ma.sum(self, out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `self`, `out`. numpy", "question_id": 22817}
{"snippet": "ma.sum(self, keepdims=<no value>)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `self`, `keepdims`. numpy", "question_id": 22818}
{"snippet": "ma.sum(self, axis=None, dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `self`, `dtype`. numpy", "question_id": 22819}
{"snippet": "ma.sum(self, axis=None, out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `self`, `out`. numpy", "question_id": 22820}
{"snippet": "ma.sum(self, axis=None, keepdims=<no value>)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `self`, `keepdims`. numpy", "question_id": 22821}
{"snippet": "ma.sum(self, dtype=None, out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `self`, `dtype`, `out`. numpy", "question_id": 22822}
{"snippet": "ma.sum(self, dtype=None, keepdims=<no value>)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `self`, `dtype`, `keepdims`. numpy", "question_id": 22823}
{"snippet": "ma.MaskType.astype()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 22824}
{"snippet": "char.chararray.partition(sep)", "intent": "Partition each element in self around `sep` . numpy", "question_id": 22825}
{"snippet": "generic.dtype", "intent": "Get array data-descriptor. numpy", "question_id": 22826}
{"snippet": "ndarray.dumps()", "intent": "Returns the pickle of the array as a string . numpy", "question_id": 22827}
{"snippet": "ndarray.__lt__(value, /)", "intent": "Return self < `value` . With arguments `/`. numpy", "question_id": 22828}
{"snippet": "numpy.broadcast_shapes(*args)", "intent": "Broadcast the input shapes into a single shape . With arguments `*args`. numpy", "question_id": 22829}
{"snippet": "random.multivariate_normal(mean, cov)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`. numpy", "question_id": 22830}
{"snippet": "random.multivariate_normal(mean, cov, size=None)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `size`. numpy", "question_id": 22831}
{"snippet": "random.multivariate_normal(mean, cov, check_valid='warn')", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `check_valid`. numpy", "question_id": 22832}
{"snippet": "random.multivariate_normal(mean, cov, tol=1e-8)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `tol`. numpy", "question_id": 22833}
{"snippet": "random.multivariate_normal(mean, cov, size=None, check_valid='warn')", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `size`, `check_valid`. numpy", "question_id": 22834}
{"snippet": "random.multivariate_normal(mean, cov, size=None, tol=1e-8)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `size`, `tol`. numpy", "question_id": 22835}
{"snippet": "random.multivariate_normal(mean, cov, check_valid='warn', tol=1e-8)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `check_valid`, `tol`. numpy", "question_id": 22836}
{"snippet": "random.multivariate_normal(mean, cov, size=None, check_valid='warn', tol=1e-8)", "intent": "Draw random samples from a multivariate normal distribution . Such a distribution is specified by its `mean` and covariance matrix . With arguments `cov`, `size`, `check_valid`, `tol`. numpy", "question_id": 22837}
{"snippet": "record.argsort()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 22838}
{"snippet": "ma.mask_rowcols(a)", "intent": "Mask rows and/or columns of `a` 2D array that contain masked values . numpy", "question_id": 22839}
{"snippet": "ma.mask_rowcols(a, axis=None)", "intent": "Mask rows and/or columns of `a` 2D array that contain masked values . The masking behavior is selected using the `axis` parameter . numpy", "question_id": 22840}
{"snippet": "numpy.mintypecode(typechars)", "intent": "Return the character for the minimum-size type to which given types can be safely cast . The returned type character must represent the smallest size dtype such that an array of the returned type can handle the data from an array of all types in `typechars` ( or if typechars is an array , then its dtype.char ) . numpy", "question_id": 22841}
{"snippet": "numpy.mintypecode(typechars, typeset='GDFgdf')", "intent": "Return the character for the minimum-size type to which given types can be safely cast . The returned type character must represent the smallest size dtype such that an array of the returned type can handle the data from an array of all types in `typechars` ( or if typechars is an array , then its dtype.char ) . With arguments `typeset`. numpy", "question_id": 22842}
{"snippet": "numpy.mintypecode(typechars, default='d')", "intent": "Return the character for the minimum-size type to which given types can be safely cast . The returned type character must represent the smallest size dtype such that an array of the returned type can handle the data from an array of all types in `typechars` ( or if typechars is an array , then its dtype.char ) . With arguments `default`. numpy", "question_id": 22843}
{"snippet": "numpy.mintypecode(typechars, typeset='GDFgdf', default='d')", "intent": "Return the character for the minimum-size type to which given types can be safely cast . The returned type character must represent the smallest size dtype such that an array of the returned type can handle the data from an array of all types in `typechars` ( or if typechars is an array , then its dtype.char ) . With arguments `typeset`, `default`. numpy", "question_id": 22844}
{"snippet": "matrix.dump(file)", "intent": "Dump a pickle of the array to the specified `file` . numpy", "question_id": 22845}
{"snippet": "numpy.poly(seq_of_zeros)", "intent": "Find the coefficients of a polynomial with the given sequence of roots . With arguments `seq_of_zeros`. numpy", "question_id": 22846}
{"snippet": "linalg.qr(a)", "intent": "Compute the qr factorization of `a` matrix . numpy", "question_id": 22847}
{"snippet": "linalg.qr(a, mode='reduced')", "intent": "Compute the qr factorization of `a` matrix . Subclasses of ndarray are preserved except for the \u2018 raw \u2019 `mode` . numpy", "question_id": 22848}
{"snippet": "memmap.all()", "intent": "Returns True if all elements evaluate to True . numpy", "question_id": 22849}
{"snippet": "memmap.all(axis=None)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`. numpy", "question_id": 22850}
{"snippet": "memmap.all(out=None)", "intent": "Returns True if all elements evaluate to True . With arguments `out`. numpy", "question_id": 22851}
{"snippet": "memmap.all(keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `keepdims`. numpy", "question_id": 22852}
{"snippet": "memmap.all(where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `where`. numpy", "question_id": 22853}
{"snippet": "memmap.all(axis=None, out=None)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `out`. numpy", "question_id": 22854}
{"snippet": "memmap.all(axis=None, keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `keepdims`. numpy", "question_id": 22855}
{"snippet": "memmap.all(axis=None, where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `where`. numpy", "question_id": 22856}
{"snippet": "memmap.all(out=None, keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `out`, `keepdims`. numpy", "question_id": 22857}
{"snippet": "memmap.all(out=None, where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `out`, `where`. numpy", "question_id": 22858}
{"snippet": "ma.MaskedArray.__pow__(other)", "intent": "Raise self to the power `other` , masking the potential NaNs/Infs numpy", "question_id": 22859}
{"snippet": "distutils.ccompiler.CCompiler_cxx_compiler(self)", "intent": "Return the C++ compiler . With arguments `self`. numpy", "question_id": 22860}
{"snippet": "recarray.flatten()", "intent": "Return a copy of the array collapsed into one dimension . numpy", "question_id": 22861}
{"snippet": "recarray.flatten(order='C')", "intent": "Return a copy of the array collapsed into one dimension . With arguments `order`. numpy", "question_id": 22862}
{"snippet": "ma.size(obj)", "intent": "Return the number of elements along a given `axis` . With arguments `obj`. numpy", "question_id": 22863}
{"snippet": "ma.size(obj, axis=None)", "intent": "Return the number of elements along a given `axis` . With arguments `obj`. numpy", "question_id": 22864}
{"snippet": "numpy.std(a)", "intent": "Compute the standard deviation along the specified `axis` . Returns the standard deviation , `a` measure of the spread of a distribution , of the array elements . numpy", "question_id": 22865}
{"snippet": "numpy.std(a, axis=None)", "intent": "Compute the standard deviation along the specified `axis` . Returns the standard deviation , `a` measure of the spread of a distribution , of the array elements . numpy", "question_id": 22866}
{"snippet": "numpy.std(a, dtype=None)", "intent": "Compute the standard deviation along the specified `axis` . Returns the standard deviation , `a` measure of the spread of a distribution , of the array elements . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue . numpy", "question_id": 22867}
{"snippet": "numpy.std(a, out=None)", "intent": "Compute the standard deviation along the specified `axis` . Returns the standard deviation , `a` measure of the spread of a distribution , of the array elements . With arguments `out`. numpy", "question_id": 22868}
{"snippet": "numpy.std(a, ddof=0)", "intent": "Compute the standard deviation along the specified `axis` . Returns the standard deviation , `a` measure of the spread of a distribution , of the array elements . If , however , `ddof` is specified , the divisor N - ddof is used instead . numpy", "question_id": 22869}
{"snippet": "numpy.std(a, keepdims=<no value>)", "intent": "Compute the standard deviation along the specified `axis` . Returns the standard deviation , `a` measure of the spread of a distribution , of the array elements . With arguments `keepdims`. numpy", "question_id": 22870}
{"snippet": "numpy.std(a, where=<no value>)", "intent": "Compute the standard deviation along the specified `axis` . Returns the standard deviation , `a` measure of the spread of a distribution , of the array elements . The standard deviation is the square root of the average of the squared deviations from the mean , i.e. , std = sqrt ( mean ( x ) ) , `where` x = abs ( a - a.mean ( ) ) * * 2 . numpy", "question_id": 22871}
{"snippet": "numpy.std(a, axis=None, dtype=None)", "intent": "Compute the standard deviation along the specified `axis` . Returns the standard deviation , `a` measure of the spread of a distribution , of the array elements . Specifying a higher-accuracy accumulator using the `dtype` keyword can alleviate this issue . numpy", "question_id": 22872}
{"snippet": "numpy.std(a, axis=None, out=None)", "intent": "Compute the standard deviation along the specified `axis` . Returns the standard deviation , `a` measure of the spread of a distribution , of the array elements . With arguments `out`. numpy", "question_id": 22873}
{"snippet": "numpy.std(a, axis=None, ddof=0)", "intent": "Compute the standard deviation along the specified `axis` . Returns the standard deviation , `a` measure of the spread of a distribution , of the array elements . If , however , `ddof` is specified , the divisor N - ddof is used instead . numpy", "question_id": 22874}
{"snippet": "ma.masked_array.dump(file)", "intent": "Dump a pickle of the array to the specified `file` . numpy", "question_id": 22875}
{"snippet": "ma.MaskedArray.harden_mask()", "intent": "Force the mask to hard . numpy", "question_id": 22876}
{"snippet": "ma.MaskType.mean()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 22877}
{"snippet": "numpy.recarray(shape)", "intent": "Construct an ndarray that allows field access using attributes . With arguments `shape`. numpy", "question_id": 22878}
{"snippet": "numpy.recarray(shape, dtype=None)", "intent": "Construct an ndarray that allows field access using attributes . With arguments `shape`, `dtype`. numpy", "question_id": 22879}
{"snippet": "numpy.recarray(shape, buf=None)", "intent": "Construct an ndarray that allows field access using attributes . With arguments `shape`, `buf`. numpy", "question_id": 22880}
{"snippet": "numpy.recarray(shape, offset=0)", "intent": "Construct an ndarray that allows field access using attributes . With arguments `shape`, `offset`. numpy", "question_id": 22881}
{"snippet": "numpy.recarray(shape, strides=None)", "intent": "Construct an ndarray that allows field access using attributes . With arguments `shape`, `strides`. numpy", "question_id": 22882}
{"snippet": "numpy.recarray(shape, formats=None)", "intent": "Construct an ndarray that allows field access using attributes . With arguments `shape`, `formats`. numpy", "question_id": 22883}
{"snippet": "numpy.recarray(shape, names=None)", "intent": "Construct an ndarray that allows field access using attributes . With arguments `shape`, `names`. numpy", "question_id": 22884}
{"snippet": "numpy.recarray(shape, titles=None)", "intent": "Construct an ndarray that allows field access using attributes . With arguments `shape`, `titles`. numpy", "question_id": 22885}
{"snippet": "numpy.recarray(shape, byteorder=None)", "intent": "Construct an ndarray that allows field access using attributes . With arguments `shape`, `byteorder`. numpy", "question_id": 22886}
{"snippet": "numpy.recarray(shape, aligned=False)", "intent": "Construct an ndarray that allows field access using attributes . With arguments `shape`, `aligned`. numpy", "question_id": 22887}
{"snippet": "record.choose()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 22888}
{"snippet": "ndarray.item(*args)", "intent": "Copy an element of an array to a standard Python scalar and return it . With arguments `*args`. numpy", "question_id": 22889}
{"snippet": "polynomial.hermite.Hermite.has_samedomain(other)", "intent": "Check if domains match . With arguments `other`. numpy", "question_id": 22890}
{"snippet": "polynomial.chebyshev.Chebyshev.copy()", "intent": "Return a copy . numpy", "question_id": 22891}
{"snippet": "matrix.put(indices, values)", "intent": "Set a.flat [ n ] = `values` [ n ] for all n in `indices` . numpy", "question_id": 22892}
{"snippet": "matrix.put(indices, values, mode='raise')", "intent": "Set a.flat [ n ] = `values` [ n ] for all n in `indices` . With arguments `mode`. numpy", "question_id": 22893}
{"snippet": "numpy.ndenumerate(arr)", "intent": "Multidimensional index iterator . With arguments `arr`. numpy", "question_id": 22894}
{"snippet": "memmap.max()", "intent": "Return the maximum along a given `axis` . numpy", "question_id": 22895}
{"snippet": "memmap.max(axis=None)", "intent": "Return the maximum along a given `axis` . numpy", "question_id": 22896}
{"snippet": "memmap.max(out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`. numpy", "question_id": 22897}
{"snippet": "memmap.max(keepdims=False)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 22898}
{"snippet": "memmap.max(initial=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `initial`. numpy", "question_id": 22899}
{"snippet": "memmap.max(where=True)", "intent": "Return the maximum along a given `axis` . With arguments `where`. numpy", "question_id": 22900}
{"snippet": "memmap.max(axis=None, out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`. numpy", "question_id": 22901}
{"snippet": "memmap.max(axis=None, keepdims=False)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 22902}
{"snippet": "memmap.max(axis=None, initial=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `initial`. numpy", "question_id": 22903}
{"snippet": "memmap.max(axis=None, where=True)", "intent": "Return the maximum along a given `axis` . With arguments `where`. numpy", "question_id": 22904}
{"snippet": "chararray.rjust(width)", "intent": "Return an array with the elements of self right-justified in a string of length `width` . numpy", "question_id": 22905}
{"snippet": "chararray.rjust(width, fillchar=' ')", "intent": "Return an array with the elements of self right-justified in a string of length `width` . With arguments `fillchar`. numpy", "question_id": 22906}
{"snippet": "linalg.tensorinv(a)", "intent": "Compute the \u2018 inverse \u2019 of an N-dimensional array . The result is an inverse for `a` relative to the tensordot operation tensordot ( a , b , `ind` ) , i. e. , up to floating-point accuracy , tensordot ( tensorinv ( a ) , a , ind ) is the \u201c identity \u201d tensor for the tensordot operation . numpy", "question_id": 22907}
{"snippet": "linalg.tensorinv(a, ind=2)", "intent": "Compute the \u2018 inverse \u2019 of an N-dimensional array . The result is an inverse for `a` relative to the tensordot operation tensordot ( a , b , `ind` ) , i. e. , up to floating-point accuracy , tensordot ( tensorinv ( a ) , a , ind ) is the \u201c identity \u201d tensor for the tensordot operation . numpy", "question_id": 22908}
{"snippet": "char.chararray.lower()", "intent": "Return an array with the elements of self converted to lowercase . numpy", "question_id": 22909}
{"snippet": "ma.MaskedArray.__deepcopy__(memo, /)", "intent": "Used if copy.deepcopy is called on an array . With arguments `memo`, `/`. numpy", "question_id": 22910}
{"snippet": "ma.masked_array.argmin()", "intent": "Return array of indices to the minimum values along the given `axis` . numpy", "question_id": 22911}
{"snippet": "ma.masked_array.argmin(axis=None)", "intent": "Return array of indices to the minimum values along the given `axis` . numpy", "question_id": 22912}
{"snippet": "ma.masked_array.argmin(fill_value=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `fill_value`. numpy", "question_id": 22913}
{"snippet": "ma.masked_array.argmin(out=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `out`. numpy", "question_id": 22914}
{"snippet": "ma.masked_array.argmin(axis=None, fill_value=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `fill_value`. numpy", "question_id": 22915}
{"snippet": "ma.masked_array.argmin(axis=None, out=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `out`. numpy", "question_id": 22916}
{"snippet": "ma.masked_array.argmin(fill_value=None, out=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `fill_value`, `out`. numpy", "question_id": 22917}
{"snippet": "ma.masked_array.argmin(axis=None, fill_value=None, out=None)", "intent": "Return array of indices to the minimum values along the given `axis` . With arguments `fill_value`, `out`. numpy", "question_id": 22918}
{"snippet": "ma.make_mask(m)", "intent": "Create a boolean mask from an array . Return `m` as a boolean mask , creating a `copy` if necessary or requested . numpy", "question_id": 22919}
{"snippet": "ma.make_mask(m, copy=False)", "intent": "Create a boolean mask from an array . Return `m` as a boolean mask , creating a `copy` if necessary or requested . numpy", "question_id": 22920}
{"snippet": "ma.make_mask(m, shrink=True)", "intent": "Create a boolean mask from an array . Return `m` as a boolean mask , creating a `copy` if necessary or requested . Effect of the `shrink` parameter . numpy", "question_id": 22921}
{"snippet": "ma.make_mask(m, dtype=<class 'numpy.bool_'>)", "intent": "Create a boolean mask from an array . Return `m` as a boolean mask , creating a `copy` if necessary or requested . Using a flexible `dtype` . numpy", "question_id": 22922}
{"snippet": "ma.make_mask(m, copy=False, shrink=True)", "intent": "Create a boolean mask from an array . Return `m` as a boolean mask , creating a `copy` if necessary or requested . Effect of the `shrink` parameter . numpy", "question_id": 22923}
{"snippet": "ma.make_mask(m, copy=False, dtype=<class 'numpy.bool_'>)", "intent": "Create a boolean mask from an array . Return `m` as a boolean mask , creating a `copy` if necessary or requested . Using a flexible `dtype` . numpy", "question_id": 22924}
{"snippet": "ma.make_mask(m, shrink=True, dtype=<class 'numpy.bool_'>)", "intent": "Create a boolean mask from an array . Return `m` as a boolean mask , creating a `copy` if necessary or requested . Effect of the `shrink` parameter . Using a flexible `dtype` . numpy", "question_id": 22925}
{"snippet": "ma.make_mask(m, copy=False, shrink=True, dtype=<class 'numpy.bool_'>)", "intent": "Create a boolean mask from an array . Return `m` as a boolean mask , creating a `copy` if necessary or requested . Effect of the `shrink` parameter . Using a flexible `dtype` . numpy", "question_id": 22926}
{"snippet": "ma.allclose(a, b)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . Return True if all elements of a and `b` are equal subject to given tolerances . numpy", "question_id": 22927}
{"snippet": "ma.allclose(a, b, masked_equal=True)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . Return True if all elements of a and `b` are equal subject to given tolerances . This function is equivalent to allclose except that masked values are treated as equal ( default ) or unequal , depending on the `masked_equal` argument . numpy", "question_id": 22928}
{"snippet": "ma.allclose(a, b, rtol=1e-05)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . Return True if all elements of a and `b` are equal subject to given tolerances . With arguments `rtol`. numpy", "question_id": 22929}
{"snippet": "ma.allclose(a, b, atol=1e-08)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . Return True if all elements of a and `b` are equal subject to given tolerances . With arguments `atol`. numpy", "question_id": 22930}
{"snippet": "ma.allclose(a, b, masked_equal=True, rtol=1e-05)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . Return True if all elements of a and `b` are equal subject to given tolerances . This function is equivalent to allclose except that masked values are treated as equal ( default ) or unequal , depending on the `masked_equal` argument . With arguments `rtol`. numpy", "question_id": 22931}
{"snippet": "ma.allclose(a, b, masked_equal=True, atol=1e-08)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . Return True if all elements of a and `b` are equal subject to given tolerances . This function is equivalent to allclose except that masked values are treated as equal ( default ) or unequal , depending on the `masked_equal` argument . With arguments `atol`. numpy", "question_id": 22932}
{"snippet": "ma.allclose(a, b, rtol=1e-05, atol=1e-08)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . Return True if all elements of a and `b` are equal subject to given tolerances . With arguments `rtol`, `atol`. numpy", "question_id": 22933}
{"snippet": "ma.allclose(a, b, masked_equal=True, rtol=1e-05, atol=1e-08)", "intent": "Returns True if two arrays are element-wise equal within `a` tolerance . Return True if all elements of a and `b` are equal subject to given tolerances . This function is equivalent to allclose except that masked values are treated as equal ( default ) or unequal , depending on the `masked_equal` argument . With arguments `rtol`, `atol`. numpy", "question_id": 22934}
{"snippet": "numpy.array(object)", "intent": "Create an array . When `order` is \u2018 A \u2019 and `object` is an array in neither \u2018 C \u2019 nor \u2018 F \u2019 order , and a `copy` is forced by a change in `dtype` , then the order of the result is not necessarily \u2018 C \u2019 as expected . numpy", "question_id": 22935}
{"snippet": "numpy.array(object, dtype=None)", "intent": "Create an array . When `order` is \u2018 A \u2019 and `object` is an array in neither \u2018 C \u2019 nor \u2018 F \u2019 order , and a `copy` is forced by a change in `dtype` , then the order of the result is not necessarily \u2018 C \u2019 as expected . numpy", "question_id": 22936}
{"snippet": "numpy.array(object, copy=True)", "intent": "Create an array . When `order` is \u2018 A \u2019 and `object` is an array in neither \u2018 C \u2019 nor \u2018 F \u2019 order , and a `copy` is forced by a change in `dtype` , then the order of the result is not necessarily \u2018 C \u2019 as expected . numpy", "question_id": 22937}
{"snippet": "numpy.array(object, order='K')", "intent": "Create an array . When `order` is \u2018 A \u2019 and `object` is an array in neither \u2018 C \u2019 nor \u2018 F \u2019 order , and a `copy` is forced by a change in `dtype` , then the order of the result is not necessarily \u2018 C \u2019 as expected . numpy", "question_id": 22938}
{"snippet": "numpy.array(object, subok=False)", "intent": "Create an array . When `order` is \u2018 A \u2019 and `object` is an array in neither \u2018 C \u2019 nor \u2018 F \u2019 order , and a `copy` is forced by a change in `dtype` , then the order of the result is not necessarily \u2018 C \u2019 as expected . With arguments `subok`. numpy", "question_id": 22939}
{"snippet": "numpy.array(object, ndmin=0)", "intent": "Create an array . When `order` is \u2018 A \u2019 and `object` is an array in neither \u2018 C \u2019 nor \u2018 F \u2019 order , and a `copy` is forced by a change in `dtype` , then the order of the result is not necessarily \u2018 C \u2019 as expected . With arguments `ndmin`. numpy", "question_id": 22940}
{"snippet": "numpy.array(object, like=None)", "intent": "Create an array . When `order` is \u2018 A \u2019 and `object` is an array in neither \u2018 C \u2019 nor \u2018 F \u2019 order , and a `copy` is forced by a change in `dtype` , then the order of the result is not necessarily \u2018 C \u2019 as expected . With arguments `like`. numpy", "question_id": 22941}
{"snippet": "numpy.array(object, dtype=None, copy=True)", "intent": "Create an array . When `order` is \u2018 A \u2019 and `object` is an array in neither \u2018 C \u2019 nor \u2018 F \u2019 order , and a `copy` is forced by a change in `dtype` , then the order of the result is not necessarily \u2018 C \u2019 as expected . numpy", "question_id": 22942}
{"snippet": "numpy.array(object, dtype=None, order='K')", "intent": "Create an array . When `order` is \u2018 A \u2019 and `object` is an array in neither \u2018 C \u2019 nor \u2018 F \u2019 order , and a `copy` is forced by a change in `dtype` , then the order of the result is not necessarily \u2018 C \u2019 as expected . numpy", "question_id": 22943}
{"snippet": "numpy.array(object, dtype=None, subok=False)", "intent": "Create an array . When `order` is \u2018 A \u2019 and `object` is an array in neither \u2018 C \u2019 nor \u2018 F \u2019 order , and a `copy` is forced by a change in `dtype` , then the order of the result is not necessarily \u2018 C \u2019 as expected . With arguments `subok`. numpy", "question_id": 22944}
{"snippet": "fft.ihfft(a)", "intent": "Compute the inverse FFT of `a` signal that has Hermitian symmetry . numpy", "question_id": 22945}
{"snippet": "fft.ihfft(a, n=None)", "intent": "Compute the inverse FFT of `a` signal that has Hermitian symmetry . With arguments `n`. numpy", "question_id": 22946}
{"snippet": "fft.ihfft(a, axis=- 1)", "intent": "Compute the inverse FFT of `a` signal that has Hermitian symmetry . With arguments `axis`. numpy", "question_id": 22947}
{"snippet": "fft.ihfft(a, norm=None)", "intent": "Compute the inverse FFT of `a` signal that has Hermitian symmetry . With arguments `norm`. numpy", "question_id": 22948}
{"snippet": "fft.ihfft(a, n=None, axis=- 1)", "intent": "Compute the inverse FFT of `a` signal that has Hermitian symmetry . With arguments `n`, `axis`. numpy", "question_id": 22949}
{"snippet": "fft.ihfft(a, n=None, norm=None)", "intent": "Compute the inverse FFT of `a` signal that has Hermitian symmetry . With arguments `n`, `norm`. numpy", "question_id": 22950}
{"snippet": "fft.ihfft(a, axis=- 1, norm=None)", "intent": "Compute the inverse FFT of `a` signal that has Hermitian symmetry . With arguments `axis`, `norm`. numpy", "question_id": 22951}
{"snippet": "fft.ihfft(a, n=None, axis=- 1, norm=None)", "intent": "Compute the inverse FFT of `a` signal that has Hermitian symmetry . With arguments `n`, `axis`, `norm`. numpy", "question_id": 22952}
{"snippet": "numpy.set_printoptions()", "intent": "Set printing options . numpy", "question_id": 22953}
{"snippet": "numpy.set_printoptions(precision=None)", "intent": "Set printing options . Floating point `precision` can be set : numpy", "question_id": 22954}
{"snippet": "numpy.set_printoptions(threshold=None)", "intent": "Set printing options . With arguments `threshold`. numpy", "question_id": 22955}
{"snippet": "numpy.set_printoptions(edgeitems=None)", "intent": "Set printing options . With arguments `edgeitems`. numpy", "question_id": 22956}
{"snippet": "numpy.set_printoptions(linewidth=None)", "intent": "Set printing options . With arguments `linewidth`. numpy", "question_id": 22957}
{"snippet": "numpy.set_printoptions(suppress=None)", "intent": "Set printing options . With arguments `suppress`. numpy", "question_id": 22958}
{"snippet": "numpy.set_printoptions(nanstr=None)", "intent": "Set printing options . With arguments `nanstr`. numpy", "question_id": 22959}
{"snippet": "numpy.set_printoptions(infstr=None)", "intent": "Set printing options . With arguments `infstr`. numpy", "question_id": 22960}
{"snippet": "numpy.set_printoptions(formatter=None)", "intent": "Set printing options . `formatter` is always reset with a call to set_printoptions . numpy", "question_id": 22961}
{"snippet": "numpy.set_printoptions(sign=None)", "intent": "Set printing options . With arguments `sign`. numpy", "question_id": 22962}
{"snippet": "polynomial.hermite_e.poly2herme(pol)", "intent": "Convert a polynomial to a Hermite series . With arguments `pol`. numpy", "question_id": 22963}
{"snippet": "polynomial.hermite.hermtrim(c)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . With arguments `c`. numpy", "question_id": 22964}
{"snippet": "polynomial.hermite.hermtrim(c, tol=0)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . \u201c Small \u201d means \u201c small in absolute value \u201d and is controlled by the parameter `tol` ; \u201c trailing \u201d means highest order coefficient ( s ) , e.g. , in [ 0 , 1 , 1 , 0 , 0 ] ( which represents 0 + x + x * * 2 + 0 * x * * 3 + 0 * x * * 4 ) both the 3-rd and 4-th order coefficients would be \u201c trimmed . \u201d With arguments `c`. numpy", "question_id": 22965}
{"snippet": "record.dump()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 22966}
{"snippet": "ma.MaskType.resize()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 22967}
{"snippet": "polynomial.chebyshev.chebcompanion(c)", "intent": "Return the scaled companion matrix of `c` . numpy", "question_id": 22968}
{"snippet": "polynomial.polyutils.mapdomain(x, old, new)", "intent": "Apply linear map to input points . The linear map offset + scale * `x` that maps the domain `old` to the domain `new` is applied to the points x . numpy", "question_id": 22969}
{"snippet": "char.isspace(a)", "intent": "Returns true for each element if there are only whitespace characters in the string and there is at least one character , false otherwise . With arguments `a`. numpy", "question_id": 22970}
{"snippet": "ma.MaskedArray.__len__(/)", "intent": "Return len ( self ) . With arguments `/`. numpy", "question_id": 22971}
{"snippet": "numpy.multiply(x1, x2, /, signature, extobj)", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 22972}
{"snippet": "numpy.multiply(x1, x2, /, signature, extobj, out=None)", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 22973}
{"snippet": "numpy.multiply(x1, x2, /, signature, extobj, where=True)", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 22974}
{"snippet": "numpy.multiply(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 22975}
{"snippet": "numpy.multiply(x1, x2, /, signature, extobj, order='K')", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 22976}
{"snippet": "numpy.multiply(x1, x2, /, signature, extobj, dtype=None)", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 22977}
{"snippet": "numpy.multiply(x1, x2, /, signature, extobj, subok=True)", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 22978}
{"snippet": "numpy.multiply(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 22979}
{"snippet": "numpy.multiply(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 22980}
{"snippet": "numpy.multiply(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 22981}
{"snippet": "numpy.multiply(x1, x2, /, signature)", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`. numpy", "question_id": 22982}
{"snippet": "numpy.multiply(x1, x2, /, signature, out=None)", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `out`. numpy", "question_id": 22983}
{"snippet": "numpy.multiply(x1, x2, /, signature, where=True)", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `where`. numpy", "question_id": 22984}
{"snippet": "numpy.multiply(x1, x2, /, signature, casting='same_kind')", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `casting`. numpy", "question_id": 22985}
{"snippet": "numpy.multiply(x1, x2, /, signature, order='K')", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `order`. numpy", "question_id": 22986}
{"snippet": "numpy.multiply(x1, x2, /, signature, dtype=None)", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 22987}
{"snippet": "numpy.multiply(x1, x2, /, signature, subok=True)", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `subok`. numpy", "question_id": 22988}
{"snippet": "numpy.multiply(x1, x2, /, signature, out=None, where=True)", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 22989}
{"snippet": "numpy.multiply(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 22990}
{"snippet": "numpy.multiply(x1, x2, /, signature, out=None, order='K')", "intent": "Multiply arguments element-wise . Equivalent to `x1` * `x2` in terms of array broadcasting . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 22991}
{"snippet": "ma.MaskedArray.tostring()", "intent": "A compatibility alias for tobytes , with exactly the same behavior . numpy", "question_id": 22992}
{"snippet": "ma.MaskedArray.tostring(fill_value=None)", "intent": "A compatibility alias for tobytes , with exactly the same behavior . With arguments `fill_value`. numpy", "question_id": 22993}
{"snippet": "ma.MaskedArray.tostring(order='C')", "intent": "A compatibility alias for tobytes , with exactly the same behavior . With arguments `order`. numpy", "question_id": 22994}
{"snippet": "ma.MaskedArray.tostring(fill_value=None, order='C')", "intent": "A compatibility alias for tobytes , with exactly the same behavior . With arguments `fill_value`, `order`. numpy", "question_id": 22995}
{"snippet": "record.tolist()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 22996}
{"snippet": "chararray.title()", "intent": "For each element in self , return a titlecased version of the string : words start with uppercase characters , all remaining cased characters are lowercase . numpy", "question_id": 22997}
{"snippet": "ma.MaskedArray.__rmod__(value, /)", "intent": "Return `value` % self . With arguments `/`. numpy", "question_id": 22998}
{"snippet": "ma.masked_greater_equal(x, value)", "intent": "Mask an array where greater than or equal to a given `value` . This function is a shortcut to masked_where , with condition = ( `x` > = value ) . numpy", "question_id": 22999}
{"snippet": "ma.masked_greater_equal(x, value, copy=True)", "intent": "Mask an array where greater than or equal to a given `value` . This function is a shortcut to masked_where , with condition = ( `x` > = value ) . With arguments `copy`. numpy", "question_id": 23000}
{"snippet": "record.T", "intent": "Scalar attribute identical to the corresponding array attribute. numpy", "question_id": 23001}
{"snippet": "ma.MaskedArray.__rxor__(value, /)", "intent": "Return value^self . With arguments `value`, `/`. numpy", "question_id": 23002}
{"snippet": "polynomial.hermite.hermcompanion(c)", "intent": "Return the scaled companion matrix of `c` . numpy", "question_id": 23003}
{"snippet": "polynomial.hermite.Hermite.linspace()", "intent": "Return x , y values at equally spaced points in `domain` . numpy", "question_id": 23004}
{"snippet": "polynomial.hermite.Hermite.linspace(n=100)", "intent": "Return x , y values at equally spaced points in `domain` . Returns the x , y values at `n` linearly spaced points across the domain . numpy", "question_id": 23005}
{"snippet": "polynomial.hermite.Hermite.linspace(domain=None)", "intent": "Return x , y values at equally spaced points in `domain` . numpy", "question_id": 23006}
{"snippet": "polynomial.hermite.Hermite.linspace(n=100, domain=None)", "intent": "Return x , y values at equally spaced points in `domain` . Returns the x , y values at `n` linearly spaced points across the domain . numpy", "question_id": 23007}
{"snippet": "fft.hfft(a)", "intent": "Compute the FFT of `a` signal that has Hermitian symmetry , i.e. , a real spectrum . numpy", "question_id": 23008}
{"snippet": "fft.hfft(a, n=None)", "intent": "Compute the FFT of `a` signal that has Hermitian symmetry , i.e. , a real spectrum . With arguments `n`. numpy", "question_id": 23009}
{"snippet": "fft.hfft(a, axis=- 1)", "intent": "Compute the FFT of `a` signal that has Hermitian symmetry , i.e. , a real spectrum . With arguments `axis`. numpy", "question_id": 23010}
{"snippet": "fft.hfft(a, norm=None)", "intent": "Compute the FFT of `a` signal that has Hermitian symmetry , i.e. , a real spectrum . With arguments `norm`. numpy", "question_id": 23011}
{"snippet": "fft.hfft(a, n=None, axis=- 1)", "intent": "Compute the FFT of `a` signal that has Hermitian symmetry , i.e. , a real spectrum . With arguments `n`, `axis`. numpy", "question_id": 23012}
{"snippet": "fft.hfft(a, n=None, norm=None)", "intent": "Compute the FFT of `a` signal that has Hermitian symmetry , i.e. , a real spectrum . With arguments `n`, `norm`. numpy", "question_id": 23013}
{"snippet": "fft.hfft(a, axis=- 1, norm=None)", "intent": "Compute the FFT of `a` signal that has Hermitian symmetry , i.e. , a real spectrum . With arguments `axis`, `norm`. numpy", "question_id": 23014}
{"snippet": "fft.hfft(a, n=None, axis=- 1, norm=None)", "intent": "Compute the FFT of `a` signal that has Hermitian symmetry , i.e. , a real spectrum . With arguments `n`, `axis`, `norm`. numpy", "question_id": 23015}
{"snippet": "ma.masked_array.strides", "intent": "Tuple of bytes to step in each dimension when traversing an array. numpy", "question_id": 23016}
{"snippet": "memmap.byteswap()", "intent": "Swap the bytes of the array elements numpy", "question_id": 23017}
{"snippet": "memmap.byteswap(inplace=False)", "intent": "Swap the bytes of the array elements With arguments `inplace`. numpy", "question_id": 23018}
{"snippet": "ma.MaskType.min()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 23019}
{"snippet": "char.less(x1, x2)", "intent": "Return ( `x1` < `x2` ) element-wise . numpy", "question_id": 23020}
{"snippet": "numpy.errstate(**kwargs)", "intent": "Context manager for floating-point error handling . With arguments `**kwargs`. numpy", "question_id": 23021}
{"snippet": "record.dumps()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 23022}
{"snippet": "matrix.transpose(*axes)", "intent": "Returns a view of the array with axes transposed . With arguments `*axes`. numpy", "question_id": 23023}
{"snippet": "record.real", "intent": "The real part of the scalar. numpy", "question_id": 23024}
{"snippet": "lib.format.write_array_header_1_0(fp, d)", "intent": "Write the header for an array using the 1.0 format . With arguments `fp`, `d`. numpy", "question_id": 23025}
{"snippet": "char.chararray.rpartition(sep)", "intent": "Partition each element in self around `sep` . numpy", "question_id": 23026}
{"snippet": "char.lstrip(a)", "intent": "For each element in `a` , return a copy with the leading characters removed . numpy", "question_id": 23027}
{"snippet": "char.lstrip(a, chars=None)", "intent": "For each element in `a` , return a copy with the leading characters removed . With arguments `chars`. numpy", "question_id": 23028}
{"snippet": "polynomial.polynomial.polyint(c)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 23029}
{"snippet": "polynomial.polynomial.polyint(c, m=1)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 23030}
{"snippet": "polynomial.polynomial.polyint(c, k=)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 23031}
{"snippet": "polynomial.polynomial.polyint(c, lbnd=0)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 23032}
{"snippet": "polynomial.polynomial.polyint(c, scl=1)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 23033}
{"snippet": "polynomial.polynomial.polyint(c, axis=0)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 23034}
{"snippet": "polynomial.polynomial.polyint(c, m=1, k=)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 23035}
{"snippet": "polynomial.polynomial.polyint(c, m=1, lbnd=0)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 23036}
{"snippet": "polynomial.polynomial.polyint(c, m=1, scl=1)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 23037}
{"snippet": "polynomial.polynomial.polyint(c, m=1, axis=0)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 23038}
{"snippet": "polynomial.polynomial.polyint()", "intent": "Integrate a polynomial . numpy", "question_id": 23039}
{"snippet": "polynomial.polynomial.polyint(m=1)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 23040}
{"snippet": "polynomial.polynomial.polyint(k=)", "intent": "Integrate a polynomial . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 23041}
{"snippet": "polynomial.polynomial.polyint(lbnd=0)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 23042}
{"snippet": "polynomial.polynomial.polyint(scl=1)", "intent": "Integrate a polynomial . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 23043}
{"snippet": "polynomial.polynomial.polyint(axis=0)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 23044}
{"snippet": "polynomial.polynomial.polyint(m=1, k=)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 23045}
{"snippet": "polynomial.polynomial.polyint(m=1, lbnd=0)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 23046}
{"snippet": "polynomial.polynomial.polyint(m=1, scl=1)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` . At each iteration the resulting series is multiplied by `scl` and an integration constant , `k` , is added . numpy", "question_id": 23047}
{"snippet": "polynomial.polynomial.polyint(m=1, axis=0)", "intent": "Integrate a polynomial . Returns the polynomial coefficients `c` integrated `m` times from `lbnd` along `axis` . numpy", "question_id": 23048}
{"snippet": "matrix.argsort()", "intent": "Returns the indices that would sort this array . numpy", "question_id": 23049}
{"snippet": "matrix.argsort(axis=- 1)", "intent": "Returns the indices that would sort this array . With arguments `axis`. numpy", "question_id": 23050}
{"snippet": "matrix.argsort(kind=None)", "intent": "Returns the indices that would sort this array . With arguments `kind`. numpy", "question_id": 23051}
{"snippet": "matrix.argsort(order=None)", "intent": "Returns the indices that would sort this array . With arguments `order`. numpy", "question_id": 23052}
{"snippet": "matrix.argsort(axis=- 1, kind=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `kind`. numpy", "question_id": 23053}
{"snippet": "matrix.argsort(axis=- 1, order=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `order`. numpy", "question_id": 23054}
{"snippet": "matrix.argsort(kind=None, order=None)", "intent": "Returns the indices that would sort this array . With arguments `kind`, `order`. numpy", "question_id": 23055}
{"snippet": "matrix.argsort(axis=- 1, kind=None, order=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `kind`, `order`. numpy", "question_id": 23056}
{"snippet": "numpy.arctan(x, /, signature, extobj)", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 23057}
{"snippet": "numpy.arctan(x, /, signature, extobj, out=None)", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 23058}
{"snippet": "numpy.arctan(x, /, signature, extobj, where=True)", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 23059}
{"snippet": "numpy.arctan(x, /, signature, extobj, casting='same_kind')", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 23060}
{"snippet": "numpy.arctan(x, /, signature, extobj, order='K')", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 23061}
{"snippet": "numpy.arctan(x, /, signature, extobj, dtype=None)", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 23062}
{"snippet": "numpy.arctan(x, /, signature, extobj, subok=True)", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 23063}
{"snippet": "numpy.arctan(x, /, signature, extobj, out=None, where=True)", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 23064}
{"snippet": "numpy.arctan(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 23065}
{"snippet": "numpy.arctan(x, /, signature, extobj, out=None, order='K')", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 23066}
{"snippet": "numpy.arctan(x, /, signature)", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`. numpy", "question_id": 23067}
{"snippet": "numpy.arctan(x, /, signature, out=None)", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `out`. numpy", "question_id": 23068}
{"snippet": "numpy.arctan(x, /, signature, where=True)", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `where`. numpy", "question_id": 23069}
{"snippet": "numpy.arctan(x, /, signature, casting='same_kind')", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `casting`. numpy", "question_id": 23070}
{"snippet": "numpy.arctan(x, /, signature, order='K')", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `order`. numpy", "question_id": 23071}
{"snippet": "numpy.arctan(x, /, signature, dtype=None)", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 23072}
{"snippet": "numpy.arctan(x, /, signature, subok=True)", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `subok`. numpy", "question_id": 23073}
{"snippet": "numpy.arctan(x, /, signature, out=None, where=True)", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 23074}
{"snippet": "numpy.arctan(x, /, signature, out=None, casting='same_kind')", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 23075}
{"snippet": "numpy.arctan(x, /, signature, out=None, order='K')", "intent": "Trigonometric inverse tangent , element-wise . The inverse of tan , so that if y = tan ( `x` ) then x = arctan ( y ) . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 23076}
{"snippet": "matrix.tofile(fid)", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . numpy", "question_id": 23077}
{"snippet": "matrix.tofile(fid, sep='')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `sep`. numpy", "question_id": 23078}
{"snippet": "matrix.tofile(fid, format='%s')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `format`. numpy", "question_id": 23079}
{"snippet": "matrix.tofile(fid, sep='', format='%s')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `sep`, `format`. numpy", "question_id": 23080}
{"snippet": "random.RandomState.logistic()", "intent": "Draw samples from a logistic distribution . numpy", "question_id": 23081}
{"snippet": "random.RandomState.logistic(loc=0.0)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . numpy", "question_id": 23082}
{"snippet": "random.RandomState.logistic(scale=1.0)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . numpy", "question_id": 23083}
{"snippet": "random.RandomState.logistic(size=None)", "intent": "Draw samples from a logistic distribution . With arguments `size`. numpy", "question_id": 23084}
{"snippet": "random.RandomState.logistic(loc=0.0, scale=1.0)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . numpy", "question_id": 23085}
{"snippet": "random.RandomState.logistic(loc=0.0, size=None)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . With arguments `size`. numpy", "question_id": 23086}
{"snippet": "random.RandomState.logistic(scale=1.0, size=None)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . With arguments `size`. numpy", "question_id": 23087}
{"snippet": "random.RandomState.logistic(loc=0.0, scale=1.0, size=None)", "intent": "Draw samples from a logistic distribution . Samples are drawn from a logistic distribution with specified parameters , `loc` ( location or mean , also median ) , and `scale` ( > 0 ) . With arguments `size`. numpy", "question_id": 23088}
{"snippet": "ma.masked_array.conj()", "intent": "Complex-conjugate all elements . numpy", "question_id": 23089}
{"snippet": "random.rand(d0, d1, dn)", "intent": "Random values in a given shape . With arguments `d0`, `d1`, `dn`. numpy", "question_id": 23090}
{"snippet": "ma.masked_array.all()", "intent": "Returns True if all elements evaluate to True . numpy", "question_id": 23091}
{"snippet": "ma.masked_array.all(axis=None)", "intent": "Returns True if all elements evaluate to True . The output array is masked where all the values along the given `axis` are masked : if the output would have been a scalar and that all the values are masked , then the output is masked . numpy", "question_id": 23092}
{"snippet": "ma.masked_array.all(out=None)", "intent": "Returns True if all elements evaluate to True . With arguments `out`. numpy", "question_id": 23093}
{"snippet": "ma.masked_array.all(keepdims=<no value>)", "intent": "Returns True if all elements evaluate to True . With arguments `keepdims`. numpy", "question_id": 23094}
{"snippet": "ma.masked_array.all(axis=None, out=None)", "intent": "Returns True if all elements evaluate to True . The output array is masked where all the values along the given `axis` are masked : if the output would have been a scalar and that all the values are masked , then the output is masked . With arguments `out`. numpy", "question_id": 23095}
{"snippet": "ma.masked_array.all(axis=None, keepdims=<no value>)", "intent": "Returns True if all elements evaluate to True . The output array is masked where all the values along the given `axis` are masked : if the output would have been a scalar and that all the values are masked , then the output is masked . With arguments `keepdims`. numpy", "question_id": 23096}
{"snippet": "ma.masked_array.all(out=None, keepdims=<no value>)", "intent": "Returns True if all elements evaluate to True . With arguments `out`, `keepdims`. numpy", "question_id": 23097}
{"snippet": "ma.masked_array.all(axis=None, out=None, keepdims=<no value>)", "intent": "Returns True if all elements evaluate to True . The output array is masked where all the values along the given `axis` are masked : if the output would have been a scalar and that all the values are masked , then the output is masked . With arguments `out`, `keepdims`. numpy", "question_id": 23098}
{"snippet": "chararray.rpartition(sep)", "intent": "Partition each element in self around `sep` . numpy", "question_id": 23099}
{"snippet": "ndarray.put(indices, values)", "intent": "Set a.flat [ n ] = `values` [ n ] for all n in `indices` . numpy", "question_id": 23100}
{"snippet": "ndarray.put(indices, values, mode='raise')", "intent": "Set a.flat [ n ] = `values` [ n ] for all n in `indices` . With arguments `mode`. numpy", "question_id": 23101}
{"snippet": "numpy.binary_repr(num)", "intent": "Return the binary representation of the input number as a string . With arguments `num`. numpy", "question_id": 23102}
{"snippet": "numpy.binary_repr(num, width=None)", "intent": "Return the binary representation of the input number as a string . For negative numbers , if `width` is not given , a minus sign is added to the front . With arguments `num`. numpy", "question_id": 23103}
{"snippet": "matrix.tobytes()", "intent": "Construct Python bytes containing the raw data bytes in the array . numpy", "question_id": 23104}
{"snippet": "matrix.tobytes(order='C')", "intent": "Construct Python bytes containing the raw data bytes in the array . This behavior is controlled by the `order` parameter . numpy", "question_id": 23105}
{"snippet": "char.rstrip(a)", "intent": "For each element in `a` , return a copy with the trailing characters removed . numpy", "question_id": 23106}
{"snippet": "char.rstrip(a, chars=None)", "intent": "For each element in `a` , return a copy with the trailing characters removed . With arguments `chars`. numpy", "question_id": 23107}
{"snippet": "generic.squeeze()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 23108}
{"snippet": "numpy.geterrcall()", "intent": "Return the current callback function used on floating-point errors . numpy", "question_id": 23109}
{"snippet": "dtype.hasobject", "intent": "Boolean indicating whether this dtype contains any reference-counted objects in any fields or sub-dtypes. numpy", "question_id": 23110}
{"snippet": "polynomial.legendre.Legendre.trim()", "intent": "Remove trailing coefficients numpy", "question_id": 23111}
{"snippet": "polynomial.legendre.Legendre.trim(tol=0)", "intent": "Remove trailing coefficients Remove trailing coefficients until a coefficient is reached whose absolute value greater than `tol` or the beginning of the series is reached . numpy", "question_id": 23112}
{"snippet": "numpy.asfarray(a)", "intent": "Return an array converted to `a` float type . numpy", "question_id": 23113}
{"snippet": "numpy.asfarray(a, dtype=<class 'numpy.double'>)", "intent": "Return an array converted to `a` float type . With arguments `dtype`. numpy", "question_id": 23114}
{"snippet": "chararray.std()", "intent": "Returns the standard deviation of the array elements along given `axis` . numpy", "question_id": 23115}
{"snippet": "chararray.std(axis=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . numpy", "question_id": 23116}
{"snippet": "chararray.std(dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 23117}
{"snippet": "chararray.std(out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 23118}
{"snippet": "chararray.std(ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`. numpy", "question_id": 23119}
{"snippet": "chararray.std(keepdims=False)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `keepdims`. numpy", "question_id": 23120}
{"snippet": "chararray.std(where=True)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `where`. numpy", "question_id": 23121}
{"snippet": "chararray.std(axis=None, dtype=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `dtype`. numpy", "question_id": 23122}
{"snippet": "chararray.std(axis=None, out=None)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `out`. numpy", "question_id": 23123}
{"snippet": "chararray.std(axis=None, ddof=0)", "intent": "Returns the standard deviation of the array elements along given `axis` . With arguments `ddof`. numpy", "question_id": 23124}
{"snippet": "generic.base", "intent": "Scalar attribute identical to the corresponding array attribute. numpy", "question_id": 23125}
{"snippet": "polynomial.legendre.legder(c)", "intent": "Differentiate a Legendre series . Returns the Legendre series coefficients `c` differentiated `m` times along `axis` . numpy", "question_id": 23126}
{"snippet": "polynomial.legendre.legder(c, m=1)", "intent": "Differentiate a Legendre series . Returns the Legendre series coefficients `c` differentiated `m` times along `axis` . numpy", "question_id": 23127}
{"snippet": "polynomial.legendre.legder(c, scl=1)", "intent": "Differentiate a Legendre series . Returns the Legendre series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) . numpy", "question_id": 23128}
{"snippet": "polynomial.legendre.legder(c, axis=0)", "intent": "Differentiate a Legendre series . Returns the Legendre series coefficients `c` differentiated `m` times along `axis` . numpy", "question_id": 23129}
{"snippet": "polynomial.legendre.legder(c, m=1, scl=1)", "intent": "Differentiate a Legendre series . Returns the Legendre series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) . numpy", "question_id": 23130}
{"snippet": "polynomial.legendre.legder(c, m=1, axis=0)", "intent": "Differentiate a Legendre series . Returns the Legendre series coefficients `c` differentiated `m` times along `axis` . numpy", "question_id": 23131}
{"snippet": "polynomial.legendre.legder(c, scl=1, axis=0)", "intent": "Differentiate a Legendre series . Returns the Legendre series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) . numpy", "question_id": 23132}
{"snippet": "polynomial.legendre.legder(c, m=1, scl=1, axis=0)", "intent": "Differentiate a Legendre series . Returns the Legendre series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) . numpy", "question_id": 23133}
{"snippet": "fft.fft2(a, - 1))", "intent": "Compute the 2-dimensional discrete Fourier Transform . By default , the transform is computed over the last two axes of the input array , i.e. , `a` 2-dimensional FFT . With arguments `- 1)`. numpy", "question_id": 23134}
{"snippet": "fft.fft2(a, - 1), s=None)", "intent": "Compute the 2-dimensional discrete Fourier Transform . By default , the transform is computed over the last two axes of the input array , i.e. , `a` 2-dimensional FFT . With arguments `- 1)`, `s`. numpy", "question_id": 23135}
{"snippet": "fft.fft2(a, - 1), axes=(- 2)", "intent": "Compute the 2-dimensional discrete Fourier Transform . By default , the transform is computed over the last two axes of the input array , i.e. , `a` 2-dimensional FFT . This function computes the n-dimensional discrete Fourier Transform over any `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `- 1)`. numpy", "question_id": 23136}
{"snippet": "fft.fft2(a, - 1), norm=None)", "intent": "Compute the 2-dimensional discrete Fourier Transform . By default , the transform is computed over the last two axes of the input array , i.e. , `a` 2-dimensional FFT . With arguments `- 1)`, `norm`. numpy", "question_id": 23137}
{"snippet": "fft.fft2(a, - 1), s=None, axes=(- 2)", "intent": "Compute the 2-dimensional discrete Fourier Transform . By default , the transform is computed over the last two axes of the input array , i.e. , `a` 2-dimensional FFT . This function computes the n-dimensional discrete Fourier Transform over any `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `- 1)`, `s`. numpy", "question_id": 23138}
{"snippet": "fft.fft2(a, - 1), s=None, norm=None)", "intent": "Compute the 2-dimensional discrete Fourier Transform . By default , the transform is computed over the last two axes of the input array , i.e. , `a` 2-dimensional FFT . With arguments `- 1)`, `s`, `norm`. numpy", "question_id": 23139}
{"snippet": "fft.fft2(a, - 1), axes=(- 2, norm=None)", "intent": "Compute the 2-dimensional discrete Fourier Transform . By default , the transform is computed over the last two axes of the input array , i.e. , `a` 2-dimensional FFT . This function computes the n-dimensional discrete Fourier Transform over any `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `- 1)`, `norm`. numpy", "question_id": 23140}
{"snippet": "fft.fft2(a, - 1), s=None, axes=(- 2, norm=None)", "intent": "Compute the 2-dimensional discrete Fourier Transform . By default , the transform is computed over the last two axes of the input array , i.e. , `a` 2-dimensional FFT . This function computes the n-dimensional discrete Fourier Transform over any `axes` in an M-dimensional array by means of the Fast Fourier Transform ( FFT ) . With arguments `- 1)`, `s`, `norm`. numpy", "question_id": 23141}
{"snippet": "polynomial.laguerre.lagval(x, c)", "intent": "Evaluate a Laguerre series at points `x` . If `c` is of length n + 1 , this function returns the value : numpy", "question_id": 23142}
{"snippet": "polynomial.laguerre.lagval(x, c, tensor=True)", "intent": "Evaluate a Laguerre series at points `x` . If `c` is of length n + 1 , this function returns the value : If c is multidimensional , then the shape of the result depends on the value of `tensor` . numpy", "question_id": 23143}
{"snippet": "ma.any(self)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `self`. numpy", "question_id": 23144}
{"snippet": "ma.any(self, axis=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `self`, `axis`. numpy", "question_id": 23145}
{"snippet": "ma.any(self, out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `self`, `out`. numpy", "question_id": 23146}
{"snippet": "ma.any(self, keepdims=<no value>)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `self`, `keepdims`. numpy", "question_id": 23147}
{"snippet": "ma.any(self, axis=None, out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `self`, `axis`, `out`. numpy", "question_id": 23148}
{"snippet": "ma.any(self, axis=None, keepdims=<no value>)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `self`, `axis`, `keepdims`. numpy", "question_id": 23149}
{"snippet": "ma.any(self, out=None, keepdims=<no value>)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `self`, `out`, `keepdims`. numpy", "question_id": 23150}
{"snippet": "ma.any(self, axis=None, out=None, keepdims=<no value>)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `self`, `axis`, `out`, `keepdims`. numpy", "question_id": 23151}
{"snippet": "numpy.can_cast(from_, to)", "intent": "Returns True if cast between data types can occur according `to` the `casting` rule . With arguments `from_`. numpy", "question_id": 23152}
{"snippet": "numpy.can_cast(from_, to, casting='safe')", "intent": "Returns True if cast between data types can occur according `to` the `casting` rule . With arguments `from_`. numpy", "question_id": 23153}
{"snippet": "char.greater(x1, x2)", "intent": "Return ( `x1` > `x2` ) element-wise . numpy", "question_id": 23154}
{"snippet": "ma.MaskType.itemset()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 23155}
{"snippet": "lib.format.read_array_header_1_0(fp)", "intent": "Read an array header from a filelike object using the 1.0 file format version . With arguments `fp`. numpy", "question_id": 23156}
{"snippet": "numpy.isscalar(element)", "intent": "Returns True if the type of `element` is a scalar type . numpy", "question_id": 23157}
{"snippet": "numpy.signbit(x, /, signature, extobj)", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `extobj`. numpy", "question_id": 23158}
{"snippet": "numpy.signbit(x, /, signature, extobj, out=None)", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 23159}
{"snippet": "numpy.signbit(x, /, signature, extobj, where=True)", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `extobj`. numpy", "question_id": 23160}
{"snippet": "numpy.signbit(x, /, signature, extobj, casting='same_kind')", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 23161}
{"snippet": "numpy.signbit(x, /, signature, extobj, order='K')", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 23162}
{"snippet": "numpy.signbit(x, /, signature, extobj, dtype=None)", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 23163}
{"snippet": "numpy.signbit(x, /, signature, extobj, subok=True)", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 23164}
{"snippet": "numpy.signbit(x, /, signature, extobj, out=None, where=True)", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 23165}
{"snippet": "numpy.signbit(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 23166}
{"snippet": "numpy.signbit(x, /, signature, extobj, out=None, order='K')", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 23167}
{"snippet": "numpy.signbit(x, /, signature)", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`. numpy", "question_id": 23168}
{"snippet": "numpy.signbit(x, /, signature, out=None)", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `out`. numpy", "question_id": 23169}
{"snippet": "numpy.signbit(x, /, signature, where=True)", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`. numpy", "question_id": 23170}
{"snippet": "numpy.signbit(x, /, signature, casting='same_kind')", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `casting`. numpy", "question_id": 23171}
{"snippet": "numpy.signbit(x, /, signature, order='K')", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `order`. numpy", "question_id": 23172}
{"snippet": "numpy.signbit(x, /, signature, dtype=None)", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `dtype`. numpy", "question_id": 23173}
{"snippet": "numpy.signbit(x, /, signature, subok=True)", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `subok`. numpy", "question_id": 23174}
{"snippet": "numpy.signbit(x, /, signature, out=None, where=True)", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `out`. numpy", "question_id": 23175}
{"snippet": "numpy.signbit(x, /, signature, out=None, casting='same_kind')", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `out`, `casting`. numpy", "question_id": 23176}
{"snippet": "numpy.signbit(x, /, signature, out=None, order='K')", "intent": "Returns element-wise True `where` signbit is set ( less than zero ) . With arguments `x`, `/`, `signature`, `out`, `order`. numpy", "question_id": 23177}
{"snippet": "ndarray.__bool__(/)", "intent": "self ! = 0 With arguments `/`. numpy", "question_id": 23178}
{"snippet": "matrix.clip(**kwargs)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 23179}
{"snippet": "matrix.clip(**kwargs, min=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 23180}
{"snippet": "matrix.clip(**kwargs, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 23181}
{"snippet": "matrix.clip(**kwargs, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 23182}
{"snippet": "matrix.clip(**kwargs, min=None, max=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`. numpy", "question_id": 23183}
{"snippet": "matrix.clip(**kwargs, min=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 23184}
{"snippet": "matrix.clip(**kwargs, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 23185}
{"snippet": "matrix.clip(**kwargs, min=None, max=None, out=None)", "intent": "Return an array whose values are limited to [ `min` , `max` ] . With arguments `**kwargs`, `out`. numpy", "question_id": 23186}
{"snippet": "ma.MaskedArray.__rrshift__(value, /)", "intent": "Return `value` > > self . With arguments `/`. numpy", "question_id": 23187}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.parse_targets(source)", "intent": "Fetch and parse configuration statements that required for defining the targeted CPU features , statements should be declared in the top of `source` in between C comment and start with a special mark @ targets . numpy", "question_id": 23188}
{"snippet": "matlib.empty(shape)", "intent": "Return a new matrix of given `shape` and type , without initializing entries . numpy", "question_id": 23189}
{"snippet": "matlib.empty(shape, dtype=None)", "intent": "Return a new matrix of given `shape` and type , without initializing entries . With arguments `dtype`. numpy", "question_id": 23190}
{"snippet": "matlib.empty(shape, order='C')", "intent": "Return a new matrix of given `shape` and type , without initializing entries . With arguments `order`. numpy", "question_id": 23191}
{"snippet": "matlib.empty(shape, dtype=None, order='C')", "intent": "Return a new matrix of given `shape` and type , without initializing entries . With arguments `dtype`, `order`. numpy", "question_id": 23192}
{"snippet": "random.Generator.vonmises(mu, kappa)", "intent": "Draw samples from a von Mises distribution . Samples are drawn from a von Mises distribution with specified mode ( `mu` ) and dispersion ( `kappa` ) , on the interval [ -pi , pi ] . numpy", "question_id": 23193}
{"snippet": "random.Generator.vonmises(mu, kappa, size=None)", "intent": "Draw samples from a von Mises distribution . Samples are drawn from a von Mises distribution with specified mode ( `mu` ) and dispersion ( `kappa` ) , on the interval [ -pi , pi ] . With arguments `size`. numpy", "question_id": 23194}
{"snippet": "memmap.sum()", "intent": "Return the sum of the array elements over the given `axis` . numpy", "question_id": 23195}
{"snippet": "memmap.sum(axis=None)", "intent": "Return the sum of the array elements over the given `axis` . numpy", "question_id": 23196}
{"snippet": "memmap.sum(dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 23197}
{"snippet": "memmap.sum(out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`. numpy", "question_id": 23198}
{"snippet": "memmap.sum(keepdims=False)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`. numpy", "question_id": 23199}
{"snippet": "memmap.sum(initial=0)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `initial`. numpy", "question_id": 23200}
{"snippet": "memmap.sum(where=True)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `where`. numpy", "question_id": 23201}
{"snippet": "memmap.sum(axis=None, dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 23202}
{"snippet": "memmap.sum(axis=None, out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`. numpy", "question_id": 23203}
{"snippet": "memmap.sum(axis=None, keepdims=False)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`. numpy", "question_id": 23204}
{"snippet": "char.chararray.fill(value)", "intent": "Fill the array with a scalar `value` . numpy", "question_id": 23205}
{"snippet": "ma.minimum_fill_value(obj)", "intent": "Return the maximum value that can be represented by the dtype of an object . With arguments `obj`. numpy", "question_id": 23206}
{"snippet": "ma.ediff1d(arr)", "intent": "Compute the differences between consecutive elements of an array . With arguments `arr`. numpy", "question_id": 23207}
{"snippet": "ma.ediff1d(arr, to_end=None)", "intent": "Compute the differences between consecutive elements of an array . With arguments `arr`, `to_end`. numpy", "question_id": 23208}
{"snippet": "ma.ediff1d(arr, to_begin=None)", "intent": "Compute the differences between consecutive elements of an array . With arguments `arr`, `to_begin`. numpy", "question_id": 23209}
{"snippet": "ma.ediff1d(arr, to_end=None, to_begin=None)", "intent": "Compute the differences between consecutive elements of an array . With arguments `arr`, `to_end`, `to_begin`. numpy", "question_id": 23210}
{"snippet": "numpy.triu_indices_from(arr)", "intent": "Return the indices for the upper-triangle of `arr` . numpy", "question_id": 23211}
{"snippet": "numpy.triu_indices_from(arr, k=0)", "intent": "Return the indices for the upper-triangle of `arr` . With arguments `k`. numpy", "question_id": 23212}
{"snippet": "char.asarray(obj)", "intent": "Convert the input to a chararray , copying the data only if necessary . With arguments `obj`. numpy", "question_id": 23213}
{"snippet": "char.asarray(obj, itemsize=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . With arguments `obj`, `itemsize`. numpy", "question_id": 23214}
{"snippet": "char.asarray(obj, unicode=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`. numpy", "question_id": 23215}
{"snippet": "char.asarray(obj, order=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . With arguments `obj`, `order`. numpy", "question_id": 23216}
{"snippet": "char.asarray(obj, itemsize=None, unicode=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`, `itemsize`. numpy", "question_id": 23217}
{"snippet": "char.asarray(obj, itemsize=None, order=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . With arguments `obj`, `itemsize`, `order`. numpy", "question_id": 23218}
{"snippet": "char.asarray(obj, unicode=None, order=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`, `order`. numpy", "question_id": 23219}
{"snippet": "char.asarray(obj, itemsize=None, unicode=None, order=None)", "intent": "Convert the input to a chararray , copying the data only if necessary . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`, `itemsize`, `order`. numpy", "question_id": 23220}
{"snippet": "ma.masked_not_equal(x, value)", "intent": "Mask an array where not equal to a given `value` . This function is a shortcut to masked_where , with condition = ( `x` ! = value ) . numpy", "question_id": 23221}
{"snippet": "ma.masked_not_equal(x, value, copy=True)", "intent": "Mask an array where not equal to a given `value` . This function is a shortcut to masked_where , with condition = ( `x` ! = value ) . With arguments `copy`. numpy", "question_id": 23222}
{"snippet": "ma.masked_array.anom()", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . numpy", "question_id": 23223}
{"snippet": "ma.masked_array.anom(axis=None)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . numpy", "question_id": 23224}
{"snippet": "ma.masked_array.anom(dtype=None)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . With arguments `dtype`. numpy", "question_id": 23225}
{"snippet": "ma.masked_array.anom(axis=None, dtype=None)", "intent": "Compute the anomalies ( deviations from the arithmetic mean ) along the given `axis` . With arguments `dtype`. numpy", "question_id": 23226}
{"snippet": "polynomial.legendre.legweight(x)", "intent": "Weight function of the Legendre polynomials . With arguments `x`. numpy", "question_id": 23227}
{"snippet": "ma.MaskedArray.ndim", "intent": "Number of array dimensions. numpy", "question_id": 23228}
{"snippet": "ma.append(a, b)", "intent": "Append values to the end of an array . With arguments `a`, `b`. numpy", "question_id": 23229}
{"snippet": "ma.append(a, b, axis=None)", "intent": "Append values to the end of an array . With arguments `a`, `b`, `axis`. numpy", "question_id": 23230}
{"snippet": "distutils.exec_command.exec_command(command, **env)", "intent": "Return ( status , output ) of executed `command` . With arguments `**env`. numpy", "question_id": 23231}
{"snippet": "distutils.exec_command.exec_command(command, **env, execute_in='')", "intent": "Return ( status , output ) of executed `command` . With arguments `**env`, `execute_in`. numpy", "question_id": 23232}
{"snippet": "distutils.exec_command.exec_command(command, **env, use_shell=None)", "intent": "Return ( status , output ) of executed `command` . With arguments `**env`, `use_shell`. numpy", "question_id": 23233}
{"snippet": "distutils.exec_command.exec_command(command, **env, use_tee=None)", "intent": "Return ( status , output ) of executed `command` . With arguments `**env`, `use_tee`. numpy", "question_id": 23234}
{"snippet": "distutils.exec_command.exec_command(command, **env, _with_python=1)", "intent": "Return ( status , output ) of executed `command` . With arguments `**env`, `_with_python`. numpy", "question_id": 23235}
{"snippet": "distutils.exec_command.exec_command(command, **env, execute_in='', use_shell=None)", "intent": "Return ( status , output ) of executed `command` . With arguments `**env`, `execute_in`, `use_shell`. numpy", "question_id": 23236}
{"snippet": "distutils.exec_command.exec_command(command, **env, execute_in='', use_tee=None)", "intent": "Return ( status , output ) of executed `command` . With arguments `**env`, `execute_in`, `use_tee`. numpy", "question_id": 23237}
{"snippet": "distutils.exec_command.exec_command(command, **env, execute_in='', _with_python=1)", "intent": "Return ( status , output ) of executed `command` . With arguments `**env`, `execute_in`, `_with_python`. numpy", "question_id": 23238}
{"snippet": "distutils.exec_command.exec_command(command, **env, use_shell=None, use_tee=None)", "intent": "Return ( status , output ) of executed `command` . With arguments `**env`, `use_shell`, `use_tee`. numpy", "question_id": 23239}
{"snippet": "distutils.exec_command.exec_command(command, **env, use_shell=None, _with_python=1)", "intent": "Return ( status , output ) of executed `command` . With arguments `**env`, `use_shell`, `_with_python`. numpy", "question_id": 23240}
{"snippet": "random.dirichlet(alpha)", "intent": "Draw samples from the Dirichlet distribution . With arguments `alpha`. numpy", "question_id": 23241}
{"snippet": "random.dirichlet(alpha, size=None)", "intent": "Draw samples from the Dirichlet distribution . Draw `size` samples of dimension k from a Dirichlet distribution . With arguments `alpha`. numpy", "question_id": 23242}
{"snippet": "testing.suppress_warnings.__call__(func)", "intent": "Function decorator to apply certain suppressions to a whole function . With arguments `func`. numpy", "question_id": 23243}
{"snippet": "polynomial.hermite.hermval(x, c)", "intent": "Evaluate an Hermite series at points `x` . If `c` is of length n + 1 , this function returns the value : numpy", "question_id": 23244}
{"snippet": "polynomial.hermite.hermval(x, c, tensor=True)", "intent": "Evaluate an Hermite series at points `x` . If `c` is of length n + 1 , this function returns the value : If c is multidimensional , then the shape of the result depends on the value of `tensor` . numpy", "question_id": 23245}
{"snippet": "distutils.ccompiler.CCompiler_customize_cmd(self, cmd)", "intent": "Customize compiler using distutils command . With arguments `self`, `cmd`. numpy", "question_id": 23246}
{"snippet": "distutils.ccompiler.CCompiler_customize_cmd(self, cmd, ignore=())", "intent": "Customize compiler using distutils command . With arguments `self`, `cmd`, `ignore`. numpy", "question_id": 23247}
{"snippet": "polynomial.polyutils.trimseq(seq)", "intent": "Remove small Poly series coefficients . With arguments `seq`. numpy", "question_id": 23248}
{"snippet": "ma.MaskedArray.__ilshift__(value, /)", "intent": "Return self < < =value . With arguments `value`, `/`. numpy", "question_id": 23249}
{"snippet": "matlib.ones(shape)", "intent": "Matrix of ones . Return a matrix of given `shape` and type , filled with ones . numpy", "question_id": 23250}
{"snippet": "matlib.ones(shape, dtype=None)", "intent": "Matrix of ones . Return a matrix of given `shape` and type , filled with ones . With arguments `dtype`. numpy", "question_id": 23251}
{"snippet": "matlib.ones(shape, order='C')", "intent": "Matrix of ones . Return a matrix of given `shape` and type , filled with ones . With arguments `order`. numpy", "question_id": 23252}
{"snippet": "matlib.ones(shape, dtype=None, order='C')", "intent": "Matrix of ones . Return a matrix of given `shape` and type , filled with ones . With arguments `dtype`, `order`. numpy", "question_id": 23253}
{"snippet": "random.negative_binomial(n, p)", "intent": "Draw samples from a negative binomial distribution . Samples are drawn from a negative binomial distribution with specified parameters , `n` successes and `p` probability of success where n is > 0 and p is in the interval [ 0 , 1 ] . numpy", "question_id": 23254}
{"snippet": "random.negative_binomial(n, p, size=None)", "intent": "Draw samples from a negative binomial distribution . Samples are drawn from a negative binomial distribution with specified parameters , `n` successes and `p` probability of success where n is > 0 and p is in the interval [ 0 , 1 ] . With arguments `size`. numpy", "question_id": 23255}
{"snippet": "lib.scimath.log2(x)", "intent": "Compute the logarithm base 2 of `x` . numpy", "question_id": 23256}
{"snippet": "ma.masked_array.argmax()", "intent": "Returns array of indices of the maximum values along the given `axis` . numpy", "question_id": 23257}
{"snippet": "ma.masked_array.argmax(axis=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . numpy", "question_id": 23258}
{"snippet": "ma.masked_array.argmax(fill_value=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . Masked values are treated as if they had the value `fill_value` . numpy", "question_id": 23259}
{"snippet": "ma.masked_array.argmax(out=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . With arguments `out`. numpy", "question_id": 23260}
{"snippet": "ma.masked_array.argmax(axis=None, fill_value=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . Masked values are treated as if they had the value `fill_value` . numpy", "question_id": 23261}
{"snippet": "ma.masked_array.argmax(axis=None, out=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . With arguments `out`. numpy", "question_id": 23262}
{"snippet": "ma.masked_array.argmax(fill_value=None, out=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . Masked values are treated as if they had the value `fill_value` . With arguments `out`. numpy", "question_id": 23263}
{"snippet": "ma.masked_array.argmax(axis=None, fill_value=None, out=None)", "intent": "Returns array of indices of the maximum values along the given `axis` . Masked values are treated as if they had the value `fill_value` . With arguments `out`. numpy", "question_id": 23264}
{"snippet": "memmap.sort()", "intent": "Sort an array in-place . numpy", "question_id": 23265}
{"snippet": "memmap.sort(axis=- 1)", "intent": "Sort an array in-place . With arguments `axis`. numpy", "question_id": 23266}
{"snippet": "memmap.sort(kind=None)", "intent": "Sort an array in-place . With arguments `kind`. numpy", "question_id": 23267}
{"snippet": "memmap.sort(order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : numpy", "question_id": 23268}
{"snippet": "memmap.sort(axis=- 1, kind=None)", "intent": "Sort an array in-place . With arguments `axis`, `kind`. numpy", "question_id": 23269}
{"snippet": "memmap.sort(axis=- 1, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `axis`. numpy", "question_id": 23270}
{"snippet": "memmap.sort(kind=None, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `kind`. numpy", "question_id": 23271}
{"snippet": "memmap.sort(axis=- 1, kind=None, order=None)", "intent": "Sort an array in-place . Use the `order` keyword to specify a field to use when sorting a structured array : With arguments `axis`, `kind`. numpy", "question_id": 23272}
{"snippet": "linalg.cond(x)", "intent": "Compute the condition number of a matrix . The condition number of `x` is defined as the norm of x times the norm of the inverse of x [ 1 ] ; the norm can be the usual L2-norm ( root-of-sum-of-squares ) or one of a number of other matrix norms . numpy", "question_id": 23273}
{"snippet": "linalg.cond(x, p=None)", "intent": "Compute the condition number of a matrix . The condition number of `x` is defined as the norm of x times the norm of the inverse of x [ 1 ] ; the norm can be the usual L2-norm ( root-of-sum-of-squares ) or one of a number of other matrix norms . This function is capable of returning the condition number using one of seven different norms , depending on the value of `p` ( see Parameters below ) . numpy", "question_id": 23274}
{"snippet": "char.chararray.ljust(width)", "intent": "Return an array with the elements of self left-justified in a string of length `width` . numpy", "question_id": 23275}
{"snippet": "char.chararray.ljust(width, fillchar=' ')", "intent": "Return an array with the elements of self left-justified in a string of length `width` . With arguments `fillchar`. numpy", "question_id": 23276}
{"snippet": "random.RandomState.bytes(length)", "intent": "Return random bytes . With arguments `length`. numpy", "question_id": 23277}
{"snippet": "numpy.around(a)", "intent": "Evenly round to the given number of `decimals` . np.around uses `a` fast but sometimes inexact algorithm to round floating-point datatypes . numpy", "question_id": 23278}
{"snippet": "numpy.around(a, decimals=0)", "intent": "Evenly round to the given number of `decimals` . np.around uses `a` fast but sometimes inexact algorithm to round floating-point datatypes . numpy", "question_id": 23279}
{"snippet": "numpy.around(a, out=None)", "intent": "Evenly round to the given number of `decimals` . np.around uses `a` fast but sometimes inexact algorithm to round floating-point datatypes . With arguments `out`. numpy", "question_id": 23280}
{"snippet": "numpy.around(a, decimals=0, out=None)", "intent": "Evenly round to the given number of `decimals` . np.around uses `a` fast but sometimes inexact algorithm to round floating-point datatypes . With arguments `out`. numpy", "question_id": 23281}
{"snippet": "ndarray.itemset(*args)", "intent": "Insert scalar into an array ( scalar is cast to array \u2019 s dtype , if possible ) With arguments `*args`. numpy", "question_id": 23282}
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, extobj)", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`. numpy", "question_id": 23283}
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, extobj, out=None)", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 23284}
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, extobj, where=True)", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `where`. numpy", "question_id": 23285}
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 23286}
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, extobj, order='K')", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 23287}
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, extobj, dtype=None)", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 23288}
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, extobj, subok=True)", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 23289}
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 23290}
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 23291}
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 23292}
{"snippet": "numpy.bitwise_and(x1, x2, /, signature)", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`. numpy", "question_id": 23293}
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, out=None)", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `out`. numpy", "question_id": 23294}
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, where=True)", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `where`. numpy", "question_id": 23295}
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, casting='same_kind')", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `casting`. numpy", "question_id": 23296}
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, order='K')", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `order`. numpy", "question_id": 23297}
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, dtype=None)", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `dtype`. numpy", "question_id": 23298}
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, subok=True)", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `subok`. numpy", "question_id": 23299}
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, out=None, where=True)", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `out`, `where`. numpy", "question_id": 23300}
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `out`, `casting`. numpy", "question_id": 23301}
{"snippet": "numpy.bitwise_and(x1, x2, /, signature, out=None, order='K')", "intent": "Compute the bit-wise AND of two arrays element-wise . With arguments `x1`, `x2`, `/`, `signature`, `out`, `order`. numpy", "question_id": 23302}
{"snippet": "char.chararray.argsort()", "intent": "Returns the indices that would sort this array . numpy", "question_id": 23303}
{"snippet": "char.chararray.argsort(axis=- 1)", "intent": "Returns the indices that would sort this array . With arguments `axis`. numpy", "question_id": 23304}
{"snippet": "char.chararray.argsort(kind=None)", "intent": "Returns the indices that would sort this array . With arguments `kind`. numpy", "question_id": 23305}
{"snippet": "char.chararray.argsort(order=None)", "intent": "Returns the indices that would sort this array . With arguments `order`. numpy", "question_id": 23306}
{"snippet": "char.chararray.argsort(axis=- 1, kind=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `kind`. numpy", "question_id": 23307}
{"snippet": "char.chararray.argsort(axis=- 1, order=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `order`. numpy", "question_id": 23308}
{"snippet": "char.chararray.argsort(kind=None, order=None)", "intent": "Returns the indices that would sort this array . With arguments `kind`, `order`. numpy", "question_id": 23309}
{"snippet": "char.chararray.argsort(axis=- 1, kind=None, order=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `kind`, `order`. numpy", "question_id": 23310}
{"snippet": "polynomial.legendre.legline(off, scl)", "intent": "Legendre series whose graph is a straight line . With arguments `off`, `scl`. numpy", "question_id": 23311}
{"snippet": "memmap.newbyteorder(/)", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`. numpy", "question_id": 23312}
{"snippet": "memmap.newbyteorder(/, new_order='S')", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`, `new_order`. numpy", "question_id": 23313}
{"snippet": "ma.MaskType.max()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 23314}
{"snippet": "numpy.negative(x, /, signature, extobj)", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `extobj`. numpy", "question_id": 23315}
{"snippet": "numpy.negative(x, /, signature, extobj, out=None)", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 23316}
{"snippet": "numpy.negative(x, /, signature, extobj, where=True)", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `where`. numpy", "question_id": 23317}
{"snippet": "numpy.negative(x, /, signature, extobj, casting='same_kind')", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 23318}
{"snippet": "numpy.negative(x, /, signature, extobj, order='K')", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 23319}
{"snippet": "numpy.negative(x, /, signature, extobj, dtype=None)", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 23320}
{"snippet": "numpy.negative(x, /, signature, extobj, subok=True)", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 23321}
{"snippet": "numpy.negative(x, /, signature, extobj, out=None, where=True)", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 23322}
{"snippet": "numpy.negative(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 23323}
{"snippet": "numpy.negative(x, /, signature, extobj, out=None, order='K')", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 23324}
{"snippet": "numpy.negative(x, /, signature)", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`. numpy", "question_id": 23325}
{"snippet": "numpy.negative(x, /, signature, out=None)", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `out`. numpy", "question_id": 23326}
{"snippet": "numpy.negative(x, /, signature, where=True)", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `where`. numpy", "question_id": 23327}
{"snippet": "numpy.negative(x, /, signature, casting='same_kind')", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `casting`. numpy", "question_id": 23328}
{"snippet": "numpy.negative(x, /, signature, order='K')", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `order`. numpy", "question_id": 23329}
{"snippet": "numpy.negative(x, /, signature, dtype=None)", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `dtype`. numpy", "question_id": 23330}
{"snippet": "numpy.negative(x, /, signature, subok=True)", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `subok`. numpy", "question_id": 23331}
{"snippet": "numpy.negative(x, /, signature, out=None, where=True)", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `out`, `where`. numpy", "question_id": 23332}
{"snippet": "numpy.negative(x, /, signature, out=None, casting='same_kind')", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `out`, `casting`. numpy", "question_id": 23333}
{"snippet": "numpy.negative(x, /, signature, out=None, order='K')", "intent": "Numerical negative , element-wise . With arguments `x`, `/`, `signature`, `out`, `order`. numpy", "question_id": 23334}
{"snippet": "random.Generator.standard_normal()", "intent": "Draw samples from a standard Normal distribution ( mean=0 , stdev=1 ) . numpy", "question_id": 23335}
{"snippet": "random.Generator.standard_normal(size=None)", "intent": "Draw samples from a standard Normal distribution ( mean=0 , stdev=1 ) . With arguments `size`. numpy", "question_id": 23336}
{"snippet": "random.Generator.standard_normal(dtype=np.float64)", "intent": "Draw samples from a standard Normal distribution ( mean=0 , stdev=1 ) . With arguments `dtype`. numpy", "question_id": 23337}
{"snippet": "random.Generator.standard_normal(out=None)", "intent": "Draw samples from a standard Normal distribution ( mean=0 , stdev=1 ) . With arguments `out`. numpy", "question_id": 23338}
{"snippet": "random.Generator.standard_normal(size=None, dtype=np.float64)", "intent": "Draw samples from a standard Normal distribution ( mean=0 , stdev=1 ) . With arguments `size`, `dtype`. numpy", "question_id": 23339}
{"snippet": "random.Generator.standard_normal(size=None, out=None)", "intent": "Draw samples from a standard Normal distribution ( mean=0 , stdev=1 ) . With arguments `size`, `out`. numpy", "question_id": 23340}
{"snippet": "random.Generator.standard_normal(dtype=np.float64, out=None)", "intent": "Draw samples from a standard Normal distribution ( mean=0 , stdev=1 ) . With arguments `dtype`, `out`. numpy", "question_id": 23341}
{"snippet": "random.Generator.standard_normal(size=None, dtype=np.float64, out=None)", "intent": "Draw samples from a standard Normal distribution ( mean=0 , stdev=1 ) . With arguments `size`, `dtype`, `out`. numpy", "question_id": 23342}
{"snippet": "numpy.power(x1, x2, /, signature, extobj)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 23343}
{"snippet": "numpy.power(x1, x2, /, signature, extobj, out=None)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 23344}
{"snippet": "numpy.power(x1, x2, /, signature, extobj, where=True)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 23345}
{"snippet": "numpy.power(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 23346}
{"snippet": "numpy.power(x1, x2, /, signature, extobj, order='K')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 23347}
{"snippet": "numpy.power(x1, x2, /, signature, extobj, dtype=None)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 23348}
{"snippet": "numpy.power(x1, x2, /, signature, extobj, subok=True)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 23349}
{"snippet": "numpy.power(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 23350}
{"snippet": "numpy.power(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 23351}
{"snippet": "numpy.power(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 23352}
{"snippet": "numpy.power(x1, x2, /, signature)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`. numpy", "question_id": 23353}
{"snippet": "numpy.power(x1, x2, /, signature, out=None)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `out`. numpy", "question_id": 23354}
{"snippet": "numpy.power(x1, x2, /, signature, where=True)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `where`. numpy", "question_id": 23355}
{"snippet": "numpy.power(x1, x2, /, signature, casting='same_kind')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `casting`. numpy", "question_id": 23356}
{"snippet": "numpy.power(x1, x2, /, signature, order='K')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `order`. numpy", "question_id": 23357}
{"snippet": "numpy.power(x1, x2, /, signature, dtype=None)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 23358}
{"snippet": "numpy.power(x1, x2, /, signature, subok=True)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `subok`. numpy", "question_id": 23359}
{"snippet": "numpy.power(x1, x2, /, signature, out=None, where=True)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 23360}
{"snippet": "numpy.power(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 23361}
{"snippet": "numpy.power(x1, x2, /, signature, out=None, order='K')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 23362}
{"snippet": "ma.MaskedArray.__delitem__(key, /)", "intent": "Delete self [ `key` ] . With arguments `/`. numpy", "question_id": 23363}
{"snippet": "numpy.exp2(x, /, signature, extobj)", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `extobj`. numpy", "question_id": 23364}
{"snippet": "numpy.exp2(x, /, signature, extobj, out=None)", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 23365}
{"snippet": "numpy.exp2(x, /, signature, extobj, where=True)", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `extobj`, `where`. numpy", "question_id": 23366}
{"snippet": "numpy.exp2(x, /, signature, extobj, casting='same_kind')", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 23367}
{"snippet": "numpy.exp2(x, /, signature, extobj, order='K')", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 23368}
{"snippet": "numpy.exp2(x, /, signature, extobj, dtype=None)", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 23369}
{"snippet": "numpy.exp2(x, /, signature, extobj, subok=True)", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 23370}
{"snippet": "numpy.exp2(x, /, signature, extobj, out=None, where=True)", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 23371}
{"snippet": "numpy.exp2(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 23372}
{"snippet": "numpy.exp2(x, /, signature, extobj, out=None, order='K')", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 23373}
{"snippet": "numpy.exp2(x, /, signature)", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`. numpy", "question_id": 23374}
{"snippet": "numpy.exp2(x, /, signature, out=None)", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `out`. numpy", "question_id": 23375}
{"snippet": "numpy.exp2(x, /, signature, where=True)", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `where`. numpy", "question_id": 23376}
{"snippet": "numpy.exp2(x, /, signature, casting='same_kind')", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `casting`. numpy", "question_id": 23377}
{"snippet": "numpy.exp2(x, /, signature, order='K')", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `order`. numpy", "question_id": 23378}
{"snippet": "numpy.exp2(x, /, signature, dtype=None)", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `dtype`. numpy", "question_id": 23379}
{"snippet": "numpy.exp2(x, /, signature, subok=True)", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `subok`. numpy", "question_id": 23380}
{"snippet": "numpy.exp2(x, /, signature, out=None, where=True)", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `out`, `where`. numpy", "question_id": 23381}
{"snippet": "numpy.exp2(x, /, signature, out=None, casting='same_kind')", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `out`, `casting`. numpy", "question_id": 23382}
{"snippet": "numpy.exp2(x, /, signature, out=None, order='K')", "intent": "Calculate 2 * * p for all p in the input array . With arguments `x`, `/`, `signature`, `out`, `order`. numpy", "question_id": 23383}
{"snippet": "numpy.atleast_3d(*arys)", "intent": "View inputs as arrays with at least three dimensions . With arguments `*arys`. numpy", "question_id": 23384}
{"snippet": "polynomial.legendre.legcompanion(c)", "intent": "Return the scaled companion matrix of `c` . numpy", "question_id": 23385}
{"snippet": "polynomial.legendre.legtrim(c)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . With arguments `c`. numpy", "question_id": 23386}
{"snippet": "polynomial.legendre.legtrim(c, tol=0)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . \u201c Small \u201d means \u201c small in absolute value \u201d and is controlled by the parameter `tol` ; \u201c trailing \u201d means highest order coefficient ( s ) , e.g. , in [ 0 , 1 , 1 , 0 , 0 ] ( which represents 0 + x + x * * 2 + 0 * x * * 3 + 0 * x * * 4 ) both the 3-rd and 4-th order coefficients would be \u201c trimmed . \u201d With arguments `c`. numpy", "question_id": 23387}
{"snippet": "memmap.itemsize", "intent": "Length of one array element in bytes. numpy", "question_id": 23388}
{"snippet": "char.chararray.byteswap()", "intent": "Swap the bytes of the array elements numpy", "question_id": 23389}
{"snippet": "char.chararray.byteswap(inplace=False)", "intent": "Swap the bytes of the array elements With arguments `inplace`. numpy", "question_id": 23390}
{"snippet": "polynomial.chebyshev.Chebyshev.interpolate(func, deg)", "intent": "Interpolate a function at the Chebyshev points of the first kind . Returns the series that interpolates `func` at the Chebyshev points of the first kind scaled and shifted to the `domain` . With arguments `deg`. numpy", "question_id": 23391}
{"snippet": "polynomial.chebyshev.Chebyshev.interpolate(func, deg, domain=None)", "intent": "Interpolate a function at the Chebyshev points of the first kind . Returns the series that interpolates `func` at the Chebyshev points of the first kind scaled and shifted to the `domain` . With arguments `deg`. numpy", "question_id": 23392}
{"snippet": "polynomial.chebyshev.Chebyshev.interpolate(func, deg, args=())", "intent": "Interpolate a function at the Chebyshev points of the first kind . Returns the series that interpolates `func` at the Chebyshev points of the first kind scaled and shifted to the `domain` . With arguments `deg`, `args`. numpy", "question_id": 23393}
{"snippet": "polynomial.chebyshev.Chebyshev.interpolate(func, deg, domain=None, args=())", "intent": "Interpolate a function at the Chebyshev points of the first kind . Returns the series that interpolates `func` at the Chebyshev points of the first kind scaled and shifted to the `domain` . With arguments `deg`, `args`. numpy", "question_id": 23394}
{"snippet": "ndarray.conjugate()", "intent": "Return the complex conjugate , element-wise . numpy", "question_id": 23395}
{"snippet": "ndarray.astype(dtype)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`. numpy", "question_id": 23396}
{"snippet": "ndarray.astype(dtype, order='K')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`. numpy", "question_id": 23397}
{"snippet": "ndarray.astype(dtype, casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`. numpy", "question_id": 23398}
{"snippet": "ndarray.astype(dtype, subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `subok`. numpy", "question_id": 23399}
{"snippet": "ndarray.astype(dtype, copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `copy`. numpy", "question_id": 23400}
{"snippet": "ndarray.astype(dtype, order='K', casting='unsafe')", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `casting`. numpy", "question_id": 23401}
{"snippet": "ndarray.astype(dtype, order='K', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `subok`. numpy", "question_id": 23402}
{"snippet": "ndarray.astype(dtype, order='K', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `order`, `copy`. numpy", "question_id": 23403}
{"snippet": "ndarray.astype(dtype, casting='unsafe', subok=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `subok`. numpy", "question_id": 23404}
{"snippet": "ndarray.astype(dtype, casting='unsafe', copy=True)", "intent": "Copy of the array , cast to a specified type . With arguments `dtype`, `casting`, `copy`. numpy", "question_id": 23405}
{"snippet": "matrix.fill(value)", "intent": "Fill the array with a scalar `value` . numpy", "question_id": 23406}
{"snippet": "polynomial.hermite_e.hermegrid3d(x, y, z, c)", "intent": "Evaluate a 3-D HermiteE series on the Cartesian product of `x` , `y` , and `z` . where the points ( a , b , `c` ) consist of all triples formed by taking a from x , b from y , and c from z . numpy", "question_id": 23407}
{"snippet": "memmap.squeeze()", "intent": "Remove axes of length one from a . numpy", "question_id": 23408}
{"snippet": "memmap.squeeze(axis=None)", "intent": "Remove axes of length one from a . With arguments `axis`. numpy", "question_id": 23409}
{"snippet": "polynomial.legendre.Legendre.integ()", "intent": "Integrate . numpy", "question_id": 23410}
{"snippet": "polynomial.legendre.Legendre.integ(m=1)", "intent": "Integrate . With arguments `m`. numpy", "question_id": 23411}
{"snippet": "polynomial.legendre.Legendre.integ(k=)", "intent": "Integrate . With arguments `k`. numpy", "question_id": 23412}
{"snippet": "polynomial.legendre.Legendre.integ(lbnd=None)", "intent": "Integrate . With arguments `lbnd`. numpy", "question_id": 23413}
{"snippet": "polynomial.legendre.Legendre.integ(m=1, k=)", "intent": "Integrate . With arguments `m`, `k`. numpy", "question_id": 23414}
{"snippet": "polynomial.legendre.Legendre.integ(m=1, lbnd=None)", "intent": "Integrate . With arguments `m`, `lbnd`. numpy", "question_id": 23415}
{"snippet": "polynomial.legendre.Legendre.integ(k=, lbnd=None)", "intent": "Integrate . With arguments `k`, `lbnd`. numpy", "question_id": 23416}
{"snippet": "polynomial.legendre.Legendre.integ(m=1, k=, lbnd=None)", "intent": "Integrate . With arguments `m`, `k`, `lbnd`. numpy", "question_id": 23417}
{"snippet": "polynomial.legendre.Legendre.integ()", "intent": "Integrate . numpy", "question_id": 23418}
{"snippet": "polynomial.legendre.Legendre.integ(m=1)", "intent": "Integrate . With arguments `m`. numpy", "question_id": 23419}
{"snippet": "polynomial.legendre.Legendre.integ(k=)", "intent": "Integrate . With arguments `k`. numpy", "question_id": 23420}
{"snippet": "polynomial.legendre.Legendre.integ(lbnd=None)", "intent": "Integrate . With arguments `lbnd`. numpy", "question_id": 23421}
{"snippet": "polynomial.legendre.Legendre.integ(m=1, k=)", "intent": "Integrate . With arguments `m`, `k`. numpy", "question_id": 23422}
{"snippet": "polynomial.legendre.Legendre.integ(m=1, lbnd=None)", "intent": "Integrate . With arguments `m`, `lbnd`. numpy", "question_id": 23423}
{"snippet": "polynomial.legendre.Legendre.integ(k=, lbnd=None)", "intent": "Integrate . With arguments `k`, `lbnd`. numpy", "question_id": 23424}
{"snippet": "polynomial.legendre.Legendre.integ(m=1, k=, lbnd=None)", "intent": "Integrate . With arguments `m`, `k`, `lbnd`. numpy", "question_id": 23425}
{"snippet": "memmap.tostring()", "intent": "A compatibility alias for tobytes , with exactly the same behavior . numpy", "question_id": 23426}
{"snippet": "memmap.tostring(order='C')", "intent": "A compatibility alias for tobytes , with exactly the same behavior . With arguments `order`. numpy", "question_id": 23427}
{"snippet": "ufunc.signature", "intent": "Definition of the core elements a generalized ufunc operates on. numpy", "question_id": 23428}
{"snippet": "ma.MaskedArray.__irshift__(value, /)", "intent": "Return self > > =value . With arguments `value`, `/`. numpy", "question_id": 23429}
{"snippet": "ndarray.base", "intent": "Base object if memory is from some other object. numpy", "question_id": 23430}
{"snippet": "polynomial.hermite.hermder(c)", "intent": "Differentiate a Hermite series . Returns the Hermite series coefficients `c` differentiated `m` times along `axis` . numpy", "question_id": 23431}
{"snippet": "polynomial.hermite.hermder(c, m=1)", "intent": "Differentiate a Hermite series . Returns the Hermite series coefficients `c` differentiated `m` times along `axis` . numpy", "question_id": 23432}
{"snippet": "polynomial.hermite.hermder(c, scl=1)", "intent": "Differentiate a Hermite series . Returns the Hermite series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) . numpy", "question_id": 23433}
{"snippet": "polynomial.hermite.hermder(c, axis=0)", "intent": "Differentiate a Hermite series . Returns the Hermite series coefficients `c` differentiated `m` times along `axis` . numpy", "question_id": 23434}
{"snippet": "polynomial.hermite.hermder(c, m=1, scl=1)", "intent": "Differentiate a Hermite series . Returns the Hermite series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) . numpy", "question_id": 23435}
{"snippet": "polynomial.hermite.hermder(c, m=1, axis=0)", "intent": "Differentiate a Hermite series . Returns the Hermite series coefficients `c` differentiated `m` times along `axis` . numpy", "question_id": 23436}
{"snippet": "polynomial.hermite.hermder(c, scl=1, axis=0)", "intent": "Differentiate a Hermite series . Returns the Hermite series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) . numpy", "question_id": 23437}
{"snippet": "polynomial.hermite.hermder(c, m=1, scl=1, axis=0)", "intent": "Differentiate a Hermite series . Returns the Hermite series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) . numpy", "question_id": 23438}
{"snippet": "chararray.rfind(sub)", "intent": "For each element in self , return the highest index in the string where substring `sub` is found , such that sub is contained within [ `start` , `end` ] . numpy", "question_id": 23439}
{"snippet": "chararray.rfind(sub, start=0)", "intent": "For each element in self , return the highest index in the string where substring `sub` is found , such that sub is contained within [ `start` , `end` ] . numpy", "question_id": 23440}
{"snippet": "chararray.rfind(sub, end=None)", "intent": "For each element in self , return the highest index in the string where substring `sub` is found , such that sub is contained within [ `start` , `end` ] . numpy", "question_id": 23441}
{"snippet": "chararray.rfind(sub, start=0, end=None)", "intent": "For each element in self , return the highest index in the string where substring `sub` is found , such that sub is contained within [ `start` , `end` ] . numpy", "question_id": 23442}
{"snippet": "random.Generator.noncentral_f(dfnum, dfden, nonc)", "intent": "Draw samples from the noncentral F distribution . Samples are drawn from an F distribution with specified parameters , `dfnum` ( degrees of freedom in numerator ) and `dfden` ( degrees of freedom in denominator ) , where both parameters > 1. `nonc` is the non-centrality parameter . numpy", "question_id": 23443}
{"snippet": "random.Generator.noncentral_f(dfnum, dfden, nonc, size=None)", "intent": "Draw samples from the noncentral F distribution . Samples are drawn from an F distribution with specified parameters , `dfnum` ( degrees of freedom in numerator ) and `dfden` ( degrees of freedom in denominator ) , where both parameters > 1. `nonc` is the non-centrality parameter . With arguments `size`. numpy", "question_id": 23444}
{"snippet": "ma.getdata(a)", "intent": "Return the data of `a` masked array as an ndarray . numpy", "question_id": 23445}
{"snippet": "ma.getdata(a, subok=True)", "intent": "Return the data of `a` masked array as an ndarray . Return the data of a ( if any ) as an ndarray if a is a MaskedArray , else return a as a ndarray or subclass ( depending on `subok` ) if not . numpy", "question_id": 23446}
{"snippet": "record.prod()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 23447}
{"snippet": "numpy.chararray(shape)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . numpy", "question_id": 23448}
{"snippet": "numpy.chararray(shape, itemsize=1)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . With arguments `itemsize`. numpy", "question_id": 23449}
{"snippet": "numpy.chararray(shape, unicode=False)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . numpy", "question_id": 23450}
{"snippet": "numpy.chararray(shape, buffer=None)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . This constructor creates the array , using `buffer` ( with `offset` and `strides` ) if it is not None . numpy", "question_id": 23451}
{"snippet": "numpy.chararray(shape, offset=0)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . This constructor creates the array , using `buffer` ( with `offset` and `strides` ) if it is not None . numpy", "question_id": 23452}
{"snippet": "numpy.chararray(shape, strides=None)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . This constructor creates the array , using `buffer` ( with `offset` and `strides` ) if it is not None . numpy", "question_id": 23453}
{"snippet": "numpy.chararray(shape, order=None)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . numpy", "question_id": 23454}
{"snippet": "numpy.chararray(shape, itemsize=1, unicode=False)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . With arguments `itemsize`. numpy", "question_id": 23455}
{"snippet": "numpy.chararray(shape, itemsize=1, buffer=None)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . This constructor creates the array , using `buffer` ( with `offset` and `strides` ) if it is not None . With arguments `itemsize`. numpy", "question_id": 23456}
{"snippet": "numpy.chararray(shape, itemsize=1, offset=0)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . This constructor creates the array , using `buffer` ( with `offset` and `strides` ) if it is not None . With arguments `itemsize`. numpy", "question_id": 23457}
{"snippet": "numpy.asarray_chkfinite(a)", "intent": "Convert the input to an array , checking for NaNs or Infs . Convert `a` list into an array . numpy", "question_id": 23458}
{"snippet": "numpy.asarray_chkfinite(a, dtype=None)", "intent": "Convert the input to an array , checking for NaNs or Infs . Convert `a` list into an array . With arguments `dtype`. numpy", "question_id": 23459}
{"snippet": "numpy.asarray_chkfinite(a, order=None)", "intent": "Convert the input to an array , checking for NaNs or Infs . Convert `a` list into an array . With arguments `order`. numpy", "question_id": 23460}
{"snippet": "numpy.asarray_chkfinite(a, dtype=None, order=None)", "intent": "Convert the input to an array , checking for NaNs or Infs . Convert `a` list into an array . With arguments `dtype`, `order`. numpy", "question_id": 23461}
{"snippet": "numpy.show_config()", "intent": "Show libraries in the system on which NumPy was built . numpy", "question_id": 23462}
{"snippet": "numpy.isnat(x, /, signature, extobj)", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`. numpy", "question_id": 23463}
{"snippet": "numpy.isnat(x, /, signature, extobj, out=None)", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 23464}
{"snippet": "numpy.isnat(x, /, signature, extobj, where=True)", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `where`. numpy", "question_id": 23465}
{"snippet": "numpy.isnat(x, /, signature, extobj, casting='same_kind')", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 23466}
{"snippet": "numpy.isnat(x, /, signature, extobj, order='K')", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 23467}
{"snippet": "numpy.isnat(x, /, signature, extobj, dtype=None)", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 23468}
{"snippet": "numpy.isnat(x, /, signature, extobj, subok=True)", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 23469}
{"snippet": "numpy.isnat(x, /, signature, extobj, out=None, where=True)", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 23470}
{"snippet": "numpy.isnat(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 23471}
{"snippet": "numpy.isnat(x, /, signature, extobj, out=None, order='K')", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 23472}
{"snippet": "numpy.isnat(x, /, signature)", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`. numpy", "question_id": 23473}
{"snippet": "numpy.isnat(x, /, signature, out=None)", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `out`. numpy", "question_id": 23474}
{"snippet": "numpy.isnat(x, /, signature, where=True)", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `where`. numpy", "question_id": 23475}
{"snippet": "numpy.isnat(x, /, signature, casting='same_kind')", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `casting`. numpy", "question_id": 23476}
{"snippet": "numpy.isnat(x, /, signature, order='K')", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `order`. numpy", "question_id": 23477}
{"snippet": "numpy.isnat(x, /, signature, dtype=None)", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `dtype`. numpy", "question_id": 23478}
{"snippet": "numpy.isnat(x, /, signature, subok=True)", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `subok`. numpy", "question_id": 23479}
{"snippet": "numpy.isnat(x, /, signature, out=None, where=True)", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `out`, `where`. numpy", "question_id": 23480}
{"snippet": "numpy.isnat(x, /, signature, out=None, casting='same_kind')", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `out`, `casting`. numpy", "question_id": 23481}
{"snippet": "numpy.isnat(x, /, signature, out=None, order='K')", "intent": "Test element-wise for NaT ( not a time ) and return result as a boolean array . With arguments `x`, `/`, `signature`, `out`, `order`. numpy", "question_id": 23482}
{"snippet": "ma.transpose(a)", "intent": "Permute the dimensions of an array . With arguments `a`. numpy", "question_id": 23483}
{"snippet": "ma.transpose(a, axes=None)", "intent": "Permute the dimensions of an array . With arguments `a`, `axes`. numpy", "question_id": 23484}
{"snippet": "numpy.arccos(x, /, signature, extobj)", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 23485}
{"snippet": "numpy.arccos(x, /, signature, extobj, out=None)", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 23486}
{"snippet": "numpy.arccos(x, /, signature, extobj, where=True)", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 23487}
{"snippet": "numpy.arccos(x, /, signature, extobj, casting='same_kind')", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 23488}
{"snippet": "numpy.arccos(x, /, signature, extobj, order='K')", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 23489}
{"snippet": "numpy.arccos(x, /, signature, extobj, dtype=None)", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 23490}
{"snippet": "numpy.arccos(x, /, signature, extobj, subok=True)", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 23491}
{"snippet": "numpy.arccos(x, /, signature, extobj, out=None, where=True)", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 23492}
{"snippet": "numpy.arccos(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 23493}
{"snippet": "numpy.arccos(x, /, signature, extobj, out=None, order='K')", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 23494}
{"snippet": "numpy.arccos(x, /, signature)", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`. numpy", "question_id": 23495}
{"snippet": "numpy.arccos(x, /, signature, out=None)", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `out`. numpy", "question_id": 23496}
{"snippet": "numpy.arccos(x, /, signature, where=True)", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `where`. numpy", "question_id": 23497}
{"snippet": "numpy.arccos(x, /, signature, casting='same_kind')", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `casting`. numpy", "question_id": 23498}
{"snippet": "numpy.arccos(x, /, signature, order='K')", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `order`. numpy", "question_id": 23499}
{"snippet": "numpy.arccos(x, /, signature, dtype=None)", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 23500}
{"snippet": "numpy.arccos(x, /, signature, subok=True)", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `subok`. numpy", "question_id": 23501}
{"snippet": "numpy.arccos(x, /, signature, out=None, where=True)", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 23502}
{"snippet": "numpy.arccos(x, /, signature, out=None, casting='same_kind')", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 23503}
{"snippet": "numpy.arccos(x, /, signature, out=None, order='K')", "intent": "Trigonometric inverse cosine , element-wise . The inverse of cos so that , if y = cos ( `x` ) , then x = arccos ( y ) . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 23504}
{"snippet": "recarray.trace()", "intent": "Return the sum along diagonals of the array . numpy", "question_id": 23505}
{"snippet": "recarray.trace(offset=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`. numpy", "question_id": 23506}
{"snippet": "recarray.trace(axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `axis1`. numpy", "question_id": 23507}
{"snippet": "recarray.trace(axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `axis2`. numpy", "question_id": 23508}
{"snippet": "recarray.trace(dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `dtype`. numpy", "question_id": 23509}
{"snippet": "recarray.trace(out=None)", "intent": "Return the sum along diagonals of the array . With arguments `out`. numpy", "question_id": 23510}
{"snippet": "recarray.trace(offset=0, axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis1`. numpy", "question_id": 23511}
{"snippet": "recarray.trace(offset=0, axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis2`. numpy", "question_id": 23512}
{"snippet": "recarray.trace(offset=0, dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `dtype`. numpy", "question_id": 23513}
{"snippet": "recarray.trace(offset=0, out=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `out`. numpy", "question_id": 23514}
{"snippet": "ma.MaskType.base", "intent": "Scalar attribute identical to the corresponding array attribute. numpy", "question_id": 23515}
{"snippet": "DataSource.open(path)", "intent": "Open and return file-like object . If `path` is an URL , it will be downloaded , stored in the DataSource directory and opened from there . numpy", "question_id": 23516}
{"snippet": "DataSource.open(path, mode='r')", "intent": "Open and return file-like object . If `path` is an URL , it will be downloaded , stored in the DataSource directory and opened from there . With arguments `mode`. numpy", "question_id": 23517}
{"snippet": "DataSource.open(path, encoding=None)", "intent": "Open and return file-like object . If `path` is an URL , it will be downloaded , stored in the DataSource directory and opened from there . With arguments `encoding`. numpy", "question_id": 23518}
{"snippet": "DataSource.open(path, newline=None)", "intent": "Open and return file-like object . If `path` is an URL , it will be downloaded , stored in the DataSource directory and opened from there . With arguments `newline`. numpy", "question_id": 23519}
{"snippet": "DataSource.open(path, mode='r', encoding=None)", "intent": "Open and return file-like object . If `path` is an URL , it will be downloaded , stored in the DataSource directory and opened from there . With arguments `mode`, `encoding`. numpy", "question_id": 23520}
{"snippet": "DataSource.open(path, mode='r', newline=None)", "intent": "Open and return file-like object . If `path` is an URL , it will be downloaded , stored in the DataSource directory and opened from there . With arguments `mode`, `newline`. numpy", "question_id": 23521}
{"snippet": "DataSource.open(path, encoding=None, newline=None)", "intent": "Open and return file-like object . If `path` is an URL , it will be downloaded , stored in the DataSource directory and opened from there . With arguments `encoding`, `newline`. numpy", "question_id": 23522}
{"snippet": "DataSource.open(path, mode='r', encoding=None, newline=None)", "intent": "Open and return file-like object . If `path` is an URL , it will be downloaded , stored in the DataSource directory and opened from there . With arguments `mode`, `encoding`, `newline`. numpy", "question_id": 23523}
{"snippet": "matrix.swapaxes(axis1, axis2)", "intent": "Return a view of the array with `axis1` and `axis2` interchanged . numpy", "question_id": 23524}
{"snippet": "numpy.array_equiv(a1, a2)", "intent": "Returns True if input arrays are shape consistent and all elements equal . With arguments `a1`, `a2`. numpy", "question_id": 23525}
{"snippet": "numpy.compress(condition, a)", "intent": "Return selected slices of an array along given `axis` . When working along `a` given axis , a slice along that axis is returned in output for each index where `condition` evaluates to True . numpy", "question_id": 23526}
{"snippet": "numpy.compress(condition, a, axis=None)", "intent": "Return selected slices of an array along given `axis` . When working along `a` given axis , a slice along that axis is returned in output for each index where `condition` evaluates to True . numpy", "question_id": 23527}
{"snippet": "numpy.compress(condition, a, out=None)", "intent": "Return selected slices of an array along given `axis` . When working along `a` given axis , a slice along that axis is returned in output for each index where `condition` evaluates to True . With arguments `out`. numpy", "question_id": 23528}
{"snippet": "numpy.compress(condition, a, axis=None, out=None)", "intent": "Return selected slices of an array along given `axis` . When working along `a` given axis , a slice along that axis is returned in output for each index where `condition` evaluates to True . With arguments `out`. numpy", "question_id": 23529}
{"snippet": "core.defchararray.array(obj)", "intent": "Create a chararray . With arguments `obj`. numpy", "question_id": 23530}
{"snippet": "core.defchararray.array(obj, itemsize=None)", "intent": "Create a chararray . With arguments `obj`, `itemsize`. numpy", "question_id": 23531}
{"snippet": "core.defchararray.array(obj, copy=True)", "intent": "Create a chararray . With arguments `obj`, `copy`. numpy", "question_id": 23532}
{"snippet": "core.defchararray.array(obj, unicode=None)", "intent": "Create a chararray . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`. numpy", "question_id": 23533}
{"snippet": "core.defchararray.array(obj, order=None)", "intent": "Create a chararray . With arguments `obj`, `order`. numpy", "question_id": 23534}
{"snippet": "core.defchararray.array(obj, itemsize=None, copy=True)", "intent": "Create a chararray . With arguments `obj`, `itemsize`, `copy`. numpy", "question_id": 23535}
{"snippet": "core.defchararray.array(obj, itemsize=None, unicode=None)", "intent": "Create a chararray . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`, `itemsize`. numpy", "question_id": 23536}
{"snippet": "core.defchararray.array(obj, itemsize=None, order=None)", "intent": "Create a chararray . With arguments `obj`, `itemsize`, `order`. numpy", "question_id": 23537}
{"snippet": "core.defchararray.array(obj, copy=True, unicode=None)", "intent": "Create a chararray . Versus a regular NumPy array of type str or `unicode` , this class adds the following functionality : With arguments `obj`, `copy`. numpy", "question_id": 23538}
{"snippet": "core.defchararray.array(obj, copy=True, order=None)", "intent": "Create a chararray . With arguments `obj`, `copy`, `order`. numpy", "question_id": 23539}
{"snippet": "ndarray.getfield(dtype)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements . numpy", "question_id": 23540}
{"snippet": "ndarray.getfield(dtype, offset=0)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements . The values in the view are determined by the given type and the `offset` into the current array in bytes . numpy", "question_id": 23541}
{"snippet": "polynomial.hermite_e.HermiteE.deriv()", "intent": "Differentiate . numpy", "question_id": 23542}
{"snippet": "polynomial.hermite_e.HermiteE.deriv(m=1)", "intent": "Differentiate . With arguments `m`. numpy", "question_id": 23543}
{"snippet": "recarray.argpartition(kth)", "intent": "Returns the indices that would partition this array . With arguments `kth`. numpy", "question_id": 23544}
{"snippet": "recarray.argpartition(kth, axis=- 1)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`. numpy", "question_id": 23545}
{"snippet": "recarray.argpartition(kth, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`. numpy", "question_id": 23546}
{"snippet": "recarray.argpartition(kth, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `order`. numpy", "question_id": 23547}
{"snippet": "recarray.argpartition(kth, axis=- 1, kind='introselect')", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`. numpy", "question_id": 23548}
{"snippet": "recarray.argpartition(kth, axis=- 1, order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `order`. numpy", "question_id": 23549}
{"snippet": "recarray.argpartition(kth, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `kind`, `order`. numpy", "question_id": 23550}
{"snippet": "recarray.argpartition(kth, axis=- 1, kind='introselect', order=None)", "intent": "Returns the indices that would partition this array . With arguments `kth`, `axis`, `kind`, `order`. numpy", "question_id": 23551}
{"snippet": "char.count(a, sub)", "intent": "Returns an array with the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] . With arguments `a`. numpy", "question_id": 23552}
{"snippet": "char.count(a, sub, start=0)", "intent": "Returns an array with the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] . With arguments `a`. numpy", "question_id": 23553}
{"snippet": "char.count(a, sub, end=None)", "intent": "Returns an array with the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] . With arguments `a`. numpy", "question_id": 23554}
{"snippet": "char.count(a, sub, start=0, end=None)", "intent": "Returns an array with the number of non-overlapping occurrences of substring `sub` in the range [ `start` , `end` ] . With arguments `a`. numpy", "question_id": 23555}
{"snippet": "chararray.itemsize", "intent": "Length of one array element in bytes. numpy", "question_id": 23556}
{"snippet": "recarray.strides", "intent": "Tuple of bytes to step in each dimension when traversing an array. numpy", "question_id": 23557}
{"snippet": "record.data", "intent": "Pointer to start of data. numpy", "question_id": 23558}
{"snippet": "ma.masked_array.nonzero()", "intent": "Return the indices of unmasked elements that are not zero . numpy", "question_id": 23559}
{"snippet": "recarray.argmin()", "intent": "Return indices of the minimum values along the given `axis` . numpy", "question_id": 23560}
{"snippet": "recarray.argmin(axis=None)", "intent": "Return indices of the minimum values along the given `axis` . numpy", "question_id": 23561}
{"snippet": "recarray.argmin(out=None)", "intent": "Return indices of the minimum values along the given `axis` . With arguments `out`. numpy", "question_id": 23562}
{"snippet": "recarray.argmin(axis=None, out=None)", "intent": "Return indices of the minimum values along the given `axis` . With arguments `out`. numpy", "question_id": 23563}
{"snippet": "polynomial.chebyshev.chebvander(x, deg)", "intent": "Pseudo-Vandermonde matrix of given degree . Returns the pseudo-Vandermonde matrix of degree `deg` and sample points `x` . numpy", "question_id": 23564}
{"snippet": "numpy.msort(a)", "intent": "Return `a` copy of an array sorted along the first axis . numpy", "question_id": 23565}
{"snippet": "ndarray.partition(kth)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . numpy", "question_id": 23566}
{"snippet": "ndarray.partition(kth, axis=- 1)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`. numpy", "question_id": 23567}
{"snippet": "ndarray.partition(kth, kind='introselect')", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `kind`. numpy", "question_id": 23568}
{"snippet": "ndarray.partition(kth, order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `order`. numpy", "question_id": 23569}
{"snippet": "ndarray.partition(kth, axis=- 1, kind='introselect')", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `kind`. numpy", "question_id": 23570}
{"snippet": "ndarray.partition(kth, axis=- 1, order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `order`. numpy", "question_id": 23571}
{"snippet": "ndarray.partition(kth, kind='introselect', order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `kind`, `order`. numpy", "question_id": 23572}
{"snippet": "ndarray.partition(kth, axis=- 1, kind='introselect', order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `kind`, `order`. numpy", "question_id": 23573}
{"snippet": "record.itemset()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 23574}
{"snippet": "polynomial.chebyshev.chebder(c)", "intent": "Differentiate a Chebyshev series . Returns the Chebyshev series coefficients `c` differentiated `m` times along `axis` . numpy", "question_id": 23575}
{"snippet": "polynomial.chebyshev.chebder(c, m=1)", "intent": "Differentiate a Chebyshev series . Returns the Chebyshev series coefficients `c` differentiated `m` times along `axis` . numpy", "question_id": 23576}
{"snippet": "polynomial.chebyshev.chebder(c, scl=1)", "intent": "Differentiate a Chebyshev series . Returns the Chebyshev series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) . numpy", "question_id": 23577}
{"snippet": "polynomial.chebyshev.chebder(c, axis=0)", "intent": "Differentiate a Chebyshev series . Returns the Chebyshev series coefficients `c` differentiated `m` times along `axis` . numpy", "question_id": 23578}
{"snippet": "polynomial.chebyshev.chebder(c, m=1, scl=1)", "intent": "Differentiate a Chebyshev series . Returns the Chebyshev series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) . numpy", "question_id": 23579}
{"snippet": "polynomial.chebyshev.chebder(c, m=1, axis=0)", "intent": "Differentiate a Chebyshev series . Returns the Chebyshev series coefficients `c` differentiated `m` times along `axis` . numpy", "question_id": 23580}
{"snippet": "polynomial.chebyshev.chebder(c, scl=1, axis=0)", "intent": "Differentiate a Chebyshev series . Returns the Chebyshev series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) . numpy", "question_id": 23581}
{"snippet": "polynomial.chebyshev.chebder(c, m=1, scl=1, axis=0)", "intent": "Differentiate a Chebyshev series . Returns the Chebyshev series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) . numpy", "question_id": 23582}
{"snippet": "random.exponential()", "intent": "Draw samples from an exponential distribution . numpy", "question_id": 23583}
{"snippet": "random.exponential(scale=1.0)", "intent": "Draw samples from an exponential distribution . \\ ( \\beta\\ ) is the `scale` parameter , which is the inverse of the rate parameter \\ ( \\lambda = 1/\\beta\\ ) . numpy", "question_id": 23584}
{"snippet": "random.exponential(size=None)", "intent": "Draw samples from an exponential distribution . It describes many common situations , such as the `size` of raindrops measured over many rainstorms [ 1 ] , or the time between page requests to Wikipedia [ 2 ] . numpy", "question_id": 23585}
{"snippet": "random.exponential(scale=1.0, size=None)", "intent": "Draw samples from an exponential distribution . \\ ( \\beta\\ ) is the `scale` parameter , which is the inverse of the rate parameter \\ ( \\lambda = 1/\\beta\\ ) . It describes many common situations , such as the `size` of raindrops measured over many rainstorms [ 1 ] , or the time between page requests to Wikipedia [ 2 ] . numpy", "question_id": 23586}
{"snippet": "matrix.view(dtype, type)", "intent": "New view of array with the same data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) Viewing array data using a different `type` and dtype : numpy", "question_id": 23587}
{"snippet": "matrix.view(dtype)", "intent": "New view of array with the same data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) numpy", "question_id": 23588}
{"snippet": "matrix.view()", "intent": "New view of array with the same data . numpy", "question_id": 23589}
{"snippet": "numpy.sort_complex(a)", "intent": "Sort `a` complex array using the real part first , then the imaginary part . numpy", "question_id": 23590}
{"snippet": "numpy.hanning(M)", "intent": "Return the Hanning window . With arguments `M`. numpy", "question_id": 23591}
{"snippet": "ma.sort(a)", "intent": "Return `a` sorted copy of the masked array . numpy", "question_id": 23592}
{"snippet": "ma.sort(a, axis=- 1)", "intent": "Return `a` sorted copy of the masked array . With arguments `axis`. numpy", "question_id": 23593}
{"snippet": "ma.sort(a, kind=None)", "intent": "Return `a` sorted copy of the masked array . With arguments `kind`. numpy", "question_id": 23594}
{"snippet": "ma.sort(a, order=None)", "intent": "Return `a` sorted copy of the masked array . With arguments `order`. numpy", "question_id": 23595}
{"snippet": "ma.sort(a, endwith=True)", "intent": "Return `a` sorted copy of the masked array . With arguments `endwith`. numpy", "question_id": 23596}
{"snippet": "ma.sort(a, fill_value=None)", "intent": "Return `a` sorted copy of the masked array . With arguments `fill_value`. numpy", "question_id": 23597}
{"snippet": "ma.sort(a, axis=- 1, kind=None)", "intent": "Return `a` sorted copy of the masked array . With arguments `axis`, `kind`. numpy", "question_id": 23598}
{"snippet": "ma.sort(a, axis=- 1, order=None)", "intent": "Return `a` sorted copy of the masked array . With arguments `axis`, `order`. numpy", "question_id": 23599}
{"snippet": "ma.sort(a, axis=- 1, endwith=True)", "intent": "Return `a` sorted copy of the masked array . With arguments `axis`, `endwith`. numpy", "question_id": 23600}
{"snippet": "ma.sort(a, axis=- 1, fill_value=None)", "intent": "Return `a` sorted copy of the masked array . With arguments `axis`, `fill_value`. numpy", "question_id": 23601}
{"snippet": "polynomial.hermite.hermgrid3d(x, y, z, c)", "intent": "Evaluate a 3-D Hermite series on the Cartesian product of `x` , `y` , and `z` . where the points ( a , b , `c` ) consist of all triples formed by taking a from x , b from y , and c from z . numpy", "question_id": 23602}
{"snippet": "ma.column_stack(*args, **kwargs)", "intent": "Stack 1-D arrays as columns into a 2-D array . With arguments `*args`, `**kwargs`. numpy", "question_id": 23603}
{"snippet": "numpy.isreal(x)", "intent": "Returns a bool array , where True if input element is real . With arguments `x`. numpy", "question_id": 23604}
{"snippet": "numpy.nanprod(a)", "intent": "Return the product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as ones . numpy", "question_id": 23605}
{"snippet": "numpy.nanprod(a, axis=None)", "intent": "Return the product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as ones . numpy", "question_id": 23606}
{"snippet": "numpy.nanprod(a, dtype=None)", "intent": "Return the product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as ones . With arguments `dtype`. numpy", "question_id": 23607}
{"snippet": "numpy.nanprod(a, out=None)", "intent": "Return the product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as ones . With arguments `out`. numpy", "question_id": 23608}
{"snippet": "numpy.nanprod(a, keepdims=<no value>)", "intent": "Return the product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as ones . With arguments `keepdims`. numpy", "question_id": 23609}
{"snippet": "numpy.nanprod(a, axis=None, dtype=None)", "intent": "Return the product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as ones . With arguments `dtype`. numpy", "question_id": 23610}
{"snippet": "numpy.nanprod(a, axis=None, out=None)", "intent": "Return the product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as ones . With arguments `out`. numpy", "question_id": 23611}
{"snippet": "numpy.nanprod(a, axis=None, keepdims=<no value>)", "intent": "Return the product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as ones . With arguments `keepdims`. numpy", "question_id": 23612}
{"snippet": "numpy.nanprod(a, dtype=None, out=None)", "intent": "Return the product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as ones . With arguments `dtype`, `out`. numpy", "question_id": 23613}
{"snippet": "numpy.nanprod(a, dtype=None, keepdims=<no value>)", "intent": "Return the product of array elements over `a` given `axis` treating Not a Numbers ( NaNs ) as ones . With arguments `dtype`, `keepdims`. numpy", "question_id": 23614}
{"snippet": "numpy.rollaxis(a, axis)", "intent": "Roll the specified `axis` backwards , until it lies in `a` given position . numpy", "question_id": 23615}
{"snippet": "numpy.rollaxis(a, axis, start=0)", "intent": "Roll the specified `axis` backwards , until it lies in `a` given position . With arguments `start`. numpy", "question_id": 23616}
{"snippet": "polynomial.laguerre.laggrid2d(x, y, c)", "intent": "Evaluate a 2-D Laguerre series on the Cartesian product of `x` and `y` . In either case , either x and y or their elements must support multiplication and addition both with themselves and with the elements of `c` . numpy", "question_id": 23617}
{"snippet": "ndarray.tofile(fid)", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . numpy", "question_id": 23618}
{"snippet": "ndarray.tofile(fid, sep='')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `sep`. numpy", "question_id": 23619}
{"snippet": "ndarray.tofile(fid, format='%s')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `format`. numpy", "question_id": 23620}
{"snippet": "ndarray.tofile(fid, sep='', format='%s')", "intent": "Write array to a file as text or binary ( default ) . When `fid` is a file object , array contents are directly written to the file , bypassing the file object \u2019 s write method . With arguments `sep`, `format`. numpy", "question_id": 23621}
{"snippet": "random.vonmises(mu, kappa)", "intent": "Draw samples from a von Mises distribution . Samples are drawn from a von Mises distribution with specified mode ( `mu` ) and dispersion ( `kappa` ) , on the interval [ -pi , pi ] . numpy", "question_id": 23622}
{"snippet": "random.vonmises(mu, kappa, size=None)", "intent": "Draw samples from a von Mises distribution . Samples are drawn from a von Mises distribution with specified mode ( `mu` ) and dispersion ( `kappa` ) , on the interval [ -pi , pi ] . With arguments `size`. numpy", "question_id": 23623}
{"snippet": "polynomial.hermite.Hermite.cutdeg(deg)", "intent": "Truncate series to the given degree . Reduce the degree of the series to `deg` by discarding the high order terms . numpy", "question_id": 23624}
{"snippet": "ma.masked_inside(x, v1, v2)", "intent": "Mask an array inside a given interval . Shortcut to masked_where , where condition is True for `x` inside the interval [ `v1` , `v2` ] ( v1 < = x < = v2 ) . numpy", "question_id": 23625}
{"snippet": "ma.masked_inside(x, v1, v2, copy=True)", "intent": "Mask an array inside a given interval . Shortcut to masked_where , where condition is True for `x` inside the interval [ `v1` , `v2` ] ( v1 < = x < = v2 ) . With arguments `copy`. numpy", "question_id": 23626}
{"snippet": "polynomial.hermite.hermgrid2d(x, y, c)", "intent": "Evaluate a 2-D Hermite series on the Cartesian product of `x` and `y` . In either case , either x and y or their elements must support multiplication and addition both with themselves and with the elements of `c` . numpy", "question_id": 23627}
{"snippet": "recarray.dot(b)", "intent": "Dot product of two arrays . With arguments `b`. numpy", "question_id": 23628}
{"snippet": "recarray.dot(b, out=None)", "intent": "Dot product of two arrays . With arguments `b`, `out`. numpy", "question_id": 23629}
{"snippet": "polynomial.hermite_e.hermesub(c1, c2)", "intent": "Subtract one Hermite series from another . Returns the difference of two Hermite series `c1` - `c2` . numpy", "question_id": 23630}
{"snippet": "distutils.ccompiler.CCompiler_object_filenames(self, source_filenames)", "intent": "Return the name of the object files for the given source files . With arguments `self`, `source_filenames`. numpy", "question_id": 23631}
{"snippet": "distutils.ccompiler.CCompiler_object_filenames(self, source_filenames, strip_dir=0)", "intent": "Return the name of the object files for the given source files . With arguments `self`, `source_filenames`, `strip_dir`. numpy", "question_id": 23632}
{"snippet": "distutils.ccompiler.CCompiler_object_filenames(self, source_filenames, output_dir='')", "intent": "Return the name of the object files for the given source files . With arguments `self`, `source_filenames`, `output_dir`. numpy", "question_id": 23633}
{"snippet": "distutils.ccompiler.CCompiler_object_filenames(self, source_filenames, strip_dir=0, output_dir='')", "intent": "Return the name of the object files for the given source files . With arguments `self`, `source_filenames`, `strip_dir`, `output_dir`. numpy", "question_id": 23634}
{"snippet": "lib.scimath.arcsin(x)", "intent": "Compute the inverse sine of `x` . numpy", "question_id": 23635}
{"snippet": "numpy.left_shift(x1, x2, /, signature, extobj)", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 23636}
{"snippet": "numpy.left_shift(x1, x2, /, signature, extobj, out=None)", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 23637}
{"snippet": "numpy.left_shift(x1, x2, /, signature, extobj, where=True)", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 23638}
{"snippet": "numpy.left_shift(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 23639}
{"snippet": "numpy.left_shift(x1, x2, /, signature, extobj, order='K')", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 23640}
{"snippet": "numpy.left_shift(x1, x2, /, signature, extobj, dtype=None)", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . Note that the `dtype` of the second argument may change the dtype of the result and can lead to unexpected results in some cases ( see Casting Rules ) : With arguments `/`, `signature`, `extobj`. numpy", "question_id": 23641}
{"snippet": "numpy.left_shift(x1, x2, /, signature, extobj, subok=True)", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 23642}
{"snippet": "numpy.left_shift(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 23643}
{"snippet": "numpy.left_shift(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 23644}
{"snippet": "numpy.left_shift(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 23645}
{"snippet": "numpy.left_shift(x1, x2, /, signature)", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`. numpy", "question_id": 23646}
{"snippet": "numpy.left_shift(x1, x2, /, signature, out=None)", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `out`. numpy", "question_id": 23647}
{"snippet": "numpy.left_shift(x1, x2, /, signature, where=True)", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `where`. numpy", "question_id": 23648}
{"snippet": "numpy.left_shift(x1, x2, /, signature, casting='same_kind')", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `casting`. numpy", "question_id": 23649}
{"snippet": "numpy.left_shift(x1, x2, /, signature, order='K')", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `order`. numpy", "question_id": 23650}
{"snippet": "numpy.left_shift(x1, x2, /, signature, dtype=None)", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . Note that the `dtype` of the second argument may change the dtype of the result and can lead to unexpected results in some cases ( see Casting Rules ) : With arguments `/`, `signature`. numpy", "question_id": 23651}
{"snippet": "numpy.left_shift(x1, x2, /, signature, subok=True)", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `subok`. numpy", "question_id": 23652}
{"snippet": "numpy.left_shift(x1, x2, /, signature, out=None, where=True)", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 23653}
{"snippet": "numpy.left_shift(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 23654}
{"snippet": "numpy.left_shift(x1, x2, /, signature, out=None, order='K')", "intent": "Shift the bits of an integer to the left . Bits are shifted to the left by appending `x2` 0s at the right of `x1` . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 23655}
{"snippet": "ndarray.compress(condition)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`. numpy", "question_id": 23656}
{"snippet": "ndarray.compress(condition, axis=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`. numpy", "question_id": 23657}
{"snippet": "ndarray.compress(condition, out=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`, `out`. numpy", "question_id": 23658}
{"snippet": "ndarray.compress(condition, axis=None, out=None)", "intent": "Return selected slices of this array along given `axis` . With arguments `condition`, `out`. numpy", "question_id": 23659}
{"snippet": "numpy.polyadd(a1, a2)", "intent": "Find the sum of two polynomials . With arguments `a1`, `a2`. numpy", "question_id": 23660}
{"snippet": "numpy.clip(a, a_min, a_max, **kwargs)", "intent": "Clip ( limit ) the values in an array . Equivalent to but faster than np.minimum ( `a_max` , np.maximum ( `a` , `a_min` ) ) . With arguments `**kwargs`. numpy", "question_id": 23661}
{"snippet": "numpy.clip(a, a_min, a_max, **kwargs, out=None)", "intent": "Clip ( limit ) the values in an array . Equivalent to but faster than np.minimum ( `a_max` , np.maximum ( `a` , `a_min` ) ) . With arguments `**kwargs`, `out`. numpy", "question_id": 23662}
{"snippet": "ma.masked_array.tostring()", "intent": "A compatibility alias for tobytes , with exactly the same behavior . numpy", "question_id": 23663}
{"snippet": "ma.masked_array.tostring(fill_value=None)", "intent": "A compatibility alias for tobytes , with exactly the same behavior . With arguments `fill_value`. numpy", "question_id": 23664}
{"snippet": "ma.masked_array.tostring(order='C')", "intent": "A compatibility alias for tobytes , with exactly the same behavior . With arguments `order`. numpy", "question_id": 23665}
{"snippet": "ma.masked_array.tostring(fill_value=None, order='C')", "intent": "A compatibility alias for tobytes , with exactly the same behavior . With arguments `fill_value`, `order`. numpy", "question_id": 23666}
{"snippet": "matrix.prod()", "intent": "Return the product of the array elements over the given `axis` . numpy", "question_id": 23667}
{"snippet": "matrix.prod(axis=None)", "intent": "Return the product of the array elements over the given `axis` . numpy", "question_id": 23668}
{"snippet": "matrix.prod(dtype=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 23669}
{"snippet": "matrix.prod(out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `out`. numpy", "question_id": 23670}
{"snippet": "matrix.prod(axis=None, dtype=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 23671}
{"snippet": "matrix.prod(axis=None, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `out`. numpy", "question_id": 23672}
{"snippet": "matrix.prod(dtype=None, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 23673}
{"snippet": "matrix.prod(axis=None, dtype=None, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 23674}
{"snippet": "matrix.itemsize", "intent": "Length of one array element in bytes. numpy", "question_id": 23675}
{"snippet": "chararray.cumprod()", "intent": "Return the cumulative product of the elements along the given `axis` . numpy", "question_id": 23676}
{"snippet": "chararray.cumprod(axis=None)", "intent": "Return the cumulative product of the elements along the given `axis` . numpy", "question_id": 23677}
{"snippet": "chararray.cumprod(dtype=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 23678}
{"snippet": "chararray.cumprod(out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `out`. numpy", "question_id": 23679}
{"snippet": "chararray.cumprod(axis=None, dtype=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 23680}
{"snippet": "chararray.cumprod(axis=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `out`. numpy", "question_id": 23681}
{"snippet": "chararray.cumprod(dtype=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 23682}
{"snippet": "chararray.cumprod(axis=None, dtype=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 23683}
{"snippet": "ma.MaskType.diagonal()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 23684}
{"snippet": "chararray.max()", "intent": "Return the maximum along a given `axis` . numpy", "question_id": 23685}
{"snippet": "chararray.max(axis=None)", "intent": "Return the maximum along a given `axis` . numpy", "question_id": 23686}
{"snippet": "chararray.max(out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`. numpy", "question_id": 23687}
{"snippet": "chararray.max(keepdims=False)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 23688}
{"snippet": "chararray.max(initial=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `initial`. numpy", "question_id": 23689}
{"snippet": "chararray.max(where=True)", "intent": "Return the maximum along a given `axis` . With arguments `where`. numpy", "question_id": 23690}
{"snippet": "chararray.max(axis=None, out=None)", "intent": "Return the maximum along a given `axis` . With arguments `out`. numpy", "question_id": 23691}
{"snippet": "chararray.max(axis=None, keepdims=False)", "intent": "Return the maximum along a given `axis` . With arguments `keepdims`. numpy", "question_id": 23692}
{"snippet": "chararray.max(axis=None, initial=<no value>)", "intent": "Return the maximum along a given `axis` . With arguments `initial`. numpy", "question_id": 23693}
{"snippet": "chararray.max(axis=None, where=True)", "intent": "Return the maximum along a given `axis` . With arguments `where`. numpy", "question_id": 23694}
{"snippet": "memmap.real", "intent": "The real part of the array. numpy", "question_id": 23695}
{"snippet": "ma.masked_array.ndim", "intent": "Number of array dimensions. numpy", "question_id": 23696}
{"snippet": "numpy.amax(a)", "intent": "Return the maximum of an array or maximum along an `axis` . Don \u2019 t use amax for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , maximum ( `a` [ 0 ] , a [ 1 ] ) is faster than amax ( a , axis=0 ) . numpy", "question_id": 23697}
{"snippet": "numpy.amax(a, axis=None)", "intent": "Return the maximum of an array or maximum along an `axis` . Don \u2019 t use amax for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , maximum ( `a` [ 0 ] , a [ 1 ] ) is faster than amax ( a , axis=0 ) . numpy", "question_id": 23698}
{"snippet": "numpy.amax(a, out=None)", "intent": "Return the maximum of an array or maximum along an `axis` . Don \u2019 t use amax for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , maximum ( `a` [ 0 ] , a [ 1 ] ) is faster than amax ( a , axis=0 ) . With arguments `out`. numpy", "question_id": 23699}
{"snippet": "numpy.amax(a, keepdims=<no value>)", "intent": "Return the maximum of an array or maximum along an `axis` . Don \u2019 t use amax for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , maximum ( `a` [ 0 ] , a [ 1 ] ) is faster than amax ( a , axis=0 ) . With arguments `keepdims`. numpy", "question_id": 23700}
{"snippet": "numpy.amax(a, initial=<no value>)", "intent": "Return the maximum of an array or maximum along an `axis` . Don \u2019 t use amax for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , maximum ( `a` [ 0 ] , a [ 1 ] ) is faster than amax ( a , axis=0 ) . You can use an `initial` value to compute the maximum of an empty slice , or to initialize it to a different value : numpy", "question_id": 23701}
{"snippet": "numpy.amax(a, where=<no value>)", "intent": "Return the maximum of an array or maximum along an `axis` . Don \u2019 t use amax for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , maximum ( `a` [ 0 ] , a [ 1 ] ) is faster than amax ( a , axis=0 ) . With arguments `where`. numpy", "question_id": 23702}
{"snippet": "numpy.amax(a, axis=None, out=None)", "intent": "Return the maximum of an array or maximum along an `axis` . Don \u2019 t use amax for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , maximum ( `a` [ 0 ] , a [ 1 ] ) is faster than amax ( a , axis=0 ) . With arguments `out`. numpy", "question_id": 23703}
{"snippet": "numpy.amax(a, axis=None, keepdims=<no value>)", "intent": "Return the maximum of an array or maximum along an `axis` . Don \u2019 t use amax for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , maximum ( `a` [ 0 ] , a [ 1 ] ) is faster than amax ( a , axis=0 ) . With arguments `keepdims`. numpy", "question_id": 23704}
{"snippet": "numpy.amax(a, axis=None, initial=<no value>)", "intent": "Return the maximum of an array or maximum along an `axis` . Don \u2019 t use amax for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , maximum ( `a` [ 0 ] , a [ 1 ] ) is faster than amax ( a , axis=0 ) . You can use an `initial` value to compute the maximum of an empty slice , or to initialize it to a different value : numpy", "question_id": 23705}
{"snippet": "numpy.amax(a, axis=None, where=<no value>)", "intent": "Return the maximum of an array or maximum along an `axis` . Don \u2019 t use amax for element-wise comparison of 2 arrays ; when a.shape [ 0 ] is 2 , maximum ( `a` [ 0 ] , a [ 1 ] ) is faster than amax ( a , axis=0 ) . With arguments `where`. numpy", "question_id": 23706}
{"snippet": "random.pareto(a)", "intent": "Draw samples from `a` Pareto II or Lomax distribution with specified shape . numpy", "question_id": 23707}
{"snippet": "random.pareto(a, size=None)", "intent": "Draw samples from `a` Pareto II or Lomax distribution with specified shape . With arguments `size`. numpy", "question_id": 23708}
{"snippet": "numpy.squeeze(a)", "intent": "Remove axes of length one from `a` . numpy", "question_id": 23709}
{"snippet": "numpy.squeeze(a, axis=None)", "intent": "Remove axes of length one from `a` . With arguments `axis`. numpy", "question_id": 23710}
{"snippet": "random.hypergeometric(ngood, nbad, nsample)", "intent": "Draw samples from a Hypergeometric distribution . Samples are drawn from a hypergeometric distribution with specified parameters , `ngood` ( ways to make a good selection ) , `nbad` ( ways to make a bad selection ) , and `nsample` ( number of items sampled , which is less than or equal to the sum ngood + nbad ) . numpy", "question_id": 23711}
{"snippet": "random.hypergeometric(ngood, nbad, nsample, size=None)", "intent": "Draw samples from a Hypergeometric distribution . Samples are drawn from a hypergeometric distribution with specified parameters , `ngood` ( ways to make a good selection ) , `nbad` ( ways to make a bad selection ) , and `nsample` ( number of items sampled , which is less than or equal to the sum ngood + nbad ) . With arguments `size`. numpy", "question_id": 23712}
{"snippet": "polynomial.polynomial.polytrim(c)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . With arguments `c`. numpy", "question_id": 23713}
{"snippet": "polynomial.polynomial.polytrim(c, tol=0)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . \u201c Small \u201d means \u201c small in absolute value \u201d and is controlled by the parameter `tol` ; \u201c trailing \u201d means highest order coefficient ( s ) , e.g. , in [ 0 , 1 , 1 , 0 , 0 ] ( which represents 0 + x + x * * 2 + 0 * x * * 3 + 0 * x * * 4 ) both the 3-rd and 4-th order coefficients would be \u201c trimmed . \u201d With arguments `c`. numpy", "question_id": 23714}
{"snippet": "numpy.promote_types(type1, type2)", "intent": "Returns the data type with the smallest size and smallest scalar kind to which both `type1` and `type2` may be safely cast . numpy", "question_id": 23715}
{"snippet": "ndarray.__imul__(value, /)", "intent": "Return self * =value . With arguments `value`, `/`. numpy", "question_id": 23716}
{"snippet": "ndarray.__ilshift__(value, /)", "intent": "Return self < < =value . With arguments `value`, `/`. numpy", "question_id": 23717}
{"snippet": "char.chararray.var()", "intent": "Returns the variance of the array elements , along given `axis` . numpy", "question_id": 23718}
{"snippet": "char.chararray.var(axis=None)", "intent": "Returns the variance of the array elements , along given `axis` . numpy", "question_id": 23719}
{"snippet": "char.chararray.var(dtype=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `dtype`. numpy", "question_id": 23720}
{"snippet": "char.chararray.var(out=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `out`. numpy", "question_id": 23721}
{"snippet": "char.chararray.var(ddof=0)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `ddof`. numpy", "question_id": 23722}
{"snippet": "char.chararray.var(keepdims=False)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `keepdims`. numpy", "question_id": 23723}
{"snippet": "char.chararray.var(where=True)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `where`. numpy", "question_id": 23724}
{"snippet": "char.chararray.var(axis=None, dtype=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `dtype`. numpy", "question_id": 23725}
{"snippet": "char.chararray.var(axis=None, out=None)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `out`. numpy", "question_id": 23726}
{"snippet": "char.chararray.var(axis=None, ddof=0)", "intent": "Returns the variance of the array elements , along given `axis` . With arguments `ddof`. numpy", "question_id": 23727}
{"snippet": "ma.MaskedArray.__rfloordiv__(other)", "intent": "Divide self into `other` , and return a new masked array . numpy", "question_id": 23728}
{"snippet": "ma.masked_array.put(indices, values)", "intent": "Set storage-indexed locations to corresponding `values` . Sets self._data.flat [ n ] = values [ n ] for each n in `indices` . numpy", "question_id": 23729}
{"snippet": "ma.masked_array.put(indices, values, mode='raise')", "intent": "Set storage-indexed locations to corresponding `values` . Sets self._data.flat [ n ] = values [ n ] for each n in `indices` . With arguments `mode`. numpy", "question_id": 23730}
{"snippet": "ma.MaskedArray.__rmul__(other)", "intent": "Multiply `other` by self , and return a new masked array . numpy", "question_id": 23731}
{"snippet": "poly1d.integ()", "intent": "Return an antiderivative ( indefinite integral ) of this polynomial . numpy", "question_id": 23732}
{"snippet": "poly1d.integ(m=1)", "intent": "Return an antiderivative ( indefinite integral ) of this polynomial . With arguments `m`. numpy", "question_id": 23733}
{"snippet": "poly1d.integ(k=0)", "intent": "Return an antiderivative ( indefinite integral ) of this polynomial . With arguments `k`. numpy", "question_id": 23734}
{"snippet": "poly1d.integ(m=1, k=0)", "intent": "Return an antiderivative ( indefinite integral ) of this polynomial . With arguments `m`, `k`. numpy", "question_id": 23735}
{"snippet": "busdaycalendar.holidays", "intent": "A copy of the holiday array indicating additional invalid days. numpy", "question_id": 23736}
{"snippet": "ma.MaskedArray.__imul__(other)", "intent": "Multiply self by `other` in-place . numpy", "question_id": 23737}
{"snippet": "char.chararray.all()", "intent": "Returns True if all elements evaluate to True . numpy", "question_id": 23738}
{"snippet": "char.chararray.all(axis=None)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`. numpy", "question_id": 23739}
{"snippet": "char.chararray.all(out=None)", "intent": "Returns True if all elements evaluate to True . With arguments `out`. numpy", "question_id": 23740}
{"snippet": "char.chararray.all(keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `keepdims`. numpy", "question_id": 23741}
{"snippet": "char.chararray.all(where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `where`. numpy", "question_id": 23742}
{"snippet": "char.chararray.all(axis=None, out=None)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `out`. numpy", "question_id": 23743}
{"snippet": "char.chararray.all(axis=None, keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `keepdims`. numpy", "question_id": 23744}
{"snippet": "char.chararray.all(axis=None, where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `where`. numpy", "question_id": 23745}
{"snippet": "char.chararray.all(out=None, keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `out`, `keepdims`. numpy", "question_id": 23746}
{"snippet": "char.chararray.all(out=None, where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `out`, `where`. numpy", "question_id": 23747}
{"snippet": "numpy.hsplit(ary, indices_or_sections)", "intent": "Split an array into multiple sub-arrays horizontally ( column-wise ) . With arguments `ary`, `indices_or_sections`. numpy", "question_id": 23748}
{"snippet": "numpy.interp(x, xp, fp)", "intent": "One-dimensional linear interpolation for monotonically increasing sample points . Returns the one-dimensional piecewise linear interpolant to a function with given discrete data points ( `xp` , `fp` ) , evaluated at `x` . numpy", "question_id": 23749}
{"snippet": "numpy.interp(x, xp, fp, left=None)", "intent": "One-dimensional linear interpolation for monotonically increasing sample points . Returns the one-dimensional piecewise linear interpolant to a function with given discrete data points ( `xp` , `fp` ) , evaluated at `x` . With arguments `left`. numpy", "question_id": 23750}
{"snippet": "numpy.interp(x, xp, fp, right=None)", "intent": "One-dimensional linear interpolation for monotonically increasing sample points . Returns the one-dimensional piecewise linear interpolant to a function with given discrete data points ( `xp` , `fp` ) , evaluated at `x` . With arguments `right`. numpy", "question_id": 23751}
{"snippet": "numpy.interp(x, xp, fp, period=None)", "intent": "One-dimensional linear interpolation for monotonically increasing sample points . Returns the one-dimensional piecewise linear interpolant to a function with given discrete data points ( `xp` , `fp` ) , evaluated at `x` . With arguments `period`. numpy", "question_id": 23752}
{"snippet": "numpy.interp(x, xp, fp, left=None, right=None)", "intent": "One-dimensional linear interpolation for monotonically increasing sample points . Returns the one-dimensional piecewise linear interpolant to a function with given discrete data points ( `xp` , `fp` ) , evaluated at `x` . With arguments `left`, `right`. numpy", "question_id": 23753}
{"snippet": "numpy.interp(x, xp, fp, left=None, period=None)", "intent": "One-dimensional linear interpolation for monotonically increasing sample points . Returns the one-dimensional piecewise linear interpolant to a function with given discrete data points ( `xp` , `fp` ) , evaluated at `x` . With arguments `left`, `period`. numpy", "question_id": 23754}
{"snippet": "numpy.interp(x, xp, fp, right=None, period=None)", "intent": "One-dimensional linear interpolation for monotonically increasing sample points . Returns the one-dimensional piecewise linear interpolant to a function with given discrete data points ( `xp` , `fp` ) , evaluated at `x` . With arguments `right`, `period`. numpy", "question_id": 23755}
{"snippet": "numpy.interp(x, xp, fp, left=None, right=None, period=None)", "intent": "One-dimensional linear interpolation for monotonically increasing sample points . Returns the one-dimensional piecewise linear interpolant to a function with given discrete data points ( `xp` , `fp` ) , evaluated at `x` . With arguments `left`, `right`, `period`. numpy", "question_id": 23756}
{"snippet": "ma.MaskType.ptp()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 23757}
{"snippet": "ma.masked_array.copy()", "intent": "Return a copy of the array . numpy", "question_id": 23758}
{"snippet": "ma.masked_array.copy(order='C')", "intent": "Return a copy of the array . The function numpy.copy is similar , but it defaults to using `order` \u2018 K \u2019 , and will not pass sub-classes through by default . numpy", "question_id": 23759}
{"snippet": "ma.MaskedArray.__add__(other)", "intent": "Add self to `other` , and return a new masked array . numpy", "question_id": 23760}
{"snippet": "ma.masked_all(shape)", "intent": "Empty masked array with all elements masked . Return an empty masked array of the given `shape` and `dtype` , where all the data are masked . numpy", "question_id": 23761}
{"snippet": "ma.masked_all(shape, dtype=<class 'float'>)", "intent": "Empty masked array with all elements masked . Return an empty masked array of the given `shape` and `dtype` , where all the data are masked . numpy", "question_id": 23762}
{"snippet": "recarray.itemsize", "intent": "Length of one array element in bytes. numpy", "question_id": 23763}
{"snippet": "random.RandomState.gamma(shape)", "intent": "Draw samples from a Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and `scale` ( sometimes designated \u201c theta \u201d ) , where both parameters are > 0 . numpy", "question_id": 23764}
{"snippet": "random.RandomState.gamma(shape, scale=1.0)", "intent": "Draw samples from a Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and `scale` ( sometimes designated \u201c theta \u201d ) , where both parameters are > 0 . numpy", "question_id": 23765}
{"snippet": "random.RandomState.gamma(shape, size=None)", "intent": "Draw samples from a Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and `scale` ( sometimes designated \u201c theta \u201d ) , where both parameters are > 0 . With arguments `size`. numpy", "question_id": 23766}
{"snippet": "random.RandomState.gamma(shape, scale=1.0, size=None)", "intent": "Draw samples from a Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and `scale` ( sometimes designated \u201c theta \u201d ) , where both parameters are > 0 . With arguments `size`. numpy", "question_id": 23767}
{"snippet": "chararray.round()", "intent": "Return a with each element rounded to the given number of `decimals` . numpy", "question_id": 23768}
{"snippet": "chararray.round(decimals=0)", "intent": "Return a with each element rounded to the given number of `decimals` . numpy", "question_id": 23769}
{"snippet": "chararray.round(out=None)", "intent": "Return a with each element rounded to the given number of `decimals` . With arguments `out`. numpy", "question_id": 23770}
{"snippet": "chararray.round(decimals=0, out=None)", "intent": "Return a with each element rounded to the given number of `decimals` . With arguments `out`. numpy", "question_id": 23771}
{"snippet": "chararray.isalpha()", "intent": "Returns true for each element if all characters in the string are alphabetic and there is at least one character , false otherwise . numpy", "question_id": 23772}
{"snippet": "chararray.center(width)", "intent": "Return a copy of self with its elements centered in a string of length `width` . numpy", "question_id": 23773}
{"snippet": "chararray.center(width, fillchar=' ')", "intent": "Return a copy of self with its elements centered in a string of length `width` . With arguments `fillchar`. numpy", "question_id": 23774}
{"snippet": "ndarray.repeat(repeats)", "intent": "Repeat elements of an array . With arguments `repeats`. numpy", "question_id": 23775}
{"snippet": "ndarray.repeat(repeats, axis=None)", "intent": "Repeat elements of an array . With arguments `repeats`, `axis`. numpy", "question_id": 23776}
{"snippet": "record.base", "intent": "base object numpy", "question_id": 23777}
{"snippet": "recarray.dump(file)", "intent": "Dump a pickle of the array to the specified `file` . numpy", "question_id": 23778}
{"snippet": "record.fill()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 23779}
{"snippet": "recarray.argsort()", "intent": "Returns the indices that would sort this array . numpy", "question_id": 23780}
{"snippet": "recarray.argsort(axis=- 1)", "intent": "Returns the indices that would sort this array . With arguments `axis`. numpy", "question_id": 23781}
{"snippet": "recarray.argsort(kind=None)", "intent": "Returns the indices that would sort this array . With arguments `kind`. numpy", "question_id": 23782}
{"snippet": "recarray.argsort(order=None)", "intent": "Returns the indices that would sort this array . With arguments `order`. numpy", "question_id": 23783}
{"snippet": "recarray.argsort(axis=- 1, kind=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `kind`. numpy", "question_id": 23784}
{"snippet": "recarray.argsort(axis=- 1, order=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `order`. numpy", "question_id": 23785}
{"snippet": "recarray.argsort(kind=None, order=None)", "intent": "Returns the indices that would sort this array . With arguments `kind`, `order`. numpy", "question_id": 23786}
{"snippet": "recarray.argsort(axis=- 1, kind=None, order=None)", "intent": "Returns the indices that would sort this array . With arguments `axis`, `kind`, `order`. numpy", "question_id": 23787}
{"snippet": "random.wald(mean, scale)", "intent": "Draw samples from a Wald , or inverse Gaussian , distribution . Some references claim that the Wald is an inverse Gaussian with `mean` equal to 1 , but this is by no means universal . As the `scale` approaches infinity , the distribution becomes more like a Gaussian . numpy", "question_id": 23788}
{"snippet": "random.wald(mean, scale, size=None)", "intent": "Draw samples from a Wald , or inverse Gaussian , distribution . Some references claim that the Wald is an inverse Gaussian with `mean` equal to 1 , but this is by no means universal . As the `scale` approaches infinity , the distribution becomes more like a Gaussian . With arguments `size`. numpy", "question_id": 23789}
{"snippet": "numpy.ravel_multi_index(multi_index, dims)", "intent": "Converts a tuple of index arrays into an array of flat indices , applying boundary modes to the multi-index . With arguments `multi_index`, `dims`. numpy", "question_id": 23790}
{"snippet": "numpy.ravel_multi_index(multi_index, dims, mode='raise')", "intent": "Converts a tuple of index arrays into an array of flat indices , applying boundary modes to the multi-index . With arguments `multi_index`, `dims`, `mode`. numpy", "question_id": 23791}
{"snippet": "numpy.ravel_multi_index(multi_index, dims, order='C')", "intent": "Converts a tuple of index arrays into an array of flat indices , applying boundary modes to the multi-index . With arguments `multi_index`, `dims`, `order`. numpy", "question_id": 23792}
{"snippet": "numpy.ravel_multi_index(multi_index, dims, mode='raise', order='C')", "intent": "Converts a tuple of index arrays into an array of flat indices , applying boundary modes to the multi-index . With arguments `multi_index`, `dims`, `mode`, `order`. numpy", "question_id": 23793}
{"snippet": "ndarray.T", "intent": "The transposed array. numpy", "question_id": 23794}
{"snippet": "random.Generator.bit_generator", "intent": "Gets the bit generator instance used by the generator numpy", "question_id": 23795}
{"snippet": "numpy.vsplit(ary, indices_or_sections)", "intent": "Split an array into multiple sub-arrays vertically ( row-wise ) . With arguments `ary`, `indices_or_sections`. numpy", "question_id": 23796}
{"snippet": "char.chararray.tolist()", "intent": "Return the array as an a.ndim-levels deep nested list of Python scalars . numpy", "question_id": 23797}
{"snippet": "chararray.byteswap()", "intent": "Swap the bytes of the array elements numpy", "question_id": 23798}
{"snippet": "chararray.byteswap(inplace=False)", "intent": "Swap the bytes of the array elements With arguments `inplace`. numpy", "question_id": 23799}
{"snippet": "record.cumsum()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 23800}
{"snippet": "memmap.resize(new_shape)", "intent": "Change shape and size of array in-place . With arguments `new_shape`. numpy", "question_id": 23801}
{"snippet": "memmap.resize(new_shape, refcheck=True)", "intent": "Change shape and size of array in-place . However , reference counts can increase in other ways so if you are sure that you have not shared the memory for this array with another Python object , then you may safely set `refcheck` to False . With arguments `new_shape`. numpy", "question_id": 23802}
{"snippet": "numpy.diag_indices(n)", "intent": "Return the indices to access the main diagonal of an array . This returns a tuple of indices that can be used to access the main diagonal of an array a with a.ndim > = 2 dimensions and shape ( `n` , n , \u2026 , n ) . numpy", "question_id": 23803}
{"snippet": "numpy.diag_indices(n, ndim=2)", "intent": "Return the indices to access the main diagonal of an array . This returns a tuple of indices that can be used to access the main diagonal of an array a with a.ndim > = 2 dimensions and shape ( `n` , n , \u2026 , n ) . With arguments `ndim`. numpy", "question_id": 23804}
{"snippet": "ma.MaskedArray.__array_wrap__(obj)", "intent": "Special hook for ufuncs . With arguments `obj`. numpy", "question_id": 23805}
{"snippet": "ma.MaskedArray.__array_wrap__(obj, context=None)", "intent": "Special hook for ufuncs . Wraps the numpy array and sets the mask according to `context` . With arguments `obj`. numpy", "question_id": 23806}
{"snippet": "numpy.cross(a, b)", "intent": "Return the cross product of two ( arrays of ) vectors . The cross product of `a` and `b` in \\ ( R^3\\ ) is a vector perpendicular to both a and b . numpy", "question_id": 23807}
{"snippet": "numpy.cross(a, b, axisa=- 1)", "intent": "Return the cross product of two ( arrays of ) vectors . The cross product of `a` and `b` in \\ ( R^3\\ ) is a vector perpendicular to both a and b . Change the vector definition of x and y using `axisa` and `axisb` . numpy", "question_id": 23808}
{"snippet": "numpy.cross(a, b, axisb=- 1)", "intent": "Return the cross product of two ( arrays of ) vectors . The cross product of `a` and `b` in \\ ( R^3\\ ) is a vector perpendicular to both a and b . Change the vector definition of x and y using `axisa` and `axisb` . numpy", "question_id": 23809}
{"snippet": "numpy.cross(a, b, axisc=- 1)", "intent": "Return the cross product of two ( arrays of ) vectors . The cross product of `a` and `b` in \\ ( R^3\\ ) is a vector perpendicular to both a and b . The orientation of c can be changed using the `axisc` keyword . numpy", "question_id": 23810}
{"snippet": "numpy.cross(a, b, axis=None)", "intent": "Return the cross product of two ( arrays of ) vectors . The cross product of `a` and `b` in \\ ( R^3\\ ) is a vector perpendicular to both a and b . If a and b are arrays of vectors , the vectors are defined by the last `axis` of a and b by default , and these axes can have dimensions 2 or 3 . numpy", "question_id": 23811}
{"snippet": "numpy.cross(a, b, axisa=- 1, axisb=- 1)", "intent": "Return the cross product of two ( arrays of ) vectors . The cross product of `a` and `b` in \\ ( R^3\\ ) is a vector perpendicular to both a and b . Change the vector definition of x and y using `axisa` and `axisb` . numpy", "question_id": 23812}
{"snippet": "numpy.cross(a, b, axisa=- 1, axisc=- 1)", "intent": "Return the cross product of two ( arrays of ) vectors . The cross product of `a` and `b` in \\ ( R^3\\ ) is a vector perpendicular to both a and b . Change the vector definition of x and y using `axisa` and `axisb` . The orientation of c can be changed using the `axisc` keyword . numpy", "question_id": 23813}
{"snippet": "numpy.cross(a, b, axisa=- 1, axis=None)", "intent": "Return the cross product of two ( arrays of ) vectors . The cross product of `a` and `b` in \\ ( R^3\\ ) is a vector perpendicular to both a and b . Change the vector definition of x and y using `axisa` and `axisb` . If a and b are arrays of vectors , the vectors are defined by the last `axis` of a and b by default , and these axes can have dimensions 2 or 3 . numpy", "question_id": 23814}
{"snippet": "numpy.cross(a, b, axisb=- 1, axisc=- 1)", "intent": "Return the cross product of two ( arrays of ) vectors . The cross product of `a` and `b` in \\ ( R^3\\ ) is a vector perpendicular to both a and b . Change the vector definition of x and y using `axisa` and `axisb` . The orientation of c can be changed using the `axisc` keyword . numpy", "question_id": 23815}
{"snippet": "numpy.cross(a, b, axisb=- 1, axis=None)", "intent": "Return the cross product of two ( arrays of ) vectors . The cross product of `a` and `b` in \\ ( R^3\\ ) is a vector perpendicular to both a and b . Change the vector definition of x and y using `axisa` and `axisb` . If a and b are arrays of vectors , the vectors are defined by the last `axis` of a and b by default , and these axes can have dimensions 2 or 3 . numpy", "question_id": 23816}
{"snippet": "polynomial.hermite_e.HermiteE.identity()", "intent": "Identity function . numpy", "question_id": 23817}
{"snippet": "polynomial.hermite_e.HermiteE.identity(domain=None)", "intent": "Identity function . With arguments `domain`. numpy", "question_id": 23818}
{"snippet": "polynomial.hermite_e.HermiteE.identity(window=None)", "intent": "Identity function . With arguments `window`. numpy", "question_id": 23819}
{"snippet": "polynomial.hermite_e.HermiteE.identity(domain=None, window=None)", "intent": "Identity function . With arguments `domain`, `window`. numpy", "question_id": 23820}
{"snippet": "char.chararray.searchsorted(v)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . numpy", "question_id": 23821}
{"snippet": "char.chararray.searchsorted(v, side='left')", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`. numpy", "question_id": 23822}
{"snippet": "char.chararray.searchsorted(v, sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `sorter`. numpy", "question_id": 23823}
{"snippet": "char.chararray.searchsorted(v, side='left', sorter=None)", "intent": "Find indices where elements of `v` should be inserted in a to maintain order . With arguments `side`, `sorter`. numpy", "question_id": 23824}
{"snippet": "ma.masked_array.flags", "intent": "Information about the memory layout of the array. numpy", "question_id": 23825}
{"snippet": "linalg.matrix_rank(M)", "intent": "Return matrix rank of array using SVD method Imagine that there is a column in `M` that is an exact ( in floating point ) linear combination of other columns in M. Computing the SVD on M will not produce a singular value exactly equal to 0 in general : any difference of the smallest SVD value from 0 will be caused by numerical imprecision in the calculation of the SVD . numpy", "question_id": 23826}
{"snippet": "linalg.matrix_rank(M, tol=None)", "intent": "Return matrix rank of array using SVD method Imagine that there is a column in `M` that is an exact ( in floating point ) linear combination of other columns in M. Computing the SVD on M will not produce a singular value exactly equal to 0 in general : any difference of the smallest SVD value from 0 will be caused by numerical imprecision in the calculation of the SVD . Rank of the array is the number of singular values of the array that are greater than `tol` . numpy", "question_id": 23827}
{"snippet": "linalg.matrix_rank(M, hermitian=False)", "intent": "Return matrix rank of array using SVD method Imagine that there is a column in `M` that is an exact ( in floating point ) linear combination of other columns in M. Computing the SVD on M will not produce a singular value exactly equal to 0 in general : any difference of the smallest SVD value from 0 will be caused by numerical imprecision in the calculation of the SVD . With arguments `hermitian`. numpy", "question_id": 23828}
{"snippet": "linalg.matrix_rank(M, tol=None, hermitian=False)", "intent": "Return matrix rank of array using SVD method Imagine that there is a column in `M` that is an exact ( in floating point ) linear combination of other columns in M. Computing the SVD on M will not produce a singular value exactly equal to 0 in general : any difference of the smallest SVD value from 0 will be caused by numerical imprecision in the calculation of the SVD . Rank of the array is the number of singular values of the array that are greater than `tol` . With arguments `hermitian`. numpy", "question_id": 23829}
{"snippet": "numpy.asfortranarray(a)", "intent": "Return an array ( ndim > = 1 ) laid out in Fortran order in memory . With arguments `a`. numpy", "question_id": 23830}
{"snippet": "numpy.asfortranarray(a, dtype=None)", "intent": "Return an array ( ndim > = 1 ) laid out in Fortran order in memory . With arguments `a`, `dtype`. numpy", "question_id": 23831}
{"snippet": "numpy.asfortranarray(a, like=None)", "intent": "Return an array ( ndim > = 1 ) laid out in Fortran order in memory . With arguments `a`, `like`. numpy", "question_id": 23832}
{"snippet": "numpy.asfortranarray(a, dtype=None, like=None)", "intent": "Return an array ( ndim > = 1 ) laid out in Fortran order in memory . With arguments `a`, `dtype`, `like`. numpy", "question_id": 23833}
{"snippet": "record.all()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 23834}
{"snippet": "lib.format.write_array(fp, array)", "intent": "Write an `array` to an NPY file , including a header . With arguments `fp`. numpy", "question_id": 23835}
{"snippet": "lib.format.write_array(fp, array, version=None)", "intent": "Write an `array` to an NPY file , including a header . With arguments `fp`, `version`. numpy", "question_id": 23836}
{"snippet": "lib.format.write_array(fp, array, allow_pickle=True)", "intent": "Write an `array` to an NPY file , including a header . With arguments `fp`, `allow_pickle`. numpy", "question_id": 23837}
{"snippet": "lib.format.write_array(fp, array, pickle_kwargs=None)", "intent": "Write an `array` to an NPY file , including a header . With arguments `fp`, `pickle_kwargs`. numpy", "question_id": 23838}
{"snippet": "lib.format.write_array(fp, array, version=None, allow_pickle=True)", "intent": "Write an `array` to an NPY file , including a header . With arguments `fp`, `version`, `allow_pickle`. numpy", "question_id": 23839}
{"snippet": "lib.format.write_array(fp, array, version=None, pickle_kwargs=None)", "intent": "Write an `array` to an NPY file , including a header . With arguments `fp`, `version`, `pickle_kwargs`. numpy", "question_id": 23840}
{"snippet": "lib.format.write_array(fp, array, allow_pickle=True, pickle_kwargs=None)", "intent": "Write an `array` to an NPY file , including a header . With arguments `fp`, `allow_pickle`, `pickle_kwargs`. numpy", "question_id": 23841}
{"snippet": "lib.format.write_array(fp, array, version=None, allow_pickle=True, pickle_kwargs=None)", "intent": "Write an `array` to an NPY file , including a header . With arguments `fp`, `version`, `allow_pickle`, `pickle_kwargs`. numpy", "question_id": 23842}
{"snippet": "ma.MaskType.argmin()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 23843}
{"snippet": "ufunc.nin", "intent": "The number of inputs. numpy", "question_id": 23844}
{"snippet": "polynomial.hermite_e.hermevander3d(x, y, z, deg)", "intent": "Pseudo-Vandermonde matrix of given degrees . Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points ( `x` , `y` , `z` ) . numpy", "question_id": 23845}
{"snippet": "chararray.isalnum()", "intent": "Returns true for each element if all characters in the string are alphanumeric and there is at least one character , false otherwise . numpy", "question_id": 23846}
{"snippet": "dtype.isbuiltin", "intent": "Integer indicating how this dtype relates to the built-in dtypes. numpy", "question_id": 23847}
{"snippet": "ma.MaskedArray.count()", "intent": "Count the non-masked elements of the array along the given `axis` . numpy", "question_id": 23848}
{"snippet": "ma.MaskedArray.count(axis=None)", "intent": "Count the non-masked elements of the array along the given `axis` . numpy", "question_id": 23849}
{"snippet": "ma.MaskedArray.count(keepdims=<no value>)", "intent": "Count the non-masked elements of the array along the given `axis` . With arguments `keepdims`. numpy", "question_id": 23850}
{"snippet": "ma.MaskedArray.count(axis=None, keepdims=<no value>)", "intent": "Count the non-masked elements of the array along the given `axis` . With arguments `keepdims`. numpy", "question_id": 23851}
{"snippet": "record.flat", "intent": "A 1-D view of the scalar. numpy", "question_id": 23852}
{"snippet": "char.chararray.take(indices)", "intent": "Return an array formed from the elements of a at the given `indices` . numpy", "question_id": 23853}
{"snippet": "char.chararray.take(indices, axis=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`. numpy", "question_id": 23854}
{"snippet": "char.chararray.take(indices, out=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `out`. numpy", "question_id": 23855}
{"snippet": "char.chararray.take(indices, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `mode`. numpy", "question_id": 23856}
{"snippet": "char.chararray.take(indices, axis=None, out=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `out`. numpy", "question_id": 23857}
{"snippet": "char.chararray.take(indices, axis=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `mode`. numpy", "question_id": 23858}
{"snippet": "char.chararray.take(indices, out=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `out`, `mode`. numpy", "question_id": 23859}
{"snippet": "char.chararray.take(indices, axis=None, out=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `out`, `mode`. numpy", "question_id": 23860}
{"snippet": "distutils.ccompiler.CCompiler_spawn(self, cmd)", "intent": "Execute a command in a sub-process . With arguments `self`, `cmd`. numpy", "question_id": 23861}
{"snippet": "distutils.ccompiler.CCompiler_spawn(self, cmd, display=None)", "intent": "Execute a command in a sub-process . With arguments `self`, `cmd`, `display`. numpy", "question_id": 23862}
{"snippet": "polynomial.legendre.legval(x, c)", "intent": "Evaluate a Legendre series at points `x` . If `c` is of length n + 1 , this function returns the value : numpy", "question_id": 23863}
{"snippet": "polynomial.legendre.legval(x, c, tensor=True)", "intent": "Evaluate a Legendre series at points `x` . If `c` is of length n + 1 , this function returns the value : If c is multidimensional , then the shape of the result depends on the value of `tensor` . numpy", "question_id": 23864}
{"snippet": "ma.masked_array.itemset(*args)", "intent": "Insert scalar into an array ( scalar is cast to array \u2019 s dtype , if possible ) With arguments `*args`. numpy", "question_id": 23865}
{"snippet": "char.chararray.repeat(repeats)", "intent": "Repeat elements of an array . With arguments `repeats`. numpy", "question_id": 23866}
{"snippet": "char.chararray.repeat(repeats, axis=None)", "intent": "Repeat elements of an array . With arguments `repeats`, `axis`. numpy", "question_id": 23867}
{"snippet": "ma.MaskedArray.sort()", "intent": "Sort the array , in-place numpy", "question_id": 23868}
{"snippet": "ma.MaskedArray.sort(axis=- 1)", "intent": "Sort the array , in-place With arguments `axis`. numpy", "question_id": 23869}
{"snippet": "ma.MaskedArray.sort(kind=None)", "intent": "Sort the array , in-place With arguments `kind`. numpy", "question_id": 23870}
{"snippet": "ma.MaskedArray.sort(order=None)", "intent": "Sort the array , in-place With arguments `order`. numpy", "question_id": 23871}
{"snippet": "ma.MaskedArray.sort(endwith=True)", "intent": "Sort the array , in-place With arguments `endwith`. numpy", "question_id": 23872}
{"snippet": "ma.MaskedArray.sort(fill_value=None)", "intent": "Sort the array , in-place With arguments `fill_value`. numpy", "question_id": 23873}
{"snippet": "ma.MaskedArray.sort(axis=- 1, kind=None)", "intent": "Sort the array , in-place With arguments `axis`, `kind`. numpy", "question_id": 23874}
{"snippet": "ma.MaskedArray.sort(axis=- 1, order=None)", "intent": "Sort the array , in-place With arguments `axis`, `order`. numpy", "question_id": 23875}
{"snippet": "ma.MaskedArray.sort(axis=- 1, endwith=True)", "intent": "Sort the array , in-place With arguments `axis`, `endwith`. numpy", "question_id": 23876}
{"snippet": "ma.MaskedArray.sort(axis=- 1, fill_value=None)", "intent": "Sort the array , in-place With arguments `axis`, `fill_value`. numpy", "question_id": 23877}
{"snippet": "char.endswith(a, suffix)", "intent": "Returns `a` boolean array which is True where the string element in a ends with `suffix` , otherwise False . numpy", "question_id": 23878}
{"snippet": "char.endswith(a, suffix, start=0)", "intent": "Returns `a` boolean array which is True where the string element in a ends with `suffix` , otherwise False . With arguments `start`. numpy", "question_id": 23879}
{"snippet": "char.endswith(a, suffix, end=None)", "intent": "Returns `a` boolean array which is True where the string element in a ends with `suffix` , otherwise False . With arguments `end`. numpy", "question_id": 23880}
{"snippet": "char.endswith(a, suffix, start=0, end=None)", "intent": "Returns `a` boolean array which is True where the string element in a ends with `suffix` , otherwise False . With arguments `start`, `end`. numpy", "question_id": 23881}
{"snippet": "ndarray.view(dtype, type)", "intent": "New view of array with the same data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) Viewing array data using a different `type` and dtype : numpy", "question_id": 23882}
{"snippet": "ndarray.view(dtype)", "intent": "New view of array with the same data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) numpy", "question_id": 23883}
{"snippet": "ndarray.view()", "intent": "New view of array with the same data . numpy", "question_id": 23884}
{"snippet": "numpy.tanh(x, /, signature, extobj)", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 23885}
{"snippet": "numpy.tanh(x, /, signature, extobj, out=None)", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 23886}
{"snippet": "numpy.tanh(x, /, signature, extobj, where=True)", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 23887}
{"snippet": "numpy.tanh(x, /, signature, extobj, casting='same_kind')", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 23888}
{"snippet": "numpy.tanh(x, /, signature, extobj, order='K')", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 23889}
{"snippet": "numpy.tanh(x, /, signature, extobj, dtype=None)", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 23890}
{"snippet": "numpy.tanh(x, /, signature, extobj, subok=True)", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 23891}
{"snippet": "numpy.tanh(x, /, signature, extobj, out=None, where=True)", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 23892}
{"snippet": "numpy.tanh(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 23893}
{"snippet": "numpy.tanh(x, /, signature, extobj, out=None, order='K')", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 23894}
{"snippet": "numpy.tanh(x, /, signature)", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . With arguments `/`, `signature`. numpy", "question_id": 23895}
{"snippet": "numpy.tanh(x, /, signature, out=None)", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`. numpy", "question_id": 23896}
{"snippet": "numpy.tanh(x, /, signature, where=True)", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . With arguments `/`, `signature`, `where`. numpy", "question_id": 23897}
{"snippet": "numpy.tanh(x, /, signature, casting='same_kind')", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . With arguments `/`, `signature`, `casting`. numpy", "question_id": 23898}
{"snippet": "numpy.tanh(x, /, signature, order='K')", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . With arguments `/`, `signature`, `order`. numpy", "question_id": 23899}
{"snippet": "numpy.tanh(x, /, signature, dtype=None)", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 23900}
{"snippet": "numpy.tanh(x, /, signature, subok=True)", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . With arguments `/`, `signature`, `subok`. numpy", "question_id": 23901}
{"snippet": "numpy.tanh(x, /, signature, out=None, where=True)", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `where`. numpy", "question_id": 23902}
{"snippet": "numpy.tanh(x, /, signature, out=None, casting='same_kind')", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `casting`. numpy", "question_id": 23903}
{"snippet": "numpy.tanh(x, /, signature, out=None, order='K')", "intent": "Compute hyperbolic tangent element-wise . Equivalent to np.sinh ( `x` ) /np.cosh ( x ) or -1j * np.tan ( 1j * x ) . If `out` is provided , the function writes the result into it , and returns a reference to out . With arguments `/`, `signature`, `order`. numpy", "question_id": 23904}
{"snippet": "polynomial.laguerre.laggauss(deg)", "intent": "Gauss-Laguerre quadrature . These sample points and weights will correctly integrate polynomials of degree \\ ( 2 * `deg` - 1\\ ) or less over the interval \\ ( [ 0 , \\inf ] \\ ) with the weight function \\ ( f ( x ) = \\exp ( -x ) \\ ) . numpy", "question_id": 23905}
{"snippet": "ma.MaskType.prod()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 23906}
{"snippet": "ufunc.reduceat(array, indices)", "intent": "Performs a ( local ) reduce with specified slices over a single `axis` . For i in range ( len ( `indices` ) ) , reduceat computes ufunc.reduce ( `array` [ indices [ i ] : indices [ i+1 ] ] ) , which becomes the i-th generalized \u201c row \u201d parallel to axis in the final result ( i.e. , in a 2-D array , for example , if axis = 0 , it becomes the i-th row , but if axis = 1 , it becomes the i-th column ) . numpy", "question_id": 23907}
{"snippet": "ufunc.reduceat(array, indices, axis=0)", "intent": "Performs a ( local ) reduce with specified slices over a single `axis` . For i in range ( len ( `indices` ) ) , reduceat computes ufunc.reduce ( `array` [ indices [ i ] : indices [ i+1 ] ] ) , which becomes the i-th generalized \u201c row \u201d parallel to axis in the final result ( i.e. , in a 2-D array , for example , if axis = 0 , it becomes the i-th row , but if axis = 1 , it becomes the i-th column ) . numpy", "question_id": 23908}
{"snippet": "ufunc.reduceat(array, indices, dtype=None)", "intent": "Performs a ( local ) reduce with specified slices over a single `axis` . For i in range ( len ( `indices` ) ) , reduceat computes ufunc.reduce ( `array` [ indices [ i ] : indices [ i+1 ] ] ) , which becomes the i-th generalized \u201c row \u201d parallel to axis in the final result ( i.e. , in a 2-D array , for example , if axis = 0 , it becomes the i-th row , but if axis = 1 , it becomes the i-th column ) . With arguments `dtype`. numpy", "question_id": 23909}
{"snippet": "ufunc.reduceat(array, indices, out=None)", "intent": "Performs a ( local ) reduce with specified slices over a single `axis` . For i in range ( len ( `indices` ) ) , reduceat computes ufunc.reduce ( `array` [ indices [ i ] : indices [ i+1 ] ] ) , which becomes the i-th generalized \u201c row \u201d parallel to axis in the final result ( i.e. , in a 2-D array , for example , if axis = 0 , it becomes the i-th row , but if axis = 1 , it becomes the i-th column ) . With arguments `out`. numpy", "question_id": 23910}
{"snippet": "ufunc.reduceat(array, indices, axis=0, dtype=None)", "intent": "Performs a ( local ) reduce with specified slices over a single `axis` . For i in range ( len ( `indices` ) ) , reduceat computes ufunc.reduce ( `array` [ indices [ i ] : indices [ i+1 ] ] ) , which becomes the i-th generalized \u201c row \u201d parallel to axis in the final result ( i.e. , in a 2-D array , for example , if axis = 0 , it becomes the i-th row , but if axis = 1 , it becomes the i-th column ) . With arguments `dtype`. numpy", "question_id": 23911}
{"snippet": "ufunc.reduceat(array, indices, axis=0, out=None)", "intent": "Performs a ( local ) reduce with specified slices over a single `axis` . For i in range ( len ( `indices` ) ) , reduceat computes ufunc.reduce ( `array` [ indices [ i ] : indices [ i+1 ] ] ) , which becomes the i-th generalized \u201c row \u201d parallel to axis in the final result ( i.e. , in a 2-D array , for example , if axis = 0 , it becomes the i-th row , but if axis = 1 , it becomes the i-th column ) . With arguments `out`. numpy", "question_id": 23912}
{"snippet": "ufunc.reduceat(array, indices, dtype=None, out=None)", "intent": "Performs a ( local ) reduce with specified slices over a single `axis` . For i in range ( len ( `indices` ) ) , reduceat computes ufunc.reduce ( `array` [ indices [ i ] : indices [ i+1 ] ] ) , which becomes the i-th generalized \u201c row \u201d parallel to axis in the final result ( i.e. , in a 2-D array , for example , if axis = 0 , it becomes the i-th row , but if axis = 1 , it becomes the i-th column ) . With arguments `dtype`, `out`. numpy", "question_id": 23913}
{"snippet": "ufunc.reduceat(array, indices, axis=0, dtype=None, out=None)", "intent": "Performs a ( local ) reduce with specified slices over a single `axis` . For i in range ( len ( `indices` ) ) , reduceat computes ufunc.reduce ( `array` [ indices [ i ] : indices [ i+1 ] ] ) , which becomes the i-th generalized \u201c row \u201d parallel to axis in the final result ( i.e. , in a 2-D array , for example , if axis = 0 , it becomes the i-th row , but if axis = 1 , it becomes the i-th column ) . With arguments `dtype`, `out`. numpy", "question_id": 23914}
{"snippet": "numpy.broadcast", "intent": "Produce an object that mimics broadcasting. numpy", "question_id": 23915}
{"snippet": "random.Generator.choice(a)", "intent": "Generates `a` random sample from a given array numpy", "question_id": 23916}
{"snippet": "random.Generator.choice(a, size=None)", "intent": "Generates `a` random sample from a given array Generate a uniform random sample from np.arange ( 5 ) of `size` 3 : numpy", "question_id": 23917}
{"snippet": "random.Generator.choice(a, replace=True)", "intent": "Generates `a` random sample from a given array With arguments `replace`. numpy", "question_id": 23918}
{"snippet": "random.Generator.choice(a, p=None)", "intent": "Generates `a` random sample from a given array Setting user-specified probabilities through `p` uses a more general but less efficient sampler than the default . numpy", "question_id": 23919}
{"snippet": "random.Generator.choice(a, axis=0)", "intent": "Generates `a` random sample from a given array Generate a uniform random sample from a 2-D array along the first `axis` ( the default ) , without replacement : numpy", "question_id": 23920}
{"snippet": "random.Generator.choice(a, shuffle=True)", "intent": "Generates `a` random sample from a given array With arguments `shuffle`. numpy", "question_id": 23921}
{"snippet": "random.Generator.choice(a, size=None, replace=True)", "intent": "Generates `a` random sample from a given array Generate a uniform random sample from np.arange ( 5 ) of `size` 3 : With arguments `replace`. numpy", "question_id": 23922}
{"snippet": "random.Generator.choice(a, size=None, p=None)", "intent": "Generates `a` random sample from a given array Generate a uniform random sample from np.arange ( 5 ) of `size` 3 : Setting user-specified probabilities through `p` uses a more general but less efficient sampler than the default . numpy", "question_id": 23923}
{"snippet": "random.Generator.choice(a, size=None, axis=0)", "intent": "Generates `a` random sample from a given array Generate a uniform random sample from np.arange ( 5 ) of `size` 3 : Generate a uniform random sample from a 2-D array along the first `axis` ( the default ) , without replacement : numpy", "question_id": 23924}
{"snippet": "random.Generator.choice(a, size=None, shuffle=True)", "intent": "Generates `a` random sample from a given array Generate a uniform random sample from np.arange ( 5 ) of `size` 3 : With arguments `shuffle`. numpy", "question_id": 23925}
{"snippet": "random.standard_gamma(shape)", "intent": "Draw samples from a standard Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and scale=1 . numpy", "question_id": 23926}
{"snippet": "random.standard_gamma(shape, size=None)", "intent": "Draw samples from a standard Gamma distribution . Samples are drawn from a Gamma distribution with specified parameters , `shape` ( sometimes designated \u201c k \u201d ) and scale=1 . With arguments `size`. numpy", "question_id": 23927}
{"snippet": "numpy.in1d(ar1, ar2)", "intent": "Test whether each element of a 1-D array is also present in a second array . Returns a boolean array the same length as `ar1` that is True where an element of ar1 is in `ar2` and False otherwise . numpy", "question_id": 23928}
{"snippet": "numpy.in1d(ar1, ar2, assume_unique=False)", "intent": "Test whether each element of a 1-D array is also present in a second array . Returns a boolean array the same length as `ar1` that is True where an element of ar1 is in `ar2` and False otherwise . With arguments `assume_unique`. numpy", "question_id": 23929}
{"snippet": "numpy.in1d(ar1, ar2, invert=False)", "intent": "Test whether each element of a 1-D array is also present in a second array . Returns a boolean array the same length as `ar1` that is True where an element of ar1 is in `ar2` and False otherwise . With arguments `invert`. numpy", "question_id": 23930}
{"snippet": "numpy.in1d(ar1, ar2, assume_unique=False, invert=False)", "intent": "Test whether each element of a 1-D array is also present in a second array . Returns a boolean array the same length as `ar1` that is True where an element of ar1 is in `ar2` and False otherwise . With arguments `assume_unique`, `invert`. numpy", "question_id": 23931}
{"snippet": "numpy.ascontiguousarray(a)", "intent": "Return `a` contiguous array ( ndim > = 1 ) in memory ( C order ) . numpy", "question_id": 23932}
{"snippet": "numpy.ascontiguousarray(a, dtype=None)", "intent": "Return `a` contiguous array ( ndim > = 1 ) in memory ( C order ) . With arguments `dtype`. numpy", "question_id": 23933}
{"snippet": "numpy.ascontiguousarray(a, like=None)", "intent": "Return `a` contiguous array ( ndim > = 1 ) in memory ( C order ) . With arguments `like`. numpy", "question_id": 23934}
{"snippet": "numpy.ascontiguousarray(a, dtype=None, like=None)", "intent": "Return `a` contiguous array ( ndim > = 1 ) in memory ( C order ) . With arguments `dtype`, `like`. numpy", "question_id": 23935}
{"snippet": "polynomial.chebyshev.chebval2d(x, y, c)", "intent": "Evaluate a 2-D Chebyshev series at points ( `x` , `y` ) . In either case , either x and y or their elements must support multiplication and addition both with themselves and with the elements of `c` . numpy", "question_id": 23936}
{"snippet": "random.RandomState.triangular(left, mode, right)", "intent": "Draw samples from the triangular distribution over the interval [ `left` , `right` ] . The triangular distribution is a continuous probability distribution with lower limit left , peak at `mode` , and upper limit right . numpy", "question_id": 23937}
{"snippet": "random.RandomState.triangular(left, mode, right, size=None)", "intent": "Draw samples from the triangular distribution over the interval [ `left` , `right` ] . The triangular distribution is a continuous probability distribution with lower limit left , peak at `mode` , and upper limit right . With arguments `size`. numpy", "question_id": 23938}
{"snippet": "ma.clip(a, a_min, a_max, **kwargs)", "intent": "Clip ( limit ) the values in an array . Equivalent to but faster than np.minimum ( `a_max` , np.maximum ( `a` , `a_min` ) ) . With arguments `**kwargs`. numpy", "question_id": 23939}
{"snippet": "ma.clip(a, a_min, a_max, **kwargs, out=None)", "intent": "Clip ( limit ) the values in an array . Equivalent to but faster than np.minimum ( `a_max` , np.maximum ( `a` , `a_min` ) ) . With arguments `**kwargs`, `out`. numpy", "question_id": 23940}
{"snippet": "polynomial.laguerre.laggrid3d(x, y, z, c)", "intent": "Evaluate a 3-D Laguerre series on the Cartesian product of `x` , `y` , and `z` . where the points ( a , b , `c` ) consist of all triples formed by taking a from x , b from y , and c from z . numpy", "question_id": 23941}
{"snippet": "ma.MaskedArray.size", "intent": "Number of elements in the array. numpy", "question_id": 23942}
{"snippet": "ma.masked_array.harden_mask()", "intent": "Force the mask to hard . numpy", "question_id": 23943}
{"snippet": "polynomial.laguerre.Laguerre.identity()", "intent": "Identity function . numpy", "question_id": 23944}
{"snippet": "polynomial.laguerre.Laguerre.identity(domain=None)", "intent": "Identity function . With arguments `domain`. numpy", "question_id": 23945}
{"snippet": "polynomial.laguerre.Laguerre.identity(window=None)", "intent": "Identity function . With arguments `window`. numpy", "question_id": 23946}
{"snippet": "polynomial.laguerre.Laguerre.identity(domain=None, window=None)", "intent": "Identity function . With arguments `domain`, `window`. numpy", "question_id": 23947}
{"snippet": "random.Generator.standard_cauchy()", "intent": "Draw samples from a standard Cauchy distribution with mode = 0 . numpy", "question_id": 23948}
{"snippet": "random.Generator.standard_cauchy(size=None)", "intent": "Draw samples from a standard Cauchy distribution with mode = 0 . With arguments `size`. numpy", "question_id": 23949}
{"snippet": "char.chararray.strides", "intent": "Tuple of bytes to step in each dimension when traversing an array. numpy", "question_id": 23950}
{"snippet": "ma.count_masked(arr)", "intent": "Count the number of masked elements along the given `axis` . With arguments `arr`. numpy", "question_id": 23951}
{"snippet": "ma.count_masked(arr, axis=None)", "intent": "Count the number of masked elements along the given `axis` . With arguments `arr`. numpy", "question_id": 23952}
{"snippet": "record.item()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 23953}
{"snippet": "char.chararray.getfield(dtype)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements . numpy", "question_id": 23954}
{"snippet": "char.chararray.getfield(dtype, offset=0)", "intent": "Returns a field of the given array as a certain type . The offset needs to be such that the view `dtype` fits in the array dtype ; for example an array of dtype complex128 has 16-byte elements . The values in the view are determined by the given type and the `offset` into the current array in bytes . numpy", "question_id": 23955}
{"snippet": "ndarray.all()", "intent": "Returns True if all elements evaluate to True . numpy", "question_id": 23956}
{"snippet": "ndarray.all(axis=None)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`. numpy", "question_id": 23957}
{"snippet": "ndarray.all(out=None)", "intent": "Returns True if all elements evaluate to True . With arguments `out`. numpy", "question_id": 23958}
{"snippet": "ndarray.all(keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `keepdims`. numpy", "question_id": 23959}
{"snippet": "ndarray.all(where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `where`. numpy", "question_id": 23960}
{"snippet": "ndarray.all(axis=None, out=None)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `out`. numpy", "question_id": 23961}
{"snippet": "ndarray.all(axis=None, keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `keepdims`. numpy", "question_id": 23962}
{"snippet": "ndarray.all(axis=None, where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `axis`, `where`. numpy", "question_id": 23963}
{"snippet": "ndarray.all(out=None, keepdims=False)", "intent": "Returns True if all elements evaluate to True . With arguments `out`, `keepdims`. numpy", "question_id": 23964}
{"snippet": "ndarray.all(out=None, where=True)", "intent": "Returns True if all elements evaluate to True . With arguments `out`, `where`. numpy", "question_id": 23965}
{"snippet": "ma.ptp(obj)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `obj`. numpy", "question_id": 23966}
{"snippet": "ma.ptp(obj, axis=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `obj`, `axis`. numpy", "question_id": 23967}
{"snippet": "ma.ptp(obj, out=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `obj`, `out`. numpy", "question_id": 23968}
{"snippet": "ma.ptp(obj, fill_value=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `obj`, `fill_value`. numpy", "question_id": 23969}
{"snippet": "ma.ptp(obj, keepdims=<no value>)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `obj`, `keepdims`. numpy", "question_id": 23970}
{"snippet": "ma.ptp(obj, axis=None, out=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `obj`, `axis`, `out`. numpy", "question_id": 23971}
{"snippet": "ma.ptp(obj, axis=None, fill_value=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `obj`, `axis`, `fill_value`. numpy", "question_id": 23972}
{"snippet": "ma.ptp(obj, axis=None, keepdims=<no value>)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `obj`, `axis`, `keepdims`. numpy", "question_id": 23973}
{"snippet": "ma.ptp(obj, out=None, fill_value=None)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `obj`, `out`, `fill_value`. numpy", "question_id": 23974}
{"snippet": "ma.ptp(obj, out=None, keepdims=<no value>)", "intent": "Return ( maximum - minimum ) along the given dimension ( i.e . With arguments `obj`, `out`, `keepdims`. numpy", "question_id": 23975}
{"snippet": "ndarray.ptp()", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . numpy", "question_id": 23976}
{"snippet": "ndarray.ptp(axis=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . numpy", "question_id": 23977}
{"snippet": "ndarray.ptp(out=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`. numpy", "question_id": 23978}
{"snippet": "ndarray.ptp(keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `keepdims`. numpy", "question_id": 23979}
{"snippet": "ndarray.ptp(axis=None, out=None)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`. numpy", "question_id": 23980}
{"snippet": "ndarray.ptp(axis=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `keepdims`. numpy", "question_id": 23981}
{"snippet": "ndarray.ptp(out=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`, `keepdims`. numpy", "question_id": 23982}
{"snippet": "ndarray.ptp(axis=None, out=None, keepdims=False)", "intent": "Peak to peak ( maximum - minimum ) value along a given `axis` . With arguments `out`, `keepdims`. numpy", "question_id": 23983}
{"snippet": "char.chararray.tostring()", "intent": "A compatibility alias for tobytes , with exactly the same behavior . numpy", "question_id": 23984}
{"snippet": "char.chararray.tostring(order='C')", "intent": "A compatibility alias for tobytes , with exactly the same behavior . With arguments `order`. numpy", "question_id": 23985}
{"snippet": "numpy.polyder(p)", "intent": "Return the derivative of the specified order of a polynomial . With arguments `p`. numpy", "question_id": 23986}
{"snippet": "numpy.polyder(p, m=1)", "intent": "Return the derivative of the specified order of a polynomial . With arguments `p`, `m`. numpy", "question_id": 23987}
{"snippet": "numpy.flip(m)", "intent": "Reverse the order of elements in an array along the given `axis` . flip ( `m` , 0 ) is equivalent to flipud ( m ) . numpy", "question_id": 23988}
{"snippet": "numpy.flip(m, axis=None)", "intent": "Reverse the order of elements in an array along the given `axis` . flip ( `m` , 0 ) is equivalent to flipud ( m ) . numpy", "question_id": 23989}
{"snippet": "chararray.swapaxes(axis1, axis2)", "intent": "Return a view of the array with `axis1` and `axis2` interchanged . numpy", "question_id": 23990}
{"snippet": "ma.MaskedArray.__ror__(value, /)", "intent": "Return value|self . With arguments `value`, `/`. numpy", "question_id": 23991}
{"snippet": "recarray.tobytes()", "intent": "Construct Python bytes containing the raw data bytes in the array . numpy", "question_id": 23992}
{"snippet": "recarray.tobytes(order='C')", "intent": "Construct Python bytes containing the raw data bytes in the array . This behavior is controlled by the `order` parameter . numpy", "question_id": 23993}
{"snippet": "numpy.identity(n)", "intent": "Return the identity array . With arguments `n`. numpy", "question_id": 23994}
{"snippet": "numpy.identity(n, dtype=None)", "intent": "Return the identity array . With arguments `n`, `dtype`. numpy", "question_id": 23995}
{"snippet": "numpy.identity(n, like=None)", "intent": "Return the identity array . With arguments `n`, `like`. numpy", "question_id": 23996}
{"snippet": "numpy.identity(n, dtype=None, like=None)", "intent": "Return the identity array . With arguments `n`, `dtype`, `like`. numpy", "question_id": 23997}
{"snippet": "char.chararray.sum()", "intent": "Return the sum of the array elements over the given `axis` . numpy", "question_id": 23998}
{"snippet": "char.chararray.sum(axis=None)", "intent": "Return the sum of the array elements over the given `axis` . numpy", "question_id": 23999}
{"snippet": "char.chararray.sum(dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 24000}
{"snippet": "char.chararray.sum(out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`. numpy", "question_id": 24001}
{"snippet": "char.chararray.sum(keepdims=False)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`. numpy", "question_id": 24002}
{"snippet": "char.chararray.sum(initial=0)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `initial`. numpy", "question_id": 24003}
{"snippet": "char.chararray.sum(where=True)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `where`. numpy", "question_id": 24004}
{"snippet": "char.chararray.sum(axis=None, dtype=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `dtype`. numpy", "question_id": 24005}
{"snippet": "char.chararray.sum(axis=None, out=None)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `out`. numpy", "question_id": 24006}
{"snippet": "char.chararray.sum(axis=None, keepdims=False)", "intent": "Return the sum of the array elements over the given `axis` . With arguments `keepdims`. numpy", "question_id": 24007}
{"snippet": "polynomial.hermite.hermvander2d(x, y, deg)", "intent": "Pseudo-Vandermonde matrix of given degrees . Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points ( `x` , `y` ) . numpy", "question_id": 24008}
{"snippet": "ndarray.__copy__()", "intent": "Used if copy.copy is called on an array . numpy", "question_id": 24009}
{"snippet": "ma.masked_array.any()", "intent": "Returns True if any of the elements of a evaluate to True . numpy", "question_id": 24010}
{"snippet": "ma.masked_array.any(axis=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`. numpy", "question_id": 24011}
{"snippet": "ma.masked_array.any(out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`. numpy", "question_id": 24012}
{"snippet": "ma.masked_array.any(keepdims=<no value>)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `keepdims`. numpy", "question_id": 24013}
{"snippet": "ma.masked_array.any(axis=None, out=None)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `out`. numpy", "question_id": 24014}
{"snippet": "ma.masked_array.any(axis=None, keepdims=<no value>)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `keepdims`. numpy", "question_id": 24015}
{"snippet": "ma.masked_array.any(out=None, keepdims=<no value>)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `out`, `keepdims`. numpy", "question_id": 24016}
{"snippet": "ma.masked_array.any(axis=None, out=None, keepdims=<no value>)", "intent": "Returns True if any of the elements of a evaluate to True . With arguments `axis`, `out`, `keepdims`. numpy", "question_id": 24017}
{"snippet": "ndarray.reshape(shape)", "intent": "Returns an array containing the same data with a new `shape` . numpy", "question_id": 24018}
{"snippet": "ndarray.reshape(shape, order='C')", "intent": "Returns an array containing the same data with a new `shape` . With arguments `order`. numpy", "question_id": 24019}
{"snippet": "chararray.split()", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string . numpy", "question_id": 24020}
{"snippet": "chararray.split(sep=None)", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string . numpy", "question_id": 24021}
{"snippet": "chararray.split(maxsplit=None)", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string . With arguments `maxsplit`. numpy", "question_id": 24022}
{"snippet": "chararray.split(sep=None, maxsplit=None)", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string . With arguments `maxsplit`. numpy", "question_id": 24023}
{"snippet": "chararray.decode()", "intent": "Calls str.decode element-wise . numpy", "question_id": 24024}
{"snippet": "chararray.decode(encoding=None)", "intent": "Calls str.decode element-wise . With arguments `encoding`. numpy", "question_id": 24025}
{"snippet": "chararray.decode(errors=None)", "intent": "Calls str.decode element-wise . With arguments `errors`. numpy", "question_id": 24026}
{"snippet": "chararray.decode(encoding=None, errors=None)", "intent": "Calls str.decode element-wise . With arguments `encoding`, `errors`. numpy", "question_id": 24027}
{"snippet": "distutils.ccompiler.CCompiler_get_version(self)", "intent": "Return compiler version , or None if compiler is not available . With arguments `self`. numpy", "question_id": 24028}
{"snippet": "distutils.ccompiler.CCompiler_get_version(self, force=False)", "intent": "Return compiler version , or None if compiler is not available . With arguments `self`, `force`. numpy", "question_id": 24029}
{"snippet": "distutils.ccompiler.CCompiler_get_version(self, ok_status=0)", "intent": "Return compiler version , or None if compiler is not available . With arguments `self`, `ok_status`. numpy", "question_id": 24030}
{"snippet": "distutils.ccompiler.CCompiler_get_version(self, force=False, ok_status=0)", "intent": "Return compiler version , or None if compiler is not available . With arguments `self`, `force`, `ok_status`. numpy", "question_id": 24031}
{"snippet": "distutils.ccompiler.CCompiler_get_version()", "intent": "Return compiler version , or None if compiler is not available . numpy", "question_id": 24032}
{"snippet": "distutils.ccompiler.CCompiler_get_version(force=False)", "intent": "Return compiler version , or None if compiler is not available . With arguments `force`. numpy", "question_id": 24033}
{"snippet": "distutils.ccompiler.CCompiler_get_version(ok_status=0)", "intent": "Return compiler version , or None if compiler is not available . With arguments `ok_status`. numpy", "question_id": 24034}
{"snippet": "distutils.ccompiler.CCompiler_get_version(force=False, ok_status=0)", "intent": "Return compiler version , or None if compiler is not available . With arguments `force`, `ok_status`. numpy", "question_id": 24035}
{"snippet": "testing.assert_raises_regex(exception_class, expected_regexp, callable, *args, **kwargs) assert_raises_regex(exception_class, expected_regexp)", "intent": "Fail unless an exception of class `exception_class` and with message that matches `expected_regexp` is thrown by `callable` when invoked with arguments args and keyword arguments kwargs . With arguments `*args`, `**kwargs) assert_raises_regex(exception_class`. numpy", "question_id": 24036}
{"snippet": "numpy.copyto(dst, src)", "intent": "Copies values from one array to another , broadcasting as necessary . With arguments `dst`, `src`. numpy", "question_id": 24037}
{"snippet": "numpy.copyto(dst, src, casting='same_kind')", "intent": "Copies values from one array to another , broadcasting as necessary . Raises a TypeError if the `casting` rule is violated , and if `where` is provided , it selects which elements to copy . With arguments `dst`, `src`. numpy", "question_id": 24038}
{"snippet": "numpy.copyto(dst, src, where=True)", "intent": "Copies values from one array to another , broadcasting as necessary . Raises a TypeError if the `casting` rule is violated , and if `where` is provided , it selects which elements to copy . With arguments `dst`, `src`. numpy", "question_id": 24039}
{"snippet": "numpy.copyto(dst, src, casting='same_kind', where=True)", "intent": "Copies values from one array to another , broadcasting as necessary . Raises a TypeError if the `casting` rule is violated , and if `where` is provided , it selects which elements to copy . With arguments `dst`, `src`. numpy", "question_id": 24040}
{"snippet": "polynomial.laguerre.lagtrim(c)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . With arguments `c`. numpy", "question_id": 24041}
{"snippet": "polynomial.laguerre.lagtrim(c, tol=0)", "intent": "Remove \u201c small \u201d \u201c trailing \u201d coefficients from a polynomial . \u201c Small \u201d means \u201c small in absolute value \u201d and is controlled by the parameter `tol` ; \u201c trailing \u201d means highest order coefficient ( s ) , e.g. , in [ 0 , 1 , 1 , 0 , 0 ] ( which represents 0 + x + x * * 2 + 0 * x * * 3 + 0 * x * * 4 ) both the 3-rd and 4-th order coefficients would be \u201c trimmed . \u201d With arguments `c`. numpy", "question_id": 24042}
{"snippet": "ma.array(data)", "intent": "An array class with possibly masked values . The `mask` can be initialized with an array of boolean values with the same shape as `data` . numpy", "question_id": 24043}
{"snippet": "ma.array(data, dtype=None)", "intent": "An array class with possibly masked values . The `mask` can be initialized with an array of boolean values with the same shape as `data` . With arguments `dtype`. numpy", "question_id": 24044}
{"snippet": "ma.array(data, copy=False)", "intent": "An array class with possibly masked values . The `mask` can be initialized with an array of boolean values with the same shape as `data` . With arguments `copy`. numpy", "question_id": 24045}
{"snippet": "ma.array(data, order=None)", "intent": "An array class with possibly masked values . The `mask` can be initialized with an array of boolean values with the same shape as `data` . With arguments `order`. numpy", "question_id": 24046}
{"snippet": "ma.array(data, mask=False)", "intent": "An array class with possibly masked values . The `mask` can be initialized with an array of boolean values with the same shape as `data` . numpy", "question_id": 24047}
{"snippet": "ma.array(data, fill_value=None)", "intent": "An array class with possibly masked values . The `mask` can be initialized with an array of boolean values with the same shape as `data` . With arguments `fill_value`. numpy", "question_id": 24048}
{"snippet": "ma.array(data, keep_mask=True)", "intent": "An array class with possibly masked values . The `mask` can be initialized with an array of boolean values with the same shape as `data` . With arguments `keep_mask`. numpy", "question_id": 24049}
{"snippet": "ma.array(data, hard_mask=False)", "intent": "An array class with possibly masked values . The `mask` can be initialized with an array of boolean values with the same shape as `data` . With arguments `hard_mask`. numpy", "question_id": 24050}
{"snippet": "ma.array(data, shrink=True)", "intent": "An array class with possibly masked values . The `mask` can be initialized with an array of boolean values with the same shape as `data` . With arguments `shrink`. numpy", "question_id": 24051}
{"snippet": "ma.array(data, subok=True)", "intent": "An array class with possibly masked values . The `mask` can be initialized with an array of boolean values with the same shape as `data` . With arguments `subok`. numpy", "question_id": 24052}
{"snippet": "polynomial.polynomial.Polynomial.mapparms()", "intent": "Return the mapping parameters . numpy", "question_id": 24053}
{"snippet": "dtype.newbyteorder(/)", "intent": "Return a new dtype with a different byte order . With arguments `/`. numpy", "question_id": 24054}
{"snippet": "dtype.newbyteorder(/, new_order='S')", "intent": "Return a new dtype with a different byte order . With arguments `/`, `new_order`. numpy", "question_id": 24055}
{"snippet": "lib.format.descr_to_dtype(descr)", "intent": "Returns a dtype based off the given description . With arguments `descr`. numpy", "question_id": 24056}
{"snippet": "numpy.log10(x, /, signature, extobj)", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 24057}
{"snippet": "numpy.log10(x, /, signature, extobj, out=None)", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 24058}
{"snippet": "numpy.log10(x, /, signature, extobj, where=True)", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 24059}
{"snippet": "numpy.log10(x, /, signature, extobj, casting='same_kind')", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 24060}
{"snippet": "numpy.log10(x, /, signature, extobj, order='K')", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 24061}
{"snippet": "numpy.log10(x, /, signature, extobj, dtype=None)", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 24062}
{"snippet": "numpy.log10(x, /, signature, extobj, subok=True)", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 24063}
{"snippet": "numpy.log10(x, /, signature, extobj, out=None, where=True)", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 24064}
{"snippet": "numpy.log10(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 24065}
{"snippet": "numpy.log10(x, /, signature, extobj, out=None, order='K')", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 24066}
{"snippet": "numpy.log10(x, /, signature)", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`. numpy", "question_id": 24067}
{"snippet": "numpy.log10(x, /, signature, out=None)", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `out`. numpy", "question_id": 24068}
{"snippet": "numpy.log10(x, /, signature, where=True)", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `where`. numpy", "question_id": 24069}
{"snippet": "numpy.log10(x, /, signature, casting='same_kind')", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `casting`. numpy", "question_id": 24070}
{"snippet": "numpy.log10(x, /, signature, order='K')", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `order`. numpy", "question_id": 24071}
{"snippet": "numpy.log10(x, /, signature, dtype=None)", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 24072}
{"snippet": "numpy.log10(x, /, signature, subok=True)", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `subok`. numpy", "question_id": 24073}
{"snippet": "numpy.log10(x, /, signature, out=None, where=True)", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 24074}
{"snippet": "numpy.log10(x, /, signature, out=None, casting='same_kind')", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 24075}
{"snippet": "numpy.log10(x, /, signature, out=None, order='K')", "intent": "Return the base 10 logarithm of the input array , element-wise . Logarithm is a multivalued function : for each `x` there is an infinite number of z such that 10 * * z = x . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 24076}
{"snippet": "polynomial.chebyshev.chebfromroots(roots)", "intent": "Generate a Chebyshev series with given `roots` . numpy", "question_id": 24077}
{"snippet": "random.Generator.triangular(left, mode, right)", "intent": "Draw samples from the triangular distribution over the interval [ `left` , `right` ] . The triangular distribution is a continuous probability distribution with lower limit left , peak at `mode` , and upper limit right . numpy", "question_id": 24078}
{"snippet": "random.Generator.triangular(left, mode, right, size=None)", "intent": "Draw samples from the triangular distribution over the interval [ `left` , `right` ] . The triangular distribution is a continuous probability distribution with lower limit left , peak at `mode` , and upper limit right . With arguments `size`. numpy", "question_id": 24079}
{"snippet": "linalg.svd(a)", "intent": "Singular Value Decomposition . When `a` is a 2D array , it is factorized as u @ np.diag ( s ) @ vh = ( u * s ) @ vh , where u and vh are 2D unitary arrays and s is a 1D array of a \u2019 s singular values . numpy", "question_id": 24080}
{"snippet": "linalg.svd(a, full_matrices=True)", "intent": "Singular Value Decomposition . When `a` is a 2D array , it is factorized as u @ np.diag ( s ) @ vh = ( u * s ) @ vh , where u and vh are 2D unitary arrays and s is a 1D array of a \u2019 s singular values . With arguments `full_matrices`. numpy", "question_id": 24081}
{"snippet": "linalg.svd(a, compute_uv=True)", "intent": "Singular Value Decomposition . When `a` is a 2D array , it is factorized as u @ np.diag ( s ) @ vh = ( u * s ) @ vh , where u and vh are 2D unitary arrays and s is a 1D array of a \u2019 s singular values . With arguments `compute_uv`. numpy", "question_id": 24082}
{"snippet": "linalg.svd(a, hermitian=False)", "intent": "Singular Value Decomposition . When `a` is a 2D array , it is factorized as u @ np.diag ( s ) @ vh = ( u * s ) @ vh , where u and vh are 2D unitary arrays and s is a 1D array of a \u2019 s singular values . With arguments `hermitian`. numpy", "question_id": 24083}
{"snippet": "linalg.svd(a, full_matrices=True, compute_uv=True)", "intent": "Singular Value Decomposition . When `a` is a 2D array , it is factorized as u @ np.diag ( s ) @ vh = ( u * s ) @ vh , where u and vh are 2D unitary arrays and s is a 1D array of a \u2019 s singular values . With arguments `full_matrices`, `compute_uv`. numpy", "question_id": 24084}
{"snippet": "linalg.svd(a, full_matrices=True, hermitian=False)", "intent": "Singular Value Decomposition . When `a` is a 2D array , it is factorized as u @ np.diag ( s ) @ vh = ( u * s ) @ vh , where u and vh are 2D unitary arrays and s is a 1D array of a \u2019 s singular values . With arguments `full_matrices`, `hermitian`. numpy", "question_id": 24085}
{"snippet": "linalg.svd(a, compute_uv=True, hermitian=False)", "intent": "Singular Value Decomposition . When `a` is a 2D array , it is factorized as u @ np.diag ( s ) @ vh = ( u * s ) @ vh , where u and vh are 2D unitary arrays and s is a 1D array of a \u2019 s singular values . With arguments `compute_uv`, `hermitian`. numpy", "question_id": 24086}
{"snippet": "linalg.svd(a, full_matrices=True, compute_uv=True, hermitian=False)", "intent": "Singular Value Decomposition . When `a` is a 2D array , it is factorized as u @ np.diag ( s ) @ vh = ( u * s ) @ vh , where u and vh are 2D unitary arrays and s is a 1D array of a \u2019 s singular values . With arguments `full_matrices`, `compute_uv`, `hermitian`. numpy", "question_id": 24087}
{"snippet": "char.expandtabs(a)", "intent": "Return `a` copy of each string element where all tab characters are replaced by one or more spaces . numpy", "question_id": 24088}
{"snippet": "char.expandtabs(a, tabsize=8)", "intent": "Return `a` copy of each string element where all tab characters are replaced by one or more spaces . Return a copy of each string element where all tab characters are replaced by one or more spaces , depending on the current column and the given `tabsize` . numpy", "question_id": 24089}
{"snippet": "numpy.polysub(a1, a2)", "intent": "Difference ( subtraction ) of two polynomials . Given two polynomials `a1` and `a2` , returns a1 - a2 . numpy", "question_id": 24090}
{"snippet": "recarray.data", "intent": "Python buffer object pointing to the start of the array\u2019s data. numpy", "question_id": 24091}
{"snippet": "random.laplace()", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . numpy", "question_id": 24092}
{"snippet": "random.laplace(loc=0.0)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `loc`. numpy", "question_id": 24093}
{"snippet": "random.laplace(scale=1.0)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . numpy", "question_id": 24094}
{"snippet": "random.laplace(size=None)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `size`. numpy", "question_id": 24095}
{"snippet": "random.laplace(loc=0.0, scale=1.0)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `loc`. numpy", "question_id": 24096}
{"snippet": "random.laplace(loc=0.0, size=None)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `loc`, `size`. numpy", "question_id": 24097}
{"snippet": "random.laplace(scale=1.0, size=None)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `size`. numpy", "question_id": 24098}
{"snippet": "random.laplace(loc=0.0, scale=1.0, size=None)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `loc`, `size`. numpy", "question_id": 24099}
{"snippet": "ndarray.__iand__(value, /)", "intent": "Return self & =value . With arguments `value`, `/`. numpy", "question_id": 24100}
{"snippet": "numpy.log2(x, /, signature, extobj)", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 24101}
{"snippet": "numpy.log2(x, /, signature, extobj, out=None)", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 24102}
{"snippet": "numpy.log2(x, /, signature, extobj, where=True)", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 24103}
{"snippet": "numpy.log2(x, /, signature, extobj, casting='same_kind')", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 24104}
{"snippet": "numpy.log2(x, /, signature, extobj, order='K')", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 24105}
{"snippet": "numpy.log2(x, /, signature, extobj, dtype=None)", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 24106}
{"snippet": "numpy.log2(x, /, signature, extobj, subok=True)", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 24107}
{"snippet": "numpy.log2(x, /, signature, extobj, out=None, where=True)", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 24108}
{"snippet": "numpy.log2(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 24109}
{"snippet": "numpy.log2(x, /, signature, extobj, out=None, order='K')", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 24110}
{"snippet": "numpy.log2(x, /, signature)", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`. numpy", "question_id": 24111}
{"snippet": "numpy.log2(x, /, signature, out=None)", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `out`. numpy", "question_id": 24112}
{"snippet": "numpy.log2(x, /, signature, where=True)", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `where`. numpy", "question_id": 24113}
{"snippet": "numpy.log2(x, /, signature, casting='same_kind')", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `casting`. numpy", "question_id": 24114}
{"snippet": "numpy.log2(x, /, signature, order='K')", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `order`. numpy", "question_id": 24115}
{"snippet": "numpy.log2(x, /, signature, dtype=None)", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 24116}
{"snippet": "numpy.log2(x, /, signature, subok=True)", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `subok`. numpy", "question_id": 24117}
{"snippet": "numpy.log2(x, /, signature, out=None, where=True)", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 24118}
{"snippet": "numpy.log2(x, /, signature, out=None, casting='same_kind')", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 24119}
{"snippet": "numpy.log2(x, /, signature, out=None, order='K')", "intent": "Base-2 logarithm of `x` . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 24120}
{"snippet": "numpy.issubsctype(arg1, arg2)", "intent": "Determine if the first argument is a subclass of the second argument . With arguments `arg1`, `arg2`. numpy", "question_id": 24121}
{"snippet": "char.rpartition(a, sep)", "intent": "Partition ( split ) each element around the right-most separator . For each element in `a` , split the element as the last occurrence of `sep` , and return 3 strings containing the part before the separator , the separator itself , and the part after the separator . numpy", "question_id": 24122}
{"snippet": "random.Generator.permuted(x)", "intent": "Randomly permute `x` along `axis` axis . numpy", "question_id": 24123}
{"snippet": "random.Generator.permuted(x, axis=None)", "intent": "Randomly permute `x` along `axis` axis . numpy", "question_id": 24124}
{"snippet": "random.Generator.permuted(x, out=None)", "intent": "Randomly permute `x` along `axis` axis . To shuffle the rows of x in-place , pass x as the `out` parameter : numpy", "question_id": 24125}
{"snippet": "random.Generator.permuted(x, axis=None, out=None)", "intent": "Randomly permute `x` along `axis` axis . To shuffle the rows of x in-place , pass x as the `out` parameter : numpy", "question_id": 24126}
{"snippet": "numpy.log(x, /, signature, extobj)", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 24127}
{"snippet": "numpy.log(x, /, signature, extobj, out=None)", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 24128}
{"snippet": "numpy.log(x, /, signature, extobj, where=True)", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 24129}
{"snippet": "numpy.log(x, /, signature, extobj, casting='same_kind')", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 24130}
{"snippet": "numpy.log(x, /, signature, extobj, order='K')", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 24131}
{"snippet": "numpy.log(x, /, signature, extobj, dtype=None)", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 24132}
{"snippet": "numpy.log(x, /, signature, extobj, subok=True)", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 24133}
{"snippet": "numpy.log(x, /, signature, extobj, out=None, where=True)", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 24134}
{"snippet": "numpy.log(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 24135}
{"snippet": "numpy.log(x, /, signature, extobj, out=None, order='K')", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 24136}
{"snippet": "numpy.log(x, /, signature)", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`. numpy", "question_id": 24137}
{"snippet": "numpy.log(x, /, signature, out=None)", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `out`. numpy", "question_id": 24138}
{"snippet": "numpy.log(x, /, signature, where=True)", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `where`. numpy", "question_id": 24139}
{"snippet": "numpy.log(x, /, signature, casting='same_kind')", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `casting`. numpy", "question_id": 24140}
{"snippet": "numpy.log(x, /, signature, order='K')", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `order`. numpy", "question_id": 24141}
{"snippet": "numpy.log(x, /, signature, dtype=None)", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 24142}
{"snippet": "numpy.log(x, /, signature, subok=True)", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `subok`. numpy", "question_id": 24143}
{"snippet": "numpy.log(x, /, signature, out=None, where=True)", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 24144}
{"snippet": "numpy.log(x, /, signature, out=None, casting='same_kind')", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 24145}
{"snippet": "numpy.log(x, /, signature, out=None, order='K')", "intent": "Natural logarithm , element-wise . The natural logarithm log is the inverse of the exponential function , so that log ( exp ( `x` ) ) = x . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 24146}
{"snippet": "polynomial.hermite_e.HermiteE.cutdeg(deg)", "intent": "Truncate series to the given degree . Reduce the degree of the series to `deg` by discarding the high order terms . numpy", "question_id": 24147}
{"snippet": "polynomial.laguerre.lagline(off, scl)", "intent": "Laguerre series whose graph is a straight line . With arguments `off`, `scl`. numpy", "question_id": 24148}
{"snippet": "linalg.inv(a)", "intent": "Compute the ( multiplicative ) inverse of `a` matrix . numpy", "question_id": 24149}
{"snippet": "ma.mr_", "intent": "Translate slice objects to concatenation along the first axis. numpy", "question_id": 24150}
{"snippet": "polynomial.chebyshev.Chebyshev.convert()", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 24151}
{"snippet": "polynomial.chebyshev.Chebyshev.convert(domain=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 24152}
{"snippet": "polynomial.chebyshev.Chebyshev.convert(kind=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 24153}
{"snippet": "polynomial.chebyshev.Chebyshev.convert(window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 24154}
{"snippet": "polynomial.chebyshev.Chebyshev.convert(domain=None, kind=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 24155}
{"snippet": "polynomial.chebyshev.Chebyshev.convert(domain=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 24156}
{"snippet": "polynomial.chebyshev.Chebyshev.convert(kind=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 24157}
{"snippet": "polynomial.chebyshev.Chebyshev.convert(domain=None, kind=None, window=None)", "intent": "Convert series to a different `kind` and/or `domain` and/or `window` . numpy", "question_id": 24158}
{"snippet": "char.chararray.expandtabs()", "intent": "Return a copy of each string element where all tab characters are replaced by one or more spaces . numpy", "question_id": 24159}
{"snippet": "char.chararray.expandtabs(tabsize=8)", "intent": "Return a copy of each string element where all tab characters are replaced by one or more spaces . With arguments `tabsize`. numpy", "question_id": 24160}
{"snippet": "ufunc.reduce(array)", "intent": "Reduces `array` \u2019 s dimension by one , by applying ufunc along one `axis` . numpy", "question_id": 24161}
{"snippet": "ufunc.reduce(array, axis=0)", "intent": "Reduces `array` \u2019 s dimension by one , by applying ufunc along one `axis` . numpy", "question_id": 24162}
{"snippet": "ufunc.reduce(array, dtype=None)", "intent": "Reduces `array` \u2019 s dimension by one , by applying ufunc along one `axis` . With arguments `dtype`. numpy", "question_id": 24163}
{"snippet": "ufunc.reduce(array, out=None)", "intent": "Reduces `array` \u2019 s dimension by one , by applying ufunc along one `axis` . With arguments `out`. numpy", "question_id": 24164}
{"snippet": "ufunc.reduce(array, keepdims=False)", "intent": "Reduces `array` \u2019 s dimension by one , by applying ufunc along one `axis` . With arguments `keepdims`. numpy", "question_id": 24165}
{"snippet": "ufunc.reduce(array, initial=<no value>)", "intent": "Reduces `array` \u2019 s dimension by one , by applying ufunc along one `axis` . You can use the `initial` keyword argument to initialize the reduction with a different value , and `where` to select specific elements to include : numpy", "question_id": 24166}
{"snippet": "ufunc.reduce(array, where=True)", "intent": "Reduces `array` \u2019 s dimension by one , by applying ufunc along one `axis` . You can use the `initial` keyword argument to initialize the reduction with a different value , and `where` to select specific elements to include : numpy", "question_id": 24167}
{"snippet": "ufunc.reduce(array, axis=0, dtype=None)", "intent": "Reduces `array` \u2019 s dimension by one , by applying ufunc along one `axis` . With arguments `dtype`. numpy", "question_id": 24168}
{"snippet": "ufunc.reduce(array, axis=0, out=None)", "intent": "Reduces `array` \u2019 s dimension by one , by applying ufunc along one `axis` . With arguments `out`. numpy", "question_id": 24169}
{"snippet": "ufunc.reduce(array, axis=0, keepdims=False)", "intent": "Reduces `array` \u2019 s dimension by one , by applying ufunc along one `axis` . With arguments `keepdims`. numpy", "question_id": 24170}
{"snippet": "ma.masked_array.filled()", "intent": "Return a copy of self , with masked values filled with a given value . numpy", "question_id": 24171}
{"snippet": "ma.masked_array.filled(fill_value=None)", "intent": "Return a copy of self , with masked values filled with a given value . With arguments `fill_value`. numpy", "question_id": 24172}
{"snippet": "numpy.greater(x1, x2, /, signature, extobj)", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 24173}
{"snippet": "numpy.greater(x1, x2, /, signature, extobj, out=None)", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 24174}
{"snippet": "numpy.greater(x1, x2, /, signature, extobj, where=True)", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 24175}
{"snippet": "numpy.greater(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 24176}
{"snippet": "numpy.greater(x1, x2, /, signature, extobj, order='K')", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 24177}
{"snippet": "numpy.greater(x1, x2, /, signature, extobj, dtype=None)", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 24178}
{"snippet": "numpy.greater(x1, x2, /, signature, extobj, subok=True)", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 24179}
{"snippet": "numpy.greater(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 24180}
{"snippet": "numpy.greater(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 24181}
{"snippet": "numpy.greater(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 24182}
{"snippet": "numpy.greater(x1, x2, /, signature)", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`. numpy", "question_id": 24183}
{"snippet": "numpy.greater(x1, x2, /, signature, out=None)", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `out`. numpy", "question_id": 24184}
{"snippet": "numpy.greater(x1, x2, /, signature, where=True)", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `where`. numpy", "question_id": 24185}
{"snippet": "numpy.greater(x1, x2, /, signature, casting='same_kind')", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `casting`. numpy", "question_id": 24186}
{"snippet": "numpy.greater(x1, x2, /, signature, order='K')", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `order`. numpy", "question_id": 24187}
{"snippet": "numpy.greater(x1, x2, /, signature, dtype=None)", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 24188}
{"snippet": "numpy.greater(x1, x2, /, signature, subok=True)", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `subok`. numpy", "question_id": 24189}
{"snippet": "numpy.greater(x1, x2, /, signature, out=None, where=True)", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 24190}
{"snippet": "numpy.greater(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 24191}
{"snippet": "numpy.greater(x1, x2, /, signature, out=None, order='K')", "intent": "Return the truth value of ( `x1` > `x2` ) element-wise . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 24192}
{"snippet": "numpy.char.chararray(shape)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . numpy", "question_id": 24193}
{"snippet": "numpy.char.chararray(shape, itemsize=1)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . With arguments `itemsize`. numpy", "question_id": 24194}
{"snippet": "numpy.char.chararray(shape, unicode=False)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . numpy", "question_id": 24195}
{"snippet": "numpy.char.chararray(shape, buffer=None)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . This constructor creates the array , using `buffer` ( with `offset` and `strides` ) if it is not None . numpy", "question_id": 24196}
{"snippet": "numpy.char.chararray(shape, offset=0)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . This constructor creates the array , using `buffer` ( with `offset` and `strides` ) if it is not None . numpy", "question_id": 24197}
{"snippet": "numpy.char.chararray(shape, strides=None)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . This constructor creates the array , using `buffer` ( with `offset` and `strides` ) if it is not None . numpy", "question_id": 24198}
{"snippet": "numpy.char.chararray(shape, order=None)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . numpy", "question_id": 24199}
{"snippet": "numpy.char.chararray(shape, itemsize=1, unicode=False)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . With arguments `itemsize`. numpy", "question_id": 24200}
{"snippet": "numpy.char.chararray(shape, itemsize=1, buffer=None)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . This constructor creates the array , using `buffer` ( with `offset` and `strides` ) if it is not None . With arguments `itemsize`. numpy", "question_id": 24201}
{"snippet": "numpy.char.chararray(shape, itemsize=1, offset=0)", "intent": "Provides a convenient view on arrays of string and `unicode` values . If buffer is None , then constructs a new array with strides in \u201c C `order` \u201d , unless both len ( `shape` ) > = 2 and order= ' F ' , in which case strides is in \u201c Fortran order \u201d . This constructor creates the array , using `buffer` ( with `offset` and `strides` ) if it is not None . With arguments `itemsize`. numpy", "question_id": 24202}
{"snippet": "chararray.resize(new_shape)", "intent": "Change shape and size of array in-place . With arguments `new_shape`. numpy", "question_id": 24203}
{"snippet": "chararray.resize(new_shape, refcheck=True)", "intent": "Change shape and size of array in-place . However , reference counts can increase in other ways so if you are sure that you have not shared the memory for this array with another Python object , then you may safely set `refcheck` to False . With arguments `new_shape`. numpy", "question_id": 24204}
{"snippet": "recarray.dtype", "intent": "Data-type of the array\u2019s elements. numpy", "question_id": 24205}
{"snippet": "lib.scimath.log(x)", "intent": "Compute the natural logarithm of `x` . numpy", "question_id": 24206}
{"snippet": "ndarray.squeeze()", "intent": "Remove axes of length one from a . numpy", "question_id": 24207}
{"snippet": "ndarray.squeeze(axis=None)", "intent": "Remove axes of length one from a . With arguments `axis`. numpy", "question_id": 24208}
{"snippet": "polynomial.polynomial.polyfromroots(roots)", "intent": "Generate a monic polynomial with given `roots` . numpy", "question_id": 24209}
{"snippet": "lib.scimath.power(x, p)", "intent": "Return `x` to the power `p` , ( x * * p ) . numpy", "question_id": 24210}
{"snippet": "polynomial.hermite_e.HermiteE.mapparms()", "intent": "Return the mapping parameters . numpy", "question_id": 24211}
{"snippet": "polynomial.hermite.Hermite.fit(x, y, deg)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`. numpy", "question_id": 24212}
{"snippet": "polynomial.hermite.Hermite.fit(x, y, deg, domain=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`. numpy", "question_id": 24213}
{"snippet": "polynomial.hermite.Hermite.fit(x, y, deg, rcond=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `rcond`. numpy", "question_id": 24214}
{"snippet": "polynomial.hermite.Hermite.fit(x, y, deg, full=False)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `full`. numpy", "question_id": 24215}
{"snippet": "polynomial.hermite.Hermite.fit(x, y, deg, w=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `w`. numpy", "question_id": 24216}
{"snippet": "polynomial.hermite.Hermite.fit(x, y, deg, window=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . With arguments `deg`, `window`. numpy", "question_id": 24217}
{"snippet": "polynomial.hermite.Hermite.fit(x, y, deg, domain=None, rcond=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `rcond`. numpy", "question_id": 24218}
{"snippet": "polynomial.hermite.Hermite.fit(x, y, deg, domain=None, full=False)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `full`. numpy", "question_id": 24219}
{"snippet": "polynomial.hermite.Hermite.fit(x, y, deg, domain=None, w=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `w`. numpy", "question_id": 24220}
{"snippet": "polynomial.hermite.Hermite.fit(x, y, deg, domain=None, window=None)", "intent": "Least squares fit to data . Return a series instance that is the least squares fit to the data `y` sampled at `x` . The `domain` of the returned instance can be specified and this will often result in a superior fit with less chance of ill conditioning . With arguments `deg`, `window`. numpy", "question_id": 24221}
{"snippet": "char.chararray.flat", "intent": "A 1-D iterator over the array. numpy", "question_id": 24222}
{"snippet": "numpy.logical_not(x, /, signature, extobj)", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 24223}
{"snippet": "numpy.logical_not(x, /, signature, extobj, out=None)", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 24224}
{"snippet": "numpy.logical_not(x, /, signature, extobj, where=True)", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 24225}
{"snippet": "numpy.logical_not(x, /, signature, extobj, casting='same_kind')", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 24226}
{"snippet": "numpy.logical_not(x, /, signature, extobj, order='K')", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 24227}
{"snippet": "numpy.logical_not(x, /, signature, extobj, dtype=None)", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 24228}
{"snippet": "numpy.logical_not(x, /, signature, extobj, subok=True)", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 24229}
{"snippet": "numpy.logical_not(x, /, signature, extobj, out=None, where=True)", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 24230}
{"snippet": "numpy.logical_not(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 24231}
{"snippet": "numpy.logical_not(x, /, signature, extobj, out=None, order='K')", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 24232}
{"snippet": "numpy.logical_not(x, /, signature)", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`. numpy", "question_id": 24233}
{"snippet": "numpy.logical_not(x, /, signature, out=None)", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `out`. numpy", "question_id": 24234}
{"snippet": "numpy.logical_not(x, /, signature, where=True)", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `where`. numpy", "question_id": 24235}
{"snippet": "numpy.logical_not(x, /, signature, casting='same_kind')", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `casting`. numpy", "question_id": 24236}
{"snippet": "numpy.logical_not(x, /, signature, order='K')", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `order`. numpy", "question_id": 24237}
{"snippet": "numpy.logical_not(x, /, signature, dtype=None)", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 24238}
{"snippet": "numpy.logical_not(x, /, signature, subok=True)", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `subok`. numpy", "question_id": 24239}
{"snippet": "numpy.logical_not(x, /, signature, out=None, where=True)", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 24240}
{"snippet": "numpy.logical_not(x, /, signature, out=None, casting='same_kind')", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 24241}
{"snippet": "numpy.logical_not(x, /, signature, out=None, order='K')", "intent": "Compute the truth value of NOT `x` element-wise . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 24242}
{"snippet": "numpy.count_nonzero(a)", "intent": "Counts the number of non-zero values in the array `a` . numpy", "question_id": 24243}
{"snippet": "numpy.count_nonzero(a, axis=None)", "intent": "Counts the number of non-zero values in the array `a` . With arguments `axis`. numpy", "question_id": 24244}
{"snippet": "numpy.count_nonzero(a, keepdims=False)", "intent": "Counts the number of non-zero values in the array `a` . With arguments `keepdims`. numpy", "question_id": 24245}
{"snippet": "numpy.count_nonzero(a, axis=None, keepdims=False)", "intent": "Counts the number of non-zero values in the array `a` . With arguments `axis`, `keepdims`. numpy", "question_id": 24246}
{"snippet": "char.chararray.rsplit()", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string . numpy", "question_id": 24247}
{"snippet": "char.chararray.rsplit(sep=None)", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string . numpy", "question_id": 24248}
{"snippet": "char.chararray.rsplit(maxsplit=None)", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string . With arguments `maxsplit`. numpy", "question_id": 24249}
{"snippet": "char.chararray.rsplit(sep=None, maxsplit=None)", "intent": "For each element in self , return a list of the words in the string , using `sep` as the delimiter string . With arguments `maxsplit`. numpy", "question_id": 24250}
{"snippet": "linalg.multi_dot(arrays)", "intent": "Compute the dot product of two or more `arrays` in a single function call , while automatically selecting the fastest evaluation order . numpy", "question_id": 24251}
{"snippet": "linalg.multi_dot(arrays, out=None)", "intent": "Compute the dot product of two or more `arrays` in a single function call , while automatically selecting the fastest evaluation order . With arguments `out`. numpy", "question_id": 24252}
{"snippet": "testing.Tester.bench()", "intent": "Run benchmarks for module using nose . numpy", "question_id": 24253}
{"snippet": "testing.Tester.bench(label='fast')", "intent": "Run benchmarks for module using nose . With arguments `label`. numpy", "question_id": 24254}
{"snippet": "testing.Tester.bench(verbose=1)", "intent": "Run benchmarks for module using nose . With arguments `verbose`. numpy", "question_id": 24255}
{"snippet": "testing.Tester.bench(extra_argv=None)", "intent": "Run benchmarks for module using nose . With arguments `extra_argv`. numpy", "question_id": 24256}
{"snippet": "testing.Tester.bench(label='fast', verbose=1)", "intent": "Run benchmarks for module using nose . With arguments `label`, `verbose`. numpy", "question_id": 24257}
{"snippet": "testing.Tester.bench(label='fast', extra_argv=None)", "intent": "Run benchmarks for module using nose . With arguments `label`, `extra_argv`. numpy", "question_id": 24258}
{"snippet": "testing.Tester.bench(verbose=1, extra_argv=None)", "intent": "Run benchmarks for module using nose . With arguments `verbose`, `extra_argv`. numpy", "question_id": 24259}
{"snippet": "testing.Tester.bench(label='fast', verbose=1, extra_argv=None)", "intent": "Run benchmarks for module using nose . With arguments `label`, `verbose`, `extra_argv`. numpy", "question_id": 24260}
{"snippet": "matrix.round()", "intent": "Return a with each element rounded to the given number of `decimals` . numpy", "question_id": 24261}
{"snippet": "matrix.round(decimals=0)", "intent": "Return a with each element rounded to the given number of `decimals` . numpy", "question_id": 24262}
{"snippet": "matrix.round(out=None)", "intent": "Return a with each element rounded to the given number of `decimals` . With arguments `out`. numpy", "question_id": 24263}
{"snippet": "matrix.round(decimals=0, out=None)", "intent": "Return a with each element rounded to the given number of `decimals` . With arguments `out`. numpy", "question_id": 24264}
{"snippet": "ma.MaskType.argsort()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 24265}
{"snippet": "numpy.cbrt(x, /, signature, extobj)", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`. numpy", "question_id": 24266}
{"snippet": "numpy.cbrt(x, /, signature, extobj, out=None)", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`. numpy", "question_id": 24267}
{"snippet": "numpy.cbrt(x, /, signature, extobj, where=True)", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `where`. numpy", "question_id": 24268}
{"snippet": "numpy.cbrt(x, /, signature, extobj, casting='same_kind')", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 24269}
{"snippet": "numpy.cbrt(x, /, signature, extobj, order='K')", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `order`. numpy", "question_id": 24270}
{"snippet": "numpy.cbrt(x, /, signature, extobj, dtype=None)", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 24271}
{"snippet": "numpy.cbrt(x, /, signature, extobj, subok=True)", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 24272}
{"snippet": "numpy.cbrt(x, /, signature, extobj, out=None, where=True)", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 24273}
{"snippet": "numpy.cbrt(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 24274}
{"snippet": "numpy.cbrt(x, /, signature, extobj, out=None, order='K')", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 24275}
{"snippet": "numpy.cbrt(x, /, signature)", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`. numpy", "question_id": 24276}
{"snippet": "numpy.cbrt(x, /, signature, out=None)", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `out`. numpy", "question_id": 24277}
{"snippet": "numpy.cbrt(x, /, signature, where=True)", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `where`. numpy", "question_id": 24278}
{"snippet": "numpy.cbrt(x, /, signature, casting='same_kind')", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `casting`. numpy", "question_id": 24279}
{"snippet": "numpy.cbrt(x, /, signature, order='K')", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `order`. numpy", "question_id": 24280}
{"snippet": "numpy.cbrt(x, /, signature, dtype=None)", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `dtype`. numpy", "question_id": 24281}
{"snippet": "numpy.cbrt(x, /, signature, subok=True)", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `subok`. numpy", "question_id": 24282}
{"snippet": "numpy.cbrt(x, /, signature, out=None, where=True)", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `out`, `where`. numpy", "question_id": 24283}
{"snippet": "numpy.cbrt(x, /, signature, out=None, casting='same_kind')", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `out`, `casting`. numpy", "question_id": 24284}
{"snippet": "numpy.cbrt(x, /, signature, out=None, order='K')", "intent": "Return the cube-root of an array , element-wise . With arguments `x`, `/`, `signature`, `out`, `order`. numpy", "question_id": 24285}
{"snippet": "random.Generator.chisquare(df)", "intent": "Draw samples from a chi-square distribution . When `df` independent random variables , each with standard normal distributions ( mean 0 , variance 1 ) , are squared and summed , the resulting distribution is chi-square ( see Notes ) . numpy", "question_id": 24286}
{"snippet": "random.Generator.chisquare(df, size=None)", "intent": "Draw samples from a chi-square distribution . When `df` independent random variables , each with standard normal distributions ( mean 0 , variance 1 ) , are squared and summed , the resulting distribution is chi-square ( see Notes ) . With arguments `size`. numpy", "question_id": 24287}
{"snippet": "recarray.cumsum()", "intent": "Return the cumulative sum of the elements along the given `axis` . numpy", "question_id": 24288}
{"snippet": "recarray.cumsum(axis=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . numpy", "question_id": 24289}
{"snippet": "recarray.cumsum(dtype=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 24290}
{"snippet": "recarray.cumsum(out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `out`. numpy", "question_id": 24291}
{"snippet": "recarray.cumsum(axis=None, dtype=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 24292}
{"snippet": "recarray.cumsum(axis=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `out`. numpy", "question_id": 24293}
{"snippet": "recarray.cumsum(dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 24294}
{"snippet": "recarray.cumsum(axis=None, dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 24295}
{"snippet": "recarray.conj()", "intent": "Complex-conjugate all elements . numpy", "question_id": 24296}
{"snippet": "numpy.diag(v)", "intent": "Extract a diagonal or construct a diagonal array . With arguments `v`. numpy", "question_id": 24297}
{"snippet": "numpy.diag(v, k=0)", "intent": "Extract a diagonal or construct a diagonal array . With arguments `v`, `k`. numpy", "question_id": 24298}
{"snippet": "chararray.take(indices)", "intent": "Return an array formed from the elements of a at the given `indices` . numpy", "question_id": 24299}
{"snippet": "chararray.take(indices, axis=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`. numpy", "question_id": 24300}
{"snippet": "chararray.take(indices, out=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `out`. numpy", "question_id": 24301}
{"snippet": "chararray.take(indices, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `mode`. numpy", "question_id": 24302}
{"snippet": "chararray.take(indices, axis=None, out=None)", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `out`. numpy", "question_id": 24303}
{"snippet": "chararray.take(indices, axis=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `mode`. numpy", "question_id": 24304}
{"snippet": "chararray.take(indices, out=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `out`, `mode`. numpy", "question_id": 24305}
{"snippet": "chararray.take(indices, axis=None, out=None, mode='raise')", "intent": "Return an array formed from the elements of a at the given `indices` . With arguments `axis`, `out`, `mode`. numpy", "question_id": 24306}
{"snippet": "numpy.argmax(a)", "intent": "Returns the indices of the maximum values along an `axis` . Indexes of the maximal elements of `a` N-dimensional array : numpy", "question_id": 24307}
{"snippet": "numpy.argmax(a, axis=None)", "intent": "Returns the indices of the maximum values along an `axis` . Indexes of the maximal elements of `a` N-dimensional array : numpy", "question_id": 24308}
{"snippet": "numpy.argmax(a, out=None)", "intent": "Returns the indices of the maximum values along an `axis` . Indexes of the maximal elements of `a` N-dimensional array : With arguments `out`. numpy", "question_id": 24309}
{"snippet": "numpy.argmax(a, axis=None, out=None)", "intent": "Returns the indices of the maximum values along an `axis` . Indexes of the maximal elements of `a` N-dimensional array : With arguments `out`. numpy", "question_id": 24310}
{"snippet": "polynomial.hermite.Hermite.copy()", "intent": "Return a copy . numpy", "question_id": 24311}
{"snippet": "ndarray.__pow__(value, /)", "intent": "Return pow ( self , `value` , `mod` ) . With arguments `/`. numpy", "question_id": 24312}
{"snippet": "ndarray.__pow__(value, /, mod=None)", "intent": "Return pow ( self , `value` , `mod` ) . With arguments `/`. numpy", "question_id": 24313}
{"snippet": "distutils.ccompiler.CCompiler_compile(self, sources)", "intent": "Compile one or more source files . With arguments `self`, `sources`. numpy", "question_id": 24314}
{"snippet": "distutils.ccompiler.CCompiler_compile(self, sources, output_dir=None)", "intent": "Compile one or more source files . With arguments `self`, `sources`, `output_dir`. numpy", "question_id": 24315}
{"snippet": "distutils.ccompiler.CCompiler_compile(self, sources, macros=None)", "intent": "Compile one or more source files . With arguments `self`, `sources`, `macros`. numpy", "question_id": 24316}
{"snippet": "distutils.ccompiler.CCompiler_compile(self, sources, include_dirs=None)", "intent": "Compile one or more source files . With arguments `self`, `sources`, `include_dirs`. numpy", "question_id": 24317}
{"snippet": "distutils.ccompiler.CCompiler_compile(self, sources, debug=0)", "intent": "Compile one or more source files . With arguments `self`, `sources`, `debug`. numpy", "question_id": 24318}
{"snippet": "distutils.ccompiler.CCompiler_compile(self, sources, extra_preargs=None)", "intent": "Compile one or more source files . With arguments `self`, `sources`, `extra_preargs`. numpy", "question_id": 24319}
{"snippet": "distutils.ccompiler.CCompiler_compile(self, sources, extra_postargs=None)", "intent": "Compile one or more source files . With arguments `self`, `sources`, `extra_postargs`. numpy", "question_id": 24320}
{"snippet": "distutils.ccompiler.CCompiler_compile(self, sources, depends=None)", "intent": "Compile one or more source files . With arguments `self`, `sources`, `depends`. numpy", "question_id": 24321}
{"snippet": "distutils.ccompiler.CCompiler_compile(self, sources, output_dir=None, macros=None)", "intent": "Compile one or more source files . With arguments `self`, `sources`, `output_dir`, `macros`. numpy", "question_id": 24322}
{"snippet": "distutils.ccompiler.CCompiler_compile(self, sources, output_dir=None, include_dirs=None)", "intent": "Compile one or more source files . With arguments `self`, `sources`, `output_dir`, `include_dirs`. numpy", "question_id": 24323}
{"snippet": "polynomial.hermite.hermvander3d(x, y, z, deg)", "intent": "Pseudo-Vandermonde matrix of given degrees . Returns the pseudo-Vandermonde matrix of degrees `deg` and sample points ( `x` , `y` , `z` ) . numpy", "question_id": 24324}
{"snippet": "char.chararray.dump(file)", "intent": "Dump a pickle of the array to the specified `file` . numpy", "question_id": 24325}
{"snippet": "polynomial.laguerre.Laguerre.has_samedomain(other)", "intent": "Check if domains match . With arguments `other`. numpy", "question_id": 24326}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.cpu_baseline_flags()", "intent": "Returns a list of final CPU baseline compiler flags numpy", "question_id": 24327}
{"snippet": "char.chararray.ctypes", "intent": "An object to simplify the interaction of the array with the ctypes module. numpy", "question_id": 24328}
{"snippet": "_ctypes.data", "intent": "A pointer to the memory area of the array as a Python integer. numpy", "question_id": 24329}
{"snippet": "_ctypes.shape", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the C-integer corresponding to dtype('p') on this platform. numpy", "question_id": 24330}
{"snippet": "_ctypes.strides", "intent": "(c_intp*self.ndim): A ctypes array of length self.ndim where the basetype is the same as for the shape attribute. numpy", "question_id": 24331}
{"snippet": "_ctypes.data_as(obj)", "intent": "Return the data pointer cast to a particular c-types object . With arguments `obj`. numpy", "question_id": 24332}
{"snippet": "_ctypes.shape_as(obj)", "intent": "Return the shape tuple as an array of some other c-types type . With arguments `obj`. numpy", "question_id": 24333}
{"snippet": "_ctypes.strides_as(obj)", "intent": "Return the strides tuple as an array of some other c-types type . With arguments `obj`. numpy", "question_id": 24334}
{"snippet": "polynomial.polynomial.polyval3d(x, y, z, c)", "intent": "Evaluate a 3-D polynomial at points ( `x` , `y` , `z` ) . In either case , either x , y , and z or their elements must support multiplication and addition both with themselves and with the elements of `c` . numpy", "question_id": 24335}
{"snippet": "numpy.putmask(a, mask, values)", "intent": "Changes elements of an array based on conditional and input `values` . If values is not the same size as `a` and `mask` then it will repeat . numpy", "question_id": 24336}
{"snippet": "recarray.size", "intent": "Number of elements in the array. numpy", "question_id": 24337}
{"snippet": "generic.flags", "intent": "The integer value of flags. numpy", "question_id": 24338}
{"snippet": "ma.prod(self)", "intent": "Return the product of the array elements over the given `axis` . With arguments `self`. numpy", "question_id": 24339}
{"snippet": "ma.prod(self, axis=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `self`. numpy", "question_id": 24340}
{"snippet": "ma.prod(self, dtype=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `self`, `dtype`. numpy", "question_id": 24341}
{"snippet": "ma.prod(self, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `self`, `out`. numpy", "question_id": 24342}
{"snippet": "ma.prod(self, keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `self`, `keepdims`. numpy", "question_id": 24343}
{"snippet": "ma.prod(self, axis=None, dtype=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `self`, `dtype`. numpy", "question_id": 24344}
{"snippet": "ma.prod(self, axis=None, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `self`, `out`. numpy", "question_id": 24345}
{"snippet": "ma.prod(self, axis=None, keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `self`, `keepdims`. numpy", "question_id": 24346}
{"snippet": "ma.prod(self, dtype=None, out=None)", "intent": "Return the product of the array elements over the given `axis` . With arguments `self`, `dtype`, `out`. numpy", "question_id": 24347}
{"snippet": "ma.prod(self, dtype=None, keepdims=<no value>)", "intent": "Return the product of the array elements over the given `axis` . With arguments `self`, `dtype`, `keepdims`. numpy", "question_id": 24348}
{"snippet": "ma.fix_invalid(a)", "intent": "Return input with invalid data masked and replaced by `a` fill value . numpy", "question_id": 24349}
{"snippet": "ma.fix_invalid(a, mask=False)", "intent": "Return input with invalid data masked and replaced by `a` fill value . With arguments `mask`. numpy", "question_id": 24350}
{"snippet": "ma.fix_invalid(a, copy=True)", "intent": "Return input with invalid data masked and replaced by `a` fill value . A `copy` is performed by default . numpy", "question_id": 24351}
{"snippet": "ma.fix_invalid(a, fill_value=None)", "intent": "Return input with invalid data masked and replaced by `a` fill value . With arguments `fill_value`. numpy", "question_id": 24352}
{"snippet": "ma.fix_invalid(a, mask=False, copy=True)", "intent": "Return input with invalid data masked and replaced by `a` fill value . A `copy` is performed by default . With arguments `mask`. numpy", "question_id": 24353}
{"snippet": "ma.fix_invalid(a, mask=False, fill_value=None)", "intent": "Return input with invalid data masked and replaced by `a` fill value . With arguments `mask`, `fill_value`. numpy", "question_id": 24354}
{"snippet": "ma.fix_invalid(a, copy=True, fill_value=None)", "intent": "Return input with invalid data masked and replaced by `a` fill value . A `copy` is performed by default . With arguments `fill_value`. numpy", "question_id": 24355}
{"snippet": "ma.fix_invalid(a, mask=False, copy=True, fill_value=None)", "intent": "Return input with invalid data masked and replaced by `a` fill value . A `copy` is performed by default . With arguments `mask`, `fill_value`. numpy", "question_id": 24356}
{"snippet": "ma.mask_rows(a)", "intent": "Mask rows of `a` 2D array that contain masked values . numpy", "question_id": 24357}
{"snippet": "ma.mask_rows(a, axis=<no value>)", "intent": "Mask rows of `a` 2D array that contain masked values . This function is a shortcut to mask_rowcols with `axis` equal to 0 . numpy", "question_id": 24358}
{"snippet": "numpy.zeros_like(a)", "intent": "Return an array of zeros with the same `shape` and type as `a` given array . numpy", "question_id": 24359}
{"snippet": "numpy.zeros_like(a, dtype=None)", "intent": "Return an array of zeros with the same `shape` and type as `a` given array . With arguments `dtype`. numpy", "question_id": 24360}
{"snippet": "numpy.zeros_like(a, order='K')", "intent": "Return an array of zeros with the same `shape` and type as `a` given array . With arguments `order`. numpy", "question_id": 24361}
{"snippet": "numpy.zeros_like(a, subok=True)", "intent": "Return an array of zeros with the same `shape` and type as `a` given array . With arguments `subok`. numpy", "question_id": 24362}
{"snippet": "numpy.zeros_like(a, shape=None)", "intent": "Return an array of zeros with the same `shape` and type as `a` given array . numpy", "question_id": 24363}
{"snippet": "numpy.zeros_like(a, dtype=None, order='K')", "intent": "Return an array of zeros with the same `shape` and type as `a` given array . With arguments `dtype`, `order`. numpy", "question_id": 24364}
{"snippet": "numpy.zeros_like(a, dtype=None, subok=True)", "intent": "Return an array of zeros with the same `shape` and type as `a` given array . With arguments `dtype`, `subok`. numpy", "question_id": 24365}
{"snippet": "numpy.zeros_like(a, dtype=None, shape=None)", "intent": "Return an array of zeros with the same `shape` and type as `a` given array . With arguments `dtype`. numpy", "question_id": 24366}
{"snippet": "numpy.zeros_like(a, order='K', subok=True)", "intent": "Return an array of zeros with the same `shape` and type as `a` given array . With arguments `order`, `subok`. numpy", "question_id": 24367}
{"snippet": "numpy.zeros_like(a, order='K', shape=None)", "intent": "Return an array of zeros with the same `shape` and type as `a` given array . With arguments `order`. numpy", "question_id": 24368}
{"snippet": "matrix.conj()", "intent": "Complex-conjugate all elements . numpy", "question_id": 24369}
{"snippet": "matrix.setfield(val, dtype)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field . numpy", "question_id": 24370}
{"snippet": "matrix.setfield(val, dtype, offset=0)", "intent": "Put a value into a specified place in a field defined by a data-type . Place `val` into a \u2019 s field defined by `dtype` and beginning `offset` bytes into the field . numpy", "question_id": 24371}
{"snippet": "numpy.fromiter(iter, dtype)", "intent": "Create a new 1-dimensional array from an iterable object . With arguments `iter`, `dtype`. numpy", "question_id": 24372}
{"snippet": "numpy.fromiter(iter, dtype, count=- 1)", "intent": "Create a new 1-dimensional array from an iterable object . Specify `count` to improve performance . With arguments `iter`, `dtype`. numpy", "question_id": 24373}
{"snippet": "numpy.fromiter(iter, dtype, like=None)", "intent": "Create a new 1-dimensional array from an iterable object . With arguments `iter`, `dtype`, `like`. numpy", "question_id": 24374}
{"snippet": "numpy.fromiter(iter, dtype, count=- 1, like=None)", "intent": "Create a new 1-dimensional array from an iterable object . Specify `count` to improve performance . With arguments `iter`, `dtype`, `like`. numpy", "question_id": 24375}
{"snippet": "memmap.transpose(*axes)", "intent": "Returns a view of the array with axes transposed . With arguments `*axes`. numpy", "question_id": 24376}
{"snippet": "ma.MaskedArray.round()", "intent": "Return each element rounded to the given number of `decimals` . numpy", "question_id": 24377}
{"snippet": "ma.MaskedArray.round(decimals=0)", "intent": "Return each element rounded to the given number of `decimals` . numpy", "question_id": 24378}
{"snippet": "ma.MaskedArray.round(out=None)", "intent": "Return each element rounded to the given number of `decimals` . With arguments `out`. numpy", "question_id": 24379}
{"snippet": "ma.MaskedArray.round(decimals=0, out=None)", "intent": "Return each element rounded to the given number of `decimals` . With arguments `out`. numpy", "question_id": 24380}
{"snippet": "numpy.setdiff1d(ar1, ar2)", "intent": "Find the set difference of two arrays . Return the unique values in `ar1` that are not in `ar2` . numpy", "question_id": 24381}
{"snippet": "numpy.setdiff1d(ar1, ar2, assume_unique=False)", "intent": "Find the set difference of two arrays . Return the unique values in `ar1` that are not in `ar2` . With arguments `assume_unique`. numpy", "question_id": 24382}
{"snippet": "record.byteswap()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 24383}
{"snippet": "ma.MaskType.byteswap()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 24384}
{"snippet": "matrix.max()", "intent": "Return the maximum value along an `axis` . numpy", "question_id": 24385}
{"snippet": "matrix.max(axis=None)", "intent": "Return the maximum value along an `axis` . numpy", "question_id": 24386}
{"snippet": "matrix.max(out=None)", "intent": "Return the maximum value along an `axis` . With arguments `out`. numpy", "question_id": 24387}
{"snippet": "matrix.max(axis=None, out=None)", "intent": "Return the maximum value along an `axis` . With arguments `out`. numpy", "question_id": 24388}
{"snippet": "polynomial.chebyshev.Chebyshev.has_samewindow(other)", "intent": "Check if windows match . With arguments `other`. numpy", "question_id": 24389}
{"snippet": "char.chararray.flags", "intent": "Information about the memory layout of the array. numpy", "question_id": 24390}
{"snippet": "ma.MaskedArray.__itruediv__(other)", "intent": "True divide self by `other` in-place . numpy", "question_id": 24391}
{"snippet": "numpy.float_power(x1, x2, /, signature, extobj)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 24392}
{"snippet": "numpy.float_power(x1, x2, /, signature, extobj, out=None)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 24393}
{"snippet": "numpy.float_power(x1, x2, /, signature, extobj, where=True)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 24394}
{"snippet": "numpy.float_power(x1, x2, /, signature, extobj, casting='same_kind')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 24395}
{"snippet": "numpy.float_power(x1, x2, /, signature, extobj, order='K')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 24396}
{"snippet": "numpy.float_power(x1, x2, /, signature, extobj, dtype=None)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 24397}
{"snippet": "numpy.float_power(x1, x2, /, signature, extobj, subok=True)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 24398}
{"snippet": "numpy.float_power(x1, x2, /, signature, extobj, out=None, where=True)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 24399}
{"snippet": "numpy.float_power(x1, x2, /, signature, extobj, out=None, casting='same_kind')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 24400}
{"snippet": "numpy.float_power(x1, x2, /, signature, extobj, out=None, order='K')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 24401}
{"snippet": "numpy.float_power(x1, x2, /, signature)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`. numpy", "question_id": 24402}
{"snippet": "numpy.float_power(x1, x2, /, signature, out=None)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `out`. numpy", "question_id": 24403}
{"snippet": "numpy.float_power(x1, x2, /, signature, where=True)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `where`. numpy", "question_id": 24404}
{"snippet": "numpy.float_power(x1, x2, /, signature, casting='same_kind')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `casting`. numpy", "question_id": 24405}
{"snippet": "numpy.float_power(x1, x2, /, signature, order='K')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `order`. numpy", "question_id": 24406}
{"snippet": "numpy.float_power(x1, x2, /, signature, dtype=None)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 24407}
{"snippet": "numpy.float_power(x1, x2, /, signature, subok=True)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `subok`. numpy", "question_id": 24408}
{"snippet": "numpy.float_power(x1, x2, /, signature, out=None, where=True)", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 24409}
{"snippet": "numpy.float_power(x1, x2, /, signature, out=None, casting='same_kind')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 24410}
{"snippet": "numpy.float_power(x1, x2, /, signature, out=None, order='K')", "intent": "First array elements raised to powers from second array , element-wise . Raise each base in `x1` to the positionally-corresponding power in `x2` . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 24411}
{"snippet": "ma.ravel(self)", "intent": "Returns a 1D version of `self` , as a view . numpy", "question_id": 24412}
{"snippet": "ma.ravel(self, order='C')", "intent": "Returns a 1D version of `self` , as a view . With arguments `order`. numpy", "question_id": 24413}
{"snippet": "recarray.partition(kth)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . numpy", "question_id": 24414}
{"snippet": "recarray.partition(kth, axis=- 1)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`. numpy", "question_id": 24415}
{"snippet": "recarray.partition(kth, kind='introselect')", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `kind`. numpy", "question_id": 24416}
{"snippet": "recarray.partition(kth, order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `order`. numpy", "question_id": 24417}
{"snippet": "recarray.partition(kth, axis=- 1, kind='introselect')", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `kind`. numpy", "question_id": 24418}
{"snippet": "recarray.partition(kth, axis=- 1, order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `order`. numpy", "question_id": 24419}
{"snippet": "recarray.partition(kth, kind='introselect', order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `kind`, `order`. numpy", "question_id": 24420}
{"snippet": "recarray.partition(kth, axis=- 1, kind='introselect', order=None)", "intent": "Rearranges the elements in the array in such a way that the value of the element in `kth` position is in the position it would be in a sorted array . With arguments `axis`, `kind`, `order`. numpy", "question_id": 24421}
{"snippet": "testing.rundocs()", "intent": "Run doctests found in the given file . numpy", "question_id": 24422}
{"snippet": "testing.rundocs(filename=None)", "intent": "Run doctests found in the given file . With arguments `filename`. numpy", "question_id": 24423}
{"snippet": "testing.rundocs(raise_on_error=True)", "intent": "Run doctests found in the given file . With arguments `raise_on_error`. numpy", "question_id": 24424}
{"snippet": "testing.rundocs(filename=None, raise_on_error=True)", "intent": "Run doctests found in the given file . With arguments `filename`, `raise_on_error`. numpy", "question_id": 24425}
{"snippet": "random.RandomState.binomial(n, p)", "intent": "Draw samples from a binomial distribution . Samples are drawn from a binomial distribution with specified parameters , `n` trials and `p` probability of success where n an integer > = 0 and p is in the interval [ 0,1 ] . numpy", "question_id": 24426}
{"snippet": "random.RandomState.binomial(n, p, size=None)", "intent": "Draw samples from a binomial distribution . Samples are drawn from a binomial distribution with specified parameters , `n` trials and `p` probability of success where n an integer > = 0 and p is in the interval [ 0,1 ] . With arguments `size`. numpy", "question_id": 24427}
{"snippet": "ndarray.__setitem__(key, value, /)", "intent": "Set self [ `key` ] to `value` . With arguments `/`. numpy", "question_id": 24428}
{"snippet": "numpy.meshgrid(*xi)", "intent": "Return coordinate matrices from coordinate vectors . With arguments `*xi`. numpy", "question_id": 24429}
{"snippet": "numpy.meshgrid(*xi, copy=True)", "intent": "Return coordinate matrices from coordinate vectors . With arguments `*xi`, `copy`. numpy", "question_id": 24430}
{"snippet": "numpy.meshgrid(*xi, sparse=False)", "intent": "Return coordinate matrices from coordinate vectors . In the 1-D and 0-D case , the indexing and `sparse` keywords have no effect . With arguments `*xi`. numpy", "question_id": 24431}
{"snippet": "numpy.meshgrid(*xi, indexing='xy')", "intent": "Return coordinate matrices from coordinate vectors . This function supports both `indexing` conventions through the indexing keyword argument . With arguments `*xi`. numpy", "question_id": 24432}
{"snippet": "numpy.meshgrid(*xi, copy=True, sparse=False)", "intent": "Return coordinate matrices from coordinate vectors . In the 1-D and 0-D case , the indexing and `sparse` keywords have no effect . With arguments `*xi`, `copy`. numpy", "question_id": 24433}
{"snippet": "numpy.meshgrid(*xi, copy=True, indexing='xy')", "intent": "Return coordinate matrices from coordinate vectors . This function supports both `indexing` conventions through the indexing keyword argument . With arguments `*xi`, `copy`. numpy", "question_id": 24434}
{"snippet": "numpy.meshgrid(*xi, sparse=False, indexing='xy')", "intent": "Return coordinate matrices from coordinate vectors . In the 1-D and 0-D case , the indexing and `sparse` keywords have no effect . This function supports both `indexing` conventions through the indexing keyword argument . With arguments `*xi`. numpy", "question_id": 24435}
{"snippet": "numpy.meshgrid(*xi, copy=True, sparse=False, indexing='xy')", "intent": "Return coordinate matrices from coordinate vectors . In the 1-D and 0-D case , the indexing and `sparse` keywords have no effect . This function supports both `indexing` conventions through the indexing keyword argument . With arguments `*xi`, `copy`. numpy", "question_id": 24436}
{"snippet": "polynomial.chebyshev.poly2cheb(pol)", "intent": "Convert a polynomial to a Chebyshev series . With arguments `pol`. numpy", "question_id": 24437}
{"snippet": "nditer.operands", "intent": "operands[Slice] numpy", "question_id": 24438}
{"snippet": "char.chararray.istitle()", "intent": "Returns true for each element if the element is a titlecased string and there is at least one character , false otherwise . numpy", "question_id": 24439}
{"snippet": "ndarray.flatten()", "intent": "Return a copy of the array collapsed into one dimension . numpy", "question_id": 24440}
{"snippet": "ndarray.flatten(order='C')", "intent": "Return a copy of the array collapsed into one dimension . With arguments `order`. numpy", "question_id": 24441}
{"snippet": "char.translate(a, table)", "intent": "For each element in `a` , return a copy of the string where all characters occurring in the optional argument `deletechars` are removed , and the remaining characters have been mapped through the given translation `table` . numpy", "question_id": 24442}
{"snippet": "char.translate(a, table, deletechars=None)", "intent": "For each element in `a` , return a copy of the string where all characters occurring in the optional argument `deletechars` are removed , and the remaining characters have been mapped through the given translation `table` . numpy", "question_id": 24443}
{"snippet": "ma.MaskedArray.__ifloordiv__(other)", "intent": "Floor divide self by `other` in-place . numpy", "question_id": 24444}
{"snippet": "ndarray.__deepcopy__(memo, /)", "intent": "Used if copy.deepcopy is called on an array . With arguments `memo`, `/`. numpy", "question_id": 24445}
{"snippet": "numpy.polyint(p)", "intent": "Return an antiderivative ( indefinite integral ) of a polynomial . The returned order `m` antiderivative P of polynomial `p` satisfies \\ ( \\frac { d^m } { dx^m } P ( x ) = p ( x ) \\ ) and is defined up to m - 1 integration constants k. The constants determine the low-order polynomial part numpy", "question_id": 24446}
{"snippet": "numpy.polyint(p, m=1)", "intent": "Return an antiderivative ( indefinite integral ) of a polynomial . The returned order `m` antiderivative P of polynomial `p` satisfies \\ ( \\frac { d^m } { dx^m } P ( x ) = p ( x ) \\ ) and is defined up to m - 1 integration constants k. The constants determine the low-order polynomial part numpy", "question_id": 24447}
{"snippet": "numpy.polyint(p, k=None)", "intent": "Return an antiderivative ( indefinite integral ) of a polynomial . The returned order `m` antiderivative P of polynomial `p` satisfies \\ ( \\frac { d^m } { dx^m } P ( x ) = p ( x ) \\ ) and is defined up to m - 1 integration constants k. The constants determine the low-order polynomial part With arguments `k`. numpy", "question_id": 24448}
{"snippet": "numpy.polyint(p, m=1, k=None)", "intent": "Return an antiderivative ( indefinite integral ) of a polynomial . The returned order `m` antiderivative P of polynomial `p` satisfies \\ ( \\frac { d^m } { dx^m } P ( x ) = p ( x ) \\ ) and is defined up to m - 1 integration constants k. The constants determine the low-order polynomial part With arguments `k`. numpy", "question_id": 24449}
{"snippet": "generic.imag", "intent": "The imaginary part of the scalar. numpy", "question_id": 24450}
{"snippet": "numpy.prod(a)", "intent": "Return the product of array elements over `a` given `axis` . numpy", "question_id": 24451}
{"snippet": "numpy.prod(a, axis=None)", "intent": "Return the product of array elements over `a` given `axis` . numpy", "question_id": 24452}
{"snippet": "numpy.prod(a, dtype=None)", "intent": "Return the product of array elements over `a` given `axis` . With arguments `dtype`. numpy", "question_id": 24453}
{"snippet": "numpy.prod(a, out=None)", "intent": "Return the product of array elements over `a` given `axis` . With arguments `out`. numpy", "question_id": 24454}
{"snippet": "numpy.prod(a, keepdims=<no value>)", "intent": "Return the product of array elements over `a` given `axis` . With arguments `keepdims`. numpy", "question_id": 24455}
{"snippet": "numpy.prod(a, initial=<no value>)", "intent": "Return the product of array elements over `a` given `axis` . With arguments `initial`. numpy", "question_id": 24456}
{"snippet": "numpy.prod(a, where=<no value>)", "intent": "Return the product of array elements over `a` given `axis` . With arguments `where`. numpy", "question_id": 24457}
{"snippet": "numpy.prod(a, axis=None, dtype=None)", "intent": "Return the product of array elements over `a` given `axis` . With arguments `dtype`. numpy", "question_id": 24458}
{"snippet": "numpy.prod(a, axis=None, out=None)", "intent": "Return the product of array elements over `a` given `axis` . With arguments `out`. numpy", "question_id": 24459}
{"snippet": "numpy.prod(a, axis=None, keepdims=<no value>)", "intent": "Return the product of array elements over `a` given `axis` . With arguments `keepdims`. numpy", "question_id": 24460}
{"snippet": "broadcast.numiter", "intent": "Number of iterators possessed by the broadcasted result. numpy", "question_id": 24461}
{"snippet": "memmap.conj()", "intent": "Complex-conjugate all elements . numpy", "question_id": 24462}
{"snippet": "linalg.pinv(a)", "intent": "Compute the ( Moore-Penrose ) pseudo-inverse of `a` matrix . numpy", "question_id": 24463}
{"snippet": "linalg.pinv(a, rcond=1e-15)", "intent": "Compute the ( Moore-Penrose ) pseudo-inverse of `a` matrix . With arguments `rcond`. numpy", "question_id": 24464}
{"snippet": "linalg.pinv(a, hermitian=False)", "intent": "Compute the ( Moore-Penrose ) pseudo-inverse of `a` matrix . With arguments `hermitian`. numpy", "question_id": 24465}
{"snippet": "linalg.pinv(a, rcond=1e-15, hermitian=False)", "intent": "Compute the ( Moore-Penrose ) pseudo-inverse of `a` matrix . With arguments `rcond`, `hermitian`. numpy", "question_id": 24466}
{"snippet": "numpy.diff(a)", "intent": "Calculate the n-th discrete difference along the given `axis` . The first difference is given by out [ i ] = `a` [ i+1 ] - a [ i ] along the given axis , higher differences are calculated by using diff recursively . numpy", "question_id": 24467}
{"snippet": "numpy.diff(a, n=1)", "intent": "Calculate the n-th discrete difference along the given `axis` . The first difference is given by out [ i ] = `a` [ i+1 ] - a [ i ] along the given axis , higher differences are calculated by using diff recursively . With arguments `n`. numpy", "question_id": 24468}
{"snippet": "numpy.diff(a, axis=-1)", "intent": "Calculate the n-th discrete difference along the given `axis` . The first difference is given by out [ i ] = `a` [ i+1 ] - a [ i ] along the given axis , higher differences are calculated by using diff recursively . numpy", "question_id": 24469}
{"snippet": "numpy.diff(a, prepend=<no value>)", "intent": "Calculate the n-th discrete difference along the given `axis` . The first difference is given by out [ i ] = `a` [ i+1 ] - a [ i ] along the given axis , higher differences are calculated by using diff recursively . With arguments `prepend`. numpy", "question_id": 24470}
{"snippet": "numpy.diff(a, append=<no value>)", "intent": "Calculate the n-th discrete difference along the given `axis` . The first difference is given by out [ i ] = `a` [ i+1 ] - a [ i ] along the given axis , higher differences are calculated by using diff recursively . With arguments `append`. numpy", "question_id": 24471}
{"snippet": "numpy.diff(a, n=1, axis=-1)", "intent": "Calculate the n-th discrete difference along the given `axis` . The first difference is given by out [ i ] = `a` [ i+1 ] - a [ i ] along the given axis , higher differences are calculated by using diff recursively . With arguments `n`. numpy", "question_id": 24472}
{"snippet": "numpy.diff(a, n=1, prepend=<no value>)", "intent": "Calculate the n-th discrete difference along the given `axis` . The first difference is given by out [ i ] = `a` [ i+1 ] - a [ i ] along the given axis , higher differences are calculated by using diff recursively . With arguments `n`, `prepend`. numpy", "question_id": 24473}
{"snippet": "numpy.diff(a, n=1, append=<no value>)", "intent": "Calculate the n-th discrete difference along the given `axis` . The first difference is given by out [ i ] = `a` [ i+1 ] - a [ i ] along the given axis , higher differences are calculated by using diff recursively . With arguments `n`, `append`. numpy", "question_id": 24474}
{"snippet": "numpy.diff(a, axis=-1, prepend=<no value>)", "intent": "Calculate the n-th discrete difference along the given `axis` . The first difference is given by out [ i ] = `a` [ i+1 ] - a [ i ] along the given axis , higher differences are calculated by using diff recursively . With arguments `prepend`. numpy", "question_id": 24475}
{"snippet": "numpy.diff(a, axis=-1, append=<no value>)", "intent": "Calculate the n-th discrete difference along the given `axis` . The first difference is given by out [ i ] = `a` [ i+1 ] - a [ i ] along the given axis , higher differences are calculated by using diff recursively . With arguments `append`. numpy", "question_id": 24476}
{"snippet": "numpy.cosh(x, /, signature, extobj)", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `extobj`. numpy", "question_id": 24477}
{"snippet": "numpy.cosh(x, /, signature, extobj, out=None)", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `out`. numpy", "question_id": 24478}
{"snippet": "numpy.cosh(x, /, signature, extobj, where=True)", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `where`. numpy", "question_id": 24479}
{"snippet": "numpy.cosh(x, /, signature, extobj, casting='same_kind')", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `casting`. numpy", "question_id": 24480}
{"snippet": "numpy.cosh(x, /, signature, extobj, order='K')", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `order`. numpy", "question_id": 24481}
{"snippet": "numpy.cosh(x, /, signature, extobj, dtype=None)", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `dtype`. numpy", "question_id": 24482}
{"snippet": "numpy.cosh(x, /, signature, extobj, subok=True)", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `subok`. numpy", "question_id": 24483}
{"snippet": "numpy.cosh(x, /, signature, extobj, out=None, where=True)", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `out`, `where`. numpy", "question_id": 24484}
{"snippet": "numpy.cosh(x, /, signature, extobj, out=None, casting='same_kind')", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `out`, `casting`. numpy", "question_id": 24485}
{"snippet": "numpy.cosh(x, /, signature, extobj, out=None, order='K')", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `extobj`, `out`, `order`. numpy", "question_id": 24486}
{"snippet": "numpy.cosh(x, /, signature)", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`. numpy", "question_id": 24487}
{"snippet": "numpy.cosh(x, /, signature, out=None)", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `out`. numpy", "question_id": 24488}
{"snippet": "numpy.cosh(x, /, signature, where=True)", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `where`. numpy", "question_id": 24489}
{"snippet": "numpy.cosh(x, /, signature, casting='same_kind')", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `casting`. numpy", "question_id": 24490}
{"snippet": "numpy.cosh(x, /, signature, order='K')", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `order`. numpy", "question_id": 24491}
{"snippet": "numpy.cosh(x, /, signature, dtype=None)", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `dtype`. numpy", "question_id": 24492}
{"snippet": "numpy.cosh(x, /, signature, subok=True)", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `subok`. numpy", "question_id": 24493}
{"snippet": "numpy.cosh(x, /, signature, out=None, where=True)", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `out`, `where`. numpy", "question_id": 24494}
{"snippet": "numpy.cosh(x, /, signature, out=None, casting='same_kind')", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `out`, `casting`. numpy", "question_id": 24495}
{"snippet": "numpy.cosh(x, /, signature, out=None, order='K')", "intent": "Hyperbolic cosine , element-wise . Equivalent to 1/2 * ( np.exp ( `x` ) + np.exp ( -x ) ) and np.cos ( 1j * x ) . With arguments `/`, `signature`, `out`, `order`. numpy", "question_id": 24496}
{"snippet": "numpy.deprecate(*args, **kwargs)", "intent": "Issues a DeprecationWarning , adds warning to old_name \u2019 s docstring , rebinds old_name.__name__ and returns the new function object . With arguments `*args`, `**kwargs`. numpy", "question_id": 24497}
{"snippet": "chararray.tostring()", "intent": "A compatibility alias for tobytes , with exactly the same behavior . numpy", "question_id": 24498}
{"snippet": "chararray.tostring(order='C')", "intent": "A compatibility alias for tobytes , with exactly the same behavior . With arguments `order`. numpy", "question_id": 24499}
{"snippet": "matrix.newbyteorder(/)", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`. numpy", "question_id": 24500}
{"snippet": "matrix.newbyteorder(/, new_order='S')", "intent": "Return the array with the same data viewed with a different byte order . With arguments `/`, `new_order`. numpy", "question_id": 24501}
{"snippet": "linalg.solve(a, b)", "intent": "Solve `a` linear matrix equation , or system of linear scalar equations . Computes the \u201c exact \u201d solution , x , of the well-determined , i.e. , full rank , linear matrix equation ax = `b` . numpy", "question_id": 24502}
{"snippet": "memmap.trace()", "intent": "Return the sum along diagonals of the array . numpy", "question_id": 24503}
{"snippet": "memmap.trace(offset=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`. numpy", "question_id": 24504}
{"snippet": "memmap.trace(axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `axis1`. numpy", "question_id": 24505}
{"snippet": "memmap.trace(axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `axis2`. numpy", "question_id": 24506}
{"snippet": "memmap.trace(dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `dtype`. numpy", "question_id": 24507}
{"snippet": "memmap.trace(out=None)", "intent": "Return the sum along diagonals of the array . With arguments `out`. numpy", "question_id": 24508}
{"snippet": "memmap.trace(offset=0, axis1=0)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis1`. numpy", "question_id": 24509}
{"snippet": "memmap.trace(offset=0, axis2=1)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `axis2`. numpy", "question_id": 24510}
{"snippet": "memmap.trace(offset=0, dtype=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `dtype`. numpy", "question_id": 24511}
{"snippet": "memmap.trace(offset=0, out=None)", "intent": "Return the sum along diagonals of the array . With arguments `offset`, `out`. numpy", "question_id": 24512}
{"snippet": "numpy.histogram_bin_edges(a)", "intent": "Function to calculate only the edges of the `bins` used by the histogram function . With arguments `a`. numpy", "question_id": 24513}
{"snippet": "numpy.histogram_bin_edges(a, bins=10)", "intent": "Function to calculate only the edges of the `bins` used by the histogram function . With arguments `a`. numpy", "question_id": 24514}
{"snippet": "numpy.histogram_bin_edges(a, range=None)", "intent": "Function to calculate only the edges of the `bins` used by the histogram function . The final bin count is obtained from np.round ( np.ceil ( `range` / h ) ) . With arguments `a`. numpy", "question_id": 24515}
{"snippet": "numpy.histogram_bin_edges(a, weights=None)", "intent": "Function to calculate only the edges of the `bins` used by the histogram function . With arguments `a`, `weights`. numpy", "question_id": 24516}
{"snippet": "numpy.histogram_bin_edges(a, bins=10, range=None)", "intent": "Function to calculate only the edges of the `bins` used by the histogram function . The final bin count is obtained from np.round ( np.ceil ( `range` / h ) ) . With arguments `a`. numpy", "question_id": 24517}
{"snippet": "numpy.histogram_bin_edges(a, bins=10, weights=None)", "intent": "Function to calculate only the edges of the `bins` used by the histogram function . With arguments `a`, `weights`. numpy", "question_id": 24518}
{"snippet": "numpy.histogram_bin_edges(a, range=None, weights=None)", "intent": "Function to calculate only the edges of the `bins` used by the histogram function . The final bin count is obtained from np.round ( np.ceil ( `range` / h ) ) . With arguments `a`, `weights`. numpy", "question_id": 24519}
{"snippet": "numpy.histogram_bin_edges(a, bins=10, range=None, weights=None)", "intent": "Function to calculate only the edges of the `bins` used by the histogram function . The final bin count is obtained from np.round ( np.ceil ( `range` / h ) ) . With arguments `a`, `weights`. numpy", "question_id": 24520}
{"snippet": "random.random()", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) . numpy", "question_id": 24521}
{"snippet": "random.random(size=None)", "intent": "Return random floats in the half-open interval [ 0.0 , 1.0 ) . With arguments `size`. numpy", "question_id": 24522}
{"snippet": "memmap.tolist()", "intent": "Return the array as an a.ndim-levels deep nested list of Python scalars . numpy", "question_id": 24523}
{"snippet": "polynomial.hermite_e.hermeder(c)", "intent": "Differentiate a Hermite_e series . Returns the series coefficients `c` differentiated `m` times along `axis` . numpy", "question_id": 24524}
{"snippet": "polynomial.hermite_e.hermeder(c, m=1)", "intent": "Differentiate a Hermite_e series . Returns the series coefficients `c` differentiated `m` times along `axis` . numpy", "question_id": 24525}
{"snippet": "polynomial.hermite_e.hermeder(c, scl=1)", "intent": "Differentiate a Hermite_e series . Returns the series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) . numpy", "question_id": 24526}
{"snippet": "polynomial.hermite_e.hermeder(c, axis=0)", "intent": "Differentiate a Hermite_e series . Returns the series coefficients `c` differentiated `m` times along `axis` . numpy", "question_id": 24527}
{"snippet": "polynomial.hermite_e.hermeder(c, m=1, scl=1)", "intent": "Differentiate a Hermite_e series . Returns the series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) . numpy", "question_id": 24528}
{"snippet": "polynomial.hermite_e.hermeder(c, m=1, axis=0)", "intent": "Differentiate a Hermite_e series . Returns the series coefficients `c` differentiated `m` times along `axis` . numpy", "question_id": 24529}
{"snippet": "polynomial.hermite_e.hermeder(c, scl=1, axis=0)", "intent": "Differentiate a Hermite_e series . Returns the series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) . numpy", "question_id": 24530}
{"snippet": "polynomial.hermite_e.hermeder(c, m=1, scl=1, axis=0)", "intent": "Differentiate a Hermite_e series . Returns the series coefficients `c` differentiated `m` times along `axis` . At each iteration the result is multiplied by `scl` ( the scaling factor is for use in a linear change of variable ) . numpy", "question_id": 24531}
{"snippet": "numpy.deprecate_with_doc(msg)", "intent": "Deprecates a function and includes the deprecation in its docstring . With arguments `msg`. numpy", "question_id": 24532}
{"snippet": "memmap.flat", "intent": "A 1-D iterator over the array. numpy", "question_id": 24533}
{"snippet": "matrix.squeeze()", "intent": "Return a possibly reshaped matrix . numpy", "question_id": 24534}
{"snippet": "matrix.squeeze(axis=None)", "intent": "Return a possibly reshaped matrix . The returned matrix is always either m itself or a view into m. Supplying an `axis` keyword argument will not affect the returned matrix but it may cause an error to be raised . numpy", "question_id": 24535}
{"snippet": "ma.masked_array.resize(newshape)", "intent": "This method is difficult to implement safely and may be deprecated in future releases of NumPy . With arguments `newshape`. numpy", "question_id": 24536}
{"snippet": "ma.masked_array.resize(newshape, refcheck=True)", "intent": "This method is difficult to implement safely and may be deprecated in future releases of NumPy . With arguments `newshape`, `refcheck`. numpy", "question_id": 24537}
{"snippet": "ma.masked_array.resize(newshape, order=False)", "intent": "This method is difficult to implement safely and may be deprecated in future releases of NumPy . With arguments `newshape`, `order`. numpy", "question_id": 24538}
{"snippet": "ma.masked_array.resize(newshape, refcheck=True, order=False)", "intent": "This method is difficult to implement safely and may be deprecated in future releases of NumPy . With arguments `newshape`, `refcheck`, `order`. numpy", "question_id": 24539}
{"snippet": "chararray.flags", "intent": "Information about the memory layout of the array. numpy", "question_id": 24540}
{"snippet": "numpy.trace(a)", "intent": "Return the sum along diagonals of the array . If `a` is 2-D , the sum along its diagonal with the given `offset` is returned , i.e. , the sum of elements a [ i , i+offset ] for all i . numpy", "question_id": 24541}
{"snippet": "numpy.trace(a, offset=0)", "intent": "Return the sum along diagonals of the array . If `a` is 2-D , the sum along its diagonal with the given `offset` is returned , i.e. , the sum of elements a [ i , i+offset ] for all i . numpy", "question_id": 24542}
{"snippet": "numpy.trace(a, axis1=0)", "intent": "Return the sum along diagonals of the array . If `a` is 2-D , the sum along its diagonal with the given `offset` is returned , i.e. , the sum of elements a [ i , i+offset ] for all i . If a has more than two dimensions , then the axes specified by `axis1` and `axis2` are used to determine the 2-D sub-arrays whose traces are returned . numpy", "question_id": 24543}
{"snippet": "numpy.trace(a, axis2=1)", "intent": "Return the sum along diagonals of the array . If `a` is 2-D , the sum along its diagonal with the given `offset` is returned , i.e. , the sum of elements a [ i , i+offset ] for all i . If a has more than two dimensions , then the axes specified by `axis1` and `axis2` are used to determine the 2-D sub-arrays whose traces are returned . numpy", "question_id": 24544}
{"snippet": "numpy.trace(a, dtype=None)", "intent": "Return the sum along diagonals of the array . If `a` is 2-D , the sum along its diagonal with the given `offset` is returned , i.e. , the sum of elements a [ i , i+offset ] for all i . With arguments `dtype`. numpy", "question_id": 24545}
{"snippet": "numpy.trace(a, out=None)", "intent": "Return the sum along diagonals of the array . If `a` is 2-D , the sum along its diagonal with the given `offset` is returned , i.e. , the sum of elements a [ i , i+offset ] for all i . With arguments `out`. numpy", "question_id": 24546}
{"snippet": "numpy.trace(a, offset=0, axis1=0)", "intent": "Return the sum along diagonals of the array . If `a` is 2-D , the sum along its diagonal with the given `offset` is returned , i.e. , the sum of elements a [ i , i+offset ] for all i . If a has more than two dimensions , then the axes specified by `axis1` and `axis2` are used to determine the 2-D sub-arrays whose traces are returned . numpy", "question_id": 24547}
{"snippet": "numpy.trace(a, offset=0, axis2=1)", "intent": "Return the sum along diagonals of the array . If `a` is 2-D , the sum along its diagonal with the given `offset` is returned , i.e. , the sum of elements a [ i , i+offset ] for all i . If a has more than two dimensions , then the axes specified by `axis1` and `axis2` are used to determine the 2-D sub-arrays whose traces are returned . numpy", "question_id": 24548}
{"snippet": "numpy.trace(a, offset=0, dtype=None)", "intent": "Return the sum along diagonals of the array . If `a` is 2-D , the sum along its diagonal with the given `offset` is returned , i.e. , the sum of elements a [ i , i+offset ] for all i . With arguments `dtype`. numpy", "question_id": 24549}
{"snippet": "numpy.trace(a, offset=0, out=None)", "intent": "Return the sum along diagonals of the array . If `a` is 2-D , the sum along its diagonal with the given `offset` is returned , i.e. , the sum of elements a [ i , i+offset ] for all i . With arguments `out`. numpy", "question_id": 24550}
{"snippet": "numpy.seterrcall(func)", "intent": "Set the floating-point error callback function or log object . With arguments `func`. numpy", "question_id": 24551}
{"snippet": "polynomial.polynomial.polymulx(c)", "intent": "Multiply a polynomial by x . Multiply the polynomial `c` by x , where x is the independent variable . numpy", "question_id": 24552}
{"snippet": "numpy.cumsum(a)", "intent": "Return the cumulative sum of the elements along `a` given `axis` . numpy", "question_id": 24553}
{"snippet": "numpy.cumsum(a, axis=None)", "intent": "Return the cumulative sum of the elements along `a` given `axis` . numpy", "question_id": 24554}
{"snippet": "numpy.cumsum(a, dtype=None)", "intent": "Return the cumulative sum of the elements along `a` given `axis` . With arguments `dtype`. numpy", "question_id": 24555}
{"snippet": "numpy.cumsum(a, out=None)", "intent": "Return the cumulative sum of the elements along `a` given `axis` . With arguments `out`. numpy", "question_id": 24556}
{"snippet": "numpy.cumsum(a, axis=None, dtype=None)", "intent": "Return the cumulative sum of the elements along `a` given `axis` . With arguments `dtype`. numpy", "question_id": 24557}
{"snippet": "numpy.cumsum(a, axis=None, out=None)", "intent": "Return the cumulative sum of the elements along `a` given `axis` . With arguments `out`. numpy", "question_id": 24558}
{"snippet": "numpy.cumsum(a, dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along `a` given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 24559}
{"snippet": "numpy.cumsum(a, axis=None, dtype=None, out=None)", "intent": "Return the cumulative sum of the elements along `a` given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 24560}
{"snippet": "ndarray.round()", "intent": "Return a with each element rounded to the given number of `decimals` . numpy", "question_id": 24561}
{"snippet": "ndarray.round(decimals=0)", "intent": "Return a with each element rounded to the given number of `decimals` . numpy", "question_id": 24562}
{"snippet": "ndarray.round(out=None)", "intent": "Return a with each element rounded to the given number of `decimals` . With arguments `out`. numpy", "question_id": 24563}
{"snippet": "ndarray.round(decimals=0, out=None)", "intent": "Return a with each element rounded to the given number of `decimals` . With arguments `out`. numpy", "question_id": 24564}
{"snippet": "ndarray.__invert__(/)", "intent": "~self With arguments `/`. numpy", "question_id": 24565}
{"snippet": "chararray.view(dtype, type)", "intent": "New view of array with the same data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) Viewing array data using a different `type` and dtype : numpy", "question_id": 24566}
{"snippet": "chararray.view(dtype)", "intent": "New view of array with the same data . a.view ( ndarray_subclass ) or a.view ( type=ndarray_subclass ) just returns an instance of ndarray_subclass that looks at the same array ( same shape , `dtype` , etc . ) numpy", "question_id": 24567}
{"snippet": "chararray.view()", "intent": "New view of array with the same data . numpy", "question_id": 24568}
{"snippet": "ndarray.__le__(value, /)", "intent": "Return self < =value . With arguments `value`, `/`. numpy", "question_id": 24569}
{"snippet": "numpy.pad(array, pad_width, **kwargs)", "intent": "Pad an `array` . With arguments `pad_width`, `**kwargs`. numpy", "question_id": 24570}
{"snippet": "numpy.pad(array, pad_width, **kwargs, mode='constant')", "intent": "Pad an `array` . With arguments `pad_width`, `**kwargs`, `mode`. numpy", "question_id": 24571}
{"snippet": "numpy.nanargmax(a)", "intent": "Return the indices of the maximum values in the specified `axis` ignoring NaNs . Warning : the results can not be trusted if `a` slice contains only NaNs and -Infs . numpy", "question_id": 24572}
{"snippet": "numpy.nanargmax(a, axis=None)", "intent": "Return the indices of the maximum values in the specified `axis` ignoring NaNs . Warning : the results can not be trusted if `a` slice contains only NaNs and -Infs . numpy", "question_id": 24573}
{"snippet": "recarray.tolist()", "intent": "Return the array as an a.ndim-levels deep nested list of Python scalars . numpy", "question_id": 24574}
{"snippet": "numpy.ogrid", "intent": "nd_grid instance which returns an open multi-dimensional \u201cmeshgrid\u201d. numpy", "question_id": 24575}
{"snippet": "matrix.item(*args)", "intent": "Copy an element of an array to a standard Python scalar and return it . With arguments `*args`. numpy", "question_id": 24576}
{"snippet": "chararray.zfill(width)", "intent": "Return the numeric string left-filled with zeros in a string of length `width` . numpy", "question_id": 24577}
{"snippet": "memmap.cumprod()", "intent": "Return the cumulative product of the elements along the given `axis` . numpy", "question_id": 24578}
{"snippet": "memmap.cumprod(axis=None)", "intent": "Return the cumulative product of the elements along the given `axis` . numpy", "question_id": 24579}
{"snippet": "memmap.cumprod(dtype=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 24580}
{"snippet": "memmap.cumprod(out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `out`. numpy", "question_id": 24581}
{"snippet": "memmap.cumprod(axis=None, dtype=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`. numpy", "question_id": 24582}
{"snippet": "memmap.cumprod(axis=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `out`. numpy", "question_id": 24583}
{"snippet": "memmap.cumprod(dtype=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 24584}
{"snippet": "memmap.cumprod(axis=None, dtype=None, out=None)", "intent": "Return the cumulative product of the elements along the given `axis` . With arguments `dtype`, `out`. numpy", "question_id": 24585}
{"snippet": "record.view()", "intent": "Scalar method identical to the corresponding array attribute . numpy", "question_id": 24586}
{"snippet": "matrix.dtype", "intent": "Data-type of the array\u2019s elements. numpy", "question_id": 24587}
{"snippet": "random.RandomState.laplace()", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . numpy", "question_id": 24588}
{"snippet": "random.RandomState.laplace(loc=0.0)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `loc`. numpy", "question_id": 24589}
{"snippet": "random.RandomState.laplace(scale=1.0)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . numpy", "question_id": 24590}
{"snippet": "random.RandomState.laplace(size=None)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `size`. numpy", "question_id": 24591}
{"snippet": "random.RandomState.laplace(loc=0.0, scale=1.0)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `loc`. numpy", "question_id": 24592}
{"snippet": "random.RandomState.laplace(loc=0.0, size=None)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `loc`, `size`. numpy", "question_id": 24593}
{"snippet": "random.RandomState.laplace(scale=1.0, size=None)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `size`. numpy", "question_id": 24594}
{"snippet": "random.RandomState.laplace(loc=0.0, scale=1.0, size=None)", "intent": "Draw samples from the Laplace or double exponential distribution with specified location ( or mean ) and `scale` ( decay ) . With arguments `loc`, `size`. numpy", "question_id": 24595}
{"snippet": "ma.masked_array.count()", "intent": "Count the non-masked elements of the array along the given `axis` . numpy", "question_id": 24596}
{"snippet": "ma.masked_array.count(axis=None)", "intent": "Count the non-masked elements of the array along the given `axis` . numpy", "question_id": 24597}
{"snippet": "ma.masked_array.count(keepdims=<no value>)", "intent": "Count the non-masked elements of the array along the given `axis` . With arguments `keepdims`. numpy", "question_id": 24598}
{"snippet": "ma.masked_array.count(axis=None, keepdims=<no value>)", "intent": "Count the non-masked elements of the array along the given `axis` . With arguments `keepdims`. numpy", "question_id": 24599}
{"snippet": "distutils.ccompiler_opt.CCompilerOpt.conf_features_partial()", "intent": "Return a dictionary of supported CPU features by the platform , and accumulate the rest of undefined options in conf_features , the returned dict has same rules and notes in class attribute conf_features , also its override any options that been set in \u2018 conf_features \u2019 . numpy", "question_id": 24600}
{"snippet": "ma.MaskedArray.__or__(value, /)", "intent": "Return self|value . With arguments `value`, `/`. numpy", "question_id": 24601}
{"snippet": "ma.MaskedArray.__ixor__(value, /)", "intent": "Return self^=value . With arguments `value`, `/`. numpy", "question_id": 24602}
