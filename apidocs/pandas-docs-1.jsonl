{"snippet": "pandas.BooleanDtype", "intent": "Extension dtype for boolean data.", "question_id": 32000}
{"snippet": "pandas.BooleanDtype", "intent": "Extension dtype for boolean data.", "question_id": 32001}
{"snippet": "pandas.BooleanDtype", "intent": "Extension dtype for boolean data.", "question_id": 32002}
{"snippet": "Categorical.__array__()", "intent": "The numpy array interface .", "question_id": 32003}
{"snippet": "Categorical.__array__(dtype=None)", "intent": "The numpy array interface . With arguments `dtype`.", "question_id": 32004}
{"snippet": "Categorical.__array__()", "intent": "The numpy array interface .", "question_id": 32005}
{"snippet": "Categorical.__array__(dtype=None)", "intent": "The numpy array interface . With arguments `dtype`.", "question_id": 32006}
{"snippet": "Categorical.__array__()", "intent": "The numpy array interface .", "question_id": 32007}
{"snippet": "Categorical.__array__(dtype=None)", "intent": "The numpy array interface . With arguments `dtype`.", "question_id": 32008}
{"snippet": "Categorical.from_codes(codes)", "intent": "Make a Categorical type from `codes` and `categories` or `dtype` .", "question_id": 32009}
{"snippet": "Categorical.from_codes(codes, categories=None)", "intent": "Make a Categorical type from `codes` and `categories` or `dtype` .", "question_id": 32010}
{"snippet": "Categorical.from_codes(codes, ordered=None)", "intent": "Make a Categorical type from `codes` and `categories` or `dtype` . With arguments `ordered`.", "question_id": 32011}
{"snippet": "Categorical.from_codes(codes, dtype=None)", "intent": "Make a Categorical type from `codes` and `categories` or `dtype` .", "question_id": 32012}
{"snippet": "Categorical.from_codes(codes, categories=None, ordered=None)", "intent": "Make a Categorical type from `codes` and `categories` or `dtype` . With arguments `ordered`.", "question_id": 32013}
{"snippet": "Categorical.from_codes(codes, categories=None, dtype=None)", "intent": "Make a Categorical type from `codes` and `categories` or `dtype` .", "question_id": 32014}
{"snippet": "Categorical.from_codes(codes, ordered=None, dtype=None)", "intent": "Make a Categorical type from `codes` and `categories` or `dtype` . With arguments `ordered`.", "question_id": 32015}
{"snippet": "Categorical.from_codes(codes, categories=None, ordered=None, dtype=None)", "intent": "Make a Categorical type from `codes` and `categories` or `dtype` . With arguments `ordered`.", "question_id": 32016}
{"snippet": "Categorical.from_codes(codes)", "intent": "Make a Categorical type from `codes` and `categories` or `dtype` .", "question_id": 32017}
{"snippet": "Categorical.from_codes(codes, categories=None)", "intent": "Make a Categorical type from `codes` and `categories` or `dtype` .", "question_id": 32018}
{"snippet": "Categorical.from_codes(codes, ordered=None)", "intent": "Make a Categorical type from `codes` and `categories` or `dtype` . With arguments `ordered`.", "question_id": 32019}
{"snippet": "Categorical.from_codes(codes, dtype=None)", "intent": "Make a Categorical type from `codes` and `categories` or `dtype` .", "question_id": 32020}
{"snippet": "Categorical.from_codes(codes, categories=None, ordered=None)", "intent": "Make a Categorical type from `codes` and `categories` or `dtype` . With arguments `ordered`.", "question_id": 32021}
{"snippet": "Categorical.from_codes(codes, categories=None, dtype=None)", "intent": "Make a Categorical type from `codes` and `categories` or `dtype` .", "question_id": 32022}
{"snippet": "Categorical.from_codes(codes, ordered=None, dtype=None)", "intent": "Make a Categorical type from `codes` and `categories` or `dtype` . With arguments `ordered`.", "question_id": 32023}
{"snippet": "Categorical.from_codes(codes, categories=None, ordered=None, dtype=None)", "intent": "Make a Categorical type from `codes` and `categories` or `dtype` . With arguments `ordered`.", "question_id": 32024}
{"snippet": "Categorical.from_codes(codes)", "intent": "Make a Categorical type from `codes` and `categories` or `dtype` .", "question_id": 32025}
{"snippet": "Categorical.from_codes(codes, categories=None)", "intent": "Make a Categorical type from `codes` and `categories` or `dtype` .", "question_id": 32026}
{"snippet": "Categorical.from_codes(codes, ordered=None)", "intent": "Make a Categorical type from `codes` and `categories` or `dtype` . With arguments `ordered`.", "question_id": 32027}
{"snippet": "Categorical.from_codes(codes, dtype=None)", "intent": "Make a Categorical type from `codes` and `categories` or `dtype` .", "question_id": 32028}
{"snippet": "Categorical.from_codes(codes, categories=None, ordered=None)", "intent": "Make a Categorical type from `codes` and `categories` or `dtype` . With arguments `ordered`.", "question_id": 32029}
{"snippet": "Categorical.from_codes(codes, categories=None, dtype=None)", "intent": "Make a Categorical type from `codes` and `categories` or `dtype` .", "question_id": 32030}
{"snippet": "Categorical.from_codes(codes, ordered=None, dtype=None)", "intent": "Make a Categorical type from `codes` and `categories` or `dtype` . With arguments `ordered`.", "question_id": 32031}
{"snippet": "Categorical.from_codes(codes, categories=None, ordered=None, dtype=None)", "intent": "Make a Categorical type from `codes` and `categories` or `dtype` . With arguments `ordered`.", "question_id": 32032}
{"snippet": "pandas.Categorical(values)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) .", "question_id": 32033}
{"snippet": "pandas.Categorical(values, categories=None)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) .", "question_id": 32034}
{"snippet": "pandas.Categorical(values, ordered=None)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) . With arguments `ordered`.", "question_id": 32035}
{"snippet": "pandas.Categorical(values, dtype=None)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) . With arguments `dtype`.", "question_id": 32036}
{"snippet": "pandas.Categorical(values, fastpath=False)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) . With arguments `fastpath`.", "question_id": 32037}
{"snippet": "pandas.Categorical(values, copy=True)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) . With arguments `copy`.", "question_id": 32038}
{"snippet": "pandas.Categorical(values, categories=None, ordered=None)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) . With arguments `ordered`.", "question_id": 32039}
{"snippet": "pandas.Categorical(values, categories=None, dtype=None)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) . With arguments `dtype`.", "question_id": 32040}
{"snippet": "pandas.Categorical(values, categories=None, fastpath=False)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) . With arguments `fastpath`.", "question_id": 32041}
{"snippet": "pandas.Categorical(values, categories=None, copy=True)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) . With arguments `copy`.", "question_id": 32042}
{"snippet": "pandas.Categorical(values)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) .", "question_id": 32043}
{"snippet": "pandas.Categorical(values, categories=None)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) .", "question_id": 32044}
{"snippet": "pandas.Categorical(values, ordered=None)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) . With arguments `ordered`.", "question_id": 32045}
{"snippet": "pandas.Categorical(values, dtype=None)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) . With arguments `dtype`.", "question_id": 32046}
{"snippet": "pandas.Categorical(values, fastpath=False)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) . With arguments `fastpath`.", "question_id": 32047}
{"snippet": "pandas.Categorical(values, copy=True)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) . With arguments `copy`.", "question_id": 32048}
{"snippet": "pandas.Categorical(values, categories=None, ordered=None)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) . With arguments `ordered`.", "question_id": 32049}
{"snippet": "pandas.Categorical(values, categories=None, dtype=None)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) . With arguments `dtype`.", "question_id": 32050}
{"snippet": "pandas.Categorical(values, categories=None, fastpath=False)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) . With arguments `fastpath`.", "question_id": 32051}
{"snippet": "pandas.Categorical(values, categories=None, copy=True)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) . With arguments `copy`.", "question_id": 32052}
{"snippet": "pandas.Categorical(values)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) .", "question_id": 32053}
{"snippet": "pandas.Categorical(values, categories=None)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) .", "question_id": 32054}
{"snippet": "pandas.Categorical(values, ordered=None)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) . With arguments `ordered`.", "question_id": 32055}
{"snippet": "pandas.Categorical(values, dtype=None)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) . With arguments `dtype`.", "question_id": 32056}
{"snippet": "pandas.Categorical(values, fastpath=False)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) . With arguments `fastpath`.", "question_id": 32057}
{"snippet": "pandas.Categorical(values, copy=True)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) . With arguments `copy`.", "question_id": 32058}
{"snippet": "pandas.Categorical(values, categories=None, ordered=None)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) . With arguments `ordered`.", "question_id": 32059}
{"snippet": "pandas.Categorical(values, categories=None, dtype=None)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) . With arguments `dtype`.", "question_id": 32060}
{"snippet": "pandas.Categorical(values, categories=None, fastpath=False)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) . With arguments `fastpath`.", "question_id": 32061}
{"snippet": "pandas.Categorical(values, categories=None, copy=True)", "intent": "Represent a categorical variable in classic R / S-plus fashion . Categoricals can only take on only a limited , and usually fixed , number of possible `values` ( `categories` ) . With arguments `copy`.", "question_id": 32062}
{"snippet": "pandas.CategoricalDtype()", "intent": "Type for categorical data with the `categories` and orderedness .", "question_id": 32063}
{"snippet": "pandas.CategoricalDtype(categories=None)", "intent": "Type for categorical data with the `categories` and orderedness .", "question_id": 32064}
{"snippet": "pandas.CategoricalDtype(ordered=False)", "intent": "Type for categorical data with the `categories` and orderedness . With arguments `ordered`.", "question_id": 32065}
{"snippet": "pandas.CategoricalDtype(categories=None, ordered=False)", "intent": "Type for categorical data with the `categories` and orderedness . With arguments `ordered`.", "question_id": 32066}
{"snippet": "pandas.CategoricalDtype()", "intent": "Type for categorical data with the `categories` and orderedness .", "question_id": 32067}
{"snippet": "pandas.CategoricalDtype(categories=None)", "intent": "Type for categorical data with the `categories` and orderedness .", "question_id": 32068}
{"snippet": "pandas.CategoricalDtype(ordered=False)", "intent": "Type for categorical data with the `categories` and orderedness . With arguments `ordered`.", "question_id": 32069}
{"snippet": "pandas.CategoricalDtype(categories=None, ordered=False)", "intent": "Type for categorical data with the `categories` and orderedness . With arguments `ordered`.", "question_id": 32070}
{"snippet": "pandas.CategoricalDtype()", "intent": "Type for categorical data with the `categories` and orderedness .", "question_id": 32071}
{"snippet": "pandas.CategoricalDtype(categories=None)", "intent": "Type for categorical data with the `categories` and orderedness .", "question_id": 32072}
{"snippet": "pandas.CategoricalDtype(ordered=False)", "intent": "Type for categorical data with the `categories` and orderedness . With arguments `ordered`.", "question_id": 32073}
{"snippet": "pandas.CategoricalDtype(categories=None, ordered=False)", "intent": "Type for categorical data with the `categories` and orderedness . With arguments `ordered`.", "question_id": 32074}
{"snippet": "CategoricalIndex.add_categories(*args, **kwargs)", "intent": "Add new categories . With arguments `*args`, `**kwargs`.", "question_id": 32075}
{"snippet": "CategoricalIndex.add_categories(*args, **kwargs)", "intent": "Add new categories . With arguments `*args`, `**kwargs`.", "question_id": 32076}
{"snippet": "CategoricalIndex.add_categories(*args, **kwargs)", "intent": "Add new categories . With arguments `*args`, `**kwargs`.", "question_id": 32077}
{"snippet": "CategoricalIndex.as_ordered(*args, **kwargs)", "intent": "Set the Categorical to be ordered . With arguments `*args`, `**kwargs`.", "question_id": 32078}
{"snippet": "CategoricalIndex.as_ordered(*args, **kwargs)", "intent": "Set the Categorical to be ordered . With arguments `*args`, `**kwargs`.", "question_id": 32079}
{"snippet": "CategoricalIndex.as_ordered(*args, **kwargs)", "intent": "Set the Categorical to be ordered . With arguments `*args`, `**kwargs`.", "question_id": 32080}
{"snippet": "CategoricalIndex.as_unordered(*args, **kwargs)", "intent": "Set the Categorical to be unordered . With arguments `*args`, `**kwargs`.", "question_id": 32081}
{"snippet": "CategoricalIndex.as_unordered(*args, **kwargs)", "intent": "Set the Categorical to be unordered . With arguments `*args`, `**kwargs`.", "question_id": 32082}
{"snippet": "CategoricalIndex.as_unordered(*args, **kwargs)", "intent": "Set the Categorical to be unordered . With arguments `*args`, `**kwargs`.", "question_id": 32083}
{"snippet": "CategoricalIndex.equals(other)", "intent": "Determine if two CategoricalIndex objects contain the same elements . With arguments `other`.", "question_id": 32084}
{"snippet": "CategoricalIndex.equals(other)", "intent": "Determine if two CategoricalIndex objects contain the same elements . With arguments `other`.", "question_id": 32085}
{"snippet": "CategoricalIndex.equals(other)", "intent": "Determine if two CategoricalIndex objects contain the same elements . With arguments `other`.", "question_id": 32086}
{"snippet": "pandas.CategoricalIndex()", "intent": "Index based on an underlying Categorical .", "question_id": 32087}
{"snippet": "pandas.CategoricalIndex(data=None)", "intent": "Index based on an underlying Categorical . With arguments `data`.", "question_id": 32088}
{"snippet": "pandas.CategoricalIndex(categories=None)", "intent": "Index based on an underlying Categorical . CategoricalIndex , like Categorical , can only take on a limited , and usually fixed , number of possible values ( `categories` ) .", "question_id": 32089}
{"snippet": "pandas.CategoricalIndex(ordered=None)", "intent": "Index based on an underlying Categorical . With arguments `ordered`.", "question_id": 32090}
{"snippet": "pandas.CategoricalIndex(dtype=None)", "intent": "Index based on an underlying Categorical . With arguments `dtype`.", "question_id": 32091}
{"snippet": "pandas.CategoricalIndex(copy=False)", "intent": "Index based on an underlying Categorical . With arguments `copy`.", "question_id": 32092}
{"snippet": "pandas.CategoricalIndex(name=None)", "intent": "Index based on an underlying Categorical . With arguments `name`.", "question_id": 32093}
{"snippet": "pandas.CategoricalIndex(data=None, categories=None)", "intent": "Index based on an underlying Categorical . CategoricalIndex , like Categorical , can only take on a limited , and usually fixed , number of possible values ( `categories` ) . With arguments `data`.", "question_id": 32094}
{"snippet": "pandas.CategoricalIndex(data=None, ordered=None)", "intent": "Index based on an underlying Categorical . With arguments `data`, `ordered`.", "question_id": 32095}
{"snippet": "pandas.CategoricalIndex(data=None, dtype=None)", "intent": "Index based on an underlying Categorical . With arguments `data`, `dtype`.", "question_id": 32096}
{"snippet": "pandas.CategoricalIndex()", "intent": "Index based on an underlying Categorical .", "question_id": 32097}
{"snippet": "pandas.CategoricalIndex(data=None)", "intent": "Index based on an underlying Categorical . With arguments `data`.", "question_id": 32098}
{"snippet": "pandas.CategoricalIndex(categories=None)", "intent": "Index based on an underlying Categorical . CategoricalIndex , like Categorical , can only take on a limited , and usually fixed , number of possible values ( `categories` ) .", "question_id": 32099}
{"snippet": "pandas.CategoricalIndex(ordered=None)", "intent": "Index based on an underlying Categorical . With arguments `ordered`.", "question_id": 32100}
{"snippet": "pandas.CategoricalIndex(dtype=None)", "intent": "Index based on an underlying Categorical . With arguments `dtype`.", "question_id": 32101}
{"snippet": "pandas.CategoricalIndex(copy=False)", "intent": "Index based on an underlying Categorical . With arguments `copy`.", "question_id": 32102}
{"snippet": "pandas.CategoricalIndex(name=None)", "intent": "Index based on an underlying Categorical . With arguments `name`.", "question_id": 32103}
{"snippet": "pandas.CategoricalIndex(data=None, categories=None)", "intent": "Index based on an underlying Categorical . CategoricalIndex , like Categorical , can only take on a limited , and usually fixed , number of possible values ( `categories` ) . With arguments `data`.", "question_id": 32104}
{"snippet": "pandas.CategoricalIndex(data=None, ordered=None)", "intent": "Index based on an underlying Categorical . With arguments `data`, `ordered`.", "question_id": 32105}
{"snippet": "pandas.CategoricalIndex(data=None, dtype=None)", "intent": "Index based on an underlying Categorical . With arguments `data`, `dtype`.", "question_id": 32106}
{"snippet": "pandas.CategoricalIndex()", "intent": "Index based on an underlying Categorical .", "question_id": 32107}
{"snippet": "pandas.CategoricalIndex(data=None)", "intent": "Index based on an underlying Categorical . With arguments `data`.", "question_id": 32108}
{"snippet": "pandas.CategoricalIndex(categories=None)", "intent": "Index based on an underlying Categorical . CategoricalIndex , like Categorical , can only take on a limited , and usually fixed , number of possible values ( `categories` ) .", "question_id": 32109}
{"snippet": "pandas.CategoricalIndex(ordered=None)", "intent": "Index based on an underlying Categorical . With arguments `ordered`.", "question_id": 32110}
{"snippet": "pandas.CategoricalIndex(dtype=None)", "intent": "Index based on an underlying Categorical . With arguments `dtype`.", "question_id": 32111}
{"snippet": "pandas.CategoricalIndex(copy=False)", "intent": "Index based on an underlying Categorical . With arguments `copy`.", "question_id": 32112}
{"snippet": "pandas.CategoricalIndex(name=None)", "intent": "Index based on an underlying Categorical . With arguments `name`.", "question_id": 32113}
{"snippet": "pandas.CategoricalIndex(data=None, categories=None)", "intent": "Index based on an underlying Categorical . CategoricalIndex , like Categorical , can only take on a limited , and usually fixed , number of possible values ( `categories` ) . With arguments `data`.", "question_id": 32114}
{"snippet": "pandas.CategoricalIndex(data=None, ordered=None)", "intent": "Index based on an underlying Categorical . With arguments `data`, `ordered`.", "question_id": 32115}
{"snippet": "pandas.CategoricalIndex(data=None, dtype=None)", "intent": "Index based on an underlying Categorical . With arguments `data`, `dtype`.", "question_id": 32116}
{"snippet": "CategoricalIndex.map(mapper)", "intent": "Map values using input correspondence ( a dict , Series , or function ) . With arguments `mapper`.", "question_id": 32117}
{"snippet": "CategoricalIndex.map(mapper)", "intent": "Map values using input correspondence ( a dict , Series , or function ) . With arguments `mapper`.", "question_id": 32118}
{"snippet": "CategoricalIndex.map(mapper)", "intent": "Map values using input correspondence ( a dict , Series , or function ) . With arguments `mapper`.", "question_id": 32119}
{"snippet": "CategoricalIndex.remove_categories(*args, **kwargs)", "intent": "Remove the specified categories . With arguments `*args`, `**kwargs`.", "question_id": 32120}
{"snippet": "CategoricalIndex.remove_categories(*args, **kwargs)", "intent": "Remove the specified categories . With arguments `*args`, `**kwargs`.", "question_id": 32121}
{"snippet": "CategoricalIndex.remove_categories(*args, **kwargs)", "intent": "Remove the specified categories . With arguments `*args`, `**kwargs`.", "question_id": 32122}
{"snippet": "CategoricalIndex.remove_unused_categories(*args, **kwargs)", "intent": "Remove categories which are not used . With arguments `*args`, `**kwargs`.", "question_id": 32123}
{"snippet": "CategoricalIndex.remove_unused_categories(*args, **kwargs)", "intent": "Remove categories which are not used . With arguments `*args`, `**kwargs`.", "question_id": 32124}
{"snippet": "CategoricalIndex.remove_unused_categories(*args, **kwargs)", "intent": "Remove categories which are not used . With arguments `*args`, `**kwargs`.", "question_id": 32125}
{"snippet": "CategoricalIndex.rename_categories(*args, **kwargs)", "intent": "Rename categories . With arguments `*args`, `**kwargs`.", "question_id": 32126}
{"snippet": "CategoricalIndex.rename_categories(*args, **kwargs)", "intent": "Rename categories . With arguments `*args`, `**kwargs`.", "question_id": 32127}
{"snippet": "CategoricalIndex.rename_categories(*args, **kwargs)", "intent": "Rename categories . With arguments `*args`, `**kwargs`.", "question_id": 32128}
{"snippet": "CategoricalIndex.reorder_categories(*args, **kwargs)", "intent": "Reorder categories as specified in new_categories . With arguments `*args`, `**kwargs`.", "question_id": 32129}
{"snippet": "CategoricalIndex.reorder_categories(*args, **kwargs)", "intent": "Reorder categories as specified in new_categories . With arguments `*args`, `**kwargs`.", "question_id": 32130}
{"snippet": "CategoricalIndex.reorder_categories(*args, **kwargs)", "intent": "Reorder categories as specified in new_categories . With arguments `*args`, `**kwargs`.", "question_id": 32131}
{"snippet": "CategoricalIndex.set_categories(*args, **kwargs)", "intent": "Set the categories to the specified new_categories . With arguments `*args`, `**kwargs`.", "question_id": 32132}
{"snippet": "CategoricalIndex.set_categories(*args, **kwargs)", "intent": "Set the categories to the specified new_categories . With arguments `*args`, `**kwargs`.", "question_id": 32133}
{"snippet": "CategoricalIndex.set_categories(*args, **kwargs)", "intent": "Set the categories to the specified new_categories . With arguments `*args`, `**kwargs`.", "question_id": 32134}
{"snippet": "DataFrame.__iter__()", "intent": "Iterate over info axis .", "question_id": 32135}
{"snippet": "DataFrame.__iter__()", "intent": "Iterate over info axis .", "question_id": 32136}
{"snippet": "DataFrame.__iter__()", "intent": "Iterate over info axis .", "question_id": 32137}
{"snippet": "DataFrame.abs()", "intent": "Return a Series/DataFrame with absolute numeric value of each element .", "question_id": 32138}
{"snippet": "DataFrame.abs()", "intent": "Return a Series/DataFrame with absolute numeric value of each element .", "question_id": 32139}
{"snippet": "DataFrame.abs()", "intent": "Return a Series/DataFrame with absolute numeric value of each element .", "question_id": 32140}
{"snippet": "DataFrame.add(other)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator add ) .", "question_id": 32141}
{"snippet": "DataFrame.add(other, axis='columns')", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator add ) . Subtract a list and Series by `axis` with operator version .", "question_id": 32142}
{"snippet": "DataFrame.add(other, level=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator add ) . Divide by a MultiIndex by `level` .", "question_id": 32143}
{"snippet": "DataFrame.add(other, fill_value=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator add ) . Equivalent to dataframe + other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32144}
{"snippet": "DataFrame.add(other, axis='columns', level=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator add ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 32145}
{"snippet": "DataFrame.add(other, axis='columns', fill_value=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator add ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe + other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32146}
{"snippet": "DataFrame.add(other, level=None, fill_value=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator add ) . Divide by a MultiIndex by `level` . Equivalent to dataframe + other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32147}
{"snippet": "DataFrame.add(other, axis='columns', level=None, fill_value=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator add ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe + other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32148}
{"snippet": "DataFrame.add(other)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator add ) .", "question_id": 32149}
{"snippet": "DataFrame.add(other, axis='columns')", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator add ) . Subtract a list and Series by `axis` with operator version .", "question_id": 32150}
{"snippet": "DataFrame.add(other, level=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator add ) . Divide by a MultiIndex by `level` .", "question_id": 32151}
{"snippet": "DataFrame.add(other, fill_value=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator add ) . Equivalent to dataframe + other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32152}
{"snippet": "DataFrame.add(other, axis='columns', level=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator add ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 32153}
{"snippet": "DataFrame.add(other, axis='columns', fill_value=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator add ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe + other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32154}
{"snippet": "DataFrame.add(other, level=None, fill_value=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator add ) . Divide by a MultiIndex by `level` . Equivalent to dataframe + other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32155}
{"snippet": "DataFrame.add(other, axis='columns', level=None, fill_value=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator add ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe + other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32156}
{"snippet": "DataFrame.add(other)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator add ) .", "question_id": 32157}
{"snippet": "DataFrame.add(other, axis='columns')", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator add ) . Subtract a list and Series by `axis` with operator version .", "question_id": 32158}
{"snippet": "DataFrame.add(other, level=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator add ) . Divide by a MultiIndex by `level` .", "question_id": 32159}
{"snippet": "DataFrame.add(other, fill_value=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator add ) . Equivalent to dataframe + other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32160}
{"snippet": "DataFrame.add(other, axis='columns', level=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator add ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 32161}
{"snippet": "DataFrame.add(other, axis='columns', fill_value=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator add ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe + other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32162}
{"snippet": "DataFrame.add(other, level=None, fill_value=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator add ) . Divide by a MultiIndex by `level` . Equivalent to dataframe + other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32163}
{"snippet": "DataFrame.add(other, axis='columns', level=None, fill_value=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator add ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe + other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32164}
{"snippet": "DataFrame.add_prefix(prefix)", "intent": "Prefix labels with string `prefix` .", "question_id": 32165}
{"snippet": "DataFrame.add_prefix(prefix)", "intent": "Prefix labels with string `prefix` .", "question_id": 32166}
{"snippet": "DataFrame.add_prefix(prefix)", "intent": "Prefix labels with string `prefix` .", "question_id": 32167}
{"snippet": "DataFrame.add_suffix(suffix)", "intent": "Suffix labels with string `suffix` .", "question_id": 32168}
{"snippet": "DataFrame.add_suffix(suffix)", "intent": "Suffix labels with string `suffix` .", "question_id": 32169}
{"snippet": "DataFrame.add_suffix(suffix)", "intent": "Suffix labels with string `suffix` .", "question_id": 32170}
{"snippet": "DataFrame.agg(*args, **kwargs)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32171}
{"snippet": "DataFrame.agg(*args, **kwargs, func=None)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`, `func`.", "question_id": 32172}
{"snippet": "DataFrame.agg(*args, **kwargs, axis=0)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32173}
{"snippet": "DataFrame.agg(*args, **kwargs, func=None, axis=0)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`, `func`.", "question_id": 32174}
{"snippet": "DataFrame.agg(*args, **kwargs)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32175}
{"snippet": "DataFrame.agg(*args, **kwargs, func=None)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`, `func`.", "question_id": 32176}
{"snippet": "DataFrame.agg(*args, **kwargs, axis=0)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32177}
{"snippet": "DataFrame.agg(*args, **kwargs, func=None, axis=0)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`, `func`.", "question_id": 32178}
{"snippet": "DataFrame.agg(*args, **kwargs)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32179}
{"snippet": "DataFrame.agg(*args, **kwargs, func=None)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`, `func`.", "question_id": 32180}
{"snippet": "DataFrame.agg(*args, **kwargs, axis=0)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32181}
{"snippet": "DataFrame.agg(*args, **kwargs, func=None, axis=0)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`, `func`.", "question_id": 32182}
{"snippet": "DataFrame.aggregate(*args, **kwargs)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32183}
{"snippet": "DataFrame.aggregate(*args, **kwargs, func=None)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`, `func`.", "question_id": 32184}
{"snippet": "DataFrame.aggregate(*args, **kwargs, axis=0)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32185}
{"snippet": "DataFrame.aggregate(*args, **kwargs, func=None, axis=0)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`, `func`.", "question_id": 32186}
{"snippet": "DataFrame.aggregate(*args, **kwargs)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32187}
{"snippet": "DataFrame.aggregate(*args, **kwargs, func=None)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`, `func`.", "question_id": 32188}
{"snippet": "DataFrame.aggregate(*args, **kwargs, axis=0)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32189}
{"snippet": "DataFrame.aggregate(*args, **kwargs, func=None, axis=0)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`, `func`.", "question_id": 32190}
{"snippet": "DataFrame.aggregate(*args, **kwargs)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32191}
{"snippet": "DataFrame.aggregate(*args, **kwargs, func=None)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`, `func`.", "question_id": 32192}
{"snippet": "DataFrame.aggregate(*args, **kwargs, axis=0)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32193}
{"snippet": "DataFrame.aggregate(*args, **kwargs, func=None, axis=0)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`, `func`.", "question_id": 32194}
{"snippet": "DataFrame.align(other)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`.", "question_id": 32195}
{"snippet": "DataFrame.align(other, join='outer')", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`.", "question_id": 32196}
{"snippet": "DataFrame.align(other, axis=None)", "intent": "Align two objects on their axes with the specified `join` `method` . Join method is specified for each `axis` Index . With arguments `other`.", "question_id": 32197}
{"snippet": "DataFrame.align(other, level=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `level`.", "question_id": 32198}
{"snippet": "DataFrame.align(other, copy=True)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `copy`.", "question_id": 32199}
{"snippet": "DataFrame.align(other, fill_value=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `fill_value`.", "question_id": 32200}
{"snippet": "DataFrame.align(other, method=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`.", "question_id": 32201}
{"snippet": "DataFrame.align(other, limit=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `limit`.", "question_id": 32202}
{"snippet": "DataFrame.align(other, fill_axis=0)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `fill_axis`.", "question_id": 32203}
{"snippet": "DataFrame.align(other, broadcast_axis=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `broadcast_axis`.", "question_id": 32204}
{"snippet": "DataFrame.align(other)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`.", "question_id": 32205}
{"snippet": "DataFrame.align(other, join='outer')", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`.", "question_id": 32206}
{"snippet": "DataFrame.align(other, axis=None)", "intent": "Align two objects on their axes with the specified `join` `method` . Join method is specified for each `axis` Index . With arguments `other`.", "question_id": 32207}
{"snippet": "DataFrame.align(other, level=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `level`.", "question_id": 32208}
{"snippet": "DataFrame.align(other, copy=True)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `copy`.", "question_id": 32209}
{"snippet": "DataFrame.align(other, fill_value=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `fill_value`.", "question_id": 32210}
{"snippet": "DataFrame.align(other, method=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`.", "question_id": 32211}
{"snippet": "DataFrame.align(other, limit=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `limit`.", "question_id": 32212}
{"snippet": "DataFrame.align(other, fill_axis=0)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `fill_axis`.", "question_id": 32213}
{"snippet": "DataFrame.align(other, broadcast_axis=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `broadcast_axis`.", "question_id": 32214}
{"snippet": "DataFrame.align(other)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`.", "question_id": 32215}
{"snippet": "DataFrame.align(other, join='outer')", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`.", "question_id": 32216}
{"snippet": "DataFrame.align(other, axis=None)", "intent": "Align two objects on their axes with the specified `join` `method` . Join method is specified for each `axis` Index . With arguments `other`.", "question_id": 32217}
{"snippet": "DataFrame.align(other, level=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `level`.", "question_id": 32218}
{"snippet": "DataFrame.align(other, copy=True)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `copy`.", "question_id": 32219}
{"snippet": "DataFrame.align(other, fill_value=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `fill_value`.", "question_id": 32220}
{"snippet": "DataFrame.align(other, method=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`.", "question_id": 32221}
{"snippet": "DataFrame.align(other, limit=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `limit`.", "question_id": 32222}
{"snippet": "DataFrame.align(other, fill_axis=0)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `fill_axis`.", "question_id": 32223}
{"snippet": "DataFrame.align(other, broadcast_axis=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `broadcast_axis`.", "question_id": 32224}
{"snippet": "DataFrame.all(**kwargs)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`.", "question_id": 32225}
{"snippet": "DataFrame.all(**kwargs, axis=0)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`.", "question_id": 32226}
{"snippet": "DataFrame.all(**kwargs, bool_only=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`.", "question_id": 32227}
{"snippet": "DataFrame.all(**kwargs, skipna=True)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 32228}
{"snippet": "DataFrame.all(**kwargs, level=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `level`.", "question_id": 32229}
{"snippet": "DataFrame.all(**kwargs, axis=0, bool_only=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`.", "question_id": 32230}
{"snippet": "DataFrame.all(**kwargs, axis=0, skipna=True)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 32231}
{"snippet": "DataFrame.all(**kwargs, axis=0, level=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `level`.", "question_id": 32232}
{"snippet": "DataFrame.all(**kwargs, bool_only=None, skipna=True)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`, `skipna`.", "question_id": 32233}
{"snippet": "DataFrame.all(**kwargs, bool_only=None, level=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`, `level`.", "question_id": 32234}
{"snippet": "DataFrame.all(**kwargs)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`.", "question_id": 32235}
{"snippet": "DataFrame.all(**kwargs, axis=0)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`.", "question_id": 32236}
{"snippet": "DataFrame.all(**kwargs, bool_only=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`.", "question_id": 32237}
{"snippet": "DataFrame.all(**kwargs, skipna=True)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 32238}
{"snippet": "DataFrame.all(**kwargs, level=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `level`.", "question_id": 32239}
{"snippet": "DataFrame.all(**kwargs, axis=0, bool_only=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`.", "question_id": 32240}
{"snippet": "DataFrame.all(**kwargs, axis=0, skipna=True)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 32241}
{"snippet": "DataFrame.all(**kwargs, axis=0, level=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `level`.", "question_id": 32242}
{"snippet": "DataFrame.all(**kwargs, bool_only=None, skipna=True)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`, `skipna`.", "question_id": 32243}
{"snippet": "DataFrame.all(**kwargs, bool_only=None, level=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`, `level`.", "question_id": 32244}
{"snippet": "DataFrame.all(**kwargs)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`.", "question_id": 32245}
{"snippet": "DataFrame.all(**kwargs, axis=0)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`.", "question_id": 32246}
{"snippet": "DataFrame.all(**kwargs, bool_only=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`.", "question_id": 32247}
{"snippet": "DataFrame.all(**kwargs, skipna=True)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 32248}
{"snippet": "DataFrame.all(**kwargs, level=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `level`.", "question_id": 32249}
{"snippet": "DataFrame.all(**kwargs, axis=0, bool_only=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`.", "question_id": 32250}
{"snippet": "DataFrame.all(**kwargs, axis=0, skipna=True)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 32251}
{"snippet": "DataFrame.all(**kwargs, axis=0, level=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `level`.", "question_id": 32252}
{"snippet": "DataFrame.all(**kwargs, bool_only=None, skipna=True)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`, `skipna`.", "question_id": 32253}
{"snippet": "DataFrame.all(**kwargs, bool_only=None, level=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`, `level`.", "question_id": 32254}
{"snippet": "DataFrame.any(**kwargs)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`.", "question_id": 32255}
{"snippet": "DataFrame.any(**kwargs, axis=0)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`.", "question_id": 32256}
{"snippet": "DataFrame.any(**kwargs, bool_only=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`.", "question_id": 32257}
{"snippet": "DataFrame.any(**kwargs, skipna=True)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 32258}
{"snippet": "DataFrame.any(**kwargs, level=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `level`.", "question_id": 32259}
{"snippet": "DataFrame.any(**kwargs, axis=0, bool_only=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`.", "question_id": 32260}
{"snippet": "DataFrame.any(**kwargs, axis=0, skipna=True)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 32261}
{"snippet": "DataFrame.any(**kwargs, axis=0, level=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `level`.", "question_id": 32262}
{"snippet": "DataFrame.any(**kwargs, bool_only=None, skipna=True)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`, `skipna`.", "question_id": 32263}
{"snippet": "DataFrame.any(**kwargs, bool_only=None, level=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`, `level`.", "question_id": 32264}
{"snippet": "DataFrame.any(**kwargs)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`.", "question_id": 32265}
{"snippet": "DataFrame.any(**kwargs, axis=0)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`.", "question_id": 32266}
{"snippet": "DataFrame.any(**kwargs, bool_only=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`.", "question_id": 32267}
{"snippet": "DataFrame.any(**kwargs, skipna=True)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 32268}
{"snippet": "DataFrame.any(**kwargs, level=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `level`.", "question_id": 32269}
{"snippet": "DataFrame.any(**kwargs, axis=0, bool_only=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`.", "question_id": 32270}
{"snippet": "DataFrame.any(**kwargs, axis=0, skipna=True)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 32271}
{"snippet": "DataFrame.any(**kwargs, axis=0, level=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `level`.", "question_id": 32272}
{"snippet": "DataFrame.any(**kwargs, bool_only=None, skipna=True)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`, `skipna`.", "question_id": 32273}
{"snippet": "DataFrame.any(**kwargs, bool_only=None, level=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`, `level`.", "question_id": 32274}
{"snippet": "DataFrame.any(**kwargs)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`.", "question_id": 32275}
{"snippet": "DataFrame.any(**kwargs, axis=0)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`.", "question_id": 32276}
{"snippet": "DataFrame.any(**kwargs, bool_only=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`.", "question_id": 32277}
{"snippet": "DataFrame.any(**kwargs, skipna=True)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 32278}
{"snippet": "DataFrame.any(**kwargs, level=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `level`.", "question_id": 32279}
{"snippet": "DataFrame.any(**kwargs, axis=0, bool_only=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`.", "question_id": 32280}
{"snippet": "DataFrame.any(**kwargs, axis=0, skipna=True)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 32281}
{"snippet": "DataFrame.any(**kwargs, axis=0, level=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `level`.", "question_id": 32282}
{"snippet": "DataFrame.any(**kwargs, bool_only=None, skipna=True)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`, `skipna`.", "question_id": 32283}
{"snippet": "DataFrame.any(**kwargs, bool_only=None, level=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`, `level`.", "question_id": 32284}
{"snippet": "DataFrame.append(other)", "intent": "Append rows of `other` to the end of caller , returning a new object .", "question_id": 32285}
{"snippet": "DataFrame.append(other, ignore_index=False)", "intent": "Append rows of `other` to the end of caller , returning a new object . With `ignore_index` set to True :", "question_id": 32286}
{"snippet": "DataFrame.append(other, verify_integrity=False)", "intent": "Append rows of `other` to the end of caller , returning a new object . With arguments `verify_integrity`.", "question_id": 32287}
{"snippet": "DataFrame.append(other, sort=False)", "intent": "Append rows of `other` to the end of caller , returning a new object . With arguments `sort`.", "question_id": 32288}
{"snippet": "DataFrame.append(other, ignore_index=False, verify_integrity=False)", "intent": "Append rows of `other` to the end of caller , returning a new object . With `ignore_index` set to True : With arguments `verify_integrity`.", "question_id": 32289}
{"snippet": "DataFrame.append(other, ignore_index=False, sort=False)", "intent": "Append rows of `other` to the end of caller , returning a new object . With `ignore_index` set to True : With arguments `sort`.", "question_id": 32290}
{"snippet": "DataFrame.append(other, verify_integrity=False, sort=False)", "intent": "Append rows of `other` to the end of caller , returning a new object . With arguments `verify_integrity`, `sort`.", "question_id": 32291}
{"snippet": "DataFrame.append(other, ignore_index=False, verify_integrity=False, sort=False)", "intent": "Append rows of `other` to the end of caller , returning a new object . With `ignore_index` set to True : With arguments `verify_integrity`, `sort`.", "question_id": 32292}
{"snippet": "DataFrame.append(other)", "intent": "Append rows of `other` to the end of caller , returning a new object .", "question_id": 32293}
{"snippet": "DataFrame.append(other, ignore_index=False)", "intent": "Append rows of `other` to the end of caller , returning a new object . With `ignore_index` set to True :", "question_id": 32294}
{"snippet": "DataFrame.append(other, verify_integrity=False)", "intent": "Append rows of `other` to the end of caller , returning a new object . With arguments `verify_integrity`.", "question_id": 32295}
{"snippet": "DataFrame.append(other, sort=False)", "intent": "Append rows of `other` to the end of caller , returning a new object . With arguments `sort`.", "question_id": 32296}
{"snippet": "DataFrame.append(other, ignore_index=False, verify_integrity=False)", "intent": "Append rows of `other` to the end of caller , returning a new object . With `ignore_index` set to True : With arguments `verify_integrity`.", "question_id": 32297}
{"snippet": "DataFrame.append(other, ignore_index=False, sort=False)", "intent": "Append rows of `other` to the end of caller , returning a new object . With `ignore_index` set to True : With arguments `sort`.", "question_id": 32298}
{"snippet": "DataFrame.append(other, verify_integrity=False, sort=False)", "intent": "Append rows of `other` to the end of caller , returning a new object . With arguments `verify_integrity`, `sort`.", "question_id": 32299}
{"snippet": "DataFrame.append(other, ignore_index=False, verify_integrity=False, sort=False)", "intent": "Append rows of `other` to the end of caller , returning a new object . With `ignore_index` set to True : With arguments `verify_integrity`, `sort`.", "question_id": 32300}
{"snippet": "DataFrame.append(other)", "intent": "Append rows of `other` to the end of caller , returning a new object .", "question_id": 32301}
{"snippet": "DataFrame.append(other, ignore_index=False)", "intent": "Append rows of `other` to the end of caller , returning a new object . With `ignore_index` set to True :", "question_id": 32302}
{"snippet": "DataFrame.append(other, verify_integrity=False)", "intent": "Append rows of `other` to the end of caller , returning a new object . With arguments `verify_integrity`.", "question_id": 32303}
{"snippet": "DataFrame.append(other, sort=False)", "intent": "Append rows of `other` to the end of caller , returning a new object . With arguments `sort`.", "question_id": 32304}
{"snippet": "DataFrame.append(other, ignore_index=False, verify_integrity=False)", "intent": "Append rows of `other` to the end of caller , returning a new object . With `ignore_index` set to True : With arguments `verify_integrity`.", "question_id": 32305}
{"snippet": "DataFrame.append(other, ignore_index=False, sort=False)", "intent": "Append rows of `other` to the end of caller , returning a new object . With `ignore_index` set to True : With arguments `sort`.", "question_id": 32306}
{"snippet": "DataFrame.append(other, verify_integrity=False, sort=False)", "intent": "Append rows of `other` to the end of caller , returning a new object . With arguments `verify_integrity`, `sort`.", "question_id": 32307}
{"snippet": "DataFrame.append(other, ignore_index=False, verify_integrity=False, sort=False)", "intent": "Append rows of `other` to the end of caller , returning a new object . With `ignore_index` set to True : With arguments `verify_integrity`, `sort`.", "question_id": 32308}
{"snippet": "DataFrame.apply(func, **kwargs)", "intent": "Apply a function along an `axis` of the DataFrame . With arguments `func`, `**kwargs`.", "question_id": 32309}
{"snippet": "DataFrame.apply(func, **kwargs, axis=0)", "intent": "Apply a function along an `axis` of the DataFrame . With arguments `func`, `**kwargs`.", "question_id": 32310}
{"snippet": "DataFrame.apply(func, **kwargs, raw=False)", "intent": "Apply a function along an `axis` of the DataFrame . With arguments `func`, `**kwargs`, `raw`.", "question_id": 32311}
{"snippet": "DataFrame.apply(func, **kwargs, result_type=None)", "intent": "Apply a function along an `axis` of the DataFrame . Otherwise , it depends on the `result_type` argument . With arguments `func`, `**kwargs`.", "question_id": 32312}
{"snippet": "DataFrame.apply(func, **kwargs, args=())", "intent": "Apply a function along an `axis` of the DataFrame . With arguments `func`, `**kwargs`, `args`.", "question_id": 32313}
{"snippet": "DataFrame.apply(func, **kwargs, axis=0, raw=False)", "intent": "Apply a function along an `axis` of the DataFrame . With arguments `func`, `**kwargs`, `raw`.", "question_id": 32314}
{"snippet": "DataFrame.apply(func, **kwargs, axis=0, result_type=None)", "intent": "Apply a function along an `axis` of the DataFrame . Otherwise , it depends on the `result_type` argument . With arguments `func`, `**kwargs`.", "question_id": 32315}
{"snippet": "DataFrame.apply(func, **kwargs, axis=0, args=())", "intent": "Apply a function along an `axis` of the DataFrame . With arguments `func`, `**kwargs`, `args`.", "question_id": 32316}
{"snippet": "DataFrame.apply(func, **kwargs, raw=False, result_type=None)", "intent": "Apply a function along an `axis` of the DataFrame . Otherwise , it depends on the `result_type` argument . With arguments `func`, `**kwargs`, `raw`.", "question_id": 32317}
{"snippet": "DataFrame.apply(func, **kwargs, raw=False, args=())", "intent": "Apply a function along an `axis` of the DataFrame . With arguments `func`, `**kwargs`, `raw`, `args`.", "question_id": 32318}
{"snippet": "DataFrame.apply(func, **kwargs)", "intent": "Apply a function along an `axis` of the DataFrame . With arguments `func`, `**kwargs`.", "question_id": 32319}
{"snippet": "DataFrame.apply(func, **kwargs, axis=0)", "intent": "Apply a function along an `axis` of the DataFrame . With arguments `func`, `**kwargs`.", "question_id": 32320}
{"snippet": "DataFrame.apply(func, **kwargs, raw=False)", "intent": "Apply a function along an `axis` of the DataFrame . With arguments `func`, `**kwargs`, `raw`.", "question_id": 32321}
{"snippet": "DataFrame.apply(func, **kwargs, result_type=None)", "intent": "Apply a function along an `axis` of the DataFrame . Otherwise , it depends on the `result_type` argument . With arguments `func`, `**kwargs`.", "question_id": 32322}
{"snippet": "DataFrame.apply(func, **kwargs, args=())", "intent": "Apply a function along an `axis` of the DataFrame . With arguments `func`, `**kwargs`, `args`.", "question_id": 32323}
{"snippet": "DataFrame.apply(func, **kwargs, axis=0, raw=False)", "intent": "Apply a function along an `axis` of the DataFrame . With arguments `func`, `**kwargs`, `raw`.", "question_id": 32324}
{"snippet": "DataFrame.apply(func, **kwargs, axis=0, result_type=None)", "intent": "Apply a function along an `axis` of the DataFrame . Otherwise , it depends on the `result_type` argument . With arguments `func`, `**kwargs`.", "question_id": 32325}
{"snippet": "DataFrame.apply(func, **kwargs, axis=0, args=())", "intent": "Apply a function along an `axis` of the DataFrame . With arguments `func`, `**kwargs`, `args`.", "question_id": 32326}
{"snippet": "DataFrame.apply(func, **kwargs, raw=False, result_type=None)", "intent": "Apply a function along an `axis` of the DataFrame . Otherwise , it depends on the `result_type` argument . With arguments `func`, `**kwargs`, `raw`.", "question_id": 32327}
{"snippet": "DataFrame.apply(func, **kwargs, raw=False, args=())", "intent": "Apply a function along an `axis` of the DataFrame . With arguments `func`, `**kwargs`, `raw`, `args`.", "question_id": 32328}
{"snippet": "DataFrame.apply(func, **kwargs)", "intent": "Apply a function along an `axis` of the DataFrame . With arguments `func`, `**kwargs`.", "question_id": 32329}
{"snippet": "DataFrame.apply(func, **kwargs, axis=0)", "intent": "Apply a function along an `axis` of the DataFrame . With arguments `func`, `**kwargs`.", "question_id": 32330}
{"snippet": "DataFrame.apply(func, **kwargs, raw=False)", "intent": "Apply a function along an `axis` of the DataFrame . With arguments `func`, `**kwargs`, `raw`.", "question_id": 32331}
{"snippet": "DataFrame.apply(func, **kwargs, result_type=None)", "intent": "Apply a function along an `axis` of the DataFrame . Otherwise , it depends on the `result_type` argument . With arguments `func`, `**kwargs`.", "question_id": 32332}
{"snippet": "DataFrame.apply(func, **kwargs, args=())", "intent": "Apply a function along an `axis` of the DataFrame . With arguments `func`, `**kwargs`, `args`.", "question_id": 32333}
{"snippet": "DataFrame.apply(func, **kwargs, axis=0, raw=False)", "intent": "Apply a function along an `axis` of the DataFrame . With arguments `func`, `**kwargs`, `raw`.", "question_id": 32334}
{"snippet": "DataFrame.apply(func, **kwargs, axis=0, result_type=None)", "intent": "Apply a function along an `axis` of the DataFrame . Otherwise , it depends on the `result_type` argument . With arguments `func`, `**kwargs`.", "question_id": 32335}
{"snippet": "DataFrame.apply(func, **kwargs, axis=0, args=())", "intent": "Apply a function along an `axis` of the DataFrame . With arguments `func`, `**kwargs`, `args`.", "question_id": 32336}
{"snippet": "DataFrame.apply(func, **kwargs, raw=False, result_type=None)", "intent": "Apply a function along an `axis` of the DataFrame . Otherwise , it depends on the `result_type` argument . With arguments `func`, `**kwargs`, `raw`.", "question_id": 32337}
{"snippet": "DataFrame.apply(func, **kwargs, raw=False, args=())", "intent": "Apply a function along an `axis` of the DataFrame . With arguments `func`, `**kwargs`, `raw`, `args`.", "question_id": 32338}
{"snippet": "DataFrame.applymap(func, **kwargs)", "intent": "Apply a function to a Dataframe elementwise . Note that a vectorized version of `func` often exists , which will be much faster . With arguments `**kwargs`.", "question_id": 32339}
{"snippet": "DataFrame.applymap(func, **kwargs, na_action=None)", "intent": "Apply a function to a Dataframe elementwise . Note that a vectorized version of `func` often exists , which will be much faster . With arguments `**kwargs`, `na_action`.", "question_id": 32340}
{"snippet": "DataFrame.applymap(func, **kwargs)", "intent": "Apply a function to a Dataframe elementwise . Note that a vectorized version of `func` often exists , which will be much faster . With arguments `**kwargs`.", "question_id": 32341}
{"snippet": "DataFrame.applymap(func, **kwargs, na_action=None)", "intent": "Apply a function to a Dataframe elementwise . Note that a vectorized version of `func` often exists , which will be much faster . With arguments `**kwargs`, `na_action`.", "question_id": 32342}
{"snippet": "DataFrame.applymap(func, **kwargs)", "intent": "Apply a function to a Dataframe elementwise . Note that a vectorized version of `func` often exists , which will be much faster . With arguments `**kwargs`.", "question_id": 32343}
{"snippet": "DataFrame.applymap(func, **kwargs, na_action=None)", "intent": "Apply a function to a Dataframe elementwise . Note that a vectorized version of `func` often exists , which will be much faster . With arguments `**kwargs`, `na_action`.", "question_id": 32344}
{"snippet": "DataFrame.asfreq(freq)", "intent": "Convert time series to specified frequency . With arguments `freq`.", "question_id": 32345}
{"snippet": "DataFrame.asfreq(freq, method=None)", "intent": "Convert time series to specified frequency . The values corresponding to any timesteps in the new index which were not present in the original index will be null ( NaN ) , unless a `method` for filling such unknowns is provided ( see the method parameter below ) . With arguments `freq`.", "question_id": 32346}
{"snippet": "DataFrame.asfreq(freq, how=None)", "intent": "Convert time series to specified frequency . With arguments `freq`, `how`.", "question_id": 32347}
{"snippet": "DataFrame.asfreq(freq, normalize=False)", "intent": "Convert time series to specified frequency . With arguments `freq`, `normalize`.", "question_id": 32348}
{"snippet": "DataFrame.asfreq(freq, fill_value=None)", "intent": "Convert time series to specified frequency . With arguments `freq`, `fill_value`.", "question_id": 32349}
{"snippet": "DataFrame.asfreq(freq, method=None, how=None)", "intent": "Convert time series to specified frequency . The values corresponding to any timesteps in the new index which were not present in the original index will be null ( NaN ) , unless a `method` for filling such unknowns is provided ( see the method parameter below ) . With arguments `freq`, `how`.", "question_id": 32350}
{"snippet": "DataFrame.asfreq(freq, method=None, normalize=False)", "intent": "Convert time series to specified frequency . The values corresponding to any timesteps in the new index which were not present in the original index will be null ( NaN ) , unless a `method` for filling such unknowns is provided ( see the method parameter below ) . With arguments `freq`, `normalize`.", "question_id": 32351}
{"snippet": "DataFrame.asfreq(freq, method=None, fill_value=None)", "intent": "Convert time series to specified frequency . The values corresponding to any timesteps in the new index which were not present in the original index will be null ( NaN ) , unless a `method` for filling such unknowns is provided ( see the method parameter below ) . With arguments `freq`, `fill_value`.", "question_id": 32352}
{"snippet": "DataFrame.asfreq(freq, how=None, normalize=False)", "intent": "Convert time series to specified frequency . With arguments `freq`, `how`, `normalize`.", "question_id": 32353}
{"snippet": "DataFrame.asfreq(freq, how=None, fill_value=None)", "intent": "Convert time series to specified frequency . With arguments `freq`, `how`, `fill_value`.", "question_id": 32354}
{"snippet": "DataFrame.asfreq(freq)", "intent": "Convert time series to specified frequency . With arguments `freq`.", "question_id": 32355}
{"snippet": "DataFrame.asfreq(freq, method=None)", "intent": "Convert time series to specified frequency . The values corresponding to any timesteps in the new index which were not present in the original index will be null ( NaN ) , unless a `method` for filling such unknowns is provided ( see the method parameter below ) . With arguments `freq`.", "question_id": 32356}
{"snippet": "DataFrame.asfreq(freq, how=None)", "intent": "Convert time series to specified frequency . With arguments `freq`, `how`.", "question_id": 32357}
{"snippet": "DataFrame.asfreq(freq, normalize=False)", "intent": "Convert time series to specified frequency . With arguments `freq`, `normalize`.", "question_id": 32358}
{"snippet": "DataFrame.asfreq(freq, fill_value=None)", "intent": "Convert time series to specified frequency . With arguments `freq`, `fill_value`.", "question_id": 32359}
{"snippet": "DataFrame.asfreq(freq, method=None, how=None)", "intent": "Convert time series to specified frequency . The values corresponding to any timesteps in the new index which were not present in the original index will be null ( NaN ) , unless a `method` for filling such unknowns is provided ( see the method parameter below ) . With arguments `freq`, `how`.", "question_id": 32360}
{"snippet": "DataFrame.asfreq(freq, method=None, normalize=False)", "intent": "Convert time series to specified frequency . The values corresponding to any timesteps in the new index which were not present in the original index will be null ( NaN ) , unless a `method` for filling such unknowns is provided ( see the method parameter below ) . With arguments `freq`, `normalize`.", "question_id": 32361}
{"snippet": "DataFrame.asfreq(freq, method=None, fill_value=None)", "intent": "Convert time series to specified frequency . The values corresponding to any timesteps in the new index which were not present in the original index will be null ( NaN ) , unless a `method` for filling such unknowns is provided ( see the method parameter below ) . With arguments `freq`, `fill_value`.", "question_id": 32362}
{"snippet": "DataFrame.asfreq(freq, how=None, normalize=False)", "intent": "Convert time series to specified frequency . With arguments `freq`, `how`, `normalize`.", "question_id": 32363}
{"snippet": "DataFrame.asfreq(freq, how=None, fill_value=None)", "intent": "Convert time series to specified frequency . With arguments `freq`, `how`, `fill_value`.", "question_id": 32364}
{"snippet": "DataFrame.asfreq(freq)", "intent": "Convert time series to specified frequency . With arguments `freq`.", "question_id": 32365}
{"snippet": "DataFrame.asfreq(freq, method=None)", "intent": "Convert time series to specified frequency . The values corresponding to any timesteps in the new index which were not present in the original index will be null ( NaN ) , unless a `method` for filling such unknowns is provided ( see the method parameter below ) . With arguments `freq`.", "question_id": 32366}
{"snippet": "DataFrame.asfreq(freq, how=None)", "intent": "Convert time series to specified frequency . With arguments `freq`, `how`.", "question_id": 32367}
{"snippet": "DataFrame.asfreq(freq, normalize=False)", "intent": "Convert time series to specified frequency . With arguments `freq`, `normalize`.", "question_id": 32368}
{"snippet": "DataFrame.asfreq(freq, fill_value=None)", "intent": "Convert time series to specified frequency . With arguments `freq`, `fill_value`.", "question_id": 32369}
{"snippet": "DataFrame.asfreq(freq, method=None, how=None)", "intent": "Convert time series to specified frequency . The values corresponding to any timesteps in the new index which were not present in the original index will be null ( NaN ) , unless a `method` for filling such unknowns is provided ( see the method parameter below ) . With arguments `freq`, `how`.", "question_id": 32370}
{"snippet": "DataFrame.asfreq(freq, method=None, normalize=False)", "intent": "Convert time series to specified frequency . The values corresponding to any timesteps in the new index which were not present in the original index will be null ( NaN ) , unless a `method` for filling such unknowns is provided ( see the method parameter below ) . With arguments `freq`, `normalize`.", "question_id": 32371}
{"snippet": "DataFrame.asfreq(freq, method=None, fill_value=None)", "intent": "Convert time series to specified frequency . The values corresponding to any timesteps in the new index which were not present in the original index will be null ( NaN ) , unless a `method` for filling such unknowns is provided ( see the method parameter below ) . With arguments `freq`, `fill_value`.", "question_id": 32372}
{"snippet": "DataFrame.asfreq(freq, how=None, normalize=False)", "intent": "Convert time series to specified frequency . With arguments `freq`, `how`, `normalize`.", "question_id": 32373}
{"snippet": "DataFrame.asfreq(freq, how=None, fill_value=None)", "intent": "Convert time series to specified frequency . With arguments `freq`, `how`, `fill_value`.", "question_id": 32374}
{"snippet": "DataFrame.asof(where)", "intent": "Return the last row ( s ) without any NaNs before `where` .", "question_id": 32375}
{"snippet": "DataFrame.asof(where, subset=None)", "intent": "Return the last row ( s ) without any NaNs before `where` . In case of a DataFrame , the last row without NaN considering only the `subset` of columns ( if not None )", "question_id": 32376}
{"snippet": "DataFrame.asof(where)", "intent": "Return the last row ( s ) without any NaNs before `where` .", "question_id": 32377}
{"snippet": "DataFrame.asof(where, subset=None)", "intent": "Return the last row ( s ) without any NaNs before `where` . In case of a DataFrame , the last row without NaN considering only the `subset` of columns ( if not None )", "question_id": 32378}
{"snippet": "DataFrame.asof(where)", "intent": "Return the last row ( s ) without any NaNs before `where` .", "question_id": 32379}
{"snippet": "DataFrame.asof(where, subset=None)", "intent": "Return the last row ( s ) without any NaNs before `where` . In case of a DataFrame , the last row without NaN considering only the `subset` of columns ( if not None )", "question_id": 32380}
{"snippet": "DataFrame.assign(**kwargs)", "intent": "Assign new columns to a DataFrame . With arguments `**kwargs`.", "question_id": 32381}
{"snippet": "DataFrame.assign(**kwargs)", "intent": "Assign new columns to a DataFrame . With arguments `**kwargs`.", "question_id": 32382}
{"snippet": "DataFrame.assign(**kwargs)", "intent": "Assign new columns to a DataFrame . With arguments `**kwargs`.", "question_id": 32383}
{"snippet": "DataFrame.astype(dtype)", "intent": "Cast a pandas object to a specified `dtype` dtype .", "question_id": 32384}
{"snippet": "DataFrame.astype(dtype, copy=True)", "intent": "Cast a pandas object to a specified `dtype` dtype . With arguments `copy`.", "question_id": 32385}
{"snippet": "DataFrame.astype(dtype, errors='raise')", "intent": "Cast a pandas object to a specified `dtype` dtype . With arguments `errors`.", "question_id": 32386}
{"snippet": "DataFrame.astype(dtype, copy=True, errors='raise')", "intent": "Cast a pandas object to a specified `dtype` dtype . With arguments `copy`, `errors`.", "question_id": 32387}
{"snippet": "DataFrame.astype(dtype)", "intent": "Cast a pandas object to a specified `dtype` dtype .", "question_id": 32388}
{"snippet": "DataFrame.astype(dtype, copy=True)", "intent": "Cast a pandas object to a specified `dtype` dtype . With arguments `copy`.", "question_id": 32389}
{"snippet": "DataFrame.astype(dtype, errors='raise')", "intent": "Cast a pandas object to a specified `dtype` dtype . With arguments `errors`.", "question_id": 32390}
{"snippet": "DataFrame.astype(dtype, copy=True, errors='raise')", "intent": "Cast a pandas object to a specified `dtype` dtype . With arguments `copy`, `errors`.", "question_id": 32391}
{"snippet": "DataFrame.astype(dtype)", "intent": "Cast a pandas object to a specified `dtype` dtype .", "question_id": 32392}
{"snippet": "DataFrame.astype(dtype, copy=True)", "intent": "Cast a pandas object to a specified `dtype` dtype . With arguments `copy`.", "question_id": 32393}
{"snippet": "DataFrame.astype(dtype, errors='raise')", "intent": "Cast a pandas object to a specified `dtype` dtype . With arguments `errors`.", "question_id": 32394}
{"snippet": "DataFrame.astype(dtype, copy=True, errors='raise')", "intent": "Cast a pandas object to a specified `dtype` dtype . With arguments `copy`, `errors`.", "question_id": 32395}
{"snippet": "DataFrame.at_time(time)", "intent": "Select values at particular `time` of day ( e.g. , 9:30AM ) .", "question_id": 32396}
{"snippet": "DataFrame.at_time(time, asof=False)", "intent": "Select values at particular `time` of day ( e.g. , 9:30AM ) . With arguments `asof`.", "question_id": 32397}
{"snippet": "DataFrame.at_time(time, axis=None)", "intent": "Select values at particular `time` of day ( e.g. , 9:30AM ) . With arguments `axis`.", "question_id": 32398}
{"snippet": "DataFrame.at_time(time, asof=False, axis=None)", "intent": "Select values at particular `time` of day ( e.g. , 9:30AM ) . With arguments `asof`, `axis`.", "question_id": 32399}
{"snippet": "DataFrame.at_time(time)", "intent": "Select values at particular `time` of day ( e.g. , 9:30AM ) .", "question_id": 32400}
{"snippet": "DataFrame.at_time(time, asof=False)", "intent": "Select values at particular `time` of day ( e.g. , 9:30AM ) . With arguments `asof`.", "question_id": 32401}
{"snippet": "DataFrame.at_time(time, axis=None)", "intent": "Select values at particular `time` of day ( e.g. , 9:30AM ) . With arguments `axis`.", "question_id": 32402}
{"snippet": "DataFrame.at_time(time, asof=False, axis=None)", "intent": "Select values at particular `time` of day ( e.g. , 9:30AM ) . With arguments `asof`, `axis`.", "question_id": 32403}
{"snippet": "DataFrame.at_time(time)", "intent": "Select values at particular `time` of day ( e.g. , 9:30AM ) .", "question_id": 32404}
{"snippet": "DataFrame.at_time(time, asof=False)", "intent": "Select values at particular `time` of day ( e.g. , 9:30AM ) . With arguments `asof`.", "question_id": 32405}
{"snippet": "DataFrame.at_time(time, axis=None)", "intent": "Select values at particular `time` of day ( e.g. , 9:30AM ) . With arguments `axis`.", "question_id": 32406}
{"snippet": "DataFrame.at_time(time, asof=False, axis=None)", "intent": "Select values at particular `time` of day ( e.g. , 9:30AM ) . With arguments `asof`, `axis`.", "question_id": 32407}
{"snippet": "DataFrame.backfill()", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' .", "question_id": 32408}
{"snippet": "DataFrame.backfill(axis=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`.", "question_id": 32409}
{"snippet": "DataFrame.backfill(inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`.", "question_id": 32410}
{"snippet": "DataFrame.backfill(limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `limit`.", "question_id": 32411}
{"snippet": "DataFrame.backfill(downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `downcast`.", "question_id": 32412}
{"snippet": "DataFrame.backfill(axis=None, inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `inplace`.", "question_id": 32413}
{"snippet": "DataFrame.backfill(axis=None, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `limit`.", "question_id": 32414}
{"snippet": "DataFrame.backfill(axis=None, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `downcast`.", "question_id": 32415}
{"snippet": "DataFrame.backfill(inplace=False, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`, `limit`.", "question_id": 32416}
{"snippet": "DataFrame.backfill(inplace=False, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`, `downcast`.", "question_id": 32417}
{"snippet": "DataFrame.backfill()", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' .", "question_id": 32418}
{"snippet": "DataFrame.backfill(axis=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`.", "question_id": 32419}
{"snippet": "DataFrame.backfill(inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`.", "question_id": 32420}
{"snippet": "DataFrame.backfill(limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `limit`.", "question_id": 32421}
{"snippet": "DataFrame.backfill(downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `downcast`.", "question_id": 32422}
{"snippet": "DataFrame.backfill(axis=None, inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `inplace`.", "question_id": 32423}
{"snippet": "DataFrame.backfill(axis=None, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `limit`.", "question_id": 32424}
{"snippet": "DataFrame.backfill(axis=None, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `downcast`.", "question_id": 32425}
{"snippet": "DataFrame.backfill(inplace=False, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`, `limit`.", "question_id": 32426}
{"snippet": "DataFrame.backfill(inplace=False, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`, `downcast`.", "question_id": 32427}
{"snippet": "DataFrame.backfill()", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' .", "question_id": 32428}
{"snippet": "DataFrame.backfill(axis=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`.", "question_id": 32429}
{"snippet": "DataFrame.backfill(inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`.", "question_id": 32430}
{"snippet": "DataFrame.backfill(limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `limit`.", "question_id": 32431}
{"snippet": "DataFrame.backfill(downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `downcast`.", "question_id": 32432}
{"snippet": "DataFrame.backfill(axis=None, inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `inplace`.", "question_id": 32433}
{"snippet": "DataFrame.backfill(axis=None, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `limit`.", "question_id": 32434}
{"snippet": "DataFrame.backfill(axis=None, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `downcast`.", "question_id": 32435}
{"snippet": "DataFrame.backfill(inplace=False, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`, `limit`.", "question_id": 32436}
{"snippet": "DataFrame.backfill(inplace=False, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`, `downcast`.", "question_id": 32437}
{"snippet": "DataFrame.between_time(start_time, end_time)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times .", "question_id": 32438}
{"snippet": "DataFrame.between_time(start_time, end_time, include_start=True)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_start`.", "question_id": 32439}
{"snippet": "DataFrame.between_time(start_time, end_time, include_end=True)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_end`.", "question_id": 32440}
{"snippet": "DataFrame.between_time(start_time, end_time, axis=None)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `axis`.", "question_id": 32441}
{"snippet": "DataFrame.between_time(start_time, end_time, include_start=True, include_end=True)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_start`, `include_end`.", "question_id": 32442}
{"snippet": "DataFrame.between_time(start_time, end_time, include_start=True, axis=None)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_start`, `axis`.", "question_id": 32443}
{"snippet": "DataFrame.between_time(start_time, end_time, include_end=True, axis=None)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_end`, `axis`.", "question_id": 32444}
{"snippet": "DataFrame.between_time(start_time, end_time, include_start=True, include_end=True, axis=None)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_start`, `include_end`, `axis`.", "question_id": 32445}
{"snippet": "DataFrame.between_time(start_time, end_time)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times .", "question_id": 32446}
{"snippet": "DataFrame.between_time(start_time, end_time, include_start=True)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_start`.", "question_id": 32447}
{"snippet": "DataFrame.between_time(start_time, end_time, include_end=True)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_end`.", "question_id": 32448}
{"snippet": "DataFrame.between_time(start_time, end_time, axis=None)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `axis`.", "question_id": 32449}
{"snippet": "DataFrame.between_time(start_time, end_time, include_start=True, include_end=True)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_start`, `include_end`.", "question_id": 32450}
{"snippet": "DataFrame.between_time(start_time, end_time, include_start=True, axis=None)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_start`, `axis`.", "question_id": 32451}
{"snippet": "DataFrame.between_time(start_time, end_time, include_end=True, axis=None)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_end`, `axis`.", "question_id": 32452}
{"snippet": "DataFrame.between_time(start_time, end_time, include_start=True, include_end=True, axis=None)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_start`, `include_end`, `axis`.", "question_id": 32453}
{"snippet": "DataFrame.between_time(start_time, end_time)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times .", "question_id": 32454}
{"snippet": "DataFrame.between_time(start_time, end_time, include_start=True)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_start`.", "question_id": 32455}
{"snippet": "DataFrame.between_time(start_time, end_time, include_end=True)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_end`.", "question_id": 32456}
{"snippet": "DataFrame.between_time(start_time, end_time, axis=None)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `axis`.", "question_id": 32457}
{"snippet": "DataFrame.between_time(start_time, end_time, include_start=True, include_end=True)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_start`, `include_end`.", "question_id": 32458}
{"snippet": "DataFrame.between_time(start_time, end_time, include_start=True, axis=None)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_start`, `axis`.", "question_id": 32459}
{"snippet": "DataFrame.between_time(start_time, end_time, include_end=True, axis=None)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_end`, `axis`.", "question_id": 32460}
{"snippet": "DataFrame.between_time(start_time, end_time, include_start=True, include_end=True, axis=None)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_start`, `include_end`, `axis`.", "question_id": 32461}
{"snippet": "DataFrame.bfill()", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' .", "question_id": 32462}
{"snippet": "DataFrame.bfill(axis=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`.", "question_id": 32463}
{"snippet": "DataFrame.bfill(inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`.", "question_id": 32464}
{"snippet": "DataFrame.bfill(limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `limit`.", "question_id": 32465}
{"snippet": "DataFrame.bfill(downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `downcast`.", "question_id": 32466}
{"snippet": "DataFrame.bfill(axis=None, inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `inplace`.", "question_id": 32467}
{"snippet": "DataFrame.bfill(axis=None, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `limit`.", "question_id": 32468}
{"snippet": "DataFrame.bfill(axis=None, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `downcast`.", "question_id": 32469}
{"snippet": "DataFrame.bfill(inplace=False, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`, `limit`.", "question_id": 32470}
{"snippet": "DataFrame.bfill(inplace=False, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`, `downcast`.", "question_id": 32471}
{"snippet": "DataFrame.bfill()", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' .", "question_id": 32472}
{"snippet": "DataFrame.bfill(axis=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`.", "question_id": 32473}
{"snippet": "DataFrame.bfill(inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`.", "question_id": 32474}
{"snippet": "DataFrame.bfill(limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `limit`.", "question_id": 32475}
{"snippet": "DataFrame.bfill(downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `downcast`.", "question_id": 32476}
{"snippet": "DataFrame.bfill(axis=None, inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `inplace`.", "question_id": 32477}
{"snippet": "DataFrame.bfill(axis=None, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `limit`.", "question_id": 32478}
{"snippet": "DataFrame.bfill(axis=None, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `downcast`.", "question_id": 32479}
{"snippet": "DataFrame.bfill(inplace=False, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`, `limit`.", "question_id": 32480}
{"snippet": "DataFrame.bfill(inplace=False, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`, `downcast`.", "question_id": 32481}
{"snippet": "DataFrame.bfill()", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' .", "question_id": 32482}
{"snippet": "DataFrame.bfill(axis=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`.", "question_id": 32483}
{"snippet": "DataFrame.bfill(inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`.", "question_id": 32484}
{"snippet": "DataFrame.bfill(limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `limit`.", "question_id": 32485}
{"snippet": "DataFrame.bfill(downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `downcast`.", "question_id": 32486}
{"snippet": "DataFrame.bfill(axis=None, inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `inplace`.", "question_id": 32487}
{"snippet": "DataFrame.bfill(axis=None, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `limit`.", "question_id": 32488}
{"snippet": "DataFrame.bfill(axis=None, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `downcast`.", "question_id": 32489}
{"snippet": "DataFrame.bfill(inplace=False, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`, `limit`.", "question_id": 32490}
{"snippet": "DataFrame.bfill(inplace=False, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`, `downcast`.", "question_id": 32491}
{"snippet": "DataFrame.bool()", "intent": "Return the bool of a single element Series or DataFrame .", "question_id": 32492}
{"snippet": "DataFrame.bool()", "intent": "Return the bool of a single element Series or DataFrame .", "question_id": 32493}
{"snippet": "DataFrame.bool()", "intent": "Return the bool of a single element Series or DataFrame .", "question_id": 32494}
{"snippet": "DataFrame.boxplot(**kwargs)", "intent": "Make a box plot from DataFrame columns . With arguments `**kwargs`.", "question_id": 32495}
{"snippet": "DataFrame.boxplot(**kwargs, column=None)", "intent": "Make a box plot from DataFrame columns . Boxplots can be created for every `column` in the dataframe by df.boxplot ( ) or indicating the columns to be used : With arguments `**kwargs`.", "question_id": 32496}
{"snippet": "DataFrame.boxplot(**kwargs, by=None)", "intent": "Make a box plot from DataFrame columns . Make a box-and-whisker plot from DataFrame columns , optionally grouped `by` some other columns . With arguments `**kwargs`.", "question_id": 32497}
{"snippet": "DataFrame.boxplot(**kwargs, ax=None)", "intent": "Make a box plot from DataFrame columns . With arguments `**kwargs`, `ax`.", "question_id": 32498}
{"snippet": "DataFrame.boxplot(**kwargs, fontsize=None)", "intent": "Make a box plot from DataFrame columns . rot=45 ) or changing the `fontsize` ( i.e . With arguments `**kwargs`.", "question_id": 32499}
{"snippet": "DataFrame.boxplot(**kwargs, rot=0)", "intent": "Make a box plot from DataFrame columns . With arguments `**kwargs`, `rot`.", "question_id": 32500}
{"snippet": "DataFrame.boxplot(**kwargs, grid=True)", "intent": "Make a box plot from DataFrame columns . Additional formatting can be done to the boxplot , like suppressing the `grid` ( grid=False ) , rotating the labels in the x-axis ( i.e . With arguments `**kwargs`.", "question_id": 32501}
{"snippet": "DataFrame.boxplot(**kwargs, figsize=None)", "intent": "Make a box plot from DataFrame columns . With arguments `**kwargs`, `figsize`.", "question_id": 32502}
{"snippet": "DataFrame.boxplot(**kwargs, layout=None)", "intent": "Make a box plot from DataFrame columns . The `layout` of boxplot can be adjusted giving a tuple to layout : With arguments `**kwargs`.", "question_id": 32503}
{"snippet": "DataFrame.boxplot(**kwargs, return_type=None)", "intent": "Make a box plot from DataFrame columns . The return type depends on the `return_type` parameter : With arguments `**kwargs`.", "question_id": 32504}
{"snippet": "DataFrame.boxplot(**kwargs)", "intent": "Make a box plot from DataFrame columns . With arguments `**kwargs`.", "question_id": 32505}
{"snippet": "DataFrame.boxplot(**kwargs, column=None)", "intent": "Make a box plot from DataFrame columns . Boxplots can be created for every `column` in the dataframe by df.boxplot ( ) or indicating the columns to be used : With arguments `**kwargs`.", "question_id": 32506}
{"snippet": "DataFrame.boxplot(**kwargs, by=None)", "intent": "Make a box plot from DataFrame columns . Make a box-and-whisker plot from DataFrame columns , optionally grouped `by` some other columns . With arguments `**kwargs`.", "question_id": 32507}
{"snippet": "DataFrame.boxplot(**kwargs, ax=None)", "intent": "Make a box plot from DataFrame columns . With arguments `**kwargs`, `ax`.", "question_id": 32508}
{"snippet": "DataFrame.boxplot(**kwargs, fontsize=None)", "intent": "Make a box plot from DataFrame columns . rot=45 ) or changing the `fontsize` ( i.e . With arguments `**kwargs`.", "question_id": 32509}
{"snippet": "DataFrame.boxplot(**kwargs, rot=0)", "intent": "Make a box plot from DataFrame columns . With arguments `**kwargs`, `rot`.", "question_id": 32510}
{"snippet": "DataFrame.boxplot(**kwargs, grid=True)", "intent": "Make a box plot from DataFrame columns . Additional formatting can be done to the boxplot , like suppressing the `grid` ( grid=False ) , rotating the labels in the x-axis ( i.e . With arguments `**kwargs`.", "question_id": 32511}
{"snippet": "DataFrame.boxplot(**kwargs, figsize=None)", "intent": "Make a box plot from DataFrame columns . With arguments `**kwargs`, `figsize`.", "question_id": 32512}
{"snippet": "DataFrame.boxplot(**kwargs, layout=None)", "intent": "Make a box plot from DataFrame columns . The `layout` of boxplot can be adjusted giving a tuple to layout : With arguments `**kwargs`.", "question_id": 32513}
{"snippet": "DataFrame.boxplot(**kwargs, return_type=None)", "intent": "Make a box plot from DataFrame columns . The return type depends on the `return_type` parameter : With arguments `**kwargs`.", "question_id": 32514}
{"snippet": "DataFrame.boxplot(**kwargs)", "intent": "Make a box plot from DataFrame columns . With arguments `**kwargs`.", "question_id": 32515}
{"snippet": "DataFrame.boxplot(**kwargs, column=None)", "intent": "Make a box plot from DataFrame columns . Boxplots can be created for every `column` in the dataframe by df.boxplot ( ) or indicating the columns to be used : With arguments `**kwargs`.", "question_id": 32516}
{"snippet": "DataFrame.boxplot(**kwargs, by=None)", "intent": "Make a box plot from DataFrame columns . Make a box-and-whisker plot from DataFrame columns , optionally grouped `by` some other columns . With arguments `**kwargs`.", "question_id": 32517}
{"snippet": "DataFrame.boxplot(**kwargs, ax=None)", "intent": "Make a box plot from DataFrame columns . With arguments `**kwargs`, `ax`.", "question_id": 32518}
{"snippet": "DataFrame.boxplot(**kwargs, fontsize=None)", "intent": "Make a box plot from DataFrame columns . rot=45 ) or changing the `fontsize` ( i.e . With arguments `**kwargs`.", "question_id": 32519}
{"snippet": "DataFrame.boxplot(**kwargs, rot=0)", "intent": "Make a box plot from DataFrame columns . With arguments `**kwargs`, `rot`.", "question_id": 32520}
{"snippet": "DataFrame.boxplot(**kwargs, grid=True)", "intent": "Make a box plot from DataFrame columns . Additional formatting can be done to the boxplot , like suppressing the `grid` ( grid=False ) , rotating the labels in the x-axis ( i.e . With arguments `**kwargs`.", "question_id": 32521}
{"snippet": "DataFrame.boxplot(**kwargs, figsize=None)", "intent": "Make a box plot from DataFrame columns . With arguments `**kwargs`, `figsize`.", "question_id": 32522}
{"snippet": "DataFrame.boxplot(**kwargs, layout=None)", "intent": "Make a box plot from DataFrame columns . The `layout` of boxplot can be adjusted giving a tuple to layout : With arguments `**kwargs`.", "question_id": 32523}
{"snippet": "DataFrame.boxplot(**kwargs, return_type=None)", "intent": "Make a box plot from DataFrame columns . The return type depends on the `return_type` parameter : With arguments `**kwargs`.", "question_id": 32524}
{"snippet": "DataFrame.clip(*args, **kwargs)", "intent": "Trim values at input threshold ( s ) . With arguments `*args`, `**kwargs`.", "question_id": 32525}
{"snippet": "DataFrame.clip(*args, **kwargs, lower=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`.", "question_id": 32526}
{"snippet": "DataFrame.clip(*args, **kwargs, upper=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`.", "question_id": 32527}
{"snippet": "DataFrame.clip(*args, **kwargs, axis=None)", "intent": "Trim values at input threshold ( s ) . Thresholds can be singular values or array like , and in the latter case the clipping is performed element-wise in the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32528}
{"snippet": "DataFrame.clip(*args, **kwargs, inplace=False)", "intent": "Trim values at input threshold ( s ) . With arguments `*args`, `**kwargs`, `inplace`.", "question_id": 32529}
{"snippet": "DataFrame.clip(*args, **kwargs, lower=None, upper=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`.", "question_id": 32530}
{"snippet": "DataFrame.clip(*args, **kwargs, lower=None, axis=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : Thresholds can be singular values or array like , and in the latter case the clipping is performed element-wise in the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32531}
{"snippet": "DataFrame.clip(*args, **kwargs, lower=None, inplace=False)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`, `inplace`.", "question_id": 32532}
{"snippet": "DataFrame.clip(*args, **kwargs, upper=None, axis=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : Thresholds can be singular values or array like , and in the latter case the clipping is performed element-wise in the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32533}
{"snippet": "DataFrame.clip(*args, **kwargs, upper=None, inplace=False)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`, `inplace`.", "question_id": 32534}
{"snippet": "DataFrame.clip(*args, **kwargs)", "intent": "Trim values at input threshold ( s ) . With arguments `*args`, `**kwargs`.", "question_id": 32535}
{"snippet": "DataFrame.clip(*args, **kwargs, lower=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`.", "question_id": 32536}
{"snippet": "DataFrame.clip(*args, **kwargs, upper=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`.", "question_id": 32537}
{"snippet": "DataFrame.clip(*args, **kwargs, axis=None)", "intent": "Trim values at input threshold ( s ) . Thresholds can be singular values or array like , and in the latter case the clipping is performed element-wise in the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32538}
{"snippet": "DataFrame.clip(*args, **kwargs, inplace=False)", "intent": "Trim values at input threshold ( s ) . With arguments `*args`, `**kwargs`, `inplace`.", "question_id": 32539}
{"snippet": "DataFrame.clip(*args, **kwargs, lower=None, upper=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`.", "question_id": 32540}
{"snippet": "DataFrame.clip(*args, **kwargs, lower=None, axis=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : Thresholds can be singular values or array like , and in the latter case the clipping is performed element-wise in the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32541}
{"snippet": "DataFrame.clip(*args, **kwargs, lower=None, inplace=False)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`, `inplace`.", "question_id": 32542}
{"snippet": "DataFrame.clip(*args, **kwargs, upper=None, axis=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : Thresholds can be singular values or array like , and in the latter case the clipping is performed element-wise in the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32543}
{"snippet": "DataFrame.clip(*args, **kwargs, upper=None, inplace=False)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`, `inplace`.", "question_id": 32544}
{"snippet": "DataFrame.clip(*args, **kwargs)", "intent": "Trim values at input threshold ( s ) . With arguments `*args`, `**kwargs`.", "question_id": 32545}
{"snippet": "DataFrame.clip(*args, **kwargs, lower=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`.", "question_id": 32546}
{"snippet": "DataFrame.clip(*args, **kwargs, upper=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`.", "question_id": 32547}
{"snippet": "DataFrame.clip(*args, **kwargs, axis=None)", "intent": "Trim values at input threshold ( s ) . Thresholds can be singular values or array like , and in the latter case the clipping is performed element-wise in the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32548}
{"snippet": "DataFrame.clip(*args, **kwargs, inplace=False)", "intent": "Trim values at input threshold ( s ) . With arguments `*args`, `**kwargs`, `inplace`.", "question_id": 32549}
{"snippet": "DataFrame.clip(*args, **kwargs, lower=None, upper=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`.", "question_id": 32550}
{"snippet": "DataFrame.clip(*args, **kwargs, lower=None, axis=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : Thresholds can be singular values or array like , and in the latter case the clipping is performed element-wise in the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32551}
{"snippet": "DataFrame.clip(*args, **kwargs, lower=None, inplace=False)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`, `inplace`.", "question_id": 32552}
{"snippet": "DataFrame.clip(*args, **kwargs, upper=None, axis=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : Thresholds can be singular values or array like , and in the latter case the clipping is performed element-wise in the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32553}
{"snippet": "DataFrame.clip(*args, **kwargs, upper=None, inplace=False)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`, `inplace`.", "question_id": 32554}
{"snippet": "DataFrame.columns", "intent": "The column labels of the DataFrame.", "question_id": 32555}
{"snippet": "DataFrame.columns", "intent": "The column labels of the DataFrame.", "question_id": 32556}
{"snippet": "DataFrame.columns", "intent": "The column labels of the DataFrame.", "question_id": 32557}
{"snippet": "DataFrame.combine(other, func)", "intent": "Perform column-wise combine with another DataFrame . Combines a DataFrame with `other` DataFrame using `func` to element-wise combine columns .", "question_id": 32558}
{"snippet": "DataFrame.combine(other, func, fill_value=None)", "intent": "Perform column-wise combine with another DataFrame . Combines a DataFrame with `other` DataFrame using `func` to element-wise combine columns . Using `fill_value` fills Nones prior to passing the column to the merge function .", "question_id": 32559}
{"snippet": "DataFrame.combine(other, func, overwrite=True)", "intent": "Perform column-wise combine with another DataFrame . Combines a DataFrame with `other` DataFrame using `func` to element-wise combine columns . Example that demonstrates the use of `overwrite` and behavior when the axis differ between the dataframes .", "question_id": 32560}
{"snippet": "DataFrame.combine(other, func, fill_value=None, overwrite=True)", "intent": "Perform column-wise combine with another DataFrame . Combines a DataFrame with `other` DataFrame using `func` to element-wise combine columns . Using `fill_value` fills Nones prior to passing the column to the merge function . Example that demonstrates the use of `overwrite` and behavior when the axis differ between the dataframes .", "question_id": 32561}
{"snippet": "DataFrame.combine(other, func)", "intent": "Perform column-wise combine with another DataFrame . Combines a DataFrame with `other` DataFrame using `func` to element-wise combine columns .", "question_id": 32562}
{"snippet": "DataFrame.combine(other, func, fill_value=None)", "intent": "Perform column-wise combine with another DataFrame . Combines a DataFrame with `other` DataFrame using `func` to element-wise combine columns . Using `fill_value` fills Nones prior to passing the column to the merge function .", "question_id": 32563}
{"snippet": "DataFrame.combine(other, func, overwrite=True)", "intent": "Perform column-wise combine with another DataFrame . Combines a DataFrame with `other` DataFrame using `func` to element-wise combine columns . Example that demonstrates the use of `overwrite` and behavior when the axis differ between the dataframes .", "question_id": 32564}
{"snippet": "DataFrame.combine(other, func, fill_value=None, overwrite=True)", "intent": "Perform column-wise combine with another DataFrame . Combines a DataFrame with `other` DataFrame using `func` to element-wise combine columns . Using `fill_value` fills Nones prior to passing the column to the merge function . Example that demonstrates the use of `overwrite` and behavior when the axis differ between the dataframes .", "question_id": 32565}
{"snippet": "DataFrame.combine(other, func)", "intent": "Perform column-wise combine with another DataFrame . Combines a DataFrame with `other` DataFrame using `func` to element-wise combine columns .", "question_id": 32566}
{"snippet": "DataFrame.combine(other, func, fill_value=None)", "intent": "Perform column-wise combine with another DataFrame . Combines a DataFrame with `other` DataFrame using `func` to element-wise combine columns . Using `fill_value` fills Nones prior to passing the column to the merge function .", "question_id": 32567}
{"snippet": "DataFrame.combine(other, func, overwrite=True)", "intent": "Perform column-wise combine with another DataFrame . Combines a DataFrame with `other` DataFrame using `func` to element-wise combine columns . Example that demonstrates the use of `overwrite` and behavior when the axis differ between the dataframes .", "question_id": 32568}
{"snippet": "DataFrame.combine(other, func, fill_value=None, overwrite=True)", "intent": "Perform column-wise combine with another DataFrame . Combines a DataFrame with `other` DataFrame using `func` to element-wise combine columns . Using `fill_value` fills Nones prior to passing the column to the merge function . Example that demonstrates the use of `overwrite` and behavior when the axis differ between the dataframes .", "question_id": 32569}
{"snippet": "DataFrame.combine_first(other)", "intent": "Update null elements with value in the same location in `other` .", "question_id": 32570}
{"snippet": "DataFrame.combine_first(other)", "intent": "Update null elements with value in the same location in `other` .", "question_id": 32571}
{"snippet": "DataFrame.combine_first(other)", "intent": "Update null elements with value in the same location in `other` .", "question_id": 32572}
{"snippet": "DataFrame.compare(other)", "intent": "Compare to another DataFrame and show the differences . With arguments `other`.", "question_id": 32573}
{"snippet": "DataFrame.compare(other, align_axis=1)", "intent": "Compare to another DataFrame and show the differences . With arguments `other`, `align_axis`.", "question_id": 32574}
{"snippet": "DataFrame.compare(other, keep_shape=False)", "intent": "Compare to another DataFrame and show the differences . With arguments `other`, `keep_shape`.", "question_id": 32575}
{"snippet": "DataFrame.compare(other, keep_equal=False)", "intent": "Compare to another DataFrame and show the differences . With arguments `other`, `keep_equal`.", "question_id": 32576}
{"snippet": "DataFrame.compare(other, align_axis=1, keep_shape=False)", "intent": "Compare to another DataFrame and show the differences . With arguments `other`, `align_axis`, `keep_shape`.", "question_id": 32577}
{"snippet": "DataFrame.compare(other, align_axis=1, keep_equal=False)", "intent": "Compare to another DataFrame and show the differences . With arguments `other`, `align_axis`, `keep_equal`.", "question_id": 32578}
{"snippet": "DataFrame.compare(other, keep_shape=False, keep_equal=False)", "intent": "Compare to another DataFrame and show the differences . With arguments `other`, `keep_shape`, `keep_equal`.", "question_id": 32579}
{"snippet": "DataFrame.compare(other, align_axis=1, keep_shape=False, keep_equal=False)", "intent": "Compare to another DataFrame and show the differences . With arguments `other`, `align_axis`, `keep_shape`, `keep_equal`.", "question_id": 32580}
{"snippet": "DataFrame.compare(other)", "intent": "Compare to another DataFrame and show the differences . With arguments `other`.", "question_id": 32581}
{"snippet": "DataFrame.compare(other, align_axis=1)", "intent": "Compare to another DataFrame and show the differences . With arguments `other`, `align_axis`.", "question_id": 32582}
{"snippet": "DataFrame.compare(other, keep_shape=False)", "intent": "Compare to another DataFrame and show the differences . With arguments `other`, `keep_shape`.", "question_id": 32583}
{"snippet": "DataFrame.compare(other, keep_equal=False)", "intent": "Compare to another DataFrame and show the differences . With arguments `other`, `keep_equal`.", "question_id": 32584}
{"snippet": "DataFrame.compare(other, align_axis=1, keep_shape=False)", "intent": "Compare to another DataFrame and show the differences . With arguments `other`, `align_axis`, `keep_shape`.", "question_id": 32585}
{"snippet": "DataFrame.compare(other, align_axis=1, keep_equal=False)", "intent": "Compare to another DataFrame and show the differences . With arguments `other`, `align_axis`, `keep_equal`.", "question_id": 32586}
{"snippet": "DataFrame.compare(other, keep_shape=False, keep_equal=False)", "intent": "Compare to another DataFrame and show the differences . With arguments `other`, `keep_shape`, `keep_equal`.", "question_id": 32587}
{"snippet": "DataFrame.compare(other, align_axis=1, keep_shape=False, keep_equal=False)", "intent": "Compare to another DataFrame and show the differences . With arguments `other`, `align_axis`, `keep_shape`, `keep_equal`.", "question_id": 32588}
{"snippet": "DataFrame.compare(other)", "intent": "Compare to another DataFrame and show the differences . With arguments `other`.", "question_id": 32589}
{"snippet": "DataFrame.compare(other, align_axis=1)", "intent": "Compare to another DataFrame and show the differences . With arguments `other`, `align_axis`.", "question_id": 32590}
{"snippet": "DataFrame.compare(other, keep_shape=False)", "intent": "Compare to another DataFrame and show the differences . With arguments `other`, `keep_shape`.", "question_id": 32591}
{"snippet": "DataFrame.compare(other, keep_equal=False)", "intent": "Compare to another DataFrame and show the differences . With arguments `other`, `keep_equal`.", "question_id": 32592}
{"snippet": "DataFrame.compare(other, align_axis=1, keep_shape=False)", "intent": "Compare to another DataFrame and show the differences . With arguments `other`, `align_axis`, `keep_shape`.", "question_id": 32593}
{"snippet": "DataFrame.compare(other, align_axis=1, keep_equal=False)", "intent": "Compare to another DataFrame and show the differences . With arguments `other`, `align_axis`, `keep_equal`.", "question_id": 32594}
{"snippet": "DataFrame.compare(other, keep_shape=False, keep_equal=False)", "intent": "Compare to another DataFrame and show the differences . With arguments `other`, `keep_shape`, `keep_equal`.", "question_id": 32595}
{"snippet": "DataFrame.compare(other, align_axis=1, keep_shape=False, keep_equal=False)", "intent": "Compare to another DataFrame and show the differences . With arguments `other`, `align_axis`, `keep_shape`, `keep_equal`.", "question_id": 32596}
{"snippet": "DataFrame.convert_dtypes()", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA .", "question_id": 32597}
{"snippet": "DataFrame.convert_dtypes(infer_objects=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction .", "question_id": 32598}
{"snippet": "DataFrame.convert_dtypes(convert_string=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 32599}
{"snippet": "DataFrame.convert_dtypes(convert_integer=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 32600}
{"snippet": "DataFrame.convert_dtypes(convert_boolean=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 32601}
{"snippet": "DataFrame.convert_dtypes(convert_floating=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . With arguments `convert_floating`.", "question_id": 32602}
{"snippet": "DataFrame.convert_dtypes(infer_objects=True, convert_string=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 32603}
{"snippet": "DataFrame.convert_dtypes(infer_objects=True, convert_integer=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 32604}
{"snippet": "DataFrame.convert_dtypes(infer_objects=True, convert_boolean=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 32605}
{"snippet": "DataFrame.convert_dtypes(infer_objects=True, convert_floating=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction . With arguments `convert_floating`.", "question_id": 32606}
{"snippet": "DataFrame.convert_dtypes()", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA .", "question_id": 32607}
{"snippet": "DataFrame.convert_dtypes(infer_objects=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction .", "question_id": 32608}
{"snippet": "DataFrame.convert_dtypes(convert_string=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 32609}
{"snippet": "DataFrame.convert_dtypes(convert_integer=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 32610}
{"snippet": "DataFrame.convert_dtypes(convert_boolean=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 32611}
{"snippet": "DataFrame.convert_dtypes(convert_floating=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . With arguments `convert_floating`.", "question_id": 32612}
{"snippet": "DataFrame.convert_dtypes(infer_objects=True, convert_string=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 32613}
{"snippet": "DataFrame.convert_dtypes(infer_objects=True, convert_integer=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 32614}
{"snippet": "DataFrame.convert_dtypes(infer_objects=True, convert_boolean=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 32615}
{"snippet": "DataFrame.convert_dtypes(infer_objects=True, convert_floating=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction . With arguments `convert_floating`.", "question_id": 32616}
{"snippet": "DataFrame.convert_dtypes()", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA .", "question_id": 32617}
{"snippet": "DataFrame.convert_dtypes(infer_objects=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction .", "question_id": 32618}
{"snippet": "DataFrame.convert_dtypes(convert_string=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 32619}
{"snippet": "DataFrame.convert_dtypes(convert_integer=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 32620}
{"snippet": "DataFrame.convert_dtypes(convert_boolean=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 32621}
{"snippet": "DataFrame.convert_dtypes(convert_floating=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . With arguments `convert_floating`.", "question_id": 32622}
{"snippet": "DataFrame.convert_dtypes(infer_objects=True, convert_string=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 32623}
{"snippet": "DataFrame.convert_dtypes(infer_objects=True, convert_integer=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 32624}
{"snippet": "DataFrame.convert_dtypes(infer_objects=True, convert_boolean=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 32625}
{"snippet": "DataFrame.convert_dtypes(infer_objects=True, convert_floating=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction . With arguments `convert_floating`.", "question_id": 32626}
{"snippet": "DataFrame.copy()", "intent": "Make a copy of this object \u2019 s indices and data .", "question_id": 32627}
{"snippet": "DataFrame.copy(deep=True)", "intent": "Make a copy of this object \u2019 s indices and data . Shallow copy versus default ( `deep` ) copy :", "question_id": 32628}
{"snippet": "DataFrame.copy()", "intent": "Make a copy of this object \u2019 s indices and data .", "question_id": 32629}
{"snippet": "DataFrame.copy(deep=True)", "intent": "Make a copy of this object \u2019 s indices and data . Shallow copy versus default ( `deep` ) copy :", "question_id": 32630}
{"snippet": "DataFrame.copy()", "intent": "Make a copy of this object \u2019 s indices and data .", "question_id": 32631}
{"snippet": "DataFrame.copy(deep=True)", "intent": "Make a copy of this object \u2019 s indices and data . Shallow copy versus default ( `deep` ) copy :", "question_id": 32632}
{"snippet": "DataFrame.corr()", "intent": "Compute pairwise correlation of columns , excluding NA/null values .", "question_id": 32633}
{"snippet": "DataFrame.corr(method='pearson')", "intent": "Compute pairwise correlation of columns , excluding NA/null values . With arguments `method`.", "question_id": 32634}
{"snippet": "DataFrame.corr(min_periods=1)", "intent": "Compute pairwise correlation of columns , excluding NA/null values . With arguments `min_periods`.", "question_id": 32635}
{"snippet": "DataFrame.corr(method='pearson', min_periods=1)", "intent": "Compute pairwise correlation of columns , excluding NA/null values . With arguments `method`, `min_periods`.", "question_id": 32636}
{"snippet": "DataFrame.corr()", "intent": "Compute pairwise correlation of columns , excluding NA/null values .", "question_id": 32637}
{"snippet": "DataFrame.corr(method='pearson')", "intent": "Compute pairwise correlation of columns , excluding NA/null values . With arguments `method`.", "question_id": 32638}
{"snippet": "DataFrame.corr(min_periods=1)", "intent": "Compute pairwise correlation of columns , excluding NA/null values . With arguments `min_periods`.", "question_id": 32639}
{"snippet": "DataFrame.corr(method='pearson', min_periods=1)", "intent": "Compute pairwise correlation of columns , excluding NA/null values . With arguments `method`, `min_periods`.", "question_id": 32640}
{"snippet": "DataFrame.corr()", "intent": "Compute pairwise correlation of columns , excluding NA/null values .", "question_id": 32641}
{"snippet": "DataFrame.corr(method='pearson')", "intent": "Compute pairwise correlation of columns , excluding NA/null values . With arguments `method`.", "question_id": 32642}
{"snippet": "DataFrame.corr(min_periods=1)", "intent": "Compute pairwise correlation of columns , excluding NA/null values . With arguments `min_periods`.", "question_id": 32643}
{"snippet": "DataFrame.corr(method='pearson', min_periods=1)", "intent": "Compute pairwise correlation of columns , excluding NA/null values . With arguments `method`, `min_periods`.", "question_id": 32644}
{"snippet": "DataFrame.corrwith(other)", "intent": "Compute pairwise correlation . With arguments `other`.", "question_id": 32645}
{"snippet": "DataFrame.corrwith(other, axis=0)", "intent": "Compute pairwise correlation . With arguments `other`, `axis`.", "question_id": 32646}
{"snippet": "DataFrame.corrwith(other, drop=False)", "intent": "Compute pairwise correlation . With arguments `other`, `drop`.", "question_id": 32647}
{"snippet": "DataFrame.corrwith(other, method='pearson')", "intent": "Compute pairwise correlation . With arguments `other`, `method`.", "question_id": 32648}
{"snippet": "DataFrame.corrwith(other, axis=0, drop=False)", "intent": "Compute pairwise correlation . With arguments `other`, `axis`, `drop`.", "question_id": 32649}
{"snippet": "DataFrame.corrwith(other, axis=0, method='pearson')", "intent": "Compute pairwise correlation . With arguments `other`, `axis`, `method`.", "question_id": 32650}
{"snippet": "DataFrame.corrwith(other, drop=False, method='pearson')", "intent": "Compute pairwise correlation . With arguments `other`, `drop`, `method`.", "question_id": 32651}
{"snippet": "DataFrame.corrwith(other, axis=0, drop=False, method='pearson')", "intent": "Compute pairwise correlation . With arguments `other`, `axis`, `drop`, `method`.", "question_id": 32652}
{"snippet": "DataFrame.corrwith(other)", "intent": "Compute pairwise correlation . With arguments `other`.", "question_id": 32653}
{"snippet": "DataFrame.corrwith(other, axis=0)", "intent": "Compute pairwise correlation . With arguments `other`, `axis`.", "question_id": 32654}
{"snippet": "DataFrame.corrwith(other, drop=False)", "intent": "Compute pairwise correlation . With arguments `other`, `drop`.", "question_id": 32655}
{"snippet": "DataFrame.corrwith(other, method='pearson')", "intent": "Compute pairwise correlation . With arguments `other`, `method`.", "question_id": 32656}
{"snippet": "DataFrame.corrwith(other, axis=0, drop=False)", "intent": "Compute pairwise correlation . With arguments `other`, `axis`, `drop`.", "question_id": 32657}
{"snippet": "DataFrame.corrwith(other, axis=0, method='pearson')", "intent": "Compute pairwise correlation . With arguments `other`, `axis`, `method`.", "question_id": 32658}
{"snippet": "DataFrame.corrwith(other, drop=False, method='pearson')", "intent": "Compute pairwise correlation . With arguments `other`, `drop`, `method`.", "question_id": 32659}
{"snippet": "DataFrame.corrwith(other, axis=0, drop=False, method='pearson')", "intent": "Compute pairwise correlation . With arguments `other`, `axis`, `drop`, `method`.", "question_id": 32660}
{"snippet": "DataFrame.corrwith(other)", "intent": "Compute pairwise correlation . With arguments `other`.", "question_id": 32661}
{"snippet": "DataFrame.corrwith(other, axis=0)", "intent": "Compute pairwise correlation . With arguments `other`, `axis`.", "question_id": 32662}
{"snippet": "DataFrame.corrwith(other, drop=False)", "intent": "Compute pairwise correlation . With arguments `other`, `drop`.", "question_id": 32663}
{"snippet": "DataFrame.corrwith(other, method='pearson')", "intent": "Compute pairwise correlation . With arguments `other`, `method`.", "question_id": 32664}
{"snippet": "DataFrame.corrwith(other, axis=0, drop=False)", "intent": "Compute pairwise correlation . With arguments `other`, `axis`, `drop`.", "question_id": 32665}
{"snippet": "DataFrame.corrwith(other, axis=0, method='pearson')", "intent": "Compute pairwise correlation . With arguments `other`, `axis`, `method`.", "question_id": 32666}
{"snippet": "DataFrame.corrwith(other, drop=False, method='pearson')", "intent": "Compute pairwise correlation . With arguments `other`, `drop`, `method`.", "question_id": 32667}
{"snippet": "DataFrame.corrwith(other, axis=0, drop=False, method='pearson')", "intent": "Compute pairwise correlation . With arguments `other`, `axis`, `drop`, `method`.", "question_id": 32668}
{"snippet": "DataFrame.count()", "intent": "Count non-NA cells for each column or row .", "question_id": 32669}
{"snippet": "DataFrame.count(axis=0)", "intent": "Count non-NA cells for each column or row . With arguments `axis`.", "question_id": 32670}
{"snippet": "DataFrame.count(level=None)", "intent": "Count non-NA cells for each column or row . With arguments `level`.", "question_id": 32671}
{"snippet": "DataFrame.count(numeric_only=False)", "intent": "Count non-NA cells for each column or row . With arguments `numeric_only`.", "question_id": 32672}
{"snippet": "DataFrame.count(axis=0, level=None)", "intent": "Count non-NA cells for each column or row . With arguments `axis`, `level`.", "question_id": 32673}
{"snippet": "DataFrame.count(axis=0, numeric_only=False)", "intent": "Count non-NA cells for each column or row . With arguments `axis`, `numeric_only`.", "question_id": 32674}
{"snippet": "DataFrame.count(level=None, numeric_only=False)", "intent": "Count non-NA cells for each column or row . With arguments `level`, `numeric_only`.", "question_id": 32675}
{"snippet": "DataFrame.count(axis=0, level=None, numeric_only=False)", "intent": "Count non-NA cells for each column or row . With arguments `axis`, `level`, `numeric_only`.", "question_id": 32676}
{"snippet": "DataFrame.count()", "intent": "Count non-NA cells for each column or row .", "question_id": 32677}
{"snippet": "DataFrame.count(axis=0)", "intent": "Count non-NA cells for each column or row . With arguments `axis`.", "question_id": 32678}
{"snippet": "DataFrame.count(level=None)", "intent": "Count non-NA cells for each column or row . With arguments `level`.", "question_id": 32679}
{"snippet": "DataFrame.count(numeric_only=False)", "intent": "Count non-NA cells for each column or row . With arguments `numeric_only`.", "question_id": 32680}
{"snippet": "DataFrame.count(axis=0, level=None)", "intent": "Count non-NA cells for each column or row . With arguments `axis`, `level`.", "question_id": 32681}
{"snippet": "DataFrame.count(axis=0, numeric_only=False)", "intent": "Count non-NA cells for each column or row . With arguments `axis`, `numeric_only`.", "question_id": 32682}
{"snippet": "DataFrame.count(level=None, numeric_only=False)", "intent": "Count non-NA cells for each column or row . With arguments `level`, `numeric_only`.", "question_id": 32683}
{"snippet": "DataFrame.count(axis=0, level=None, numeric_only=False)", "intent": "Count non-NA cells for each column or row . With arguments `axis`, `level`, `numeric_only`.", "question_id": 32684}
{"snippet": "DataFrame.count()", "intent": "Count non-NA cells for each column or row .", "question_id": 32685}
{"snippet": "DataFrame.count(axis=0)", "intent": "Count non-NA cells for each column or row . With arguments `axis`.", "question_id": 32686}
{"snippet": "DataFrame.count(level=None)", "intent": "Count non-NA cells for each column or row . With arguments `level`.", "question_id": 32687}
{"snippet": "DataFrame.count(numeric_only=False)", "intent": "Count non-NA cells for each column or row . With arguments `numeric_only`.", "question_id": 32688}
{"snippet": "DataFrame.count(axis=0, level=None)", "intent": "Count non-NA cells for each column or row . With arguments `axis`, `level`.", "question_id": 32689}
{"snippet": "DataFrame.count(axis=0, numeric_only=False)", "intent": "Count non-NA cells for each column or row . With arguments `axis`, `numeric_only`.", "question_id": 32690}
{"snippet": "DataFrame.count(level=None, numeric_only=False)", "intent": "Count non-NA cells for each column or row . With arguments `level`, `numeric_only`.", "question_id": 32691}
{"snippet": "DataFrame.count(axis=0, level=None, numeric_only=False)", "intent": "Count non-NA cells for each column or row . With arguments `axis`, `level`, `numeric_only`.", "question_id": 32692}
{"snippet": "DataFrame.cov()", "intent": "Compute pairwise covariance of columns , excluding NA/null values .", "question_id": 32693}
{"snippet": "DataFrame.cov(min_periods=None)", "intent": "Compute pairwise covariance of columns , excluding NA/null values . This method also supports an optional `min_periods` keyword that specifies the required minimum number of non-NA observations for each column pair in order to have a valid result :", "question_id": 32694}
{"snippet": "DataFrame.cov(ddof=1)", "intent": "Compute pairwise covariance of columns , excluding NA/null values . With arguments `ddof`.", "question_id": 32695}
{"snippet": "DataFrame.cov(min_periods=None, ddof=1)", "intent": "Compute pairwise covariance of columns , excluding NA/null values . This method also supports an optional `min_periods` keyword that specifies the required minimum number of non-NA observations for each column pair in order to have a valid result : With arguments `ddof`.", "question_id": 32696}
{"snippet": "DataFrame.cov()", "intent": "Compute pairwise covariance of columns , excluding NA/null values .", "question_id": 32697}
{"snippet": "DataFrame.cov(min_periods=None)", "intent": "Compute pairwise covariance of columns , excluding NA/null values . This method also supports an optional `min_periods` keyword that specifies the required minimum number of non-NA observations for each column pair in order to have a valid result :", "question_id": 32698}
{"snippet": "DataFrame.cov(ddof=1)", "intent": "Compute pairwise covariance of columns , excluding NA/null values . With arguments `ddof`.", "question_id": 32699}
{"snippet": "DataFrame.cov(min_periods=None, ddof=1)", "intent": "Compute pairwise covariance of columns , excluding NA/null values . This method also supports an optional `min_periods` keyword that specifies the required minimum number of non-NA observations for each column pair in order to have a valid result : With arguments `ddof`.", "question_id": 32700}
{"snippet": "DataFrame.cov()", "intent": "Compute pairwise covariance of columns , excluding NA/null values .", "question_id": 32701}
{"snippet": "DataFrame.cov(min_periods=None)", "intent": "Compute pairwise covariance of columns , excluding NA/null values . This method also supports an optional `min_periods` keyword that specifies the required minimum number of non-NA observations for each column pair in order to have a valid result :", "question_id": 32702}
{"snippet": "DataFrame.cov(ddof=1)", "intent": "Compute pairwise covariance of columns , excluding NA/null values . With arguments `ddof`.", "question_id": 32703}
{"snippet": "DataFrame.cov(min_periods=None, ddof=1)", "intent": "Compute pairwise covariance of columns , excluding NA/null values . This method also supports an optional `min_periods` keyword that specifies the required minimum number of non-NA observations for each column pair in order to have a valid result : With arguments `ddof`.", "question_id": 32704}
{"snippet": "DataFrame.cummax(*args, **kwargs)", "intent": "Return cumulative maximum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32705}
{"snippet": "DataFrame.cummax(*args, **kwargs, axis=None)", "intent": "Return cumulative maximum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32706}
{"snippet": "DataFrame.cummax(*args, **kwargs, skipna=True)", "intent": "Return cumulative maximum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 32707}
{"snippet": "DataFrame.cummax(*args, **kwargs, axis=None, skipna=True)", "intent": "Return cumulative maximum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 32708}
{"snippet": "DataFrame.cummax(*args, **kwargs)", "intent": "Return cumulative maximum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32709}
{"snippet": "DataFrame.cummax(*args, **kwargs, axis=None)", "intent": "Return cumulative maximum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32710}
{"snippet": "DataFrame.cummax(*args, **kwargs, skipna=True)", "intent": "Return cumulative maximum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 32711}
{"snippet": "DataFrame.cummax(*args, **kwargs, axis=None, skipna=True)", "intent": "Return cumulative maximum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 32712}
{"snippet": "DataFrame.cummax(*args, **kwargs)", "intent": "Return cumulative maximum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32713}
{"snippet": "DataFrame.cummax(*args, **kwargs, axis=None)", "intent": "Return cumulative maximum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32714}
{"snippet": "DataFrame.cummax(*args, **kwargs, skipna=True)", "intent": "Return cumulative maximum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 32715}
{"snippet": "DataFrame.cummax(*args, **kwargs, axis=None, skipna=True)", "intent": "Return cumulative maximum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 32716}
{"snippet": "DataFrame.cummin(*args, **kwargs)", "intent": "Return cumulative minimum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32717}
{"snippet": "DataFrame.cummin(*args, **kwargs, axis=None)", "intent": "Return cumulative minimum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32718}
{"snippet": "DataFrame.cummin(*args, **kwargs, skipna=True)", "intent": "Return cumulative minimum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 32719}
{"snippet": "DataFrame.cummin(*args, **kwargs, axis=None, skipna=True)", "intent": "Return cumulative minimum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 32720}
{"snippet": "DataFrame.cummin(*args, **kwargs)", "intent": "Return cumulative minimum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32721}
{"snippet": "DataFrame.cummin(*args, **kwargs, axis=None)", "intent": "Return cumulative minimum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32722}
{"snippet": "DataFrame.cummin(*args, **kwargs, skipna=True)", "intent": "Return cumulative minimum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 32723}
{"snippet": "DataFrame.cummin(*args, **kwargs, axis=None, skipna=True)", "intent": "Return cumulative minimum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 32724}
{"snippet": "DataFrame.cummin(*args, **kwargs)", "intent": "Return cumulative minimum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32725}
{"snippet": "DataFrame.cummin(*args, **kwargs, axis=None)", "intent": "Return cumulative minimum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32726}
{"snippet": "DataFrame.cummin(*args, **kwargs, skipna=True)", "intent": "Return cumulative minimum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 32727}
{"snippet": "DataFrame.cummin(*args, **kwargs, axis=None, skipna=True)", "intent": "Return cumulative minimum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 32728}
{"snippet": "DataFrame.cumprod(*args, **kwargs)", "intent": "Return cumulative product over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32729}
{"snippet": "DataFrame.cumprod(*args, **kwargs, axis=None)", "intent": "Return cumulative product over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32730}
{"snippet": "DataFrame.cumprod(*args, **kwargs, skipna=True)", "intent": "Return cumulative product over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 32731}
{"snippet": "DataFrame.cumprod(*args, **kwargs, axis=None, skipna=True)", "intent": "Return cumulative product over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 32732}
{"snippet": "DataFrame.cumprod(*args, **kwargs)", "intent": "Return cumulative product over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32733}
{"snippet": "DataFrame.cumprod(*args, **kwargs, axis=None)", "intent": "Return cumulative product over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32734}
{"snippet": "DataFrame.cumprod(*args, **kwargs, skipna=True)", "intent": "Return cumulative product over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 32735}
{"snippet": "DataFrame.cumprod(*args, **kwargs, axis=None, skipna=True)", "intent": "Return cumulative product over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 32736}
{"snippet": "DataFrame.cumprod(*args, **kwargs)", "intent": "Return cumulative product over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32737}
{"snippet": "DataFrame.cumprod(*args, **kwargs, axis=None)", "intent": "Return cumulative product over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32738}
{"snippet": "DataFrame.cumprod(*args, **kwargs, skipna=True)", "intent": "Return cumulative product over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 32739}
{"snippet": "DataFrame.cumprod(*args, **kwargs, axis=None, skipna=True)", "intent": "Return cumulative product over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 32740}
{"snippet": "DataFrame.cumsum(*args, **kwargs)", "intent": "Return cumulative sum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32741}
{"snippet": "DataFrame.cumsum(*args, **kwargs, axis=None)", "intent": "Return cumulative sum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32742}
{"snippet": "DataFrame.cumsum(*args, **kwargs, skipna=True)", "intent": "Return cumulative sum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 32743}
{"snippet": "DataFrame.cumsum(*args, **kwargs, axis=None, skipna=True)", "intent": "Return cumulative sum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 32744}
{"snippet": "DataFrame.cumsum(*args, **kwargs)", "intent": "Return cumulative sum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32745}
{"snippet": "DataFrame.cumsum(*args, **kwargs, axis=None)", "intent": "Return cumulative sum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32746}
{"snippet": "DataFrame.cumsum(*args, **kwargs, skipna=True)", "intent": "Return cumulative sum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 32747}
{"snippet": "DataFrame.cumsum(*args, **kwargs, axis=None, skipna=True)", "intent": "Return cumulative sum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 32748}
{"snippet": "DataFrame.cumsum(*args, **kwargs)", "intent": "Return cumulative sum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32749}
{"snippet": "DataFrame.cumsum(*args, **kwargs, axis=None)", "intent": "Return cumulative sum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 32750}
{"snippet": "DataFrame.cumsum(*args, **kwargs, skipna=True)", "intent": "Return cumulative sum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 32751}
{"snippet": "DataFrame.cumsum(*args, **kwargs, axis=None, skipna=True)", "intent": "Return cumulative sum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 32752}
{"snippet": "DataFrame.describe()", "intent": "Generate descriptive statistics .", "question_id": 32753}
{"snippet": "DataFrame.describe(percentiles=None)", "intent": "Generate descriptive statistics . For numeric data , the result \u2019 s index will include count , mean , std , min , max as well as lower , 50 and upper `percentiles` .", "question_id": 32754}
{"snippet": "DataFrame.describe(include=None)", "intent": "Generate descriptive statistics . Descriptive statistics `include` those that summarize the central tendency , dispersion and shape of a dataset \u2019 s distribution , excluding NaN values .", "question_id": 32755}
{"snippet": "DataFrame.describe(exclude=None)", "intent": "Generate descriptive statistics . The include and `exclude` parameters can be used to limit which columns in a DataFrame are analyzed for the output .", "question_id": 32756}
{"snippet": "DataFrame.describe(datetime_is_numeric=False)", "intent": "Generate descriptive statistics . With arguments `datetime_is_numeric`.", "question_id": 32757}
{"snippet": "DataFrame.describe(percentiles=None, include=None)", "intent": "Generate descriptive statistics . For numeric data , the result \u2019 s index will include count , mean , std , min , max as well as lower , 50 and upper `percentiles` . Descriptive statistics `include` those that summarize the central tendency , dispersion and shape of a dataset \u2019 s distribution , excluding NaN values .", "question_id": 32758}
{"snippet": "DataFrame.describe(percentiles=None, exclude=None)", "intent": "Generate descriptive statistics . For numeric data , the result \u2019 s index will include count , mean , std , min , max as well as lower , 50 and upper `percentiles` . The include and `exclude` parameters can be used to limit which columns in a DataFrame are analyzed for the output .", "question_id": 32759}
{"snippet": "DataFrame.describe(percentiles=None, datetime_is_numeric=False)", "intent": "Generate descriptive statistics . For numeric data , the result \u2019 s index will include count , mean , std , min , max as well as lower , 50 and upper `percentiles` . With arguments `datetime_is_numeric`.", "question_id": 32760}
{"snippet": "DataFrame.describe(include=None, exclude=None)", "intent": "Generate descriptive statistics . Descriptive statistics `include` those that summarize the central tendency , dispersion and shape of a dataset \u2019 s distribution , excluding NaN values . The include and `exclude` parameters can be used to limit which columns in a DataFrame are analyzed for the output .", "question_id": 32761}
{"snippet": "DataFrame.describe(include=None, datetime_is_numeric=False)", "intent": "Generate descriptive statistics . Descriptive statistics `include` those that summarize the central tendency , dispersion and shape of a dataset \u2019 s distribution , excluding NaN values . With arguments `datetime_is_numeric`.", "question_id": 32762}
{"snippet": "DataFrame.describe()", "intent": "Generate descriptive statistics .", "question_id": 32763}
{"snippet": "DataFrame.describe(percentiles=None)", "intent": "Generate descriptive statistics . For numeric data , the result \u2019 s index will include count , mean , std , min , max as well as lower , 50 and upper `percentiles` .", "question_id": 32764}
{"snippet": "DataFrame.describe(include=None)", "intent": "Generate descriptive statistics . Descriptive statistics `include` those that summarize the central tendency , dispersion and shape of a dataset \u2019 s distribution , excluding NaN values .", "question_id": 32765}
{"snippet": "DataFrame.describe(exclude=None)", "intent": "Generate descriptive statistics . The include and `exclude` parameters can be used to limit which columns in a DataFrame are analyzed for the output .", "question_id": 32766}
{"snippet": "DataFrame.describe(datetime_is_numeric=False)", "intent": "Generate descriptive statistics . With arguments `datetime_is_numeric`.", "question_id": 32767}
{"snippet": "DataFrame.describe(percentiles=None, include=None)", "intent": "Generate descriptive statistics . For numeric data , the result \u2019 s index will include count , mean , std , min , max as well as lower , 50 and upper `percentiles` . Descriptive statistics `include` those that summarize the central tendency , dispersion and shape of a dataset \u2019 s distribution , excluding NaN values .", "question_id": 32768}
{"snippet": "DataFrame.describe(percentiles=None, exclude=None)", "intent": "Generate descriptive statistics . For numeric data , the result \u2019 s index will include count , mean , std , min , max as well as lower , 50 and upper `percentiles` . The include and `exclude` parameters can be used to limit which columns in a DataFrame are analyzed for the output .", "question_id": 32769}
{"snippet": "DataFrame.describe(percentiles=None, datetime_is_numeric=False)", "intent": "Generate descriptive statistics . For numeric data , the result \u2019 s index will include count , mean , std , min , max as well as lower , 50 and upper `percentiles` . With arguments `datetime_is_numeric`.", "question_id": 32770}
{"snippet": "DataFrame.describe(include=None, exclude=None)", "intent": "Generate descriptive statistics . Descriptive statistics `include` those that summarize the central tendency , dispersion and shape of a dataset \u2019 s distribution , excluding NaN values . The include and `exclude` parameters can be used to limit which columns in a DataFrame are analyzed for the output .", "question_id": 32771}
{"snippet": "DataFrame.describe(include=None, datetime_is_numeric=False)", "intent": "Generate descriptive statistics . Descriptive statistics `include` those that summarize the central tendency , dispersion and shape of a dataset \u2019 s distribution , excluding NaN values . With arguments `datetime_is_numeric`.", "question_id": 32772}
{"snippet": "DataFrame.describe()", "intent": "Generate descriptive statistics .", "question_id": 32773}
{"snippet": "DataFrame.describe(percentiles=None)", "intent": "Generate descriptive statistics . For numeric data , the result \u2019 s index will include count , mean , std , min , max as well as lower , 50 and upper `percentiles` .", "question_id": 32774}
{"snippet": "DataFrame.describe(include=None)", "intent": "Generate descriptive statistics . Descriptive statistics `include` those that summarize the central tendency , dispersion and shape of a dataset \u2019 s distribution , excluding NaN values .", "question_id": 32775}
{"snippet": "DataFrame.describe(exclude=None)", "intent": "Generate descriptive statistics . The include and `exclude` parameters can be used to limit which columns in a DataFrame are analyzed for the output .", "question_id": 32776}
{"snippet": "DataFrame.describe(datetime_is_numeric=False)", "intent": "Generate descriptive statistics . With arguments `datetime_is_numeric`.", "question_id": 32777}
{"snippet": "DataFrame.describe(percentiles=None, include=None)", "intent": "Generate descriptive statistics . For numeric data , the result \u2019 s index will include count , mean , std , min , max as well as lower , 50 and upper `percentiles` . Descriptive statistics `include` those that summarize the central tendency , dispersion and shape of a dataset \u2019 s distribution , excluding NaN values .", "question_id": 32778}
{"snippet": "DataFrame.describe(percentiles=None, exclude=None)", "intent": "Generate descriptive statistics . For numeric data , the result \u2019 s index will include count , mean , std , min , max as well as lower , 50 and upper `percentiles` . The include and `exclude` parameters can be used to limit which columns in a DataFrame are analyzed for the output .", "question_id": 32779}
{"snippet": "DataFrame.describe(percentiles=None, datetime_is_numeric=False)", "intent": "Generate descriptive statistics . For numeric data , the result \u2019 s index will include count , mean , std , min , max as well as lower , 50 and upper `percentiles` . With arguments `datetime_is_numeric`.", "question_id": 32780}
{"snippet": "DataFrame.describe(include=None, exclude=None)", "intent": "Generate descriptive statistics . Descriptive statistics `include` those that summarize the central tendency , dispersion and shape of a dataset \u2019 s distribution , excluding NaN values . The include and `exclude` parameters can be used to limit which columns in a DataFrame are analyzed for the output .", "question_id": 32781}
{"snippet": "DataFrame.describe(include=None, datetime_is_numeric=False)", "intent": "Generate descriptive statistics . Descriptive statistics `include` those that summarize the central tendency , dispersion and shape of a dataset \u2019 s distribution , excluding NaN values . With arguments `datetime_is_numeric`.", "question_id": 32782}
{"snippet": "DataFrame.diff()", "intent": "First discrete difference of element .", "question_id": 32783}
{"snippet": "DataFrame.diff(periods=1)", "intent": "First discrete difference of element . With arguments `periods`.", "question_id": 32784}
{"snippet": "DataFrame.diff(axis=0)", "intent": "First discrete difference of element . With arguments `axis`.", "question_id": 32785}
{"snippet": "DataFrame.diff(periods=1, axis=0)", "intent": "First discrete difference of element . With arguments `periods`, `axis`.", "question_id": 32786}
{"snippet": "DataFrame.diff()", "intent": "First discrete difference of element .", "question_id": 32787}
{"snippet": "DataFrame.diff(periods=1)", "intent": "First discrete difference of element . With arguments `periods`.", "question_id": 32788}
{"snippet": "DataFrame.diff(axis=0)", "intent": "First discrete difference of element . With arguments `axis`.", "question_id": 32789}
{"snippet": "DataFrame.diff(periods=1, axis=0)", "intent": "First discrete difference of element . With arguments `periods`, `axis`.", "question_id": 32790}
{"snippet": "DataFrame.diff()", "intent": "First discrete difference of element .", "question_id": 32791}
{"snippet": "DataFrame.diff(periods=1)", "intent": "First discrete difference of element . With arguments `periods`.", "question_id": 32792}
{"snippet": "DataFrame.diff(axis=0)", "intent": "First discrete difference of element . With arguments `axis`.", "question_id": 32793}
{"snippet": "DataFrame.diff(periods=1, axis=0)", "intent": "First discrete difference of element . With arguments `periods`, `axis`.", "question_id": 32794}
{"snippet": "DataFrame.div(other)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) .", "question_id": 32795}
{"snippet": "DataFrame.div(other, axis='columns')", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version .", "question_id": 32796}
{"snippet": "DataFrame.div(other, level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Divide by a MultiIndex by `level` .", "question_id": 32797}
{"snippet": "DataFrame.div(other, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32798}
{"snippet": "DataFrame.div(other, axis='columns', level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 32799}
{"snippet": "DataFrame.div(other, axis='columns', fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32800}
{"snippet": "DataFrame.div(other, level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Divide by a MultiIndex by `level` . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32801}
{"snippet": "DataFrame.div(other, axis='columns', level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32802}
{"snippet": "DataFrame.div(other)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) .", "question_id": 32803}
{"snippet": "DataFrame.div(other, axis='columns')", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version .", "question_id": 32804}
{"snippet": "DataFrame.div(other, level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Divide by a MultiIndex by `level` .", "question_id": 32805}
{"snippet": "DataFrame.div(other, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32806}
{"snippet": "DataFrame.div(other, axis='columns', level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 32807}
{"snippet": "DataFrame.div(other, axis='columns', fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32808}
{"snippet": "DataFrame.div(other, level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Divide by a MultiIndex by `level` . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32809}
{"snippet": "DataFrame.div(other, axis='columns', level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32810}
{"snippet": "DataFrame.div(other)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) .", "question_id": 32811}
{"snippet": "DataFrame.div(other, axis='columns')", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version .", "question_id": 32812}
{"snippet": "DataFrame.div(other, level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Divide by a MultiIndex by `level` .", "question_id": 32813}
{"snippet": "DataFrame.div(other, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32814}
{"snippet": "DataFrame.div(other, axis='columns', level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 32815}
{"snippet": "DataFrame.div(other, axis='columns', fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32816}
{"snippet": "DataFrame.div(other, level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Divide by a MultiIndex by `level` . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32817}
{"snippet": "DataFrame.div(other, axis='columns', level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32818}
{"snippet": "DataFrame.divide(other)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) .", "question_id": 32819}
{"snippet": "DataFrame.divide(other, axis='columns')", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version .", "question_id": 32820}
{"snippet": "DataFrame.divide(other, level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Divide by a MultiIndex by `level` .", "question_id": 32821}
{"snippet": "DataFrame.divide(other, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32822}
{"snippet": "DataFrame.divide(other, axis='columns', level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 32823}
{"snippet": "DataFrame.divide(other, axis='columns', fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32824}
{"snippet": "DataFrame.divide(other, level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Divide by a MultiIndex by `level` . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32825}
{"snippet": "DataFrame.divide(other, axis='columns', level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32826}
{"snippet": "DataFrame.divide(other)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) .", "question_id": 32827}
{"snippet": "DataFrame.divide(other, axis='columns')", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version .", "question_id": 32828}
{"snippet": "DataFrame.divide(other, level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Divide by a MultiIndex by `level` .", "question_id": 32829}
{"snippet": "DataFrame.divide(other, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32830}
{"snippet": "DataFrame.divide(other, axis='columns', level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 32831}
{"snippet": "DataFrame.divide(other, axis='columns', fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32832}
{"snippet": "DataFrame.divide(other, level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Divide by a MultiIndex by `level` . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32833}
{"snippet": "DataFrame.divide(other, axis='columns', level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32834}
{"snippet": "DataFrame.divide(other)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) .", "question_id": 32835}
{"snippet": "DataFrame.divide(other, axis='columns')", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version .", "question_id": 32836}
{"snippet": "DataFrame.divide(other, level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Divide by a MultiIndex by `level` .", "question_id": 32837}
{"snippet": "DataFrame.divide(other, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32838}
{"snippet": "DataFrame.divide(other, axis='columns', level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 32839}
{"snippet": "DataFrame.divide(other, axis='columns', fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32840}
{"snippet": "DataFrame.divide(other, level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Divide by a MultiIndex by `level` . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32841}
{"snippet": "DataFrame.divide(other, axis='columns', level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 32842}
{"snippet": "DataFrame.dot(other)", "intent": "Compute the matrix multiplication between the DataFrame and `other` .", "question_id": 32843}
{"snippet": "DataFrame.dot(other)", "intent": "Compute the matrix multiplication between the DataFrame and `other` .", "question_id": 32844}
{"snippet": "DataFrame.dot(other)", "intent": "Compute the matrix multiplication between the DataFrame and `other` .", "question_id": 32845}
{"snippet": "DataFrame.drop()", "intent": "Drop specified `labels` from rows or `columns` .", "question_id": 32846}
{"snippet": "DataFrame.drop(labels=None)", "intent": "Drop specified `labels` from rows or `columns` .", "question_id": 32847}
{"snippet": "DataFrame.drop(axis=0)", "intent": "Drop specified `labels` from rows or `columns` . Remove rows or columns by specifying label names and corresponding `axis` , or by specifying directly `index` or column names .", "question_id": 32848}
{"snippet": "DataFrame.drop(index=None)", "intent": "Drop specified `labels` from rows or `columns` . Remove rows or columns by specifying label names and corresponding `axis` , or by specifying directly `index` or column names .", "question_id": 32849}
{"snippet": "DataFrame.drop(columns=None)", "intent": "Drop specified `labels` from rows or `columns` .", "question_id": 32850}
{"snippet": "DataFrame.drop(level=None)", "intent": "Drop specified `labels` from rows or `columns` . When using a multi-index , labels on different levels can be removed by specifying the `level` .", "question_id": 32851}
{"snippet": "DataFrame.drop(inplace=False)", "intent": "Drop specified `labels` from rows or `columns` . With arguments `inplace`.", "question_id": 32852}
{"snippet": "DataFrame.drop(errors='raise')", "intent": "Drop specified `labels` from rows or `columns` . With arguments `errors`.", "question_id": 32853}
{"snippet": "DataFrame.drop(labels=None, axis=0)", "intent": "Drop specified `labels` from rows or `columns` . Remove rows or columns by specifying label names and corresponding `axis` , or by specifying directly `index` or column names .", "question_id": 32854}
{"snippet": "DataFrame.drop(labels=None, index=None)", "intent": "Drop specified `labels` from rows or `columns` . Remove rows or columns by specifying label names and corresponding `axis` , or by specifying directly `index` or column names .", "question_id": 32855}
{"snippet": "DataFrame.drop()", "intent": "Drop specified `labels` from rows or `columns` .", "question_id": 32856}
{"snippet": "DataFrame.drop(labels=None)", "intent": "Drop specified `labels` from rows or `columns` .", "question_id": 32857}
{"snippet": "DataFrame.drop(axis=0)", "intent": "Drop specified `labels` from rows or `columns` . Remove rows or columns by specifying label names and corresponding `axis` , or by specifying directly `index` or column names .", "question_id": 32858}
{"snippet": "DataFrame.drop(index=None)", "intent": "Drop specified `labels` from rows or `columns` . Remove rows or columns by specifying label names and corresponding `axis` , or by specifying directly `index` or column names .", "question_id": 32859}
{"snippet": "DataFrame.drop(columns=None)", "intent": "Drop specified `labels` from rows or `columns` .", "question_id": 32860}
{"snippet": "DataFrame.drop(level=None)", "intent": "Drop specified `labels` from rows or `columns` . When using a multi-index , labels on different levels can be removed by specifying the `level` .", "question_id": 32861}
{"snippet": "DataFrame.drop(inplace=False)", "intent": "Drop specified `labels` from rows or `columns` . With arguments `inplace`.", "question_id": 32862}
{"snippet": "DataFrame.drop(errors='raise')", "intent": "Drop specified `labels` from rows or `columns` . With arguments `errors`.", "question_id": 32863}
{"snippet": "DataFrame.drop(labels=None, axis=0)", "intent": "Drop specified `labels` from rows or `columns` . Remove rows or columns by specifying label names and corresponding `axis` , or by specifying directly `index` or column names .", "question_id": 32864}
{"snippet": "DataFrame.drop(labels=None, index=None)", "intent": "Drop specified `labels` from rows or `columns` . Remove rows or columns by specifying label names and corresponding `axis` , or by specifying directly `index` or column names .", "question_id": 32865}
{"snippet": "DataFrame.drop()", "intent": "Drop specified `labels` from rows or `columns` .", "question_id": 32866}
{"snippet": "DataFrame.drop(labels=None)", "intent": "Drop specified `labels` from rows or `columns` .", "question_id": 32867}
{"snippet": "DataFrame.drop(axis=0)", "intent": "Drop specified `labels` from rows or `columns` . Remove rows or columns by specifying label names and corresponding `axis` , or by specifying directly `index` or column names .", "question_id": 32868}
{"snippet": "DataFrame.drop(index=None)", "intent": "Drop specified `labels` from rows or `columns` . Remove rows or columns by specifying label names and corresponding `axis` , or by specifying directly `index` or column names .", "question_id": 32869}
{"snippet": "DataFrame.drop(columns=None)", "intent": "Drop specified `labels` from rows or `columns` .", "question_id": 32870}
{"snippet": "DataFrame.drop(level=None)", "intent": "Drop specified `labels` from rows or `columns` . When using a multi-index , labels on different levels can be removed by specifying the `level` .", "question_id": 32871}
{"snippet": "DataFrame.drop(inplace=False)", "intent": "Drop specified `labels` from rows or `columns` . With arguments `inplace`.", "question_id": 32872}
{"snippet": "DataFrame.drop(errors='raise')", "intent": "Drop specified `labels` from rows or `columns` . With arguments `errors`.", "question_id": 32873}
{"snippet": "DataFrame.drop(labels=None, axis=0)", "intent": "Drop specified `labels` from rows or `columns` . Remove rows or columns by specifying label names and corresponding `axis` , or by specifying directly `index` or column names .", "question_id": 32874}
{"snippet": "DataFrame.drop(labels=None, index=None)", "intent": "Drop specified `labels` from rows or `columns` . Remove rows or columns by specifying label names and corresponding `axis` , or by specifying directly `index` or column names .", "question_id": 32875}
{"snippet": "DataFrame.drop_duplicates()", "intent": "Return DataFrame with duplicate rows removed .", "question_id": 32876}
{"snippet": "DataFrame.drop_duplicates(subset=None)", "intent": "Return DataFrame with duplicate rows removed . To remove duplicates on specific column ( s ) , use `subset` .", "question_id": 32877}
{"snippet": "DataFrame.drop_duplicates(keep='first')", "intent": "Return DataFrame with duplicate rows removed . To remove duplicates and `keep` last occurrences , use keep .", "question_id": 32878}
{"snippet": "DataFrame.drop_duplicates(inplace=False)", "intent": "Return DataFrame with duplicate rows removed . With arguments `inplace`.", "question_id": 32879}
{"snippet": "DataFrame.drop_duplicates(ignore_index=False)", "intent": "Return DataFrame with duplicate rows removed . With arguments `ignore_index`.", "question_id": 32880}
{"snippet": "DataFrame.drop_duplicates(subset=None, keep='first')", "intent": "Return DataFrame with duplicate rows removed . To remove duplicates on specific column ( s ) , use `subset` . To remove duplicates and `keep` last occurrences , use keep .", "question_id": 32881}
{"snippet": "DataFrame.drop_duplicates(subset=None, inplace=False)", "intent": "Return DataFrame with duplicate rows removed . To remove duplicates on specific column ( s ) , use `subset` . With arguments `inplace`.", "question_id": 32882}
{"snippet": "DataFrame.drop_duplicates(subset=None, ignore_index=False)", "intent": "Return DataFrame with duplicate rows removed . To remove duplicates on specific column ( s ) , use `subset` . With arguments `ignore_index`.", "question_id": 32883}
{"snippet": "DataFrame.drop_duplicates(keep='first', inplace=False)", "intent": "Return DataFrame with duplicate rows removed . To remove duplicates and `keep` last occurrences , use keep . With arguments `inplace`.", "question_id": 32884}
{"snippet": "DataFrame.drop_duplicates(keep='first', ignore_index=False)", "intent": "Return DataFrame with duplicate rows removed . To remove duplicates and `keep` last occurrences , use keep . With arguments `ignore_index`.", "question_id": 32885}
{"snippet": "DataFrame.drop_duplicates()", "intent": "Return DataFrame with duplicate rows removed .", "question_id": 32886}
{"snippet": "DataFrame.drop_duplicates(subset=None)", "intent": "Return DataFrame with duplicate rows removed . To remove duplicates on specific column ( s ) , use `subset` .", "question_id": 32887}
{"snippet": "DataFrame.drop_duplicates(keep='first')", "intent": "Return DataFrame with duplicate rows removed . To remove duplicates and `keep` last occurrences , use keep .", "question_id": 32888}
{"snippet": "DataFrame.drop_duplicates(inplace=False)", "intent": "Return DataFrame with duplicate rows removed . With arguments `inplace`.", "question_id": 32889}
{"snippet": "DataFrame.drop_duplicates(ignore_index=False)", "intent": "Return DataFrame with duplicate rows removed . With arguments `ignore_index`.", "question_id": 32890}
{"snippet": "DataFrame.drop_duplicates(subset=None, keep='first')", "intent": "Return DataFrame with duplicate rows removed . To remove duplicates on specific column ( s ) , use `subset` . To remove duplicates and `keep` last occurrences , use keep .", "question_id": 32891}
{"snippet": "DataFrame.drop_duplicates(subset=None, inplace=False)", "intent": "Return DataFrame with duplicate rows removed . To remove duplicates on specific column ( s ) , use `subset` . With arguments `inplace`.", "question_id": 32892}
{"snippet": "DataFrame.drop_duplicates(subset=None, ignore_index=False)", "intent": "Return DataFrame with duplicate rows removed . To remove duplicates on specific column ( s ) , use `subset` . With arguments `ignore_index`.", "question_id": 32893}
{"snippet": "DataFrame.drop_duplicates(keep='first', inplace=False)", "intent": "Return DataFrame with duplicate rows removed . To remove duplicates and `keep` last occurrences , use keep . With arguments `inplace`.", "question_id": 32894}
{"snippet": "DataFrame.drop_duplicates(keep='first', ignore_index=False)", "intent": "Return DataFrame with duplicate rows removed . To remove duplicates and `keep` last occurrences , use keep . With arguments `ignore_index`.", "question_id": 32895}
{"snippet": "DataFrame.drop_duplicates()", "intent": "Return DataFrame with duplicate rows removed .", "question_id": 32896}
{"snippet": "DataFrame.drop_duplicates(subset=None)", "intent": "Return DataFrame with duplicate rows removed . To remove duplicates on specific column ( s ) , use `subset` .", "question_id": 32897}
{"snippet": "DataFrame.drop_duplicates(keep='first')", "intent": "Return DataFrame with duplicate rows removed . To remove duplicates and `keep` last occurrences , use keep .", "question_id": 32898}
{"snippet": "DataFrame.drop_duplicates(inplace=False)", "intent": "Return DataFrame with duplicate rows removed . With arguments `inplace`.", "question_id": 32899}
{"snippet": "DataFrame.drop_duplicates(ignore_index=False)", "intent": "Return DataFrame with duplicate rows removed . With arguments `ignore_index`.", "question_id": 32900}
{"snippet": "DataFrame.drop_duplicates(subset=None, keep='first')", "intent": "Return DataFrame with duplicate rows removed . To remove duplicates on specific column ( s ) , use `subset` . To remove duplicates and `keep` last occurrences , use keep .", "question_id": 32901}
{"snippet": "DataFrame.drop_duplicates(subset=None, inplace=False)", "intent": "Return DataFrame with duplicate rows removed . To remove duplicates on specific column ( s ) , use `subset` . With arguments `inplace`.", "question_id": 32902}
{"snippet": "DataFrame.drop_duplicates(subset=None, ignore_index=False)", "intent": "Return DataFrame with duplicate rows removed . To remove duplicates on specific column ( s ) , use `subset` . With arguments `ignore_index`.", "question_id": 32903}
{"snippet": "DataFrame.drop_duplicates(keep='first', inplace=False)", "intent": "Return DataFrame with duplicate rows removed . To remove duplicates and `keep` last occurrences , use keep . With arguments `inplace`.", "question_id": 32904}
{"snippet": "DataFrame.drop_duplicates(keep='first', ignore_index=False)", "intent": "Return DataFrame with duplicate rows removed . To remove duplicates and `keep` last occurrences , use keep . With arguments `ignore_index`.", "question_id": 32905}
{"snippet": "DataFrame.droplevel(level)", "intent": "Return Series/DataFrame with requested index / column `level` ( s ) removed .", "question_id": 32906}
{"snippet": "DataFrame.droplevel(level, axis=0)", "intent": "Return Series/DataFrame with requested index / column `level` ( s ) removed . With arguments `axis`.", "question_id": 32907}
{"snippet": "DataFrame.droplevel(level)", "intent": "Return Series/DataFrame with requested index / column `level` ( s ) removed .", "question_id": 32908}
{"snippet": "DataFrame.droplevel(level, axis=0)", "intent": "Return Series/DataFrame with requested index / column `level` ( s ) removed . With arguments `axis`.", "question_id": 32909}
{"snippet": "DataFrame.droplevel(level)", "intent": "Return Series/DataFrame with requested index / column `level` ( s ) removed .", "question_id": 32910}
{"snippet": "DataFrame.droplevel(level, axis=0)", "intent": "Return Series/DataFrame with requested index / column `level` ( s ) removed . With arguments `axis`.", "question_id": 32911}
{"snippet": "DataFrame.dropna()", "intent": "Remove missing values .", "question_id": 32912}
{"snippet": "DataFrame.dropna(axis=0)", "intent": "Remove missing values . With arguments `axis`.", "question_id": 32913}
{"snippet": "DataFrame.dropna(how='any')", "intent": "Remove missing values . See the User Guide for more on which values are considered missing , and `how` to work with missing data .", "question_id": 32914}
{"snippet": "DataFrame.dropna(thresh=None)", "intent": "Remove missing values . With arguments `thresh`.", "question_id": 32915}
{"snippet": "DataFrame.dropna(subset=None)", "intent": "Remove missing values . With arguments `subset`.", "question_id": 32916}
{"snippet": "DataFrame.dropna(inplace=False)", "intent": "Remove missing values . With arguments `inplace`.", "question_id": 32917}
{"snippet": "DataFrame.dropna(axis=0, how='any')", "intent": "Remove missing values . See the User Guide for more on which values are considered missing , and `how` to work with missing data . With arguments `axis`.", "question_id": 32918}
{"snippet": "DataFrame.dropna(axis=0, thresh=None)", "intent": "Remove missing values . With arguments `axis`, `thresh`.", "question_id": 32919}
{"snippet": "DataFrame.dropna(axis=0, subset=None)", "intent": "Remove missing values . With arguments `axis`, `subset`.", "question_id": 32920}
{"snippet": "DataFrame.dropna(axis=0, inplace=False)", "intent": "Remove missing values . With arguments `axis`, `inplace`.", "question_id": 32921}
{"snippet": "DataFrame.dropna()", "intent": "Remove missing values .", "question_id": 32922}
{"snippet": "DataFrame.dropna(axis=0)", "intent": "Remove missing values . With arguments `axis`.", "question_id": 32923}
{"snippet": "DataFrame.dropna(how='any')", "intent": "Remove missing values . See the User Guide for more on which values are considered missing , and `how` to work with missing data .", "question_id": 32924}
{"snippet": "DataFrame.dropna(thresh=None)", "intent": "Remove missing values . With arguments `thresh`.", "question_id": 32925}
{"snippet": "DataFrame.dropna(subset=None)", "intent": "Remove missing values . With arguments `subset`.", "question_id": 32926}
{"snippet": "DataFrame.dropna(inplace=False)", "intent": "Remove missing values . With arguments `inplace`.", "question_id": 32927}
{"snippet": "DataFrame.dropna(axis=0, how='any')", "intent": "Remove missing values . See the User Guide for more on which values are considered missing , and `how` to work with missing data . With arguments `axis`.", "question_id": 32928}
{"snippet": "DataFrame.dropna(axis=0, thresh=None)", "intent": "Remove missing values . With arguments `axis`, `thresh`.", "question_id": 32929}
{"snippet": "DataFrame.dropna(axis=0, subset=None)", "intent": "Remove missing values . With arguments `axis`, `subset`.", "question_id": 32930}
{"snippet": "DataFrame.dropna(axis=0, inplace=False)", "intent": "Remove missing values . With arguments `axis`, `inplace`.", "question_id": 32931}
{"snippet": "DataFrame.dropna()", "intent": "Remove missing values .", "question_id": 32932}
{"snippet": "DataFrame.dropna(axis=0)", "intent": "Remove missing values . With arguments `axis`.", "question_id": 32933}
{"snippet": "DataFrame.dropna(how='any')", "intent": "Remove missing values . See the User Guide for more on which values are considered missing , and `how` to work with missing data .", "question_id": 32934}
{"snippet": "DataFrame.dropna(thresh=None)", "intent": "Remove missing values . With arguments `thresh`.", "question_id": 32935}
{"snippet": "DataFrame.dropna(subset=None)", "intent": "Remove missing values . With arguments `subset`.", "question_id": 32936}
{"snippet": "DataFrame.dropna(inplace=False)", "intent": "Remove missing values . With arguments `inplace`.", "question_id": 32937}
{"snippet": "DataFrame.dropna(axis=0, how='any')", "intent": "Remove missing values . See the User Guide for more on which values are considered missing , and `how` to work with missing data . With arguments `axis`.", "question_id": 32938}
{"snippet": "DataFrame.dropna(axis=0, thresh=None)", "intent": "Remove missing values . With arguments `axis`, `thresh`.", "question_id": 32939}
{"snippet": "DataFrame.dropna(axis=0, subset=None)", "intent": "Remove missing values . With arguments `axis`, `subset`.", "question_id": 32940}
{"snippet": "DataFrame.dropna(axis=0, inplace=False)", "intent": "Remove missing values . With arguments `axis`, `inplace`.", "question_id": 32941}
{"snippet": "DataFrame.duplicated()", "intent": "Return boolean Series denoting duplicate rows .", "question_id": 32942}
{"snippet": "DataFrame.duplicated(subset=None)", "intent": "Return boolean Series denoting duplicate rows . To find duplicates on specific column ( s ) , use `subset` .", "question_id": 32943}
{"snippet": "DataFrame.duplicated(keep='first')", "intent": "Return boolean Series denoting duplicate rows . By setting `keep` on False , all duplicates are True .", "question_id": 32944}
{"snippet": "DataFrame.duplicated(subset=None, keep='first')", "intent": "Return boolean Series denoting duplicate rows . To find duplicates on specific column ( s ) , use `subset` . By setting `keep` on False , all duplicates are True .", "question_id": 32945}
{"snippet": "DataFrame.duplicated()", "intent": "Return boolean Series denoting duplicate rows .", "question_id": 32946}
{"snippet": "DataFrame.duplicated(subset=None)", "intent": "Return boolean Series denoting duplicate rows . To find duplicates on specific column ( s ) , use `subset` .", "question_id": 32947}
{"snippet": "DataFrame.duplicated(keep='first')", "intent": "Return boolean Series denoting duplicate rows . By setting `keep` on False , all duplicates are True .", "question_id": 32948}
{"snippet": "DataFrame.duplicated(subset=None, keep='first')", "intent": "Return boolean Series denoting duplicate rows . To find duplicates on specific column ( s ) , use `subset` . By setting `keep` on False , all duplicates are True .", "question_id": 32949}
{"snippet": "DataFrame.duplicated()", "intent": "Return boolean Series denoting duplicate rows .", "question_id": 32950}
{"snippet": "DataFrame.duplicated(subset=None)", "intent": "Return boolean Series denoting duplicate rows . To find duplicates on specific column ( s ) , use `subset` .", "question_id": 32951}
{"snippet": "DataFrame.duplicated(keep='first')", "intent": "Return boolean Series denoting duplicate rows . By setting `keep` on False , all duplicates are True .", "question_id": 32952}
{"snippet": "DataFrame.duplicated(subset=None, keep='first')", "intent": "Return boolean Series denoting duplicate rows . To find duplicates on specific column ( s ) , use `subset` . By setting `keep` on False , all duplicates are True .", "question_id": 32953}
{"snippet": "DataFrame.eq(other)", "intent": "Get Equal to of dataframe and `other` , element-wise ( binary operator eq ) .", "question_id": 32954}
{"snippet": "DataFrame.eq(other, axis='columns')", "intent": "Get Equal to of dataframe and `other` , element-wise ( binary operator eq ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 32955}
{"snippet": "DataFrame.eq(other, level=None)", "intent": "Get Equal to of dataframe and `other` , element-wise ( binary operator eq ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 32956}
{"snippet": "DataFrame.eq(other, axis='columns', level=None)", "intent": "Get Equal to of dataframe and `other` , element-wise ( binary operator eq ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 32957}
{"snippet": "DataFrame.eq(other)", "intent": "Get Equal to of dataframe and `other` , element-wise ( binary operator eq ) .", "question_id": 32958}
{"snippet": "DataFrame.eq(other, axis='columns')", "intent": "Get Equal to of dataframe and `other` , element-wise ( binary operator eq ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 32959}
{"snippet": "DataFrame.eq(other, level=None)", "intent": "Get Equal to of dataframe and `other` , element-wise ( binary operator eq ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 32960}
{"snippet": "DataFrame.eq(other, axis='columns', level=None)", "intent": "Get Equal to of dataframe and `other` , element-wise ( binary operator eq ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 32961}
{"snippet": "DataFrame.eq(other)", "intent": "Get Equal to of dataframe and `other` , element-wise ( binary operator eq ) .", "question_id": 32962}
{"snippet": "DataFrame.eq(other, axis='columns')", "intent": "Get Equal to of dataframe and `other` , element-wise ( binary operator eq ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 32963}
{"snippet": "DataFrame.eq(other, level=None)", "intent": "Get Equal to of dataframe and `other` , element-wise ( binary operator eq ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 32964}
{"snippet": "DataFrame.eq(other, axis='columns', level=None)", "intent": "Get Equal to of dataframe and `other` , element-wise ( binary operator eq ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 32965}
{"snippet": "DataFrame.equals(other)", "intent": "Test whether two objects contain the same elements . This function allows two Series or DataFrames to be compared against each `other` to see if they have the same shape and elements .", "question_id": 32966}
{"snippet": "DataFrame.equals(other)", "intent": "Test whether two objects contain the same elements . This function allows two Series or DataFrames to be compared against each `other` to see if they have the same shape and elements .", "question_id": 32967}
{"snippet": "DataFrame.equals(other)", "intent": "Test whether two objects contain the same elements . This function allows two Series or DataFrames to be compared against each `other` to see if they have the same shape and elements .", "question_id": 32968}
{"snippet": "DataFrame.eval(expr, **kwargs)", "intent": "Evaluate a string describing operations on DataFrame columns . With arguments `expr`, `**kwargs`.", "question_id": 32969}
{"snippet": "DataFrame.eval(expr, **kwargs, inplace=False)", "intent": "Evaluate a string describing operations on DataFrame columns . With arguments `expr`, `**kwargs`, `inplace`.", "question_id": 32970}
{"snippet": "DataFrame.eval(expr, **kwargs)", "intent": "Evaluate a string describing operations on DataFrame columns . With arguments `expr`, `**kwargs`.", "question_id": 32971}
{"snippet": "DataFrame.eval(expr, **kwargs, inplace=False)", "intent": "Evaluate a string describing operations on DataFrame columns . With arguments `expr`, `**kwargs`, `inplace`.", "question_id": 32972}
{"snippet": "DataFrame.eval(expr, **kwargs)", "intent": "Evaluate a string describing operations on DataFrame columns . With arguments `expr`, `**kwargs`.", "question_id": 32973}
{"snippet": "DataFrame.eval(expr, **kwargs, inplace=False)", "intent": "Evaluate a string describing operations on DataFrame columns . With arguments `expr`, `**kwargs`, `inplace`.", "question_id": 32974}
{"snippet": "DataFrame.ewm()", "intent": "Provide exponential weighted ( EW ) functions .", "question_id": 32975}
{"snippet": "DataFrame.ewm(com=None)", "intent": "Provide exponential weighted ( EW ) functions . Exactly one parameter : `com` , `span` , `halflife` , or `alpha` must be provided .", "question_id": 32976}
{"snippet": "DataFrame.ewm(span=None)", "intent": "Provide exponential weighted ( EW ) functions . Exactly one parameter : `com` , `span` , `halflife` , or `alpha` must be provided .", "question_id": 32977}
{"snippet": "DataFrame.ewm(halflife=None)", "intent": "Provide exponential weighted ( EW ) functions . Exactly one parameter : `com` , `span` , `halflife` , or `alpha` must be provided .", "question_id": 32978}
{"snippet": "DataFrame.ewm(alpha=None)", "intent": "Provide exponential weighted ( EW ) functions . Exactly one parameter : `com` , `span` , `halflife` , or `alpha` must be provided .", "question_id": 32979}
{"snippet": "DataFrame.ewm(min_periods=0)", "intent": "Provide exponential weighted ( EW ) functions . With arguments `min_periods`.", "question_id": 32980}
{"snippet": "DataFrame.ewm(adjust=True)", "intent": "Provide exponential weighted ( EW ) functions . With arguments `adjust`.", "question_id": 32981}
{"snippet": "DataFrame.ewm(ignore_na=False)", "intent": "Provide exponential weighted ( EW ) functions . With arguments `ignore_na`.", "question_id": 32982}
{"snippet": "DataFrame.ewm(axis=0)", "intent": "Provide exponential weighted ( EW ) functions . With arguments `axis`.", "question_id": 32983}
{"snippet": "DataFrame.ewm(times=None)", "intent": "Provide exponential weighted ( EW ) functions . Specifying `times` with a timedelta halflife when computing mean .", "question_id": 32984}
{"snippet": "DataFrame.ewm()", "intent": "Provide exponential weighted ( EW ) functions .", "question_id": 32985}
{"snippet": "DataFrame.ewm(com=None)", "intent": "Provide exponential weighted ( EW ) functions . Exactly one parameter : `com` , `span` , `halflife` , or `alpha` must be provided .", "question_id": 32986}
{"snippet": "DataFrame.ewm(span=None)", "intent": "Provide exponential weighted ( EW ) functions . Exactly one parameter : `com` , `span` , `halflife` , or `alpha` must be provided .", "question_id": 32987}
{"snippet": "DataFrame.ewm(halflife=None)", "intent": "Provide exponential weighted ( EW ) functions . Exactly one parameter : `com` , `span` , `halflife` , or `alpha` must be provided .", "question_id": 32988}
{"snippet": "DataFrame.ewm(alpha=None)", "intent": "Provide exponential weighted ( EW ) functions . Exactly one parameter : `com` , `span` , `halflife` , or `alpha` must be provided .", "question_id": 32989}
{"snippet": "DataFrame.ewm(min_periods=0)", "intent": "Provide exponential weighted ( EW ) functions . With arguments `min_periods`.", "question_id": 32990}
{"snippet": "DataFrame.ewm(adjust=True)", "intent": "Provide exponential weighted ( EW ) functions . With arguments `adjust`.", "question_id": 32991}
{"snippet": "DataFrame.ewm(ignore_na=False)", "intent": "Provide exponential weighted ( EW ) functions . With arguments `ignore_na`.", "question_id": 32992}
{"snippet": "DataFrame.ewm(axis=0)", "intent": "Provide exponential weighted ( EW ) functions . With arguments `axis`.", "question_id": 32993}
{"snippet": "DataFrame.ewm(times=None)", "intent": "Provide exponential weighted ( EW ) functions . Specifying `times` with a timedelta halflife when computing mean .", "question_id": 32994}
{"snippet": "DataFrame.ewm()", "intent": "Provide exponential weighted ( EW ) functions .", "question_id": 32995}
{"snippet": "DataFrame.ewm(com=None)", "intent": "Provide exponential weighted ( EW ) functions . Exactly one parameter : `com` , `span` , `halflife` , or `alpha` must be provided .", "question_id": 32996}
{"snippet": "DataFrame.ewm(span=None)", "intent": "Provide exponential weighted ( EW ) functions . Exactly one parameter : `com` , `span` , `halflife` , or `alpha` must be provided .", "question_id": 32997}
{"snippet": "DataFrame.ewm(halflife=None)", "intent": "Provide exponential weighted ( EW ) functions . Exactly one parameter : `com` , `span` , `halflife` , or `alpha` must be provided .", "question_id": 32998}
{"snippet": "DataFrame.ewm(alpha=None)", "intent": "Provide exponential weighted ( EW ) functions . Exactly one parameter : `com` , `span` , `halflife` , or `alpha` must be provided .", "question_id": 32999}
{"snippet": "DataFrame.ewm(min_periods=0)", "intent": "Provide exponential weighted ( EW ) functions . With arguments `min_periods`.", "question_id": 33000}
{"snippet": "DataFrame.ewm(adjust=True)", "intent": "Provide exponential weighted ( EW ) functions . With arguments `adjust`.", "question_id": 33001}
{"snippet": "DataFrame.ewm(ignore_na=False)", "intent": "Provide exponential weighted ( EW ) functions . With arguments `ignore_na`.", "question_id": 33002}
{"snippet": "DataFrame.ewm(axis=0)", "intent": "Provide exponential weighted ( EW ) functions . With arguments `axis`.", "question_id": 33003}
{"snippet": "DataFrame.ewm(times=None)", "intent": "Provide exponential weighted ( EW ) functions . Specifying `times` with a timedelta halflife when computing mean .", "question_id": 33004}
{"snippet": "DataFrame.expanding()", "intent": "Provide expanding transformations .", "question_id": 33005}
{"snippet": "DataFrame.expanding(min_periods=1)", "intent": "Provide expanding transformations . With arguments `min_periods`.", "question_id": 33006}
{"snippet": "DataFrame.expanding(center=None)", "intent": "Provide expanding transformations . This can be changed to the `center` of the window by setting center=True .", "question_id": 33007}
{"snippet": "DataFrame.expanding(axis=0)", "intent": "Provide expanding transformations . With arguments `axis`.", "question_id": 33008}
{"snippet": "DataFrame.expanding(method='single')", "intent": "Provide expanding transformations . With arguments `method`.", "question_id": 33009}
{"snippet": "DataFrame.expanding(min_periods=1, center=None)", "intent": "Provide expanding transformations . This can be changed to the `center` of the window by setting center=True . With arguments `min_periods`.", "question_id": 33010}
{"snippet": "DataFrame.expanding(min_periods=1, axis=0)", "intent": "Provide expanding transformations . With arguments `min_periods`, `axis`.", "question_id": 33011}
{"snippet": "DataFrame.expanding(min_periods=1, method='single')", "intent": "Provide expanding transformations . With arguments `min_periods`, `method`.", "question_id": 33012}
{"snippet": "DataFrame.expanding(center=None, axis=0)", "intent": "Provide expanding transformations . This can be changed to the `center` of the window by setting center=True . With arguments `axis`.", "question_id": 33013}
{"snippet": "DataFrame.expanding(center=None, method='single')", "intent": "Provide expanding transformations . This can be changed to the `center` of the window by setting center=True . With arguments `method`.", "question_id": 33014}
{"snippet": "DataFrame.expanding()", "intent": "Provide expanding transformations .", "question_id": 33015}
{"snippet": "DataFrame.expanding(min_periods=1)", "intent": "Provide expanding transformations . With arguments `min_periods`.", "question_id": 33016}
{"snippet": "DataFrame.expanding(center=None)", "intent": "Provide expanding transformations . This can be changed to the `center` of the window by setting center=True .", "question_id": 33017}
{"snippet": "DataFrame.expanding(axis=0)", "intent": "Provide expanding transformations . With arguments `axis`.", "question_id": 33018}
{"snippet": "DataFrame.expanding(method='single')", "intent": "Provide expanding transformations . With arguments `method`.", "question_id": 33019}
{"snippet": "DataFrame.expanding(min_periods=1, center=None)", "intent": "Provide expanding transformations . This can be changed to the `center` of the window by setting center=True . With arguments `min_periods`.", "question_id": 33020}
{"snippet": "DataFrame.expanding(min_periods=1, axis=0)", "intent": "Provide expanding transformations . With arguments `min_periods`, `axis`.", "question_id": 33021}
{"snippet": "DataFrame.expanding(min_periods=1, method='single')", "intent": "Provide expanding transformations . With arguments `min_periods`, `method`.", "question_id": 33022}
{"snippet": "DataFrame.expanding(center=None, axis=0)", "intent": "Provide expanding transformations . This can be changed to the `center` of the window by setting center=True . With arguments `axis`.", "question_id": 33023}
{"snippet": "DataFrame.expanding(center=None, method='single')", "intent": "Provide expanding transformations . This can be changed to the `center` of the window by setting center=True . With arguments `method`.", "question_id": 33024}
{"snippet": "DataFrame.expanding()", "intent": "Provide expanding transformations .", "question_id": 33025}
{"snippet": "DataFrame.expanding(min_periods=1)", "intent": "Provide expanding transformations . With arguments `min_periods`.", "question_id": 33026}
{"snippet": "DataFrame.expanding(center=None)", "intent": "Provide expanding transformations . This can be changed to the `center` of the window by setting center=True .", "question_id": 33027}
{"snippet": "DataFrame.expanding(axis=0)", "intent": "Provide expanding transformations . With arguments `axis`.", "question_id": 33028}
{"snippet": "DataFrame.expanding(method='single')", "intent": "Provide expanding transformations . With arguments `method`.", "question_id": 33029}
{"snippet": "DataFrame.expanding(min_periods=1, center=None)", "intent": "Provide expanding transformations . This can be changed to the `center` of the window by setting center=True . With arguments `min_periods`.", "question_id": 33030}
{"snippet": "DataFrame.expanding(min_periods=1, axis=0)", "intent": "Provide expanding transformations . With arguments `min_periods`, `axis`.", "question_id": 33031}
{"snippet": "DataFrame.expanding(min_periods=1, method='single')", "intent": "Provide expanding transformations . With arguments `min_periods`, `method`.", "question_id": 33032}
{"snippet": "DataFrame.expanding(center=None, axis=0)", "intent": "Provide expanding transformations . This can be changed to the `center` of the window by setting center=True . With arguments `axis`.", "question_id": 33033}
{"snippet": "DataFrame.expanding(center=None, method='single')", "intent": "Provide expanding transformations . This can be changed to the `center` of the window by setting center=True . With arguments `method`.", "question_id": 33034}
{"snippet": "DataFrame.explode(column)", "intent": "Transform each element of a list-like to a row , replicating index values . With arguments `column`.", "question_id": 33035}
{"snippet": "DataFrame.explode(column, ignore_index=False)", "intent": "Transform each element of a list-like to a row , replicating index values . With arguments `column`, `ignore_index`.", "question_id": 33036}
{"snippet": "DataFrame.explode(column)", "intent": "Transform each element of a list-like to a row , replicating index values . With arguments `column`.", "question_id": 33037}
{"snippet": "DataFrame.explode(column, ignore_index=False)", "intent": "Transform each element of a list-like to a row , replicating index values . With arguments `column`, `ignore_index`.", "question_id": 33038}
{"snippet": "DataFrame.explode(column)", "intent": "Transform each element of a list-like to a row , replicating index values . With arguments `column`.", "question_id": 33039}
{"snippet": "DataFrame.explode(column, ignore_index=False)", "intent": "Transform each element of a list-like to a row , replicating index values . With arguments `column`, `ignore_index`.", "question_id": 33040}
{"snippet": "DataFrame.ffill()", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' .", "question_id": 33041}
{"snippet": "DataFrame.ffill(axis=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`.", "question_id": 33042}
{"snippet": "DataFrame.ffill(inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`.", "question_id": 33043}
{"snippet": "DataFrame.ffill(limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `limit`.", "question_id": 33044}
{"snippet": "DataFrame.ffill(downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `downcast`.", "question_id": 33045}
{"snippet": "DataFrame.ffill(axis=None, inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `inplace`.", "question_id": 33046}
{"snippet": "DataFrame.ffill(axis=None, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `limit`.", "question_id": 33047}
{"snippet": "DataFrame.ffill(axis=None, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `downcast`.", "question_id": 33048}
{"snippet": "DataFrame.ffill(inplace=False, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`, `limit`.", "question_id": 33049}
{"snippet": "DataFrame.ffill(inplace=False, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`, `downcast`.", "question_id": 33050}
{"snippet": "DataFrame.ffill()", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' .", "question_id": 33051}
{"snippet": "DataFrame.ffill(axis=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`.", "question_id": 33052}
{"snippet": "DataFrame.ffill(inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`.", "question_id": 33053}
{"snippet": "DataFrame.ffill(limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `limit`.", "question_id": 33054}
{"snippet": "DataFrame.ffill(downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `downcast`.", "question_id": 33055}
{"snippet": "DataFrame.ffill(axis=None, inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `inplace`.", "question_id": 33056}
{"snippet": "DataFrame.ffill(axis=None, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `limit`.", "question_id": 33057}
{"snippet": "DataFrame.ffill(axis=None, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `downcast`.", "question_id": 33058}
{"snippet": "DataFrame.ffill(inplace=False, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`, `limit`.", "question_id": 33059}
{"snippet": "DataFrame.ffill(inplace=False, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`, `downcast`.", "question_id": 33060}
{"snippet": "DataFrame.ffill()", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' .", "question_id": 33061}
{"snippet": "DataFrame.ffill(axis=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`.", "question_id": 33062}
{"snippet": "DataFrame.ffill(inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`.", "question_id": 33063}
{"snippet": "DataFrame.ffill(limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `limit`.", "question_id": 33064}
{"snippet": "DataFrame.ffill(downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `downcast`.", "question_id": 33065}
{"snippet": "DataFrame.ffill(axis=None, inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `inplace`.", "question_id": 33066}
{"snippet": "DataFrame.ffill(axis=None, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `limit`.", "question_id": 33067}
{"snippet": "DataFrame.ffill(axis=None, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `downcast`.", "question_id": 33068}
{"snippet": "DataFrame.ffill(inplace=False, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`, `limit`.", "question_id": 33069}
{"snippet": "DataFrame.ffill(inplace=False, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`, `downcast`.", "question_id": 33070}
{"snippet": "DataFrame.fillna()", "intent": "Fill NA/NaN values using the specified `method` .", "question_id": 33071}
{"snippet": "DataFrame.fillna(value=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`.", "question_id": 33072}
{"snippet": "DataFrame.fillna(method=None)", "intent": "Fill NA/NaN values using the specified `method` .", "question_id": 33073}
{"snippet": "DataFrame.fillna(axis=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `axis`.", "question_id": 33074}
{"snippet": "DataFrame.fillna(inplace=False)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `inplace`.", "question_id": 33075}
{"snippet": "DataFrame.fillna(limit=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `limit`.", "question_id": 33076}
{"snippet": "DataFrame.fillna(downcast=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `downcast`.", "question_id": 33077}
{"snippet": "DataFrame.fillna(value=None, method=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`.", "question_id": 33078}
{"snippet": "DataFrame.fillna(value=None, axis=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`, `axis`.", "question_id": 33079}
{"snippet": "DataFrame.fillna(value=None, inplace=False)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`, `inplace`.", "question_id": 33080}
{"snippet": "DataFrame.fillna()", "intent": "Fill NA/NaN values using the specified `method` .", "question_id": 33081}
{"snippet": "DataFrame.fillna(value=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`.", "question_id": 33082}
{"snippet": "DataFrame.fillna(method=None)", "intent": "Fill NA/NaN values using the specified `method` .", "question_id": 33083}
{"snippet": "DataFrame.fillna(axis=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `axis`.", "question_id": 33084}
{"snippet": "DataFrame.fillna(inplace=False)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `inplace`.", "question_id": 33085}
{"snippet": "DataFrame.fillna(limit=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `limit`.", "question_id": 33086}
{"snippet": "DataFrame.fillna(downcast=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `downcast`.", "question_id": 33087}
{"snippet": "DataFrame.fillna(value=None, method=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`.", "question_id": 33088}
{"snippet": "DataFrame.fillna(value=None, axis=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`, `axis`.", "question_id": 33089}
{"snippet": "DataFrame.fillna(value=None, inplace=False)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`, `inplace`.", "question_id": 33090}
{"snippet": "DataFrame.fillna()", "intent": "Fill NA/NaN values using the specified `method` .", "question_id": 33091}
{"snippet": "DataFrame.fillna(value=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`.", "question_id": 33092}
{"snippet": "DataFrame.fillna(method=None)", "intent": "Fill NA/NaN values using the specified `method` .", "question_id": 33093}
{"snippet": "DataFrame.fillna(axis=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `axis`.", "question_id": 33094}
{"snippet": "DataFrame.fillna(inplace=False)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `inplace`.", "question_id": 33095}
{"snippet": "DataFrame.fillna(limit=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `limit`.", "question_id": 33096}
{"snippet": "DataFrame.fillna(downcast=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `downcast`.", "question_id": 33097}
{"snippet": "DataFrame.fillna(value=None, method=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`.", "question_id": 33098}
{"snippet": "DataFrame.fillna(value=None, axis=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`, `axis`.", "question_id": 33099}
{"snippet": "DataFrame.fillna(value=None, inplace=False)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`, `inplace`.", "question_id": 33100}
{"snippet": "DataFrame.filter()", "intent": "Subset the dataframe rows or columns according to the specified index labels .", "question_id": 33101}
{"snippet": "DataFrame.filter(items=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 33102}
{"snippet": "DataFrame.filter(like=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 33103}
{"snippet": "DataFrame.filter(regex=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 33104}
{"snippet": "DataFrame.filter(axis=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . `axis` defaults to the info axis that is used when indexing with [ ] .", "question_id": 33105}
{"snippet": "DataFrame.filter(items=None, like=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 33106}
{"snippet": "DataFrame.filter(items=None, regex=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 33107}
{"snippet": "DataFrame.filter(items=None, axis=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive . `axis` defaults to the info axis that is used when indexing with [ ] .", "question_id": 33108}
{"snippet": "DataFrame.filter(like=None, regex=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 33109}
{"snippet": "DataFrame.filter(like=None, axis=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive . `axis` defaults to the info axis that is used when indexing with [ ] .", "question_id": 33110}
{"snippet": "DataFrame.filter()", "intent": "Subset the dataframe rows or columns according to the specified index labels .", "question_id": 33111}
{"snippet": "DataFrame.filter(items=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 33112}
{"snippet": "DataFrame.filter(like=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 33113}
{"snippet": "DataFrame.filter(regex=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 33114}
{"snippet": "DataFrame.filter(axis=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . `axis` defaults to the info axis that is used when indexing with [ ] .", "question_id": 33115}
{"snippet": "DataFrame.filter(items=None, like=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 33116}
{"snippet": "DataFrame.filter(items=None, regex=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 33117}
{"snippet": "DataFrame.filter(items=None, axis=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive . `axis` defaults to the info axis that is used when indexing with [ ] .", "question_id": 33118}
{"snippet": "DataFrame.filter(like=None, regex=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 33119}
{"snippet": "DataFrame.filter(like=None, axis=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive . `axis` defaults to the info axis that is used when indexing with [ ] .", "question_id": 33120}
{"snippet": "DataFrame.filter()", "intent": "Subset the dataframe rows or columns according to the specified index labels .", "question_id": 33121}
{"snippet": "DataFrame.filter(items=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 33122}
{"snippet": "DataFrame.filter(like=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 33123}
{"snippet": "DataFrame.filter(regex=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 33124}
{"snippet": "DataFrame.filter(axis=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . `axis` defaults to the info axis that is used when indexing with [ ] .", "question_id": 33125}
{"snippet": "DataFrame.filter(items=None, like=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 33126}
{"snippet": "DataFrame.filter(items=None, regex=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 33127}
{"snippet": "DataFrame.filter(items=None, axis=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive . `axis` defaults to the info axis that is used when indexing with [ ] .", "question_id": 33128}
{"snippet": "DataFrame.filter(like=None, regex=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 33129}
{"snippet": "DataFrame.filter(like=None, axis=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive . `axis` defaults to the info axis that is used when indexing with [ ] .", "question_id": 33130}
{"snippet": "DataFrame.first(offset)", "intent": "Select initial periods of time series data based on a date `offset` .", "question_id": 33131}
{"snippet": "DataFrame.first(offset)", "intent": "Select initial periods of time series data based on a date `offset` .", "question_id": 33132}
{"snippet": "DataFrame.first(offset)", "intent": "Select initial periods of time series data based on a date `offset` .", "question_id": 33133}
{"snippet": "DataFrame.first_valid_index()", "intent": "Return index for first non-NA value or None , if no NA value is found .", "question_id": 33134}
{"snippet": "DataFrame.first_valid_index()", "intent": "Return index for first non-NA value or None , if no NA value is found .", "question_id": 33135}
{"snippet": "DataFrame.first_valid_index()", "intent": "Return index for first non-NA value or None , if no NA value is found .", "question_id": 33136}
{"snippet": "DataFrame.floordiv(other)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator floordiv ) .", "question_id": 33137}
{"snippet": "DataFrame.floordiv(other, axis='columns')", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator floordiv ) . Subtract a list and Series by `axis` with operator version .", "question_id": 33138}
{"snippet": "DataFrame.floordiv(other, level=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator floordiv ) . Divide by a MultiIndex by `level` .", "question_id": 33139}
{"snippet": "DataFrame.floordiv(other, fill_value=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator floordiv ) . Equivalent to dataframe // other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33140}
{"snippet": "DataFrame.floordiv(other, axis='columns', level=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator floordiv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 33141}
{"snippet": "DataFrame.floordiv(other, axis='columns', fill_value=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator floordiv ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe // other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33142}
{"snippet": "DataFrame.floordiv(other, level=None, fill_value=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator floordiv ) . Divide by a MultiIndex by `level` . Equivalent to dataframe // other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33143}
{"snippet": "DataFrame.floordiv(other, axis='columns', level=None, fill_value=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator floordiv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe // other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33144}
{"snippet": "DataFrame.floordiv(other)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator floordiv ) .", "question_id": 33145}
{"snippet": "DataFrame.floordiv(other, axis='columns')", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator floordiv ) . Subtract a list and Series by `axis` with operator version .", "question_id": 33146}
{"snippet": "DataFrame.floordiv(other, level=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator floordiv ) . Divide by a MultiIndex by `level` .", "question_id": 33147}
{"snippet": "DataFrame.floordiv(other, fill_value=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator floordiv ) . Equivalent to dataframe // other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33148}
{"snippet": "DataFrame.floordiv(other, axis='columns', level=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator floordiv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 33149}
{"snippet": "DataFrame.floordiv(other, axis='columns', fill_value=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator floordiv ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe // other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33150}
{"snippet": "DataFrame.floordiv(other, level=None, fill_value=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator floordiv ) . Divide by a MultiIndex by `level` . Equivalent to dataframe // other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33151}
{"snippet": "DataFrame.floordiv(other, axis='columns', level=None, fill_value=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator floordiv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe // other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33152}
{"snippet": "DataFrame.floordiv(other)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator floordiv ) .", "question_id": 33153}
{"snippet": "DataFrame.floordiv(other, axis='columns')", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator floordiv ) . Subtract a list and Series by `axis` with operator version .", "question_id": 33154}
{"snippet": "DataFrame.floordiv(other, level=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator floordiv ) . Divide by a MultiIndex by `level` .", "question_id": 33155}
{"snippet": "DataFrame.floordiv(other, fill_value=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator floordiv ) . Equivalent to dataframe // other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33156}
{"snippet": "DataFrame.floordiv(other, axis='columns', level=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator floordiv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 33157}
{"snippet": "DataFrame.floordiv(other, axis='columns', fill_value=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator floordiv ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe // other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33158}
{"snippet": "DataFrame.floordiv(other, level=None, fill_value=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator floordiv ) . Divide by a MultiIndex by `level` . Equivalent to dataframe // other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33159}
{"snippet": "DataFrame.floordiv(other, axis='columns', level=None, fill_value=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator floordiv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe // other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33160}
{"snippet": "DataFrame.from_dict(data)", "intent": "Construct DataFrame from dict of array-like or dicts . With arguments `data`.", "question_id": 33161}
{"snippet": "DataFrame.from_dict(data, orient='columns')", "intent": "Construct DataFrame from dict of array-like or dicts . With arguments `data`, `orient`.", "question_id": 33162}
{"snippet": "DataFrame.from_dict(data, dtype=None)", "intent": "Construct DataFrame from dict of array-like or dicts . Creates DataFrame object from dictionary by `columns` or by index allowing `dtype` specification . With arguments `data`.", "question_id": 33163}
{"snippet": "DataFrame.from_dict(data, columns=None)", "intent": "Construct DataFrame from dict of array-like or dicts . Creates DataFrame object from dictionary by `columns` or by index allowing `dtype` specification . With arguments `data`.", "question_id": 33164}
{"snippet": "DataFrame.from_dict(data, orient='columns', dtype=None)", "intent": "Construct DataFrame from dict of array-like or dicts . Creates DataFrame object from dictionary by `columns` or by index allowing `dtype` specification . With arguments `data`, `orient`.", "question_id": 33165}
{"snippet": "DataFrame.from_dict(data, orient='columns', columns=None)", "intent": "Construct DataFrame from dict of array-like or dicts . Creates DataFrame object from dictionary by `columns` or by index allowing `dtype` specification . With arguments `data`, `orient`.", "question_id": 33166}
{"snippet": "DataFrame.from_dict(data, dtype=None, columns=None)", "intent": "Construct DataFrame from dict of array-like or dicts . Creates DataFrame object from dictionary by `columns` or by index allowing `dtype` specification . With arguments `data`.", "question_id": 33167}
{"snippet": "DataFrame.from_dict(data, orient='columns', dtype=None, columns=None)", "intent": "Construct DataFrame from dict of array-like or dicts . Creates DataFrame object from dictionary by `columns` or by index allowing `dtype` specification . With arguments `data`, `orient`.", "question_id": 33168}
{"snippet": "DataFrame.from_dict(data)", "intent": "Construct DataFrame from dict of array-like or dicts . With arguments `data`.", "question_id": 33169}
{"snippet": "DataFrame.from_dict(data, orient='columns')", "intent": "Construct DataFrame from dict of array-like or dicts . With arguments `data`, `orient`.", "question_id": 33170}
{"snippet": "DataFrame.from_dict(data, dtype=None)", "intent": "Construct DataFrame from dict of array-like or dicts . Creates DataFrame object from dictionary by `columns` or by index allowing `dtype` specification . With arguments `data`.", "question_id": 33171}
{"snippet": "DataFrame.from_dict(data, columns=None)", "intent": "Construct DataFrame from dict of array-like or dicts . Creates DataFrame object from dictionary by `columns` or by index allowing `dtype` specification . With arguments `data`.", "question_id": 33172}
{"snippet": "DataFrame.from_dict(data, orient='columns', dtype=None)", "intent": "Construct DataFrame from dict of array-like or dicts . Creates DataFrame object from dictionary by `columns` or by index allowing `dtype` specification . With arguments `data`, `orient`.", "question_id": 33173}
{"snippet": "DataFrame.from_dict(data, orient='columns', columns=None)", "intent": "Construct DataFrame from dict of array-like or dicts . Creates DataFrame object from dictionary by `columns` or by index allowing `dtype` specification . With arguments `data`, `orient`.", "question_id": 33174}
{"snippet": "DataFrame.from_dict(data, dtype=None, columns=None)", "intent": "Construct DataFrame from dict of array-like or dicts . Creates DataFrame object from dictionary by `columns` or by index allowing `dtype` specification . With arguments `data`.", "question_id": 33175}
{"snippet": "DataFrame.from_dict(data, orient='columns', dtype=None, columns=None)", "intent": "Construct DataFrame from dict of array-like or dicts . Creates DataFrame object from dictionary by `columns` or by index allowing `dtype` specification . With arguments `data`, `orient`.", "question_id": 33176}
{"snippet": "DataFrame.from_dict(data)", "intent": "Construct DataFrame from dict of array-like or dicts . With arguments `data`.", "question_id": 33177}
{"snippet": "DataFrame.from_dict(data, orient='columns')", "intent": "Construct DataFrame from dict of array-like or dicts . With arguments `data`, `orient`.", "question_id": 33178}
{"snippet": "DataFrame.from_dict(data, dtype=None)", "intent": "Construct DataFrame from dict of array-like or dicts . Creates DataFrame object from dictionary by `columns` or by index allowing `dtype` specification . With arguments `data`.", "question_id": 33179}
{"snippet": "DataFrame.from_dict(data, columns=None)", "intent": "Construct DataFrame from dict of array-like or dicts . Creates DataFrame object from dictionary by `columns` or by index allowing `dtype` specification . With arguments `data`.", "question_id": 33180}
{"snippet": "DataFrame.from_dict(data, orient='columns', dtype=None)", "intent": "Construct DataFrame from dict of array-like or dicts . Creates DataFrame object from dictionary by `columns` or by index allowing `dtype` specification . With arguments `data`, `orient`.", "question_id": 33181}
{"snippet": "DataFrame.from_dict(data, orient='columns', columns=None)", "intent": "Construct DataFrame from dict of array-like or dicts . Creates DataFrame object from dictionary by `columns` or by index allowing `dtype` specification . With arguments `data`, `orient`.", "question_id": 33182}
{"snippet": "DataFrame.from_dict(data, dtype=None, columns=None)", "intent": "Construct DataFrame from dict of array-like or dicts . Creates DataFrame object from dictionary by `columns` or by index allowing `dtype` specification . With arguments `data`.", "question_id": 33183}
{"snippet": "DataFrame.from_dict(data, orient='columns', dtype=None, columns=None)", "intent": "Construct DataFrame from dict of array-like or dicts . Creates DataFrame object from dictionary by `columns` or by index allowing `dtype` specification . With arguments `data`, `orient`.", "question_id": 33184}
{"snippet": "DataFrame.from_records(data)", "intent": "Convert structured or record ndarray to DataFrame . With arguments `data`.", "question_id": 33185}
{"snippet": "DataFrame.from_records(data, index=None)", "intent": "Convert structured or record ndarray to DataFrame . With arguments `data`, `index`.", "question_id": 33186}
{"snippet": "DataFrame.from_records(data, exclude=None)", "intent": "Convert structured or record ndarray to DataFrame . With arguments `data`, `exclude`.", "question_id": 33187}
{"snippet": "DataFrame.from_records(data, columns=None)", "intent": "Convert structured or record ndarray to DataFrame . Data can be provided as a list of tuples with corresponding `columns` : With arguments `data`.", "question_id": 33188}
{"snippet": "DataFrame.from_records(data, coerce_float=False)", "intent": "Convert structured or record ndarray to DataFrame . With arguments `data`, `coerce_float`.", "question_id": 33189}
{"snippet": "DataFrame.from_records(data, nrows=None)", "intent": "Convert structured or record ndarray to DataFrame . With arguments `data`, `nrows`.", "question_id": 33190}
{"snippet": "DataFrame.from_records(data, index=None, exclude=None)", "intent": "Convert structured or record ndarray to DataFrame . With arguments `data`, `index`, `exclude`.", "question_id": 33191}
{"snippet": "DataFrame.from_records(data, index=None, columns=None)", "intent": "Convert structured or record ndarray to DataFrame . Data can be provided as a list of tuples with corresponding `columns` : With arguments `data`, `index`.", "question_id": 33192}
{"snippet": "DataFrame.from_records(data, index=None, coerce_float=False)", "intent": "Convert structured or record ndarray to DataFrame . With arguments `data`, `index`, `coerce_float`.", "question_id": 33193}
{"snippet": "DataFrame.from_records(data, index=None, nrows=None)", "intent": "Convert structured or record ndarray to DataFrame . With arguments `data`, `index`, `nrows`.", "question_id": 33194}
{"snippet": "DataFrame.from_records(data)", "intent": "Convert structured or record ndarray to DataFrame . With arguments `data`.", "question_id": 33195}
{"snippet": "DataFrame.from_records(data, index=None)", "intent": "Convert structured or record ndarray to DataFrame . With arguments `data`, `index`.", "question_id": 33196}
{"snippet": "DataFrame.from_records(data, exclude=None)", "intent": "Convert structured or record ndarray to DataFrame . With arguments `data`, `exclude`.", "question_id": 33197}
{"snippet": "DataFrame.from_records(data, columns=None)", "intent": "Convert structured or record ndarray to DataFrame . Data can be provided as a list of tuples with corresponding `columns` : With arguments `data`.", "question_id": 33198}
{"snippet": "DataFrame.from_records(data, coerce_float=False)", "intent": "Convert structured or record ndarray to DataFrame . With arguments `data`, `coerce_float`.", "question_id": 33199}
{"snippet": "DataFrame.from_records(data, nrows=None)", "intent": "Convert structured or record ndarray to DataFrame . With arguments `data`, `nrows`.", "question_id": 33200}
{"snippet": "DataFrame.from_records(data, index=None, exclude=None)", "intent": "Convert structured or record ndarray to DataFrame . With arguments `data`, `index`, `exclude`.", "question_id": 33201}
{"snippet": "DataFrame.from_records(data, index=None, columns=None)", "intent": "Convert structured or record ndarray to DataFrame . Data can be provided as a list of tuples with corresponding `columns` : With arguments `data`, `index`.", "question_id": 33202}
{"snippet": "DataFrame.from_records(data, index=None, coerce_float=False)", "intent": "Convert structured or record ndarray to DataFrame . With arguments `data`, `index`, `coerce_float`.", "question_id": 33203}
{"snippet": "DataFrame.from_records(data, index=None, nrows=None)", "intent": "Convert structured or record ndarray to DataFrame . With arguments `data`, `index`, `nrows`.", "question_id": 33204}
{"snippet": "DataFrame.from_records(data)", "intent": "Convert structured or record ndarray to DataFrame . With arguments `data`.", "question_id": 33205}
{"snippet": "DataFrame.from_records(data, index=None)", "intent": "Convert structured or record ndarray to DataFrame . With arguments `data`, `index`.", "question_id": 33206}
{"snippet": "DataFrame.from_records(data, exclude=None)", "intent": "Convert structured or record ndarray to DataFrame . With arguments `data`, `exclude`.", "question_id": 33207}
{"snippet": "DataFrame.from_records(data, columns=None)", "intent": "Convert structured or record ndarray to DataFrame . Data can be provided as a list of tuples with corresponding `columns` : With arguments `data`.", "question_id": 33208}
{"snippet": "DataFrame.from_records(data, coerce_float=False)", "intent": "Convert structured or record ndarray to DataFrame . With arguments `data`, `coerce_float`.", "question_id": 33209}
{"snippet": "DataFrame.from_records(data, nrows=None)", "intent": "Convert structured or record ndarray to DataFrame . With arguments `data`, `nrows`.", "question_id": 33210}
{"snippet": "DataFrame.from_records(data, index=None, exclude=None)", "intent": "Convert structured or record ndarray to DataFrame . With arguments `data`, `index`, `exclude`.", "question_id": 33211}
{"snippet": "DataFrame.from_records(data, index=None, columns=None)", "intent": "Convert structured or record ndarray to DataFrame . Data can be provided as a list of tuples with corresponding `columns` : With arguments `data`, `index`.", "question_id": 33212}
{"snippet": "DataFrame.from_records(data, index=None, coerce_float=False)", "intent": "Convert structured or record ndarray to DataFrame . With arguments `data`, `index`, `coerce_float`.", "question_id": 33213}
{"snippet": "DataFrame.from_records(data, index=None, nrows=None)", "intent": "Convert structured or record ndarray to DataFrame . With arguments `data`, `index`, `nrows`.", "question_id": 33214}
{"snippet": "DataFrame.ge(other)", "intent": "Get Greater than or equal to of dataframe and `other` , element-wise ( binary operator ge ) .", "question_id": 33215}
{"snippet": "DataFrame.ge(other, axis='columns')", "intent": "Get Greater than or equal to of dataframe and `other` , element-wise ( binary operator ge ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33216}
{"snippet": "DataFrame.ge(other, level=None)", "intent": "Get Greater than or equal to of dataframe and `other` , element-wise ( binary operator ge ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33217}
{"snippet": "DataFrame.ge(other, axis='columns', level=None)", "intent": "Get Greater than or equal to of dataframe and `other` , element-wise ( binary operator ge ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33218}
{"snippet": "DataFrame.ge(other)", "intent": "Get Greater than or equal to of dataframe and `other` , element-wise ( binary operator ge ) .", "question_id": 33219}
{"snippet": "DataFrame.ge(other, axis='columns')", "intent": "Get Greater than or equal to of dataframe and `other` , element-wise ( binary operator ge ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33220}
{"snippet": "DataFrame.ge(other, level=None)", "intent": "Get Greater than or equal to of dataframe and `other` , element-wise ( binary operator ge ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33221}
{"snippet": "DataFrame.ge(other, axis='columns', level=None)", "intent": "Get Greater than or equal to of dataframe and `other` , element-wise ( binary operator ge ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33222}
{"snippet": "DataFrame.ge(other)", "intent": "Get Greater than or equal to of dataframe and `other` , element-wise ( binary operator ge ) .", "question_id": 33223}
{"snippet": "DataFrame.ge(other, axis='columns')", "intent": "Get Greater than or equal to of dataframe and `other` , element-wise ( binary operator ge ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33224}
{"snippet": "DataFrame.ge(other, level=None)", "intent": "Get Greater than or equal to of dataframe and `other` , element-wise ( binary operator ge ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33225}
{"snippet": "DataFrame.ge(other, axis='columns', level=None)", "intent": "Get Greater than or equal to of dataframe and `other` , element-wise ( binary operator ge ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33226}
{"snippet": "DataFrame.get(key)", "intent": "Get item from object for given `key` ( ex : DataFrame column ) .", "question_id": 33227}
{"snippet": "DataFrame.get(key, default=None)", "intent": "Get item from object for given `key` ( ex : DataFrame column ) . Returns `default` value if not found .", "question_id": 33228}
{"snippet": "DataFrame.get(key)", "intent": "Get item from object for given `key` ( ex : DataFrame column ) .", "question_id": 33229}
{"snippet": "DataFrame.get(key, default=None)", "intent": "Get item from object for given `key` ( ex : DataFrame column ) . Returns `default` value if not found .", "question_id": 33230}
{"snippet": "DataFrame.get(key)", "intent": "Get item from object for given `key` ( ex : DataFrame column ) .", "question_id": 33231}
{"snippet": "DataFrame.get(key, default=None)", "intent": "Get item from object for given `key` ( ex : DataFrame column ) . Returns `default` value if not found .", "question_id": 33232}
{"snippet": "DataFrame.groupby()", "intent": "Group DataFrame using a mapper or `by` a Series of columns .", "question_id": 33233}
{"snippet": "DataFrame.groupby(by=None)", "intent": "Group DataFrame using a mapper or `by` a Series of columns .", "question_id": 33234}
{"snippet": "DataFrame.groupby(axis=0)", "intent": "Group DataFrame using a mapper or `by` a Series of columns . With arguments `axis`.", "question_id": 33235}
{"snippet": "DataFrame.groupby(level=None)", "intent": "Group DataFrame using a mapper or `by` a Series of columns . We can groupby different levels of a hierarchical index using the `level` parameter :", "question_id": 33236}
{"snippet": "DataFrame.groupby(as_index=True)", "intent": "Group DataFrame using a mapper or `by` a Series of columns . With arguments `as_index`.", "question_id": 33237}
{"snippet": "DataFrame.groupby(sort=True)", "intent": "Group DataFrame using a mapper or `by` a Series of columns . With arguments `sort`.", "question_id": 33238}
{"snippet": "DataFrame.groupby(group_keys=True)", "intent": "Group DataFrame using a mapper or `by` a Series of columns . With arguments `group_keys`.", "question_id": 33239}
{"snippet": "DataFrame.groupby(squeeze=NoDefault.no_default)", "intent": "Group DataFrame using a mapper or `by` a Series of columns . With arguments `squeeze`.", "question_id": 33240}
{"snippet": "DataFrame.groupby(observed=False)", "intent": "Group DataFrame using a mapper or `by` a Series of columns . With arguments `observed`.", "question_id": 33241}
{"snippet": "DataFrame.groupby(dropna=True)", "intent": "Group DataFrame using a mapper or `by` a Series of columns . We can also choose to include NA in group keys or not by setting `dropna` parameter , the default setting is True :", "question_id": 33242}
{"snippet": "DataFrame.groupby()", "intent": "Group DataFrame using a mapper or `by` a Series of columns .", "question_id": 33243}
{"snippet": "DataFrame.groupby(by=None)", "intent": "Group DataFrame using a mapper or `by` a Series of columns .", "question_id": 33244}
{"snippet": "DataFrame.groupby(axis=0)", "intent": "Group DataFrame using a mapper or `by` a Series of columns . With arguments `axis`.", "question_id": 33245}
{"snippet": "DataFrame.groupby(level=None)", "intent": "Group DataFrame using a mapper or `by` a Series of columns . We can groupby different levels of a hierarchical index using the `level` parameter :", "question_id": 33246}
{"snippet": "DataFrame.groupby(as_index=True)", "intent": "Group DataFrame using a mapper or `by` a Series of columns . With arguments `as_index`.", "question_id": 33247}
{"snippet": "DataFrame.groupby(sort=True)", "intent": "Group DataFrame using a mapper or `by` a Series of columns . With arguments `sort`.", "question_id": 33248}
{"snippet": "DataFrame.groupby(group_keys=True)", "intent": "Group DataFrame using a mapper or `by` a Series of columns . With arguments `group_keys`.", "question_id": 33249}
{"snippet": "DataFrame.groupby(squeeze=NoDefault.no_default)", "intent": "Group DataFrame using a mapper or `by` a Series of columns . With arguments `squeeze`.", "question_id": 33250}
{"snippet": "DataFrame.groupby(observed=False)", "intent": "Group DataFrame using a mapper or `by` a Series of columns . With arguments `observed`.", "question_id": 33251}
{"snippet": "DataFrame.groupby(dropna=True)", "intent": "Group DataFrame using a mapper or `by` a Series of columns . We can also choose to include NA in group keys or not by setting `dropna` parameter , the default setting is True :", "question_id": 33252}
{"snippet": "DataFrame.groupby()", "intent": "Group DataFrame using a mapper or `by` a Series of columns .", "question_id": 33253}
{"snippet": "DataFrame.groupby(by=None)", "intent": "Group DataFrame using a mapper or `by` a Series of columns .", "question_id": 33254}
{"snippet": "DataFrame.groupby(axis=0)", "intent": "Group DataFrame using a mapper or `by` a Series of columns . With arguments `axis`.", "question_id": 33255}
{"snippet": "DataFrame.groupby(level=None)", "intent": "Group DataFrame using a mapper or `by` a Series of columns . We can groupby different levels of a hierarchical index using the `level` parameter :", "question_id": 33256}
{"snippet": "DataFrame.groupby(as_index=True)", "intent": "Group DataFrame using a mapper or `by` a Series of columns . With arguments `as_index`.", "question_id": 33257}
{"snippet": "DataFrame.groupby(sort=True)", "intent": "Group DataFrame using a mapper or `by` a Series of columns . With arguments `sort`.", "question_id": 33258}
{"snippet": "DataFrame.groupby(group_keys=True)", "intent": "Group DataFrame using a mapper or `by` a Series of columns . With arguments `group_keys`.", "question_id": 33259}
{"snippet": "DataFrame.groupby(squeeze=NoDefault.no_default)", "intent": "Group DataFrame using a mapper or `by` a Series of columns . With arguments `squeeze`.", "question_id": 33260}
{"snippet": "DataFrame.groupby(observed=False)", "intent": "Group DataFrame using a mapper or `by` a Series of columns . With arguments `observed`.", "question_id": 33261}
{"snippet": "DataFrame.groupby(dropna=True)", "intent": "Group DataFrame using a mapper or `by` a Series of columns . We can also choose to include NA in group keys or not by setting `dropna` parameter , the default setting is True :", "question_id": 33262}
{"snippet": "DataFrame.gt(other)", "intent": "Get Greater than of dataframe and `other` , element-wise ( binary operator gt ) .", "question_id": 33263}
{"snippet": "DataFrame.gt(other, axis='columns')", "intent": "Get Greater than of dataframe and `other` , element-wise ( binary operator gt ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33264}
{"snippet": "DataFrame.gt(other, level=None)", "intent": "Get Greater than of dataframe and `other` , element-wise ( binary operator gt ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33265}
{"snippet": "DataFrame.gt(other, axis='columns', level=None)", "intent": "Get Greater than of dataframe and `other` , element-wise ( binary operator gt ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33266}
{"snippet": "DataFrame.gt(other)", "intent": "Get Greater than of dataframe and `other` , element-wise ( binary operator gt ) .", "question_id": 33267}
{"snippet": "DataFrame.gt(other, axis='columns')", "intent": "Get Greater than of dataframe and `other` , element-wise ( binary operator gt ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33268}
{"snippet": "DataFrame.gt(other, level=None)", "intent": "Get Greater than of dataframe and `other` , element-wise ( binary operator gt ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33269}
{"snippet": "DataFrame.gt(other, axis='columns', level=None)", "intent": "Get Greater than of dataframe and `other` , element-wise ( binary operator gt ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33270}
{"snippet": "DataFrame.gt(other)", "intent": "Get Greater than of dataframe and `other` , element-wise ( binary operator gt ) .", "question_id": 33271}
{"snippet": "DataFrame.gt(other, axis='columns')", "intent": "Get Greater than of dataframe and `other` , element-wise ( binary operator gt ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33272}
{"snippet": "DataFrame.gt(other, level=None)", "intent": "Get Greater than of dataframe and `other` , element-wise ( binary operator gt ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33273}
{"snippet": "DataFrame.gt(other, axis='columns', level=None)", "intent": "Get Greater than of dataframe and `other` , element-wise ( binary operator gt ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33274}
{"snippet": "DataFrame.head()", "intent": "Return the first `n` rows .", "question_id": 33275}
{"snippet": "DataFrame.head(n=5)", "intent": "Return the first `n` rows .", "question_id": 33276}
{"snippet": "DataFrame.head()", "intent": "Return the first `n` rows .", "question_id": 33277}
{"snippet": "DataFrame.head(n=5)", "intent": "Return the first `n` rows .", "question_id": 33278}
{"snippet": "DataFrame.head()", "intent": "Return the first `n` rows .", "question_id": 33279}
{"snippet": "DataFrame.head(n=5)", "intent": "Return the first `n` rows .", "question_id": 33280}
{"snippet": "DataFrame.hist(**kwargs)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`.", "question_id": 33281}
{"snippet": "DataFrame.hist(**kwargs, column=None)", "intent": "Make a histogram of the DataFrame \u2019 s columns . This function calls matplotlib.pyplot.hist ( ) , on each series in the DataFrame , resulting in one histogram per `column` . With arguments `**kwargs`.", "question_id": 33282}
{"snippet": "DataFrame.hist(**kwargs, by=None)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `by`.", "question_id": 33283}
{"snippet": "DataFrame.hist(**kwargs, grid=True)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `grid`.", "question_id": 33284}
{"snippet": "DataFrame.hist(**kwargs, xlabelsize=None)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `xlabelsize`.", "question_id": 33285}
{"snippet": "DataFrame.hist(**kwargs, xrot=None)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `xrot`.", "question_id": 33286}
{"snippet": "DataFrame.hist(**kwargs, ylabelsize=None)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `ylabelsize`.", "question_id": 33287}
{"snippet": "DataFrame.hist(**kwargs, yrot=None)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `yrot`.", "question_id": 33288}
{"snippet": "DataFrame.hist(**kwargs, ax=None)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `ax`.", "question_id": 33289}
{"snippet": "DataFrame.hist(**kwargs, sharex=False)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `sharex`.", "question_id": 33290}
{"snippet": "DataFrame.hist(**kwargs)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`.", "question_id": 33291}
{"snippet": "DataFrame.hist(**kwargs, column=None)", "intent": "Make a histogram of the DataFrame \u2019 s columns . This function calls matplotlib.pyplot.hist ( ) , on each series in the DataFrame , resulting in one histogram per `column` . With arguments `**kwargs`.", "question_id": 33292}
{"snippet": "DataFrame.hist(**kwargs, by=None)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `by`.", "question_id": 33293}
{"snippet": "DataFrame.hist(**kwargs, grid=True)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `grid`.", "question_id": 33294}
{"snippet": "DataFrame.hist(**kwargs, xlabelsize=None)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `xlabelsize`.", "question_id": 33295}
{"snippet": "DataFrame.hist(**kwargs, xrot=None)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `xrot`.", "question_id": 33296}
{"snippet": "DataFrame.hist(**kwargs, ylabelsize=None)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `ylabelsize`.", "question_id": 33297}
{"snippet": "DataFrame.hist(**kwargs, yrot=None)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `yrot`.", "question_id": 33298}
{"snippet": "DataFrame.hist(**kwargs, ax=None)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `ax`.", "question_id": 33299}
{"snippet": "DataFrame.hist(**kwargs, sharex=False)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `sharex`.", "question_id": 33300}
{"snippet": "DataFrame.hist(**kwargs)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`.", "question_id": 33301}
{"snippet": "DataFrame.hist(**kwargs, column=None)", "intent": "Make a histogram of the DataFrame \u2019 s columns . This function calls matplotlib.pyplot.hist ( ) , on each series in the DataFrame , resulting in one histogram per `column` . With arguments `**kwargs`.", "question_id": 33302}
{"snippet": "DataFrame.hist(**kwargs, by=None)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `by`.", "question_id": 33303}
{"snippet": "DataFrame.hist(**kwargs, grid=True)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `grid`.", "question_id": 33304}
{"snippet": "DataFrame.hist(**kwargs, xlabelsize=None)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `xlabelsize`.", "question_id": 33305}
{"snippet": "DataFrame.hist(**kwargs, xrot=None)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `xrot`.", "question_id": 33306}
{"snippet": "DataFrame.hist(**kwargs, ylabelsize=None)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `ylabelsize`.", "question_id": 33307}
{"snippet": "DataFrame.hist(**kwargs, yrot=None)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `yrot`.", "question_id": 33308}
{"snippet": "DataFrame.hist(**kwargs, ax=None)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `ax`.", "question_id": 33309}
{"snippet": "DataFrame.hist(**kwargs, sharex=False)", "intent": "Make a histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `sharex`.", "question_id": 33310}
{"snippet": "pandas.DataFrame()", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` .", "question_id": 33311}
{"snippet": "pandas.DataFrame(data=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` .", "question_id": 33312}
{"snippet": "pandas.DataFrame(index=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` . With arguments `index`.", "question_id": 33313}
{"snippet": "pandas.DataFrame(columns=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` . Data structure also contains labeled axes ( rows and `columns` ) .", "question_id": 33314}
{"snippet": "pandas.DataFrame(dtype=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` . Notice that the inferred `dtype` is int64 .", "question_id": 33315}
{"snippet": "pandas.DataFrame(copy=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` . With arguments `copy`.", "question_id": 33316}
{"snippet": "pandas.DataFrame(data=None, index=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` . With arguments `index`.", "question_id": 33317}
{"snippet": "pandas.DataFrame(data=None, columns=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` . Data structure also contains labeled axes ( rows and `columns` ) .", "question_id": 33318}
{"snippet": "pandas.DataFrame(data=None, dtype=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` . Notice that the inferred `dtype` is int64 .", "question_id": 33319}
{"snippet": "pandas.DataFrame(data=None, copy=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` . With arguments `copy`.", "question_id": 33320}
{"snippet": "pandas.DataFrame()", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` .", "question_id": 33321}
{"snippet": "pandas.DataFrame(data=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` .", "question_id": 33322}
{"snippet": "pandas.DataFrame(index=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` . With arguments `index`.", "question_id": 33323}
{"snippet": "pandas.DataFrame(columns=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` . Data structure also contains labeled axes ( rows and `columns` ) .", "question_id": 33324}
{"snippet": "pandas.DataFrame(dtype=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` . Notice that the inferred `dtype` is int64 .", "question_id": 33325}
{"snippet": "pandas.DataFrame(copy=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` . With arguments `copy`.", "question_id": 33326}
{"snippet": "pandas.DataFrame(data=None, index=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` . With arguments `index`.", "question_id": 33327}
{"snippet": "pandas.DataFrame(data=None, columns=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` . Data structure also contains labeled axes ( rows and `columns` ) .", "question_id": 33328}
{"snippet": "pandas.DataFrame(data=None, dtype=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` . Notice that the inferred `dtype` is int64 .", "question_id": 33329}
{"snippet": "pandas.DataFrame(data=None, copy=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` . With arguments `copy`.", "question_id": 33330}
{"snippet": "pandas.DataFrame()", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` .", "question_id": 33331}
{"snippet": "pandas.DataFrame(data=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` .", "question_id": 33332}
{"snippet": "pandas.DataFrame(index=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` . With arguments `index`.", "question_id": 33333}
{"snippet": "pandas.DataFrame(columns=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` . Data structure also contains labeled axes ( rows and `columns` ) .", "question_id": 33334}
{"snippet": "pandas.DataFrame(dtype=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` . Notice that the inferred `dtype` is int64 .", "question_id": 33335}
{"snippet": "pandas.DataFrame(copy=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` . With arguments `copy`.", "question_id": 33336}
{"snippet": "pandas.DataFrame(data=None, index=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` . With arguments `index`.", "question_id": 33337}
{"snippet": "pandas.DataFrame(data=None, columns=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` . Data structure also contains labeled axes ( rows and `columns` ) .", "question_id": 33338}
{"snippet": "pandas.DataFrame(data=None, dtype=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` . Notice that the inferred `dtype` is int64 .", "question_id": 33339}
{"snippet": "pandas.DataFrame(data=None, copy=None)", "intent": "Two-dimensional , size-mutable , potentially heterogeneous tabular `data` . With arguments `copy`.", "question_id": 33340}
{"snippet": "DataFrame.idxmax()", "intent": "Return index of first occurrence of maximum over requested `axis` .", "question_id": 33341}
{"snippet": "DataFrame.idxmax(axis=0)", "intent": "Return index of first occurrence of maximum over requested `axis` .", "question_id": 33342}
{"snippet": "DataFrame.idxmax(skipna=True)", "intent": "Return index of first occurrence of maximum over requested `axis` . With arguments `skipna`.", "question_id": 33343}
{"snippet": "DataFrame.idxmax(axis=0, skipna=True)", "intent": "Return index of first occurrence of maximum over requested `axis` . With arguments `skipna`.", "question_id": 33344}
{"snippet": "DataFrame.idxmax()", "intent": "Return index of first occurrence of maximum over requested `axis` .", "question_id": 33345}
{"snippet": "DataFrame.idxmax(axis=0)", "intent": "Return index of first occurrence of maximum over requested `axis` .", "question_id": 33346}
{"snippet": "DataFrame.idxmax(skipna=True)", "intent": "Return index of first occurrence of maximum over requested `axis` . With arguments `skipna`.", "question_id": 33347}
{"snippet": "DataFrame.idxmax(axis=0, skipna=True)", "intent": "Return index of first occurrence of maximum over requested `axis` . With arguments `skipna`.", "question_id": 33348}
{"snippet": "DataFrame.idxmax()", "intent": "Return index of first occurrence of maximum over requested `axis` .", "question_id": 33349}
{"snippet": "DataFrame.idxmax(axis=0)", "intent": "Return index of first occurrence of maximum over requested `axis` .", "question_id": 33350}
{"snippet": "DataFrame.idxmax(skipna=True)", "intent": "Return index of first occurrence of maximum over requested `axis` . With arguments `skipna`.", "question_id": 33351}
{"snippet": "DataFrame.idxmax(axis=0, skipna=True)", "intent": "Return index of first occurrence of maximum over requested `axis` . With arguments `skipna`.", "question_id": 33352}
{"snippet": "DataFrame.idxmin()", "intent": "Return index of first occurrence of minimum over requested `axis` .", "question_id": 33353}
{"snippet": "DataFrame.idxmin(axis=0)", "intent": "Return index of first occurrence of minimum over requested `axis` .", "question_id": 33354}
{"snippet": "DataFrame.idxmin(skipna=True)", "intent": "Return index of first occurrence of minimum over requested `axis` . With arguments `skipna`.", "question_id": 33355}
{"snippet": "DataFrame.idxmin(axis=0, skipna=True)", "intent": "Return index of first occurrence of minimum over requested `axis` . With arguments `skipna`.", "question_id": 33356}
{"snippet": "DataFrame.idxmin()", "intent": "Return index of first occurrence of minimum over requested `axis` .", "question_id": 33357}
{"snippet": "DataFrame.idxmin(axis=0)", "intent": "Return index of first occurrence of minimum over requested `axis` .", "question_id": 33358}
{"snippet": "DataFrame.idxmin(skipna=True)", "intent": "Return index of first occurrence of minimum over requested `axis` . With arguments `skipna`.", "question_id": 33359}
{"snippet": "DataFrame.idxmin(axis=0, skipna=True)", "intent": "Return index of first occurrence of minimum over requested `axis` . With arguments `skipna`.", "question_id": 33360}
{"snippet": "DataFrame.idxmin()", "intent": "Return index of first occurrence of minimum over requested `axis` .", "question_id": 33361}
{"snippet": "DataFrame.idxmin(axis=0)", "intent": "Return index of first occurrence of minimum over requested `axis` .", "question_id": 33362}
{"snippet": "DataFrame.idxmin(skipna=True)", "intent": "Return index of first occurrence of minimum over requested `axis` . With arguments `skipna`.", "question_id": 33363}
{"snippet": "DataFrame.idxmin(axis=0, skipna=True)", "intent": "Return index of first occurrence of minimum over requested `axis` . With arguments `skipna`.", "question_id": 33364}
{"snippet": "DataFrame.index", "intent": "The index (row labels) of the DataFrame.", "question_id": 33365}
{"snippet": "DataFrame.index", "intent": "The index (row labels) of the DataFrame.", "question_id": 33366}
{"snippet": "DataFrame.index", "intent": "The index (row labels) of the DataFrame.", "question_id": 33367}
{"snippet": "DataFrame.infer_objects()", "intent": "Attempt to infer better dtypes for object columns .", "question_id": 33368}
{"snippet": "DataFrame.infer_objects()", "intent": "Attempt to infer better dtypes for object columns .", "question_id": 33369}
{"snippet": "DataFrame.infer_objects()", "intent": "Attempt to infer better dtypes for object columns .", "question_id": 33370}
{"snippet": "DataFrame.info()", "intent": "Print a concise summary of a DataFrame .", "question_id": 33371}
{"snippet": "DataFrame.info(verbose=None)", "intent": "Print a concise summary of a DataFrame . With arguments `verbose`.", "question_id": 33372}
{"snippet": "DataFrame.info(buf=None)", "intent": "Print a concise summary of a DataFrame . With arguments `buf`.", "question_id": 33373}
{"snippet": "DataFrame.info(max_cols=None)", "intent": "Print a concise summary of a DataFrame . With arguments `max_cols`.", "question_id": 33374}
{"snippet": "DataFrame.info(memory_usage=None)", "intent": "Print a concise summary of a DataFrame . The `memory_usage` parameter allows deep introspection mode , specially useful for big DataFrames and fine-tune memory optimization :", "question_id": 33375}
{"snippet": "DataFrame.info(show_counts=None)", "intent": "Print a concise summary of a DataFrame . With arguments `show_counts`.", "question_id": 33376}
{"snippet": "DataFrame.info(null_counts=None)", "intent": "Print a concise summary of a DataFrame . With arguments `null_counts`.", "question_id": 33377}
{"snippet": "DataFrame.info(verbose=None, buf=None)", "intent": "Print a concise summary of a DataFrame . With arguments `verbose`, `buf`.", "question_id": 33378}
{"snippet": "DataFrame.info(verbose=None, max_cols=None)", "intent": "Print a concise summary of a DataFrame . With arguments `verbose`, `max_cols`.", "question_id": 33379}
{"snippet": "DataFrame.info(verbose=None, memory_usage=None)", "intent": "Print a concise summary of a DataFrame . The `memory_usage` parameter allows deep introspection mode , specially useful for big DataFrames and fine-tune memory optimization : With arguments `verbose`.", "question_id": 33380}
{"snippet": "DataFrame.info()", "intent": "Print a concise summary of a DataFrame .", "question_id": 33381}
{"snippet": "DataFrame.info(verbose=None)", "intent": "Print a concise summary of a DataFrame . With arguments `verbose`.", "question_id": 33382}
{"snippet": "DataFrame.info(buf=None)", "intent": "Print a concise summary of a DataFrame . With arguments `buf`.", "question_id": 33383}
{"snippet": "DataFrame.info(max_cols=None)", "intent": "Print a concise summary of a DataFrame . With arguments `max_cols`.", "question_id": 33384}
{"snippet": "DataFrame.info(memory_usage=None)", "intent": "Print a concise summary of a DataFrame . The `memory_usage` parameter allows deep introspection mode , specially useful for big DataFrames and fine-tune memory optimization :", "question_id": 33385}
{"snippet": "DataFrame.info(show_counts=None)", "intent": "Print a concise summary of a DataFrame . With arguments `show_counts`.", "question_id": 33386}
{"snippet": "DataFrame.info(null_counts=None)", "intent": "Print a concise summary of a DataFrame . With arguments `null_counts`.", "question_id": 33387}
{"snippet": "DataFrame.info(verbose=None, buf=None)", "intent": "Print a concise summary of a DataFrame . With arguments `verbose`, `buf`.", "question_id": 33388}
{"snippet": "DataFrame.info(verbose=None, max_cols=None)", "intent": "Print a concise summary of a DataFrame . With arguments `verbose`, `max_cols`.", "question_id": 33389}
{"snippet": "DataFrame.info(verbose=None, memory_usage=None)", "intent": "Print a concise summary of a DataFrame . The `memory_usage` parameter allows deep introspection mode , specially useful for big DataFrames and fine-tune memory optimization : With arguments `verbose`.", "question_id": 33390}
{"snippet": "DataFrame.info()", "intent": "Print a concise summary of a DataFrame .", "question_id": 33391}
{"snippet": "DataFrame.info(verbose=None)", "intent": "Print a concise summary of a DataFrame . With arguments `verbose`.", "question_id": 33392}
{"snippet": "DataFrame.info(buf=None)", "intent": "Print a concise summary of a DataFrame . With arguments `buf`.", "question_id": 33393}
{"snippet": "DataFrame.info(max_cols=None)", "intent": "Print a concise summary of a DataFrame . With arguments `max_cols`.", "question_id": 33394}
{"snippet": "DataFrame.info(memory_usage=None)", "intent": "Print a concise summary of a DataFrame . The `memory_usage` parameter allows deep introspection mode , specially useful for big DataFrames and fine-tune memory optimization :", "question_id": 33395}
{"snippet": "DataFrame.info(show_counts=None)", "intent": "Print a concise summary of a DataFrame . With arguments `show_counts`.", "question_id": 33396}
{"snippet": "DataFrame.info(null_counts=None)", "intent": "Print a concise summary of a DataFrame . With arguments `null_counts`.", "question_id": 33397}
{"snippet": "DataFrame.info(verbose=None, buf=None)", "intent": "Print a concise summary of a DataFrame . With arguments `verbose`, `buf`.", "question_id": 33398}
{"snippet": "DataFrame.info(verbose=None, max_cols=None)", "intent": "Print a concise summary of a DataFrame . With arguments `verbose`, `max_cols`.", "question_id": 33399}
{"snippet": "DataFrame.info(verbose=None, memory_usage=None)", "intent": "Print a concise summary of a DataFrame . The `memory_usage` parameter allows deep introspection mode , specially useful for big DataFrames and fine-tune memory optimization : With arguments `verbose`.", "question_id": 33400}
{"snippet": "DataFrame.insert(loc, column, value)", "intent": "Insert `column` into DataFrame at specified location . Notice that pandas uses index alignment in case of `value` from type Series : With arguments `loc`.", "question_id": 33401}
{"snippet": "DataFrame.insert(loc, column, value, allow_duplicates=False)", "intent": "Insert `column` into DataFrame at specified location . Notice that pandas uses index alignment in case of `value` from type Series : Raises a ValueError if column is already contained in the DataFrame , unless `allow_duplicates` is set to True . With arguments `loc`.", "question_id": 33402}
{"snippet": "DataFrame.insert(loc, column, value)", "intent": "Insert `column` into DataFrame at specified location . Notice that pandas uses index alignment in case of `value` from type Series : With arguments `loc`.", "question_id": 33403}
{"snippet": "DataFrame.insert(loc, column, value, allow_duplicates=False)", "intent": "Insert `column` into DataFrame at specified location . Notice that pandas uses index alignment in case of `value` from type Series : Raises a ValueError if column is already contained in the DataFrame , unless `allow_duplicates` is set to True . With arguments `loc`.", "question_id": 33404}
{"snippet": "DataFrame.insert(loc, column, value)", "intent": "Insert `column` into DataFrame at specified location . Notice that pandas uses index alignment in case of `value` from type Series : With arguments `loc`.", "question_id": 33405}
{"snippet": "DataFrame.insert(loc, column, value, allow_duplicates=False)", "intent": "Insert `column` into DataFrame at specified location . Notice that pandas uses index alignment in case of `value` from type Series : Raises a ValueError if column is already contained in the DataFrame , unless `allow_duplicates` is set to True . With arguments `loc`.", "question_id": 33406}
{"snippet": "DataFrame.interpolate(**kwargs)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`.", "question_id": 33407}
{"snippet": "DataFrame.interpolate(**kwargs, method='linear')", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`.", "question_id": 33408}
{"snippet": "DataFrame.interpolate(**kwargs, axis=0)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `axis`.", "question_id": 33409}
{"snippet": "DataFrame.interpolate(**kwargs, limit=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit`.", "question_id": 33410}
{"snippet": "DataFrame.interpolate(**kwargs, inplace=False)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `inplace`.", "question_id": 33411}
{"snippet": "DataFrame.interpolate(**kwargs, limit_direction=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit_direction`.", "question_id": 33412}
{"snippet": "DataFrame.interpolate(**kwargs, limit_area=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit_area`.", "question_id": 33413}
{"snippet": "DataFrame.interpolate(**kwargs, downcast=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `downcast`.", "question_id": 33414}
{"snippet": "DataFrame.interpolate(**kwargs, method='linear', axis=0)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `axis`.", "question_id": 33415}
{"snippet": "DataFrame.interpolate(**kwargs, method='linear', limit=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit`.", "question_id": 33416}
{"snippet": "DataFrame.interpolate(**kwargs)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`.", "question_id": 33417}
{"snippet": "DataFrame.interpolate(**kwargs, method='linear')", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`.", "question_id": 33418}
{"snippet": "DataFrame.interpolate(**kwargs, axis=0)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `axis`.", "question_id": 33419}
{"snippet": "DataFrame.interpolate(**kwargs, limit=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit`.", "question_id": 33420}
{"snippet": "DataFrame.interpolate(**kwargs, inplace=False)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `inplace`.", "question_id": 33421}
{"snippet": "DataFrame.interpolate(**kwargs, limit_direction=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit_direction`.", "question_id": 33422}
{"snippet": "DataFrame.interpolate(**kwargs, limit_area=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit_area`.", "question_id": 33423}
{"snippet": "DataFrame.interpolate(**kwargs, downcast=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `downcast`.", "question_id": 33424}
{"snippet": "DataFrame.interpolate(**kwargs, method='linear', axis=0)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `axis`.", "question_id": 33425}
{"snippet": "DataFrame.interpolate(**kwargs, method='linear', limit=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit`.", "question_id": 33426}
{"snippet": "DataFrame.interpolate(**kwargs)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`.", "question_id": 33427}
{"snippet": "DataFrame.interpolate(**kwargs, method='linear')", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`.", "question_id": 33428}
{"snippet": "DataFrame.interpolate(**kwargs, axis=0)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `axis`.", "question_id": 33429}
{"snippet": "DataFrame.interpolate(**kwargs, limit=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit`.", "question_id": 33430}
{"snippet": "DataFrame.interpolate(**kwargs, inplace=False)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `inplace`.", "question_id": 33431}
{"snippet": "DataFrame.interpolate(**kwargs, limit_direction=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit_direction`.", "question_id": 33432}
{"snippet": "DataFrame.interpolate(**kwargs, limit_area=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit_area`.", "question_id": 33433}
{"snippet": "DataFrame.interpolate(**kwargs, downcast=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `downcast`.", "question_id": 33434}
{"snippet": "DataFrame.interpolate(**kwargs, method='linear', axis=0)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `axis`.", "question_id": 33435}
{"snippet": "DataFrame.interpolate(**kwargs, method='linear', limit=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit`.", "question_id": 33436}
{"snippet": "DataFrame.isin(values)", "intent": "Whether each element in the DataFrame is contained in `values` .", "question_id": 33437}
{"snippet": "DataFrame.isin(values)", "intent": "Whether each element in the DataFrame is contained in `values` .", "question_id": 33438}
{"snippet": "DataFrame.isin(values)", "intent": "Whether each element in the DataFrame is contained in `values` .", "question_id": 33439}
{"snippet": "DataFrame.isna()", "intent": "Detect missing values .", "question_id": 33440}
{"snippet": "DataFrame.isna()", "intent": "Detect missing values .", "question_id": 33441}
{"snippet": "DataFrame.isna()", "intent": "Detect missing values .", "question_id": 33442}
{"snippet": "DataFrame.isnull()", "intent": "Detect missing values .", "question_id": 33443}
{"snippet": "DataFrame.isnull()", "intent": "Detect missing values .", "question_id": 33444}
{"snippet": "DataFrame.isnull()", "intent": "Detect missing values .", "question_id": 33445}
{"snippet": "DataFrame.items()", "intent": "Iterate over ( column name , Series ) pairs .", "question_id": 33446}
{"snippet": "DataFrame.items()", "intent": "Iterate over ( column name , Series ) pairs .", "question_id": 33447}
{"snippet": "DataFrame.items()", "intent": "Iterate over ( column name , Series ) pairs .", "question_id": 33448}
{"snippet": "DataFrame.iteritems()", "intent": "Iterate over ( column name , Series ) pairs .", "question_id": 33449}
{"snippet": "DataFrame.iteritems()", "intent": "Iterate over ( column name , Series ) pairs .", "question_id": 33450}
{"snippet": "DataFrame.iteritems()", "intent": "Iterate over ( column name , Series ) pairs .", "question_id": 33451}
{"snippet": "DataFrame.iterrows()", "intent": "Iterate over DataFrame rows as ( index , Series ) pairs .", "question_id": 33452}
{"snippet": "DataFrame.iterrows()", "intent": "Iterate over DataFrame rows as ( index , Series ) pairs .", "question_id": 33453}
{"snippet": "DataFrame.iterrows()", "intent": "Iterate over DataFrame rows as ( index , Series ) pairs .", "question_id": 33454}
{"snippet": "DataFrame.itertuples()", "intent": "Iterate over DataFrame rows as namedtuples .", "question_id": 33455}
{"snippet": "DataFrame.itertuples(index=True)", "intent": "Iterate over DataFrame rows as namedtuples . By setting the `index` parameter to False we can remove the index as the first element of the tuple :", "question_id": 33456}
{"snippet": "DataFrame.itertuples(name='Pandas')", "intent": "Iterate over DataFrame rows as namedtuples . With the `name` parameter set we set a custom name for the yielded namedtuples :", "question_id": 33457}
{"snippet": "DataFrame.itertuples(index=True, name='Pandas')", "intent": "Iterate over DataFrame rows as namedtuples . By setting the `index` parameter to False we can remove the index as the first element of the tuple : With the `name` parameter set we set a custom name for the yielded namedtuples :", "question_id": 33458}
{"snippet": "DataFrame.itertuples()", "intent": "Iterate over DataFrame rows as namedtuples .", "question_id": 33459}
{"snippet": "DataFrame.itertuples(index=True)", "intent": "Iterate over DataFrame rows as namedtuples . By setting the `index` parameter to False we can remove the index as the first element of the tuple :", "question_id": 33460}
{"snippet": "DataFrame.itertuples(name='Pandas')", "intent": "Iterate over DataFrame rows as namedtuples . With the `name` parameter set we set a custom name for the yielded namedtuples :", "question_id": 33461}
{"snippet": "DataFrame.itertuples(index=True, name='Pandas')", "intent": "Iterate over DataFrame rows as namedtuples . By setting the `index` parameter to False we can remove the index as the first element of the tuple : With the `name` parameter set we set a custom name for the yielded namedtuples :", "question_id": 33462}
{"snippet": "DataFrame.itertuples()", "intent": "Iterate over DataFrame rows as namedtuples .", "question_id": 33463}
{"snippet": "DataFrame.itertuples(index=True)", "intent": "Iterate over DataFrame rows as namedtuples . By setting the `index` parameter to False we can remove the index as the first element of the tuple :", "question_id": 33464}
{"snippet": "DataFrame.itertuples(name='Pandas')", "intent": "Iterate over DataFrame rows as namedtuples . With the `name` parameter set we set a custom name for the yielded namedtuples :", "question_id": 33465}
{"snippet": "DataFrame.itertuples(index=True, name='Pandas')", "intent": "Iterate over DataFrame rows as namedtuples . By setting the `index` parameter to False we can remove the index as the first element of the tuple : With the `name` parameter set we set a custom name for the yielded namedtuples :", "question_id": 33466}
{"snippet": "DataFrame.join(other)", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column .", "question_id": 33467}
{"snippet": "DataFrame.join(other, on=None)", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column .", "question_id": 33468}
{"snippet": "DataFrame.join(other, how='left')", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column . With arguments `how`.", "question_id": 33469}
{"snippet": "DataFrame.join(other, lsuffix='')", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column . Parameters on , `lsuffix` , and `rsuffix` are not supported when passing a list of DataFrame objects .", "question_id": 33470}
{"snippet": "DataFrame.join(other, rsuffix='')", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column . Parameters on , `lsuffix` , and `rsuffix` are not supported when passing a list of DataFrame objects .", "question_id": 33471}
{"snippet": "DataFrame.join(other, sort=False)", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column . With arguments `sort`.", "question_id": 33472}
{"snippet": "DataFrame.join(other, on=None, how='left')", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column . With arguments `how`.", "question_id": 33473}
{"snippet": "DataFrame.join(other, on=None, lsuffix='')", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column . Parameters on , `lsuffix` , and `rsuffix` are not supported when passing a list of DataFrame objects .", "question_id": 33474}
{"snippet": "DataFrame.join(other, on=None, rsuffix='')", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column . Parameters on , `lsuffix` , and `rsuffix` are not supported when passing a list of DataFrame objects .", "question_id": 33475}
{"snippet": "DataFrame.join(other, on=None, sort=False)", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column . With arguments `sort`.", "question_id": 33476}
{"snippet": "DataFrame.join(other)", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column .", "question_id": 33477}
{"snippet": "DataFrame.join(other, on=None)", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column .", "question_id": 33478}
{"snippet": "DataFrame.join(other, how='left')", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column . With arguments `how`.", "question_id": 33479}
{"snippet": "DataFrame.join(other, lsuffix='')", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column . Parameters on , `lsuffix` , and `rsuffix` are not supported when passing a list of DataFrame objects .", "question_id": 33480}
{"snippet": "DataFrame.join(other, rsuffix='')", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column . Parameters on , `lsuffix` , and `rsuffix` are not supported when passing a list of DataFrame objects .", "question_id": 33481}
{"snippet": "DataFrame.join(other, sort=False)", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column . With arguments `sort`.", "question_id": 33482}
{"snippet": "DataFrame.join(other, on=None, how='left')", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column . With arguments `how`.", "question_id": 33483}
{"snippet": "DataFrame.join(other, on=None, lsuffix='')", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column . Parameters on , `lsuffix` , and `rsuffix` are not supported when passing a list of DataFrame objects .", "question_id": 33484}
{"snippet": "DataFrame.join(other, on=None, rsuffix='')", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column . Parameters on , `lsuffix` , and `rsuffix` are not supported when passing a list of DataFrame objects .", "question_id": 33485}
{"snippet": "DataFrame.join(other, on=None, sort=False)", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column . With arguments `sort`.", "question_id": 33486}
{"snippet": "DataFrame.join(other)", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column .", "question_id": 33487}
{"snippet": "DataFrame.join(other, on=None)", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column .", "question_id": 33488}
{"snippet": "DataFrame.join(other, how='left')", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column . With arguments `how`.", "question_id": 33489}
{"snippet": "DataFrame.join(other, lsuffix='')", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column . Parameters on , `lsuffix` , and `rsuffix` are not supported when passing a list of DataFrame objects .", "question_id": 33490}
{"snippet": "DataFrame.join(other, rsuffix='')", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column . Parameters on , `lsuffix` , and `rsuffix` are not supported when passing a list of DataFrame objects .", "question_id": 33491}
{"snippet": "DataFrame.join(other, sort=False)", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column . With arguments `sort`.", "question_id": 33492}
{"snippet": "DataFrame.join(other, on=None, how='left')", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column . With arguments `how`.", "question_id": 33493}
{"snippet": "DataFrame.join(other, on=None, lsuffix='')", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column . Parameters on , `lsuffix` , and `rsuffix` are not supported when passing a list of DataFrame objects .", "question_id": 33494}
{"snippet": "DataFrame.join(other, on=None, rsuffix='')", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column . Parameters on , `lsuffix` , and `rsuffix` are not supported when passing a list of DataFrame objects .", "question_id": 33495}
{"snippet": "DataFrame.join(other, on=None, sort=False)", "intent": "Join columns of another DataFrame . Join columns with `other` DataFrame either `on` index or on a key column . With arguments `sort`.", "question_id": 33496}
{"snippet": "DataFrame.keys()", "intent": "Get the \u2018 info axis \u2019 ( see Indexing for more ) .", "question_id": 33497}
{"snippet": "DataFrame.keys()", "intent": "Get the \u2018 info axis \u2019 ( see Indexing for more ) .", "question_id": 33498}
{"snippet": "DataFrame.keys()", "intent": "Get the \u2018 info axis \u2019 ( see Indexing for more ) .", "question_id": 33499}
{"snippet": "DataFrame.kurt(**kwargs)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`.", "question_id": 33500}
{"snippet": "DataFrame.kurt(**kwargs, axis=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`.", "question_id": 33501}
{"snippet": "DataFrame.kurt(**kwargs, skipna=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33502}
{"snippet": "DataFrame.kurt(**kwargs, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33503}
{"snippet": "DataFrame.kurt(**kwargs, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33504}
{"snippet": "DataFrame.kurt(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33505}
{"snippet": "DataFrame.kurt(**kwargs, axis=None, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33506}
{"snippet": "DataFrame.kurt(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33507}
{"snippet": "DataFrame.kurt(**kwargs, skipna=None, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 33508}
{"snippet": "DataFrame.kurt(**kwargs, skipna=None, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 33509}
{"snippet": "DataFrame.kurt(**kwargs)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`.", "question_id": 33510}
{"snippet": "DataFrame.kurt(**kwargs, axis=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`.", "question_id": 33511}
{"snippet": "DataFrame.kurt(**kwargs, skipna=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33512}
{"snippet": "DataFrame.kurt(**kwargs, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33513}
{"snippet": "DataFrame.kurt(**kwargs, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33514}
{"snippet": "DataFrame.kurt(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33515}
{"snippet": "DataFrame.kurt(**kwargs, axis=None, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33516}
{"snippet": "DataFrame.kurt(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33517}
{"snippet": "DataFrame.kurt(**kwargs, skipna=None, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 33518}
{"snippet": "DataFrame.kurt(**kwargs, skipna=None, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 33519}
{"snippet": "DataFrame.kurt(**kwargs)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`.", "question_id": 33520}
{"snippet": "DataFrame.kurt(**kwargs, axis=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`.", "question_id": 33521}
{"snippet": "DataFrame.kurt(**kwargs, skipna=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33522}
{"snippet": "DataFrame.kurt(**kwargs, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33523}
{"snippet": "DataFrame.kurt(**kwargs, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33524}
{"snippet": "DataFrame.kurt(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33525}
{"snippet": "DataFrame.kurt(**kwargs, axis=None, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33526}
{"snippet": "DataFrame.kurt(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33527}
{"snippet": "DataFrame.kurt(**kwargs, skipna=None, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 33528}
{"snippet": "DataFrame.kurt(**kwargs, skipna=None, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 33529}
{"snippet": "DataFrame.kurtosis(**kwargs)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`.", "question_id": 33530}
{"snippet": "DataFrame.kurtosis(**kwargs, axis=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`.", "question_id": 33531}
{"snippet": "DataFrame.kurtosis(**kwargs, skipna=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33532}
{"snippet": "DataFrame.kurtosis(**kwargs, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33533}
{"snippet": "DataFrame.kurtosis(**kwargs, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33534}
{"snippet": "DataFrame.kurtosis(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33535}
{"snippet": "DataFrame.kurtosis(**kwargs, axis=None, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33536}
{"snippet": "DataFrame.kurtosis(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33537}
{"snippet": "DataFrame.kurtosis(**kwargs, skipna=None, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 33538}
{"snippet": "DataFrame.kurtosis(**kwargs, skipna=None, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 33539}
{"snippet": "DataFrame.kurtosis(**kwargs)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`.", "question_id": 33540}
{"snippet": "DataFrame.kurtosis(**kwargs, axis=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`.", "question_id": 33541}
{"snippet": "DataFrame.kurtosis(**kwargs, skipna=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33542}
{"snippet": "DataFrame.kurtosis(**kwargs, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33543}
{"snippet": "DataFrame.kurtosis(**kwargs, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33544}
{"snippet": "DataFrame.kurtosis(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33545}
{"snippet": "DataFrame.kurtosis(**kwargs, axis=None, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33546}
{"snippet": "DataFrame.kurtosis(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33547}
{"snippet": "DataFrame.kurtosis(**kwargs, skipna=None, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 33548}
{"snippet": "DataFrame.kurtosis(**kwargs, skipna=None, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 33549}
{"snippet": "DataFrame.kurtosis(**kwargs)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`.", "question_id": 33550}
{"snippet": "DataFrame.kurtosis(**kwargs, axis=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`.", "question_id": 33551}
{"snippet": "DataFrame.kurtosis(**kwargs, skipna=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33552}
{"snippet": "DataFrame.kurtosis(**kwargs, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33553}
{"snippet": "DataFrame.kurtosis(**kwargs, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33554}
{"snippet": "DataFrame.kurtosis(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33555}
{"snippet": "DataFrame.kurtosis(**kwargs, axis=None, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33556}
{"snippet": "DataFrame.kurtosis(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33557}
{"snippet": "DataFrame.kurtosis(**kwargs, skipna=None, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 33558}
{"snippet": "DataFrame.kurtosis(**kwargs, skipna=None, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 33559}
{"snippet": "DataFrame.last(offset)", "intent": "Select final periods of time series data based on a date `offset` .", "question_id": 33560}
{"snippet": "DataFrame.last(offset)", "intent": "Select final periods of time series data based on a date `offset` .", "question_id": 33561}
{"snippet": "DataFrame.last(offset)", "intent": "Select final periods of time series data based on a date `offset` .", "question_id": 33562}
{"snippet": "DataFrame.last_valid_index()", "intent": "Return index for last non-NA value or None , if no NA value is found .", "question_id": 33563}
{"snippet": "DataFrame.last_valid_index()", "intent": "Return index for last non-NA value or None , if no NA value is found .", "question_id": 33564}
{"snippet": "DataFrame.last_valid_index()", "intent": "Return index for last non-NA value or None , if no NA value is found .", "question_id": 33565}
{"snippet": "DataFrame.le(other)", "intent": "Get Less than or equal to of dataframe and `other` , element-wise ( binary operator le ) .", "question_id": 33566}
{"snippet": "DataFrame.le(other, axis='columns')", "intent": "Get Less than or equal to of dataframe and `other` , element-wise ( binary operator le ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33567}
{"snippet": "DataFrame.le(other, level=None)", "intent": "Get Less than or equal to of dataframe and `other` , element-wise ( binary operator le ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33568}
{"snippet": "DataFrame.le(other, axis='columns', level=None)", "intent": "Get Less than or equal to of dataframe and `other` , element-wise ( binary operator le ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33569}
{"snippet": "DataFrame.le(other)", "intent": "Get Less than or equal to of dataframe and `other` , element-wise ( binary operator le ) .", "question_id": 33570}
{"snippet": "DataFrame.le(other, axis='columns')", "intent": "Get Less than or equal to of dataframe and `other` , element-wise ( binary operator le ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33571}
{"snippet": "DataFrame.le(other, level=None)", "intent": "Get Less than or equal to of dataframe and `other` , element-wise ( binary operator le ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33572}
{"snippet": "DataFrame.le(other, axis='columns', level=None)", "intent": "Get Less than or equal to of dataframe and `other` , element-wise ( binary operator le ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33573}
{"snippet": "DataFrame.le(other)", "intent": "Get Less than or equal to of dataframe and `other` , element-wise ( binary operator le ) .", "question_id": 33574}
{"snippet": "DataFrame.le(other, axis='columns')", "intent": "Get Less than or equal to of dataframe and `other` , element-wise ( binary operator le ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33575}
{"snippet": "DataFrame.le(other, level=None)", "intent": "Get Less than or equal to of dataframe and `other` , element-wise ( binary operator le ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33576}
{"snippet": "DataFrame.le(other, axis='columns', level=None)", "intent": "Get Less than or equal to of dataframe and `other` , element-wise ( binary operator le ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33577}
{"snippet": "DataFrame.lookup(row_labels, col_labels)", "intent": "Label-based \u201c fancy indexing \u201d function for DataFrame . With arguments `row_labels`, `col_labels`.", "question_id": 33578}
{"snippet": "DataFrame.lookup(row_labels, col_labels)", "intent": "Label-based \u201c fancy indexing \u201d function for DataFrame . With arguments `row_labels`, `col_labels`.", "question_id": 33579}
{"snippet": "DataFrame.lookup(row_labels, col_labels)", "intent": "Label-based \u201c fancy indexing \u201d function for DataFrame . With arguments `row_labels`, `col_labels`.", "question_id": 33580}
{"snippet": "DataFrame.lt(other)", "intent": "Get Less than of dataframe and `other` , element-wise ( binary operator lt ) .", "question_id": 33581}
{"snippet": "DataFrame.lt(other, axis='columns')", "intent": "Get Less than of dataframe and `other` , element-wise ( binary operator lt ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33582}
{"snippet": "DataFrame.lt(other, level=None)", "intent": "Get Less than of dataframe and `other` , element-wise ( binary operator lt ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33583}
{"snippet": "DataFrame.lt(other, axis='columns', level=None)", "intent": "Get Less than of dataframe and `other` , element-wise ( binary operator lt ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33584}
{"snippet": "DataFrame.lt(other)", "intent": "Get Less than of dataframe and `other` , element-wise ( binary operator lt ) .", "question_id": 33585}
{"snippet": "DataFrame.lt(other, axis='columns')", "intent": "Get Less than of dataframe and `other` , element-wise ( binary operator lt ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33586}
{"snippet": "DataFrame.lt(other, level=None)", "intent": "Get Less than of dataframe and `other` , element-wise ( binary operator lt ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33587}
{"snippet": "DataFrame.lt(other, axis='columns', level=None)", "intent": "Get Less than of dataframe and `other` , element-wise ( binary operator lt ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33588}
{"snippet": "DataFrame.lt(other)", "intent": "Get Less than of dataframe and `other` , element-wise ( binary operator lt ) .", "question_id": 33589}
{"snippet": "DataFrame.lt(other, axis='columns')", "intent": "Get Less than of dataframe and `other` , element-wise ( binary operator lt ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33590}
{"snippet": "DataFrame.lt(other, level=None)", "intent": "Get Less than of dataframe and `other` , element-wise ( binary operator lt ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33591}
{"snippet": "DataFrame.lt(other, axis='columns', level=None)", "intent": "Get Less than of dataframe and `other` , element-wise ( binary operator lt ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33592}
{"snippet": "DataFrame.mad()", "intent": "Return the mean absolute deviation of the values over the requested `axis` .", "question_id": 33593}
{"snippet": "DataFrame.mad(axis=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` .", "question_id": 33594}
{"snippet": "DataFrame.mad(skipna=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `skipna`.", "question_id": 33595}
{"snippet": "DataFrame.mad(level=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `level`.", "question_id": 33596}
{"snippet": "DataFrame.mad(axis=None, skipna=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `skipna`.", "question_id": 33597}
{"snippet": "DataFrame.mad(axis=None, level=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `level`.", "question_id": 33598}
{"snippet": "DataFrame.mad(skipna=None, level=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `skipna`, `level`.", "question_id": 33599}
{"snippet": "DataFrame.mad(axis=None, skipna=None, level=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `skipna`, `level`.", "question_id": 33600}
{"snippet": "DataFrame.mad()", "intent": "Return the mean absolute deviation of the values over the requested `axis` .", "question_id": 33601}
{"snippet": "DataFrame.mad(axis=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` .", "question_id": 33602}
{"snippet": "DataFrame.mad(skipna=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `skipna`.", "question_id": 33603}
{"snippet": "DataFrame.mad(level=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `level`.", "question_id": 33604}
{"snippet": "DataFrame.mad(axis=None, skipna=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `skipna`.", "question_id": 33605}
{"snippet": "DataFrame.mad(axis=None, level=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `level`.", "question_id": 33606}
{"snippet": "DataFrame.mad(skipna=None, level=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `skipna`, `level`.", "question_id": 33607}
{"snippet": "DataFrame.mad(axis=None, skipna=None, level=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `skipna`, `level`.", "question_id": 33608}
{"snippet": "DataFrame.mad()", "intent": "Return the mean absolute deviation of the values over the requested `axis` .", "question_id": 33609}
{"snippet": "DataFrame.mad(axis=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` .", "question_id": 33610}
{"snippet": "DataFrame.mad(skipna=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `skipna`.", "question_id": 33611}
{"snippet": "DataFrame.mad(level=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `level`.", "question_id": 33612}
{"snippet": "DataFrame.mad(axis=None, skipna=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `skipna`.", "question_id": 33613}
{"snippet": "DataFrame.mad(axis=None, level=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `level`.", "question_id": 33614}
{"snippet": "DataFrame.mad(skipna=None, level=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `skipna`, `level`.", "question_id": 33615}
{"snippet": "DataFrame.mad(axis=None, skipna=None, level=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `skipna`, `level`.", "question_id": 33616}
{"snippet": "DataFrame.mask(cond)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used .", "question_id": 33617}
{"snippet": "DataFrame.mask(cond, other=nan)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used .", "question_id": 33618}
{"snippet": "DataFrame.mask(cond, inplace=False)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `inplace`.", "question_id": 33619}
{"snippet": "DataFrame.mask(cond, axis=None)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `axis`.", "question_id": 33620}
{"snippet": "DataFrame.mask(cond, level=None)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `level`.", "question_id": 33621}
{"snippet": "DataFrame.mask(cond, errors='raise')", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `errors`.", "question_id": 33622}
{"snippet": "DataFrame.mask(cond, try_cast=NoDefault.no_default)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `try_cast`.", "question_id": 33623}
{"snippet": "DataFrame.mask(cond, other=nan, inplace=False)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `inplace`.", "question_id": 33624}
{"snippet": "DataFrame.mask(cond, other=nan, axis=None)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `axis`.", "question_id": 33625}
{"snippet": "DataFrame.mask(cond, other=nan, level=None)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `level`.", "question_id": 33626}
{"snippet": "DataFrame.mask(cond)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used .", "question_id": 33627}
{"snippet": "DataFrame.mask(cond, other=nan)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used .", "question_id": 33628}
{"snippet": "DataFrame.mask(cond, inplace=False)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `inplace`.", "question_id": 33629}
{"snippet": "DataFrame.mask(cond, axis=None)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `axis`.", "question_id": 33630}
{"snippet": "DataFrame.mask(cond, level=None)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `level`.", "question_id": 33631}
{"snippet": "DataFrame.mask(cond, errors='raise')", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `errors`.", "question_id": 33632}
{"snippet": "DataFrame.mask(cond, try_cast=NoDefault.no_default)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `try_cast`.", "question_id": 33633}
{"snippet": "DataFrame.mask(cond, other=nan, inplace=False)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `inplace`.", "question_id": 33634}
{"snippet": "DataFrame.mask(cond, other=nan, axis=None)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `axis`.", "question_id": 33635}
{"snippet": "DataFrame.mask(cond, other=nan, level=None)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `level`.", "question_id": 33636}
{"snippet": "DataFrame.mask(cond)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used .", "question_id": 33637}
{"snippet": "DataFrame.mask(cond, other=nan)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used .", "question_id": 33638}
{"snippet": "DataFrame.mask(cond, inplace=False)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `inplace`.", "question_id": 33639}
{"snippet": "DataFrame.mask(cond, axis=None)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `axis`.", "question_id": 33640}
{"snippet": "DataFrame.mask(cond, level=None)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `level`.", "question_id": 33641}
{"snippet": "DataFrame.mask(cond, errors='raise')", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `errors`.", "question_id": 33642}
{"snippet": "DataFrame.mask(cond, try_cast=NoDefault.no_default)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `try_cast`.", "question_id": 33643}
{"snippet": "DataFrame.mask(cond, other=nan, inplace=False)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `inplace`.", "question_id": 33644}
{"snippet": "DataFrame.mask(cond, other=nan, axis=None)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `axis`.", "question_id": 33645}
{"snippet": "DataFrame.mask(cond, other=nan, level=None)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `level`.", "question_id": 33646}
{"snippet": "DataFrame.max(**kwargs)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 33647}
{"snippet": "DataFrame.max(**kwargs, axis=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 33648}
{"snippet": "DataFrame.max(**kwargs, skipna=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33649}
{"snippet": "DataFrame.max(**kwargs, level=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33650}
{"snippet": "DataFrame.max(**kwargs, numeric_only=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33651}
{"snippet": "DataFrame.max(**kwargs, axis=None, skipna=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33652}
{"snippet": "DataFrame.max(**kwargs, axis=None, level=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33653}
{"snippet": "DataFrame.max(**kwargs, axis=None, numeric_only=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33654}
{"snippet": "DataFrame.max(**kwargs, skipna=None, level=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 33655}
{"snippet": "DataFrame.max(**kwargs, skipna=None, numeric_only=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 33656}
{"snippet": "DataFrame.max(**kwargs)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 33657}
{"snippet": "DataFrame.max(**kwargs, axis=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 33658}
{"snippet": "DataFrame.max(**kwargs, skipna=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33659}
{"snippet": "DataFrame.max(**kwargs, level=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33660}
{"snippet": "DataFrame.max(**kwargs, numeric_only=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33661}
{"snippet": "DataFrame.max(**kwargs, axis=None, skipna=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33662}
{"snippet": "DataFrame.max(**kwargs, axis=None, level=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33663}
{"snippet": "DataFrame.max(**kwargs, axis=None, numeric_only=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33664}
{"snippet": "DataFrame.max(**kwargs, skipna=None, level=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 33665}
{"snippet": "DataFrame.max(**kwargs, skipna=None, numeric_only=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 33666}
{"snippet": "DataFrame.max(**kwargs)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 33667}
{"snippet": "DataFrame.max(**kwargs, axis=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 33668}
{"snippet": "DataFrame.max(**kwargs, skipna=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33669}
{"snippet": "DataFrame.max(**kwargs, level=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33670}
{"snippet": "DataFrame.max(**kwargs, numeric_only=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33671}
{"snippet": "DataFrame.max(**kwargs, axis=None, skipna=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33672}
{"snippet": "DataFrame.max(**kwargs, axis=None, level=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33673}
{"snippet": "DataFrame.max(**kwargs, axis=None, numeric_only=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33674}
{"snippet": "DataFrame.max(**kwargs, skipna=None, level=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 33675}
{"snippet": "DataFrame.max(**kwargs, skipna=None, numeric_only=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 33676}
{"snippet": "DataFrame.mean(**kwargs)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 33677}
{"snippet": "DataFrame.mean(**kwargs, axis=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 33678}
{"snippet": "DataFrame.mean(**kwargs, skipna=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33679}
{"snippet": "DataFrame.mean(**kwargs, level=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33680}
{"snippet": "DataFrame.mean(**kwargs, numeric_only=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33681}
{"snippet": "DataFrame.mean(**kwargs, axis=None, skipna=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33682}
{"snippet": "DataFrame.mean(**kwargs, axis=None, level=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33683}
{"snippet": "DataFrame.mean(**kwargs, axis=None, numeric_only=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33684}
{"snippet": "DataFrame.mean(**kwargs, skipna=None, level=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 33685}
{"snippet": "DataFrame.mean(**kwargs, skipna=None, numeric_only=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 33686}
{"snippet": "DataFrame.mean(**kwargs)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 33687}
{"snippet": "DataFrame.mean(**kwargs, axis=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 33688}
{"snippet": "DataFrame.mean(**kwargs, skipna=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33689}
{"snippet": "DataFrame.mean(**kwargs, level=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33690}
{"snippet": "DataFrame.mean(**kwargs, numeric_only=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33691}
{"snippet": "DataFrame.mean(**kwargs, axis=None, skipna=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33692}
{"snippet": "DataFrame.mean(**kwargs, axis=None, level=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33693}
{"snippet": "DataFrame.mean(**kwargs, axis=None, numeric_only=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33694}
{"snippet": "DataFrame.mean(**kwargs, skipna=None, level=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 33695}
{"snippet": "DataFrame.mean(**kwargs, skipna=None, numeric_only=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 33696}
{"snippet": "DataFrame.mean(**kwargs)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 33697}
{"snippet": "DataFrame.mean(**kwargs, axis=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 33698}
{"snippet": "DataFrame.mean(**kwargs, skipna=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33699}
{"snippet": "DataFrame.mean(**kwargs, level=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33700}
{"snippet": "DataFrame.mean(**kwargs, numeric_only=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33701}
{"snippet": "DataFrame.mean(**kwargs, axis=None, skipna=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33702}
{"snippet": "DataFrame.mean(**kwargs, axis=None, level=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33703}
{"snippet": "DataFrame.mean(**kwargs, axis=None, numeric_only=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33704}
{"snippet": "DataFrame.mean(**kwargs, skipna=None, level=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 33705}
{"snippet": "DataFrame.mean(**kwargs, skipna=None, numeric_only=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 33706}
{"snippet": "DataFrame.median(**kwargs)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 33707}
{"snippet": "DataFrame.median(**kwargs, axis=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 33708}
{"snippet": "DataFrame.median(**kwargs, skipna=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33709}
{"snippet": "DataFrame.median(**kwargs, level=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33710}
{"snippet": "DataFrame.median(**kwargs, numeric_only=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33711}
{"snippet": "DataFrame.median(**kwargs, axis=None, skipna=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33712}
{"snippet": "DataFrame.median(**kwargs, axis=None, level=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33713}
{"snippet": "DataFrame.median(**kwargs, axis=None, numeric_only=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33714}
{"snippet": "DataFrame.median(**kwargs, skipna=None, level=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 33715}
{"snippet": "DataFrame.median(**kwargs, skipna=None, numeric_only=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 33716}
{"snippet": "DataFrame.median(**kwargs)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 33717}
{"snippet": "DataFrame.median(**kwargs, axis=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 33718}
{"snippet": "DataFrame.median(**kwargs, skipna=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33719}
{"snippet": "DataFrame.median(**kwargs, level=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33720}
{"snippet": "DataFrame.median(**kwargs, numeric_only=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33721}
{"snippet": "DataFrame.median(**kwargs, axis=None, skipna=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33722}
{"snippet": "DataFrame.median(**kwargs, axis=None, level=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33723}
{"snippet": "DataFrame.median(**kwargs, axis=None, numeric_only=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33724}
{"snippet": "DataFrame.median(**kwargs, skipna=None, level=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 33725}
{"snippet": "DataFrame.median(**kwargs, skipna=None, numeric_only=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 33726}
{"snippet": "DataFrame.median(**kwargs)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 33727}
{"snippet": "DataFrame.median(**kwargs, axis=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 33728}
{"snippet": "DataFrame.median(**kwargs, skipna=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33729}
{"snippet": "DataFrame.median(**kwargs, level=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33730}
{"snippet": "DataFrame.median(**kwargs, numeric_only=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33731}
{"snippet": "DataFrame.median(**kwargs, axis=None, skipna=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33732}
{"snippet": "DataFrame.median(**kwargs, axis=None, level=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33733}
{"snippet": "DataFrame.median(**kwargs, axis=None, numeric_only=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33734}
{"snippet": "DataFrame.median(**kwargs, skipna=None, level=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 33735}
{"snippet": "DataFrame.median(**kwargs, skipna=None, numeric_only=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 33736}
{"snippet": "DataFrame.melt()", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set .", "question_id": 33737}
{"snippet": "DataFrame.melt(id_vars=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 .", "question_id": 33738}
{"snippet": "DataFrame.melt(value_vars=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 .", "question_id": 33739}
{"snippet": "DataFrame.melt(var_name=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `var_name`.", "question_id": 33740}
{"snippet": "DataFrame.melt(value_name='value')", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `value_name`.", "question_id": 33741}
{"snippet": "DataFrame.melt(col_level=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `col_level`.", "question_id": 33742}
{"snippet": "DataFrame.melt(ignore_index=True)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `ignore_index`.", "question_id": 33743}
{"snippet": "DataFrame.melt(id_vars=None, value_vars=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 .", "question_id": 33744}
{"snippet": "DataFrame.melt(id_vars=None, var_name=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 . With arguments `var_name`.", "question_id": 33745}
{"snippet": "DataFrame.melt(id_vars=None, value_name='value')", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 . With arguments `value_name`.", "question_id": 33746}
{"snippet": "DataFrame.melt()", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set .", "question_id": 33747}
{"snippet": "DataFrame.melt(id_vars=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 .", "question_id": 33748}
{"snippet": "DataFrame.melt(value_vars=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 .", "question_id": 33749}
{"snippet": "DataFrame.melt(var_name=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `var_name`.", "question_id": 33750}
{"snippet": "DataFrame.melt(value_name='value')", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `value_name`.", "question_id": 33751}
{"snippet": "DataFrame.melt(col_level=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `col_level`.", "question_id": 33752}
{"snippet": "DataFrame.melt(ignore_index=True)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `ignore_index`.", "question_id": 33753}
{"snippet": "DataFrame.melt(id_vars=None, value_vars=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 .", "question_id": 33754}
{"snippet": "DataFrame.melt(id_vars=None, var_name=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 . With arguments `var_name`.", "question_id": 33755}
{"snippet": "DataFrame.melt(id_vars=None, value_name='value')", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 . With arguments `value_name`.", "question_id": 33756}
{"snippet": "DataFrame.melt()", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set .", "question_id": 33757}
{"snippet": "DataFrame.melt(id_vars=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 .", "question_id": 33758}
{"snippet": "DataFrame.melt(value_vars=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 .", "question_id": 33759}
{"snippet": "DataFrame.melt(var_name=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `var_name`.", "question_id": 33760}
{"snippet": "DataFrame.melt(value_name='value')", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `value_name`.", "question_id": 33761}
{"snippet": "DataFrame.melt(col_level=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `col_level`.", "question_id": 33762}
{"snippet": "DataFrame.melt(ignore_index=True)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `ignore_index`.", "question_id": 33763}
{"snippet": "DataFrame.melt(id_vars=None, value_vars=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 .", "question_id": 33764}
{"snippet": "DataFrame.melt(id_vars=None, var_name=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 . With arguments `var_name`.", "question_id": 33765}
{"snippet": "DataFrame.melt(id_vars=None, value_name='value')", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 . With arguments `value_name`.", "question_id": 33766}
{"snippet": "DataFrame.memory_usage()", "intent": "Return the memory usage of each column in bytes .", "question_id": 33767}
{"snippet": "DataFrame.memory_usage(index=True)", "intent": "Return the memory usage of each column in bytes . The memory usage can optionally include the contribution of the `index` and elements of object dtype .", "question_id": 33768}
{"snippet": "DataFrame.memory_usage(deep=False)", "intent": "Return the memory usage of each column in bytes . With arguments `deep`.", "question_id": 33769}
{"snippet": "DataFrame.memory_usage(index=True, deep=False)", "intent": "Return the memory usage of each column in bytes . The memory usage can optionally include the contribution of the `index` and elements of object dtype . With arguments `deep`.", "question_id": 33770}
{"snippet": "DataFrame.memory_usage()", "intent": "Return the memory usage of each column in bytes .", "question_id": 33771}
{"snippet": "DataFrame.memory_usage(index=True)", "intent": "Return the memory usage of each column in bytes . The memory usage can optionally include the contribution of the `index` and elements of object dtype .", "question_id": 33772}
{"snippet": "DataFrame.memory_usage(deep=False)", "intent": "Return the memory usage of each column in bytes . With arguments `deep`.", "question_id": 33773}
{"snippet": "DataFrame.memory_usage(index=True, deep=False)", "intent": "Return the memory usage of each column in bytes . The memory usage can optionally include the contribution of the `index` and elements of object dtype . With arguments `deep`.", "question_id": 33774}
{"snippet": "DataFrame.memory_usage()", "intent": "Return the memory usage of each column in bytes .", "question_id": 33775}
{"snippet": "DataFrame.memory_usage(index=True)", "intent": "Return the memory usage of each column in bytes . The memory usage can optionally include the contribution of the `index` and elements of object dtype .", "question_id": 33776}
{"snippet": "DataFrame.memory_usage(deep=False)", "intent": "Return the memory usage of each column in bytes . With arguments `deep`.", "question_id": 33777}
{"snippet": "DataFrame.memory_usage(index=True, deep=False)", "intent": "Return the memory usage of each column in bytes . The memory usage can optionally include the contribution of the `index` and elements of object dtype . With arguments `deep`.", "question_id": 33778}
{"snippet": "DataFrame.merge(right, '_y'))", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . With arguments `'_y')`.", "question_id": 33779}
{"snippet": "DataFrame.merge(right, '_y'), how='inner')", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `how`.", "question_id": 33780}
{"snippet": "DataFrame.merge(right, '_y'), on=None)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . The join is done `on` columns or indexes . With arguments `'_y')`.", "question_id": 33781}
{"snippet": "DataFrame.merge(right, '_y'), left_on=None)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . Support for specifying index levels as the on , `left_on` , and `right_on` parameters was added in version 0.23.0 Support for merging named Series objects was added in version 0.24.0 With arguments `'_y')`.", "question_id": 33782}
{"snippet": "DataFrame.merge(right, '_y'), right_on=None)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . Support for specifying index levels as the on , `left_on` , and `right_on` parameters was added in version 0.23.0 Support for merging named Series objects was added in version 0.24.0 With arguments `'_y')`.", "question_id": 33783}
{"snippet": "DataFrame.merge(right, '_y'), left_index=False)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `left_index`.", "question_id": 33784}
{"snippet": "DataFrame.merge(right, '_y'), right_index=False)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `right_index`.", "question_id": 33785}
{"snippet": "DataFrame.merge(right, '_y'), sort=False)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `sort`.", "question_id": 33786}
{"snippet": "DataFrame.merge(right, '_y'), suffixes=('_x')", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . The value columns have the default `suffixes` , _x and _y , appended . With arguments `'_y')`.", "question_id": 33787}
{"snippet": "DataFrame.merge(right, '_y'), copy=True)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `copy`.", "question_id": 33788}
{"snippet": "DataFrame.merge(right, '_y'))", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . With arguments `'_y')`.", "question_id": 33789}
{"snippet": "DataFrame.merge(right, '_y'), how='inner')", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `how`.", "question_id": 33790}
{"snippet": "DataFrame.merge(right, '_y'), on=None)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . The join is done `on` columns or indexes . With arguments `'_y')`.", "question_id": 33791}
{"snippet": "DataFrame.merge(right, '_y'), left_on=None)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . Support for specifying index levels as the on , `left_on` , and `right_on` parameters was added in version 0.23.0 Support for merging named Series objects was added in version 0.24.0 With arguments `'_y')`.", "question_id": 33792}
{"snippet": "DataFrame.merge(right, '_y'), right_on=None)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . Support for specifying index levels as the on , `left_on` , and `right_on` parameters was added in version 0.23.0 Support for merging named Series objects was added in version 0.24.0 With arguments `'_y')`.", "question_id": 33793}
{"snippet": "DataFrame.merge(right, '_y'), left_index=False)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `left_index`.", "question_id": 33794}
{"snippet": "DataFrame.merge(right, '_y'), right_index=False)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `right_index`.", "question_id": 33795}
{"snippet": "DataFrame.merge(right, '_y'), sort=False)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `sort`.", "question_id": 33796}
{"snippet": "DataFrame.merge(right, '_y'), suffixes=('_x')", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . The value columns have the default `suffixes` , _x and _y , appended . With arguments `'_y')`.", "question_id": 33797}
{"snippet": "DataFrame.merge(right, '_y'), copy=True)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `copy`.", "question_id": 33798}
{"snippet": "DataFrame.merge(right, '_y'))", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . With arguments `'_y')`.", "question_id": 33799}
{"snippet": "DataFrame.merge(right, '_y'), how='inner')", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `how`.", "question_id": 33800}
{"snippet": "DataFrame.merge(right, '_y'), on=None)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . The join is done `on` columns or indexes . With arguments `'_y')`.", "question_id": 33801}
{"snippet": "DataFrame.merge(right, '_y'), left_on=None)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . Support for specifying index levels as the on , `left_on` , and `right_on` parameters was added in version 0.23.0 Support for merging named Series objects was added in version 0.24.0 With arguments `'_y')`.", "question_id": 33802}
{"snippet": "DataFrame.merge(right, '_y'), right_on=None)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . Support for specifying index levels as the on , `left_on` , and `right_on` parameters was added in version 0.23.0 Support for merging named Series objects was added in version 0.24.0 With arguments `'_y')`.", "question_id": 33803}
{"snippet": "DataFrame.merge(right, '_y'), left_index=False)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `left_index`.", "question_id": 33804}
{"snippet": "DataFrame.merge(right, '_y'), right_index=False)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `right_index`.", "question_id": 33805}
{"snippet": "DataFrame.merge(right, '_y'), sort=False)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `sort`.", "question_id": 33806}
{"snippet": "DataFrame.merge(right, '_y'), suffixes=('_x')", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . The value columns have the default `suffixes` , _x and _y , appended . With arguments `'_y')`.", "question_id": 33807}
{"snippet": "DataFrame.merge(right, '_y'), copy=True)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified left and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `copy`.", "question_id": 33808}
{"snippet": "DataFrame.min(**kwargs)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 33809}
{"snippet": "DataFrame.min(**kwargs, axis=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 33810}
{"snippet": "DataFrame.min(**kwargs, skipna=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33811}
{"snippet": "DataFrame.min(**kwargs, level=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33812}
{"snippet": "DataFrame.min(**kwargs, numeric_only=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33813}
{"snippet": "DataFrame.min(**kwargs, axis=None, skipna=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33814}
{"snippet": "DataFrame.min(**kwargs, axis=None, level=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33815}
{"snippet": "DataFrame.min(**kwargs, axis=None, numeric_only=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33816}
{"snippet": "DataFrame.min(**kwargs, skipna=None, level=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 33817}
{"snippet": "DataFrame.min(**kwargs, skipna=None, numeric_only=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 33818}
{"snippet": "DataFrame.min(**kwargs)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 33819}
{"snippet": "DataFrame.min(**kwargs, axis=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 33820}
{"snippet": "DataFrame.min(**kwargs, skipna=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33821}
{"snippet": "DataFrame.min(**kwargs, level=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33822}
{"snippet": "DataFrame.min(**kwargs, numeric_only=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33823}
{"snippet": "DataFrame.min(**kwargs, axis=None, skipna=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33824}
{"snippet": "DataFrame.min(**kwargs, axis=None, level=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33825}
{"snippet": "DataFrame.min(**kwargs, axis=None, numeric_only=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33826}
{"snippet": "DataFrame.min(**kwargs, skipna=None, level=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 33827}
{"snippet": "DataFrame.min(**kwargs, skipna=None, numeric_only=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 33828}
{"snippet": "DataFrame.min(**kwargs)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 33829}
{"snippet": "DataFrame.min(**kwargs, axis=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 33830}
{"snippet": "DataFrame.min(**kwargs, skipna=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33831}
{"snippet": "DataFrame.min(**kwargs, level=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33832}
{"snippet": "DataFrame.min(**kwargs, numeric_only=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33833}
{"snippet": "DataFrame.min(**kwargs, axis=None, skipna=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 33834}
{"snippet": "DataFrame.min(**kwargs, axis=None, level=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 33835}
{"snippet": "DataFrame.min(**kwargs, axis=None, numeric_only=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 33836}
{"snippet": "DataFrame.min(**kwargs, skipna=None, level=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 33837}
{"snippet": "DataFrame.min(**kwargs, skipna=None, numeric_only=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 33838}
{"snippet": "DataFrame.mod(other)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator mod ) .", "question_id": 33839}
{"snippet": "DataFrame.mod(other, axis='columns')", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator mod ) . Subtract a list and Series by `axis` with operator version .", "question_id": 33840}
{"snippet": "DataFrame.mod(other, level=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator mod ) . Divide by a MultiIndex by `level` .", "question_id": 33841}
{"snippet": "DataFrame.mod(other, fill_value=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator mod ) . Equivalent to dataframe % other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33842}
{"snippet": "DataFrame.mod(other, axis='columns', level=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator mod ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 33843}
{"snippet": "DataFrame.mod(other, axis='columns', fill_value=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator mod ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe % other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33844}
{"snippet": "DataFrame.mod(other, level=None, fill_value=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator mod ) . Divide by a MultiIndex by `level` . Equivalent to dataframe % other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33845}
{"snippet": "DataFrame.mod(other, axis='columns', level=None, fill_value=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator mod ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe % other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33846}
{"snippet": "DataFrame.mod(other)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator mod ) .", "question_id": 33847}
{"snippet": "DataFrame.mod(other, axis='columns')", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator mod ) . Subtract a list and Series by `axis` with operator version .", "question_id": 33848}
{"snippet": "DataFrame.mod(other, level=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator mod ) . Divide by a MultiIndex by `level` .", "question_id": 33849}
{"snippet": "DataFrame.mod(other, fill_value=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator mod ) . Equivalent to dataframe % other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33850}
{"snippet": "DataFrame.mod(other, axis='columns', level=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator mod ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 33851}
{"snippet": "DataFrame.mod(other, axis='columns', fill_value=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator mod ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe % other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33852}
{"snippet": "DataFrame.mod(other, level=None, fill_value=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator mod ) . Divide by a MultiIndex by `level` . Equivalent to dataframe % other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33853}
{"snippet": "DataFrame.mod(other, axis='columns', level=None, fill_value=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator mod ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe % other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33854}
{"snippet": "DataFrame.mod(other)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator mod ) .", "question_id": 33855}
{"snippet": "DataFrame.mod(other, axis='columns')", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator mod ) . Subtract a list and Series by `axis` with operator version .", "question_id": 33856}
{"snippet": "DataFrame.mod(other, level=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator mod ) . Divide by a MultiIndex by `level` .", "question_id": 33857}
{"snippet": "DataFrame.mod(other, fill_value=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator mod ) . Equivalent to dataframe % other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33858}
{"snippet": "DataFrame.mod(other, axis='columns', level=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator mod ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 33859}
{"snippet": "DataFrame.mod(other, axis='columns', fill_value=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator mod ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe % other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33860}
{"snippet": "DataFrame.mod(other, level=None, fill_value=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator mod ) . Divide by a MultiIndex by `level` . Equivalent to dataframe % other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33861}
{"snippet": "DataFrame.mod(other, axis='columns', level=None, fill_value=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator mod ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe % other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33862}
{"snippet": "DataFrame.mode()", "intent": "Get the mode ( s ) of each element along the selected `axis` .", "question_id": 33863}
{"snippet": "DataFrame.mode(axis=0)", "intent": "Get the mode ( s ) of each element along the selected `axis` .", "question_id": 33864}
{"snippet": "DataFrame.mode(numeric_only=False)", "intent": "Get the mode ( s ) of each element along the selected `axis` . With arguments `numeric_only`.", "question_id": 33865}
{"snippet": "DataFrame.mode(dropna=True)", "intent": "Get the mode ( s ) of each element along the selected `axis` . With arguments `dropna`.", "question_id": 33866}
{"snippet": "DataFrame.mode(axis=0, numeric_only=False)", "intent": "Get the mode ( s ) of each element along the selected `axis` . With arguments `numeric_only`.", "question_id": 33867}
{"snippet": "DataFrame.mode(axis=0, dropna=True)", "intent": "Get the mode ( s ) of each element along the selected `axis` . With arguments `dropna`.", "question_id": 33868}
{"snippet": "DataFrame.mode(numeric_only=False, dropna=True)", "intent": "Get the mode ( s ) of each element along the selected `axis` . With arguments `numeric_only`, `dropna`.", "question_id": 33869}
{"snippet": "DataFrame.mode(axis=0, numeric_only=False, dropna=True)", "intent": "Get the mode ( s ) of each element along the selected `axis` . With arguments `numeric_only`, `dropna`.", "question_id": 33870}
{"snippet": "DataFrame.mode()", "intent": "Get the mode ( s ) of each element along the selected `axis` .", "question_id": 33871}
{"snippet": "DataFrame.mode(axis=0)", "intent": "Get the mode ( s ) of each element along the selected `axis` .", "question_id": 33872}
{"snippet": "DataFrame.mode(numeric_only=False)", "intent": "Get the mode ( s ) of each element along the selected `axis` . With arguments `numeric_only`.", "question_id": 33873}
{"snippet": "DataFrame.mode(dropna=True)", "intent": "Get the mode ( s ) of each element along the selected `axis` . With arguments `dropna`.", "question_id": 33874}
{"snippet": "DataFrame.mode(axis=0, numeric_only=False)", "intent": "Get the mode ( s ) of each element along the selected `axis` . With arguments `numeric_only`.", "question_id": 33875}
{"snippet": "DataFrame.mode(axis=0, dropna=True)", "intent": "Get the mode ( s ) of each element along the selected `axis` . With arguments `dropna`.", "question_id": 33876}
{"snippet": "DataFrame.mode(numeric_only=False, dropna=True)", "intent": "Get the mode ( s ) of each element along the selected `axis` . With arguments `numeric_only`, `dropna`.", "question_id": 33877}
{"snippet": "DataFrame.mode(axis=0, numeric_only=False, dropna=True)", "intent": "Get the mode ( s ) of each element along the selected `axis` . With arguments `numeric_only`, `dropna`.", "question_id": 33878}
{"snippet": "DataFrame.mode()", "intent": "Get the mode ( s ) of each element along the selected `axis` .", "question_id": 33879}
{"snippet": "DataFrame.mode(axis=0)", "intent": "Get the mode ( s ) of each element along the selected `axis` .", "question_id": 33880}
{"snippet": "DataFrame.mode(numeric_only=False)", "intent": "Get the mode ( s ) of each element along the selected `axis` . With arguments `numeric_only`.", "question_id": 33881}
{"snippet": "DataFrame.mode(dropna=True)", "intent": "Get the mode ( s ) of each element along the selected `axis` . With arguments `dropna`.", "question_id": 33882}
{"snippet": "DataFrame.mode(axis=0, numeric_only=False)", "intent": "Get the mode ( s ) of each element along the selected `axis` . With arguments `numeric_only`.", "question_id": 33883}
{"snippet": "DataFrame.mode(axis=0, dropna=True)", "intent": "Get the mode ( s ) of each element along the selected `axis` . With arguments `dropna`.", "question_id": 33884}
{"snippet": "DataFrame.mode(numeric_only=False, dropna=True)", "intent": "Get the mode ( s ) of each element along the selected `axis` . With arguments `numeric_only`, `dropna`.", "question_id": 33885}
{"snippet": "DataFrame.mode(axis=0, numeric_only=False, dropna=True)", "intent": "Get the mode ( s ) of each element along the selected `axis` . With arguments `numeric_only`, `dropna`.", "question_id": 33886}
{"snippet": "DataFrame.mul(other)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) .", "question_id": 33887}
{"snippet": "DataFrame.mul(other, axis='columns')", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Subtract a list and Series by `axis` with operator version .", "question_id": 33888}
{"snippet": "DataFrame.mul(other, level=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Divide by a MultiIndex by `level` .", "question_id": 33889}
{"snippet": "DataFrame.mul(other, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Equivalent to dataframe * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33890}
{"snippet": "DataFrame.mul(other, axis='columns', level=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 33891}
{"snippet": "DataFrame.mul(other, axis='columns', fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33892}
{"snippet": "DataFrame.mul(other, level=None, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Divide by a MultiIndex by `level` . Equivalent to dataframe * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33893}
{"snippet": "DataFrame.mul(other, axis='columns', level=None, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33894}
{"snippet": "DataFrame.mul(other)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) .", "question_id": 33895}
{"snippet": "DataFrame.mul(other, axis='columns')", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Subtract a list and Series by `axis` with operator version .", "question_id": 33896}
{"snippet": "DataFrame.mul(other, level=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Divide by a MultiIndex by `level` .", "question_id": 33897}
{"snippet": "DataFrame.mul(other, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Equivalent to dataframe * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33898}
{"snippet": "DataFrame.mul(other, axis='columns', level=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 33899}
{"snippet": "DataFrame.mul(other, axis='columns', fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33900}
{"snippet": "DataFrame.mul(other, level=None, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Divide by a MultiIndex by `level` . Equivalent to dataframe * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33901}
{"snippet": "DataFrame.mul(other, axis='columns', level=None, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33902}
{"snippet": "DataFrame.mul(other)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) .", "question_id": 33903}
{"snippet": "DataFrame.mul(other, axis='columns')", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Subtract a list and Series by `axis` with operator version .", "question_id": 33904}
{"snippet": "DataFrame.mul(other, level=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Divide by a MultiIndex by `level` .", "question_id": 33905}
{"snippet": "DataFrame.mul(other, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Equivalent to dataframe * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33906}
{"snippet": "DataFrame.mul(other, axis='columns', level=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 33907}
{"snippet": "DataFrame.mul(other, axis='columns', fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33908}
{"snippet": "DataFrame.mul(other, level=None, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Divide by a MultiIndex by `level` . Equivalent to dataframe * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33909}
{"snippet": "DataFrame.mul(other, axis='columns', level=None, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33910}
{"snippet": "DataFrame.multiply(other)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) .", "question_id": 33911}
{"snippet": "DataFrame.multiply(other, axis='columns')", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Subtract a list and Series by `axis` with operator version .", "question_id": 33912}
{"snippet": "DataFrame.multiply(other, level=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Divide by a MultiIndex by `level` .", "question_id": 33913}
{"snippet": "DataFrame.multiply(other, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Equivalent to dataframe * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33914}
{"snippet": "DataFrame.multiply(other, axis='columns', level=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 33915}
{"snippet": "DataFrame.multiply(other, axis='columns', fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33916}
{"snippet": "DataFrame.multiply(other, level=None, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Divide by a MultiIndex by `level` . Equivalent to dataframe * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33917}
{"snippet": "DataFrame.multiply(other, axis='columns', level=None, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33918}
{"snippet": "DataFrame.multiply(other)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) .", "question_id": 33919}
{"snippet": "DataFrame.multiply(other, axis='columns')", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Subtract a list and Series by `axis` with operator version .", "question_id": 33920}
{"snippet": "DataFrame.multiply(other, level=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Divide by a MultiIndex by `level` .", "question_id": 33921}
{"snippet": "DataFrame.multiply(other, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Equivalent to dataframe * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33922}
{"snippet": "DataFrame.multiply(other, axis='columns', level=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 33923}
{"snippet": "DataFrame.multiply(other, axis='columns', fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33924}
{"snippet": "DataFrame.multiply(other, level=None, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Divide by a MultiIndex by `level` . Equivalent to dataframe * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33925}
{"snippet": "DataFrame.multiply(other, axis='columns', level=None, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33926}
{"snippet": "DataFrame.multiply(other)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) .", "question_id": 33927}
{"snippet": "DataFrame.multiply(other, axis='columns')", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Subtract a list and Series by `axis` with operator version .", "question_id": 33928}
{"snippet": "DataFrame.multiply(other, level=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Divide by a MultiIndex by `level` .", "question_id": 33929}
{"snippet": "DataFrame.multiply(other, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Equivalent to dataframe * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33930}
{"snippet": "DataFrame.multiply(other, axis='columns', level=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 33931}
{"snippet": "DataFrame.multiply(other, axis='columns', fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33932}
{"snippet": "DataFrame.multiply(other, level=None, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Divide by a MultiIndex by `level` . Equivalent to dataframe * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33933}
{"snippet": "DataFrame.multiply(other, axis='columns', level=None, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator mul ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 33934}
{"snippet": "DataFrame.ne(other)", "intent": "Get Not equal to of dataframe and `other` , element-wise ( binary operator ne ) .", "question_id": 33935}
{"snippet": "DataFrame.ne(other, axis='columns')", "intent": "Get Not equal to of dataframe and `other` , element-wise ( binary operator ne ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33936}
{"snippet": "DataFrame.ne(other, level=None)", "intent": "Get Not equal to of dataframe and `other` , element-wise ( binary operator ne ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33937}
{"snippet": "DataFrame.ne(other, axis='columns', level=None)", "intent": "Get Not equal to of dataframe and `other` , element-wise ( binary operator ne ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33938}
{"snippet": "DataFrame.ne(other)", "intent": "Get Not equal to of dataframe and `other` , element-wise ( binary operator ne ) .", "question_id": 33939}
{"snippet": "DataFrame.ne(other, axis='columns')", "intent": "Get Not equal to of dataframe and `other` , element-wise ( binary operator ne ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33940}
{"snippet": "DataFrame.ne(other, level=None)", "intent": "Get Not equal to of dataframe and `other` , element-wise ( binary operator ne ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33941}
{"snippet": "DataFrame.ne(other, axis='columns', level=None)", "intent": "Get Not equal to of dataframe and `other` , element-wise ( binary operator ne ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33942}
{"snippet": "DataFrame.ne(other)", "intent": "Get Not equal to of dataframe and `other` , element-wise ( binary operator ne ) .", "question_id": 33943}
{"snippet": "DataFrame.ne(other, axis='columns')", "intent": "Get Not equal to of dataframe and `other` , element-wise ( binary operator ne ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33944}
{"snippet": "DataFrame.ne(other, level=None)", "intent": "Get Not equal to of dataframe and `other` , element-wise ( binary operator ne ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33945}
{"snippet": "DataFrame.ne(other, axis='columns', level=None)", "intent": "Get Not equal to of dataframe and `other` , element-wise ( binary operator ne ) . Equivalent to == , ! = , < = , < , > = , > with support to choose `axis` ( rows or columns ) and `level` for comparison .", "question_id": 33946}
{"snippet": "DataFrame.nlargest(n, columns)", "intent": "Return the first `n` rows ordered by `columns` in descending order .", "question_id": 33947}
{"snippet": "DataFrame.nlargest(n, columns, keep='first')", "intent": "Return the first `n` rows ordered by `columns` in descending order . With arguments `keep`.", "question_id": 33948}
{"snippet": "DataFrame.nlargest(n, columns)", "intent": "Return the first `n` rows ordered by `columns` in descending order .", "question_id": 33949}
{"snippet": "DataFrame.nlargest(n, columns, keep='first')", "intent": "Return the first `n` rows ordered by `columns` in descending order . With arguments `keep`.", "question_id": 33950}
{"snippet": "DataFrame.nlargest(n, columns)", "intent": "Return the first `n` rows ordered by `columns` in descending order .", "question_id": 33951}
{"snippet": "DataFrame.nlargest(n, columns, keep='first')", "intent": "Return the first `n` rows ordered by `columns` in descending order . With arguments `keep`.", "question_id": 33952}
{"snippet": "DataFrame.notna()", "intent": "Detect existing ( non-missing ) values .", "question_id": 33953}
{"snippet": "DataFrame.notna()", "intent": "Detect existing ( non-missing ) values .", "question_id": 33954}
{"snippet": "DataFrame.notna()", "intent": "Detect existing ( non-missing ) values .", "question_id": 33955}
{"snippet": "DataFrame.notnull()", "intent": "Detect existing ( non-missing ) values .", "question_id": 33956}
{"snippet": "DataFrame.notnull()", "intent": "Detect existing ( non-missing ) values .", "question_id": 33957}
{"snippet": "DataFrame.notnull()", "intent": "Detect existing ( non-missing ) values .", "question_id": 33958}
{"snippet": "DataFrame.nsmallest(n, columns)", "intent": "Return the first `n` rows ordered by `columns` in ascending order .", "question_id": 33959}
{"snippet": "DataFrame.nsmallest(n, columns, keep='first')", "intent": "Return the first `n` rows ordered by `columns` in ascending order . With arguments `keep`.", "question_id": 33960}
{"snippet": "DataFrame.nsmallest(n, columns)", "intent": "Return the first `n` rows ordered by `columns` in ascending order .", "question_id": 33961}
{"snippet": "DataFrame.nsmallest(n, columns, keep='first')", "intent": "Return the first `n` rows ordered by `columns` in ascending order . With arguments `keep`.", "question_id": 33962}
{"snippet": "DataFrame.nsmallest(n, columns)", "intent": "Return the first `n` rows ordered by `columns` in ascending order .", "question_id": 33963}
{"snippet": "DataFrame.nsmallest(n, columns, keep='first')", "intent": "Return the first `n` rows ordered by `columns` in ascending order . With arguments `keep`.", "question_id": 33964}
{"snippet": "DataFrame.nunique()", "intent": "Count number of distinct elements in specified `axis` .", "question_id": 33965}
{"snippet": "DataFrame.nunique(axis=0)", "intent": "Count number of distinct elements in specified `axis` .", "question_id": 33966}
{"snippet": "DataFrame.nunique(dropna=True)", "intent": "Count number of distinct elements in specified `axis` . With arguments `dropna`.", "question_id": 33967}
{"snippet": "DataFrame.nunique(axis=0, dropna=True)", "intent": "Count number of distinct elements in specified `axis` . With arguments `dropna`.", "question_id": 33968}
{"snippet": "DataFrame.nunique()", "intent": "Count number of distinct elements in specified `axis` .", "question_id": 33969}
{"snippet": "DataFrame.nunique(axis=0)", "intent": "Count number of distinct elements in specified `axis` .", "question_id": 33970}
{"snippet": "DataFrame.nunique(dropna=True)", "intent": "Count number of distinct elements in specified `axis` . With arguments `dropna`.", "question_id": 33971}
{"snippet": "DataFrame.nunique(axis=0, dropna=True)", "intent": "Count number of distinct elements in specified `axis` . With arguments `dropna`.", "question_id": 33972}
{"snippet": "DataFrame.nunique()", "intent": "Count number of distinct elements in specified `axis` .", "question_id": 33973}
{"snippet": "DataFrame.nunique(axis=0)", "intent": "Count number of distinct elements in specified `axis` .", "question_id": 33974}
{"snippet": "DataFrame.nunique(dropna=True)", "intent": "Count number of distinct elements in specified `axis` . With arguments `dropna`.", "question_id": 33975}
{"snippet": "DataFrame.nunique(axis=0, dropna=True)", "intent": "Count number of distinct elements in specified `axis` . With arguments `dropna`.", "question_id": 33976}
{"snippet": "DataFrame.pad()", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' .", "question_id": 33977}
{"snippet": "DataFrame.pad(axis=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`.", "question_id": 33978}
{"snippet": "DataFrame.pad(inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`.", "question_id": 33979}
{"snippet": "DataFrame.pad(limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `limit`.", "question_id": 33980}
{"snippet": "DataFrame.pad(downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `downcast`.", "question_id": 33981}
{"snippet": "DataFrame.pad(axis=None, inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `inplace`.", "question_id": 33982}
{"snippet": "DataFrame.pad(axis=None, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `limit`.", "question_id": 33983}
{"snippet": "DataFrame.pad(axis=None, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `downcast`.", "question_id": 33984}
{"snippet": "DataFrame.pad(inplace=False, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`, `limit`.", "question_id": 33985}
{"snippet": "DataFrame.pad(inplace=False, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`, `downcast`.", "question_id": 33986}
{"snippet": "DataFrame.pad()", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' .", "question_id": 33987}
{"snippet": "DataFrame.pad(axis=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`.", "question_id": 33988}
{"snippet": "DataFrame.pad(inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`.", "question_id": 33989}
{"snippet": "DataFrame.pad(limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `limit`.", "question_id": 33990}
{"snippet": "DataFrame.pad(downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `downcast`.", "question_id": 33991}
{"snippet": "DataFrame.pad(axis=None, inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `inplace`.", "question_id": 33992}
{"snippet": "DataFrame.pad(axis=None, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `limit`.", "question_id": 33993}
{"snippet": "DataFrame.pad(axis=None, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `downcast`.", "question_id": 33994}
{"snippet": "DataFrame.pad(inplace=False, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`, `limit`.", "question_id": 33995}
{"snippet": "DataFrame.pad(inplace=False, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`, `downcast`.", "question_id": 33996}
{"snippet": "DataFrame.pad()", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' .", "question_id": 33997}
{"snippet": "DataFrame.pad(axis=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`.", "question_id": 33998}
{"snippet": "DataFrame.pad(inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`.", "question_id": 33999}
{"snippet": "DataFrame.pad(limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `limit`.", "question_id": 34000}
{"snippet": "DataFrame.pad(downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `downcast`.", "question_id": 34001}
{"snippet": "DataFrame.pad(axis=None, inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `inplace`.", "question_id": 34002}
{"snippet": "DataFrame.pad(axis=None, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `limit`.", "question_id": 34003}
{"snippet": "DataFrame.pad(axis=None, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `downcast`.", "question_id": 34004}
{"snippet": "DataFrame.pad(inplace=False, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`, `limit`.", "question_id": 34005}
{"snippet": "DataFrame.pad(inplace=False, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`, `downcast`.", "question_id": 34006}
{"snippet": "DataFrame.pct_change(**kwargs)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`.", "question_id": 34007}
{"snippet": "DataFrame.pct_change(**kwargs, periods=1)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `periods`.", "question_id": 34008}
{"snippet": "DataFrame.pct_change(**kwargs, fill_method='pad')", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `fill_method`.", "question_id": 34009}
{"snippet": "DataFrame.pct_change(**kwargs, limit=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `limit`.", "question_id": 34010}
{"snippet": "DataFrame.pct_change(**kwargs, freq=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `freq`.", "question_id": 34011}
{"snippet": "DataFrame.pct_change(**kwargs, periods=1, fill_method='pad')", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `periods`, `fill_method`.", "question_id": 34012}
{"snippet": "DataFrame.pct_change(**kwargs, periods=1, limit=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `periods`, `limit`.", "question_id": 34013}
{"snippet": "DataFrame.pct_change(**kwargs, periods=1, freq=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `periods`, `freq`.", "question_id": 34014}
{"snippet": "DataFrame.pct_change(**kwargs, fill_method='pad', limit=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `fill_method`, `limit`.", "question_id": 34015}
{"snippet": "DataFrame.pct_change(**kwargs, fill_method='pad', freq=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `fill_method`, `freq`.", "question_id": 34016}
{"snippet": "DataFrame.pct_change(**kwargs)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`.", "question_id": 34017}
{"snippet": "DataFrame.pct_change(**kwargs, periods=1)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `periods`.", "question_id": 34018}
{"snippet": "DataFrame.pct_change(**kwargs, fill_method='pad')", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `fill_method`.", "question_id": 34019}
{"snippet": "DataFrame.pct_change(**kwargs, limit=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `limit`.", "question_id": 34020}
{"snippet": "DataFrame.pct_change(**kwargs, freq=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `freq`.", "question_id": 34021}
{"snippet": "DataFrame.pct_change(**kwargs, periods=1, fill_method='pad')", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `periods`, `fill_method`.", "question_id": 34022}
{"snippet": "DataFrame.pct_change(**kwargs, periods=1, limit=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `periods`, `limit`.", "question_id": 34023}
{"snippet": "DataFrame.pct_change(**kwargs, periods=1, freq=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `periods`, `freq`.", "question_id": 34024}
{"snippet": "DataFrame.pct_change(**kwargs, fill_method='pad', limit=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `fill_method`, `limit`.", "question_id": 34025}
{"snippet": "DataFrame.pct_change(**kwargs, fill_method='pad', freq=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `fill_method`, `freq`.", "question_id": 34026}
{"snippet": "DataFrame.pct_change(**kwargs)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`.", "question_id": 34027}
{"snippet": "DataFrame.pct_change(**kwargs, periods=1)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `periods`.", "question_id": 34028}
{"snippet": "DataFrame.pct_change(**kwargs, fill_method='pad')", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `fill_method`.", "question_id": 34029}
{"snippet": "DataFrame.pct_change(**kwargs, limit=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `limit`.", "question_id": 34030}
{"snippet": "DataFrame.pct_change(**kwargs, freq=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `freq`.", "question_id": 34031}
{"snippet": "DataFrame.pct_change(**kwargs, periods=1, fill_method='pad')", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `periods`, `fill_method`.", "question_id": 34032}
{"snippet": "DataFrame.pct_change(**kwargs, periods=1, limit=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `periods`, `limit`.", "question_id": 34033}
{"snippet": "DataFrame.pct_change(**kwargs, periods=1, freq=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `periods`, `freq`.", "question_id": 34034}
{"snippet": "DataFrame.pct_change(**kwargs, fill_method='pad', limit=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `fill_method`, `limit`.", "question_id": 34035}
{"snippet": "DataFrame.pct_change(**kwargs, fill_method='pad', freq=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `fill_method`, `freq`.", "question_id": 34036}
{"snippet": "DataFrame.pipe(func, *args, **kwargs)", "intent": "Apply `func` ( self , * args , * * kwargs ) . With arguments `*args`, `**kwargs`.", "question_id": 34037}
{"snippet": "DataFrame.pipe(func, *args, **kwargs)", "intent": "Apply `func` ( self , * args , * * kwargs ) . With arguments `*args`, `**kwargs`.", "question_id": 34038}
{"snippet": "DataFrame.pipe(func, *args, **kwargs)", "intent": "Apply `func` ( self , * args , * * kwargs ) . With arguments `*args`, `**kwargs`.", "question_id": 34039}
{"snippet": "DataFrame.pivot()", "intent": "Return reshaped DataFrame organized by given `index` / column `values` .", "question_id": 34040}
{"snippet": "DataFrame.pivot(index=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` .", "question_id": 34041}
{"snippet": "DataFrame.pivot(columns=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Uses unique values from specified index / `columns` to form axes of the resulting DataFrame .", "question_id": 34042}
{"snippet": "DataFrame.pivot(values=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` .", "question_id": 34043}
{"snippet": "DataFrame.pivot(index=None, columns=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Uses unique values from specified index / `columns` to form axes of the resulting DataFrame .", "question_id": 34044}
{"snippet": "DataFrame.pivot(index=None, values=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` .", "question_id": 34045}
{"snippet": "DataFrame.pivot(columns=None, values=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Uses unique values from specified index / `columns` to form axes of the resulting DataFrame .", "question_id": 34046}
{"snippet": "DataFrame.pivot(index=None, columns=None, values=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Uses unique values from specified index / `columns` to form axes of the resulting DataFrame .", "question_id": 34047}
{"snippet": "DataFrame.pivot()", "intent": "Return reshaped DataFrame organized by given `index` / column `values` .", "question_id": 34048}
{"snippet": "DataFrame.pivot(index=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` .", "question_id": 34049}
{"snippet": "DataFrame.pivot(columns=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Uses unique values from specified index / `columns` to form axes of the resulting DataFrame .", "question_id": 34050}
{"snippet": "DataFrame.pivot(values=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` .", "question_id": 34051}
{"snippet": "DataFrame.pivot(index=None, columns=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Uses unique values from specified index / `columns` to form axes of the resulting DataFrame .", "question_id": 34052}
{"snippet": "DataFrame.pivot(index=None, values=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` .", "question_id": 34053}
{"snippet": "DataFrame.pivot(columns=None, values=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Uses unique values from specified index / `columns` to form axes of the resulting DataFrame .", "question_id": 34054}
{"snippet": "DataFrame.pivot(index=None, columns=None, values=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Uses unique values from specified index / `columns` to form axes of the resulting DataFrame .", "question_id": 34055}
{"snippet": "DataFrame.pivot()", "intent": "Return reshaped DataFrame organized by given `index` / column `values` .", "question_id": 34056}
{"snippet": "DataFrame.pivot(index=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` .", "question_id": 34057}
{"snippet": "DataFrame.pivot(columns=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Uses unique values from specified index / `columns` to form axes of the resulting DataFrame .", "question_id": 34058}
{"snippet": "DataFrame.pivot(values=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` .", "question_id": 34059}
{"snippet": "DataFrame.pivot(index=None, columns=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Uses unique values from specified index / `columns` to form axes of the resulting DataFrame .", "question_id": 34060}
{"snippet": "DataFrame.pivot(index=None, values=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` .", "question_id": 34061}
{"snippet": "DataFrame.pivot(columns=None, values=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Uses unique values from specified index / `columns` to form axes of the resulting DataFrame .", "question_id": 34062}
{"snippet": "DataFrame.pivot(index=None, columns=None, values=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Uses unique values from specified index / `columns` to form axes of the resulting DataFrame .", "question_id": 34063}
{"snippet": "DataFrame.pivot_table()", "intent": "Create a spreadsheet-style pivot table as a DataFrame .", "question_id": 34064}
{"snippet": "DataFrame.pivot_table(values=None)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . This first example aggregates `values` by taking the sum .", "question_id": 34065}
{"snippet": "DataFrame.pivot_table(index=None)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . The levels in the pivot table will be stored in MultiIndex objects ( hierarchical indexes ) on the `index` and `columns` of the result DataFrame .", "question_id": 34066}
{"snippet": "DataFrame.pivot_table(columns=None)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . The levels in the pivot table will be stored in MultiIndex objects ( hierarchical indexes ) on the `index` and `columns` of the result DataFrame .", "question_id": 34067}
{"snippet": "DataFrame.pivot_table(aggfunc='mean')", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `aggfunc`.", "question_id": 34068}
{"snippet": "DataFrame.pivot_table(fill_value=None)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . We can also fill missing values using the `fill_value` parameter .", "question_id": 34069}
{"snippet": "DataFrame.pivot_table(margins=False)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `margins`.", "question_id": 34070}
{"snippet": "DataFrame.pivot_table(dropna=True)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `dropna`.", "question_id": 34071}
{"snippet": "DataFrame.pivot_table(margins_name='All')", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `margins_name`.", "question_id": 34072}
{"snippet": "DataFrame.pivot_table(observed=False)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `observed`.", "question_id": 34073}
{"snippet": "DataFrame.pivot_table()", "intent": "Create a spreadsheet-style pivot table as a DataFrame .", "question_id": 34074}
{"snippet": "DataFrame.pivot_table(values=None)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . This first example aggregates `values` by taking the sum .", "question_id": 34075}
{"snippet": "DataFrame.pivot_table(index=None)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . The levels in the pivot table will be stored in MultiIndex objects ( hierarchical indexes ) on the `index` and `columns` of the result DataFrame .", "question_id": 34076}
{"snippet": "DataFrame.pivot_table(columns=None)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . The levels in the pivot table will be stored in MultiIndex objects ( hierarchical indexes ) on the `index` and `columns` of the result DataFrame .", "question_id": 34077}
{"snippet": "DataFrame.pivot_table(aggfunc='mean')", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `aggfunc`.", "question_id": 34078}
{"snippet": "DataFrame.pivot_table(fill_value=None)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . We can also fill missing values using the `fill_value` parameter .", "question_id": 34079}
{"snippet": "DataFrame.pivot_table(margins=False)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `margins`.", "question_id": 34080}
{"snippet": "DataFrame.pivot_table(dropna=True)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `dropna`.", "question_id": 34081}
{"snippet": "DataFrame.pivot_table(margins_name='All')", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `margins_name`.", "question_id": 34082}
{"snippet": "DataFrame.pivot_table(observed=False)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `observed`.", "question_id": 34083}
{"snippet": "DataFrame.pivot_table()", "intent": "Create a spreadsheet-style pivot table as a DataFrame .", "question_id": 34084}
{"snippet": "DataFrame.pivot_table(values=None)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . This first example aggregates `values` by taking the sum .", "question_id": 34085}
{"snippet": "DataFrame.pivot_table(index=None)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . The levels in the pivot table will be stored in MultiIndex objects ( hierarchical indexes ) on the `index` and `columns` of the result DataFrame .", "question_id": 34086}
{"snippet": "DataFrame.pivot_table(columns=None)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . The levels in the pivot table will be stored in MultiIndex objects ( hierarchical indexes ) on the `index` and `columns` of the result DataFrame .", "question_id": 34087}
{"snippet": "DataFrame.pivot_table(aggfunc='mean')", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `aggfunc`.", "question_id": 34088}
{"snippet": "DataFrame.pivot_table(fill_value=None)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . We can also fill missing values using the `fill_value` parameter .", "question_id": 34089}
{"snippet": "DataFrame.pivot_table(margins=False)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `margins`.", "question_id": 34090}
{"snippet": "DataFrame.pivot_table(dropna=True)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `dropna`.", "question_id": 34091}
{"snippet": "DataFrame.pivot_table(margins_name='All')", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `margins_name`.", "question_id": 34092}
{"snippet": "DataFrame.pivot_table(observed=False)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `observed`.", "question_id": 34093}
{"snippet": "DataFrame.plot.area(**kwargs)", "intent": "Draw a stacked area plot . With arguments `**kwargs`.", "question_id": 34094}
{"snippet": "DataFrame.plot.area(**kwargs, x=None)", "intent": "Draw a stacked area plot . Draw with a different `x` : With arguments `**kwargs`.", "question_id": 34095}
{"snippet": "DataFrame.plot.area(**kwargs, y=None)", "intent": "Draw a stacked area plot . With arguments `**kwargs`, `y`.", "question_id": 34096}
{"snippet": "DataFrame.plot.area(**kwargs, x=None, y=None)", "intent": "Draw a stacked area plot . Draw with a different `x` : With arguments `**kwargs`, `y`.", "question_id": 34097}
{"snippet": "DataFrame.plot.area(**kwargs)", "intent": "Draw a stacked area plot . With arguments `**kwargs`.", "question_id": 34098}
{"snippet": "DataFrame.plot.area(**kwargs, x=None)", "intent": "Draw a stacked area plot . Draw with a different `x` : With arguments `**kwargs`.", "question_id": 34099}
{"snippet": "DataFrame.plot.area(**kwargs, y=None)", "intent": "Draw a stacked area plot . With arguments `**kwargs`, `y`.", "question_id": 34100}
{"snippet": "DataFrame.plot.area(**kwargs, x=None, y=None)", "intent": "Draw a stacked area plot . Draw with a different `x` : With arguments `**kwargs`, `y`.", "question_id": 34101}
{"snippet": "DataFrame.plot.area(**kwargs)", "intent": "Draw a stacked area plot . With arguments `**kwargs`.", "question_id": 34102}
{"snippet": "DataFrame.plot.area(**kwargs, x=None)", "intent": "Draw a stacked area plot . Draw with a different `x` : With arguments `**kwargs`.", "question_id": 34103}
{"snippet": "DataFrame.plot.area(**kwargs, y=None)", "intent": "Draw a stacked area plot . With arguments `**kwargs`, `y`.", "question_id": 34104}
{"snippet": "DataFrame.plot.area(**kwargs, x=None, y=None)", "intent": "Draw a stacked area plot . Draw with a different `x` : With arguments `**kwargs`, `y`.", "question_id": 34105}
{"snippet": "DataFrame.plot.bar(**kwargs)", "intent": "Vertical bar plot . With arguments `**kwargs`.", "question_id": 34106}
{"snippet": "DataFrame.plot.bar(**kwargs, x=None)", "intent": "Vertical bar plot . With arguments `**kwargs`, `x`.", "question_id": 34107}
{"snippet": "DataFrame.plot.bar(**kwargs, y=None)", "intent": "Vertical bar plot . With arguments `**kwargs`, `y`.", "question_id": 34108}
{"snippet": "DataFrame.plot.bar(**kwargs, x=None, y=None)", "intent": "Vertical bar plot . With arguments `**kwargs`, `x`, `y`.", "question_id": 34109}
{"snippet": "DataFrame.plot.bar(**kwargs)", "intent": "Vertical bar plot . With arguments `**kwargs`.", "question_id": 34110}
{"snippet": "DataFrame.plot.bar(**kwargs, x=None)", "intent": "Vertical bar plot . With arguments `**kwargs`, `x`.", "question_id": 34111}
{"snippet": "DataFrame.plot.bar(**kwargs, y=None)", "intent": "Vertical bar plot . With arguments `**kwargs`, `y`.", "question_id": 34112}
{"snippet": "DataFrame.plot.bar(**kwargs, x=None, y=None)", "intent": "Vertical bar plot . With arguments `**kwargs`, `x`, `y`.", "question_id": 34113}
{"snippet": "DataFrame.plot.bar(**kwargs)", "intent": "Vertical bar plot . With arguments `**kwargs`.", "question_id": 34114}
{"snippet": "DataFrame.plot.bar(**kwargs, x=None)", "intent": "Vertical bar plot . With arguments `**kwargs`, `x`.", "question_id": 34115}
{"snippet": "DataFrame.plot.bar(**kwargs, y=None)", "intent": "Vertical bar plot . With arguments `**kwargs`, `y`.", "question_id": 34116}
{"snippet": "DataFrame.plot.bar(**kwargs, x=None, y=None)", "intent": "Vertical bar plot . With arguments `**kwargs`, `x`, `y`.", "question_id": 34117}
{"snippet": "DataFrame.plot.barh(**kwargs)", "intent": "Make a horizontal bar plot . With arguments `**kwargs`.", "question_id": 34118}
{"snippet": "DataFrame.plot.barh(**kwargs, x=None)", "intent": "Make a horizontal bar plot . With arguments `**kwargs`, `x`.", "question_id": 34119}
{"snippet": "DataFrame.plot.barh(**kwargs, y=None)", "intent": "Make a horizontal bar plot . With arguments `**kwargs`, `y`.", "question_id": 34120}
{"snippet": "DataFrame.plot.barh(**kwargs, x=None, y=None)", "intent": "Make a horizontal bar plot . With arguments `**kwargs`, `x`, `y`.", "question_id": 34121}
{"snippet": "DataFrame.plot.barh(**kwargs)", "intent": "Make a horizontal bar plot . With arguments `**kwargs`.", "question_id": 34122}
{"snippet": "DataFrame.plot.barh(**kwargs, x=None)", "intent": "Make a horizontal bar plot . With arguments `**kwargs`, `x`.", "question_id": 34123}
{"snippet": "DataFrame.plot.barh(**kwargs, y=None)", "intent": "Make a horizontal bar plot . With arguments `**kwargs`, `y`.", "question_id": 34124}
{"snippet": "DataFrame.plot.barh(**kwargs, x=None, y=None)", "intent": "Make a horizontal bar plot . With arguments `**kwargs`, `x`, `y`.", "question_id": 34125}
{"snippet": "DataFrame.plot.barh(**kwargs)", "intent": "Make a horizontal bar plot . With arguments `**kwargs`.", "question_id": 34126}
{"snippet": "DataFrame.plot.barh(**kwargs, x=None)", "intent": "Make a horizontal bar plot . With arguments `**kwargs`, `x`.", "question_id": 34127}
{"snippet": "DataFrame.plot.barh(**kwargs, y=None)", "intent": "Make a horizontal bar plot . With arguments `**kwargs`, `y`.", "question_id": 34128}
{"snippet": "DataFrame.plot.barh(**kwargs, x=None, y=None)", "intent": "Make a horizontal bar plot . With arguments `**kwargs`, `x`, `y`.", "question_id": 34129}
{"snippet": "DataFrame.plot.box(**kwargs)", "intent": "Make a box plot of the DataFrame columns . With arguments `**kwargs`.", "question_id": 34130}
{"snippet": "DataFrame.plot.box(**kwargs, by=None)", "intent": "Make a box plot of the DataFrame columns . The position of the whiskers is set `by` default to 1.5 * IQR ( IQR = Q3 - Q1 ) from the edges of the box . With arguments `**kwargs`.", "question_id": 34131}
{"snippet": "DataFrame.plot.box(**kwargs)", "intent": "Make a box plot of the DataFrame columns . With arguments `**kwargs`.", "question_id": 34132}
{"snippet": "DataFrame.plot.box(**kwargs, by=None)", "intent": "Make a box plot of the DataFrame columns . The position of the whiskers is set `by` default to 1.5 * IQR ( IQR = Q3 - Q1 ) from the edges of the box . With arguments `**kwargs`.", "question_id": 34133}
{"snippet": "DataFrame.plot.box(**kwargs)", "intent": "Make a box plot of the DataFrame columns . With arguments `**kwargs`.", "question_id": 34134}
{"snippet": "DataFrame.plot.box(**kwargs, by=None)", "intent": "Make a box plot of the DataFrame columns . The position of the whiskers is set `by` default to 1.5 * IQR ( IQR = Q3 - Q1 ) from the edges of the box . With arguments `**kwargs`.", "question_id": 34135}
{"snippet": "DataFrame.plot.density(**kwargs)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . With arguments `**kwargs`.", "question_id": 34136}
{"snippet": "DataFrame.plot.density(**kwargs, bw_method=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . With arguments `**kwargs`, `bw_method`.", "question_id": 34137}
{"snippet": "DataFrame.plot.density(**kwargs, ind=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . Finally , the `ind` parameter determines the evaluation points for the plot of the estimated PDF : With arguments `**kwargs`.", "question_id": 34138}
{"snippet": "DataFrame.plot.density(**kwargs, bw_method=None, ind=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . Finally , the `ind` parameter determines the evaluation points for the plot of the estimated PDF : With arguments `**kwargs`, `bw_method`.", "question_id": 34139}
{"snippet": "DataFrame.plot.density(**kwargs)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . With arguments `**kwargs`.", "question_id": 34140}
{"snippet": "DataFrame.plot.density(**kwargs, bw_method=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . With arguments `**kwargs`, `bw_method`.", "question_id": 34141}
{"snippet": "DataFrame.plot.density(**kwargs, ind=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . Finally , the `ind` parameter determines the evaluation points for the plot of the estimated PDF : With arguments `**kwargs`.", "question_id": 34142}
{"snippet": "DataFrame.plot.density(**kwargs, bw_method=None, ind=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . Finally , the `ind` parameter determines the evaluation points for the plot of the estimated PDF : With arguments `**kwargs`, `bw_method`.", "question_id": 34143}
{"snippet": "DataFrame.plot.density(**kwargs)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . With arguments `**kwargs`.", "question_id": 34144}
{"snippet": "DataFrame.plot.density(**kwargs, bw_method=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . With arguments `**kwargs`, `bw_method`.", "question_id": 34145}
{"snippet": "DataFrame.plot.density(**kwargs, ind=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . Finally , the `ind` parameter determines the evaluation points for the plot of the estimated PDF : With arguments `**kwargs`.", "question_id": 34146}
{"snippet": "DataFrame.plot.density(**kwargs, bw_method=None, ind=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . Finally , the `ind` parameter determines the evaluation points for the plot of the estimated PDF : With arguments `**kwargs`, `bw_method`.", "question_id": 34147}
{"snippet": "DataFrame.plot.hexbin(x, y, **kwargs)", "intent": "Generate a hexagonal binning plot . Generate a hexagonal binning plot of `x` versus `y` . With arguments `**kwargs`.", "question_id": 34148}
{"snippet": "DataFrame.plot.hexbin(x, y, **kwargs, C=None)", "intent": "Generate a hexagonal binning plot . Generate a hexagonal binning plot of `x` versus `y` . If `C` is None ( the default ) , this is a histogram of the number of occurrences of the observations at ( x [ i ] , y [ i ] ) . With arguments `**kwargs`.", "question_id": 34149}
{"snippet": "DataFrame.plot.hexbin(x, y, **kwargs, reduce_C_function=None)", "intent": "Generate a hexagonal binning plot . Generate a hexagonal binning plot of `x` versus `y` . These values are accumulated for each hexagonal bin and then reduced according to `reduce_C_function` , having as default the NumPy \u2019 s mean function ( numpy.mean ( ) ) . With arguments `**kwargs`.", "question_id": 34150}
{"snippet": "DataFrame.plot.hexbin(x, y, **kwargs, gridsize=None)", "intent": "Generate a hexagonal binning plot . Generate a hexagonal binning plot of `x` versus `y` . With arguments `**kwargs`, `gridsize`.", "question_id": 34151}
{"snippet": "DataFrame.plot.hexbin(x, y, **kwargs, C=None, reduce_C_function=None)", "intent": "Generate a hexagonal binning plot . Generate a hexagonal binning plot of `x` versus `y` . If `C` is None ( the default ) , this is a histogram of the number of occurrences of the observations at ( x [ i ] , y [ i ] ) . These values are accumulated for each hexagonal bin and then reduced according to `reduce_C_function` , having as default the NumPy \u2019 s mean function ( numpy.mean ( ) ) . With arguments `**kwargs`.", "question_id": 34152}
{"snippet": "DataFrame.plot.hexbin(x, y, **kwargs, C=None, gridsize=None)", "intent": "Generate a hexagonal binning plot . Generate a hexagonal binning plot of `x` versus `y` . If `C` is None ( the default ) , this is a histogram of the number of occurrences of the observations at ( x [ i ] , y [ i ] ) . With arguments `**kwargs`, `gridsize`.", "question_id": 34153}
{"snippet": "DataFrame.plot.hexbin(x, y, **kwargs, reduce_C_function=None, gridsize=None)", "intent": "Generate a hexagonal binning plot . Generate a hexagonal binning plot of `x` versus `y` . These values are accumulated for each hexagonal bin and then reduced according to `reduce_C_function` , having as default the NumPy \u2019 s mean function ( numpy.mean ( ) ) . With arguments `**kwargs`, `gridsize`.", "question_id": 34154}
{"snippet": "DataFrame.plot.hexbin(x, y, **kwargs, C=None, reduce_C_function=None, gridsize=None)", "intent": "Generate a hexagonal binning plot . Generate a hexagonal binning plot of `x` versus `y` . If `C` is None ( the default ) , this is a histogram of the number of occurrences of the observations at ( x [ i ] , y [ i ] ) . These values are accumulated for each hexagonal bin and then reduced according to `reduce_C_function` , having as default the NumPy \u2019 s mean function ( numpy.mean ( ) ) . With arguments `**kwargs`, `gridsize`.", "question_id": 34155}
{"snippet": "DataFrame.plot.hexbin(x, y, **kwargs)", "intent": "Generate a hexagonal binning plot . Generate a hexagonal binning plot of `x` versus `y` . With arguments `**kwargs`.", "question_id": 34156}
{"snippet": "DataFrame.plot.hexbin(x, y, **kwargs, C=None)", "intent": "Generate a hexagonal binning plot . Generate a hexagonal binning plot of `x` versus `y` . If `C` is None ( the default ) , this is a histogram of the number of occurrences of the observations at ( x [ i ] , y [ i ] ) . With arguments `**kwargs`.", "question_id": 34157}
{"snippet": "DataFrame.plot.hexbin(x, y, **kwargs, reduce_C_function=None)", "intent": "Generate a hexagonal binning plot . Generate a hexagonal binning plot of `x` versus `y` . These values are accumulated for each hexagonal bin and then reduced according to `reduce_C_function` , having as default the NumPy \u2019 s mean function ( numpy.mean ( ) ) . With arguments `**kwargs`.", "question_id": 34158}
{"snippet": "DataFrame.plot.hexbin(x, y, **kwargs, gridsize=None)", "intent": "Generate a hexagonal binning plot . Generate a hexagonal binning plot of `x` versus `y` . With arguments `**kwargs`, `gridsize`.", "question_id": 34159}
{"snippet": "DataFrame.plot.hexbin(x, y, **kwargs, C=None, reduce_C_function=None)", "intent": "Generate a hexagonal binning plot . Generate a hexagonal binning plot of `x` versus `y` . If `C` is None ( the default ) , this is a histogram of the number of occurrences of the observations at ( x [ i ] , y [ i ] ) . These values are accumulated for each hexagonal bin and then reduced according to `reduce_C_function` , having as default the NumPy \u2019 s mean function ( numpy.mean ( ) ) . With arguments `**kwargs`.", "question_id": 34160}
{"snippet": "DataFrame.plot.hexbin(x, y, **kwargs, C=None, gridsize=None)", "intent": "Generate a hexagonal binning plot . Generate a hexagonal binning plot of `x` versus `y` . If `C` is None ( the default ) , this is a histogram of the number of occurrences of the observations at ( x [ i ] , y [ i ] ) . With arguments `**kwargs`, `gridsize`.", "question_id": 34161}
{"snippet": "DataFrame.plot.hexbin(x, y, **kwargs, reduce_C_function=None, gridsize=None)", "intent": "Generate a hexagonal binning plot . Generate a hexagonal binning plot of `x` versus `y` . These values are accumulated for each hexagonal bin and then reduced according to `reduce_C_function` , having as default the NumPy \u2019 s mean function ( numpy.mean ( ) ) . With arguments `**kwargs`, `gridsize`.", "question_id": 34162}
{"snippet": "DataFrame.plot.hexbin(x, y, **kwargs, C=None, reduce_C_function=None, gridsize=None)", "intent": "Generate a hexagonal binning plot . Generate a hexagonal binning plot of `x` versus `y` . If `C` is None ( the default ) , this is a histogram of the number of occurrences of the observations at ( x [ i ] , y [ i ] ) . These values are accumulated for each hexagonal bin and then reduced according to `reduce_C_function` , having as default the NumPy \u2019 s mean function ( numpy.mean ( ) ) . With arguments `**kwargs`, `gridsize`.", "question_id": 34163}
{"snippet": "DataFrame.plot.hexbin(x, y, **kwargs)", "intent": "Generate a hexagonal binning plot . Generate a hexagonal binning plot of `x` versus `y` . With arguments `**kwargs`.", "question_id": 34164}
{"snippet": "DataFrame.plot.hexbin(x, y, **kwargs, C=None)", "intent": "Generate a hexagonal binning plot . Generate a hexagonal binning plot of `x` versus `y` . If `C` is None ( the default ) , this is a histogram of the number of occurrences of the observations at ( x [ i ] , y [ i ] ) . With arguments `**kwargs`.", "question_id": 34165}
{"snippet": "DataFrame.plot.hexbin(x, y, **kwargs, reduce_C_function=None)", "intent": "Generate a hexagonal binning plot . Generate a hexagonal binning plot of `x` versus `y` . These values are accumulated for each hexagonal bin and then reduced according to `reduce_C_function` , having as default the NumPy \u2019 s mean function ( numpy.mean ( ) ) . With arguments `**kwargs`.", "question_id": 34166}
{"snippet": "DataFrame.plot.hexbin(x, y, **kwargs, gridsize=None)", "intent": "Generate a hexagonal binning plot . Generate a hexagonal binning plot of `x` versus `y` . With arguments `**kwargs`, `gridsize`.", "question_id": 34167}
{"snippet": "DataFrame.plot.hexbin(x, y, **kwargs, C=None, reduce_C_function=None)", "intent": "Generate a hexagonal binning plot . Generate a hexagonal binning plot of `x` versus `y` . If `C` is None ( the default ) , this is a histogram of the number of occurrences of the observations at ( x [ i ] , y [ i ] ) . These values are accumulated for each hexagonal bin and then reduced according to `reduce_C_function` , having as default the NumPy \u2019 s mean function ( numpy.mean ( ) ) . With arguments `**kwargs`.", "question_id": 34168}
{"snippet": "DataFrame.plot.hexbin(x, y, **kwargs, C=None, gridsize=None)", "intent": "Generate a hexagonal binning plot . Generate a hexagonal binning plot of `x` versus `y` . If `C` is None ( the default ) , this is a histogram of the number of occurrences of the observations at ( x [ i ] , y [ i ] ) . With arguments `**kwargs`, `gridsize`.", "question_id": 34169}
{"snippet": "DataFrame.plot.hexbin(x, y, **kwargs, reduce_C_function=None, gridsize=None)", "intent": "Generate a hexagonal binning plot . Generate a hexagonal binning plot of `x` versus `y` . These values are accumulated for each hexagonal bin and then reduced according to `reduce_C_function` , having as default the NumPy \u2019 s mean function ( numpy.mean ( ) ) . With arguments `**kwargs`, `gridsize`.", "question_id": 34170}
{"snippet": "DataFrame.plot.hexbin(x, y, **kwargs, C=None, reduce_C_function=None, gridsize=None)", "intent": "Generate a hexagonal binning plot . Generate a hexagonal binning plot of `x` versus `y` . If `C` is None ( the default ) , this is a histogram of the number of occurrences of the observations at ( x [ i ] , y [ i ] ) . These values are accumulated for each hexagonal bin and then reduced according to `reduce_C_function` , having as default the NumPy \u2019 s mean function ( numpy.mean ( ) ) . With arguments `**kwargs`, `gridsize`.", "question_id": 34171}
{"snippet": "DataFrame.plot.hist(**kwargs)", "intent": "Draw one histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`.", "question_id": 34172}
{"snippet": "DataFrame.plot.hist(**kwargs, by=None)", "intent": "Draw one histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `by`.", "question_id": 34173}
{"snippet": "DataFrame.plot.hist(**kwargs, bins=10)", "intent": "Draw one histogram of the DataFrame \u2019 s columns . This function groups the values of all given Series in the DataFrame into `bins` and draws all bins in one matplotlib.axes.Axes . With arguments `**kwargs`.", "question_id": 34174}
{"snippet": "DataFrame.plot.hist(**kwargs, by=None, bins=10)", "intent": "Draw one histogram of the DataFrame \u2019 s columns . This function groups the values of all given Series in the DataFrame into `bins` and draws all bins in one matplotlib.axes.Axes . With arguments `**kwargs`, `by`.", "question_id": 34175}
{"snippet": "DataFrame.plot.hist(**kwargs)", "intent": "Draw one histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`.", "question_id": 34176}
{"snippet": "DataFrame.plot.hist(**kwargs, by=None)", "intent": "Draw one histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `by`.", "question_id": 34177}
{"snippet": "DataFrame.plot.hist(**kwargs, bins=10)", "intent": "Draw one histogram of the DataFrame \u2019 s columns . This function groups the values of all given Series in the DataFrame into `bins` and draws all bins in one matplotlib.axes.Axes . With arguments `**kwargs`.", "question_id": 34178}
{"snippet": "DataFrame.plot.hist(**kwargs, by=None, bins=10)", "intent": "Draw one histogram of the DataFrame \u2019 s columns . This function groups the values of all given Series in the DataFrame into `bins` and draws all bins in one matplotlib.axes.Axes . With arguments `**kwargs`, `by`.", "question_id": 34179}
{"snippet": "DataFrame.plot.hist(**kwargs)", "intent": "Draw one histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`.", "question_id": 34180}
{"snippet": "DataFrame.plot.hist(**kwargs, by=None)", "intent": "Draw one histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `by`.", "question_id": 34181}
{"snippet": "DataFrame.plot.hist(**kwargs, bins=10)", "intent": "Draw one histogram of the DataFrame \u2019 s columns . This function groups the values of all given Series in the DataFrame into `bins` and draws all bins in one matplotlib.axes.Axes . With arguments `**kwargs`.", "question_id": 34182}
{"snippet": "DataFrame.plot.hist(**kwargs, by=None, bins=10)", "intent": "Draw one histogram of the DataFrame \u2019 s columns . This function groups the values of all given Series in the DataFrame into `bins` and draws all bins in one matplotlib.axes.Axes . With arguments `**kwargs`, `by`.", "question_id": 34183}
{"snippet": "DataFrame.plot(*args, **kwargs)", "intent": "Make plots of Series or DataFrame . With arguments `*args`, `**kwargs`.", "question_id": 34184}
{"snippet": "DataFrame.plot(*args, **kwargs)", "intent": "Make plots of Series or DataFrame . With arguments `*args`, `**kwargs`.", "question_id": 34185}
{"snippet": "DataFrame.plot(*args, **kwargs)", "intent": "Make plots of Series or DataFrame . With arguments `*args`, `**kwargs`.", "question_id": 34186}
{"snippet": "DataFrame.plot.kde(**kwargs)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . With arguments `**kwargs`.", "question_id": 34187}
{"snippet": "DataFrame.plot.kde(**kwargs, bw_method=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . With arguments `**kwargs`, `bw_method`.", "question_id": 34188}
{"snippet": "DataFrame.plot.kde(**kwargs, ind=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . Finally , the `ind` parameter determines the evaluation points for the plot of the estimated PDF : With arguments `**kwargs`.", "question_id": 34189}
{"snippet": "DataFrame.plot.kde(**kwargs, bw_method=None, ind=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . Finally , the `ind` parameter determines the evaluation points for the plot of the estimated PDF : With arguments `**kwargs`, `bw_method`.", "question_id": 34190}
{"snippet": "DataFrame.plot.kde(**kwargs)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . With arguments `**kwargs`.", "question_id": 34191}
{"snippet": "DataFrame.plot.kde(**kwargs, bw_method=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . With arguments `**kwargs`, `bw_method`.", "question_id": 34192}
{"snippet": "DataFrame.plot.kde(**kwargs, ind=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . Finally , the `ind` parameter determines the evaluation points for the plot of the estimated PDF : With arguments `**kwargs`.", "question_id": 34193}
{"snippet": "DataFrame.plot.kde(**kwargs, bw_method=None, ind=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . Finally , the `ind` parameter determines the evaluation points for the plot of the estimated PDF : With arguments `**kwargs`, `bw_method`.", "question_id": 34194}
{"snippet": "DataFrame.plot.kde(**kwargs)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . With arguments `**kwargs`.", "question_id": 34195}
{"snippet": "DataFrame.plot.kde(**kwargs, bw_method=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . With arguments `**kwargs`, `bw_method`.", "question_id": 34196}
{"snippet": "DataFrame.plot.kde(**kwargs, ind=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . Finally , the `ind` parameter determines the evaluation points for the plot of the estimated PDF : With arguments `**kwargs`.", "question_id": 34197}
{"snippet": "DataFrame.plot.kde(**kwargs, bw_method=None, ind=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . Finally , the `ind` parameter determines the evaluation points for the plot of the estimated PDF : With arguments `**kwargs`, `bw_method`.", "question_id": 34198}
{"snippet": "DataFrame.plot.line(**kwargs)", "intent": "Plot Series or DataFrame as lines . With arguments `**kwargs`.", "question_id": 34199}
{"snippet": "DataFrame.plot.line(**kwargs, x=None)", "intent": "Plot Series or DataFrame as lines . With arguments `**kwargs`, `x`.", "question_id": 34200}
{"snippet": "DataFrame.plot.line(**kwargs, y=None)", "intent": "Plot Series or DataFrame as lines . With arguments `**kwargs`, `y`.", "question_id": 34201}
{"snippet": "DataFrame.plot.line(**kwargs, x=None, y=None)", "intent": "Plot Series or DataFrame as lines . With arguments `**kwargs`, `x`, `y`.", "question_id": 34202}
{"snippet": "DataFrame.plot.line(**kwargs)", "intent": "Plot Series or DataFrame as lines . With arguments `**kwargs`.", "question_id": 34203}
{"snippet": "DataFrame.plot.line(**kwargs, x=None)", "intent": "Plot Series or DataFrame as lines . With arguments `**kwargs`, `x`.", "question_id": 34204}
{"snippet": "DataFrame.plot.line(**kwargs, y=None)", "intent": "Plot Series or DataFrame as lines . With arguments `**kwargs`, `y`.", "question_id": 34205}
{"snippet": "DataFrame.plot.line(**kwargs, x=None, y=None)", "intent": "Plot Series or DataFrame as lines . With arguments `**kwargs`, `x`, `y`.", "question_id": 34206}
{"snippet": "DataFrame.plot.line(**kwargs)", "intent": "Plot Series or DataFrame as lines . With arguments `**kwargs`.", "question_id": 34207}
{"snippet": "DataFrame.plot.line(**kwargs, x=None)", "intent": "Plot Series or DataFrame as lines . With arguments `**kwargs`, `x`.", "question_id": 34208}
{"snippet": "DataFrame.plot.line(**kwargs, y=None)", "intent": "Plot Series or DataFrame as lines . With arguments `**kwargs`, `y`.", "question_id": 34209}
{"snippet": "DataFrame.plot.line(**kwargs, x=None, y=None)", "intent": "Plot Series or DataFrame as lines . With arguments `**kwargs`, `x`, `y`.", "question_id": 34210}
{"snippet": "DataFrame.plot.pie(**kwargs)", "intent": "Generate a pie plot . With arguments `**kwargs`.", "question_id": 34211}
{"snippet": "DataFrame.plot.pie(**kwargs)", "intent": "Generate a pie plot . With arguments `**kwargs`.", "question_id": 34212}
{"snippet": "DataFrame.plot.pie(**kwargs)", "intent": "Generate a pie plot . With arguments `**kwargs`.", "question_id": 34213}
{"snippet": "DataFrame.plot.scatter(x, y, **kwargs)", "intent": "Create a scatter plot with varying marker point size and color . With arguments `x`, `y`, `**kwargs`.", "question_id": 34214}
{"snippet": "DataFrame.plot.scatter(x, y, **kwargs, s=None)", "intent": "Create a scatter plot with varying marker point size and color . Let \u2019 `s` see how to draw a scatter plot using coordinates from the values in a DataFrame \u2019 s columns . With arguments `x`, `y`, `**kwargs`.", "question_id": 34215}
{"snippet": "DataFrame.plot.scatter(x, y, **kwargs, c=None)", "intent": "Create a scatter plot with varying marker point size and color . With arguments `x`, `y`, `**kwargs`, `c`.", "question_id": 34216}
{"snippet": "DataFrame.plot.scatter(x, y, **kwargs, s=None, c=None)", "intent": "Create a scatter plot with varying marker point size and color . Let \u2019 `s` see how to draw a scatter plot using coordinates from the values in a DataFrame \u2019 s columns . With arguments `x`, `y`, `**kwargs`, `c`.", "question_id": 34217}
{"snippet": "DataFrame.plot.scatter(x, y, **kwargs)", "intent": "Create a scatter plot with varying marker point size and color . With arguments `x`, `y`, `**kwargs`.", "question_id": 34218}
{"snippet": "DataFrame.plot.scatter(x, y, **kwargs, s=None)", "intent": "Create a scatter plot with varying marker point size and color . Let \u2019 `s` see how to draw a scatter plot using coordinates from the values in a DataFrame \u2019 s columns . With arguments `x`, `y`, `**kwargs`.", "question_id": 34219}
{"snippet": "DataFrame.plot.scatter(x, y, **kwargs, c=None)", "intent": "Create a scatter plot with varying marker point size and color . With arguments `x`, `y`, `**kwargs`, `c`.", "question_id": 34220}
{"snippet": "DataFrame.plot.scatter(x, y, **kwargs, s=None, c=None)", "intent": "Create a scatter plot with varying marker point size and color . Let \u2019 `s` see how to draw a scatter plot using coordinates from the values in a DataFrame \u2019 s columns . With arguments `x`, `y`, `**kwargs`, `c`.", "question_id": 34221}
{"snippet": "DataFrame.plot.scatter(x, y, **kwargs)", "intent": "Create a scatter plot with varying marker point size and color . With arguments `x`, `y`, `**kwargs`.", "question_id": 34222}
{"snippet": "DataFrame.plot.scatter(x, y, **kwargs, s=None)", "intent": "Create a scatter plot with varying marker point size and color . Let \u2019 `s` see how to draw a scatter plot using coordinates from the values in a DataFrame \u2019 s columns . With arguments `x`, `y`, `**kwargs`.", "question_id": 34223}
{"snippet": "DataFrame.plot.scatter(x, y, **kwargs, c=None)", "intent": "Create a scatter plot with varying marker point size and color . With arguments `x`, `y`, `**kwargs`, `c`.", "question_id": 34224}
{"snippet": "DataFrame.plot.scatter(x, y, **kwargs, s=None, c=None)", "intent": "Create a scatter plot with varying marker point size and color . Let \u2019 `s` see how to draw a scatter plot using coordinates from the values in a DataFrame \u2019 s columns . With arguments `x`, `y`, `**kwargs`, `c`.", "question_id": 34225}
{"snippet": "DataFrame.pop(item)", "intent": "Return `item` and drop from frame .", "question_id": 34226}
{"snippet": "DataFrame.pop(item)", "intent": "Return `item` and drop from frame .", "question_id": 34227}
{"snippet": "DataFrame.pop(item)", "intent": "Return `item` and drop from frame .", "question_id": 34228}
{"snippet": "DataFrame.pow(other)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator pow ) .", "question_id": 34229}
{"snippet": "DataFrame.pow(other, axis='columns')", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator pow ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34230}
{"snippet": "DataFrame.pow(other, level=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator pow ) . Divide by a MultiIndex by `level` .", "question_id": 34231}
{"snippet": "DataFrame.pow(other, fill_value=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator pow ) . Equivalent to dataframe * * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34232}
{"snippet": "DataFrame.pow(other, axis='columns', level=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator pow ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34233}
{"snippet": "DataFrame.pow(other, axis='columns', fill_value=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator pow ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe * * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34234}
{"snippet": "DataFrame.pow(other, level=None, fill_value=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator pow ) . Divide by a MultiIndex by `level` . Equivalent to dataframe * * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34235}
{"snippet": "DataFrame.pow(other, axis='columns', level=None, fill_value=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator pow ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe * * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34236}
{"snippet": "DataFrame.pow(other)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator pow ) .", "question_id": 34237}
{"snippet": "DataFrame.pow(other, axis='columns')", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator pow ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34238}
{"snippet": "DataFrame.pow(other, level=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator pow ) . Divide by a MultiIndex by `level` .", "question_id": 34239}
{"snippet": "DataFrame.pow(other, fill_value=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator pow ) . Equivalent to dataframe * * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34240}
{"snippet": "DataFrame.pow(other, axis='columns', level=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator pow ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34241}
{"snippet": "DataFrame.pow(other, axis='columns', fill_value=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator pow ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe * * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34242}
{"snippet": "DataFrame.pow(other, level=None, fill_value=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator pow ) . Divide by a MultiIndex by `level` . Equivalent to dataframe * * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34243}
{"snippet": "DataFrame.pow(other, axis='columns', level=None, fill_value=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator pow ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe * * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34244}
{"snippet": "DataFrame.pow(other)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator pow ) .", "question_id": 34245}
{"snippet": "DataFrame.pow(other, axis='columns')", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator pow ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34246}
{"snippet": "DataFrame.pow(other, level=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator pow ) . Divide by a MultiIndex by `level` .", "question_id": 34247}
{"snippet": "DataFrame.pow(other, fill_value=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator pow ) . Equivalent to dataframe * * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34248}
{"snippet": "DataFrame.pow(other, axis='columns', level=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator pow ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34249}
{"snippet": "DataFrame.pow(other, axis='columns', fill_value=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator pow ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe * * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34250}
{"snippet": "DataFrame.pow(other, level=None, fill_value=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator pow ) . Divide by a MultiIndex by `level` . Equivalent to dataframe * * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34251}
{"snippet": "DataFrame.pow(other, axis='columns', level=None, fill_value=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator pow ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe * * other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34252}
{"snippet": "DataFrame.prod(**kwargs)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 34253}
{"snippet": "DataFrame.prod(**kwargs, axis=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 34254}
{"snippet": "DataFrame.prod(**kwargs, skipna=None)", "intent": "Return the product of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 34255}
{"snippet": "DataFrame.prod(**kwargs, level=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 34256}
{"snippet": "DataFrame.prod(**kwargs, numeric_only=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 34257}
{"snippet": "DataFrame.prod(**kwargs, min_count=0)", "intent": "Return the product of the values over the requested `axis` . This can be controlled with the `min_count` parameter With arguments `**kwargs`.", "question_id": 34258}
{"snippet": "DataFrame.prod(**kwargs, axis=None, skipna=None)", "intent": "Return the product of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 34259}
{"snippet": "DataFrame.prod(**kwargs, axis=None, level=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 34260}
{"snippet": "DataFrame.prod(**kwargs, axis=None, numeric_only=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 34261}
{"snippet": "DataFrame.prod(**kwargs, axis=None, min_count=0)", "intent": "Return the product of the values over the requested `axis` . This can be controlled with the `min_count` parameter With arguments `**kwargs`.", "question_id": 34262}
{"snippet": "DataFrame.prod(**kwargs)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 34263}
{"snippet": "DataFrame.prod(**kwargs, axis=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 34264}
{"snippet": "DataFrame.prod(**kwargs, skipna=None)", "intent": "Return the product of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 34265}
{"snippet": "DataFrame.prod(**kwargs, level=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 34266}
{"snippet": "DataFrame.prod(**kwargs, numeric_only=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 34267}
{"snippet": "DataFrame.prod(**kwargs, min_count=0)", "intent": "Return the product of the values over the requested `axis` . This can be controlled with the `min_count` parameter With arguments `**kwargs`.", "question_id": 34268}
{"snippet": "DataFrame.prod(**kwargs, axis=None, skipna=None)", "intent": "Return the product of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 34269}
{"snippet": "DataFrame.prod(**kwargs, axis=None, level=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 34270}
{"snippet": "DataFrame.prod(**kwargs, axis=None, numeric_only=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 34271}
{"snippet": "DataFrame.prod(**kwargs, axis=None, min_count=0)", "intent": "Return the product of the values over the requested `axis` . This can be controlled with the `min_count` parameter With arguments `**kwargs`.", "question_id": 34272}
{"snippet": "DataFrame.prod(**kwargs)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 34273}
{"snippet": "DataFrame.prod(**kwargs, axis=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 34274}
{"snippet": "DataFrame.prod(**kwargs, skipna=None)", "intent": "Return the product of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 34275}
{"snippet": "DataFrame.prod(**kwargs, level=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 34276}
{"snippet": "DataFrame.prod(**kwargs, numeric_only=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 34277}
{"snippet": "DataFrame.prod(**kwargs, min_count=0)", "intent": "Return the product of the values over the requested `axis` . This can be controlled with the `min_count` parameter With arguments `**kwargs`.", "question_id": 34278}
{"snippet": "DataFrame.prod(**kwargs, axis=None, skipna=None)", "intent": "Return the product of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 34279}
{"snippet": "DataFrame.prod(**kwargs, axis=None, level=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 34280}
{"snippet": "DataFrame.prod(**kwargs, axis=None, numeric_only=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 34281}
{"snippet": "DataFrame.prod(**kwargs, axis=None, min_count=0)", "intent": "Return the product of the values over the requested `axis` . This can be controlled with the `min_count` parameter With arguments `**kwargs`.", "question_id": 34282}
{"snippet": "DataFrame.product(**kwargs)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 34283}
{"snippet": "DataFrame.product(**kwargs, axis=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 34284}
{"snippet": "DataFrame.product(**kwargs, skipna=None)", "intent": "Return the product of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 34285}
{"snippet": "DataFrame.product(**kwargs, level=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 34286}
{"snippet": "DataFrame.product(**kwargs, numeric_only=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 34287}
{"snippet": "DataFrame.product(**kwargs, min_count=0)", "intent": "Return the product of the values over the requested `axis` . This can be controlled with the `min_count` parameter With arguments `**kwargs`.", "question_id": 34288}
{"snippet": "DataFrame.product(**kwargs, axis=None, skipna=None)", "intent": "Return the product of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 34289}
{"snippet": "DataFrame.product(**kwargs, axis=None, level=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 34290}
{"snippet": "DataFrame.product(**kwargs, axis=None, numeric_only=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 34291}
{"snippet": "DataFrame.product(**kwargs, axis=None, min_count=0)", "intent": "Return the product of the values over the requested `axis` . This can be controlled with the `min_count` parameter With arguments `**kwargs`.", "question_id": 34292}
{"snippet": "DataFrame.product(**kwargs)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 34293}
{"snippet": "DataFrame.product(**kwargs, axis=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 34294}
{"snippet": "DataFrame.product(**kwargs, skipna=None)", "intent": "Return the product of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 34295}
{"snippet": "DataFrame.product(**kwargs, level=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 34296}
{"snippet": "DataFrame.product(**kwargs, numeric_only=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 34297}
{"snippet": "DataFrame.product(**kwargs, min_count=0)", "intent": "Return the product of the values over the requested `axis` . This can be controlled with the `min_count` parameter With arguments `**kwargs`.", "question_id": 34298}
{"snippet": "DataFrame.product(**kwargs, axis=None, skipna=None)", "intent": "Return the product of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 34299}
{"snippet": "DataFrame.product(**kwargs, axis=None, level=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 34300}
{"snippet": "DataFrame.product(**kwargs, axis=None, numeric_only=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 34301}
{"snippet": "DataFrame.product(**kwargs, axis=None, min_count=0)", "intent": "Return the product of the values over the requested `axis` . This can be controlled with the `min_count` parameter With arguments `**kwargs`.", "question_id": 34302}
{"snippet": "DataFrame.product(**kwargs)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 34303}
{"snippet": "DataFrame.product(**kwargs, axis=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 34304}
{"snippet": "DataFrame.product(**kwargs, skipna=None)", "intent": "Return the product of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 34305}
{"snippet": "DataFrame.product(**kwargs, level=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 34306}
{"snippet": "DataFrame.product(**kwargs, numeric_only=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 34307}
{"snippet": "DataFrame.product(**kwargs, min_count=0)", "intent": "Return the product of the values over the requested `axis` . This can be controlled with the `min_count` parameter With arguments `**kwargs`.", "question_id": 34308}
{"snippet": "DataFrame.product(**kwargs, axis=None, skipna=None)", "intent": "Return the product of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 34309}
{"snippet": "DataFrame.product(**kwargs, axis=None, level=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 34310}
{"snippet": "DataFrame.product(**kwargs, axis=None, numeric_only=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 34311}
{"snippet": "DataFrame.product(**kwargs, axis=None, min_count=0)", "intent": "Return the product of the values over the requested `axis` . This can be controlled with the `min_count` parameter With arguments `**kwargs`.", "question_id": 34312}
{"snippet": "DataFrame.quantile()", "intent": "Return values at the given quantile over requested `axis` .", "question_id": 34313}
{"snippet": "DataFrame.quantile(q=0.5)", "intent": "Return values at the given quantile over requested `axis` . With arguments `q`.", "question_id": 34314}
{"snippet": "DataFrame.quantile(axis=0)", "intent": "Return values at the given quantile over requested `axis` .", "question_id": 34315}
{"snippet": "DataFrame.quantile(numeric_only=True)", "intent": "Return values at the given quantile over requested `axis` . With arguments `numeric_only`.", "question_id": 34316}
{"snippet": "DataFrame.quantile(interpolation='linear')", "intent": "Return values at the given quantile over requested `axis` . With arguments `interpolation`.", "question_id": 34317}
{"snippet": "DataFrame.quantile(q=0.5, axis=0)", "intent": "Return values at the given quantile over requested `axis` . With arguments `q`.", "question_id": 34318}
{"snippet": "DataFrame.quantile(q=0.5, numeric_only=True)", "intent": "Return values at the given quantile over requested `axis` . With arguments `q`, `numeric_only`.", "question_id": 34319}
{"snippet": "DataFrame.quantile(q=0.5, interpolation='linear')", "intent": "Return values at the given quantile over requested `axis` . With arguments `q`, `interpolation`.", "question_id": 34320}
{"snippet": "DataFrame.quantile(axis=0, numeric_only=True)", "intent": "Return values at the given quantile over requested `axis` . With arguments `numeric_only`.", "question_id": 34321}
{"snippet": "DataFrame.quantile(axis=0, interpolation='linear')", "intent": "Return values at the given quantile over requested `axis` . With arguments `interpolation`.", "question_id": 34322}
{"snippet": "DataFrame.quantile()", "intent": "Return values at the given quantile over requested `axis` .", "question_id": 34323}
{"snippet": "DataFrame.quantile(q=0.5)", "intent": "Return values at the given quantile over requested `axis` . With arguments `q`.", "question_id": 34324}
{"snippet": "DataFrame.quantile(axis=0)", "intent": "Return values at the given quantile over requested `axis` .", "question_id": 34325}
{"snippet": "DataFrame.quantile(numeric_only=True)", "intent": "Return values at the given quantile over requested `axis` . With arguments `numeric_only`.", "question_id": 34326}
{"snippet": "DataFrame.quantile(interpolation='linear')", "intent": "Return values at the given quantile over requested `axis` . With arguments `interpolation`.", "question_id": 34327}
{"snippet": "DataFrame.quantile(q=0.5, axis=0)", "intent": "Return values at the given quantile over requested `axis` . With arguments `q`.", "question_id": 34328}
{"snippet": "DataFrame.quantile(q=0.5, numeric_only=True)", "intent": "Return values at the given quantile over requested `axis` . With arguments `q`, `numeric_only`.", "question_id": 34329}
{"snippet": "DataFrame.quantile(q=0.5, interpolation='linear')", "intent": "Return values at the given quantile over requested `axis` . With arguments `q`, `interpolation`.", "question_id": 34330}
{"snippet": "DataFrame.quantile(axis=0, numeric_only=True)", "intent": "Return values at the given quantile over requested `axis` . With arguments `numeric_only`.", "question_id": 34331}
{"snippet": "DataFrame.quantile(axis=0, interpolation='linear')", "intent": "Return values at the given quantile over requested `axis` . With arguments `interpolation`.", "question_id": 34332}
{"snippet": "DataFrame.quantile()", "intent": "Return values at the given quantile over requested `axis` .", "question_id": 34333}
{"snippet": "DataFrame.quantile(q=0.5)", "intent": "Return values at the given quantile over requested `axis` . With arguments `q`.", "question_id": 34334}
{"snippet": "DataFrame.quantile(axis=0)", "intent": "Return values at the given quantile over requested `axis` .", "question_id": 34335}
{"snippet": "DataFrame.quantile(numeric_only=True)", "intent": "Return values at the given quantile over requested `axis` . With arguments `numeric_only`.", "question_id": 34336}
{"snippet": "DataFrame.quantile(interpolation='linear')", "intent": "Return values at the given quantile over requested `axis` . With arguments `interpolation`.", "question_id": 34337}
{"snippet": "DataFrame.quantile(q=0.5, axis=0)", "intent": "Return values at the given quantile over requested `axis` . With arguments `q`.", "question_id": 34338}
{"snippet": "DataFrame.quantile(q=0.5, numeric_only=True)", "intent": "Return values at the given quantile over requested `axis` . With arguments `q`, `numeric_only`.", "question_id": 34339}
{"snippet": "DataFrame.quantile(q=0.5, interpolation='linear')", "intent": "Return values at the given quantile over requested `axis` . With arguments `q`, `interpolation`.", "question_id": 34340}
{"snippet": "DataFrame.quantile(axis=0, numeric_only=True)", "intent": "Return values at the given quantile over requested `axis` . With arguments `numeric_only`.", "question_id": 34341}
{"snippet": "DataFrame.quantile(axis=0, interpolation='linear')", "intent": "Return values at the given quantile over requested `axis` . With arguments `interpolation`.", "question_id": 34342}
{"snippet": "DataFrame.query(expr, **kwargs)", "intent": "Query the columns of a DataFrame with a boolean expression . With arguments `expr`, `**kwargs`.", "question_id": 34343}
{"snippet": "DataFrame.query(expr, **kwargs, inplace=False)", "intent": "Query the columns of a DataFrame with a boolean expression . With arguments `expr`, `**kwargs`, `inplace`.", "question_id": 34344}
{"snippet": "DataFrame.query(expr, **kwargs)", "intent": "Query the columns of a DataFrame with a boolean expression . With arguments `expr`, `**kwargs`.", "question_id": 34345}
{"snippet": "DataFrame.query(expr, **kwargs, inplace=False)", "intent": "Query the columns of a DataFrame with a boolean expression . With arguments `expr`, `**kwargs`, `inplace`.", "question_id": 34346}
{"snippet": "DataFrame.query(expr, **kwargs)", "intent": "Query the columns of a DataFrame with a boolean expression . With arguments `expr`, `**kwargs`.", "question_id": 34347}
{"snippet": "DataFrame.query(expr, **kwargs, inplace=False)", "intent": "Query the columns of a DataFrame with a boolean expression . With arguments `expr`, `**kwargs`, `inplace`.", "question_id": 34348}
{"snippet": "DataFrame.radd(other)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator radd ) .", "question_id": 34349}
{"snippet": "DataFrame.radd(other, axis='columns')", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator radd ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34350}
{"snippet": "DataFrame.radd(other, level=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator radd ) . Divide by a MultiIndex by `level` .", "question_id": 34351}
{"snippet": "DataFrame.radd(other, fill_value=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator radd ) . Equivalent to other + dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34352}
{"snippet": "DataFrame.radd(other, axis='columns', level=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator radd ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34353}
{"snippet": "DataFrame.radd(other, axis='columns', fill_value=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator radd ) . Subtract a list and Series by `axis` with operator version . Equivalent to other + dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34354}
{"snippet": "DataFrame.radd(other, level=None, fill_value=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator radd ) . Divide by a MultiIndex by `level` . Equivalent to other + dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34355}
{"snippet": "DataFrame.radd(other, axis='columns', level=None, fill_value=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator radd ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to other + dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34356}
{"snippet": "DataFrame.radd(other)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator radd ) .", "question_id": 34357}
{"snippet": "DataFrame.radd(other, axis='columns')", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator radd ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34358}
{"snippet": "DataFrame.radd(other, level=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator radd ) . Divide by a MultiIndex by `level` .", "question_id": 34359}
{"snippet": "DataFrame.radd(other, fill_value=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator radd ) . Equivalent to other + dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34360}
{"snippet": "DataFrame.radd(other, axis='columns', level=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator radd ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34361}
{"snippet": "DataFrame.radd(other, axis='columns', fill_value=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator radd ) . Subtract a list and Series by `axis` with operator version . Equivalent to other + dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34362}
{"snippet": "DataFrame.radd(other, level=None, fill_value=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator radd ) . Divide by a MultiIndex by `level` . Equivalent to other + dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34363}
{"snippet": "DataFrame.radd(other, axis='columns', level=None, fill_value=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator radd ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to other + dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34364}
{"snippet": "DataFrame.radd(other)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator radd ) .", "question_id": 34365}
{"snippet": "DataFrame.radd(other, axis='columns')", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator radd ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34366}
{"snippet": "DataFrame.radd(other, level=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator radd ) . Divide by a MultiIndex by `level` .", "question_id": 34367}
{"snippet": "DataFrame.radd(other, fill_value=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator radd ) . Equivalent to other + dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34368}
{"snippet": "DataFrame.radd(other, axis='columns', level=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator radd ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34369}
{"snippet": "DataFrame.radd(other, axis='columns', fill_value=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator radd ) . Subtract a list and Series by `axis` with operator version . Equivalent to other + dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34370}
{"snippet": "DataFrame.radd(other, level=None, fill_value=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator radd ) . Divide by a MultiIndex by `level` . Equivalent to other + dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34371}
{"snippet": "DataFrame.radd(other, axis='columns', level=None, fill_value=None)", "intent": "Get Addition of dataframe and `other` , element-wise ( binary operator radd ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to other + dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34372}
{"snippet": "DataFrame.rank()", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` .", "question_id": 34373}
{"snippet": "DataFrame.rank(axis=0)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` .", "question_id": 34374}
{"snippet": "DataFrame.rank(method='average')", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . The following example shows how the `method` behaves with the above parameters :", "question_id": 34375}
{"snippet": "DataFrame.rank(numeric_only=None)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `numeric_only`.", "question_id": 34376}
{"snippet": "DataFrame.rank(na_option='keep')", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `na_option`.", "question_id": 34377}
{"snippet": "DataFrame.rank(ascending=True)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `ascending`.", "question_id": 34378}
{"snippet": "DataFrame.rank(pct=False)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `pct`.", "question_id": 34379}
{"snippet": "DataFrame.rank(axis=0, method='average')", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . The following example shows how the `method` behaves with the above parameters :", "question_id": 34380}
{"snippet": "DataFrame.rank(axis=0, numeric_only=None)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `numeric_only`.", "question_id": 34381}
{"snippet": "DataFrame.rank(axis=0, na_option='keep')", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `na_option`.", "question_id": 34382}
{"snippet": "DataFrame.rank()", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` .", "question_id": 34383}
{"snippet": "DataFrame.rank(axis=0)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` .", "question_id": 34384}
{"snippet": "DataFrame.rank(method='average')", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . The following example shows how the `method` behaves with the above parameters :", "question_id": 34385}
{"snippet": "DataFrame.rank(numeric_only=None)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `numeric_only`.", "question_id": 34386}
{"snippet": "DataFrame.rank(na_option='keep')", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `na_option`.", "question_id": 34387}
{"snippet": "DataFrame.rank(ascending=True)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `ascending`.", "question_id": 34388}
{"snippet": "DataFrame.rank(pct=False)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `pct`.", "question_id": 34389}
{"snippet": "DataFrame.rank(axis=0, method='average')", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . The following example shows how the `method` behaves with the above parameters :", "question_id": 34390}
{"snippet": "DataFrame.rank(axis=0, numeric_only=None)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `numeric_only`.", "question_id": 34391}
{"snippet": "DataFrame.rank(axis=0, na_option='keep')", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `na_option`.", "question_id": 34392}
{"snippet": "DataFrame.rank()", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` .", "question_id": 34393}
{"snippet": "DataFrame.rank(axis=0)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` .", "question_id": 34394}
{"snippet": "DataFrame.rank(method='average')", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . The following example shows how the `method` behaves with the above parameters :", "question_id": 34395}
{"snippet": "DataFrame.rank(numeric_only=None)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `numeric_only`.", "question_id": 34396}
{"snippet": "DataFrame.rank(na_option='keep')", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `na_option`.", "question_id": 34397}
{"snippet": "DataFrame.rank(ascending=True)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `ascending`.", "question_id": 34398}
{"snippet": "DataFrame.rank(pct=False)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `pct`.", "question_id": 34399}
{"snippet": "DataFrame.rank(axis=0, method='average')", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . The following example shows how the `method` behaves with the above parameters :", "question_id": 34400}
{"snippet": "DataFrame.rank(axis=0, numeric_only=None)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `numeric_only`.", "question_id": 34401}
{"snippet": "DataFrame.rank(axis=0, na_option='keep')", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `na_option`.", "question_id": 34402}
{"snippet": "DataFrame.rdiv(other)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) .", "question_id": 34403}
{"snippet": "DataFrame.rdiv(other, axis='columns')", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34404}
{"snippet": "DataFrame.rdiv(other, level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Divide by a MultiIndex by `level` .", "question_id": 34405}
{"snippet": "DataFrame.rdiv(other, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34406}
{"snippet": "DataFrame.rdiv(other, axis='columns', level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34407}
{"snippet": "DataFrame.rdiv(other, axis='columns', fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Subtract a list and Series by `axis` with operator version . Equivalent to other / dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34408}
{"snippet": "DataFrame.rdiv(other, level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Divide by a MultiIndex by `level` . Equivalent to other / dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34409}
{"snippet": "DataFrame.rdiv(other, axis='columns', level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to other / dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34410}
{"snippet": "DataFrame.rdiv(other)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) .", "question_id": 34411}
{"snippet": "DataFrame.rdiv(other, axis='columns')", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34412}
{"snippet": "DataFrame.rdiv(other, level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Divide by a MultiIndex by `level` .", "question_id": 34413}
{"snippet": "DataFrame.rdiv(other, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34414}
{"snippet": "DataFrame.rdiv(other, axis='columns', level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34415}
{"snippet": "DataFrame.rdiv(other, axis='columns', fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Subtract a list and Series by `axis` with operator version . Equivalent to other / dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34416}
{"snippet": "DataFrame.rdiv(other, level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Divide by a MultiIndex by `level` . Equivalent to other / dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34417}
{"snippet": "DataFrame.rdiv(other, axis='columns', level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to other / dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34418}
{"snippet": "DataFrame.rdiv(other)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) .", "question_id": 34419}
{"snippet": "DataFrame.rdiv(other, axis='columns')", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34420}
{"snippet": "DataFrame.rdiv(other, level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Divide by a MultiIndex by `level` .", "question_id": 34421}
{"snippet": "DataFrame.rdiv(other, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34422}
{"snippet": "DataFrame.rdiv(other, axis='columns', level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34423}
{"snippet": "DataFrame.rdiv(other, axis='columns', fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Subtract a list and Series by `axis` with operator version . Equivalent to other / dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34424}
{"snippet": "DataFrame.rdiv(other, level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Divide by a MultiIndex by `level` . Equivalent to other / dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34425}
{"snippet": "DataFrame.rdiv(other, axis='columns', level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to other / dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34426}
{"snippet": "DataFrame.reindex()", "intent": "Conform Series/DataFrame to new `index` with optional filling logic .", "question_id": 34427}
{"snippet": "DataFrame.reindex(labels=None)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic . With arguments `labels`.", "question_id": 34428}
{"snippet": "DataFrame.reindex(index=None)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic .", "question_id": 34429}
{"snippet": "DataFrame.reindex(columns=None)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic . We can also reindex the `columns` .", "question_id": 34430}
{"snippet": "DataFrame.reindex(axis=None)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic . With arguments `axis`.", "question_id": 34431}
{"snippet": "DataFrame.reindex(method=None)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic . Because the index is not monotonically increasing or decreasing , we can not use arguments to the keyword `method` to fill the NaN values .", "question_id": 34432}
{"snippet": "DataFrame.reindex(copy=True)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic . With arguments `copy`.", "question_id": 34433}
{"snippet": "DataFrame.reindex(level=None)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic . With arguments `level`.", "question_id": 34434}
{"snippet": "DataFrame.reindex(fill_value=nan)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic . We can fill in the missing values by passing a value to the keyword `fill_value` .", "question_id": 34435}
{"snippet": "DataFrame.reindex(limit=None)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic . With arguments `limit`.", "question_id": 34436}
{"snippet": "DataFrame.reindex()", "intent": "Conform Series/DataFrame to new `index` with optional filling logic .", "question_id": 34437}
{"snippet": "DataFrame.reindex(labels=None)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic . With arguments `labels`.", "question_id": 34438}
{"snippet": "DataFrame.reindex(index=None)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic .", "question_id": 34439}
{"snippet": "DataFrame.reindex(columns=None)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic . We can also reindex the `columns` .", "question_id": 34440}
{"snippet": "DataFrame.reindex(axis=None)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic . With arguments `axis`.", "question_id": 34441}
{"snippet": "DataFrame.reindex(method=None)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic . Because the index is not monotonically increasing or decreasing , we can not use arguments to the keyword `method` to fill the NaN values .", "question_id": 34442}
{"snippet": "DataFrame.reindex(copy=True)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic . With arguments `copy`.", "question_id": 34443}
{"snippet": "DataFrame.reindex(level=None)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic . With arguments `level`.", "question_id": 34444}
{"snippet": "DataFrame.reindex(fill_value=nan)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic . We can fill in the missing values by passing a value to the keyword `fill_value` .", "question_id": 34445}
{"snippet": "DataFrame.reindex(limit=None)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic . With arguments `limit`.", "question_id": 34446}
{"snippet": "DataFrame.reindex()", "intent": "Conform Series/DataFrame to new `index` with optional filling logic .", "question_id": 34447}
{"snippet": "DataFrame.reindex(labels=None)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic . With arguments `labels`.", "question_id": 34448}
{"snippet": "DataFrame.reindex(index=None)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic .", "question_id": 34449}
{"snippet": "DataFrame.reindex(columns=None)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic . We can also reindex the `columns` .", "question_id": 34450}
{"snippet": "DataFrame.reindex(axis=None)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic . With arguments `axis`.", "question_id": 34451}
{"snippet": "DataFrame.reindex(method=None)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic . Because the index is not monotonically increasing or decreasing , we can not use arguments to the keyword `method` to fill the NaN values .", "question_id": 34452}
{"snippet": "DataFrame.reindex(copy=True)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic . With arguments `copy`.", "question_id": 34453}
{"snippet": "DataFrame.reindex(level=None)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic . With arguments `level`.", "question_id": 34454}
{"snippet": "DataFrame.reindex(fill_value=nan)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic . We can fill in the missing values by passing a value to the keyword `fill_value` .", "question_id": 34455}
{"snippet": "DataFrame.reindex(limit=None)", "intent": "Conform Series/DataFrame to new `index` with optional filling logic . With arguments `limit`.", "question_id": 34456}
{"snippet": "DataFrame.reindex_like(other)", "intent": "Return an object with matching indices as `other` object .", "question_id": 34457}
{"snippet": "DataFrame.reindex_like(other, method=None)", "intent": "Return an object with matching indices as `other` object . With arguments `method`.", "question_id": 34458}
{"snippet": "DataFrame.reindex_like(other, copy=True)", "intent": "Return an object with matching indices as `other` object . With arguments `copy`.", "question_id": 34459}
{"snippet": "DataFrame.reindex_like(other, limit=None)", "intent": "Return an object with matching indices as `other` object . With arguments `limit`.", "question_id": 34460}
{"snippet": "DataFrame.reindex_like(other, tolerance=None)", "intent": "Return an object with matching indices as `other` object . With arguments `tolerance`.", "question_id": 34461}
{"snippet": "DataFrame.reindex_like(other, method=None, copy=True)", "intent": "Return an object with matching indices as `other` object . With arguments `method`, `copy`.", "question_id": 34462}
{"snippet": "DataFrame.reindex_like(other, method=None, limit=None)", "intent": "Return an object with matching indices as `other` object . With arguments `method`, `limit`.", "question_id": 34463}
{"snippet": "DataFrame.reindex_like(other, method=None, tolerance=None)", "intent": "Return an object with matching indices as `other` object . With arguments `method`, `tolerance`.", "question_id": 34464}
{"snippet": "DataFrame.reindex_like(other, copy=True, limit=None)", "intent": "Return an object with matching indices as `other` object . With arguments `copy`, `limit`.", "question_id": 34465}
{"snippet": "DataFrame.reindex_like(other, copy=True, tolerance=None)", "intent": "Return an object with matching indices as `other` object . With arguments `copy`, `tolerance`.", "question_id": 34466}
{"snippet": "DataFrame.reindex_like(other)", "intent": "Return an object with matching indices as `other` object .", "question_id": 34467}
{"snippet": "DataFrame.reindex_like(other, method=None)", "intent": "Return an object with matching indices as `other` object . With arguments `method`.", "question_id": 34468}
{"snippet": "DataFrame.reindex_like(other, copy=True)", "intent": "Return an object with matching indices as `other` object . With arguments `copy`.", "question_id": 34469}
{"snippet": "DataFrame.reindex_like(other, limit=None)", "intent": "Return an object with matching indices as `other` object . With arguments `limit`.", "question_id": 34470}
{"snippet": "DataFrame.reindex_like(other, tolerance=None)", "intent": "Return an object with matching indices as `other` object . With arguments `tolerance`.", "question_id": 34471}
{"snippet": "DataFrame.reindex_like(other, method=None, copy=True)", "intent": "Return an object with matching indices as `other` object . With arguments `method`, `copy`.", "question_id": 34472}
{"snippet": "DataFrame.reindex_like(other, method=None, limit=None)", "intent": "Return an object with matching indices as `other` object . With arguments `method`, `limit`.", "question_id": 34473}
{"snippet": "DataFrame.reindex_like(other, method=None, tolerance=None)", "intent": "Return an object with matching indices as `other` object . With arguments `method`, `tolerance`.", "question_id": 34474}
{"snippet": "DataFrame.reindex_like(other, copy=True, limit=None)", "intent": "Return an object with matching indices as `other` object . With arguments `copy`, `limit`.", "question_id": 34475}
{"snippet": "DataFrame.reindex_like(other, copy=True, tolerance=None)", "intent": "Return an object with matching indices as `other` object . With arguments `copy`, `tolerance`.", "question_id": 34476}
{"snippet": "DataFrame.reindex_like(other)", "intent": "Return an object with matching indices as `other` object .", "question_id": 34477}
{"snippet": "DataFrame.reindex_like(other, method=None)", "intent": "Return an object with matching indices as `other` object . With arguments `method`.", "question_id": 34478}
{"snippet": "DataFrame.reindex_like(other, copy=True)", "intent": "Return an object with matching indices as `other` object . With arguments `copy`.", "question_id": 34479}
{"snippet": "DataFrame.reindex_like(other, limit=None)", "intent": "Return an object with matching indices as `other` object . With arguments `limit`.", "question_id": 34480}
{"snippet": "DataFrame.reindex_like(other, tolerance=None)", "intent": "Return an object with matching indices as `other` object . With arguments `tolerance`.", "question_id": 34481}
{"snippet": "DataFrame.reindex_like(other, method=None, copy=True)", "intent": "Return an object with matching indices as `other` object . With arguments `method`, `copy`.", "question_id": 34482}
{"snippet": "DataFrame.reindex_like(other, method=None, limit=None)", "intent": "Return an object with matching indices as `other` object . With arguments `method`, `limit`.", "question_id": 34483}
{"snippet": "DataFrame.reindex_like(other, method=None, tolerance=None)", "intent": "Return an object with matching indices as `other` object . With arguments `method`, `tolerance`.", "question_id": 34484}
{"snippet": "DataFrame.reindex_like(other, copy=True, limit=None)", "intent": "Return an object with matching indices as `other` object . With arguments `copy`, `limit`.", "question_id": 34485}
{"snippet": "DataFrame.reindex_like(other, copy=True, tolerance=None)", "intent": "Return an object with matching indices as `other` object . With arguments `copy`, `tolerance`.", "question_id": 34486}
{"snippet": "DataFrame.rename()", "intent": "Alter axes labels .", "question_id": 34487}
{"snippet": "DataFrame.rename(mapper=None)", "intent": "Alter axes labels . With arguments `mapper`.", "question_id": 34488}
{"snippet": "DataFrame.rename(index=None)", "intent": "Alter axes labels . Rename `index` using a mapping :", "question_id": 34489}
{"snippet": "DataFrame.rename(columns=None)", "intent": "Alter axes labels . Rename `columns` using a mapping :", "question_id": 34490}
{"snippet": "DataFrame.rename(axis=None)", "intent": "Alter axes labels . With arguments `axis`.", "question_id": 34491}
{"snippet": "DataFrame.rename(copy=True)", "intent": "Alter axes labels . With arguments `copy`.", "question_id": 34492}
{"snippet": "DataFrame.rename(inplace=False)", "intent": "Alter axes labels . With arguments `inplace`.", "question_id": 34493}
{"snippet": "DataFrame.rename(level=None)", "intent": "Alter axes labels . With arguments `level`.", "question_id": 34494}
{"snippet": "DataFrame.rename(errors='ignore')", "intent": "Alter axes labels . With arguments `errors`.", "question_id": 34495}
{"snippet": "DataFrame.rename(mapper=None, index=None)", "intent": "Alter axes labels . Rename `index` using a mapping : With arguments `mapper`.", "question_id": 34496}
{"snippet": "DataFrame.rename()", "intent": "Alter axes labels .", "question_id": 34497}
{"snippet": "DataFrame.rename(mapper=None)", "intent": "Alter axes labels . With arguments `mapper`.", "question_id": 34498}
{"snippet": "DataFrame.rename(index=None)", "intent": "Alter axes labels . Rename `index` using a mapping :", "question_id": 34499}
{"snippet": "DataFrame.rename(columns=None)", "intent": "Alter axes labels . Rename `columns` using a mapping :", "question_id": 34500}
{"snippet": "DataFrame.rename(axis=None)", "intent": "Alter axes labels . With arguments `axis`.", "question_id": 34501}
{"snippet": "DataFrame.rename(copy=True)", "intent": "Alter axes labels . With arguments `copy`.", "question_id": 34502}
{"snippet": "DataFrame.rename(inplace=False)", "intent": "Alter axes labels . With arguments `inplace`.", "question_id": 34503}
{"snippet": "DataFrame.rename(level=None)", "intent": "Alter axes labels . With arguments `level`.", "question_id": 34504}
{"snippet": "DataFrame.rename(errors='ignore')", "intent": "Alter axes labels . With arguments `errors`.", "question_id": 34505}
{"snippet": "DataFrame.rename(mapper=None, index=None)", "intent": "Alter axes labels . Rename `index` using a mapping : With arguments `mapper`.", "question_id": 34506}
{"snippet": "DataFrame.rename()", "intent": "Alter axes labels .", "question_id": 34507}
{"snippet": "DataFrame.rename(mapper=None)", "intent": "Alter axes labels . With arguments `mapper`.", "question_id": 34508}
{"snippet": "DataFrame.rename(index=None)", "intent": "Alter axes labels . Rename `index` using a mapping :", "question_id": 34509}
{"snippet": "DataFrame.rename(columns=None)", "intent": "Alter axes labels . Rename `columns` using a mapping :", "question_id": 34510}
{"snippet": "DataFrame.rename(axis=None)", "intent": "Alter axes labels . With arguments `axis`.", "question_id": 34511}
{"snippet": "DataFrame.rename(copy=True)", "intent": "Alter axes labels . With arguments `copy`.", "question_id": 34512}
{"snippet": "DataFrame.rename(inplace=False)", "intent": "Alter axes labels . With arguments `inplace`.", "question_id": 34513}
{"snippet": "DataFrame.rename(level=None)", "intent": "Alter axes labels . With arguments `level`.", "question_id": 34514}
{"snippet": "DataFrame.rename(errors='ignore')", "intent": "Alter axes labels . With arguments `errors`.", "question_id": 34515}
{"snippet": "DataFrame.rename(mapper=None, index=None)", "intent": "Alter axes labels . Rename `index` using a mapping : With arguments `mapper`.", "question_id": 34516}
{"snippet": "DataFrame.rename_axis()", "intent": "Set the name of the `axis` for the `index` or `columns` .", "question_id": 34517}
{"snippet": "DataFrame.rename_axis(mapper=None)", "intent": "Set the name of the `axis` for the `index` or `columns` . The second calling convention will modify the names of the corresponding index if `mapper` is a list or a scalar .", "question_id": 34518}
{"snippet": "DataFrame.rename_axis(index=None)", "intent": "Set the name of the `axis` for the `index` or `columns` .", "question_id": 34519}
{"snippet": "DataFrame.rename_axis(columns=None)", "intent": "Set the name of the `axis` for the `index` or `columns` .", "question_id": 34520}
{"snippet": "DataFrame.rename_axis(axis=None)", "intent": "Set the name of the `axis` for the `index` or `columns` .", "question_id": 34521}
{"snippet": "DataFrame.rename_axis(copy=True)", "intent": "Set the name of the `axis` for the `index` or `columns` . In this case , the parameter `copy` is ignored .", "question_id": 34522}
{"snippet": "DataFrame.rename_axis(inplace=False)", "intent": "Set the name of the `axis` for the `index` or `columns` . With arguments `inplace`.", "question_id": 34523}
{"snippet": "DataFrame.rename_axis(mapper=None, index=None)", "intent": "Set the name of the `axis` for the `index` or `columns` . The second calling convention will modify the names of the corresponding index if `mapper` is a list or a scalar .", "question_id": 34524}
{"snippet": "DataFrame.rename_axis(mapper=None, columns=None)", "intent": "Set the name of the `axis` for the `index` or `columns` . The second calling convention will modify the names of the corresponding index if `mapper` is a list or a scalar .", "question_id": 34525}
{"snippet": "DataFrame.rename_axis(mapper=None, axis=None)", "intent": "Set the name of the `axis` for the `index` or `columns` . The second calling convention will modify the names of the corresponding index if `mapper` is a list or a scalar .", "question_id": 34526}
{"snippet": "DataFrame.rename_axis()", "intent": "Set the name of the `axis` for the `index` or `columns` .", "question_id": 34527}
{"snippet": "DataFrame.rename_axis(mapper=None)", "intent": "Set the name of the `axis` for the `index` or `columns` . The second calling convention will modify the names of the corresponding index if `mapper` is a list or a scalar .", "question_id": 34528}
{"snippet": "DataFrame.rename_axis(index=None)", "intent": "Set the name of the `axis` for the `index` or `columns` .", "question_id": 34529}
{"snippet": "DataFrame.rename_axis(columns=None)", "intent": "Set the name of the `axis` for the `index` or `columns` .", "question_id": 34530}
{"snippet": "DataFrame.rename_axis(axis=None)", "intent": "Set the name of the `axis` for the `index` or `columns` .", "question_id": 34531}
{"snippet": "DataFrame.rename_axis(copy=True)", "intent": "Set the name of the `axis` for the `index` or `columns` . In this case , the parameter `copy` is ignored .", "question_id": 34532}
{"snippet": "DataFrame.rename_axis(inplace=False)", "intent": "Set the name of the `axis` for the `index` or `columns` . With arguments `inplace`.", "question_id": 34533}
{"snippet": "DataFrame.rename_axis(mapper=None, index=None)", "intent": "Set the name of the `axis` for the `index` or `columns` . The second calling convention will modify the names of the corresponding index if `mapper` is a list or a scalar .", "question_id": 34534}
{"snippet": "DataFrame.rename_axis(mapper=None, columns=None)", "intent": "Set the name of the `axis` for the `index` or `columns` . The second calling convention will modify the names of the corresponding index if `mapper` is a list or a scalar .", "question_id": 34535}
{"snippet": "DataFrame.rename_axis(mapper=None, axis=None)", "intent": "Set the name of the `axis` for the `index` or `columns` . The second calling convention will modify the names of the corresponding index if `mapper` is a list or a scalar .", "question_id": 34536}
{"snippet": "DataFrame.rename_axis()", "intent": "Set the name of the `axis` for the `index` or `columns` .", "question_id": 34537}
{"snippet": "DataFrame.rename_axis(mapper=None)", "intent": "Set the name of the `axis` for the `index` or `columns` . The second calling convention will modify the names of the corresponding index if `mapper` is a list or a scalar .", "question_id": 34538}
{"snippet": "DataFrame.rename_axis(index=None)", "intent": "Set the name of the `axis` for the `index` or `columns` .", "question_id": 34539}
{"snippet": "DataFrame.rename_axis(columns=None)", "intent": "Set the name of the `axis` for the `index` or `columns` .", "question_id": 34540}
{"snippet": "DataFrame.rename_axis(axis=None)", "intent": "Set the name of the `axis` for the `index` or `columns` .", "question_id": 34541}
{"snippet": "DataFrame.rename_axis(copy=True)", "intent": "Set the name of the `axis` for the `index` or `columns` . In this case , the parameter `copy` is ignored .", "question_id": 34542}
{"snippet": "DataFrame.rename_axis(inplace=False)", "intent": "Set the name of the `axis` for the `index` or `columns` . With arguments `inplace`.", "question_id": 34543}
{"snippet": "DataFrame.rename_axis(mapper=None, index=None)", "intent": "Set the name of the `axis` for the `index` or `columns` . The second calling convention will modify the names of the corresponding index if `mapper` is a list or a scalar .", "question_id": 34544}
{"snippet": "DataFrame.rename_axis(mapper=None, columns=None)", "intent": "Set the name of the `axis` for the `index` or `columns` . The second calling convention will modify the names of the corresponding index if `mapper` is a list or a scalar .", "question_id": 34545}
{"snippet": "DataFrame.rename_axis(mapper=None, axis=None)", "intent": "Set the name of the `axis` for the `index` or `columns` . The second calling convention will modify the names of the corresponding index if `mapper` is a list or a scalar .", "question_id": 34546}
{"snippet": "DataFrame.reorder_levels(order)", "intent": "Rearrange index levels using input `order` .", "question_id": 34547}
{"snippet": "DataFrame.reorder_levels(order, axis=0)", "intent": "Rearrange index levels using input `order` . With arguments `axis`.", "question_id": 34548}
{"snippet": "DataFrame.reorder_levels(order)", "intent": "Rearrange index levels using input `order` .", "question_id": 34549}
{"snippet": "DataFrame.reorder_levels(order, axis=0)", "intent": "Rearrange index levels using input `order` . With arguments `axis`.", "question_id": 34550}
{"snippet": "DataFrame.reorder_levels(order)", "intent": "Rearrange index levels using input `order` .", "question_id": 34551}
{"snippet": "DataFrame.reorder_levels(order, axis=0)", "intent": "Rearrange index levels using input `order` . With arguments `axis`.", "question_id": 34552}
{"snippet": "DataFrame.replace()", "intent": "Replace values given in `to_replace` with `value` .", "question_id": 34553}
{"snippet": "DataFrame.replace(to_replace=None)", "intent": "Replace values given in `to_replace` with `value` .", "question_id": 34554}
{"snippet": "DataFrame.replace(value=None)", "intent": "Replace values given in `to_replace` with `value` .", "question_id": 34555}
{"snippet": "DataFrame.replace(inplace=False)", "intent": "Replace values given in `to_replace` with `value` . With arguments `inplace`.", "question_id": 34556}
{"snippet": "DataFrame.replace(limit=None)", "intent": "Replace values given in `to_replace` with `value` . With arguments `limit`.", "question_id": 34557}
{"snippet": "DataFrame.replace(regex=False)", "intent": "Replace values given in `to_replace` with `value` . With arguments `regex`.", "question_id": 34558}
{"snippet": "DataFrame.replace(method='pad')", "intent": "Replace values given in `to_replace` with `value` . When value=None and to_replace is a scalar , list or tuple , replace uses the `method` parameter ( default \u2018 pad \u2019 ) to do the replacement .", "question_id": 34559}
{"snippet": "DataFrame.replace(to_replace=None, value=None)", "intent": "Replace values given in `to_replace` with `value` .", "question_id": 34560}
{"snippet": "DataFrame.replace(to_replace=None, inplace=False)", "intent": "Replace values given in `to_replace` with `value` . With arguments `inplace`.", "question_id": 34561}
{"snippet": "DataFrame.replace(to_replace=None, limit=None)", "intent": "Replace values given in `to_replace` with `value` . With arguments `limit`.", "question_id": 34562}
{"snippet": "DataFrame.replace()", "intent": "Replace values given in `to_replace` with `value` .", "question_id": 34563}
{"snippet": "DataFrame.replace(to_replace=None)", "intent": "Replace values given in `to_replace` with `value` .", "question_id": 34564}
{"snippet": "DataFrame.replace(value=None)", "intent": "Replace values given in `to_replace` with `value` .", "question_id": 34565}
{"snippet": "DataFrame.replace(inplace=False)", "intent": "Replace values given in `to_replace` with `value` . With arguments `inplace`.", "question_id": 34566}
{"snippet": "DataFrame.replace(limit=None)", "intent": "Replace values given in `to_replace` with `value` . With arguments `limit`.", "question_id": 34567}
{"snippet": "DataFrame.replace(regex=False)", "intent": "Replace values given in `to_replace` with `value` . With arguments `regex`.", "question_id": 34568}
{"snippet": "DataFrame.replace(method='pad')", "intent": "Replace values given in `to_replace` with `value` . When value=None and to_replace is a scalar , list or tuple , replace uses the `method` parameter ( default \u2018 pad \u2019 ) to do the replacement .", "question_id": 34569}
{"snippet": "DataFrame.replace(to_replace=None, value=None)", "intent": "Replace values given in `to_replace` with `value` .", "question_id": 34570}
{"snippet": "DataFrame.replace(to_replace=None, inplace=False)", "intent": "Replace values given in `to_replace` with `value` . With arguments `inplace`.", "question_id": 34571}
{"snippet": "DataFrame.replace(to_replace=None, limit=None)", "intent": "Replace values given in `to_replace` with `value` . With arguments `limit`.", "question_id": 34572}
{"snippet": "DataFrame.replace()", "intent": "Replace values given in `to_replace` with `value` .", "question_id": 34573}
{"snippet": "DataFrame.replace(to_replace=None)", "intent": "Replace values given in `to_replace` with `value` .", "question_id": 34574}
{"snippet": "DataFrame.replace(value=None)", "intent": "Replace values given in `to_replace` with `value` .", "question_id": 34575}
{"snippet": "DataFrame.replace(inplace=False)", "intent": "Replace values given in `to_replace` with `value` . With arguments `inplace`.", "question_id": 34576}
{"snippet": "DataFrame.replace(limit=None)", "intent": "Replace values given in `to_replace` with `value` . With arguments `limit`.", "question_id": 34577}
{"snippet": "DataFrame.replace(regex=False)", "intent": "Replace values given in `to_replace` with `value` . With arguments `regex`.", "question_id": 34578}
{"snippet": "DataFrame.replace(method='pad')", "intent": "Replace values given in `to_replace` with `value` . When value=None and to_replace is a scalar , list or tuple , replace uses the `method` parameter ( default \u2018 pad \u2019 ) to do the replacement .", "question_id": 34579}
{"snippet": "DataFrame.replace(to_replace=None, value=None)", "intent": "Replace values given in `to_replace` with `value` .", "question_id": 34580}
{"snippet": "DataFrame.replace(to_replace=None, inplace=False)", "intent": "Replace values given in `to_replace` with `value` . With arguments `inplace`.", "question_id": 34581}
{"snippet": "DataFrame.replace(to_replace=None, limit=None)", "intent": "Replace values given in `to_replace` with `value` . With arguments `limit`.", "question_id": 34582}
{"snippet": "DataFrame.resample(rule)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` .", "question_id": 34583}
{"snippet": "DataFrame.resample(rule, axis=0)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . With arguments `axis`.", "question_id": 34584}
{"snippet": "DataFrame.resample(rule, closed=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . With arguments `closed`.", "question_id": 34585}
{"snippet": "DataFrame.resample(rule, label=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . The object must have a datetime-like index ( DatetimeIndex , PeriodIndex , or TimedeltaIndex ) , or the caller must pass the `label` of a datetime-like series/index to the on/level keyword parameter .", "question_id": 34586}
{"snippet": "DataFrame.resample(rule, convention='start')", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` .", "question_id": 34587}
{"snippet": "DataFrame.resample(rule, kind=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . With arguments `kind`.", "question_id": 34588}
{"snippet": "DataFrame.resample(rule, loffset=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . To replace the use of the deprecated `loffset` argument :", "question_id": 34589}
{"snippet": "DataFrame.resample(rule, base=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . To replace the use of the deprecated `base` argument , you can now use offset , in this example it is equivalent to have base=2 :", "question_id": 34590}
{"snippet": "DataFrame.resample(rule, on=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . For DataFrame objects , the keyword `on` can be used to specify the column instead of the index for resampling .", "question_id": 34591}
{"snippet": "DataFrame.resample(rule, level=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . For a DataFrame with MultiIndex , the keyword `level` can be used to specify on which level the resampling needs to take place .", "question_id": 34592}
{"snippet": "DataFrame.resample(rule)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` .", "question_id": 34593}
{"snippet": "DataFrame.resample(rule, axis=0)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . With arguments `axis`.", "question_id": 34594}
{"snippet": "DataFrame.resample(rule, closed=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . With arguments `closed`.", "question_id": 34595}
{"snippet": "DataFrame.resample(rule, label=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . The object must have a datetime-like index ( DatetimeIndex , PeriodIndex , or TimedeltaIndex ) , or the caller must pass the `label` of a datetime-like series/index to the on/level keyword parameter .", "question_id": 34596}
{"snippet": "DataFrame.resample(rule, convention='start')", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` .", "question_id": 34597}
{"snippet": "DataFrame.resample(rule, kind=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . With arguments `kind`.", "question_id": 34598}
{"snippet": "DataFrame.resample(rule, loffset=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . To replace the use of the deprecated `loffset` argument :", "question_id": 34599}
{"snippet": "DataFrame.resample(rule, base=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . To replace the use of the deprecated `base` argument , you can now use offset , in this example it is equivalent to have base=2 :", "question_id": 34600}
{"snippet": "DataFrame.resample(rule, on=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . For DataFrame objects , the keyword `on` can be used to specify the column instead of the index for resampling .", "question_id": 34601}
{"snippet": "DataFrame.resample(rule, level=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . For a DataFrame with MultiIndex , the keyword `level` can be used to specify on which level the resampling needs to take place .", "question_id": 34602}
{"snippet": "DataFrame.resample(rule)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` .", "question_id": 34603}
{"snippet": "DataFrame.resample(rule, axis=0)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . With arguments `axis`.", "question_id": 34604}
{"snippet": "DataFrame.resample(rule, closed=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . With arguments `closed`.", "question_id": 34605}
{"snippet": "DataFrame.resample(rule, label=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . The object must have a datetime-like index ( DatetimeIndex , PeriodIndex , or TimedeltaIndex ) , or the caller must pass the `label` of a datetime-like series/index to the on/level keyword parameter .", "question_id": 34606}
{"snippet": "DataFrame.resample(rule, convention='start')", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` .", "question_id": 34607}
{"snippet": "DataFrame.resample(rule, kind=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . With arguments `kind`.", "question_id": 34608}
{"snippet": "DataFrame.resample(rule, loffset=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . To replace the use of the deprecated `loffset` argument :", "question_id": 34609}
{"snippet": "DataFrame.resample(rule, base=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . To replace the use of the deprecated `base` argument , you can now use offset , in this example it is equivalent to have base=2 :", "question_id": 34610}
{"snippet": "DataFrame.resample(rule, on=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . For DataFrame objects , the keyword `on` can be used to specify the column instead of the index for resampling .", "question_id": 34611}
{"snippet": "DataFrame.resample(rule, level=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . For a DataFrame with MultiIndex , the keyword `level` can be used to specify on which level the resampling needs to take place .", "question_id": 34612}
{"snippet": "DataFrame.reset_index()", "intent": "Reset the index , or a `level` of it .", "question_id": 34613}
{"snippet": "DataFrame.reset_index(level=None)", "intent": "Reset the index , or a `level` of it .", "question_id": 34614}
{"snippet": "DataFrame.reset_index(drop=False)", "intent": "Reset the index , or a `level` of it . We can use the `drop` parameter to avoid the old index being added as a column :", "question_id": 34615}
{"snippet": "DataFrame.reset_index(inplace=False)", "intent": "Reset the index , or a `level` of it . With arguments `inplace`.", "question_id": 34616}
{"snippet": "DataFrame.reset_index(col_level=0)", "intent": "Reset the index , or a `level` of it . With arguments `col_level`.", "question_id": 34617}
{"snippet": "DataFrame.reset_index(col_fill='')", "intent": "Reset the index , or a `level` of it . When the index is inserted under another level , we can specify under which one with the parameter `col_fill` :", "question_id": 34618}
{"snippet": "DataFrame.reset_index(level=None, drop=False)", "intent": "Reset the index , or a `level` of it . We can use the `drop` parameter to avoid the old index being added as a column :", "question_id": 34619}
{"snippet": "DataFrame.reset_index(level=None, inplace=False)", "intent": "Reset the index , or a `level` of it . With arguments `inplace`.", "question_id": 34620}
{"snippet": "DataFrame.reset_index(level=None, col_level=0)", "intent": "Reset the index , or a `level` of it . With arguments `col_level`.", "question_id": 34621}
{"snippet": "DataFrame.reset_index(level=None, col_fill='')", "intent": "Reset the index , or a `level` of it . When the index is inserted under another level , we can specify under which one with the parameter `col_fill` :", "question_id": 34622}
{"snippet": "DataFrame.reset_index()", "intent": "Reset the index , or a `level` of it .", "question_id": 34623}
{"snippet": "DataFrame.reset_index(level=None)", "intent": "Reset the index , or a `level` of it .", "question_id": 34624}
{"snippet": "DataFrame.reset_index(drop=False)", "intent": "Reset the index , or a `level` of it . We can use the `drop` parameter to avoid the old index being added as a column :", "question_id": 34625}
{"snippet": "DataFrame.reset_index(inplace=False)", "intent": "Reset the index , or a `level` of it . With arguments `inplace`.", "question_id": 34626}
{"snippet": "DataFrame.reset_index(col_level=0)", "intent": "Reset the index , or a `level` of it . With arguments `col_level`.", "question_id": 34627}
{"snippet": "DataFrame.reset_index(col_fill='')", "intent": "Reset the index , or a `level` of it . When the index is inserted under another level , we can specify under which one with the parameter `col_fill` :", "question_id": 34628}
{"snippet": "DataFrame.reset_index(level=None, drop=False)", "intent": "Reset the index , or a `level` of it . We can use the `drop` parameter to avoid the old index being added as a column :", "question_id": 34629}
{"snippet": "DataFrame.reset_index(level=None, inplace=False)", "intent": "Reset the index , or a `level` of it . With arguments `inplace`.", "question_id": 34630}
{"snippet": "DataFrame.reset_index(level=None, col_level=0)", "intent": "Reset the index , or a `level` of it . With arguments `col_level`.", "question_id": 34631}
{"snippet": "DataFrame.reset_index(level=None, col_fill='')", "intent": "Reset the index , or a `level` of it . When the index is inserted under another level , we can specify under which one with the parameter `col_fill` :", "question_id": 34632}
{"snippet": "DataFrame.reset_index()", "intent": "Reset the index , or a `level` of it .", "question_id": 34633}
{"snippet": "DataFrame.reset_index(level=None)", "intent": "Reset the index , or a `level` of it .", "question_id": 34634}
{"snippet": "DataFrame.reset_index(drop=False)", "intent": "Reset the index , or a `level` of it . We can use the `drop` parameter to avoid the old index being added as a column :", "question_id": 34635}
{"snippet": "DataFrame.reset_index(inplace=False)", "intent": "Reset the index , or a `level` of it . With arguments `inplace`.", "question_id": 34636}
{"snippet": "DataFrame.reset_index(col_level=0)", "intent": "Reset the index , or a `level` of it . With arguments `col_level`.", "question_id": 34637}
{"snippet": "DataFrame.reset_index(col_fill='')", "intent": "Reset the index , or a `level` of it . When the index is inserted under another level , we can specify under which one with the parameter `col_fill` :", "question_id": 34638}
{"snippet": "DataFrame.reset_index(level=None, drop=False)", "intent": "Reset the index , or a `level` of it . We can use the `drop` parameter to avoid the old index being added as a column :", "question_id": 34639}
{"snippet": "DataFrame.reset_index(level=None, inplace=False)", "intent": "Reset the index , or a `level` of it . With arguments `inplace`.", "question_id": 34640}
{"snippet": "DataFrame.reset_index(level=None, col_level=0)", "intent": "Reset the index , or a `level` of it . With arguments `col_level`.", "question_id": 34641}
{"snippet": "DataFrame.reset_index(level=None, col_fill='')", "intent": "Reset the index , or a `level` of it . When the index is inserted under another level , we can specify under which one with the parameter `col_fill` :", "question_id": 34642}
{"snippet": "DataFrame.rfloordiv(other)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator rfloordiv ) .", "question_id": 34643}
{"snippet": "DataFrame.rfloordiv(other, axis='columns')", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator rfloordiv ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34644}
{"snippet": "DataFrame.rfloordiv(other, level=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator rfloordiv ) . Divide by a MultiIndex by `level` .", "question_id": 34645}
{"snippet": "DataFrame.rfloordiv(other, fill_value=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator rfloordiv ) . Equivalent to other // dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34646}
{"snippet": "DataFrame.rfloordiv(other, axis='columns', level=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator rfloordiv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34647}
{"snippet": "DataFrame.rfloordiv(other, axis='columns', fill_value=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator rfloordiv ) . Subtract a list and Series by `axis` with operator version . Equivalent to other // dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34648}
{"snippet": "DataFrame.rfloordiv(other, level=None, fill_value=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator rfloordiv ) . Divide by a MultiIndex by `level` . Equivalent to other // dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34649}
{"snippet": "DataFrame.rfloordiv(other, axis='columns', level=None, fill_value=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator rfloordiv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to other // dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34650}
{"snippet": "DataFrame.rfloordiv(other)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator rfloordiv ) .", "question_id": 34651}
{"snippet": "DataFrame.rfloordiv(other, axis='columns')", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator rfloordiv ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34652}
{"snippet": "DataFrame.rfloordiv(other, level=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator rfloordiv ) . Divide by a MultiIndex by `level` .", "question_id": 34653}
{"snippet": "DataFrame.rfloordiv(other, fill_value=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator rfloordiv ) . Equivalent to other // dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34654}
{"snippet": "DataFrame.rfloordiv(other, axis='columns', level=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator rfloordiv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34655}
{"snippet": "DataFrame.rfloordiv(other, axis='columns', fill_value=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator rfloordiv ) . Subtract a list and Series by `axis` with operator version . Equivalent to other // dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34656}
{"snippet": "DataFrame.rfloordiv(other, level=None, fill_value=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator rfloordiv ) . Divide by a MultiIndex by `level` . Equivalent to other // dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34657}
{"snippet": "DataFrame.rfloordiv(other, axis='columns', level=None, fill_value=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator rfloordiv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to other // dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34658}
{"snippet": "DataFrame.rfloordiv(other)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator rfloordiv ) .", "question_id": 34659}
{"snippet": "DataFrame.rfloordiv(other, axis='columns')", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator rfloordiv ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34660}
{"snippet": "DataFrame.rfloordiv(other, level=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator rfloordiv ) . Divide by a MultiIndex by `level` .", "question_id": 34661}
{"snippet": "DataFrame.rfloordiv(other, fill_value=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator rfloordiv ) . Equivalent to other // dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34662}
{"snippet": "DataFrame.rfloordiv(other, axis='columns', level=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator rfloordiv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34663}
{"snippet": "DataFrame.rfloordiv(other, axis='columns', fill_value=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator rfloordiv ) . Subtract a list and Series by `axis` with operator version . Equivalent to other // dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34664}
{"snippet": "DataFrame.rfloordiv(other, level=None, fill_value=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator rfloordiv ) . Divide by a MultiIndex by `level` . Equivalent to other // dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34665}
{"snippet": "DataFrame.rfloordiv(other, axis='columns', level=None, fill_value=None)", "intent": "Get Integer division of dataframe and `other` , element-wise ( binary operator rfloordiv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to other // dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34666}
{"snippet": "DataFrame.rmod(other)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator rmod ) .", "question_id": 34667}
{"snippet": "DataFrame.rmod(other, axis='columns')", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator rmod ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34668}
{"snippet": "DataFrame.rmod(other, level=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator rmod ) . Divide by a MultiIndex by `level` .", "question_id": 34669}
{"snippet": "DataFrame.rmod(other, fill_value=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator rmod ) . Equivalent to other % dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34670}
{"snippet": "DataFrame.rmod(other, axis='columns', level=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator rmod ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34671}
{"snippet": "DataFrame.rmod(other, axis='columns', fill_value=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator rmod ) . Subtract a list and Series by `axis` with operator version . Equivalent to other % dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34672}
{"snippet": "DataFrame.rmod(other, level=None, fill_value=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator rmod ) . Divide by a MultiIndex by `level` . Equivalent to other % dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34673}
{"snippet": "DataFrame.rmod(other, axis='columns', level=None, fill_value=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator rmod ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to other % dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34674}
{"snippet": "DataFrame.rmod(other)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator rmod ) .", "question_id": 34675}
{"snippet": "DataFrame.rmod(other, axis='columns')", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator rmod ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34676}
{"snippet": "DataFrame.rmod(other, level=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator rmod ) . Divide by a MultiIndex by `level` .", "question_id": 34677}
{"snippet": "DataFrame.rmod(other, fill_value=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator rmod ) . Equivalent to other % dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34678}
{"snippet": "DataFrame.rmod(other, axis='columns', level=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator rmod ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34679}
{"snippet": "DataFrame.rmod(other, axis='columns', fill_value=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator rmod ) . Subtract a list and Series by `axis` with operator version . Equivalent to other % dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34680}
{"snippet": "DataFrame.rmod(other, level=None, fill_value=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator rmod ) . Divide by a MultiIndex by `level` . Equivalent to other % dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34681}
{"snippet": "DataFrame.rmod(other, axis='columns', level=None, fill_value=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator rmod ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to other % dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34682}
{"snippet": "DataFrame.rmod(other)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator rmod ) .", "question_id": 34683}
{"snippet": "DataFrame.rmod(other, axis='columns')", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator rmod ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34684}
{"snippet": "DataFrame.rmod(other, level=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator rmod ) . Divide by a MultiIndex by `level` .", "question_id": 34685}
{"snippet": "DataFrame.rmod(other, fill_value=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator rmod ) . Equivalent to other % dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34686}
{"snippet": "DataFrame.rmod(other, axis='columns', level=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator rmod ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34687}
{"snippet": "DataFrame.rmod(other, axis='columns', fill_value=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator rmod ) . Subtract a list and Series by `axis` with operator version . Equivalent to other % dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34688}
{"snippet": "DataFrame.rmod(other, level=None, fill_value=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator rmod ) . Divide by a MultiIndex by `level` . Equivalent to other % dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34689}
{"snippet": "DataFrame.rmod(other, axis='columns', level=None, fill_value=None)", "intent": "Get Modulo of dataframe and `other` , element-wise ( binary operator rmod ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to other % dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34690}
{"snippet": "DataFrame.rmul(other)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator rmul ) .", "question_id": 34691}
{"snippet": "DataFrame.rmul(other, axis='columns')", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator rmul ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34692}
{"snippet": "DataFrame.rmul(other, level=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator rmul ) . Divide by a MultiIndex by `level` .", "question_id": 34693}
{"snippet": "DataFrame.rmul(other, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator rmul ) . Equivalent to other * dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34694}
{"snippet": "DataFrame.rmul(other, axis='columns', level=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator rmul ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34695}
{"snippet": "DataFrame.rmul(other, axis='columns', fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator rmul ) . Subtract a list and Series by `axis` with operator version . Equivalent to other * dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34696}
{"snippet": "DataFrame.rmul(other, level=None, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator rmul ) . Divide by a MultiIndex by `level` . Equivalent to other * dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34697}
{"snippet": "DataFrame.rmul(other, axis='columns', level=None, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator rmul ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to other * dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34698}
{"snippet": "DataFrame.rmul(other)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator rmul ) .", "question_id": 34699}
{"snippet": "DataFrame.rmul(other, axis='columns')", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator rmul ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34700}
{"snippet": "DataFrame.rmul(other, level=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator rmul ) . Divide by a MultiIndex by `level` .", "question_id": 34701}
{"snippet": "DataFrame.rmul(other, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator rmul ) . Equivalent to other * dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34702}
{"snippet": "DataFrame.rmul(other, axis='columns', level=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator rmul ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34703}
{"snippet": "DataFrame.rmul(other, axis='columns', fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator rmul ) . Subtract a list and Series by `axis` with operator version . Equivalent to other * dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34704}
{"snippet": "DataFrame.rmul(other, level=None, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator rmul ) . Divide by a MultiIndex by `level` . Equivalent to other * dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34705}
{"snippet": "DataFrame.rmul(other, axis='columns', level=None, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator rmul ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to other * dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34706}
{"snippet": "DataFrame.rmul(other)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator rmul ) .", "question_id": 34707}
{"snippet": "DataFrame.rmul(other, axis='columns')", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator rmul ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34708}
{"snippet": "DataFrame.rmul(other, level=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator rmul ) . Divide by a MultiIndex by `level` .", "question_id": 34709}
{"snippet": "DataFrame.rmul(other, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator rmul ) . Equivalent to other * dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34710}
{"snippet": "DataFrame.rmul(other, axis='columns', level=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator rmul ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34711}
{"snippet": "DataFrame.rmul(other, axis='columns', fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator rmul ) . Subtract a list and Series by `axis` with operator version . Equivalent to other * dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34712}
{"snippet": "DataFrame.rmul(other, level=None, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator rmul ) . Divide by a MultiIndex by `level` . Equivalent to other * dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34713}
{"snippet": "DataFrame.rmul(other, axis='columns', level=None, fill_value=None)", "intent": "Get Multiplication of dataframe and `other` , element-wise ( binary operator rmul ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to other * dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34714}
{"snippet": "DataFrame.rolling(window)", "intent": "Provide rolling `window` calculations .", "question_id": 34715}
{"snippet": "DataFrame.rolling(window, min_periods=None)", "intent": "Provide rolling `window` calculations . Rolling sum with a window length of 2 , `min_periods` defaults to the window length .", "question_id": 34716}
{"snippet": "DataFrame.rolling(window, center=False)", "intent": "Provide rolling `window` calculations . This can be changed to the `center` of the window by setting center=True .", "question_id": 34717}
{"snippet": "DataFrame.rolling(window, win_type=None)", "intent": "Provide rolling `window` calculations . If win_type=None , all points are evenly weighted ; otherwise , `win_type` can accept a string of any scipy.signal window function .", "question_id": 34718}
{"snippet": "DataFrame.rolling(window, on=None)", "intent": "Provide rolling `window` calculations . Please see the third example below `on` how to add the additional parameters .", "question_id": 34719}
{"snippet": "DataFrame.rolling(window, axis=0)", "intent": "Provide rolling `window` calculations . With arguments `axis`.", "question_id": 34720}
{"snippet": "DataFrame.rolling(window, closed=None)", "intent": "Provide rolling `window` calculations . With arguments `closed`.", "question_id": 34721}
{"snippet": "DataFrame.rolling(window, method='single')", "intent": "Provide rolling `window` calculations . The additional parameters must match the keywords specified in the Scipy window type `method` signature .", "question_id": 34722}
{"snippet": "DataFrame.rolling(window, min_periods=None, center=False)", "intent": "Provide rolling `window` calculations . Rolling sum with a window length of 2 , `min_periods` defaults to the window length . This can be changed to the `center` of the window by setting center=True .", "question_id": 34723}
{"snippet": "DataFrame.rolling(window, min_periods=None, win_type=None)", "intent": "Provide rolling `window` calculations . Rolling sum with a window length of 2 , `min_periods` defaults to the window length . If win_type=None , all points are evenly weighted ; otherwise , `win_type` can accept a string of any scipy.signal window function .", "question_id": 34724}
{"snippet": "DataFrame.rolling(window)", "intent": "Provide rolling `window` calculations .", "question_id": 34725}
{"snippet": "DataFrame.rolling(window, min_periods=None)", "intent": "Provide rolling `window` calculations . Rolling sum with a window length of 2 , `min_periods` defaults to the window length .", "question_id": 34726}
{"snippet": "DataFrame.rolling(window, center=False)", "intent": "Provide rolling `window` calculations . This can be changed to the `center` of the window by setting center=True .", "question_id": 34727}
{"snippet": "DataFrame.rolling(window, win_type=None)", "intent": "Provide rolling `window` calculations . If win_type=None , all points are evenly weighted ; otherwise , `win_type` can accept a string of any scipy.signal window function .", "question_id": 34728}
{"snippet": "DataFrame.rolling(window, on=None)", "intent": "Provide rolling `window` calculations . Please see the third example below `on` how to add the additional parameters .", "question_id": 34729}
{"snippet": "DataFrame.rolling(window, axis=0)", "intent": "Provide rolling `window` calculations . With arguments `axis`.", "question_id": 34730}
{"snippet": "DataFrame.rolling(window, closed=None)", "intent": "Provide rolling `window` calculations . With arguments `closed`.", "question_id": 34731}
{"snippet": "DataFrame.rolling(window, method='single')", "intent": "Provide rolling `window` calculations . The additional parameters must match the keywords specified in the Scipy window type `method` signature .", "question_id": 34732}
{"snippet": "DataFrame.rolling(window, min_periods=None, center=False)", "intent": "Provide rolling `window` calculations . Rolling sum with a window length of 2 , `min_periods` defaults to the window length . This can be changed to the `center` of the window by setting center=True .", "question_id": 34733}
{"snippet": "DataFrame.rolling(window, min_periods=None, win_type=None)", "intent": "Provide rolling `window` calculations . Rolling sum with a window length of 2 , `min_periods` defaults to the window length . If win_type=None , all points are evenly weighted ; otherwise , `win_type` can accept a string of any scipy.signal window function .", "question_id": 34734}
{"snippet": "DataFrame.rolling(window)", "intent": "Provide rolling `window` calculations .", "question_id": 34735}
{"snippet": "DataFrame.rolling(window, min_periods=None)", "intent": "Provide rolling `window` calculations . Rolling sum with a window length of 2 , `min_periods` defaults to the window length .", "question_id": 34736}
{"snippet": "DataFrame.rolling(window, center=False)", "intent": "Provide rolling `window` calculations . This can be changed to the `center` of the window by setting center=True .", "question_id": 34737}
{"snippet": "DataFrame.rolling(window, win_type=None)", "intent": "Provide rolling `window` calculations . If win_type=None , all points are evenly weighted ; otherwise , `win_type` can accept a string of any scipy.signal window function .", "question_id": 34738}
{"snippet": "DataFrame.rolling(window, on=None)", "intent": "Provide rolling `window` calculations . Please see the third example below `on` how to add the additional parameters .", "question_id": 34739}
{"snippet": "DataFrame.rolling(window, axis=0)", "intent": "Provide rolling `window` calculations . With arguments `axis`.", "question_id": 34740}
{"snippet": "DataFrame.rolling(window, closed=None)", "intent": "Provide rolling `window` calculations . With arguments `closed`.", "question_id": 34741}
{"snippet": "DataFrame.rolling(window, method='single')", "intent": "Provide rolling `window` calculations . The additional parameters must match the keywords specified in the Scipy window type `method` signature .", "question_id": 34742}
{"snippet": "DataFrame.rolling(window, min_periods=None, center=False)", "intent": "Provide rolling `window` calculations . Rolling sum with a window length of 2 , `min_periods` defaults to the window length . This can be changed to the `center` of the window by setting center=True .", "question_id": 34743}
{"snippet": "DataFrame.rolling(window, min_periods=None, win_type=None)", "intent": "Provide rolling `window` calculations . Rolling sum with a window length of 2 , `min_periods` defaults to the window length . If win_type=None , all points are evenly weighted ; otherwise , `win_type` can accept a string of any scipy.signal window function .", "question_id": 34744}
{"snippet": "DataFrame.round(*args, **kwargs)", "intent": "Round a DataFrame to a variable number of decimal places . With arguments `*args`, `**kwargs`.", "question_id": 34745}
{"snippet": "DataFrame.round(*args, **kwargs, decimals=0)", "intent": "Round a DataFrame to a variable number of decimal places . With arguments `*args`, `**kwargs`, `decimals`.", "question_id": 34746}
{"snippet": "DataFrame.round(*args, **kwargs)", "intent": "Round a DataFrame to a variable number of decimal places . With arguments `*args`, `**kwargs`.", "question_id": 34747}
{"snippet": "DataFrame.round(*args, **kwargs, decimals=0)", "intent": "Round a DataFrame to a variable number of decimal places . With arguments `*args`, `**kwargs`, `decimals`.", "question_id": 34748}
{"snippet": "DataFrame.round(*args, **kwargs)", "intent": "Round a DataFrame to a variable number of decimal places . With arguments `*args`, `**kwargs`.", "question_id": 34749}
{"snippet": "DataFrame.round(*args, **kwargs, decimals=0)", "intent": "Round a DataFrame to a variable number of decimal places . With arguments `*args`, `**kwargs`, `decimals`.", "question_id": 34750}
{"snippet": "DataFrame.rpow(other)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator rpow ) .", "question_id": 34751}
{"snippet": "DataFrame.rpow(other, axis='columns')", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator rpow ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34752}
{"snippet": "DataFrame.rpow(other, level=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator rpow ) . Divide by a MultiIndex by `level` .", "question_id": 34753}
{"snippet": "DataFrame.rpow(other, fill_value=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator rpow ) . Equivalent to other * * dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34754}
{"snippet": "DataFrame.rpow(other, axis='columns', level=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator rpow ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34755}
{"snippet": "DataFrame.rpow(other, axis='columns', fill_value=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator rpow ) . Subtract a list and Series by `axis` with operator version . Equivalent to other * * dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34756}
{"snippet": "DataFrame.rpow(other, level=None, fill_value=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator rpow ) . Divide by a MultiIndex by `level` . Equivalent to other * * dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34757}
{"snippet": "DataFrame.rpow(other, axis='columns', level=None, fill_value=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator rpow ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to other * * dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34758}
{"snippet": "DataFrame.rpow(other)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator rpow ) .", "question_id": 34759}
{"snippet": "DataFrame.rpow(other, axis='columns')", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator rpow ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34760}
{"snippet": "DataFrame.rpow(other, level=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator rpow ) . Divide by a MultiIndex by `level` .", "question_id": 34761}
{"snippet": "DataFrame.rpow(other, fill_value=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator rpow ) . Equivalent to other * * dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34762}
{"snippet": "DataFrame.rpow(other, axis='columns', level=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator rpow ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34763}
{"snippet": "DataFrame.rpow(other, axis='columns', fill_value=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator rpow ) . Subtract a list and Series by `axis` with operator version . Equivalent to other * * dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34764}
{"snippet": "DataFrame.rpow(other, level=None, fill_value=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator rpow ) . Divide by a MultiIndex by `level` . Equivalent to other * * dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34765}
{"snippet": "DataFrame.rpow(other, axis='columns', level=None, fill_value=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator rpow ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to other * * dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34766}
{"snippet": "DataFrame.rpow(other)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator rpow ) .", "question_id": 34767}
{"snippet": "DataFrame.rpow(other, axis='columns')", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator rpow ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34768}
{"snippet": "DataFrame.rpow(other, level=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator rpow ) . Divide by a MultiIndex by `level` .", "question_id": 34769}
{"snippet": "DataFrame.rpow(other, fill_value=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator rpow ) . Equivalent to other * * dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34770}
{"snippet": "DataFrame.rpow(other, axis='columns', level=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator rpow ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34771}
{"snippet": "DataFrame.rpow(other, axis='columns', fill_value=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator rpow ) . Subtract a list and Series by `axis` with operator version . Equivalent to other * * dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34772}
{"snippet": "DataFrame.rpow(other, level=None, fill_value=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator rpow ) . Divide by a MultiIndex by `level` . Equivalent to other * * dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34773}
{"snippet": "DataFrame.rpow(other, axis='columns', level=None, fill_value=None)", "intent": "Get Exponential power of dataframe and `other` , element-wise ( binary operator rpow ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to other * * dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34774}
{"snippet": "DataFrame.rsub(other)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator rsub ) .", "question_id": 34775}
{"snippet": "DataFrame.rsub(other, axis='columns')", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator rsub ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34776}
{"snippet": "DataFrame.rsub(other, level=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator rsub ) . Divide by a MultiIndex by `level` .", "question_id": 34777}
{"snippet": "DataFrame.rsub(other, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator rsub ) . Equivalent to other - dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34778}
{"snippet": "DataFrame.rsub(other, axis='columns', level=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator rsub ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34779}
{"snippet": "DataFrame.rsub(other, axis='columns', fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator rsub ) . Subtract a list and Series by `axis` with operator version . Equivalent to other - dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34780}
{"snippet": "DataFrame.rsub(other, level=None, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator rsub ) . Divide by a MultiIndex by `level` . Equivalent to other - dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34781}
{"snippet": "DataFrame.rsub(other, axis='columns', level=None, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator rsub ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to other - dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34782}
{"snippet": "DataFrame.rsub(other)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator rsub ) .", "question_id": 34783}
{"snippet": "DataFrame.rsub(other, axis='columns')", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator rsub ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34784}
{"snippet": "DataFrame.rsub(other, level=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator rsub ) . Divide by a MultiIndex by `level` .", "question_id": 34785}
{"snippet": "DataFrame.rsub(other, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator rsub ) . Equivalent to other - dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34786}
{"snippet": "DataFrame.rsub(other, axis='columns', level=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator rsub ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34787}
{"snippet": "DataFrame.rsub(other, axis='columns', fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator rsub ) . Subtract a list and Series by `axis` with operator version . Equivalent to other - dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34788}
{"snippet": "DataFrame.rsub(other, level=None, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator rsub ) . Divide by a MultiIndex by `level` . Equivalent to other - dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34789}
{"snippet": "DataFrame.rsub(other, axis='columns', level=None, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator rsub ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to other - dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34790}
{"snippet": "DataFrame.rsub(other)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator rsub ) .", "question_id": 34791}
{"snippet": "DataFrame.rsub(other, axis='columns')", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator rsub ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34792}
{"snippet": "DataFrame.rsub(other, level=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator rsub ) . Divide by a MultiIndex by `level` .", "question_id": 34793}
{"snippet": "DataFrame.rsub(other, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator rsub ) . Equivalent to other - dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34794}
{"snippet": "DataFrame.rsub(other, axis='columns', level=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator rsub ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34795}
{"snippet": "DataFrame.rsub(other, axis='columns', fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator rsub ) . Subtract a list and Series by `axis` with operator version . Equivalent to other - dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34796}
{"snippet": "DataFrame.rsub(other, level=None, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator rsub ) . Divide by a MultiIndex by `level` . Equivalent to other - dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34797}
{"snippet": "DataFrame.rsub(other, axis='columns', level=None, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator rsub ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to other - dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34798}
{"snippet": "DataFrame.rtruediv(other)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) .", "question_id": 34799}
{"snippet": "DataFrame.rtruediv(other, axis='columns')", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34800}
{"snippet": "DataFrame.rtruediv(other, level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Divide by a MultiIndex by `level` .", "question_id": 34801}
{"snippet": "DataFrame.rtruediv(other, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34802}
{"snippet": "DataFrame.rtruediv(other, axis='columns', level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34803}
{"snippet": "DataFrame.rtruediv(other, axis='columns', fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Subtract a list and Series by `axis` with operator version . Equivalent to other / dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34804}
{"snippet": "DataFrame.rtruediv(other, level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Divide by a MultiIndex by `level` . Equivalent to other / dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34805}
{"snippet": "DataFrame.rtruediv(other, axis='columns', level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to other / dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34806}
{"snippet": "DataFrame.rtruediv(other)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) .", "question_id": 34807}
{"snippet": "DataFrame.rtruediv(other, axis='columns')", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34808}
{"snippet": "DataFrame.rtruediv(other, level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Divide by a MultiIndex by `level` .", "question_id": 34809}
{"snippet": "DataFrame.rtruediv(other, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34810}
{"snippet": "DataFrame.rtruediv(other, axis='columns', level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34811}
{"snippet": "DataFrame.rtruediv(other, axis='columns', fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Subtract a list and Series by `axis` with operator version . Equivalent to other / dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34812}
{"snippet": "DataFrame.rtruediv(other, level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Divide by a MultiIndex by `level` . Equivalent to other / dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34813}
{"snippet": "DataFrame.rtruediv(other, axis='columns', level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to other / dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34814}
{"snippet": "DataFrame.rtruediv(other)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) .", "question_id": 34815}
{"snippet": "DataFrame.rtruediv(other, axis='columns')", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Subtract a list and Series by `axis` with operator version .", "question_id": 34816}
{"snippet": "DataFrame.rtruediv(other, level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Divide by a MultiIndex by `level` .", "question_id": 34817}
{"snippet": "DataFrame.rtruediv(other, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34818}
{"snippet": "DataFrame.rtruediv(other, axis='columns', level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 34819}
{"snippet": "DataFrame.rtruediv(other, axis='columns', fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Subtract a list and Series by `axis` with operator version . Equivalent to other / dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34820}
{"snippet": "DataFrame.rtruediv(other, level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Divide by a MultiIndex by `level` . Equivalent to other / dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34821}
{"snippet": "DataFrame.rtruediv(other, axis='columns', level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator rtruediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to other / dataframe , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 34822}
{"snippet": "DataFrame.sample()", "intent": "Return a random sample of items from an `axis` of object .", "question_id": 34823}
{"snippet": "DataFrame.sample(n=None)", "intent": "Return a random sample of items from an `axis` of object . With arguments `n`.", "question_id": 34824}
{"snippet": "DataFrame.sample(frac=None)", "intent": "Return a random sample of items from an `axis` of object . If `frac` > 1 , replacement should be set to True .", "question_id": 34825}
{"snippet": "DataFrame.sample(replace=False)", "intent": "Return a random sample of items from an `axis` of object . An upsample sample of the DataFrame with replacement : Note that `replace` parameter has to be True for frac parameter > 1 .", "question_id": 34826}
{"snippet": "DataFrame.sample(weights=None)", "intent": "Return a random sample of items from an `axis` of object . Using a DataFrame column as `weights` .", "question_id": 34827}
{"snippet": "DataFrame.sample(random_state=None)", "intent": "Return a random sample of items from an `axis` of object . You can use `random_state` for reproducibility .", "question_id": 34828}
{"snippet": "DataFrame.sample(axis=None)", "intent": "Return a random sample of items from an `axis` of object .", "question_id": 34829}
{"snippet": "DataFrame.sample(ignore_index=False)", "intent": "Return a random sample of items from an `axis` of object . With arguments `ignore_index`.", "question_id": 34830}
{"snippet": "DataFrame.sample(n=None, frac=None)", "intent": "Return a random sample of items from an `axis` of object . If `frac` > 1 , replacement should be set to True . With arguments `n`.", "question_id": 34831}
{"snippet": "DataFrame.sample(n=None, replace=False)", "intent": "Return a random sample of items from an `axis` of object . An upsample sample of the DataFrame with replacement : Note that `replace` parameter has to be True for frac parameter > 1 . With arguments `n`.", "question_id": 34832}
{"snippet": "DataFrame.sample()", "intent": "Return a random sample of items from an `axis` of object .", "question_id": 34833}
{"snippet": "DataFrame.sample(n=None)", "intent": "Return a random sample of items from an `axis` of object . With arguments `n`.", "question_id": 34834}
{"snippet": "DataFrame.sample(frac=None)", "intent": "Return a random sample of items from an `axis` of object . If `frac` > 1 , replacement should be set to True .", "question_id": 34835}
{"snippet": "DataFrame.sample(replace=False)", "intent": "Return a random sample of items from an `axis` of object . An upsample sample of the DataFrame with replacement : Note that `replace` parameter has to be True for frac parameter > 1 .", "question_id": 34836}
{"snippet": "DataFrame.sample(weights=None)", "intent": "Return a random sample of items from an `axis` of object . Using a DataFrame column as `weights` .", "question_id": 34837}
{"snippet": "DataFrame.sample(random_state=None)", "intent": "Return a random sample of items from an `axis` of object . You can use `random_state` for reproducibility .", "question_id": 34838}
{"snippet": "DataFrame.sample(axis=None)", "intent": "Return a random sample of items from an `axis` of object .", "question_id": 34839}
{"snippet": "DataFrame.sample(ignore_index=False)", "intent": "Return a random sample of items from an `axis` of object . With arguments `ignore_index`.", "question_id": 34840}
{"snippet": "DataFrame.sample(n=None, frac=None)", "intent": "Return a random sample of items from an `axis` of object . If `frac` > 1 , replacement should be set to True . With arguments `n`.", "question_id": 34841}
{"snippet": "DataFrame.sample(n=None, replace=False)", "intent": "Return a random sample of items from an `axis` of object . An upsample sample of the DataFrame with replacement : Note that `replace` parameter has to be True for frac parameter > 1 . With arguments `n`.", "question_id": 34842}
{"snippet": "DataFrame.sample()", "intent": "Return a random sample of items from an `axis` of object .", "question_id": 34843}
{"snippet": "DataFrame.sample(n=None)", "intent": "Return a random sample of items from an `axis` of object . With arguments `n`.", "question_id": 34844}
{"snippet": "DataFrame.sample(frac=None)", "intent": "Return a random sample of items from an `axis` of object . If `frac` > 1 , replacement should be set to True .", "question_id": 34845}
{"snippet": "DataFrame.sample(replace=False)", "intent": "Return a random sample of items from an `axis` of object . An upsample sample of the DataFrame with replacement : Note that `replace` parameter has to be True for frac parameter > 1 .", "question_id": 34846}
{"snippet": "DataFrame.sample(weights=None)", "intent": "Return a random sample of items from an `axis` of object . Using a DataFrame column as `weights` .", "question_id": 34847}
{"snippet": "DataFrame.sample(random_state=None)", "intent": "Return a random sample of items from an `axis` of object . You can use `random_state` for reproducibility .", "question_id": 34848}
{"snippet": "DataFrame.sample(axis=None)", "intent": "Return a random sample of items from an `axis` of object .", "question_id": 34849}
{"snippet": "DataFrame.sample(ignore_index=False)", "intent": "Return a random sample of items from an `axis` of object . With arguments `ignore_index`.", "question_id": 34850}
{"snippet": "DataFrame.sample(n=None, frac=None)", "intent": "Return a random sample of items from an `axis` of object . If `frac` > 1 , replacement should be set to True . With arguments `n`.", "question_id": 34851}
{"snippet": "DataFrame.sample(n=None, replace=False)", "intent": "Return a random sample of items from an `axis` of object . An upsample sample of the DataFrame with replacement : Note that `replace` parameter has to be True for frac parameter > 1 . With arguments `n`.", "question_id": 34852}
{"snippet": "DataFrame.select_dtypes()", "intent": "Return a subset of the DataFrame \u2019 s columns based on the column dtypes .", "question_id": 34853}
{"snippet": "DataFrame.select_dtypes(include=None)", "intent": "Return a subset of the DataFrame \u2019 s columns based on the column dtypes . With arguments `include`.", "question_id": 34854}
{"snippet": "DataFrame.select_dtypes(exclude=None)", "intent": "Return a subset of the DataFrame \u2019 s columns based on the column dtypes . With arguments `exclude`.", "question_id": 34855}
{"snippet": "DataFrame.select_dtypes(include=None, exclude=None)", "intent": "Return a subset of the DataFrame \u2019 s columns based on the column dtypes . With arguments `include`, `exclude`.", "question_id": 34856}
{"snippet": "DataFrame.select_dtypes()", "intent": "Return a subset of the DataFrame \u2019 s columns based on the column dtypes .", "question_id": 34857}
{"snippet": "DataFrame.select_dtypes(include=None)", "intent": "Return a subset of the DataFrame \u2019 s columns based on the column dtypes . With arguments `include`.", "question_id": 34858}
{"snippet": "DataFrame.select_dtypes(exclude=None)", "intent": "Return a subset of the DataFrame \u2019 s columns based on the column dtypes . With arguments `exclude`.", "question_id": 34859}
{"snippet": "DataFrame.select_dtypes(include=None, exclude=None)", "intent": "Return a subset of the DataFrame \u2019 s columns based on the column dtypes . With arguments `include`, `exclude`.", "question_id": 34860}
{"snippet": "DataFrame.select_dtypes()", "intent": "Return a subset of the DataFrame \u2019 s columns based on the column dtypes .", "question_id": 34861}
{"snippet": "DataFrame.select_dtypes(include=None)", "intent": "Return a subset of the DataFrame \u2019 s columns based on the column dtypes . With arguments `include`.", "question_id": 34862}
{"snippet": "DataFrame.select_dtypes(exclude=None)", "intent": "Return a subset of the DataFrame \u2019 s columns based on the column dtypes . With arguments `exclude`.", "question_id": 34863}
{"snippet": "DataFrame.select_dtypes(include=None, exclude=None)", "intent": "Return a subset of the DataFrame \u2019 s columns based on the column dtypes . With arguments `include`, `exclude`.", "question_id": 34864}
{"snippet": "DataFrame.sem(**kwargs)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`.", "question_id": 34865}
{"snippet": "DataFrame.sem(**kwargs, axis=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`.", "question_id": 34866}
{"snippet": "DataFrame.sem(**kwargs, skipna=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 34867}
{"snippet": "DataFrame.sem(**kwargs, level=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 34868}
{"snippet": "DataFrame.sem(**kwargs, ddof=1)", "intent": "Return unbiased standard error of the mean over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 34869}
{"snippet": "DataFrame.sem(**kwargs, numeric_only=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 34870}
{"snippet": "DataFrame.sem(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 34871}
{"snippet": "DataFrame.sem(**kwargs, axis=None, level=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 34872}
{"snippet": "DataFrame.sem(**kwargs, axis=None, ddof=1)", "intent": "Return unbiased standard error of the mean over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 34873}
{"snippet": "DataFrame.sem(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 34874}
{"snippet": "DataFrame.sem(**kwargs)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`.", "question_id": 34875}
{"snippet": "DataFrame.sem(**kwargs, axis=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`.", "question_id": 34876}
{"snippet": "DataFrame.sem(**kwargs, skipna=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 34877}
{"snippet": "DataFrame.sem(**kwargs, level=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 34878}
{"snippet": "DataFrame.sem(**kwargs, ddof=1)", "intent": "Return unbiased standard error of the mean over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 34879}
{"snippet": "DataFrame.sem(**kwargs, numeric_only=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 34880}
{"snippet": "DataFrame.sem(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 34881}
{"snippet": "DataFrame.sem(**kwargs, axis=None, level=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 34882}
{"snippet": "DataFrame.sem(**kwargs, axis=None, ddof=1)", "intent": "Return unbiased standard error of the mean over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 34883}
{"snippet": "DataFrame.sem(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 34884}
{"snippet": "DataFrame.sem(**kwargs)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`.", "question_id": 34885}
{"snippet": "DataFrame.sem(**kwargs, axis=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`.", "question_id": 34886}
{"snippet": "DataFrame.sem(**kwargs, skipna=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 34887}
{"snippet": "DataFrame.sem(**kwargs, level=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 34888}
{"snippet": "DataFrame.sem(**kwargs, ddof=1)", "intent": "Return unbiased standard error of the mean over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 34889}
{"snippet": "DataFrame.sem(**kwargs, numeric_only=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 34890}
{"snippet": "DataFrame.sem(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 34891}
{"snippet": "DataFrame.sem(**kwargs, axis=None, level=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 34892}
{"snippet": "DataFrame.sem(**kwargs, axis=None, ddof=1)", "intent": "Return unbiased standard error of the mean over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 34893}
{"snippet": "DataFrame.sem(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 34894}
{"snippet": "DataFrame.set_axis(labels)", "intent": "Assign desired index to given `axis` . Indexes for column or row `labels` can be changed by assigning a list-like or Index .", "question_id": 34895}
{"snippet": "DataFrame.set_axis(labels, axis=0)", "intent": "Assign desired index to given `axis` . Indexes for column or row `labels` can be changed by assigning a list-like or Index .", "question_id": 34896}
{"snippet": "DataFrame.set_axis(labels, inplace=False)", "intent": "Assign desired index to given `axis` . Indexes for column or row `labels` can be changed by assigning a list-like or Index . Now , update the labels `inplace` .", "question_id": 34897}
{"snippet": "DataFrame.set_axis(labels, axis=0, inplace=False)", "intent": "Assign desired index to given `axis` . Indexes for column or row `labels` can be changed by assigning a list-like or Index . Now , update the labels `inplace` .", "question_id": 34898}
{"snippet": "DataFrame.set_axis(labels)", "intent": "Assign desired index to given `axis` . Indexes for column or row `labels` can be changed by assigning a list-like or Index .", "question_id": 34899}
{"snippet": "DataFrame.set_axis(labels, axis=0)", "intent": "Assign desired index to given `axis` . Indexes for column or row `labels` can be changed by assigning a list-like or Index .", "question_id": 34900}
{"snippet": "DataFrame.set_axis(labels, inplace=False)", "intent": "Assign desired index to given `axis` . Indexes for column or row `labels` can be changed by assigning a list-like or Index . Now , update the labels `inplace` .", "question_id": 34901}
{"snippet": "DataFrame.set_axis(labels, axis=0, inplace=False)", "intent": "Assign desired index to given `axis` . Indexes for column or row `labels` can be changed by assigning a list-like or Index . Now , update the labels `inplace` .", "question_id": 34902}
{"snippet": "DataFrame.set_axis(labels)", "intent": "Assign desired index to given `axis` . Indexes for column or row `labels` can be changed by assigning a list-like or Index .", "question_id": 34903}
{"snippet": "DataFrame.set_axis(labels, axis=0)", "intent": "Assign desired index to given `axis` . Indexes for column or row `labels` can be changed by assigning a list-like or Index .", "question_id": 34904}
{"snippet": "DataFrame.set_axis(labels, inplace=False)", "intent": "Assign desired index to given `axis` . Indexes for column or row `labels` can be changed by assigning a list-like or Index . Now , update the labels `inplace` .", "question_id": 34905}
{"snippet": "DataFrame.set_axis(labels, axis=0, inplace=False)", "intent": "Assign desired index to given `axis` . Indexes for column or row `labels` can be changed by assigning a list-like or Index . Now , update the labels `inplace` .", "question_id": 34906}
{"snippet": "DataFrame.set_flags()", "intent": "Return a new object with updated flags .", "question_id": 34907}
{"snippet": "DataFrame.set_flags(copy=False)", "intent": "Return a new object with updated flags . With arguments `copy`.", "question_id": 34908}
{"snippet": "DataFrame.set_flags(allows_duplicate_labels=None)", "intent": "Return a new object with updated flags . With arguments `allows_duplicate_labels`.", "question_id": 34909}
{"snippet": "DataFrame.set_flags(copy=False, allows_duplicate_labels=None)", "intent": "Return a new object with updated flags . With arguments `copy`, `allows_duplicate_labels`.", "question_id": 34910}
{"snippet": "DataFrame.set_flags()", "intent": "Return a new object with updated flags .", "question_id": 34911}
{"snippet": "DataFrame.set_flags(copy=False)", "intent": "Return a new object with updated flags . With arguments `copy`.", "question_id": 34912}
{"snippet": "DataFrame.set_flags(allows_duplicate_labels=None)", "intent": "Return a new object with updated flags . With arguments `allows_duplicate_labels`.", "question_id": 34913}
{"snippet": "DataFrame.set_flags(copy=False, allows_duplicate_labels=None)", "intent": "Return a new object with updated flags . With arguments `copy`, `allows_duplicate_labels`.", "question_id": 34914}
{"snippet": "DataFrame.set_flags()", "intent": "Return a new object with updated flags .", "question_id": 34915}
{"snippet": "DataFrame.set_flags(copy=False)", "intent": "Return a new object with updated flags . With arguments `copy`.", "question_id": 34916}
{"snippet": "DataFrame.set_flags(allows_duplicate_labels=None)", "intent": "Return a new object with updated flags . With arguments `allows_duplicate_labels`.", "question_id": 34917}
{"snippet": "DataFrame.set_flags(copy=False, allows_duplicate_labels=None)", "intent": "Return a new object with updated flags . With arguments `copy`, `allows_duplicate_labels`.", "question_id": 34918}
{"snippet": "DataFrame.set_index(keys)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`.", "question_id": 34919}
{"snippet": "DataFrame.set_index(keys, drop=True)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `drop`.", "question_id": 34920}
{"snippet": "DataFrame.set_index(keys, append=False)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `append`.", "question_id": 34921}
{"snippet": "DataFrame.set_index(keys, inplace=False)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `inplace`.", "question_id": 34922}
{"snippet": "DataFrame.set_index(keys, verify_integrity=False)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `verify_integrity`.", "question_id": 34923}
{"snippet": "DataFrame.set_index(keys, drop=True, append=False)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `drop`, `append`.", "question_id": 34924}
{"snippet": "DataFrame.set_index(keys, drop=True, inplace=False)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `drop`, `inplace`.", "question_id": 34925}
{"snippet": "DataFrame.set_index(keys, drop=True, verify_integrity=False)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `drop`, `verify_integrity`.", "question_id": 34926}
{"snippet": "DataFrame.set_index(keys, append=False, inplace=False)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `append`, `inplace`.", "question_id": 34927}
{"snippet": "DataFrame.set_index(keys, append=False, verify_integrity=False)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `append`, `verify_integrity`.", "question_id": 34928}
{"snippet": "DataFrame.set_index(keys)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`.", "question_id": 34929}
{"snippet": "DataFrame.set_index(keys, drop=True)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `drop`.", "question_id": 34930}
{"snippet": "DataFrame.set_index(keys, append=False)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `append`.", "question_id": 34931}
{"snippet": "DataFrame.set_index(keys, inplace=False)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `inplace`.", "question_id": 34932}
{"snippet": "DataFrame.set_index(keys, verify_integrity=False)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `verify_integrity`.", "question_id": 34933}
{"snippet": "DataFrame.set_index(keys, drop=True, append=False)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `drop`, `append`.", "question_id": 34934}
{"snippet": "DataFrame.set_index(keys, drop=True, inplace=False)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `drop`, `inplace`.", "question_id": 34935}
{"snippet": "DataFrame.set_index(keys, drop=True, verify_integrity=False)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `drop`, `verify_integrity`.", "question_id": 34936}
{"snippet": "DataFrame.set_index(keys, append=False, inplace=False)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `append`, `inplace`.", "question_id": 34937}
{"snippet": "DataFrame.set_index(keys, append=False, verify_integrity=False)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `append`, `verify_integrity`.", "question_id": 34938}
{"snippet": "DataFrame.set_index(keys)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`.", "question_id": 34939}
{"snippet": "DataFrame.set_index(keys, drop=True)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `drop`.", "question_id": 34940}
{"snippet": "DataFrame.set_index(keys, append=False)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `append`.", "question_id": 34941}
{"snippet": "DataFrame.set_index(keys, inplace=False)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `inplace`.", "question_id": 34942}
{"snippet": "DataFrame.set_index(keys, verify_integrity=False)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `verify_integrity`.", "question_id": 34943}
{"snippet": "DataFrame.set_index(keys, drop=True, append=False)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `drop`, `append`.", "question_id": 34944}
{"snippet": "DataFrame.set_index(keys, drop=True, inplace=False)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `drop`, `inplace`.", "question_id": 34945}
{"snippet": "DataFrame.set_index(keys, drop=True, verify_integrity=False)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `drop`, `verify_integrity`.", "question_id": 34946}
{"snippet": "DataFrame.set_index(keys, append=False, inplace=False)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `append`, `inplace`.", "question_id": 34947}
{"snippet": "DataFrame.set_index(keys, append=False, verify_integrity=False)", "intent": "Set the DataFrame index using existing columns . With arguments `keys`, `append`, `verify_integrity`.", "question_id": 34948}
{"snippet": "DataFrame.shift()", "intent": "Shift index by desired number of `periods` with an optional time `freq` .", "question_id": 34949}
{"snippet": "DataFrame.shift(periods=1)", "intent": "Shift index by desired number of `periods` with an optional time `freq` .", "question_id": 34950}
{"snippet": "DataFrame.shift(freq=None)", "intent": "Shift index by desired number of `periods` with an optional time `freq` .", "question_id": 34951}
{"snippet": "DataFrame.shift(axis=0)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `axis`.", "question_id": 34952}
{"snippet": "DataFrame.shift(fill_value=NoDefault.no_default)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `fill_value`.", "question_id": 34953}
{"snippet": "DataFrame.shift(periods=1, freq=None)", "intent": "Shift index by desired number of `periods` with an optional time `freq` .", "question_id": 34954}
{"snippet": "DataFrame.shift(periods=1, axis=0)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `axis`.", "question_id": 34955}
{"snippet": "DataFrame.shift(periods=1, fill_value=NoDefault.no_default)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `fill_value`.", "question_id": 34956}
{"snippet": "DataFrame.shift(freq=None, axis=0)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `axis`.", "question_id": 34957}
{"snippet": "DataFrame.shift(freq=None, fill_value=NoDefault.no_default)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `fill_value`.", "question_id": 34958}
{"snippet": "DataFrame.shift()", "intent": "Shift index by desired number of `periods` with an optional time `freq` .", "question_id": 34959}
{"snippet": "DataFrame.shift(periods=1)", "intent": "Shift index by desired number of `periods` with an optional time `freq` .", "question_id": 34960}
{"snippet": "DataFrame.shift(freq=None)", "intent": "Shift index by desired number of `periods` with an optional time `freq` .", "question_id": 34961}
{"snippet": "DataFrame.shift(axis=0)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `axis`.", "question_id": 34962}
{"snippet": "DataFrame.shift(fill_value=NoDefault.no_default)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `fill_value`.", "question_id": 34963}
{"snippet": "DataFrame.shift(periods=1, freq=None)", "intent": "Shift index by desired number of `periods` with an optional time `freq` .", "question_id": 34964}
{"snippet": "DataFrame.shift(periods=1, axis=0)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `axis`.", "question_id": 34965}
{"snippet": "DataFrame.shift(periods=1, fill_value=NoDefault.no_default)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `fill_value`.", "question_id": 34966}
{"snippet": "DataFrame.shift(freq=None, axis=0)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `axis`.", "question_id": 34967}
{"snippet": "DataFrame.shift(freq=None, fill_value=NoDefault.no_default)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `fill_value`.", "question_id": 34968}
{"snippet": "DataFrame.shift()", "intent": "Shift index by desired number of `periods` with an optional time `freq` .", "question_id": 34969}
{"snippet": "DataFrame.shift(periods=1)", "intent": "Shift index by desired number of `periods` with an optional time `freq` .", "question_id": 34970}
{"snippet": "DataFrame.shift(freq=None)", "intent": "Shift index by desired number of `periods` with an optional time `freq` .", "question_id": 34971}
{"snippet": "DataFrame.shift(axis=0)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `axis`.", "question_id": 34972}
{"snippet": "DataFrame.shift(fill_value=NoDefault.no_default)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `fill_value`.", "question_id": 34973}
{"snippet": "DataFrame.shift(periods=1, freq=None)", "intent": "Shift index by desired number of `periods` with an optional time `freq` .", "question_id": 34974}
{"snippet": "DataFrame.shift(periods=1, axis=0)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `axis`.", "question_id": 34975}
{"snippet": "DataFrame.shift(periods=1, fill_value=NoDefault.no_default)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `fill_value`.", "question_id": 34976}
{"snippet": "DataFrame.shift(freq=None, axis=0)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `axis`.", "question_id": 34977}
{"snippet": "DataFrame.shift(freq=None, fill_value=NoDefault.no_default)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `fill_value`.", "question_id": 34978}
{"snippet": "DataFrame.skew(**kwargs)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`.", "question_id": 34979}
{"snippet": "DataFrame.skew(**kwargs, axis=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`.", "question_id": 34980}
{"snippet": "DataFrame.skew(**kwargs, skipna=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 34981}
{"snippet": "DataFrame.skew(**kwargs, level=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 34982}
{"snippet": "DataFrame.skew(**kwargs, numeric_only=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 34983}
{"snippet": "DataFrame.skew(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 34984}
{"snippet": "DataFrame.skew(**kwargs, axis=None, level=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 34985}
{"snippet": "DataFrame.skew(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 34986}
{"snippet": "DataFrame.skew(**kwargs, skipna=None, level=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 34987}
{"snippet": "DataFrame.skew(**kwargs, skipna=None, numeric_only=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 34988}
{"snippet": "DataFrame.skew(**kwargs)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`.", "question_id": 34989}
{"snippet": "DataFrame.skew(**kwargs, axis=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`.", "question_id": 34990}
{"snippet": "DataFrame.skew(**kwargs, skipna=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 34991}
{"snippet": "DataFrame.skew(**kwargs, level=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 34992}
{"snippet": "DataFrame.skew(**kwargs, numeric_only=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 34993}
{"snippet": "DataFrame.skew(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 34994}
{"snippet": "DataFrame.skew(**kwargs, axis=None, level=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 34995}
{"snippet": "DataFrame.skew(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 34996}
{"snippet": "DataFrame.skew(**kwargs, skipna=None, level=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 34997}
{"snippet": "DataFrame.skew(**kwargs, skipna=None, numeric_only=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 34998}
{"snippet": "DataFrame.skew(**kwargs)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`.", "question_id": 34999}
{"snippet": "DataFrame.skew(**kwargs, axis=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`.", "question_id": 35000}
{"snippet": "DataFrame.skew(**kwargs, skipna=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 35001}
{"snippet": "DataFrame.skew(**kwargs, level=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 35002}
{"snippet": "DataFrame.skew(**kwargs, numeric_only=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 35003}
{"snippet": "DataFrame.skew(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 35004}
{"snippet": "DataFrame.skew(**kwargs, axis=None, level=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 35005}
{"snippet": "DataFrame.skew(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 35006}
{"snippet": "DataFrame.skew(**kwargs, skipna=None, level=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 35007}
{"snippet": "DataFrame.skew(**kwargs, skipna=None, numeric_only=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 35008}
{"snippet": "DataFrame.slice_shift()", "intent": "Equivalent to shift without copying data .", "question_id": 35009}
{"snippet": "DataFrame.slice_shift(periods=1)", "intent": "Equivalent to shift without copying data . The shifted data will not include the dropped `periods` and the shifted `axis` will be smaller than the original .", "question_id": 35010}
{"snippet": "DataFrame.slice_shift(axis=0)", "intent": "Equivalent to shift without copying data . The shifted data will not include the dropped `periods` and the shifted `axis` will be smaller than the original .", "question_id": 35011}
{"snippet": "DataFrame.slice_shift(periods=1, axis=0)", "intent": "Equivalent to shift without copying data . The shifted data will not include the dropped `periods` and the shifted `axis` will be smaller than the original .", "question_id": 35012}
{"snippet": "DataFrame.slice_shift()", "intent": "Equivalent to shift without copying data .", "question_id": 35013}
{"snippet": "DataFrame.slice_shift(periods=1)", "intent": "Equivalent to shift without copying data . The shifted data will not include the dropped `periods` and the shifted `axis` will be smaller than the original .", "question_id": 35014}
{"snippet": "DataFrame.slice_shift(axis=0)", "intent": "Equivalent to shift without copying data . The shifted data will not include the dropped `periods` and the shifted `axis` will be smaller than the original .", "question_id": 35015}
{"snippet": "DataFrame.slice_shift(periods=1, axis=0)", "intent": "Equivalent to shift without copying data . The shifted data will not include the dropped `periods` and the shifted `axis` will be smaller than the original .", "question_id": 35016}
{"snippet": "DataFrame.slice_shift()", "intent": "Equivalent to shift without copying data .", "question_id": 35017}
{"snippet": "DataFrame.slice_shift(periods=1)", "intent": "Equivalent to shift without copying data . The shifted data will not include the dropped `periods` and the shifted `axis` will be smaller than the original .", "question_id": 35018}
{"snippet": "DataFrame.slice_shift(axis=0)", "intent": "Equivalent to shift without copying data . The shifted data will not include the dropped `periods` and the shifted `axis` will be smaller than the original .", "question_id": 35019}
{"snippet": "DataFrame.slice_shift(periods=1, axis=0)", "intent": "Equivalent to shift without copying data . The shifted data will not include the dropped `periods` and the shifted `axis` will be smaller than the original .", "question_id": 35020}
{"snippet": "DataFrame.sort_index()", "intent": "Sort object by labels ( along an `axis` ) .", "question_id": 35021}
{"snippet": "DataFrame.sort_index(axis=0)", "intent": "Sort object by labels ( along an `axis` ) .", "question_id": 35022}
{"snippet": "DataFrame.sort_index(level=None)", "intent": "Sort object by labels ( along an `axis` ) . For a MultiIndex this is applied to each `level` separately .", "question_id": 35023}
{"snippet": "DataFrame.sort_index(ascending=True)", "intent": "Sort object by labels ( along an `axis` ) . By default , it sorts in `ascending` order , to sort in descending order , use ascending=False", "question_id": 35024}
{"snippet": "DataFrame.sort_index(inplace=False)", "intent": "Sort object by labels ( along an `axis` ) . Returns a new DataFrame sorted by label if `inplace` argument is False , otherwise updates the original DataFrame and returns None .", "question_id": 35025}
{"snippet": "DataFrame.sort_index(kind='quicksort')", "intent": "Sort object by labels ( along an `axis` ) . With arguments `kind`.", "question_id": 35026}
{"snippet": "DataFrame.sort_index(na_position='last')", "intent": "Sort object by labels ( along an `axis` ) . With arguments `na_position`.", "question_id": 35027}
{"snippet": "DataFrame.sort_index(sort_remaining=True)", "intent": "Sort object by labels ( along an `axis` ) . With arguments `sort_remaining`.", "question_id": 35028}
{"snippet": "DataFrame.sort_index(ignore_index=False)", "intent": "Sort object by labels ( along an `axis` ) . With arguments `ignore_index`.", "question_id": 35029}
{"snippet": "DataFrame.sort_index(key=None)", "intent": "Sort object by labels ( along an `axis` ) . A `key` function can be specified which is applied to the index before sorting .", "question_id": 35030}
{"snippet": "DataFrame.sort_index()", "intent": "Sort object by labels ( along an `axis` ) .", "question_id": 35031}
{"snippet": "DataFrame.sort_index(axis=0)", "intent": "Sort object by labels ( along an `axis` ) .", "question_id": 35032}
{"snippet": "DataFrame.sort_index(level=None)", "intent": "Sort object by labels ( along an `axis` ) . For a MultiIndex this is applied to each `level` separately .", "question_id": 35033}
{"snippet": "DataFrame.sort_index(ascending=True)", "intent": "Sort object by labels ( along an `axis` ) . By default , it sorts in `ascending` order , to sort in descending order , use ascending=False", "question_id": 35034}
{"snippet": "DataFrame.sort_index(inplace=False)", "intent": "Sort object by labels ( along an `axis` ) . Returns a new DataFrame sorted by label if `inplace` argument is False , otherwise updates the original DataFrame and returns None .", "question_id": 35035}
{"snippet": "DataFrame.sort_index(kind='quicksort')", "intent": "Sort object by labels ( along an `axis` ) . With arguments `kind`.", "question_id": 35036}
{"snippet": "DataFrame.sort_index(na_position='last')", "intent": "Sort object by labels ( along an `axis` ) . With arguments `na_position`.", "question_id": 35037}
{"snippet": "DataFrame.sort_index(sort_remaining=True)", "intent": "Sort object by labels ( along an `axis` ) . With arguments `sort_remaining`.", "question_id": 35038}
{"snippet": "DataFrame.sort_index(ignore_index=False)", "intent": "Sort object by labels ( along an `axis` ) . With arguments `ignore_index`.", "question_id": 35039}
{"snippet": "DataFrame.sort_index(key=None)", "intent": "Sort object by labels ( along an `axis` ) . A `key` function can be specified which is applied to the index before sorting .", "question_id": 35040}
{"snippet": "DataFrame.sort_index()", "intent": "Sort object by labels ( along an `axis` ) .", "question_id": 35041}
{"snippet": "DataFrame.sort_index(axis=0)", "intent": "Sort object by labels ( along an `axis` ) .", "question_id": 35042}
{"snippet": "DataFrame.sort_index(level=None)", "intent": "Sort object by labels ( along an `axis` ) . For a MultiIndex this is applied to each `level` separately .", "question_id": 35043}
{"snippet": "DataFrame.sort_index(ascending=True)", "intent": "Sort object by labels ( along an `axis` ) . By default , it sorts in `ascending` order , to sort in descending order , use ascending=False", "question_id": 35044}
{"snippet": "DataFrame.sort_index(inplace=False)", "intent": "Sort object by labels ( along an `axis` ) . Returns a new DataFrame sorted by label if `inplace` argument is False , otherwise updates the original DataFrame and returns None .", "question_id": 35045}
{"snippet": "DataFrame.sort_index(kind='quicksort')", "intent": "Sort object by labels ( along an `axis` ) . With arguments `kind`.", "question_id": 35046}
{"snippet": "DataFrame.sort_index(na_position='last')", "intent": "Sort object by labels ( along an `axis` ) . With arguments `na_position`.", "question_id": 35047}
{"snippet": "DataFrame.sort_index(sort_remaining=True)", "intent": "Sort object by labels ( along an `axis` ) . With arguments `sort_remaining`.", "question_id": 35048}
{"snippet": "DataFrame.sort_index(ignore_index=False)", "intent": "Sort object by labels ( along an `axis` ) . With arguments `ignore_index`.", "question_id": 35049}
{"snippet": "DataFrame.sort_index(key=None)", "intent": "Sort object by labels ( along an `axis` ) . A `key` function can be specified which is applied to the index before sorting .", "question_id": 35050}
{"snippet": "DataFrame.sort_values(by)", "intent": "Sort `by` the values along either `axis` .", "question_id": 35051}
{"snippet": "DataFrame.sort_values(by, axis=0)", "intent": "Sort `by` the values along either `axis` .", "question_id": 35052}
{"snippet": "DataFrame.sort_values(by, ascending=True)", "intent": "Sort `by` the values along either `axis` . With arguments `ascending`.", "question_id": 35053}
{"snippet": "DataFrame.sort_values(by, inplace=False)", "intent": "Sort `by` the values along either `axis` . With arguments `inplace`.", "question_id": 35054}
{"snippet": "DataFrame.sort_values(by, kind='quicksort')", "intent": "Sort `by` the values along either `axis` . With arguments `kind`.", "question_id": 35055}
{"snippet": "DataFrame.sort_values(by, na_position='last')", "intent": "Sort `by` the values along either `axis` . With arguments `na_position`.", "question_id": 35056}
{"snippet": "DataFrame.sort_values(by, ignore_index=False)", "intent": "Sort `by` the values along either `axis` . With arguments `ignore_index`.", "question_id": 35057}
{"snippet": "DataFrame.sort_values(by, key=None)", "intent": "Sort `by` the values along either `axis` . Sorting with a `key` function", "question_id": 35058}
{"snippet": "DataFrame.sort_values(by, axis=0, ascending=True)", "intent": "Sort `by` the values along either `axis` . With arguments `ascending`.", "question_id": 35059}
{"snippet": "DataFrame.sort_values(by, axis=0, inplace=False)", "intent": "Sort `by` the values along either `axis` . With arguments `inplace`.", "question_id": 35060}
{"snippet": "DataFrame.sort_values(by)", "intent": "Sort `by` the values along either `axis` .", "question_id": 35061}
{"snippet": "DataFrame.sort_values(by, axis=0)", "intent": "Sort `by` the values along either `axis` .", "question_id": 35062}
{"snippet": "DataFrame.sort_values(by, ascending=True)", "intent": "Sort `by` the values along either `axis` . With arguments `ascending`.", "question_id": 35063}
{"snippet": "DataFrame.sort_values(by, inplace=False)", "intent": "Sort `by` the values along either `axis` . With arguments `inplace`.", "question_id": 35064}
{"snippet": "DataFrame.sort_values(by, kind='quicksort')", "intent": "Sort `by` the values along either `axis` . With arguments `kind`.", "question_id": 35065}
{"snippet": "DataFrame.sort_values(by, na_position='last')", "intent": "Sort `by` the values along either `axis` . With arguments `na_position`.", "question_id": 35066}
{"snippet": "DataFrame.sort_values(by, ignore_index=False)", "intent": "Sort `by` the values along either `axis` . With arguments `ignore_index`.", "question_id": 35067}
{"snippet": "DataFrame.sort_values(by, key=None)", "intent": "Sort `by` the values along either `axis` . Sorting with a `key` function", "question_id": 35068}
{"snippet": "DataFrame.sort_values(by, axis=0, ascending=True)", "intent": "Sort `by` the values along either `axis` . With arguments `ascending`.", "question_id": 35069}
{"snippet": "DataFrame.sort_values(by, axis=0, inplace=False)", "intent": "Sort `by` the values along either `axis` . With arguments `inplace`.", "question_id": 35070}
{"snippet": "DataFrame.sort_values(by)", "intent": "Sort `by` the values along either `axis` .", "question_id": 35071}
{"snippet": "DataFrame.sort_values(by, axis=0)", "intent": "Sort `by` the values along either `axis` .", "question_id": 35072}
{"snippet": "DataFrame.sort_values(by, ascending=True)", "intent": "Sort `by` the values along either `axis` . With arguments `ascending`.", "question_id": 35073}
{"snippet": "DataFrame.sort_values(by, inplace=False)", "intent": "Sort `by` the values along either `axis` . With arguments `inplace`.", "question_id": 35074}
{"snippet": "DataFrame.sort_values(by, kind='quicksort')", "intent": "Sort `by` the values along either `axis` . With arguments `kind`.", "question_id": 35075}
{"snippet": "DataFrame.sort_values(by, na_position='last')", "intent": "Sort `by` the values along either `axis` . With arguments `na_position`.", "question_id": 35076}
{"snippet": "DataFrame.sort_values(by, ignore_index=False)", "intent": "Sort `by` the values along either `axis` . With arguments `ignore_index`.", "question_id": 35077}
{"snippet": "DataFrame.sort_values(by, key=None)", "intent": "Sort `by` the values along either `axis` . Sorting with a `key` function", "question_id": 35078}
{"snippet": "DataFrame.sort_values(by, axis=0, ascending=True)", "intent": "Sort `by` the values along either `axis` . With arguments `ascending`.", "question_id": 35079}
{"snippet": "DataFrame.sort_values(by, axis=0, inplace=False)", "intent": "Sort `by` the values along either `axis` . With arguments `inplace`.", "question_id": 35080}
{"snippet": "DataFrame.sparse.density", "intent": "Ratio of non-sparse points to total (dense) data points.", "question_id": 35081}
{"snippet": "DataFrame.sparse.density", "intent": "Ratio of non-sparse points to total (dense) data points.", "question_id": 35082}
{"snippet": "DataFrame.sparse.density", "intent": "Ratio of non-sparse points to total (dense) data points.", "question_id": 35083}
{"snippet": "DataFrame.sparse.from_spmatrix(data)", "intent": "Create a new DataFrame from a scipy sparse matrix . With arguments `data`.", "question_id": 35084}
{"snippet": "DataFrame.sparse.from_spmatrix(data, index=None)", "intent": "Create a new DataFrame from a scipy sparse matrix . With arguments `data`, `index`.", "question_id": 35085}
{"snippet": "DataFrame.sparse.from_spmatrix(data, columns=None)", "intent": "Create a new DataFrame from a scipy sparse matrix . With arguments `data`, `columns`.", "question_id": 35086}
{"snippet": "DataFrame.sparse.from_spmatrix(data, index=None, columns=None)", "intent": "Create a new DataFrame from a scipy sparse matrix . With arguments `data`, `index`, `columns`.", "question_id": 35087}
{"snippet": "DataFrame.sparse.from_spmatrix(data)", "intent": "Create a new DataFrame from a scipy sparse matrix . With arguments `data`.", "question_id": 35088}
{"snippet": "DataFrame.sparse.from_spmatrix(data, index=None)", "intent": "Create a new DataFrame from a scipy sparse matrix . With arguments `data`, `index`.", "question_id": 35089}
{"snippet": "DataFrame.sparse.from_spmatrix(data, columns=None)", "intent": "Create a new DataFrame from a scipy sparse matrix . With arguments `data`, `columns`.", "question_id": 35090}
{"snippet": "DataFrame.sparse.from_spmatrix(data, index=None, columns=None)", "intent": "Create a new DataFrame from a scipy sparse matrix . With arguments `data`, `index`, `columns`.", "question_id": 35091}
{"snippet": "DataFrame.sparse.from_spmatrix(data)", "intent": "Create a new DataFrame from a scipy sparse matrix . With arguments `data`.", "question_id": 35092}
{"snippet": "DataFrame.sparse.from_spmatrix(data, index=None)", "intent": "Create a new DataFrame from a scipy sparse matrix . With arguments `data`, `index`.", "question_id": 35093}
{"snippet": "DataFrame.sparse.from_spmatrix(data, columns=None)", "intent": "Create a new DataFrame from a scipy sparse matrix . With arguments `data`, `columns`.", "question_id": 35094}
{"snippet": "DataFrame.sparse.from_spmatrix(data, index=None, columns=None)", "intent": "Create a new DataFrame from a scipy sparse matrix . With arguments `data`, `index`, `columns`.", "question_id": 35095}
{"snippet": "DataFrame.sparse()", "intent": "DataFrame accessor for sparse data .", "question_id": 35096}
{"snippet": "DataFrame.sparse()", "intent": "DataFrame accessor for sparse data .", "question_id": 35097}
{"snippet": "DataFrame.sparse()", "intent": "DataFrame accessor for sparse data .", "question_id": 35098}
{"snippet": "DataFrame.sparse.to_coo()", "intent": "Return the contents of the frame as a sparse SciPy COO matrix .", "question_id": 35099}
{"snippet": "DataFrame.sparse.to_coo()", "intent": "Return the contents of the frame as a sparse SciPy COO matrix .", "question_id": 35100}
{"snippet": "DataFrame.sparse.to_coo()", "intent": "Return the contents of the frame as a sparse SciPy COO matrix .", "question_id": 35101}
{"snippet": "DataFrame.sparse.to_dense()", "intent": "Convert a DataFrame with sparse values to dense .", "question_id": 35102}
{"snippet": "DataFrame.sparse.to_dense()", "intent": "Convert a DataFrame with sparse values to dense .", "question_id": 35103}
{"snippet": "DataFrame.sparse.to_dense()", "intent": "Convert a DataFrame with sparse values to dense .", "question_id": 35104}
{"snippet": "DataFrame.squeeze()", "intent": "Squeeze 1 dimensional `axis` objects into scalars .", "question_id": 35105}
{"snippet": "DataFrame.squeeze(axis=None)", "intent": "Squeeze 1 dimensional `axis` objects into scalars .", "question_id": 35106}
{"snippet": "DataFrame.squeeze()", "intent": "Squeeze 1 dimensional `axis` objects into scalars .", "question_id": 35107}
{"snippet": "DataFrame.squeeze(axis=None)", "intent": "Squeeze 1 dimensional `axis` objects into scalars .", "question_id": 35108}
{"snippet": "DataFrame.squeeze()", "intent": "Squeeze 1 dimensional `axis` objects into scalars .", "question_id": 35109}
{"snippet": "DataFrame.squeeze(axis=None)", "intent": "Squeeze 1 dimensional `axis` objects into scalars .", "question_id": 35110}
{"snippet": "DataFrame.stack()", "intent": "Stack the prescribed `level` ( s ) from columns to index .", "question_id": 35111}
{"snippet": "DataFrame.stack(level=- 1)", "intent": "Stack the prescribed `level` ( s ) from columns to index .", "question_id": 35112}
{"snippet": "DataFrame.stack(dropna=True)", "intent": "Stack the prescribed `level` ( s ) from columns to index . Note that rows where all values are missing are dropped by default but this behaviour can be controlled via the `dropna` keyword parameter :", "question_id": 35113}
{"snippet": "DataFrame.stack(level=- 1, dropna=True)", "intent": "Stack the prescribed `level` ( s ) from columns to index . Note that rows where all values are missing are dropped by default but this behaviour can be controlled via the `dropna` keyword parameter :", "question_id": 35114}
{"snippet": "DataFrame.stack()", "intent": "Stack the prescribed `level` ( s ) from columns to index .", "question_id": 35115}
{"snippet": "DataFrame.stack(level=- 1)", "intent": "Stack the prescribed `level` ( s ) from columns to index .", "question_id": 35116}
{"snippet": "DataFrame.stack(dropna=True)", "intent": "Stack the prescribed `level` ( s ) from columns to index . Note that rows where all values are missing are dropped by default but this behaviour can be controlled via the `dropna` keyword parameter :", "question_id": 35117}
{"snippet": "DataFrame.stack(level=- 1, dropna=True)", "intent": "Stack the prescribed `level` ( s ) from columns to index . Note that rows where all values are missing are dropped by default but this behaviour can be controlled via the `dropna` keyword parameter :", "question_id": 35118}
{"snippet": "DataFrame.stack()", "intent": "Stack the prescribed `level` ( s ) from columns to index .", "question_id": 35119}
{"snippet": "DataFrame.stack(level=- 1)", "intent": "Stack the prescribed `level` ( s ) from columns to index .", "question_id": 35120}
{"snippet": "DataFrame.stack(dropna=True)", "intent": "Stack the prescribed `level` ( s ) from columns to index . Note that rows where all values are missing are dropped by default but this behaviour can be controlled via the `dropna` keyword parameter :", "question_id": 35121}
{"snippet": "DataFrame.stack(level=- 1, dropna=True)", "intent": "Stack the prescribed `level` ( s ) from columns to index . Note that rows where all values are missing are dropped by default but this behaviour can be controlled via the `dropna` keyword parameter :", "question_id": 35122}
{"snippet": "DataFrame.std(**kwargs)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`.", "question_id": 35123}
{"snippet": "DataFrame.std(**kwargs, axis=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`.", "question_id": 35124}
{"snippet": "DataFrame.std(**kwargs, skipna=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 35125}
{"snippet": "DataFrame.std(**kwargs, level=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 35126}
{"snippet": "DataFrame.std(**kwargs, ddof=1)", "intent": "Return sample standard deviation over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 35127}
{"snippet": "DataFrame.std(**kwargs, numeric_only=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 35128}
{"snippet": "DataFrame.std(**kwargs, axis=None, skipna=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 35129}
{"snippet": "DataFrame.std(**kwargs, axis=None, level=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 35130}
{"snippet": "DataFrame.std(**kwargs, axis=None, ddof=1)", "intent": "Return sample standard deviation over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 35131}
{"snippet": "DataFrame.std(**kwargs, axis=None, numeric_only=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 35132}
{"snippet": "DataFrame.std(**kwargs)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`.", "question_id": 35133}
{"snippet": "DataFrame.std(**kwargs, axis=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`.", "question_id": 35134}
{"snippet": "DataFrame.std(**kwargs, skipna=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 35135}
{"snippet": "DataFrame.std(**kwargs, level=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 35136}
{"snippet": "DataFrame.std(**kwargs, ddof=1)", "intent": "Return sample standard deviation over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 35137}
{"snippet": "DataFrame.std(**kwargs, numeric_only=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 35138}
{"snippet": "DataFrame.std(**kwargs, axis=None, skipna=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 35139}
{"snippet": "DataFrame.std(**kwargs, axis=None, level=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 35140}
{"snippet": "DataFrame.std(**kwargs, axis=None, ddof=1)", "intent": "Return sample standard deviation over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 35141}
{"snippet": "DataFrame.std(**kwargs, axis=None, numeric_only=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 35142}
{"snippet": "DataFrame.std(**kwargs)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`.", "question_id": 35143}
{"snippet": "DataFrame.std(**kwargs, axis=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`.", "question_id": 35144}
{"snippet": "DataFrame.std(**kwargs, skipna=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 35145}
{"snippet": "DataFrame.std(**kwargs, level=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 35146}
{"snippet": "DataFrame.std(**kwargs, ddof=1)", "intent": "Return sample standard deviation over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 35147}
{"snippet": "DataFrame.std(**kwargs, numeric_only=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 35148}
{"snippet": "DataFrame.std(**kwargs, axis=None, skipna=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 35149}
{"snippet": "DataFrame.std(**kwargs, axis=None, level=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 35150}
{"snippet": "DataFrame.std(**kwargs, axis=None, ddof=1)", "intent": "Return sample standard deviation over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 35151}
{"snippet": "DataFrame.std(**kwargs, axis=None, numeric_only=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 35152}
{"snippet": "DataFrame.sub(other)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) .", "question_id": 35153}
{"snippet": "DataFrame.sub(other, axis='columns')", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Subtract a list and Series by `axis` with operator version .", "question_id": 35154}
{"snippet": "DataFrame.sub(other, level=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Divide by a MultiIndex by `level` .", "question_id": 35155}
{"snippet": "DataFrame.sub(other, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Equivalent to dataframe - other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35156}
{"snippet": "DataFrame.sub(other, axis='columns', level=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 35157}
{"snippet": "DataFrame.sub(other, axis='columns', fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe - other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35158}
{"snippet": "DataFrame.sub(other, level=None, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Divide by a MultiIndex by `level` . Equivalent to dataframe - other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35159}
{"snippet": "DataFrame.sub(other, axis='columns', level=None, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe - other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35160}
{"snippet": "DataFrame.sub(other)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) .", "question_id": 35161}
{"snippet": "DataFrame.sub(other, axis='columns')", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Subtract a list and Series by `axis` with operator version .", "question_id": 35162}
{"snippet": "DataFrame.sub(other, level=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Divide by a MultiIndex by `level` .", "question_id": 35163}
{"snippet": "DataFrame.sub(other, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Equivalent to dataframe - other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35164}
{"snippet": "DataFrame.sub(other, axis='columns', level=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 35165}
{"snippet": "DataFrame.sub(other, axis='columns', fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe - other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35166}
{"snippet": "DataFrame.sub(other, level=None, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Divide by a MultiIndex by `level` . Equivalent to dataframe - other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35167}
{"snippet": "DataFrame.sub(other, axis='columns', level=None, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe - other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35168}
{"snippet": "DataFrame.sub(other)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) .", "question_id": 35169}
{"snippet": "DataFrame.sub(other, axis='columns')", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Subtract a list and Series by `axis` with operator version .", "question_id": 35170}
{"snippet": "DataFrame.sub(other, level=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Divide by a MultiIndex by `level` .", "question_id": 35171}
{"snippet": "DataFrame.sub(other, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Equivalent to dataframe - other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35172}
{"snippet": "DataFrame.sub(other, axis='columns', level=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 35173}
{"snippet": "DataFrame.sub(other, axis='columns', fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe - other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35174}
{"snippet": "DataFrame.sub(other, level=None, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Divide by a MultiIndex by `level` . Equivalent to dataframe - other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35175}
{"snippet": "DataFrame.sub(other, axis='columns', level=None, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe - other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35176}
{"snippet": "DataFrame.subtract(other)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) .", "question_id": 35177}
{"snippet": "DataFrame.subtract(other, axis='columns')", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Subtract a list and Series by `axis` with operator version .", "question_id": 35178}
{"snippet": "DataFrame.subtract(other, level=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Divide by a MultiIndex by `level` .", "question_id": 35179}
{"snippet": "DataFrame.subtract(other, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Equivalent to dataframe - other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35180}
{"snippet": "DataFrame.subtract(other, axis='columns', level=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 35181}
{"snippet": "DataFrame.subtract(other, axis='columns', fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe - other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35182}
{"snippet": "DataFrame.subtract(other, level=None, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Divide by a MultiIndex by `level` . Equivalent to dataframe - other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35183}
{"snippet": "DataFrame.subtract(other, axis='columns', level=None, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe - other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35184}
{"snippet": "DataFrame.subtract(other)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) .", "question_id": 35185}
{"snippet": "DataFrame.subtract(other, axis='columns')", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Subtract a list and Series by `axis` with operator version .", "question_id": 35186}
{"snippet": "DataFrame.subtract(other, level=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Divide by a MultiIndex by `level` .", "question_id": 35187}
{"snippet": "DataFrame.subtract(other, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Equivalent to dataframe - other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35188}
{"snippet": "DataFrame.subtract(other, axis='columns', level=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 35189}
{"snippet": "DataFrame.subtract(other, axis='columns', fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe - other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35190}
{"snippet": "DataFrame.subtract(other, level=None, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Divide by a MultiIndex by `level` . Equivalent to dataframe - other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35191}
{"snippet": "DataFrame.subtract(other, axis='columns', level=None, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe - other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35192}
{"snippet": "DataFrame.subtract(other)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) .", "question_id": 35193}
{"snippet": "DataFrame.subtract(other, axis='columns')", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Subtract a list and Series by `axis` with operator version .", "question_id": 35194}
{"snippet": "DataFrame.subtract(other, level=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Divide by a MultiIndex by `level` .", "question_id": 35195}
{"snippet": "DataFrame.subtract(other, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Equivalent to dataframe - other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35196}
{"snippet": "DataFrame.subtract(other, axis='columns', level=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 35197}
{"snippet": "DataFrame.subtract(other, axis='columns', fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe - other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35198}
{"snippet": "DataFrame.subtract(other, level=None, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Divide by a MultiIndex by `level` . Equivalent to dataframe - other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35199}
{"snippet": "DataFrame.subtract(other, axis='columns', level=None, fill_value=None)", "intent": "Get Subtraction of dataframe and `other` , element-wise ( binary operator sub ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe - other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35200}
{"snippet": "DataFrame.sum(**kwargs)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 35201}
{"snippet": "DataFrame.sum(**kwargs, axis=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 35202}
{"snippet": "DataFrame.sum(**kwargs, skipna=None)", "intent": "Return the sum of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 35203}
{"snippet": "DataFrame.sum(**kwargs, level=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 35204}
{"snippet": "DataFrame.sum(**kwargs, numeric_only=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 35205}
{"snippet": "DataFrame.sum(**kwargs, min_count=0)", "intent": "Return the sum of the values over the requested `axis` . This can be controlled with the `min_count` parameter . With arguments `**kwargs`.", "question_id": 35206}
{"snippet": "DataFrame.sum(**kwargs, axis=None, skipna=None)", "intent": "Return the sum of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 35207}
{"snippet": "DataFrame.sum(**kwargs, axis=None, level=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 35208}
{"snippet": "DataFrame.sum(**kwargs, axis=None, numeric_only=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 35209}
{"snippet": "DataFrame.sum(**kwargs, axis=None, min_count=0)", "intent": "Return the sum of the values over the requested `axis` . This can be controlled with the `min_count` parameter . With arguments `**kwargs`.", "question_id": 35210}
{"snippet": "DataFrame.sum(**kwargs)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 35211}
{"snippet": "DataFrame.sum(**kwargs, axis=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 35212}
{"snippet": "DataFrame.sum(**kwargs, skipna=None)", "intent": "Return the sum of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 35213}
{"snippet": "DataFrame.sum(**kwargs, level=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 35214}
{"snippet": "DataFrame.sum(**kwargs, numeric_only=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 35215}
{"snippet": "DataFrame.sum(**kwargs, min_count=0)", "intent": "Return the sum of the values over the requested `axis` . This can be controlled with the `min_count` parameter . With arguments `**kwargs`.", "question_id": 35216}
{"snippet": "DataFrame.sum(**kwargs, axis=None, skipna=None)", "intent": "Return the sum of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 35217}
{"snippet": "DataFrame.sum(**kwargs, axis=None, level=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 35218}
{"snippet": "DataFrame.sum(**kwargs, axis=None, numeric_only=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 35219}
{"snippet": "DataFrame.sum(**kwargs, axis=None, min_count=0)", "intent": "Return the sum of the values over the requested `axis` . This can be controlled with the `min_count` parameter . With arguments `**kwargs`.", "question_id": 35220}
{"snippet": "DataFrame.sum(**kwargs)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 35221}
{"snippet": "DataFrame.sum(**kwargs, axis=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 35222}
{"snippet": "DataFrame.sum(**kwargs, skipna=None)", "intent": "Return the sum of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 35223}
{"snippet": "DataFrame.sum(**kwargs, level=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 35224}
{"snippet": "DataFrame.sum(**kwargs, numeric_only=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 35225}
{"snippet": "DataFrame.sum(**kwargs, min_count=0)", "intent": "Return the sum of the values over the requested `axis` . This can be controlled with the `min_count` parameter . With arguments `**kwargs`.", "question_id": 35226}
{"snippet": "DataFrame.sum(**kwargs, axis=None, skipna=None)", "intent": "Return the sum of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 35227}
{"snippet": "DataFrame.sum(**kwargs, axis=None, level=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 35228}
{"snippet": "DataFrame.sum(**kwargs, axis=None, numeric_only=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 35229}
{"snippet": "DataFrame.sum(**kwargs, axis=None, min_count=0)", "intent": "Return the sum of the values over the requested `axis` . This can be controlled with the `min_count` parameter . With arguments `**kwargs`.", "question_id": 35230}
{"snippet": "DataFrame.swapaxes(axis1, axis2)", "intent": "Interchange axes and swap values axes appropriately . With arguments `axis1`, `axis2`.", "question_id": 35231}
{"snippet": "DataFrame.swapaxes(axis1, axis2, copy=True)", "intent": "Interchange axes and swap values axes appropriately . With arguments `axis1`, `axis2`, `copy`.", "question_id": 35232}
{"snippet": "DataFrame.swapaxes(axis1, axis2)", "intent": "Interchange axes and swap values axes appropriately . With arguments `axis1`, `axis2`.", "question_id": 35233}
{"snippet": "DataFrame.swapaxes(axis1, axis2, copy=True)", "intent": "Interchange axes and swap values axes appropriately . With arguments `axis1`, `axis2`, `copy`.", "question_id": 35234}
{"snippet": "DataFrame.swapaxes(axis1, axis2)", "intent": "Interchange axes and swap values axes appropriately . With arguments `axis1`, `axis2`.", "question_id": 35235}
{"snippet": "DataFrame.swapaxes(axis1, axis2, copy=True)", "intent": "Interchange axes and swap values axes appropriately . With arguments `axis1`, `axis2`, `copy`.", "question_id": 35236}
{"snippet": "DataFrame.swaplevel()", "intent": "Swap levels `i` and `j` in a MultiIndex .", "question_id": 35237}
{"snippet": "DataFrame.swaplevel(i=- 2)", "intent": "Swap levels `i` and `j` in a MultiIndex .", "question_id": 35238}
{"snippet": "DataFrame.swaplevel(j=- 1)", "intent": "Swap levels `i` and `j` in a MultiIndex .", "question_id": 35239}
{"snippet": "DataFrame.swaplevel(axis=0)", "intent": "Swap levels `i` and `j` in a MultiIndex . With arguments `axis`.", "question_id": 35240}
{"snippet": "DataFrame.swaplevel(i=- 2, j=- 1)", "intent": "Swap levels `i` and `j` in a MultiIndex .", "question_id": 35241}
{"snippet": "DataFrame.swaplevel(i=- 2, axis=0)", "intent": "Swap levels `i` and `j` in a MultiIndex . With arguments `axis`.", "question_id": 35242}
{"snippet": "DataFrame.swaplevel(j=- 1, axis=0)", "intent": "Swap levels `i` and `j` in a MultiIndex . With arguments `axis`.", "question_id": 35243}
{"snippet": "DataFrame.swaplevel(i=- 2, j=- 1, axis=0)", "intent": "Swap levels `i` and `j` in a MultiIndex . With arguments `axis`.", "question_id": 35244}
{"snippet": "DataFrame.swaplevel()", "intent": "Swap levels `i` and `j` in a MultiIndex .", "question_id": 35245}
{"snippet": "DataFrame.swaplevel(i=- 2)", "intent": "Swap levels `i` and `j` in a MultiIndex .", "question_id": 35246}
{"snippet": "DataFrame.swaplevel(j=- 1)", "intent": "Swap levels `i` and `j` in a MultiIndex .", "question_id": 35247}
{"snippet": "DataFrame.swaplevel(axis=0)", "intent": "Swap levels `i` and `j` in a MultiIndex . With arguments `axis`.", "question_id": 35248}
{"snippet": "DataFrame.swaplevel(i=- 2, j=- 1)", "intent": "Swap levels `i` and `j` in a MultiIndex .", "question_id": 35249}
{"snippet": "DataFrame.swaplevel(i=- 2, axis=0)", "intent": "Swap levels `i` and `j` in a MultiIndex . With arguments `axis`.", "question_id": 35250}
{"snippet": "DataFrame.swaplevel(j=- 1, axis=0)", "intent": "Swap levels `i` and `j` in a MultiIndex . With arguments `axis`.", "question_id": 35251}
{"snippet": "DataFrame.swaplevel(i=- 2, j=- 1, axis=0)", "intent": "Swap levels `i` and `j` in a MultiIndex . With arguments `axis`.", "question_id": 35252}
{"snippet": "DataFrame.swaplevel()", "intent": "Swap levels `i` and `j` in a MultiIndex .", "question_id": 35253}
{"snippet": "DataFrame.swaplevel(i=- 2)", "intent": "Swap levels `i` and `j` in a MultiIndex .", "question_id": 35254}
{"snippet": "DataFrame.swaplevel(j=- 1)", "intent": "Swap levels `i` and `j` in a MultiIndex .", "question_id": 35255}
{"snippet": "DataFrame.swaplevel(axis=0)", "intent": "Swap levels `i` and `j` in a MultiIndex . With arguments `axis`.", "question_id": 35256}
{"snippet": "DataFrame.swaplevel(i=- 2, j=- 1)", "intent": "Swap levels `i` and `j` in a MultiIndex .", "question_id": 35257}
{"snippet": "DataFrame.swaplevel(i=- 2, axis=0)", "intent": "Swap levels `i` and `j` in a MultiIndex . With arguments `axis`.", "question_id": 35258}
{"snippet": "DataFrame.swaplevel(j=- 1, axis=0)", "intent": "Swap levels `i` and `j` in a MultiIndex . With arguments `axis`.", "question_id": 35259}
{"snippet": "DataFrame.swaplevel(i=- 2, j=- 1, axis=0)", "intent": "Swap levels `i` and `j` in a MultiIndex . With arguments `axis`.", "question_id": 35260}
{"snippet": "DataFrame.tail()", "intent": "Return the last `n` rows .", "question_id": 35261}
{"snippet": "DataFrame.tail(n=5)", "intent": "Return the last `n` rows .", "question_id": 35262}
{"snippet": "DataFrame.tail()", "intent": "Return the last `n` rows .", "question_id": 35263}
{"snippet": "DataFrame.tail(n=5)", "intent": "Return the last `n` rows .", "question_id": 35264}
{"snippet": "DataFrame.tail()", "intent": "Return the last `n` rows .", "question_id": 35265}
{"snippet": "DataFrame.tail(n=5)", "intent": "Return the last `n` rows .", "question_id": 35266}
{"snippet": "DataFrame.take(indices, **kwargs)", "intent": "Return the elements in the given positional `indices` along an `axis` . With arguments `**kwargs`.", "question_id": 35267}
{"snippet": "DataFrame.take(indices, **kwargs, axis=0)", "intent": "Return the elements in the given positional `indices` along an `axis` . With arguments `**kwargs`.", "question_id": 35268}
{"snippet": "DataFrame.take(indices, **kwargs, is_copy=None)", "intent": "Return the elements in the given positional `indices` along an `axis` . With arguments `**kwargs`, `is_copy`.", "question_id": 35269}
{"snippet": "DataFrame.take(indices, **kwargs, axis=0, is_copy=None)", "intent": "Return the elements in the given positional `indices` along an `axis` . With arguments `**kwargs`, `is_copy`.", "question_id": 35270}
{"snippet": "DataFrame.take(indices, **kwargs)", "intent": "Return the elements in the given positional `indices` along an `axis` . With arguments `**kwargs`.", "question_id": 35271}
{"snippet": "DataFrame.take(indices, **kwargs, axis=0)", "intent": "Return the elements in the given positional `indices` along an `axis` . With arguments `**kwargs`.", "question_id": 35272}
{"snippet": "DataFrame.take(indices, **kwargs, is_copy=None)", "intent": "Return the elements in the given positional `indices` along an `axis` . With arguments `**kwargs`, `is_copy`.", "question_id": 35273}
{"snippet": "DataFrame.take(indices, **kwargs, axis=0, is_copy=None)", "intent": "Return the elements in the given positional `indices` along an `axis` . With arguments `**kwargs`, `is_copy`.", "question_id": 35274}
{"snippet": "DataFrame.take(indices, **kwargs)", "intent": "Return the elements in the given positional `indices` along an `axis` . With arguments `**kwargs`.", "question_id": 35275}
{"snippet": "DataFrame.take(indices, **kwargs, axis=0)", "intent": "Return the elements in the given positional `indices` along an `axis` . With arguments `**kwargs`.", "question_id": 35276}
{"snippet": "DataFrame.take(indices, **kwargs, is_copy=None)", "intent": "Return the elements in the given positional `indices` along an `axis` . With arguments `**kwargs`, `is_copy`.", "question_id": 35277}
{"snippet": "DataFrame.take(indices, **kwargs, axis=0, is_copy=None)", "intent": "Return the elements in the given positional `indices` along an `axis` . With arguments `**kwargs`, `is_copy`.", "question_id": 35278}
{"snippet": "DataFrame.to_clipboard(**kwargs)", "intent": "Copy object to the system clipboard . With arguments `**kwargs`.", "question_id": 35279}
{"snippet": "DataFrame.to_clipboard(**kwargs, excel=True)", "intent": "Copy object to the system clipboard . With arguments `**kwargs`, `excel`.", "question_id": 35280}
{"snippet": "DataFrame.to_clipboard(**kwargs, sep=None)", "intent": "Copy object to the system clipboard . With arguments `**kwargs`, `sep`.", "question_id": 35281}
{"snippet": "DataFrame.to_clipboard(**kwargs, excel=True, sep=None)", "intent": "Copy object to the system clipboard . With arguments `**kwargs`, `excel`, `sep`.", "question_id": 35282}
{"snippet": "DataFrame.to_clipboard(**kwargs)", "intent": "Copy object to the system clipboard . With arguments `**kwargs`.", "question_id": 35283}
{"snippet": "DataFrame.to_clipboard(**kwargs, excel=True)", "intent": "Copy object to the system clipboard . With arguments `**kwargs`, `excel`.", "question_id": 35284}
{"snippet": "DataFrame.to_clipboard(**kwargs, sep=None)", "intent": "Copy object to the system clipboard . With arguments `**kwargs`, `sep`.", "question_id": 35285}
{"snippet": "DataFrame.to_clipboard(**kwargs, excel=True, sep=None)", "intent": "Copy object to the system clipboard . With arguments `**kwargs`, `excel`, `sep`.", "question_id": 35286}
{"snippet": "DataFrame.to_clipboard(**kwargs)", "intent": "Copy object to the system clipboard . With arguments `**kwargs`.", "question_id": 35287}
{"snippet": "DataFrame.to_clipboard(**kwargs, excel=True)", "intent": "Copy object to the system clipboard . With arguments `**kwargs`, `excel`.", "question_id": 35288}
{"snippet": "DataFrame.to_clipboard(**kwargs, sep=None)", "intent": "Copy object to the system clipboard . With arguments `**kwargs`, `sep`.", "question_id": 35289}
{"snippet": "DataFrame.to_clipboard(**kwargs, excel=True, sep=None)", "intent": "Copy object to the system clipboard . With arguments `**kwargs`, `excel`, `sep`.", "question_id": 35290}
{"snippet": "DataFrame.to_csv()", "intent": "Write object to a comma-separated values ( csv ) file .", "question_id": 35291}
{"snippet": "DataFrame.to_csv(path_or_buf=None)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `path_or_buf`.", "question_id": 35292}
{"snippet": "DataFrame.to_csv(sep=',')", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `sep`.", "question_id": 35293}
{"snippet": "DataFrame.to_csv(na_rep='')", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `na_rep`.", "question_id": 35294}
{"snippet": "DataFrame.to_csv(float_format=None)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `float_format`.", "question_id": 35295}
{"snippet": "DataFrame.to_csv(columns=None)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `columns`.", "question_id": 35296}
{"snippet": "DataFrame.to_csv(header=True)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `header`.", "question_id": 35297}
{"snippet": "DataFrame.to_csv(index=True)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `index`.", "question_id": 35298}
{"snippet": "DataFrame.to_csv(index_label=None)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `index_label`.", "question_id": 35299}
{"snippet": "DataFrame.to_csv(mode='w')", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `mode`.", "question_id": 35300}
{"snippet": "DataFrame.to_csv()", "intent": "Write object to a comma-separated values ( csv ) file .", "question_id": 35301}
{"snippet": "DataFrame.to_csv(path_or_buf=None)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `path_or_buf`.", "question_id": 35302}
{"snippet": "DataFrame.to_csv(sep=',')", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `sep`.", "question_id": 35303}
{"snippet": "DataFrame.to_csv(na_rep='')", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `na_rep`.", "question_id": 35304}
{"snippet": "DataFrame.to_csv(float_format=None)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `float_format`.", "question_id": 35305}
{"snippet": "DataFrame.to_csv(columns=None)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `columns`.", "question_id": 35306}
{"snippet": "DataFrame.to_csv(header=True)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `header`.", "question_id": 35307}
{"snippet": "DataFrame.to_csv(index=True)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `index`.", "question_id": 35308}
{"snippet": "DataFrame.to_csv(index_label=None)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `index_label`.", "question_id": 35309}
{"snippet": "DataFrame.to_csv(mode='w')", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `mode`.", "question_id": 35310}
{"snippet": "DataFrame.to_csv()", "intent": "Write object to a comma-separated values ( csv ) file .", "question_id": 35311}
{"snippet": "DataFrame.to_csv(path_or_buf=None)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `path_or_buf`.", "question_id": 35312}
{"snippet": "DataFrame.to_csv(sep=',')", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `sep`.", "question_id": 35313}
{"snippet": "DataFrame.to_csv(na_rep='')", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `na_rep`.", "question_id": 35314}
{"snippet": "DataFrame.to_csv(float_format=None)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `float_format`.", "question_id": 35315}
{"snippet": "DataFrame.to_csv(columns=None)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `columns`.", "question_id": 35316}
{"snippet": "DataFrame.to_csv(header=True)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `header`.", "question_id": 35317}
{"snippet": "DataFrame.to_csv(index=True)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `index`.", "question_id": 35318}
{"snippet": "DataFrame.to_csv(index_label=None)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `index_label`.", "question_id": 35319}
{"snippet": "DataFrame.to_csv(mode='w')", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `mode`.", "question_id": 35320}
{"snippet": "DataFrame.to_dict()", "intent": "Convert the DataFrame to a dictionary .", "question_id": 35321}
{"snippet": "DataFrame.to_dict(orient='dict')", "intent": "Convert the DataFrame to a dictionary . With arguments `orient`.", "question_id": 35322}
{"snippet": "DataFrame.to_dict(into=<class 'dict'>)", "intent": "Convert the DataFrame to a dictionary . With arguments `into`.", "question_id": 35323}
{"snippet": "DataFrame.to_dict(orient='dict', into=<class 'dict'>)", "intent": "Convert the DataFrame to a dictionary . With arguments `orient`, `into`.", "question_id": 35324}
{"snippet": "DataFrame.to_dict()", "intent": "Convert the DataFrame to a dictionary .", "question_id": 35325}
{"snippet": "DataFrame.to_dict(orient='dict')", "intent": "Convert the DataFrame to a dictionary . With arguments `orient`.", "question_id": 35326}
{"snippet": "DataFrame.to_dict(into=<class 'dict'>)", "intent": "Convert the DataFrame to a dictionary . With arguments `into`.", "question_id": 35327}
{"snippet": "DataFrame.to_dict(orient='dict', into=<class 'dict'>)", "intent": "Convert the DataFrame to a dictionary . With arguments `orient`, `into`.", "question_id": 35328}
{"snippet": "DataFrame.to_dict()", "intent": "Convert the DataFrame to a dictionary .", "question_id": 35329}
{"snippet": "DataFrame.to_dict(orient='dict')", "intent": "Convert the DataFrame to a dictionary . With arguments `orient`.", "question_id": 35330}
{"snippet": "DataFrame.to_dict(into=<class 'dict'>)", "intent": "Convert the DataFrame to a dictionary . With arguments `into`.", "question_id": 35331}
{"snippet": "DataFrame.to_dict(orient='dict', into=<class 'dict'>)", "intent": "Convert the DataFrame to a dictionary . With arguments `orient`, `into`.", "question_id": 35332}
{"snippet": "DataFrame.to_excel(excel_writer)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`.", "question_id": 35333}
{"snippet": "DataFrame.to_excel(excel_writer, sheet_name='Sheet1')", "intent": "Write object to an Excel sheet . Multiple sheets may be written to by specifying unique `sheet_name` . With arguments `excel_writer`.", "question_id": 35334}
{"snippet": "DataFrame.to_excel(excel_writer, na_rep='')", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `na_rep`.", "question_id": 35335}
{"snippet": "DataFrame.to_excel(excel_writer, float_format=None)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `float_format`.", "question_id": 35336}
{"snippet": "DataFrame.to_excel(excel_writer, columns=None)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `columns`.", "question_id": 35337}
{"snippet": "DataFrame.to_excel(excel_writer, header=True)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `header`.", "question_id": 35338}
{"snippet": "DataFrame.to_excel(excel_writer, index=True)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `index`.", "question_id": 35339}
{"snippet": "DataFrame.to_excel(excel_writer, index_label=None)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `index_label`.", "question_id": 35340}
{"snippet": "DataFrame.to_excel(excel_writer, startrow=0)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `startrow`.", "question_id": 35341}
{"snippet": "DataFrame.to_excel(excel_writer, startcol=0)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `startcol`.", "question_id": 35342}
{"snippet": "DataFrame.to_excel(excel_writer)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`.", "question_id": 35343}
{"snippet": "DataFrame.to_excel(excel_writer, sheet_name='Sheet1')", "intent": "Write object to an Excel sheet . Multiple sheets may be written to by specifying unique `sheet_name` . With arguments `excel_writer`.", "question_id": 35344}
{"snippet": "DataFrame.to_excel(excel_writer, na_rep='')", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `na_rep`.", "question_id": 35345}
{"snippet": "DataFrame.to_excel(excel_writer, float_format=None)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `float_format`.", "question_id": 35346}
{"snippet": "DataFrame.to_excel(excel_writer, columns=None)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `columns`.", "question_id": 35347}
{"snippet": "DataFrame.to_excel(excel_writer, header=True)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `header`.", "question_id": 35348}
{"snippet": "DataFrame.to_excel(excel_writer, index=True)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `index`.", "question_id": 35349}
{"snippet": "DataFrame.to_excel(excel_writer, index_label=None)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `index_label`.", "question_id": 35350}
{"snippet": "DataFrame.to_excel(excel_writer, startrow=0)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `startrow`.", "question_id": 35351}
{"snippet": "DataFrame.to_excel(excel_writer, startcol=0)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `startcol`.", "question_id": 35352}
{"snippet": "DataFrame.to_excel(excel_writer)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`.", "question_id": 35353}
{"snippet": "DataFrame.to_excel(excel_writer, sheet_name='Sheet1')", "intent": "Write object to an Excel sheet . Multiple sheets may be written to by specifying unique `sheet_name` . With arguments `excel_writer`.", "question_id": 35354}
{"snippet": "DataFrame.to_excel(excel_writer, na_rep='')", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `na_rep`.", "question_id": 35355}
{"snippet": "DataFrame.to_excel(excel_writer, float_format=None)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `float_format`.", "question_id": 35356}
{"snippet": "DataFrame.to_excel(excel_writer, columns=None)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `columns`.", "question_id": 35357}
{"snippet": "DataFrame.to_excel(excel_writer, header=True)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `header`.", "question_id": 35358}
{"snippet": "DataFrame.to_excel(excel_writer, index=True)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `index`.", "question_id": 35359}
{"snippet": "DataFrame.to_excel(excel_writer, index_label=None)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `index_label`.", "question_id": 35360}
{"snippet": "DataFrame.to_excel(excel_writer, startrow=0)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `startrow`.", "question_id": 35361}
{"snippet": "DataFrame.to_excel(excel_writer, startcol=0)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `startcol`.", "question_id": 35362}
{"snippet": "DataFrame.to_feather(path, **kwargs)", "intent": "Write a DataFrame to the binary Feather format . With arguments `path`, `**kwargs`.", "question_id": 35363}
{"snippet": "DataFrame.to_feather(path, **kwargs)", "intent": "Write a DataFrame to the binary Feather format . With arguments `path`, `**kwargs`.", "question_id": 35364}
{"snippet": "DataFrame.to_feather(path, **kwargs)", "intent": "Write a DataFrame to the binary Feather format . With arguments `path`, `**kwargs`.", "question_id": 35365}
{"snippet": "DataFrame.to_gbq(destination_table)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`.", "question_id": 35366}
{"snippet": "DataFrame.to_gbq(destination_table, project_id=None)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `project_id`.", "question_id": 35367}
{"snippet": "DataFrame.to_gbq(destination_table, chunksize=None)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `chunksize`.", "question_id": 35368}
{"snippet": "DataFrame.to_gbq(destination_table, reauth=False)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `reauth`.", "question_id": 35369}
{"snippet": "DataFrame.to_gbq(destination_table, if_exists='fail')", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `if_exists`.", "question_id": 35370}
{"snippet": "DataFrame.to_gbq(destination_table, auth_local_webserver=False)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `auth_local_webserver`.", "question_id": 35371}
{"snippet": "DataFrame.to_gbq(destination_table, table_schema=None)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `table_schema`.", "question_id": 35372}
{"snippet": "DataFrame.to_gbq(destination_table, location=None)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `location`.", "question_id": 35373}
{"snippet": "DataFrame.to_gbq(destination_table, progress_bar=True)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `progress_bar`.", "question_id": 35374}
{"snippet": "DataFrame.to_gbq(destination_table, credentials=None)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `credentials`.", "question_id": 35375}
{"snippet": "DataFrame.to_gbq(destination_table)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`.", "question_id": 35376}
{"snippet": "DataFrame.to_gbq(destination_table, project_id=None)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `project_id`.", "question_id": 35377}
{"snippet": "DataFrame.to_gbq(destination_table, chunksize=None)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `chunksize`.", "question_id": 35378}
{"snippet": "DataFrame.to_gbq(destination_table, reauth=False)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `reauth`.", "question_id": 35379}
{"snippet": "DataFrame.to_gbq(destination_table, if_exists='fail')", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `if_exists`.", "question_id": 35380}
{"snippet": "DataFrame.to_gbq(destination_table, auth_local_webserver=False)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `auth_local_webserver`.", "question_id": 35381}
{"snippet": "DataFrame.to_gbq(destination_table, table_schema=None)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `table_schema`.", "question_id": 35382}
{"snippet": "DataFrame.to_gbq(destination_table, location=None)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `location`.", "question_id": 35383}
{"snippet": "DataFrame.to_gbq(destination_table, progress_bar=True)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `progress_bar`.", "question_id": 35384}
{"snippet": "DataFrame.to_gbq(destination_table, credentials=None)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `credentials`.", "question_id": 35385}
{"snippet": "DataFrame.to_gbq(destination_table)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`.", "question_id": 35386}
{"snippet": "DataFrame.to_gbq(destination_table, project_id=None)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `project_id`.", "question_id": 35387}
{"snippet": "DataFrame.to_gbq(destination_table, chunksize=None)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `chunksize`.", "question_id": 35388}
{"snippet": "DataFrame.to_gbq(destination_table, reauth=False)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `reauth`.", "question_id": 35389}
{"snippet": "DataFrame.to_gbq(destination_table, if_exists='fail')", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `if_exists`.", "question_id": 35390}
{"snippet": "DataFrame.to_gbq(destination_table, auth_local_webserver=False)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `auth_local_webserver`.", "question_id": 35391}
{"snippet": "DataFrame.to_gbq(destination_table, table_schema=None)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `table_schema`.", "question_id": 35392}
{"snippet": "DataFrame.to_gbq(destination_table, location=None)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `location`.", "question_id": 35393}
{"snippet": "DataFrame.to_gbq(destination_table, progress_bar=True)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `progress_bar`.", "question_id": 35394}
{"snippet": "DataFrame.to_gbq(destination_table, credentials=None)", "intent": "Write a DataFrame to a Google BigQuery table . With arguments `destination_table`, `credentials`.", "question_id": 35395}
{"snippet": "DataFrame.to_hdf(path_or_buf, key)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`.", "question_id": 35396}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, mode='a')", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`.", "question_id": 35397}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, complevel=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `complevel`.", "question_id": 35398}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, complib=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `complib`.", "question_id": 35399}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, append=False)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`.", "question_id": 35400}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, format=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `format`.", "question_id": 35401}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, index=True)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `index`.", "question_id": 35402}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, min_itemsize=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `min_itemsize`.", "question_id": 35403}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, nan_rep=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `nan_rep`.", "question_id": 35404}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, dropna=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `dropna`.", "question_id": 35405}
{"snippet": "DataFrame.to_hdf(path_or_buf, key)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`.", "question_id": 35406}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, mode='a')", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`.", "question_id": 35407}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, complevel=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `complevel`.", "question_id": 35408}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, complib=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `complib`.", "question_id": 35409}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, append=False)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`.", "question_id": 35410}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, format=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `format`.", "question_id": 35411}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, index=True)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `index`.", "question_id": 35412}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, min_itemsize=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `min_itemsize`.", "question_id": 35413}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, nan_rep=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `nan_rep`.", "question_id": 35414}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, dropna=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `dropna`.", "question_id": 35415}
{"snippet": "DataFrame.to_hdf(path_or_buf, key)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`.", "question_id": 35416}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, mode='a')", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`.", "question_id": 35417}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, complevel=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `complevel`.", "question_id": 35418}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, complib=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `complib`.", "question_id": 35419}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, append=False)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`.", "question_id": 35420}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, format=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `format`.", "question_id": 35421}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, index=True)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `index`.", "question_id": 35422}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, min_itemsize=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `min_itemsize`.", "question_id": 35423}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, nan_rep=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `nan_rep`.", "question_id": 35424}
{"snippet": "DataFrame.to_hdf(path_or_buf, key, dropna=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `dropna`.", "question_id": 35425}
{"snippet": "DataFrame.to_html()", "intent": "Render a DataFrame as an HTML table .", "question_id": 35426}
{"snippet": "DataFrame.to_html(buf=None)", "intent": "Render a DataFrame as an HTML table . With arguments `buf`.", "question_id": 35427}
{"snippet": "DataFrame.to_html(columns=None)", "intent": "Render a DataFrame as an HTML table . With arguments `columns`.", "question_id": 35428}
{"snippet": "DataFrame.to_html(col_space=None)", "intent": "Render a DataFrame as an HTML table . With arguments `col_space`.", "question_id": 35429}
{"snippet": "DataFrame.to_html(header=True)", "intent": "Render a DataFrame as an HTML table . With arguments `header`.", "question_id": 35430}
{"snippet": "DataFrame.to_html(index=True)", "intent": "Render a DataFrame as an HTML table . With arguments `index`.", "question_id": 35431}
{"snippet": "DataFrame.to_html(na_rep='NaN')", "intent": "Render a DataFrame as an HTML table . With arguments `na_rep`.", "question_id": 35432}
{"snippet": "DataFrame.to_html(formatters=None)", "intent": "Render a DataFrame as an HTML table . With arguments `formatters`.", "question_id": 35433}
{"snippet": "DataFrame.to_html(float_format=None)", "intent": "Render a DataFrame as an HTML table . With arguments `float_format`.", "question_id": 35434}
{"snippet": "DataFrame.to_html(sparsify=None)", "intent": "Render a DataFrame as an HTML table . With arguments `sparsify`.", "question_id": 35435}
{"snippet": "DataFrame.to_html()", "intent": "Render a DataFrame as an HTML table .", "question_id": 35436}
{"snippet": "DataFrame.to_html(buf=None)", "intent": "Render a DataFrame as an HTML table . With arguments `buf`.", "question_id": 35437}
{"snippet": "DataFrame.to_html(columns=None)", "intent": "Render a DataFrame as an HTML table . With arguments `columns`.", "question_id": 35438}
{"snippet": "DataFrame.to_html(col_space=None)", "intent": "Render a DataFrame as an HTML table . With arguments `col_space`.", "question_id": 35439}
{"snippet": "DataFrame.to_html(header=True)", "intent": "Render a DataFrame as an HTML table . With arguments `header`.", "question_id": 35440}
{"snippet": "DataFrame.to_html(index=True)", "intent": "Render a DataFrame as an HTML table . With arguments `index`.", "question_id": 35441}
{"snippet": "DataFrame.to_html(na_rep='NaN')", "intent": "Render a DataFrame as an HTML table . With arguments `na_rep`.", "question_id": 35442}
{"snippet": "DataFrame.to_html(formatters=None)", "intent": "Render a DataFrame as an HTML table . With arguments `formatters`.", "question_id": 35443}
{"snippet": "DataFrame.to_html(float_format=None)", "intent": "Render a DataFrame as an HTML table . With arguments `float_format`.", "question_id": 35444}
{"snippet": "DataFrame.to_html(sparsify=None)", "intent": "Render a DataFrame as an HTML table . With arguments `sparsify`.", "question_id": 35445}
{"snippet": "DataFrame.to_html()", "intent": "Render a DataFrame as an HTML table .", "question_id": 35446}
{"snippet": "DataFrame.to_html(buf=None)", "intent": "Render a DataFrame as an HTML table . With arguments `buf`.", "question_id": 35447}
{"snippet": "DataFrame.to_html(columns=None)", "intent": "Render a DataFrame as an HTML table . With arguments `columns`.", "question_id": 35448}
{"snippet": "DataFrame.to_html(col_space=None)", "intent": "Render a DataFrame as an HTML table . With arguments `col_space`.", "question_id": 35449}
{"snippet": "DataFrame.to_html(header=True)", "intent": "Render a DataFrame as an HTML table . With arguments `header`.", "question_id": 35450}
{"snippet": "DataFrame.to_html(index=True)", "intent": "Render a DataFrame as an HTML table . With arguments `index`.", "question_id": 35451}
{"snippet": "DataFrame.to_html(na_rep='NaN')", "intent": "Render a DataFrame as an HTML table . With arguments `na_rep`.", "question_id": 35452}
{"snippet": "DataFrame.to_html(formatters=None)", "intent": "Render a DataFrame as an HTML table . With arguments `formatters`.", "question_id": 35453}
{"snippet": "DataFrame.to_html(float_format=None)", "intent": "Render a DataFrame as an HTML table . With arguments `float_format`.", "question_id": 35454}
{"snippet": "DataFrame.to_html(sparsify=None)", "intent": "Render a DataFrame as an HTML table . With arguments `sparsify`.", "question_id": 35455}
{"snippet": "DataFrame.to_json()", "intent": "Convert the object to a JSON string .", "question_id": 35456}
{"snippet": "DataFrame.to_json(path_or_buf=None)", "intent": "Convert the object to a JSON string . With arguments `path_or_buf`.", "question_id": 35457}
{"snippet": "DataFrame.to_json(orient=None)", "intent": "Convert the object to a JSON string . With arguments `orient`.", "question_id": 35458}
{"snippet": "DataFrame.to_json(date_format=None)", "intent": "Convert the object to a JSON string . With arguments `date_format`.", "question_id": 35459}
{"snippet": "DataFrame.to_json(double_precision=10)", "intent": "Convert the object to a JSON string . With arguments `double_precision`.", "question_id": 35460}
{"snippet": "DataFrame.to_json(force_ascii=True)", "intent": "Convert the object to a JSON string . With arguments `force_ascii`.", "question_id": 35461}
{"snippet": "DataFrame.to_json(date_unit='ms')", "intent": "Convert the object to a JSON string . With arguments `date_unit`.", "question_id": 35462}
{"snippet": "DataFrame.to_json(default_handler=None)", "intent": "Convert the object to a JSON string . With arguments `default_handler`.", "question_id": 35463}
{"snippet": "DataFrame.to_json(lines=False)", "intent": "Convert the object to a JSON string . With arguments `lines`.", "question_id": 35464}
{"snippet": "DataFrame.to_json(compression='infer')", "intent": "Convert the object to a JSON string . With arguments `compression`.", "question_id": 35465}
{"snippet": "DataFrame.to_json()", "intent": "Convert the object to a JSON string .", "question_id": 35466}
{"snippet": "DataFrame.to_json(path_or_buf=None)", "intent": "Convert the object to a JSON string . With arguments `path_or_buf`.", "question_id": 35467}
{"snippet": "DataFrame.to_json(orient=None)", "intent": "Convert the object to a JSON string . With arguments `orient`.", "question_id": 35468}
{"snippet": "DataFrame.to_json(date_format=None)", "intent": "Convert the object to a JSON string . With arguments `date_format`.", "question_id": 35469}
{"snippet": "DataFrame.to_json(double_precision=10)", "intent": "Convert the object to a JSON string . With arguments `double_precision`.", "question_id": 35470}
{"snippet": "DataFrame.to_json(force_ascii=True)", "intent": "Convert the object to a JSON string . With arguments `force_ascii`.", "question_id": 35471}
{"snippet": "DataFrame.to_json(date_unit='ms')", "intent": "Convert the object to a JSON string . With arguments `date_unit`.", "question_id": 35472}
{"snippet": "DataFrame.to_json(default_handler=None)", "intent": "Convert the object to a JSON string . With arguments `default_handler`.", "question_id": 35473}
{"snippet": "DataFrame.to_json(lines=False)", "intent": "Convert the object to a JSON string . With arguments `lines`.", "question_id": 35474}
{"snippet": "DataFrame.to_json(compression='infer')", "intent": "Convert the object to a JSON string . With arguments `compression`.", "question_id": 35475}
{"snippet": "DataFrame.to_json()", "intent": "Convert the object to a JSON string .", "question_id": 35476}
{"snippet": "DataFrame.to_json(path_or_buf=None)", "intent": "Convert the object to a JSON string . With arguments `path_or_buf`.", "question_id": 35477}
{"snippet": "DataFrame.to_json(orient=None)", "intent": "Convert the object to a JSON string . With arguments `orient`.", "question_id": 35478}
{"snippet": "DataFrame.to_json(date_format=None)", "intent": "Convert the object to a JSON string . With arguments `date_format`.", "question_id": 35479}
{"snippet": "DataFrame.to_json(double_precision=10)", "intent": "Convert the object to a JSON string . With arguments `double_precision`.", "question_id": 35480}
{"snippet": "DataFrame.to_json(force_ascii=True)", "intent": "Convert the object to a JSON string . With arguments `force_ascii`.", "question_id": 35481}
{"snippet": "DataFrame.to_json(date_unit='ms')", "intent": "Convert the object to a JSON string . With arguments `date_unit`.", "question_id": 35482}
{"snippet": "DataFrame.to_json(default_handler=None)", "intent": "Convert the object to a JSON string . With arguments `default_handler`.", "question_id": 35483}
{"snippet": "DataFrame.to_json(lines=False)", "intent": "Convert the object to a JSON string . With arguments `lines`.", "question_id": 35484}
{"snippet": "DataFrame.to_json(compression='infer')", "intent": "Convert the object to a JSON string . With arguments `compression`.", "question_id": 35485}
{"snippet": "DataFrame.to_latex()", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular .", "question_id": 35486}
{"snippet": "DataFrame.to_latex(buf=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `buf`.", "question_id": 35487}
{"snippet": "DataFrame.to_latex(columns=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `columns`.", "question_id": 35488}
{"snippet": "DataFrame.to_latex(col_space=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `col_space`.", "question_id": 35489}
{"snippet": "DataFrame.to_latex(header=True)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `header`.", "question_id": 35490}
{"snippet": "DataFrame.to_latex(index=True)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `index`.", "question_id": 35491}
{"snippet": "DataFrame.to_latex(na_rep='NaN')", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `na_rep`.", "question_id": 35492}
{"snippet": "DataFrame.to_latex(formatters=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `formatters`.", "question_id": 35493}
{"snippet": "DataFrame.to_latex(float_format=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `float_format`.", "question_id": 35494}
{"snippet": "DataFrame.to_latex(sparsify=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `sparsify`.", "question_id": 35495}
{"snippet": "DataFrame.to_latex()", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular .", "question_id": 35496}
{"snippet": "DataFrame.to_latex(buf=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `buf`.", "question_id": 35497}
{"snippet": "DataFrame.to_latex(columns=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `columns`.", "question_id": 35498}
{"snippet": "DataFrame.to_latex(col_space=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `col_space`.", "question_id": 35499}
{"snippet": "DataFrame.to_latex(header=True)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `header`.", "question_id": 35500}
{"snippet": "DataFrame.to_latex(index=True)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `index`.", "question_id": 35501}
{"snippet": "DataFrame.to_latex(na_rep='NaN')", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `na_rep`.", "question_id": 35502}
{"snippet": "DataFrame.to_latex(formatters=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `formatters`.", "question_id": 35503}
{"snippet": "DataFrame.to_latex(float_format=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `float_format`.", "question_id": 35504}
{"snippet": "DataFrame.to_latex(sparsify=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `sparsify`.", "question_id": 35505}
{"snippet": "DataFrame.to_latex()", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular .", "question_id": 35506}
{"snippet": "DataFrame.to_latex(buf=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `buf`.", "question_id": 35507}
{"snippet": "DataFrame.to_latex(columns=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `columns`.", "question_id": 35508}
{"snippet": "DataFrame.to_latex(col_space=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `col_space`.", "question_id": 35509}
{"snippet": "DataFrame.to_latex(header=True)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `header`.", "question_id": 35510}
{"snippet": "DataFrame.to_latex(index=True)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `index`.", "question_id": 35511}
{"snippet": "DataFrame.to_latex(na_rep='NaN')", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `na_rep`.", "question_id": 35512}
{"snippet": "DataFrame.to_latex(formatters=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `formatters`.", "question_id": 35513}
{"snippet": "DataFrame.to_latex(float_format=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `float_format`.", "question_id": 35514}
{"snippet": "DataFrame.to_latex(sparsify=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `sparsify`.", "question_id": 35515}
{"snippet": "DataFrame.to_markdown(**kwargs)", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`.", "question_id": 35516}
{"snippet": "DataFrame.to_markdown(**kwargs, buf=None)", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `buf`.", "question_id": 35517}
{"snippet": "DataFrame.to_markdown(**kwargs, mode='wt')", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `mode`.", "question_id": 35518}
{"snippet": "DataFrame.to_markdown(**kwargs, index=True)", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `index`.", "question_id": 35519}
{"snippet": "DataFrame.to_markdown(**kwargs, storage_options=None)", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `storage_options`.", "question_id": 35520}
{"snippet": "DataFrame.to_markdown(**kwargs, buf=None, mode='wt')", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `buf`, `mode`.", "question_id": 35521}
{"snippet": "DataFrame.to_markdown(**kwargs, buf=None, index=True)", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `buf`, `index`.", "question_id": 35522}
{"snippet": "DataFrame.to_markdown(**kwargs, buf=None, storage_options=None)", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `buf`, `storage_options`.", "question_id": 35523}
{"snippet": "DataFrame.to_markdown(**kwargs, mode='wt', index=True)", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `mode`, `index`.", "question_id": 35524}
{"snippet": "DataFrame.to_markdown(**kwargs, mode='wt', storage_options=None)", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `mode`, `storage_options`.", "question_id": 35525}
{"snippet": "DataFrame.to_markdown(**kwargs)", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`.", "question_id": 35526}
{"snippet": "DataFrame.to_markdown(**kwargs, buf=None)", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `buf`.", "question_id": 35527}
{"snippet": "DataFrame.to_markdown(**kwargs, mode='wt')", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `mode`.", "question_id": 35528}
{"snippet": "DataFrame.to_markdown(**kwargs, index=True)", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `index`.", "question_id": 35529}
{"snippet": "DataFrame.to_markdown(**kwargs, storage_options=None)", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `storage_options`.", "question_id": 35530}
{"snippet": "DataFrame.to_markdown(**kwargs, buf=None, mode='wt')", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `buf`, `mode`.", "question_id": 35531}
{"snippet": "DataFrame.to_markdown(**kwargs, buf=None, index=True)", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `buf`, `index`.", "question_id": 35532}
{"snippet": "DataFrame.to_markdown(**kwargs, buf=None, storage_options=None)", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `buf`, `storage_options`.", "question_id": 35533}
{"snippet": "DataFrame.to_markdown(**kwargs, mode='wt', index=True)", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `mode`, `index`.", "question_id": 35534}
{"snippet": "DataFrame.to_markdown(**kwargs, mode='wt', storage_options=None)", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `mode`, `storage_options`.", "question_id": 35535}
{"snippet": "DataFrame.to_markdown(**kwargs)", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`.", "question_id": 35536}
{"snippet": "DataFrame.to_markdown(**kwargs, buf=None)", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `buf`.", "question_id": 35537}
{"snippet": "DataFrame.to_markdown(**kwargs, mode='wt')", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `mode`.", "question_id": 35538}
{"snippet": "DataFrame.to_markdown(**kwargs, index=True)", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `index`.", "question_id": 35539}
{"snippet": "DataFrame.to_markdown(**kwargs, storage_options=None)", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `storage_options`.", "question_id": 35540}
{"snippet": "DataFrame.to_markdown(**kwargs, buf=None, mode='wt')", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `buf`, `mode`.", "question_id": 35541}
{"snippet": "DataFrame.to_markdown(**kwargs, buf=None, index=True)", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `buf`, `index`.", "question_id": 35542}
{"snippet": "DataFrame.to_markdown(**kwargs, buf=None, storage_options=None)", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `buf`, `storage_options`.", "question_id": 35543}
{"snippet": "DataFrame.to_markdown(**kwargs, mode='wt', index=True)", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `mode`, `index`.", "question_id": 35544}
{"snippet": "DataFrame.to_markdown(**kwargs, mode='wt', storage_options=None)", "intent": "Print DataFrame in Markdown-friendly format . With arguments `**kwargs`, `mode`, `storage_options`.", "question_id": 35545}
{"snippet": "DataFrame.to_numpy()", "intent": "Convert the DataFrame to a NumPy array .", "question_id": 35546}
{"snippet": "DataFrame.to_numpy(dtype=None)", "intent": "Convert the DataFrame to a NumPy array . By default , the `dtype` of the returned array will be the common NumPy dtype of all types in the DataFrame .", "question_id": 35547}
{"snippet": "DataFrame.to_numpy(copy=False)", "intent": "Convert the DataFrame to a NumPy array . With arguments `copy`.", "question_id": 35548}
{"snippet": "DataFrame.to_numpy(na_value=NoDefault.no_default)", "intent": "Convert the DataFrame to a NumPy array . With arguments `na_value`.", "question_id": 35549}
{"snippet": "DataFrame.to_numpy(dtype=None, copy=False)", "intent": "Convert the DataFrame to a NumPy array . By default , the `dtype` of the returned array will be the common NumPy dtype of all types in the DataFrame . With arguments `copy`.", "question_id": 35550}
{"snippet": "DataFrame.to_numpy(dtype=None, na_value=NoDefault.no_default)", "intent": "Convert the DataFrame to a NumPy array . By default , the `dtype` of the returned array will be the common NumPy dtype of all types in the DataFrame . With arguments `na_value`.", "question_id": 35551}
{"snippet": "DataFrame.to_numpy(copy=False, na_value=NoDefault.no_default)", "intent": "Convert the DataFrame to a NumPy array . With arguments `copy`, `na_value`.", "question_id": 35552}
{"snippet": "DataFrame.to_numpy(dtype=None, copy=False, na_value=NoDefault.no_default)", "intent": "Convert the DataFrame to a NumPy array . By default , the `dtype` of the returned array will be the common NumPy dtype of all types in the DataFrame . With arguments `copy`, `na_value`.", "question_id": 35553}
{"snippet": "DataFrame.to_numpy()", "intent": "Convert the DataFrame to a NumPy array .", "question_id": 35554}
{"snippet": "DataFrame.to_numpy(dtype=None)", "intent": "Convert the DataFrame to a NumPy array . By default , the `dtype` of the returned array will be the common NumPy dtype of all types in the DataFrame .", "question_id": 35555}
{"snippet": "DataFrame.to_numpy(copy=False)", "intent": "Convert the DataFrame to a NumPy array . With arguments `copy`.", "question_id": 35556}
{"snippet": "DataFrame.to_numpy(na_value=NoDefault.no_default)", "intent": "Convert the DataFrame to a NumPy array . With arguments `na_value`.", "question_id": 35557}
{"snippet": "DataFrame.to_numpy(dtype=None, copy=False)", "intent": "Convert the DataFrame to a NumPy array . By default , the `dtype` of the returned array will be the common NumPy dtype of all types in the DataFrame . With arguments `copy`.", "question_id": 35558}
{"snippet": "DataFrame.to_numpy(dtype=None, na_value=NoDefault.no_default)", "intent": "Convert the DataFrame to a NumPy array . By default , the `dtype` of the returned array will be the common NumPy dtype of all types in the DataFrame . With arguments `na_value`.", "question_id": 35559}
{"snippet": "DataFrame.to_numpy(copy=False, na_value=NoDefault.no_default)", "intent": "Convert the DataFrame to a NumPy array . With arguments `copy`, `na_value`.", "question_id": 35560}
{"snippet": "DataFrame.to_numpy(dtype=None, copy=False, na_value=NoDefault.no_default)", "intent": "Convert the DataFrame to a NumPy array . By default , the `dtype` of the returned array will be the common NumPy dtype of all types in the DataFrame . With arguments `copy`, `na_value`.", "question_id": 35561}
{"snippet": "DataFrame.to_numpy()", "intent": "Convert the DataFrame to a NumPy array .", "question_id": 35562}
{"snippet": "DataFrame.to_numpy(dtype=None)", "intent": "Convert the DataFrame to a NumPy array . By default , the `dtype` of the returned array will be the common NumPy dtype of all types in the DataFrame .", "question_id": 35563}
{"snippet": "DataFrame.to_numpy(copy=False)", "intent": "Convert the DataFrame to a NumPy array . With arguments `copy`.", "question_id": 35564}
{"snippet": "DataFrame.to_numpy(na_value=NoDefault.no_default)", "intent": "Convert the DataFrame to a NumPy array . With arguments `na_value`.", "question_id": 35565}
{"snippet": "DataFrame.to_numpy(dtype=None, copy=False)", "intent": "Convert the DataFrame to a NumPy array . By default , the `dtype` of the returned array will be the common NumPy dtype of all types in the DataFrame . With arguments `copy`.", "question_id": 35566}
{"snippet": "DataFrame.to_numpy(dtype=None, na_value=NoDefault.no_default)", "intent": "Convert the DataFrame to a NumPy array . By default , the `dtype` of the returned array will be the common NumPy dtype of all types in the DataFrame . With arguments `na_value`.", "question_id": 35567}
{"snippet": "DataFrame.to_numpy(copy=False, na_value=NoDefault.no_default)", "intent": "Convert the DataFrame to a NumPy array . With arguments `copy`, `na_value`.", "question_id": 35568}
{"snippet": "DataFrame.to_numpy(dtype=None, copy=False, na_value=NoDefault.no_default)", "intent": "Convert the DataFrame to a NumPy array . By default , the `dtype` of the returned array will be the common NumPy dtype of all types in the DataFrame . With arguments `copy`, `na_value`.", "question_id": 35569}
{"snippet": "DataFrame.to_parquet(**kwargs)", "intent": "Write a DataFrame to the binary parquet format . With arguments `**kwargs`.", "question_id": 35570}
{"snippet": "DataFrame.to_parquet(**kwargs, path=None)", "intent": "Write a DataFrame to the binary parquet format . With arguments `**kwargs`, `path`.", "question_id": 35571}
{"snippet": "DataFrame.to_parquet(**kwargs, engine='auto')", "intent": "Write a DataFrame to the binary parquet format . With arguments `**kwargs`, `engine`.", "question_id": 35572}
{"snippet": "DataFrame.to_parquet(**kwargs, compression='snappy')", "intent": "Write a DataFrame to the binary parquet format . You can choose different parquet backends , and have the option of `compression` . With arguments `**kwargs`.", "question_id": 35573}
{"snippet": "DataFrame.to_parquet(**kwargs, index=None)", "intent": "Write a DataFrame to the binary parquet format . With arguments `**kwargs`, `index`.", "question_id": 35574}
{"snippet": "DataFrame.to_parquet(**kwargs, partition_cols=None)", "intent": "Write a DataFrame to the binary parquet format . If you want to get a buffer to the parquet content you can use a io.BytesIO object , as long as you don \u2019 t use `partition_cols` , which creates multiple files . With arguments `**kwargs`.", "question_id": 35575}
{"snippet": "DataFrame.to_parquet(**kwargs, storage_options=None)", "intent": "Write a DataFrame to the binary parquet format . With arguments `**kwargs`, `storage_options`.", "question_id": 35576}
{"snippet": "DataFrame.to_parquet(**kwargs, path=None, engine='auto')", "intent": "Write a DataFrame to the binary parquet format . With arguments `**kwargs`, `path`, `engine`.", "question_id": 35577}
{"snippet": "DataFrame.to_parquet(**kwargs, path=None, compression='snappy')", "intent": "Write a DataFrame to the binary parquet format . You can choose different parquet backends , and have the option of `compression` . With arguments `**kwargs`, `path`.", "question_id": 35578}
{"snippet": "DataFrame.to_parquet(**kwargs, path=None, index=None)", "intent": "Write a DataFrame to the binary parquet format . With arguments `**kwargs`, `path`, `index`.", "question_id": 35579}
{"snippet": "DataFrame.to_parquet(**kwargs)", "intent": "Write a DataFrame to the binary parquet format . With arguments `**kwargs`.", "question_id": 35580}
{"snippet": "DataFrame.to_parquet(**kwargs, path=None)", "intent": "Write a DataFrame to the binary parquet format . With arguments `**kwargs`, `path`.", "question_id": 35581}
{"snippet": "DataFrame.to_parquet(**kwargs, engine='auto')", "intent": "Write a DataFrame to the binary parquet format . With arguments `**kwargs`, `engine`.", "question_id": 35582}
{"snippet": "DataFrame.to_parquet(**kwargs, compression='snappy')", "intent": "Write a DataFrame to the binary parquet format . You can choose different parquet backends , and have the option of `compression` . With arguments `**kwargs`.", "question_id": 35583}
{"snippet": "DataFrame.to_parquet(**kwargs, index=None)", "intent": "Write a DataFrame to the binary parquet format . With arguments `**kwargs`, `index`.", "question_id": 35584}
{"snippet": "DataFrame.to_parquet(**kwargs, partition_cols=None)", "intent": "Write a DataFrame to the binary parquet format . If you want to get a buffer to the parquet content you can use a io.BytesIO object , as long as you don \u2019 t use `partition_cols` , which creates multiple files . With arguments `**kwargs`.", "question_id": 35585}
{"snippet": "DataFrame.to_parquet(**kwargs, storage_options=None)", "intent": "Write a DataFrame to the binary parquet format . With arguments `**kwargs`, `storage_options`.", "question_id": 35586}
{"snippet": "DataFrame.to_parquet(**kwargs, path=None, engine='auto')", "intent": "Write a DataFrame to the binary parquet format . With arguments `**kwargs`, `path`, `engine`.", "question_id": 35587}
{"snippet": "DataFrame.to_parquet(**kwargs, path=None, compression='snappy')", "intent": "Write a DataFrame to the binary parquet format . You can choose different parquet backends , and have the option of `compression` . With arguments `**kwargs`, `path`.", "question_id": 35588}
{"snippet": "DataFrame.to_parquet(**kwargs, path=None, index=None)", "intent": "Write a DataFrame to the binary parquet format . With arguments `**kwargs`, `path`, `index`.", "question_id": 35589}
{"snippet": "DataFrame.to_parquet(**kwargs)", "intent": "Write a DataFrame to the binary parquet format . With arguments `**kwargs`.", "question_id": 35590}
{"snippet": "DataFrame.to_parquet(**kwargs, path=None)", "intent": "Write a DataFrame to the binary parquet format . With arguments `**kwargs`, `path`.", "question_id": 35591}
{"snippet": "DataFrame.to_parquet(**kwargs, engine='auto')", "intent": "Write a DataFrame to the binary parquet format . With arguments `**kwargs`, `engine`.", "question_id": 35592}
{"snippet": "DataFrame.to_parquet(**kwargs, compression='snappy')", "intent": "Write a DataFrame to the binary parquet format . You can choose different parquet backends , and have the option of `compression` . With arguments `**kwargs`.", "question_id": 35593}
{"snippet": "DataFrame.to_parquet(**kwargs, index=None)", "intent": "Write a DataFrame to the binary parquet format . With arguments `**kwargs`, `index`.", "question_id": 35594}
{"snippet": "DataFrame.to_parquet(**kwargs, partition_cols=None)", "intent": "Write a DataFrame to the binary parquet format . If you want to get a buffer to the parquet content you can use a io.BytesIO object , as long as you don \u2019 t use `partition_cols` , which creates multiple files . With arguments `**kwargs`.", "question_id": 35595}
{"snippet": "DataFrame.to_parquet(**kwargs, storage_options=None)", "intent": "Write a DataFrame to the binary parquet format . With arguments `**kwargs`, `storage_options`.", "question_id": 35596}
{"snippet": "DataFrame.to_parquet(**kwargs, path=None, engine='auto')", "intent": "Write a DataFrame to the binary parquet format . With arguments `**kwargs`, `path`, `engine`.", "question_id": 35597}
{"snippet": "DataFrame.to_parquet(**kwargs, path=None, compression='snappy')", "intent": "Write a DataFrame to the binary parquet format . You can choose different parquet backends , and have the option of `compression` . With arguments `**kwargs`, `path`.", "question_id": 35598}
{"snippet": "DataFrame.to_parquet(**kwargs, path=None, index=None)", "intent": "Write a DataFrame to the binary parquet format . With arguments `**kwargs`, `path`, `index`.", "question_id": 35599}
{"snippet": "DataFrame.to_period()", "intent": "Convert DataFrame from DatetimeIndex to PeriodIndex .", "question_id": 35600}
{"snippet": "DataFrame.to_period(freq=None)", "intent": "Convert DataFrame from DatetimeIndex to PeriodIndex . With arguments `freq`.", "question_id": 35601}
{"snippet": "DataFrame.to_period(axis=0)", "intent": "Convert DataFrame from DatetimeIndex to PeriodIndex . With arguments `axis`.", "question_id": 35602}
{"snippet": "DataFrame.to_period(copy=True)", "intent": "Convert DataFrame from DatetimeIndex to PeriodIndex . With arguments `copy`.", "question_id": 35603}
{"snippet": "DataFrame.to_period(freq=None, axis=0)", "intent": "Convert DataFrame from DatetimeIndex to PeriodIndex . With arguments `freq`, `axis`.", "question_id": 35604}
{"snippet": "DataFrame.to_period(freq=None, copy=True)", "intent": "Convert DataFrame from DatetimeIndex to PeriodIndex . With arguments `freq`, `copy`.", "question_id": 35605}
{"snippet": "DataFrame.to_period(axis=0, copy=True)", "intent": "Convert DataFrame from DatetimeIndex to PeriodIndex . With arguments `axis`, `copy`.", "question_id": 35606}
{"snippet": "DataFrame.to_period(freq=None, axis=0, copy=True)", "intent": "Convert DataFrame from DatetimeIndex to PeriodIndex . With arguments `freq`, `axis`, `copy`.", "question_id": 35607}
{"snippet": "DataFrame.to_period()", "intent": "Convert DataFrame from DatetimeIndex to PeriodIndex .", "question_id": 35608}
{"snippet": "DataFrame.to_period(freq=None)", "intent": "Convert DataFrame from DatetimeIndex to PeriodIndex . With arguments `freq`.", "question_id": 35609}
{"snippet": "DataFrame.to_period(axis=0)", "intent": "Convert DataFrame from DatetimeIndex to PeriodIndex . With arguments `axis`.", "question_id": 35610}
{"snippet": "DataFrame.to_period(copy=True)", "intent": "Convert DataFrame from DatetimeIndex to PeriodIndex . With arguments `copy`.", "question_id": 35611}
{"snippet": "DataFrame.to_period(freq=None, axis=0)", "intent": "Convert DataFrame from DatetimeIndex to PeriodIndex . With arguments `freq`, `axis`.", "question_id": 35612}
{"snippet": "DataFrame.to_period(freq=None, copy=True)", "intent": "Convert DataFrame from DatetimeIndex to PeriodIndex . With arguments `freq`, `copy`.", "question_id": 35613}
{"snippet": "DataFrame.to_period(axis=0, copy=True)", "intent": "Convert DataFrame from DatetimeIndex to PeriodIndex . With arguments `axis`, `copy`.", "question_id": 35614}
{"snippet": "DataFrame.to_period(freq=None, axis=0, copy=True)", "intent": "Convert DataFrame from DatetimeIndex to PeriodIndex . With arguments `freq`, `axis`, `copy`.", "question_id": 35615}
{"snippet": "DataFrame.to_period()", "intent": "Convert DataFrame from DatetimeIndex to PeriodIndex .", "question_id": 35616}
{"snippet": "DataFrame.to_period(freq=None)", "intent": "Convert DataFrame from DatetimeIndex to PeriodIndex . With arguments `freq`.", "question_id": 35617}
{"snippet": "DataFrame.to_period(axis=0)", "intent": "Convert DataFrame from DatetimeIndex to PeriodIndex . With arguments `axis`.", "question_id": 35618}
{"snippet": "DataFrame.to_period(copy=True)", "intent": "Convert DataFrame from DatetimeIndex to PeriodIndex . With arguments `copy`.", "question_id": 35619}
{"snippet": "DataFrame.to_period(freq=None, axis=0)", "intent": "Convert DataFrame from DatetimeIndex to PeriodIndex . With arguments `freq`, `axis`.", "question_id": 35620}
{"snippet": "DataFrame.to_period(freq=None, copy=True)", "intent": "Convert DataFrame from DatetimeIndex to PeriodIndex . With arguments `freq`, `copy`.", "question_id": 35621}
{"snippet": "DataFrame.to_period(axis=0, copy=True)", "intent": "Convert DataFrame from DatetimeIndex to PeriodIndex . With arguments `axis`, `copy`.", "question_id": 35622}
{"snippet": "DataFrame.to_period(freq=None, axis=0, copy=True)", "intent": "Convert DataFrame from DatetimeIndex to PeriodIndex . With arguments `freq`, `axis`, `copy`.", "question_id": 35623}
{"snippet": "DataFrame.to_pickle(path)", "intent": "Pickle ( serialize ) object to file . With arguments `path`.", "question_id": 35624}
{"snippet": "DataFrame.to_pickle(path, compression='infer')", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `compression`.", "question_id": 35625}
{"snippet": "DataFrame.to_pickle(path, protocol=5)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `protocol`.", "question_id": 35626}
{"snippet": "DataFrame.to_pickle(path, storage_options=None)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `storage_options`.", "question_id": 35627}
{"snippet": "DataFrame.to_pickle(path, compression='infer', protocol=5)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `compression`, `protocol`.", "question_id": 35628}
{"snippet": "DataFrame.to_pickle(path, compression='infer', storage_options=None)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `compression`, `storage_options`.", "question_id": 35629}
{"snippet": "DataFrame.to_pickle(path, protocol=5, storage_options=None)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `protocol`, `storage_options`.", "question_id": 35630}
{"snippet": "DataFrame.to_pickle(path, compression='infer', protocol=5, storage_options=None)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `compression`, `protocol`, `storage_options`.", "question_id": 35631}
{"snippet": "DataFrame.to_pickle(path)", "intent": "Pickle ( serialize ) object to file . With arguments `path`.", "question_id": 35632}
{"snippet": "DataFrame.to_pickle(path, compression='infer')", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `compression`.", "question_id": 35633}
{"snippet": "DataFrame.to_pickle(path, protocol=5)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `protocol`.", "question_id": 35634}
{"snippet": "DataFrame.to_pickle(path, storage_options=None)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `storage_options`.", "question_id": 35635}
{"snippet": "DataFrame.to_pickle(path, compression='infer', protocol=5)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `compression`, `protocol`.", "question_id": 35636}
{"snippet": "DataFrame.to_pickle(path, compression='infer', storage_options=None)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `compression`, `storage_options`.", "question_id": 35637}
{"snippet": "DataFrame.to_pickle(path, protocol=5, storage_options=None)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `protocol`, `storage_options`.", "question_id": 35638}
{"snippet": "DataFrame.to_pickle(path, compression='infer', protocol=5, storage_options=None)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `compression`, `protocol`, `storage_options`.", "question_id": 35639}
{"snippet": "DataFrame.to_pickle(path)", "intent": "Pickle ( serialize ) object to file . With arguments `path`.", "question_id": 35640}
{"snippet": "DataFrame.to_pickle(path, compression='infer')", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `compression`.", "question_id": 35641}
{"snippet": "DataFrame.to_pickle(path, protocol=5)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `protocol`.", "question_id": 35642}
{"snippet": "DataFrame.to_pickle(path, storage_options=None)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `storage_options`.", "question_id": 35643}
{"snippet": "DataFrame.to_pickle(path, compression='infer', protocol=5)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `compression`, `protocol`.", "question_id": 35644}
{"snippet": "DataFrame.to_pickle(path, compression='infer', storage_options=None)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `compression`, `storage_options`.", "question_id": 35645}
{"snippet": "DataFrame.to_pickle(path, protocol=5, storage_options=None)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `protocol`, `storage_options`.", "question_id": 35646}
{"snippet": "DataFrame.to_pickle(path, compression='infer', protocol=5, storage_options=None)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `compression`, `protocol`, `storage_options`.", "question_id": 35647}
{"snippet": "DataFrame.to_records()", "intent": "Convert DataFrame to a NumPy record array .", "question_id": 35648}
{"snippet": "DataFrame.to_records(index=True)", "intent": "Convert DataFrame to a NumPy record array . If the DataFrame `index` has no label then the recarray field name is set to \u2018 index \u2019 .", "question_id": 35649}
{"snippet": "DataFrame.to_records(column_dtypes=None)", "intent": "Convert DataFrame to a NumPy record array . With arguments `column_dtypes`.", "question_id": 35650}
{"snippet": "DataFrame.to_records(index_dtypes=None)", "intent": "Convert DataFrame to a NumPy record array . With arguments `index_dtypes`.", "question_id": 35651}
{"snippet": "DataFrame.to_records(index=True, column_dtypes=None)", "intent": "Convert DataFrame to a NumPy record array . If the DataFrame `index` has no label then the recarray field name is set to \u2018 index \u2019 . With arguments `column_dtypes`.", "question_id": 35652}
{"snippet": "DataFrame.to_records(index=True, index_dtypes=None)", "intent": "Convert DataFrame to a NumPy record array . If the DataFrame `index` has no label then the recarray field name is set to \u2018 index \u2019 . With arguments `index_dtypes`.", "question_id": 35653}
{"snippet": "DataFrame.to_records(column_dtypes=None, index_dtypes=None)", "intent": "Convert DataFrame to a NumPy record array . With arguments `column_dtypes`, `index_dtypes`.", "question_id": 35654}
{"snippet": "DataFrame.to_records(index=True, column_dtypes=None, index_dtypes=None)", "intent": "Convert DataFrame to a NumPy record array . If the DataFrame `index` has no label then the recarray field name is set to \u2018 index \u2019 . With arguments `column_dtypes`, `index_dtypes`.", "question_id": 35655}
{"snippet": "DataFrame.to_records()", "intent": "Convert DataFrame to a NumPy record array .", "question_id": 35656}
{"snippet": "DataFrame.to_records(index=True)", "intent": "Convert DataFrame to a NumPy record array . If the DataFrame `index` has no label then the recarray field name is set to \u2018 index \u2019 .", "question_id": 35657}
{"snippet": "DataFrame.to_records(column_dtypes=None)", "intent": "Convert DataFrame to a NumPy record array . With arguments `column_dtypes`.", "question_id": 35658}
{"snippet": "DataFrame.to_records(index_dtypes=None)", "intent": "Convert DataFrame to a NumPy record array . With arguments `index_dtypes`.", "question_id": 35659}
{"snippet": "DataFrame.to_records(index=True, column_dtypes=None)", "intent": "Convert DataFrame to a NumPy record array . If the DataFrame `index` has no label then the recarray field name is set to \u2018 index \u2019 . With arguments `column_dtypes`.", "question_id": 35660}
{"snippet": "DataFrame.to_records(index=True, index_dtypes=None)", "intent": "Convert DataFrame to a NumPy record array . If the DataFrame `index` has no label then the recarray field name is set to \u2018 index \u2019 . With arguments `index_dtypes`.", "question_id": 35661}
{"snippet": "DataFrame.to_records(column_dtypes=None, index_dtypes=None)", "intent": "Convert DataFrame to a NumPy record array . With arguments `column_dtypes`, `index_dtypes`.", "question_id": 35662}
{"snippet": "DataFrame.to_records(index=True, column_dtypes=None, index_dtypes=None)", "intent": "Convert DataFrame to a NumPy record array . If the DataFrame `index` has no label then the recarray field name is set to \u2018 index \u2019 . With arguments `column_dtypes`, `index_dtypes`.", "question_id": 35663}
{"snippet": "DataFrame.to_records()", "intent": "Convert DataFrame to a NumPy record array .", "question_id": 35664}
{"snippet": "DataFrame.to_records(index=True)", "intent": "Convert DataFrame to a NumPy record array . If the DataFrame `index` has no label then the recarray field name is set to \u2018 index \u2019 .", "question_id": 35665}
{"snippet": "DataFrame.to_records(column_dtypes=None)", "intent": "Convert DataFrame to a NumPy record array . With arguments `column_dtypes`.", "question_id": 35666}
{"snippet": "DataFrame.to_records(index_dtypes=None)", "intent": "Convert DataFrame to a NumPy record array . With arguments `index_dtypes`.", "question_id": 35667}
{"snippet": "DataFrame.to_records(index=True, column_dtypes=None)", "intent": "Convert DataFrame to a NumPy record array . If the DataFrame `index` has no label then the recarray field name is set to \u2018 index \u2019 . With arguments `column_dtypes`.", "question_id": 35668}
{"snippet": "DataFrame.to_records(index=True, index_dtypes=None)", "intent": "Convert DataFrame to a NumPy record array . If the DataFrame `index` has no label then the recarray field name is set to \u2018 index \u2019 . With arguments `index_dtypes`.", "question_id": 35669}
{"snippet": "DataFrame.to_records(column_dtypes=None, index_dtypes=None)", "intent": "Convert DataFrame to a NumPy record array . With arguments `column_dtypes`, `index_dtypes`.", "question_id": 35670}
{"snippet": "DataFrame.to_records(index=True, column_dtypes=None, index_dtypes=None)", "intent": "Convert DataFrame to a NumPy record array . If the DataFrame `index` has no label then the recarray field name is set to \u2018 index \u2019 . With arguments `column_dtypes`, `index_dtypes`.", "question_id": 35671}
{"snippet": "DataFrame.to_sql(name, con)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`.", "question_id": 35672}
{"snippet": "DataFrame.to_sql(name, con, schema=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `schema`.", "question_id": 35673}
{"snippet": "DataFrame.to_sql(name, con, if_exists='fail')", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `if_exists`.", "question_id": 35674}
{"snippet": "DataFrame.to_sql(name, con, index=True)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `index`.", "question_id": 35675}
{"snippet": "DataFrame.to_sql(name, con, index_label=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `index_label`.", "question_id": 35676}
{"snippet": "DataFrame.to_sql(name, con, chunksize=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `chunksize`.", "question_id": 35677}
{"snippet": "DataFrame.to_sql(name, con, dtype=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : Specify the `dtype` ( especially useful for integers with missing values ) . With arguments `name`.", "question_id": 35678}
{"snippet": "DataFrame.to_sql(name, con, method=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `method`.", "question_id": 35679}
{"snippet": "DataFrame.to_sql(name, con, schema=None, if_exists='fail')", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `schema`, `if_exists`.", "question_id": 35680}
{"snippet": "DataFrame.to_sql(name, con, schema=None, index=True)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `schema`, `index`.", "question_id": 35681}
{"snippet": "DataFrame.to_sql(name, con)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`.", "question_id": 35682}
{"snippet": "DataFrame.to_sql(name, con, schema=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `schema`.", "question_id": 35683}
{"snippet": "DataFrame.to_sql(name, con, if_exists='fail')", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `if_exists`.", "question_id": 35684}
{"snippet": "DataFrame.to_sql(name, con, index=True)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `index`.", "question_id": 35685}
{"snippet": "DataFrame.to_sql(name, con, index_label=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `index_label`.", "question_id": 35686}
{"snippet": "DataFrame.to_sql(name, con, chunksize=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `chunksize`.", "question_id": 35687}
{"snippet": "DataFrame.to_sql(name, con, dtype=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : Specify the `dtype` ( especially useful for integers with missing values ) . With arguments `name`.", "question_id": 35688}
{"snippet": "DataFrame.to_sql(name, con, method=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `method`.", "question_id": 35689}
{"snippet": "DataFrame.to_sql(name, con, schema=None, if_exists='fail')", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `schema`, `if_exists`.", "question_id": 35690}
{"snippet": "DataFrame.to_sql(name, con, schema=None, index=True)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `schema`, `index`.", "question_id": 35691}
{"snippet": "DataFrame.to_sql(name, con)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`.", "question_id": 35692}
{"snippet": "DataFrame.to_sql(name, con, schema=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `schema`.", "question_id": 35693}
{"snippet": "DataFrame.to_sql(name, con, if_exists='fail')", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `if_exists`.", "question_id": 35694}
{"snippet": "DataFrame.to_sql(name, con, index=True)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `index`.", "question_id": 35695}
{"snippet": "DataFrame.to_sql(name, con, index_label=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `index_label`.", "question_id": 35696}
{"snippet": "DataFrame.to_sql(name, con, chunksize=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `chunksize`.", "question_id": 35697}
{"snippet": "DataFrame.to_sql(name, con, dtype=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : Specify the `dtype` ( especially useful for integers with missing values ) . With arguments `name`.", "question_id": 35698}
{"snippet": "DataFrame.to_sql(name, con, method=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `method`.", "question_id": 35699}
{"snippet": "DataFrame.to_sql(name, con, schema=None, if_exists='fail')", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `schema`, `if_exists`.", "question_id": 35700}
{"snippet": "DataFrame.to_sql(name, con, schema=None, index=True)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `schema`, `index`.", "question_id": 35701}
{"snippet": "DataFrame.to_stata(path)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`.", "question_id": 35702}
{"snippet": "DataFrame.to_stata(path, convert_dates=None)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `convert_dates`.", "question_id": 35703}
{"snippet": "DataFrame.to_stata(path, write_index=True)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `write_index`.", "question_id": 35704}
{"snippet": "DataFrame.to_stata(path, byteorder=None)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `byteorder`.", "question_id": 35705}
{"snippet": "DataFrame.to_stata(path, time_stamp=None)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `time_stamp`.", "question_id": 35706}
{"snippet": "DataFrame.to_stata(path, data_label=None)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `data_label`.", "question_id": 35707}
{"snippet": "DataFrame.to_stata(path, variable_labels=None)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `variable_labels`.", "question_id": 35708}
{"snippet": "DataFrame.to_stata(path, version=114)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `version`.", "question_id": 35709}
{"snippet": "DataFrame.to_stata(path, convert_strl=None)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `convert_strl`.", "question_id": 35710}
{"snippet": "DataFrame.to_stata(path, compression='infer')", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `compression`.", "question_id": 35711}
{"snippet": "DataFrame.to_stata(path)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`.", "question_id": 35712}
{"snippet": "DataFrame.to_stata(path, convert_dates=None)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `convert_dates`.", "question_id": 35713}
{"snippet": "DataFrame.to_stata(path, write_index=True)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `write_index`.", "question_id": 35714}
{"snippet": "DataFrame.to_stata(path, byteorder=None)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `byteorder`.", "question_id": 35715}
{"snippet": "DataFrame.to_stata(path, time_stamp=None)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `time_stamp`.", "question_id": 35716}
{"snippet": "DataFrame.to_stata(path, data_label=None)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `data_label`.", "question_id": 35717}
{"snippet": "DataFrame.to_stata(path, variable_labels=None)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `variable_labels`.", "question_id": 35718}
{"snippet": "DataFrame.to_stata(path, version=114)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `version`.", "question_id": 35719}
{"snippet": "DataFrame.to_stata(path, convert_strl=None)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `convert_strl`.", "question_id": 35720}
{"snippet": "DataFrame.to_stata(path, compression='infer')", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `compression`.", "question_id": 35721}
{"snippet": "DataFrame.to_stata(path)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`.", "question_id": 35722}
{"snippet": "DataFrame.to_stata(path, convert_dates=None)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `convert_dates`.", "question_id": 35723}
{"snippet": "DataFrame.to_stata(path, write_index=True)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `write_index`.", "question_id": 35724}
{"snippet": "DataFrame.to_stata(path, byteorder=None)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `byteorder`.", "question_id": 35725}
{"snippet": "DataFrame.to_stata(path, time_stamp=None)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `time_stamp`.", "question_id": 35726}
{"snippet": "DataFrame.to_stata(path, data_label=None)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `data_label`.", "question_id": 35727}
{"snippet": "DataFrame.to_stata(path, variable_labels=None)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `variable_labels`.", "question_id": 35728}
{"snippet": "DataFrame.to_stata(path, version=114)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `version`.", "question_id": 35729}
{"snippet": "DataFrame.to_stata(path, convert_strl=None)", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `convert_strl`.", "question_id": 35730}
{"snippet": "DataFrame.to_stata(path, compression='infer')", "intent": "Export DataFrame object to Stata dta format . With arguments `path`, `compression`.", "question_id": 35731}
{"snippet": "DataFrame.to_string()", "intent": "Render a DataFrame to a console-friendly tabular output .", "question_id": 35732}
{"snippet": "DataFrame.to_string(buf=None)", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `buf`.", "question_id": 35733}
{"snippet": "DataFrame.to_string(columns=None)", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `columns`.", "question_id": 35734}
{"snippet": "DataFrame.to_string(col_space=None)", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `col_space`.", "question_id": 35735}
{"snippet": "DataFrame.to_string(header=True)", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `header`.", "question_id": 35736}
{"snippet": "DataFrame.to_string(index=True)", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `index`.", "question_id": 35737}
{"snippet": "DataFrame.to_string(na_rep='NaN')", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `na_rep`.", "question_id": 35738}
{"snippet": "DataFrame.to_string(formatters=None)", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `formatters`.", "question_id": 35739}
{"snippet": "DataFrame.to_string(float_format=None)", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `float_format`.", "question_id": 35740}
{"snippet": "DataFrame.to_string(sparsify=None)", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `sparsify`.", "question_id": 35741}
{"snippet": "DataFrame.to_string()", "intent": "Render a DataFrame to a console-friendly tabular output .", "question_id": 35742}
{"snippet": "DataFrame.to_string(buf=None)", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `buf`.", "question_id": 35743}
{"snippet": "DataFrame.to_string(columns=None)", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `columns`.", "question_id": 35744}
{"snippet": "DataFrame.to_string(col_space=None)", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `col_space`.", "question_id": 35745}
{"snippet": "DataFrame.to_string(header=True)", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `header`.", "question_id": 35746}
{"snippet": "DataFrame.to_string(index=True)", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `index`.", "question_id": 35747}
{"snippet": "DataFrame.to_string(na_rep='NaN')", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `na_rep`.", "question_id": 35748}
{"snippet": "DataFrame.to_string(formatters=None)", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `formatters`.", "question_id": 35749}
{"snippet": "DataFrame.to_string(float_format=None)", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `float_format`.", "question_id": 35750}
{"snippet": "DataFrame.to_string(sparsify=None)", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `sparsify`.", "question_id": 35751}
{"snippet": "DataFrame.to_string()", "intent": "Render a DataFrame to a console-friendly tabular output .", "question_id": 35752}
{"snippet": "DataFrame.to_string(buf=None)", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `buf`.", "question_id": 35753}
{"snippet": "DataFrame.to_string(columns=None)", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `columns`.", "question_id": 35754}
{"snippet": "DataFrame.to_string(col_space=None)", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `col_space`.", "question_id": 35755}
{"snippet": "DataFrame.to_string(header=True)", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `header`.", "question_id": 35756}
{"snippet": "DataFrame.to_string(index=True)", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `index`.", "question_id": 35757}
{"snippet": "DataFrame.to_string(na_rep='NaN')", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `na_rep`.", "question_id": 35758}
{"snippet": "DataFrame.to_string(formatters=None)", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `formatters`.", "question_id": 35759}
{"snippet": "DataFrame.to_string(float_format=None)", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `float_format`.", "question_id": 35760}
{"snippet": "DataFrame.to_string(sparsify=None)", "intent": "Render a DataFrame to a console-friendly tabular output . With arguments `sparsify`.", "question_id": 35761}
{"snippet": "DataFrame.to_timestamp()", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period .", "question_id": 35762}
{"snippet": "DataFrame.to_timestamp(freq=None)", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `freq`.", "question_id": 35763}
{"snippet": "DataFrame.to_timestamp(how='start')", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `how`.", "question_id": 35764}
{"snippet": "DataFrame.to_timestamp(axis=0)", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `axis`.", "question_id": 35765}
{"snippet": "DataFrame.to_timestamp(copy=True)", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `copy`.", "question_id": 35766}
{"snippet": "DataFrame.to_timestamp(freq=None, how='start')", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `freq`, `how`.", "question_id": 35767}
{"snippet": "DataFrame.to_timestamp(freq=None, axis=0)", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `freq`, `axis`.", "question_id": 35768}
{"snippet": "DataFrame.to_timestamp(freq=None, copy=True)", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `freq`, `copy`.", "question_id": 35769}
{"snippet": "DataFrame.to_timestamp(how='start', axis=0)", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `how`, `axis`.", "question_id": 35770}
{"snippet": "DataFrame.to_timestamp(how='start', copy=True)", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `how`, `copy`.", "question_id": 35771}
{"snippet": "DataFrame.to_timestamp()", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period .", "question_id": 35772}
{"snippet": "DataFrame.to_timestamp(freq=None)", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `freq`.", "question_id": 35773}
{"snippet": "DataFrame.to_timestamp(how='start')", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `how`.", "question_id": 35774}
{"snippet": "DataFrame.to_timestamp(axis=0)", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `axis`.", "question_id": 35775}
{"snippet": "DataFrame.to_timestamp(copy=True)", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `copy`.", "question_id": 35776}
{"snippet": "DataFrame.to_timestamp(freq=None, how='start')", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `freq`, `how`.", "question_id": 35777}
{"snippet": "DataFrame.to_timestamp(freq=None, axis=0)", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `freq`, `axis`.", "question_id": 35778}
{"snippet": "DataFrame.to_timestamp(freq=None, copy=True)", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `freq`, `copy`.", "question_id": 35779}
{"snippet": "DataFrame.to_timestamp(how='start', axis=0)", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `how`, `axis`.", "question_id": 35780}
{"snippet": "DataFrame.to_timestamp(how='start', copy=True)", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `how`, `copy`.", "question_id": 35781}
{"snippet": "DataFrame.to_timestamp()", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period .", "question_id": 35782}
{"snippet": "DataFrame.to_timestamp(freq=None)", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `freq`.", "question_id": 35783}
{"snippet": "DataFrame.to_timestamp(how='start')", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `how`.", "question_id": 35784}
{"snippet": "DataFrame.to_timestamp(axis=0)", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `axis`.", "question_id": 35785}
{"snippet": "DataFrame.to_timestamp(copy=True)", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `copy`.", "question_id": 35786}
{"snippet": "DataFrame.to_timestamp(freq=None, how='start')", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `freq`, `how`.", "question_id": 35787}
{"snippet": "DataFrame.to_timestamp(freq=None, axis=0)", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `freq`, `axis`.", "question_id": 35788}
{"snippet": "DataFrame.to_timestamp(freq=None, copy=True)", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `freq`, `copy`.", "question_id": 35789}
{"snippet": "DataFrame.to_timestamp(how='start', axis=0)", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `how`, `axis`.", "question_id": 35790}
{"snippet": "DataFrame.to_timestamp(how='start', copy=True)", "intent": "Cast to DatetimeIndex of timestamps , at beginning of period . With arguments `how`, `copy`.", "question_id": 35791}
{"snippet": "DataFrame.to_xarray()", "intent": "Return an xarray object from the pandas object .", "question_id": 35792}
{"snippet": "DataFrame.to_xarray()", "intent": "Return an xarray object from the pandas object .", "question_id": 35793}
{"snippet": "DataFrame.to_xarray()", "intent": "Return an xarray object from the pandas object .", "question_id": 35794}
{"snippet": "DataFrame.to_xml()", "intent": "Render a DataFrame to an XML document .", "question_id": 35795}
{"snippet": "DataFrame.to_xml(path_or_buffer=None)", "intent": "Render a DataFrame to an XML document . With arguments `path_or_buffer`.", "question_id": 35796}
{"snippet": "DataFrame.to_xml(index=True)", "intent": "Render a DataFrame to an XML document . With arguments `index`.", "question_id": 35797}
{"snippet": "DataFrame.to_xml(root_name='data')", "intent": "Render a DataFrame to an XML document . With arguments `root_name`.", "question_id": 35798}
{"snippet": "DataFrame.to_xml(row_name='row')", "intent": "Render a DataFrame to an XML document . With arguments `row_name`.", "question_id": 35799}
{"snippet": "DataFrame.to_xml(na_rep=None)", "intent": "Render a DataFrame to an XML document . With arguments `na_rep`.", "question_id": 35800}
{"snippet": "DataFrame.to_xml(attr_cols=None)", "intent": "Render a DataFrame to an XML document . With arguments `attr_cols`.", "question_id": 35801}
{"snippet": "DataFrame.to_xml(elem_cols=None)", "intent": "Render a DataFrame to an XML document . With arguments `elem_cols`.", "question_id": 35802}
{"snippet": "DataFrame.to_xml(namespaces=None)", "intent": "Render a DataFrame to an XML document . With arguments `namespaces`.", "question_id": 35803}
{"snippet": "DataFrame.to_xml(prefix=None)", "intent": "Render a DataFrame to an XML document . With arguments `prefix`.", "question_id": 35804}
{"snippet": "DataFrame.to_xml()", "intent": "Render a DataFrame to an XML document .", "question_id": 35805}
{"snippet": "DataFrame.to_xml(path_or_buffer=None)", "intent": "Render a DataFrame to an XML document . With arguments `path_or_buffer`.", "question_id": 35806}
{"snippet": "DataFrame.to_xml(index=True)", "intent": "Render a DataFrame to an XML document . With arguments `index`.", "question_id": 35807}
{"snippet": "DataFrame.to_xml(root_name='data')", "intent": "Render a DataFrame to an XML document . With arguments `root_name`.", "question_id": 35808}
{"snippet": "DataFrame.to_xml(row_name='row')", "intent": "Render a DataFrame to an XML document . With arguments `row_name`.", "question_id": 35809}
{"snippet": "DataFrame.to_xml(na_rep=None)", "intent": "Render a DataFrame to an XML document . With arguments `na_rep`.", "question_id": 35810}
{"snippet": "DataFrame.to_xml(attr_cols=None)", "intent": "Render a DataFrame to an XML document . With arguments `attr_cols`.", "question_id": 35811}
{"snippet": "DataFrame.to_xml(elem_cols=None)", "intent": "Render a DataFrame to an XML document . With arguments `elem_cols`.", "question_id": 35812}
{"snippet": "DataFrame.to_xml(namespaces=None)", "intent": "Render a DataFrame to an XML document . With arguments `namespaces`.", "question_id": 35813}
{"snippet": "DataFrame.to_xml(prefix=None)", "intent": "Render a DataFrame to an XML document . With arguments `prefix`.", "question_id": 35814}
{"snippet": "DataFrame.to_xml()", "intent": "Render a DataFrame to an XML document .", "question_id": 35815}
{"snippet": "DataFrame.to_xml(path_or_buffer=None)", "intent": "Render a DataFrame to an XML document . With arguments `path_or_buffer`.", "question_id": 35816}
{"snippet": "DataFrame.to_xml(index=True)", "intent": "Render a DataFrame to an XML document . With arguments `index`.", "question_id": 35817}
{"snippet": "DataFrame.to_xml(root_name='data')", "intent": "Render a DataFrame to an XML document . With arguments `root_name`.", "question_id": 35818}
{"snippet": "DataFrame.to_xml(row_name='row')", "intent": "Render a DataFrame to an XML document . With arguments `row_name`.", "question_id": 35819}
{"snippet": "DataFrame.to_xml(na_rep=None)", "intent": "Render a DataFrame to an XML document . With arguments `na_rep`.", "question_id": 35820}
{"snippet": "DataFrame.to_xml(attr_cols=None)", "intent": "Render a DataFrame to an XML document . With arguments `attr_cols`.", "question_id": 35821}
{"snippet": "DataFrame.to_xml(elem_cols=None)", "intent": "Render a DataFrame to an XML document . With arguments `elem_cols`.", "question_id": 35822}
{"snippet": "DataFrame.to_xml(namespaces=None)", "intent": "Render a DataFrame to an XML document . With arguments `namespaces`.", "question_id": 35823}
{"snippet": "DataFrame.to_xml(prefix=None)", "intent": "Render a DataFrame to an XML document . With arguments `prefix`.", "question_id": 35824}
{"snippet": "DataFrame.transform(func, *args, **kwargs)", "intent": "Call `func` on self producing a DataFrame with transformed values . With arguments `*args`, `**kwargs`.", "question_id": 35825}
{"snippet": "DataFrame.transform(func, *args, **kwargs, axis=0)", "intent": "Call `func` on self producing a DataFrame with transformed values . Produced DataFrame will have same `axis` length as self . With arguments `*args`, `**kwargs`.", "question_id": 35826}
{"snippet": "DataFrame.transform(func, *args, **kwargs)", "intent": "Call `func` on self producing a DataFrame with transformed values . With arguments `*args`, `**kwargs`.", "question_id": 35827}
{"snippet": "DataFrame.transform(func, *args, **kwargs, axis=0)", "intent": "Call `func` on self producing a DataFrame with transformed values . Produced DataFrame will have same `axis` length as self . With arguments `*args`, `**kwargs`.", "question_id": 35828}
{"snippet": "DataFrame.transform(func, *args, **kwargs)", "intent": "Call `func` on self producing a DataFrame with transformed values . With arguments `*args`, `**kwargs`.", "question_id": 35829}
{"snippet": "DataFrame.transform(func, *args, **kwargs, axis=0)", "intent": "Call `func` on self producing a DataFrame with transformed values . Produced DataFrame will have same `axis` length as self . With arguments `*args`, `**kwargs`.", "question_id": 35830}
{"snippet": "DataFrame.transpose(*args)", "intent": "Transpose index and columns . With arguments `*args`.", "question_id": 35831}
{"snippet": "DataFrame.transpose(*args, copy=False)", "intent": "Transpose index and columns . In such a case , a `copy` of the data is always made . With arguments `*args`.", "question_id": 35832}
{"snippet": "DataFrame.transpose(*args)", "intent": "Transpose index and columns . With arguments `*args`.", "question_id": 35833}
{"snippet": "DataFrame.transpose(*args, copy=False)", "intent": "Transpose index and columns . In such a case , a `copy` of the data is always made . With arguments `*args`.", "question_id": 35834}
{"snippet": "DataFrame.transpose(*args)", "intent": "Transpose index and columns . With arguments `*args`.", "question_id": 35835}
{"snippet": "DataFrame.transpose(*args, copy=False)", "intent": "Transpose index and columns . In such a case , a `copy` of the data is always made . With arguments `*args`.", "question_id": 35836}
{"snippet": "DataFrame.truediv(other)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) .", "question_id": 35837}
{"snippet": "DataFrame.truediv(other, axis='columns')", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version .", "question_id": 35838}
{"snippet": "DataFrame.truediv(other, level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Divide by a MultiIndex by `level` .", "question_id": 35839}
{"snippet": "DataFrame.truediv(other, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35840}
{"snippet": "DataFrame.truediv(other, axis='columns', level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 35841}
{"snippet": "DataFrame.truediv(other, axis='columns', fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35842}
{"snippet": "DataFrame.truediv(other, level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Divide by a MultiIndex by `level` . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35843}
{"snippet": "DataFrame.truediv(other, axis='columns', level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35844}
{"snippet": "DataFrame.truediv(other)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) .", "question_id": 35845}
{"snippet": "DataFrame.truediv(other, axis='columns')", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version .", "question_id": 35846}
{"snippet": "DataFrame.truediv(other, level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Divide by a MultiIndex by `level` .", "question_id": 35847}
{"snippet": "DataFrame.truediv(other, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35848}
{"snippet": "DataFrame.truediv(other, axis='columns', level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 35849}
{"snippet": "DataFrame.truediv(other, axis='columns', fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35850}
{"snippet": "DataFrame.truediv(other, level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Divide by a MultiIndex by `level` . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35851}
{"snippet": "DataFrame.truediv(other, axis='columns', level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35852}
{"snippet": "DataFrame.truediv(other)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) .", "question_id": 35853}
{"snippet": "DataFrame.truediv(other, axis='columns')", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version .", "question_id": 35854}
{"snippet": "DataFrame.truediv(other, level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Divide by a MultiIndex by `level` .", "question_id": 35855}
{"snippet": "DataFrame.truediv(other, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35856}
{"snippet": "DataFrame.truediv(other, axis='columns', level=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` .", "question_id": 35857}
{"snippet": "DataFrame.truediv(other, axis='columns', fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35858}
{"snippet": "DataFrame.truediv(other, level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Divide by a MultiIndex by `level` . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35859}
{"snippet": "DataFrame.truediv(other, axis='columns', level=None, fill_value=None)", "intent": "Get Floating division of dataframe and `other` , element-wise ( binary operator truediv ) . Subtract a list and Series by `axis` with operator version . Divide by a MultiIndex by `level` . Equivalent to dataframe / other , but with support to substitute a `fill_value` for missing data in one of the inputs .", "question_id": 35860}
{"snippet": "DataFrame.truncate()", "intent": "Truncate a Series or DataFrame `before` and `after` some index value .", "question_id": 35861}
{"snippet": "DataFrame.truncate(before=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value .", "question_id": 35862}
{"snippet": "DataFrame.truncate(after=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value .", "question_id": 35863}
{"snippet": "DataFrame.truncate(axis=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `axis`.", "question_id": 35864}
{"snippet": "DataFrame.truncate(copy=True)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `copy`.", "question_id": 35865}
{"snippet": "DataFrame.truncate(before=None, after=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value .", "question_id": 35866}
{"snippet": "DataFrame.truncate(before=None, axis=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `axis`.", "question_id": 35867}
{"snippet": "DataFrame.truncate(before=None, copy=True)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `copy`.", "question_id": 35868}
{"snippet": "DataFrame.truncate(after=None, axis=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `axis`.", "question_id": 35869}
{"snippet": "DataFrame.truncate(after=None, copy=True)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `copy`.", "question_id": 35870}
{"snippet": "DataFrame.truncate()", "intent": "Truncate a Series or DataFrame `before` and `after` some index value .", "question_id": 35871}
{"snippet": "DataFrame.truncate(before=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value .", "question_id": 35872}
{"snippet": "DataFrame.truncate(after=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value .", "question_id": 35873}
{"snippet": "DataFrame.truncate(axis=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `axis`.", "question_id": 35874}
{"snippet": "DataFrame.truncate(copy=True)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `copy`.", "question_id": 35875}
{"snippet": "DataFrame.truncate(before=None, after=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value .", "question_id": 35876}
{"snippet": "DataFrame.truncate(before=None, axis=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `axis`.", "question_id": 35877}
{"snippet": "DataFrame.truncate(before=None, copy=True)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `copy`.", "question_id": 35878}
{"snippet": "DataFrame.truncate(after=None, axis=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `axis`.", "question_id": 35879}
{"snippet": "DataFrame.truncate(after=None, copy=True)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `copy`.", "question_id": 35880}
{"snippet": "DataFrame.truncate()", "intent": "Truncate a Series or DataFrame `before` and `after` some index value .", "question_id": 35881}
{"snippet": "DataFrame.truncate(before=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value .", "question_id": 35882}
{"snippet": "DataFrame.truncate(after=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value .", "question_id": 35883}
{"snippet": "DataFrame.truncate(axis=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `axis`.", "question_id": 35884}
{"snippet": "DataFrame.truncate(copy=True)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `copy`.", "question_id": 35885}
{"snippet": "DataFrame.truncate(before=None, after=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value .", "question_id": 35886}
{"snippet": "DataFrame.truncate(before=None, axis=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `axis`.", "question_id": 35887}
{"snippet": "DataFrame.truncate(before=None, copy=True)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `copy`.", "question_id": 35888}
{"snippet": "DataFrame.truncate(after=None, axis=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `axis`.", "question_id": 35889}
{"snippet": "DataFrame.truncate(after=None, copy=True)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `copy`.", "question_id": 35890}
{"snippet": "DataFrame.tshift()", "intent": "Shift the time index , using the index \u2019 s frequency if available .", "question_id": 35891}
{"snippet": "DataFrame.tshift(periods=1)", "intent": "Shift the time index , using the index \u2019 s frequency if available . With arguments `periods`.", "question_id": 35892}
{"snippet": "DataFrame.tshift(freq=None)", "intent": "Shift the time index , using the index \u2019 s frequency if available . If `freq` is not specified then tries to use the freq or inferred_freq attributes of the index .", "question_id": 35893}
{"snippet": "DataFrame.tshift(axis=0)", "intent": "Shift the time index , using the index \u2019 s frequency if available . With arguments `axis`.", "question_id": 35894}
{"snippet": "DataFrame.tshift(periods=1, freq=None)", "intent": "Shift the time index , using the index \u2019 s frequency if available . If `freq` is not specified then tries to use the freq or inferred_freq attributes of the index . With arguments `periods`.", "question_id": 35895}
{"snippet": "DataFrame.tshift(periods=1, axis=0)", "intent": "Shift the time index , using the index \u2019 s frequency if available . With arguments `periods`, `axis`.", "question_id": 35896}
{"snippet": "DataFrame.tshift(freq=None, axis=0)", "intent": "Shift the time index , using the index \u2019 s frequency if available . If `freq` is not specified then tries to use the freq or inferred_freq attributes of the index . With arguments `axis`.", "question_id": 35897}
{"snippet": "DataFrame.tshift(periods=1, freq=None, axis=0)", "intent": "Shift the time index , using the index \u2019 s frequency if available . If `freq` is not specified then tries to use the freq or inferred_freq attributes of the index . With arguments `periods`, `axis`.", "question_id": 35898}
{"snippet": "DataFrame.tshift()", "intent": "Shift the time index , using the index \u2019 s frequency if available .", "question_id": 35899}
{"snippet": "DataFrame.tshift(periods=1)", "intent": "Shift the time index , using the index \u2019 s frequency if available . With arguments `periods`.", "question_id": 35900}
{"snippet": "DataFrame.tshift(freq=None)", "intent": "Shift the time index , using the index \u2019 s frequency if available . If `freq` is not specified then tries to use the freq or inferred_freq attributes of the index .", "question_id": 35901}
{"snippet": "DataFrame.tshift(axis=0)", "intent": "Shift the time index , using the index \u2019 s frequency if available . With arguments `axis`.", "question_id": 35902}
{"snippet": "DataFrame.tshift(periods=1, freq=None)", "intent": "Shift the time index , using the index \u2019 s frequency if available . If `freq` is not specified then tries to use the freq or inferred_freq attributes of the index . With arguments `periods`.", "question_id": 35903}
{"snippet": "DataFrame.tshift(periods=1, axis=0)", "intent": "Shift the time index , using the index \u2019 s frequency if available . With arguments `periods`, `axis`.", "question_id": 35904}
{"snippet": "DataFrame.tshift(freq=None, axis=0)", "intent": "Shift the time index , using the index \u2019 s frequency if available . If `freq` is not specified then tries to use the freq or inferred_freq attributes of the index . With arguments `axis`.", "question_id": 35905}
{"snippet": "DataFrame.tshift(periods=1, freq=None, axis=0)", "intent": "Shift the time index , using the index \u2019 s frequency if available . If `freq` is not specified then tries to use the freq or inferred_freq attributes of the index . With arguments `periods`, `axis`.", "question_id": 35906}
{"snippet": "DataFrame.tshift()", "intent": "Shift the time index , using the index \u2019 s frequency if available .", "question_id": 35907}
{"snippet": "DataFrame.tshift(periods=1)", "intent": "Shift the time index , using the index \u2019 s frequency if available . With arguments `periods`.", "question_id": 35908}
{"snippet": "DataFrame.tshift(freq=None)", "intent": "Shift the time index , using the index \u2019 s frequency if available . If `freq` is not specified then tries to use the freq or inferred_freq attributes of the index .", "question_id": 35909}
{"snippet": "DataFrame.tshift(axis=0)", "intent": "Shift the time index , using the index \u2019 s frequency if available . With arguments `axis`.", "question_id": 35910}
{"snippet": "DataFrame.tshift(periods=1, freq=None)", "intent": "Shift the time index , using the index \u2019 s frequency if available . If `freq` is not specified then tries to use the freq or inferred_freq attributes of the index . With arguments `periods`.", "question_id": 35911}
{"snippet": "DataFrame.tshift(periods=1, axis=0)", "intent": "Shift the time index , using the index \u2019 s frequency if available . With arguments `periods`, `axis`.", "question_id": 35912}
{"snippet": "DataFrame.tshift(freq=None, axis=0)", "intent": "Shift the time index , using the index \u2019 s frequency if available . If `freq` is not specified then tries to use the freq or inferred_freq attributes of the index . With arguments `axis`.", "question_id": 35913}
{"snippet": "DataFrame.tshift(periods=1, freq=None, axis=0)", "intent": "Shift the time index , using the index \u2019 s frequency if available . If `freq` is not specified then tries to use the freq or inferred_freq attributes of the index . With arguments `periods`, `axis`.", "question_id": 35914}
{"snippet": "DataFrame.tz_convert(tz)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`.", "question_id": 35915}
{"snippet": "DataFrame.tz_convert(tz, axis=0)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`.", "question_id": 35916}
{"snippet": "DataFrame.tz_convert(tz, level=None)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `level`.", "question_id": 35917}
{"snippet": "DataFrame.tz_convert(tz, copy=True)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `copy`.", "question_id": 35918}
{"snippet": "DataFrame.tz_convert(tz, axis=0, level=None)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `level`.", "question_id": 35919}
{"snippet": "DataFrame.tz_convert(tz, axis=0, copy=True)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `copy`.", "question_id": 35920}
{"snippet": "DataFrame.tz_convert(tz, level=None, copy=True)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `level`, `copy`.", "question_id": 35921}
{"snippet": "DataFrame.tz_convert(tz, axis=0, level=None, copy=True)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `level`, `copy`.", "question_id": 35922}
{"snippet": "DataFrame.tz_convert(tz)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`.", "question_id": 35923}
{"snippet": "DataFrame.tz_convert(tz, axis=0)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`.", "question_id": 35924}
{"snippet": "DataFrame.tz_convert(tz, level=None)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `level`.", "question_id": 35925}
{"snippet": "DataFrame.tz_convert(tz, copy=True)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `copy`.", "question_id": 35926}
{"snippet": "DataFrame.tz_convert(tz, axis=0, level=None)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `level`.", "question_id": 35927}
{"snippet": "DataFrame.tz_convert(tz, axis=0, copy=True)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `copy`.", "question_id": 35928}
{"snippet": "DataFrame.tz_convert(tz, level=None, copy=True)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `level`, `copy`.", "question_id": 35929}
{"snippet": "DataFrame.tz_convert(tz, axis=0, level=None, copy=True)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `level`, `copy`.", "question_id": 35930}
{"snippet": "DataFrame.tz_convert(tz)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`.", "question_id": 35931}
{"snippet": "DataFrame.tz_convert(tz, axis=0)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`.", "question_id": 35932}
{"snippet": "DataFrame.tz_convert(tz, level=None)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `level`.", "question_id": 35933}
{"snippet": "DataFrame.tz_convert(tz, copy=True)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `copy`.", "question_id": 35934}
{"snippet": "DataFrame.tz_convert(tz, axis=0, level=None)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `level`.", "question_id": 35935}
{"snippet": "DataFrame.tz_convert(tz, axis=0, copy=True)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `copy`.", "question_id": 35936}
{"snippet": "DataFrame.tz_convert(tz, level=None, copy=True)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `level`, `copy`.", "question_id": 35937}
{"snippet": "DataFrame.tz_convert(tz, axis=0, level=None, copy=True)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `level`, `copy`.", "question_id": 35938}
{"snippet": "DataFrame.tz_localize(tz)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`.", "question_id": 35939}
{"snippet": "DataFrame.tz_localize(tz, axis=0)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `axis`.", "question_id": 35940}
{"snippet": "DataFrame.tz_localize(tz, level=None)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `level`.", "question_id": 35941}
{"snippet": "DataFrame.tz_localize(tz, copy=True)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `copy`.", "question_id": 35942}
{"snippet": "DataFrame.tz_localize(tz, ambiguous='raise')", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . In such cases , you can pass an ndarray to the `ambiguous` parameter to set the DST explicitly With arguments `tz`.", "question_id": 35943}
{"snippet": "DataFrame.tz_localize(tz, nonexistent='raise')", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . If the DST transition causes `nonexistent` times , you can shift these dates forward or backward with a timedelta object or \u2018 shift_forward \u2019 or \u2018 shift_backward \u2019 . With arguments `tz`.", "question_id": 35944}
{"snippet": "DataFrame.tz_localize(tz, axis=0, level=None)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `axis`, `level`.", "question_id": 35945}
{"snippet": "DataFrame.tz_localize(tz, axis=0, copy=True)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `axis`, `copy`.", "question_id": 35946}
{"snippet": "DataFrame.tz_localize(tz, axis=0, ambiguous='raise')", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . In such cases , you can pass an ndarray to the `ambiguous` parameter to set the DST explicitly With arguments `tz`, `axis`.", "question_id": 35947}
{"snippet": "DataFrame.tz_localize(tz, axis=0, nonexistent='raise')", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . If the DST transition causes `nonexistent` times , you can shift these dates forward or backward with a timedelta object or \u2018 shift_forward \u2019 or \u2018 shift_backward \u2019 . With arguments `tz`, `axis`.", "question_id": 35948}
{"snippet": "DataFrame.tz_localize(tz)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`.", "question_id": 35949}
{"snippet": "DataFrame.tz_localize(tz, axis=0)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `axis`.", "question_id": 35950}
{"snippet": "DataFrame.tz_localize(tz, level=None)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `level`.", "question_id": 35951}
{"snippet": "DataFrame.tz_localize(tz, copy=True)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `copy`.", "question_id": 35952}
{"snippet": "DataFrame.tz_localize(tz, ambiguous='raise')", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . In such cases , you can pass an ndarray to the `ambiguous` parameter to set the DST explicitly With arguments `tz`.", "question_id": 35953}
{"snippet": "DataFrame.tz_localize(tz, nonexistent='raise')", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . If the DST transition causes `nonexistent` times , you can shift these dates forward or backward with a timedelta object or \u2018 shift_forward \u2019 or \u2018 shift_backward \u2019 . With arguments `tz`.", "question_id": 35954}
{"snippet": "DataFrame.tz_localize(tz, axis=0, level=None)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `axis`, `level`.", "question_id": 35955}
{"snippet": "DataFrame.tz_localize(tz, axis=0, copy=True)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `axis`, `copy`.", "question_id": 35956}
{"snippet": "DataFrame.tz_localize(tz, axis=0, ambiguous='raise')", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . In such cases , you can pass an ndarray to the `ambiguous` parameter to set the DST explicitly With arguments `tz`, `axis`.", "question_id": 35957}
{"snippet": "DataFrame.tz_localize(tz, axis=0, nonexistent='raise')", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . If the DST transition causes `nonexistent` times , you can shift these dates forward or backward with a timedelta object or \u2018 shift_forward \u2019 or \u2018 shift_backward \u2019 . With arguments `tz`, `axis`.", "question_id": 35958}
{"snippet": "DataFrame.tz_localize(tz)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`.", "question_id": 35959}
{"snippet": "DataFrame.tz_localize(tz, axis=0)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `axis`.", "question_id": 35960}
{"snippet": "DataFrame.tz_localize(tz, level=None)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `level`.", "question_id": 35961}
{"snippet": "DataFrame.tz_localize(tz, copy=True)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `copy`.", "question_id": 35962}
{"snippet": "DataFrame.tz_localize(tz, ambiguous='raise')", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . In such cases , you can pass an ndarray to the `ambiguous` parameter to set the DST explicitly With arguments `tz`.", "question_id": 35963}
{"snippet": "DataFrame.tz_localize(tz, nonexistent='raise')", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . If the DST transition causes `nonexistent` times , you can shift these dates forward or backward with a timedelta object or \u2018 shift_forward \u2019 or \u2018 shift_backward \u2019 . With arguments `tz`.", "question_id": 35964}
{"snippet": "DataFrame.tz_localize(tz, axis=0, level=None)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `axis`, `level`.", "question_id": 35965}
{"snippet": "DataFrame.tz_localize(tz, axis=0, copy=True)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `axis`, `copy`.", "question_id": 35966}
{"snippet": "DataFrame.tz_localize(tz, axis=0, ambiguous='raise')", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . In such cases , you can pass an ndarray to the `ambiguous` parameter to set the DST explicitly With arguments `tz`, `axis`.", "question_id": 35967}
{"snippet": "DataFrame.tz_localize(tz, axis=0, nonexistent='raise')", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . If the DST transition causes `nonexistent` times , you can shift these dates forward or backward with a timedelta object or \u2018 shift_forward \u2019 or \u2018 shift_backward \u2019 . With arguments `tz`, `axis`.", "question_id": 35968}
{"snippet": "DataFrame.unstack()", "intent": "Pivot a `level` of the ( necessarily hierarchical ) index labels .", "question_id": 35969}
{"snippet": "DataFrame.unstack(level=- 1)", "intent": "Pivot a `level` of the ( necessarily hierarchical ) index labels .", "question_id": 35970}
{"snippet": "DataFrame.unstack(fill_value=None)", "intent": "Pivot a `level` of the ( necessarily hierarchical ) index labels . With arguments `fill_value`.", "question_id": 35971}
{"snippet": "DataFrame.unstack(level=- 1, fill_value=None)", "intent": "Pivot a `level` of the ( necessarily hierarchical ) index labels . With arguments `fill_value`.", "question_id": 35972}
{"snippet": "DataFrame.unstack()", "intent": "Pivot a `level` of the ( necessarily hierarchical ) index labels .", "question_id": 35973}
{"snippet": "DataFrame.unstack(level=- 1)", "intent": "Pivot a `level` of the ( necessarily hierarchical ) index labels .", "question_id": 35974}
{"snippet": "DataFrame.unstack(fill_value=None)", "intent": "Pivot a `level` of the ( necessarily hierarchical ) index labels . With arguments `fill_value`.", "question_id": 35975}
{"snippet": "DataFrame.unstack(level=- 1, fill_value=None)", "intent": "Pivot a `level` of the ( necessarily hierarchical ) index labels . With arguments `fill_value`.", "question_id": 35976}
{"snippet": "DataFrame.unstack()", "intent": "Pivot a `level` of the ( necessarily hierarchical ) index labels .", "question_id": 35977}
{"snippet": "DataFrame.unstack(level=- 1)", "intent": "Pivot a `level` of the ( necessarily hierarchical ) index labels .", "question_id": 35978}
{"snippet": "DataFrame.unstack(fill_value=None)", "intent": "Pivot a `level` of the ( necessarily hierarchical ) index labels . With arguments `fill_value`.", "question_id": 35979}
{"snippet": "DataFrame.unstack(level=- 1, fill_value=None)", "intent": "Pivot a `level` of the ( necessarily hierarchical ) index labels . With arguments `fill_value`.", "question_id": 35980}
{"snippet": "DataFrame.update(other)", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe .", "question_id": 35981}
{"snippet": "DataFrame.update(other, join='left')", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `join`.", "question_id": 35982}
{"snippet": "DataFrame.update(other, overwrite=True)", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `overwrite`.", "question_id": 35983}
{"snippet": "DataFrame.update(other, filter_func=None)", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `filter_func`.", "question_id": 35984}
{"snippet": "DataFrame.update(other, errors='ignore')", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `errors`.", "question_id": 35985}
{"snippet": "DataFrame.update(other, join='left', overwrite=True)", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `join`, `overwrite`.", "question_id": 35986}
{"snippet": "DataFrame.update(other, join='left', filter_func=None)", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `join`, `filter_func`.", "question_id": 35987}
{"snippet": "DataFrame.update(other, join='left', errors='ignore')", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `join`, `errors`.", "question_id": 35988}
{"snippet": "DataFrame.update(other, overwrite=True, filter_func=None)", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `overwrite`, `filter_func`.", "question_id": 35989}
{"snippet": "DataFrame.update(other, overwrite=True, errors='ignore')", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `overwrite`, `errors`.", "question_id": 35990}
{"snippet": "DataFrame.update(other)", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe .", "question_id": 35991}
{"snippet": "DataFrame.update(other, join='left')", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `join`.", "question_id": 35992}
{"snippet": "DataFrame.update(other, overwrite=True)", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `overwrite`.", "question_id": 35993}
{"snippet": "DataFrame.update(other, filter_func=None)", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `filter_func`.", "question_id": 35994}
{"snippet": "DataFrame.update(other, errors='ignore')", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `errors`.", "question_id": 35995}
{"snippet": "DataFrame.update(other, join='left', overwrite=True)", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `join`, `overwrite`.", "question_id": 35996}
{"snippet": "DataFrame.update(other, join='left', filter_func=None)", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `join`, `filter_func`.", "question_id": 35997}
{"snippet": "DataFrame.update(other, join='left', errors='ignore')", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `join`, `errors`.", "question_id": 35998}
{"snippet": "DataFrame.update(other, overwrite=True, filter_func=None)", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `overwrite`, `filter_func`.", "question_id": 35999}
{"snippet": "DataFrame.update(other, overwrite=True, errors='ignore')", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `overwrite`, `errors`.", "question_id": 36000}
{"snippet": "DataFrame.update(other)", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe .", "question_id": 36001}
{"snippet": "DataFrame.update(other, join='left')", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `join`.", "question_id": 36002}
{"snippet": "DataFrame.update(other, overwrite=True)", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `overwrite`.", "question_id": 36003}
{"snippet": "DataFrame.update(other, filter_func=None)", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `filter_func`.", "question_id": 36004}
{"snippet": "DataFrame.update(other, errors='ignore')", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `errors`.", "question_id": 36005}
{"snippet": "DataFrame.update(other, join='left', overwrite=True)", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `join`, `overwrite`.", "question_id": 36006}
{"snippet": "DataFrame.update(other, join='left', filter_func=None)", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `join`, `filter_func`.", "question_id": 36007}
{"snippet": "DataFrame.update(other, join='left', errors='ignore')", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `join`, `errors`.", "question_id": 36008}
{"snippet": "DataFrame.update(other, overwrite=True, filter_func=None)", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `overwrite`, `filter_func`.", "question_id": 36009}
{"snippet": "DataFrame.update(other, overwrite=True, errors='ignore')", "intent": "Modify in place using non-NA values from another DataFrame . If `other` contains NaNs the corresponding values are not updated in the original dataframe . With arguments `overwrite`, `errors`.", "question_id": 36010}
{"snippet": "DataFrame.value_counts()", "intent": "Return a Series containing counts of unique rows in the DataFrame .", "question_id": 36011}
{"snippet": "DataFrame.value_counts(subset=None)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With arguments `subset`.", "question_id": 36012}
{"snippet": "DataFrame.value_counts(normalize=False)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With arguments `normalize`.", "question_id": 36013}
{"snippet": "DataFrame.value_counts(sort=True)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With arguments `sort`.", "question_id": 36014}
{"snippet": "DataFrame.value_counts(ascending=False)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With arguments `ascending`.", "question_id": 36015}
{"snippet": "DataFrame.value_counts(dropna=True)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With `dropna` set to False we can also count rows with NA values .", "question_id": 36016}
{"snippet": "DataFrame.value_counts(subset=None, normalize=False)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With arguments `subset`, `normalize`.", "question_id": 36017}
{"snippet": "DataFrame.value_counts(subset=None, sort=True)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With arguments `subset`, `sort`.", "question_id": 36018}
{"snippet": "DataFrame.value_counts(subset=None, ascending=False)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With arguments `subset`, `ascending`.", "question_id": 36019}
{"snippet": "DataFrame.value_counts(subset=None, dropna=True)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With `dropna` set to False we can also count rows with NA values . With arguments `subset`.", "question_id": 36020}
{"snippet": "DataFrame.value_counts()", "intent": "Return a Series containing counts of unique rows in the DataFrame .", "question_id": 36021}
{"snippet": "DataFrame.value_counts(subset=None)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With arguments `subset`.", "question_id": 36022}
{"snippet": "DataFrame.value_counts(normalize=False)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With arguments `normalize`.", "question_id": 36023}
{"snippet": "DataFrame.value_counts(sort=True)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With arguments `sort`.", "question_id": 36024}
{"snippet": "DataFrame.value_counts(ascending=False)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With arguments `ascending`.", "question_id": 36025}
{"snippet": "DataFrame.value_counts(dropna=True)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With `dropna` set to False we can also count rows with NA values .", "question_id": 36026}
{"snippet": "DataFrame.value_counts(subset=None, normalize=False)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With arguments `subset`, `normalize`.", "question_id": 36027}
{"snippet": "DataFrame.value_counts(subset=None, sort=True)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With arguments `subset`, `sort`.", "question_id": 36028}
{"snippet": "DataFrame.value_counts(subset=None, ascending=False)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With arguments `subset`, `ascending`.", "question_id": 36029}
{"snippet": "DataFrame.value_counts(subset=None, dropna=True)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With `dropna` set to False we can also count rows with NA values . With arguments `subset`.", "question_id": 36030}
{"snippet": "DataFrame.value_counts()", "intent": "Return a Series containing counts of unique rows in the DataFrame .", "question_id": 36031}
{"snippet": "DataFrame.value_counts(subset=None)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With arguments `subset`.", "question_id": 36032}
{"snippet": "DataFrame.value_counts(normalize=False)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With arguments `normalize`.", "question_id": 36033}
{"snippet": "DataFrame.value_counts(sort=True)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With arguments `sort`.", "question_id": 36034}
{"snippet": "DataFrame.value_counts(ascending=False)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With arguments `ascending`.", "question_id": 36035}
{"snippet": "DataFrame.value_counts(dropna=True)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With `dropna` set to False we can also count rows with NA values .", "question_id": 36036}
{"snippet": "DataFrame.value_counts(subset=None, normalize=False)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With arguments `subset`, `normalize`.", "question_id": 36037}
{"snippet": "DataFrame.value_counts(subset=None, sort=True)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With arguments `subset`, `sort`.", "question_id": 36038}
{"snippet": "DataFrame.value_counts(subset=None, ascending=False)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With arguments `subset`, `ascending`.", "question_id": 36039}
{"snippet": "DataFrame.value_counts(subset=None, dropna=True)", "intent": "Return a Series containing counts of unique rows in the DataFrame . With `dropna` set to False we can also count rows with NA values . With arguments `subset`.", "question_id": 36040}
{"snippet": "DataFrame.var(**kwargs)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`.", "question_id": 36041}
{"snippet": "DataFrame.var(**kwargs, axis=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`.", "question_id": 36042}
{"snippet": "DataFrame.var(**kwargs, skipna=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 36043}
{"snippet": "DataFrame.var(**kwargs, level=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 36044}
{"snippet": "DataFrame.var(**kwargs, ddof=1)", "intent": "Return unbiased variance over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 36045}
{"snippet": "DataFrame.var(**kwargs, numeric_only=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 36046}
{"snippet": "DataFrame.var(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 36047}
{"snippet": "DataFrame.var(**kwargs, axis=None, level=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 36048}
{"snippet": "DataFrame.var(**kwargs, axis=None, ddof=1)", "intent": "Return unbiased variance over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 36049}
{"snippet": "DataFrame.var(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 36050}
{"snippet": "DataFrame.var(**kwargs)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`.", "question_id": 36051}
{"snippet": "DataFrame.var(**kwargs, axis=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`.", "question_id": 36052}
{"snippet": "DataFrame.var(**kwargs, skipna=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 36053}
{"snippet": "DataFrame.var(**kwargs, level=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 36054}
{"snippet": "DataFrame.var(**kwargs, ddof=1)", "intent": "Return unbiased variance over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 36055}
{"snippet": "DataFrame.var(**kwargs, numeric_only=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 36056}
{"snippet": "DataFrame.var(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 36057}
{"snippet": "DataFrame.var(**kwargs, axis=None, level=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 36058}
{"snippet": "DataFrame.var(**kwargs, axis=None, ddof=1)", "intent": "Return unbiased variance over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 36059}
{"snippet": "DataFrame.var(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 36060}
{"snippet": "DataFrame.var(**kwargs)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`.", "question_id": 36061}
{"snippet": "DataFrame.var(**kwargs, axis=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`.", "question_id": 36062}
{"snippet": "DataFrame.var(**kwargs, skipna=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 36063}
{"snippet": "DataFrame.var(**kwargs, level=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 36064}
{"snippet": "DataFrame.var(**kwargs, ddof=1)", "intent": "Return unbiased variance over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 36065}
{"snippet": "DataFrame.var(**kwargs, numeric_only=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 36066}
{"snippet": "DataFrame.var(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 36067}
{"snippet": "DataFrame.var(**kwargs, axis=None, level=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 36068}
{"snippet": "DataFrame.var(**kwargs, axis=None, ddof=1)", "intent": "Return unbiased variance over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 36069}
{"snippet": "DataFrame.var(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 36070}
{"snippet": "DataFrame.where(cond)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used .", "question_id": 36071}
{"snippet": "DataFrame.where(cond, other=nan)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used .", "question_id": 36072}
{"snippet": "DataFrame.where(cond, inplace=False)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `inplace`.", "question_id": 36073}
{"snippet": "DataFrame.where(cond, axis=None)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `axis`.", "question_id": 36074}
{"snippet": "DataFrame.where(cond, level=None)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `level`.", "question_id": 36075}
{"snippet": "DataFrame.where(cond, errors='raise')", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `errors`.", "question_id": 36076}
{"snippet": "DataFrame.where(cond, try_cast=NoDefault.no_default)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `try_cast`.", "question_id": 36077}
{"snippet": "DataFrame.where(cond, other=nan, inplace=False)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `inplace`.", "question_id": 36078}
{"snippet": "DataFrame.where(cond, other=nan, axis=None)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `axis`.", "question_id": 36079}
{"snippet": "DataFrame.where(cond, other=nan, level=None)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `level`.", "question_id": 36080}
{"snippet": "DataFrame.where(cond)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used .", "question_id": 36081}
{"snippet": "DataFrame.where(cond, other=nan)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used .", "question_id": 36082}
{"snippet": "DataFrame.where(cond, inplace=False)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `inplace`.", "question_id": 36083}
{"snippet": "DataFrame.where(cond, axis=None)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `axis`.", "question_id": 36084}
{"snippet": "DataFrame.where(cond, level=None)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `level`.", "question_id": 36085}
{"snippet": "DataFrame.where(cond, errors='raise')", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `errors`.", "question_id": 36086}
{"snippet": "DataFrame.where(cond, try_cast=NoDefault.no_default)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `try_cast`.", "question_id": 36087}
{"snippet": "DataFrame.where(cond, other=nan, inplace=False)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `inplace`.", "question_id": 36088}
{"snippet": "DataFrame.where(cond, other=nan, axis=None)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `axis`.", "question_id": 36089}
{"snippet": "DataFrame.where(cond, other=nan, level=None)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `level`.", "question_id": 36090}
{"snippet": "DataFrame.where(cond)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used .", "question_id": 36091}
{"snippet": "DataFrame.where(cond, other=nan)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used .", "question_id": 36092}
{"snippet": "DataFrame.where(cond, inplace=False)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `inplace`.", "question_id": 36093}
{"snippet": "DataFrame.where(cond, axis=None)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `axis`.", "question_id": 36094}
{"snippet": "DataFrame.where(cond, level=None)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `level`.", "question_id": 36095}
{"snippet": "DataFrame.where(cond, errors='raise')", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `errors`.", "question_id": 36096}
{"snippet": "DataFrame.where(cond, try_cast=NoDefault.no_default)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `try_cast`.", "question_id": 36097}
{"snippet": "DataFrame.where(cond, other=nan, inplace=False)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `inplace`.", "question_id": 36098}
{"snippet": "DataFrame.where(cond, other=nan, axis=None)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `axis`.", "question_id": 36099}
{"snippet": "DataFrame.where(cond, other=nan, level=None)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `level`.", "question_id": 36100}
{"snippet": "DataFrame.xs(key)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex .", "question_id": 36101}
{"snippet": "DataFrame.xs(key, axis=0)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . Get values at specified column and `axis`", "question_id": 36102}
{"snippet": "DataFrame.xs(key, level=None)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex .", "question_id": 36103}
{"snippet": "DataFrame.xs(key, drop_level=True)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . With arguments `drop_level`.", "question_id": 36104}
{"snippet": "DataFrame.xs(key, axis=0, level=None)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . Get values at specified column and `axis`", "question_id": 36105}
{"snippet": "DataFrame.xs(key, axis=0, drop_level=True)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . Get values at specified column and `axis` With arguments `drop_level`.", "question_id": 36106}
{"snippet": "DataFrame.xs(key, level=None, drop_level=True)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . With arguments `drop_level`.", "question_id": 36107}
{"snippet": "DataFrame.xs(key, axis=0, level=None, drop_level=True)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . Get values at specified column and `axis` With arguments `drop_level`.", "question_id": 36108}
{"snippet": "DataFrame.xs(key)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex .", "question_id": 36109}
{"snippet": "DataFrame.xs(key, axis=0)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . Get values at specified column and `axis`", "question_id": 36110}
{"snippet": "DataFrame.xs(key, level=None)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex .", "question_id": 36111}
{"snippet": "DataFrame.xs(key, drop_level=True)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . With arguments `drop_level`.", "question_id": 36112}
{"snippet": "DataFrame.xs(key, axis=0, level=None)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . Get values at specified column and `axis`", "question_id": 36113}
{"snippet": "DataFrame.xs(key, axis=0, drop_level=True)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . Get values at specified column and `axis` With arguments `drop_level`.", "question_id": 36114}
{"snippet": "DataFrame.xs(key, level=None, drop_level=True)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . With arguments `drop_level`.", "question_id": 36115}
{"snippet": "DataFrame.xs(key, axis=0, level=None, drop_level=True)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . Get values at specified column and `axis` With arguments `drop_level`.", "question_id": 36116}
{"snippet": "DataFrame.xs(key)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex .", "question_id": 36117}
{"snippet": "DataFrame.xs(key, axis=0)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . Get values at specified column and `axis`", "question_id": 36118}
{"snippet": "DataFrame.xs(key, level=None)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex .", "question_id": 36119}
{"snippet": "DataFrame.xs(key, drop_level=True)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . With arguments `drop_level`.", "question_id": 36120}
{"snippet": "DataFrame.xs(key, axis=0, level=None)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . Get values at specified column and `axis`", "question_id": 36121}
{"snippet": "DataFrame.xs(key, axis=0, drop_level=True)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . Get values at specified column and `axis` With arguments `drop_level`.", "question_id": 36122}
{"snippet": "DataFrame.xs(key, level=None, drop_level=True)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . With arguments `drop_level`.", "question_id": 36123}
{"snippet": "DataFrame.xs(key, axis=0, level=None, drop_level=True)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . Get values at specified column and `axis` With arguments `drop_level`.", "question_id": 36124}
{"snippet": "DatetimeIndex.ceil(*args, **kwargs)", "intent": "Perform ceil operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 36125}
{"snippet": "DatetimeIndex.ceil(*args, **kwargs)", "intent": "Perform ceil operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 36126}
{"snippet": "DatetimeIndex.ceil(*args, **kwargs)", "intent": "Perform ceil operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 36127}
{"snippet": "DatetimeIndex.day_name(*args, **kwargs)", "intent": "Return the day names of the DateTimeIndex with specified locale . With arguments `*args`, `**kwargs`.", "question_id": 36128}
{"snippet": "DatetimeIndex.day_name(*args, **kwargs)", "intent": "Return the day names of the DateTimeIndex with specified locale . With arguments `*args`, `**kwargs`.", "question_id": 36129}
{"snippet": "DatetimeIndex.day_name(*args, **kwargs)", "intent": "Return the day names of the DateTimeIndex with specified locale . With arguments `*args`, `**kwargs`.", "question_id": 36130}
{"snippet": "DatetimeIndex.floor(*args, **kwargs)", "intent": "Perform floor operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 36131}
{"snippet": "DatetimeIndex.floor(*args, **kwargs)", "intent": "Perform floor operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 36132}
{"snippet": "DatetimeIndex.floor(*args, **kwargs)", "intent": "Perform floor operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 36133}
{"snippet": "pandas.DatetimeIndex()", "intent": "Immutable ndarray-like of datetime64 `data` .", "question_id": 36134}
{"snippet": "pandas.DatetimeIndex(data=None)", "intent": "Immutable ndarray-like of datetime64 `data` .", "question_id": 36135}
{"snippet": "pandas.DatetimeIndex(freq=NoDefault.no_default)", "intent": "Immutable ndarray-like of datetime64 `data` . With arguments `freq`.", "question_id": 36136}
{"snippet": "pandas.DatetimeIndex(tz=None)", "intent": "Immutable ndarray-like of datetime64 `data` . With arguments `tz`.", "question_id": 36137}
{"snippet": "pandas.DatetimeIndex(normalize=False)", "intent": "Immutable ndarray-like of datetime64 `data` . With arguments `normalize`.", "question_id": 36138}
{"snippet": "pandas.DatetimeIndex(closed=None)", "intent": "Immutable ndarray-like of datetime64 `data` . With arguments `closed`.", "question_id": 36139}
{"snippet": "pandas.DatetimeIndex(ambiguous='raise')", "intent": "Immutable ndarray-like of datetime64 `data` . With arguments `ambiguous`.", "question_id": 36140}
{"snippet": "pandas.DatetimeIndex(dayfirst=False)", "intent": "Immutable ndarray-like of datetime64 `data` . With arguments `dayfirst`.", "question_id": 36141}
{"snippet": "pandas.DatetimeIndex(yearfirst=False)", "intent": "Immutable ndarray-like of datetime64 `data` . With arguments `yearfirst`.", "question_id": 36142}
{"snippet": "pandas.DatetimeIndex(dtype=None)", "intent": "Immutable ndarray-like of datetime64 `data` . With arguments `dtype`.", "question_id": 36143}
{"snippet": "pandas.DatetimeIndex()", "intent": "Immutable ndarray-like of datetime64 `data` .", "question_id": 36144}
{"snippet": "pandas.DatetimeIndex(data=None)", "intent": "Immutable ndarray-like of datetime64 `data` .", "question_id": 36145}
{"snippet": "pandas.DatetimeIndex(freq=NoDefault.no_default)", "intent": "Immutable ndarray-like of datetime64 `data` . With arguments `freq`.", "question_id": 36146}
{"snippet": "pandas.DatetimeIndex(tz=None)", "intent": "Immutable ndarray-like of datetime64 `data` . With arguments `tz`.", "question_id": 36147}
{"snippet": "pandas.DatetimeIndex(normalize=False)", "intent": "Immutable ndarray-like of datetime64 `data` . With arguments `normalize`.", "question_id": 36148}
{"snippet": "pandas.DatetimeIndex(closed=None)", "intent": "Immutable ndarray-like of datetime64 `data` . With arguments `closed`.", "question_id": 36149}
{"snippet": "pandas.DatetimeIndex(ambiguous='raise')", "intent": "Immutable ndarray-like of datetime64 `data` . With arguments `ambiguous`.", "question_id": 36150}
{"snippet": "pandas.DatetimeIndex(dayfirst=False)", "intent": "Immutable ndarray-like of datetime64 `data` . With arguments `dayfirst`.", "question_id": 36151}
{"snippet": "pandas.DatetimeIndex(yearfirst=False)", "intent": "Immutable ndarray-like of datetime64 `data` . With arguments `yearfirst`.", "question_id": 36152}
{"snippet": "pandas.DatetimeIndex(dtype=None)", "intent": "Immutable ndarray-like of datetime64 `data` . With arguments `dtype`.", "question_id": 36153}
{"snippet": "pandas.DatetimeIndex()", "intent": "Immutable ndarray-like of datetime64 `data` .", "question_id": 36154}
{"snippet": "pandas.DatetimeIndex(data=None)", "intent": "Immutable ndarray-like of datetime64 `data` .", "question_id": 36155}
{"snippet": "pandas.DatetimeIndex(freq=NoDefault.no_default)", "intent": "Immutable ndarray-like of datetime64 `data` . With arguments `freq`.", "question_id": 36156}
{"snippet": "pandas.DatetimeIndex(tz=None)", "intent": "Immutable ndarray-like of datetime64 `data` . With arguments `tz`.", "question_id": 36157}
{"snippet": "pandas.DatetimeIndex(normalize=False)", "intent": "Immutable ndarray-like of datetime64 `data` . With arguments `normalize`.", "question_id": 36158}
{"snippet": "pandas.DatetimeIndex(closed=None)", "intent": "Immutable ndarray-like of datetime64 `data` . With arguments `closed`.", "question_id": 36159}
{"snippet": "pandas.DatetimeIndex(ambiguous='raise')", "intent": "Immutable ndarray-like of datetime64 `data` . With arguments `ambiguous`.", "question_id": 36160}
{"snippet": "pandas.DatetimeIndex(dayfirst=False)", "intent": "Immutable ndarray-like of datetime64 `data` . With arguments `dayfirst`.", "question_id": 36161}
{"snippet": "pandas.DatetimeIndex(yearfirst=False)", "intent": "Immutable ndarray-like of datetime64 `data` . With arguments `yearfirst`.", "question_id": 36162}
{"snippet": "pandas.DatetimeIndex(dtype=None)", "intent": "Immutable ndarray-like of datetime64 `data` . With arguments `dtype`.", "question_id": 36163}
{"snippet": "DatetimeIndex.indexer_at_time(time)", "intent": "Return index locations of values at particular `time` of day ( e.g .", "question_id": 36164}
{"snippet": "DatetimeIndex.indexer_at_time(time, asof=False)", "intent": "Return index locations of values at particular `time` of day ( e.g . With arguments `asof`.", "question_id": 36165}
{"snippet": "DatetimeIndex.indexer_at_time(time)", "intent": "Return index locations of values at particular `time` of day ( e.g .", "question_id": 36166}
{"snippet": "DatetimeIndex.indexer_at_time(time, asof=False)", "intent": "Return index locations of values at particular `time` of day ( e.g . With arguments `asof`.", "question_id": 36167}
{"snippet": "DatetimeIndex.indexer_at_time(time)", "intent": "Return index locations of values at particular `time` of day ( e.g .", "question_id": 36168}
{"snippet": "DatetimeIndex.indexer_at_time(time, asof=False)", "intent": "Return index locations of values at particular `time` of day ( e.g . With arguments `asof`.", "question_id": 36169}
{"snippet": "DatetimeIndex.indexer_between_time(start_time, end_time)", "intent": "Return index locations of values between particular times of day ( e.g. , 9:00-9:30AM ) . With arguments `start_time`, `end_time`.", "question_id": 36170}
{"snippet": "DatetimeIndex.indexer_between_time(start_time, end_time, include_start=True)", "intent": "Return index locations of values between particular times of day ( e.g. , 9:00-9:30AM ) . With arguments `start_time`, `end_time`, `include_start`.", "question_id": 36171}
{"snippet": "DatetimeIndex.indexer_between_time(start_time, end_time, include_end=True)", "intent": "Return index locations of values between particular times of day ( e.g. , 9:00-9:30AM ) . With arguments `start_time`, `end_time`, `include_end`.", "question_id": 36172}
{"snippet": "DatetimeIndex.indexer_between_time(start_time, end_time, include_start=True, include_end=True)", "intent": "Return index locations of values between particular times of day ( e.g. , 9:00-9:30AM ) . With arguments `start_time`, `end_time`, `include_start`, `include_end`.", "question_id": 36173}
{"snippet": "DatetimeIndex.indexer_between_time(start_time, end_time)", "intent": "Return index locations of values between particular times of day ( e.g. , 9:00-9:30AM ) . With arguments `start_time`, `end_time`.", "question_id": 36174}
{"snippet": "DatetimeIndex.indexer_between_time(start_time, end_time, include_start=True)", "intent": "Return index locations of values between particular times of day ( e.g. , 9:00-9:30AM ) . With arguments `start_time`, `end_time`, `include_start`.", "question_id": 36175}
{"snippet": "DatetimeIndex.indexer_between_time(start_time, end_time, include_end=True)", "intent": "Return index locations of values between particular times of day ( e.g. , 9:00-9:30AM ) . With arguments `start_time`, `end_time`, `include_end`.", "question_id": 36176}
{"snippet": "DatetimeIndex.indexer_between_time(start_time, end_time, include_start=True, include_end=True)", "intent": "Return index locations of values between particular times of day ( e.g. , 9:00-9:30AM ) . With arguments `start_time`, `end_time`, `include_start`, `include_end`.", "question_id": 36177}
{"snippet": "DatetimeIndex.indexer_between_time(start_time, end_time)", "intent": "Return index locations of values between particular times of day ( e.g. , 9:00-9:30AM ) . With arguments `start_time`, `end_time`.", "question_id": 36178}
{"snippet": "DatetimeIndex.indexer_between_time(start_time, end_time, include_start=True)", "intent": "Return index locations of values between particular times of day ( e.g. , 9:00-9:30AM ) . With arguments `start_time`, `end_time`, `include_start`.", "question_id": 36179}
{"snippet": "DatetimeIndex.indexer_between_time(start_time, end_time, include_end=True)", "intent": "Return index locations of values between particular times of day ( e.g. , 9:00-9:30AM ) . With arguments `start_time`, `end_time`, `include_end`.", "question_id": 36180}
{"snippet": "DatetimeIndex.indexer_between_time(start_time, end_time, include_start=True, include_end=True)", "intent": "Return index locations of values between particular times of day ( e.g. , 9:00-9:30AM ) . With arguments `start_time`, `end_time`, `include_start`, `include_end`.", "question_id": 36181}
{"snippet": "DatetimeIndex.inferred_freq", "intent": "Tries to return a string representing a frequency guess, generated by infer_freq.", "question_id": 36182}
{"snippet": "DatetimeIndex.inferred_freq", "intent": "Tries to return a string representing a frequency guess, generated by infer_freq.", "question_id": 36183}
{"snippet": "DatetimeIndex.inferred_freq", "intent": "Tries to return a string representing a frequency guess, generated by infer_freq.", "question_id": 36184}
{"snippet": "DatetimeIndex.mean(*args, **kwargs)", "intent": "Return the mean value of the Array . With arguments `*args`, `**kwargs`.", "question_id": 36185}
{"snippet": "DatetimeIndex.mean(*args, **kwargs)", "intent": "Return the mean value of the Array . With arguments `*args`, `**kwargs`.", "question_id": 36186}
{"snippet": "DatetimeIndex.mean(*args, **kwargs)", "intent": "Return the mean value of the Array . With arguments `*args`, `**kwargs`.", "question_id": 36187}
{"snippet": "DatetimeIndex.month_name(*args, **kwargs)", "intent": "Return the month names of the DateTimeIndex with specified locale . With arguments `*args`, `**kwargs`.", "question_id": 36188}
{"snippet": "DatetimeIndex.month_name(*args, **kwargs)", "intent": "Return the month names of the DateTimeIndex with specified locale . With arguments `*args`, `**kwargs`.", "question_id": 36189}
{"snippet": "DatetimeIndex.month_name(*args, **kwargs)", "intent": "Return the month names of the DateTimeIndex with specified locale . With arguments `*args`, `**kwargs`.", "question_id": 36190}
{"snippet": "DatetimeIndex.normalize(*args, **kwargs)", "intent": "Convert times to midnight . With arguments `*args`, `**kwargs`.", "question_id": 36191}
{"snippet": "DatetimeIndex.normalize(*args, **kwargs)", "intent": "Convert times to midnight . With arguments `*args`, `**kwargs`.", "question_id": 36192}
{"snippet": "DatetimeIndex.normalize(*args, **kwargs)", "intent": "Convert times to midnight . With arguments `*args`, `**kwargs`.", "question_id": 36193}
{"snippet": "DatetimeIndex.round(*args, **kwargs)", "intent": "Perform round operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 36194}
{"snippet": "DatetimeIndex.round(*args, **kwargs)", "intent": "Perform round operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 36195}
{"snippet": "DatetimeIndex.round(*args, **kwargs)", "intent": "Perform round operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 36196}
{"snippet": "DatetimeIndex.snap()", "intent": "Snap time stamps to nearest occurring frequency .", "question_id": 36197}
{"snippet": "DatetimeIndex.snap(freq='S')", "intent": "Snap time stamps to nearest occurring frequency . With arguments `freq`.", "question_id": 36198}
{"snippet": "DatetimeIndex.snap()", "intent": "Snap time stamps to nearest occurring frequency .", "question_id": 36199}
{"snippet": "DatetimeIndex.snap(freq='S')", "intent": "Snap time stamps to nearest occurring frequency . With arguments `freq`.", "question_id": 36200}
{"snippet": "DatetimeIndex.snap()", "intent": "Snap time stamps to nearest occurring frequency .", "question_id": 36201}
{"snippet": "DatetimeIndex.snap(freq='S')", "intent": "Snap time stamps to nearest occurring frequency . With arguments `freq`.", "question_id": 36202}
{"snippet": "DatetimeIndex.strftime(*args, **kwargs)", "intent": "Convert to Index using specified date_format . With arguments `*args`, `**kwargs`.", "question_id": 36203}
{"snippet": "DatetimeIndex.strftime(*args, **kwargs)", "intent": "Convert to Index using specified date_format . With arguments `*args`, `**kwargs`.", "question_id": 36204}
{"snippet": "DatetimeIndex.strftime(*args, **kwargs)", "intent": "Convert to Index using specified date_format . With arguments `*args`, `**kwargs`.", "question_id": 36205}
{"snippet": "DatetimeIndex.to_frame()", "intent": "Create a DataFrame with a column containing the Index .", "question_id": 36206}
{"snippet": "DatetimeIndex.to_frame(index=True)", "intent": "Create a DataFrame with a column containing the Index . With arguments `index`.", "question_id": 36207}
{"snippet": "DatetimeIndex.to_frame(name=None)", "intent": "Create a DataFrame with a column containing the Index . To override the `name` of the resulting column , specify name :", "question_id": 36208}
{"snippet": "DatetimeIndex.to_frame(index=True, name=None)", "intent": "Create a DataFrame with a column containing the Index . To override the `name` of the resulting column , specify name : With arguments `index`.", "question_id": 36209}
{"snippet": "DatetimeIndex.to_frame()", "intent": "Create a DataFrame with a column containing the Index .", "question_id": 36210}
{"snippet": "DatetimeIndex.to_frame(index=True)", "intent": "Create a DataFrame with a column containing the Index . With arguments `index`.", "question_id": 36211}
{"snippet": "DatetimeIndex.to_frame(name=None)", "intent": "Create a DataFrame with a column containing the Index . To override the `name` of the resulting column , specify name :", "question_id": 36212}
{"snippet": "DatetimeIndex.to_frame(index=True, name=None)", "intent": "Create a DataFrame with a column containing the Index . To override the `name` of the resulting column , specify name : With arguments `index`.", "question_id": 36213}
{"snippet": "DatetimeIndex.to_frame()", "intent": "Create a DataFrame with a column containing the Index .", "question_id": 36214}
{"snippet": "DatetimeIndex.to_frame(index=True)", "intent": "Create a DataFrame with a column containing the Index . With arguments `index`.", "question_id": 36215}
{"snippet": "DatetimeIndex.to_frame(name=None)", "intent": "Create a DataFrame with a column containing the Index . To override the `name` of the resulting column , specify name :", "question_id": 36216}
{"snippet": "DatetimeIndex.to_frame(index=True, name=None)", "intent": "Create a DataFrame with a column containing the Index . To override the `name` of the resulting column , specify name : With arguments `index`.", "question_id": 36217}
{"snippet": "DatetimeIndex.to_period(*args, **kwargs)", "intent": "Cast to PeriodArray/Index at a particular frequency . With arguments `*args`, `**kwargs`.", "question_id": 36218}
{"snippet": "DatetimeIndex.to_period(*args, **kwargs)", "intent": "Cast to PeriodArray/Index at a particular frequency . With arguments `*args`, `**kwargs`.", "question_id": 36219}
{"snippet": "DatetimeIndex.to_period(*args, **kwargs)", "intent": "Cast to PeriodArray/Index at a particular frequency . With arguments `*args`, `**kwargs`.", "question_id": 36220}
{"snippet": "DatetimeIndex.to_perioddelta(freq)", "intent": "Calculate TimedeltaArray of difference between index values and index converted to PeriodArray at specified `freq` .", "question_id": 36221}
{"snippet": "DatetimeIndex.to_perioddelta(freq)", "intent": "Calculate TimedeltaArray of difference between index values and index converted to PeriodArray at specified `freq` .", "question_id": 36222}
{"snippet": "DatetimeIndex.to_perioddelta(freq)", "intent": "Calculate TimedeltaArray of difference between index values and index converted to PeriodArray at specified `freq` .", "question_id": 36223}
{"snippet": "DatetimeIndex.to_pydatetime(*args, **kwargs)", "intent": "Return Datetime Array/Index as object ndarray of datetime.datetime objects . With arguments `*args`, `**kwargs`.", "question_id": 36224}
{"snippet": "DatetimeIndex.to_pydatetime(*args, **kwargs)", "intent": "Return Datetime Array/Index as object ndarray of datetime.datetime objects . With arguments `*args`, `**kwargs`.", "question_id": 36225}
{"snippet": "DatetimeIndex.to_pydatetime(*args, **kwargs)", "intent": "Return Datetime Array/Index as object ndarray of datetime.datetime objects . With arguments `*args`, `**kwargs`.", "question_id": 36226}
{"snippet": "DatetimeIndex.to_series()", "intent": "Create a Series with both `index` and values equal to the index keys useful with map for returning an indexer based on an index .", "question_id": 36227}
{"snippet": "DatetimeIndex.to_series(keep_tz=NoDefault.no_default)", "intent": "Create a Series with both `index` and values equal to the index keys useful with map for returning an indexer based on an index . With arguments `keep_tz`.", "question_id": 36228}
{"snippet": "DatetimeIndex.to_series(index=None)", "intent": "Create a Series with both `index` and values equal to the index keys useful with map for returning an indexer based on an index .", "question_id": 36229}
{"snippet": "DatetimeIndex.to_series(name=None)", "intent": "Create a Series with both `index` and values equal to the index keys useful with map for returning an indexer based on an index . With arguments `name`.", "question_id": 36230}
{"snippet": "DatetimeIndex.to_series(keep_tz=NoDefault.no_default, index=None)", "intent": "Create a Series with both `index` and values equal to the index keys useful with map for returning an indexer based on an index . With arguments `keep_tz`.", "question_id": 36231}
{"snippet": "DatetimeIndex.to_series(keep_tz=NoDefault.no_default, name=None)", "intent": "Create a Series with both `index` and values equal to the index keys useful with map for returning an indexer based on an index . With arguments `keep_tz`, `name`.", "question_id": 36232}
{"snippet": "DatetimeIndex.to_series(index=None, name=None)", "intent": "Create a Series with both `index` and values equal to the index keys useful with map for returning an indexer based on an index . With arguments `name`.", "question_id": 36233}
{"snippet": "DatetimeIndex.to_series(keep_tz=NoDefault.no_default, index=None, name=None)", "intent": "Create a Series with both `index` and values equal to the index keys useful with map for returning an indexer based on an index . With arguments `keep_tz`, `name`.", "question_id": 36234}
{"snippet": "DatetimeIndex.to_series()", "intent": "Create a Series with both `index` and values equal to the index keys useful with map for returning an indexer based on an index .", "question_id": 36235}
{"snippet": "DatetimeIndex.to_series(keep_tz=NoDefault.no_default)", "intent": "Create a Series with both `index` and values equal to the index keys useful with map for returning an indexer based on an index . With arguments `keep_tz`.", "question_id": 36236}
{"snippet": "DatetimeIndex.to_series(index=None)", "intent": "Create a Series with both `index` and values equal to the index keys useful with map for returning an indexer based on an index .", "question_id": 36237}
{"snippet": "DatetimeIndex.to_series(name=None)", "intent": "Create a Series with both `index` and values equal to the index keys useful with map for returning an indexer based on an index . With arguments `name`.", "question_id": 36238}
{"snippet": "DatetimeIndex.to_series(keep_tz=NoDefault.no_default, index=None)", "intent": "Create a Series with both `index` and values equal to the index keys useful with map for returning an indexer based on an index . With arguments `keep_tz`.", "question_id": 36239}
{"snippet": "DatetimeIndex.to_series(keep_tz=NoDefault.no_default, name=None)", "intent": "Create a Series with both `index` and values equal to the index keys useful with map for returning an indexer based on an index . With arguments `keep_tz`, `name`.", "question_id": 36240}
{"snippet": "DatetimeIndex.to_series(index=None, name=None)", "intent": "Create a Series with both `index` and values equal to the index keys useful with map for returning an indexer based on an index . With arguments `name`.", "question_id": 36241}
{"snippet": "DatetimeIndex.to_series(keep_tz=NoDefault.no_default, index=None, name=None)", "intent": "Create a Series with both `index` and values equal to the index keys useful with map for returning an indexer based on an index . With arguments `keep_tz`, `name`.", "question_id": 36242}
{"snippet": "DatetimeIndex.to_series()", "intent": "Create a Series with both `index` and values equal to the index keys useful with map for returning an indexer based on an index .", "question_id": 36243}
{"snippet": "DatetimeIndex.to_series(keep_tz=NoDefault.no_default)", "intent": "Create a Series with both `index` and values equal to the index keys useful with map for returning an indexer based on an index . With arguments `keep_tz`.", "question_id": 36244}
{"snippet": "DatetimeIndex.to_series(index=None)", "intent": "Create a Series with both `index` and values equal to the index keys useful with map for returning an indexer based on an index .", "question_id": 36245}
{"snippet": "DatetimeIndex.to_series(name=None)", "intent": "Create a Series with both `index` and values equal to the index keys useful with map for returning an indexer based on an index . With arguments `name`.", "question_id": 36246}
{"snippet": "DatetimeIndex.to_series(keep_tz=NoDefault.no_default, index=None)", "intent": "Create a Series with both `index` and values equal to the index keys useful with map for returning an indexer based on an index . With arguments `keep_tz`.", "question_id": 36247}
{"snippet": "DatetimeIndex.to_series(keep_tz=NoDefault.no_default, name=None)", "intent": "Create a Series with both `index` and values equal to the index keys useful with map for returning an indexer based on an index . With arguments `keep_tz`, `name`.", "question_id": 36248}
{"snippet": "DatetimeIndex.to_series(index=None, name=None)", "intent": "Create a Series with both `index` and values equal to the index keys useful with map for returning an indexer based on an index . With arguments `name`.", "question_id": 36249}
{"snippet": "DatetimeIndex.to_series(keep_tz=NoDefault.no_default, index=None, name=None)", "intent": "Create a Series with both `index` and values equal to the index keys useful with map for returning an indexer based on an index . With arguments `keep_tz`, `name`.", "question_id": 36250}
{"snippet": "DatetimeIndex.tz_convert(tz)", "intent": "Convert tz-aware Datetime Array/Index from one time zone to another . With the `tz` parameter , we can change the DatetimeIndex to other time zones :", "question_id": 36251}
{"snippet": "DatetimeIndex.tz_convert(tz)", "intent": "Convert tz-aware Datetime Array/Index from one time zone to another . With the `tz` parameter , we can change the DatetimeIndex to other time zones :", "question_id": 36252}
{"snippet": "DatetimeIndex.tz_convert(tz)", "intent": "Convert tz-aware Datetime Array/Index from one time zone to another . With the `tz` parameter , we can change the DatetimeIndex to other time zones :", "question_id": 36253}
{"snippet": "DatetimeIndex.tz_localize(tz)", "intent": "Localize tz-naive Datetime Array/Index to tz-aware Datetime Array/Index . This method takes a time zone ( `tz` ) naive Datetime Array/Index object and makes this time zone aware .", "question_id": 36254}
{"snippet": "DatetimeIndex.tz_localize(tz, ambiguous='raise')", "intent": "Localize tz-naive Datetime Array/Index to tz-aware Datetime Array/Index . This method takes a time zone ( `tz` ) naive Datetime Array/Index object and makes this time zone aware . In such cases , you can pass an ndarray to the `ambiguous` parameter to set the DST explicitly", "question_id": 36255}
{"snippet": "DatetimeIndex.tz_localize(tz, nonexistent='raise')", "intent": "Localize tz-naive Datetime Array/Index to tz-aware Datetime Array/Index . This method takes a time zone ( `tz` ) naive Datetime Array/Index object and makes this time zone aware . If the DST transition causes `nonexistent` times , you can shift these dates forward or backwards with a timedelta object or \u2018 shift_forward \u2019 or \u2018 shift_backwards \u2019 .", "question_id": 36256}
{"snippet": "DatetimeIndex.tz_localize(tz, ambiguous='raise', nonexistent='raise')", "intent": "Localize tz-naive Datetime Array/Index to tz-aware Datetime Array/Index . This method takes a time zone ( `tz` ) naive Datetime Array/Index object and makes this time zone aware . In such cases , you can pass an ndarray to the `ambiguous` parameter to set the DST explicitly If the DST transition causes `nonexistent` times , you can shift these dates forward or backwards with a timedelta object or \u2018 shift_forward \u2019 or \u2018 shift_backwards \u2019 .", "question_id": 36257}
{"snippet": "DatetimeIndex.tz_localize(tz)", "intent": "Localize tz-naive Datetime Array/Index to tz-aware Datetime Array/Index . This method takes a time zone ( `tz` ) naive Datetime Array/Index object and makes this time zone aware .", "question_id": 36258}
{"snippet": "DatetimeIndex.tz_localize(tz, ambiguous='raise')", "intent": "Localize tz-naive Datetime Array/Index to tz-aware Datetime Array/Index . This method takes a time zone ( `tz` ) naive Datetime Array/Index object and makes this time zone aware . In such cases , you can pass an ndarray to the `ambiguous` parameter to set the DST explicitly", "question_id": 36259}
{"snippet": "DatetimeIndex.tz_localize(tz, nonexistent='raise')", "intent": "Localize tz-naive Datetime Array/Index to tz-aware Datetime Array/Index . This method takes a time zone ( `tz` ) naive Datetime Array/Index object and makes this time zone aware . If the DST transition causes `nonexistent` times , you can shift these dates forward or backwards with a timedelta object or \u2018 shift_forward \u2019 or \u2018 shift_backwards \u2019 .", "question_id": 36260}
{"snippet": "DatetimeIndex.tz_localize(tz, ambiguous='raise', nonexistent='raise')", "intent": "Localize tz-naive Datetime Array/Index to tz-aware Datetime Array/Index . This method takes a time zone ( `tz` ) naive Datetime Array/Index object and makes this time zone aware . In such cases , you can pass an ndarray to the `ambiguous` parameter to set the DST explicitly If the DST transition causes `nonexistent` times , you can shift these dates forward or backwards with a timedelta object or \u2018 shift_forward \u2019 or \u2018 shift_backwards \u2019 .", "question_id": 36261}
{"snippet": "DatetimeIndex.tz_localize(tz)", "intent": "Localize tz-naive Datetime Array/Index to tz-aware Datetime Array/Index . This method takes a time zone ( `tz` ) naive Datetime Array/Index object and makes this time zone aware .", "question_id": 36262}
{"snippet": "DatetimeIndex.tz_localize(tz, ambiguous='raise')", "intent": "Localize tz-naive Datetime Array/Index to tz-aware Datetime Array/Index . This method takes a time zone ( `tz` ) naive Datetime Array/Index object and makes this time zone aware . In such cases , you can pass an ndarray to the `ambiguous` parameter to set the DST explicitly", "question_id": 36263}
{"snippet": "DatetimeIndex.tz_localize(tz, nonexistent='raise')", "intent": "Localize tz-naive Datetime Array/Index to tz-aware Datetime Array/Index . This method takes a time zone ( `tz` ) naive Datetime Array/Index object and makes this time zone aware . If the DST transition causes `nonexistent` times , you can shift these dates forward or backwards with a timedelta object or \u2018 shift_forward \u2019 or \u2018 shift_backwards \u2019 .", "question_id": 36264}
{"snippet": "DatetimeIndex.tz_localize(tz, ambiguous='raise', nonexistent='raise')", "intent": "Localize tz-naive Datetime Array/Index to tz-aware Datetime Array/Index . This method takes a time zone ( `tz` ) naive Datetime Array/Index object and makes this time zone aware . In such cases , you can pass an ndarray to the `ambiguous` parameter to set the DST explicitly If the DST transition causes `nonexistent` times , you can shift these dates forward or backwards with a timedelta object or \u2018 shift_forward \u2019 or \u2018 shift_backwards \u2019 .", "question_id": 36265}
{"snippet": "pandas.DatetimeTZDtype()", "intent": "An ExtensionDtype for timezone-aware datetime data .", "question_id": 36266}
{"snippet": "pandas.DatetimeTZDtype(unit='ns')", "intent": "An ExtensionDtype for timezone-aware datetime data . With arguments `unit`.", "question_id": 36267}
{"snippet": "pandas.DatetimeTZDtype(tz=None)", "intent": "An ExtensionDtype for timezone-aware datetime data . With arguments `tz`.", "question_id": 36268}
{"snippet": "pandas.DatetimeTZDtype(unit='ns', tz=None)", "intent": "An ExtensionDtype for timezone-aware datetime data . With arguments `unit`, `tz`.", "question_id": 36269}
{"snippet": "pandas.DatetimeTZDtype()", "intent": "An ExtensionDtype for timezone-aware datetime data .", "question_id": 36270}
{"snippet": "pandas.DatetimeTZDtype(unit='ns')", "intent": "An ExtensionDtype for timezone-aware datetime data . With arguments `unit`.", "question_id": 36271}
{"snippet": "pandas.DatetimeTZDtype(tz=None)", "intent": "An ExtensionDtype for timezone-aware datetime data . With arguments `tz`.", "question_id": 36272}
{"snippet": "pandas.DatetimeTZDtype(unit='ns', tz=None)", "intent": "An ExtensionDtype for timezone-aware datetime data . With arguments `unit`, `tz`.", "question_id": 36273}
{"snippet": "pandas.DatetimeTZDtype()", "intent": "An ExtensionDtype for timezone-aware datetime data .", "question_id": 36274}
{"snippet": "pandas.DatetimeTZDtype(unit='ns')", "intent": "An ExtensionDtype for timezone-aware datetime data . With arguments `unit`.", "question_id": 36275}
{"snippet": "pandas.DatetimeTZDtype(tz=None)", "intent": "An ExtensionDtype for timezone-aware datetime data . With arguments `tz`.", "question_id": 36276}
{"snippet": "pandas.DatetimeTZDtype(unit='ns', tz=None)", "intent": "An ExtensionDtype for timezone-aware datetime data . With arguments `unit`, `tz`.", "question_id": 36277}
{"snippet": "ExcelFile.parse(**kwds)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`.", "question_id": 36278}
{"snippet": "ExcelFile.parse(**kwds, sheet_name=0)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `sheet_name`.", "question_id": 36279}
{"snippet": "ExcelFile.parse(**kwds, header=0)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `header`.", "question_id": 36280}
{"snippet": "ExcelFile.parse(**kwds, names=None)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `names`.", "question_id": 36281}
{"snippet": "ExcelFile.parse(**kwds, index_col=None)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `index_col`.", "question_id": 36282}
{"snippet": "ExcelFile.parse(**kwds, usecols=None)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `usecols`.", "question_id": 36283}
{"snippet": "ExcelFile.parse(**kwds, squeeze=False)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `squeeze`.", "question_id": 36284}
{"snippet": "ExcelFile.parse(**kwds, converters=None)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `converters`.", "question_id": 36285}
{"snippet": "ExcelFile.parse(**kwds, true_values=None)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `true_values`.", "question_id": 36286}
{"snippet": "ExcelFile.parse(**kwds, false_values=None)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `false_values`.", "question_id": 36287}
{"snippet": "ExcelFile.parse(**kwds)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`.", "question_id": 36288}
{"snippet": "ExcelFile.parse(**kwds, sheet_name=0)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `sheet_name`.", "question_id": 36289}
{"snippet": "ExcelFile.parse(**kwds, header=0)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `header`.", "question_id": 36290}
{"snippet": "ExcelFile.parse(**kwds, names=None)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `names`.", "question_id": 36291}
{"snippet": "ExcelFile.parse(**kwds, index_col=None)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `index_col`.", "question_id": 36292}
{"snippet": "ExcelFile.parse(**kwds, usecols=None)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `usecols`.", "question_id": 36293}
{"snippet": "ExcelFile.parse(**kwds, squeeze=False)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `squeeze`.", "question_id": 36294}
{"snippet": "ExcelFile.parse(**kwds, converters=None)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `converters`.", "question_id": 36295}
{"snippet": "ExcelFile.parse(**kwds, true_values=None)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `true_values`.", "question_id": 36296}
{"snippet": "ExcelFile.parse(**kwds, false_values=None)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `false_values`.", "question_id": 36297}
{"snippet": "ExcelFile.parse(**kwds)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`.", "question_id": 36298}
{"snippet": "ExcelFile.parse(**kwds, sheet_name=0)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `sheet_name`.", "question_id": 36299}
{"snippet": "ExcelFile.parse(**kwds, header=0)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `header`.", "question_id": 36300}
{"snippet": "ExcelFile.parse(**kwds, names=None)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `names`.", "question_id": 36301}
{"snippet": "ExcelFile.parse(**kwds, index_col=None)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `index_col`.", "question_id": 36302}
{"snippet": "ExcelFile.parse(**kwds, usecols=None)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `usecols`.", "question_id": 36303}
{"snippet": "ExcelFile.parse(**kwds, squeeze=False)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `squeeze`.", "question_id": 36304}
{"snippet": "ExcelFile.parse(**kwds, converters=None)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `converters`.", "question_id": 36305}
{"snippet": "ExcelFile.parse(**kwds, true_values=None)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `true_values`.", "question_id": 36306}
{"snippet": "ExcelFile.parse(**kwds, false_values=None)", "intent": "Parse specified sheet ( s ) into a DataFrame . With arguments `**kwds`, `false_values`.", "question_id": 36307}
{"snippet": "pandas.ExcelWriter(path, **kwargs)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`.", "question_id": 36308}
{"snippet": "pandas.ExcelWriter(path, **kwargs, engine=None)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `engine`.", "question_id": 36309}
{"snippet": "pandas.ExcelWriter(path, **kwargs, date_format=None)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `date_format`.", "question_id": 36310}
{"snippet": "pandas.ExcelWriter(path, **kwargs, datetime_format=None)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `datetime_format`.", "question_id": 36311}
{"snippet": "pandas.ExcelWriter(path, **kwargs, mode='w')", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `mode`.", "question_id": 36312}
{"snippet": "pandas.ExcelWriter(path, **kwargs, storage_options=None)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `storage_options`.", "question_id": 36313}
{"snippet": "pandas.ExcelWriter(path, **kwargs, if_sheet_exists=None)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `if_sheet_exists`.", "question_id": 36314}
{"snippet": "pandas.ExcelWriter(path, **kwargs, engine_kwargs=None)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `engine_kwargs`.", "question_id": 36315}
{"snippet": "pandas.ExcelWriter(path, **kwargs, engine=None, date_format=None)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `engine`, `date_format`.", "question_id": 36316}
{"snippet": "pandas.ExcelWriter(path, **kwargs, engine=None, datetime_format=None)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `engine`, `datetime_format`.", "question_id": 36317}
{"snippet": "pandas.ExcelWriter(path, **kwargs)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`.", "question_id": 36318}
{"snippet": "pandas.ExcelWriter(path, **kwargs, engine=None)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `engine`.", "question_id": 36319}
{"snippet": "pandas.ExcelWriter(path, **kwargs, date_format=None)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `date_format`.", "question_id": 36320}
{"snippet": "pandas.ExcelWriter(path, **kwargs, datetime_format=None)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `datetime_format`.", "question_id": 36321}
{"snippet": "pandas.ExcelWriter(path, **kwargs, mode='w')", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `mode`.", "question_id": 36322}
{"snippet": "pandas.ExcelWriter(path, **kwargs, storage_options=None)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `storage_options`.", "question_id": 36323}
{"snippet": "pandas.ExcelWriter(path, **kwargs, if_sheet_exists=None)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `if_sheet_exists`.", "question_id": 36324}
{"snippet": "pandas.ExcelWriter(path, **kwargs, engine_kwargs=None)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `engine_kwargs`.", "question_id": 36325}
{"snippet": "pandas.ExcelWriter(path, **kwargs, engine=None, date_format=None)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `engine`, `date_format`.", "question_id": 36326}
{"snippet": "pandas.ExcelWriter(path, **kwargs, engine=None, datetime_format=None)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `engine`, `datetime_format`.", "question_id": 36327}
{"snippet": "pandas.ExcelWriter(path, **kwargs)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`.", "question_id": 36328}
{"snippet": "pandas.ExcelWriter(path, **kwargs, engine=None)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `engine`.", "question_id": 36329}
{"snippet": "pandas.ExcelWriter(path, **kwargs, date_format=None)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `date_format`.", "question_id": 36330}
{"snippet": "pandas.ExcelWriter(path, **kwargs, datetime_format=None)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `datetime_format`.", "question_id": 36331}
{"snippet": "pandas.ExcelWriter(path, **kwargs, mode='w')", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `mode`.", "question_id": 36332}
{"snippet": "pandas.ExcelWriter(path, **kwargs, storage_options=None)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `storage_options`.", "question_id": 36333}
{"snippet": "pandas.ExcelWriter(path, **kwargs, if_sheet_exists=None)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `if_sheet_exists`.", "question_id": 36334}
{"snippet": "pandas.ExcelWriter(path, **kwargs, engine_kwargs=None)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `engine_kwargs`.", "question_id": 36335}
{"snippet": "pandas.ExcelWriter(path, **kwargs, engine=None, date_format=None)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `engine`, `date_format`.", "question_id": 36336}
{"snippet": "pandas.ExcelWriter(path, **kwargs, engine=None, datetime_format=None)", "intent": "Class for writing DataFrame objects into excel sheets . With arguments `path`, `**kwargs`, `engine`, `datetime_format`.", "question_id": 36337}
{"snippet": "pandas.Flags(obj, allows_duplicate_labels)", "intent": "Flags that apply to pandas objects . With arguments `obj`, `allows_duplicate_labels`.", "question_id": 36338}
{"snippet": "pandas.Flags(obj, allows_duplicate_labels)", "intent": "Flags that apply to pandas objects . With arguments `obj`, `allows_duplicate_labels`.", "question_id": 36339}
{"snippet": "pandas.Flags(obj, allows_duplicate_labels)", "intent": "Flags that apply to pandas objects . With arguments `obj`, `allows_duplicate_labels`.", "question_id": 36340}
{"snippet": "pandas.Float64Index()", "intent": "Immutable sequence used for indexing and alignment .", "question_id": 36341}
{"snippet": "pandas.Float64Index(data=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`.", "question_id": 36342}
{"snippet": "pandas.Float64Index(dtype=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`.", "question_id": 36343}
{"snippet": "pandas.Float64Index(copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `copy`.", "question_id": 36344}
{"snippet": "pandas.Float64Index(name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `name`.", "question_id": 36345}
{"snippet": "pandas.Float64Index(data=None, dtype=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `dtype`.", "question_id": 36346}
{"snippet": "pandas.Float64Index(data=None, copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `copy`.", "question_id": 36347}
{"snippet": "pandas.Float64Index(data=None, name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `name`.", "question_id": 36348}
{"snippet": "pandas.Float64Index(dtype=None, copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`, `copy`.", "question_id": 36349}
{"snippet": "pandas.Float64Index(dtype=None, name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`, `name`.", "question_id": 36350}
{"snippet": "pandas.Float64Index()", "intent": "Immutable sequence used for indexing and alignment .", "question_id": 36351}
{"snippet": "pandas.Float64Index(data=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`.", "question_id": 36352}
{"snippet": "pandas.Float64Index(dtype=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`.", "question_id": 36353}
{"snippet": "pandas.Float64Index(copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `copy`.", "question_id": 36354}
{"snippet": "pandas.Float64Index(name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `name`.", "question_id": 36355}
{"snippet": "pandas.Float64Index(data=None, dtype=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `dtype`.", "question_id": 36356}
{"snippet": "pandas.Float64Index(data=None, copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `copy`.", "question_id": 36357}
{"snippet": "pandas.Float64Index(data=None, name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `name`.", "question_id": 36358}
{"snippet": "pandas.Float64Index(dtype=None, copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`, `copy`.", "question_id": 36359}
{"snippet": "pandas.Float64Index(dtype=None, name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`, `name`.", "question_id": 36360}
{"snippet": "pandas.Float64Index()", "intent": "Immutable sequence used for indexing and alignment .", "question_id": 36361}
{"snippet": "pandas.Float64Index(data=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`.", "question_id": 36362}
{"snippet": "pandas.Float64Index(dtype=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`.", "question_id": 36363}
{"snippet": "pandas.Float64Index(copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `copy`.", "question_id": 36364}
{"snippet": "pandas.Float64Index(name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `name`.", "question_id": 36365}
{"snippet": "pandas.Float64Index(data=None, dtype=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `dtype`.", "question_id": 36366}
{"snippet": "pandas.Float64Index(data=None, copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `copy`.", "question_id": 36367}
{"snippet": "pandas.Float64Index(data=None, name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `name`.", "question_id": 36368}
{"snippet": "pandas.Float64Index(dtype=None, copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`, `copy`.", "question_id": 36369}
{"snippet": "pandas.Float64Index(dtype=None, name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`, `name`.", "question_id": 36370}
{"snippet": "pandas.Grouper(*args, **kwargs)", "intent": "A Grouper allows the user to specify a groupby instruction for an object . With arguments `*args`, `**kwargs`.", "question_id": 36371}
{"snippet": "pandas.Grouper(*args, **kwargs)", "intent": "A Grouper allows the user to specify a groupby instruction for an object . With arguments `*args`, `**kwargs`.", "question_id": 36372}
{"snippet": "pandas.Grouper(*args, **kwargs)", "intent": "A Grouper allows the user to specify a groupby instruction for an object . With arguments `*args`, `**kwargs`.", "question_id": 36373}
{"snippet": "HDFStore.append(key, value)", "intent": "Append to Table in file . With arguments `key`, `value`.", "question_id": 36374}
{"snippet": "HDFStore.append(key, value, format=None)", "intent": "Append to Table in file . Node must already exist and be Table `format` . With arguments `key`, `value`.", "question_id": 36375}
{"snippet": "HDFStore.append(key, value, axes=None)", "intent": "Append to Table in file . With arguments `key`, `value`, `axes`.", "question_id": 36376}
{"snippet": "HDFStore.append(key, value, index=True)", "intent": "Append to Table in file . With arguments `key`, `value`, `index`.", "question_id": 36377}
{"snippet": "HDFStore.append(key, value, append=True)", "intent": "Append to Table in file . With arguments `key`, `value`, `append`.", "question_id": 36378}
{"snippet": "HDFStore.append(key, value, complib=None)", "intent": "Append to Table in file . With arguments `key`, `value`, `complib`.", "question_id": 36379}
{"snippet": "HDFStore.append(key, value, complevel=None)", "intent": "Append to Table in file . With arguments `key`, `value`, `complevel`.", "question_id": 36380}
{"snippet": "HDFStore.append(key, value, columns=None)", "intent": "Append to Table in file . With arguments `key`, `value`, `columns`.", "question_id": 36381}
{"snippet": "HDFStore.append(key, value, min_itemsize=None)", "intent": "Append to Table in file . With arguments `key`, `value`, `min_itemsize`.", "question_id": 36382}
{"snippet": "HDFStore.append(key, value, nan_rep=None)", "intent": "Append to Table in file . With arguments `key`, `value`, `nan_rep`.", "question_id": 36383}
{"snippet": "HDFStore.append(key, value)", "intent": "Append to Table in file . With arguments `key`, `value`.", "question_id": 36384}
{"snippet": "HDFStore.append(key, value, format=None)", "intent": "Append to Table in file . Node must already exist and be Table `format` . With arguments `key`, `value`.", "question_id": 36385}
{"snippet": "HDFStore.append(key, value, axes=None)", "intent": "Append to Table in file . With arguments `key`, `value`, `axes`.", "question_id": 36386}
{"snippet": "HDFStore.append(key, value, index=True)", "intent": "Append to Table in file . With arguments `key`, `value`, `index`.", "question_id": 36387}
{"snippet": "HDFStore.append(key, value, append=True)", "intent": "Append to Table in file . With arguments `key`, `value`, `append`.", "question_id": 36388}
{"snippet": "HDFStore.append(key, value, complib=None)", "intent": "Append to Table in file . With arguments `key`, `value`, `complib`.", "question_id": 36389}
{"snippet": "HDFStore.append(key, value, complevel=None)", "intent": "Append to Table in file . With arguments `key`, `value`, `complevel`.", "question_id": 36390}
{"snippet": "HDFStore.append(key, value, columns=None)", "intent": "Append to Table in file . With arguments `key`, `value`, `columns`.", "question_id": 36391}
{"snippet": "HDFStore.append(key, value, min_itemsize=None)", "intent": "Append to Table in file . With arguments `key`, `value`, `min_itemsize`.", "question_id": 36392}
{"snippet": "HDFStore.append(key, value, nan_rep=None)", "intent": "Append to Table in file . With arguments `key`, `value`, `nan_rep`.", "question_id": 36393}
{"snippet": "HDFStore.append(key, value)", "intent": "Append to Table in file . With arguments `key`, `value`.", "question_id": 36394}
{"snippet": "HDFStore.append(key, value, format=None)", "intent": "Append to Table in file . Node must already exist and be Table `format` . With arguments `key`, `value`.", "question_id": 36395}
{"snippet": "HDFStore.append(key, value, axes=None)", "intent": "Append to Table in file . With arguments `key`, `value`, `axes`.", "question_id": 36396}
{"snippet": "HDFStore.append(key, value, index=True)", "intent": "Append to Table in file . With arguments `key`, `value`, `index`.", "question_id": 36397}
{"snippet": "HDFStore.append(key, value, append=True)", "intent": "Append to Table in file . With arguments `key`, `value`, `append`.", "question_id": 36398}
{"snippet": "HDFStore.append(key, value, complib=None)", "intent": "Append to Table in file . With arguments `key`, `value`, `complib`.", "question_id": 36399}
{"snippet": "HDFStore.append(key, value, complevel=None)", "intent": "Append to Table in file . With arguments `key`, `value`, `complevel`.", "question_id": 36400}
{"snippet": "HDFStore.append(key, value, columns=None)", "intent": "Append to Table in file . With arguments `key`, `value`, `columns`.", "question_id": 36401}
{"snippet": "HDFStore.append(key, value, min_itemsize=None)", "intent": "Append to Table in file . With arguments `key`, `value`, `min_itemsize`.", "question_id": 36402}
{"snippet": "HDFStore.append(key, value, nan_rep=None)", "intent": "Append to Table in file . With arguments `key`, `value`, `nan_rep`.", "question_id": 36403}
{"snippet": "HDFStore.get(key)", "intent": "Retrieve pandas object stored in file . With arguments `key`.", "question_id": 36404}
{"snippet": "HDFStore.get(key)", "intent": "Retrieve pandas object stored in file . With arguments `key`.", "question_id": 36405}
{"snippet": "HDFStore.get(key)", "intent": "Retrieve pandas object stored in file . With arguments `key`.", "question_id": 36406}
{"snippet": "HDFStore.groups()", "intent": "Return a list of all the top-level nodes .", "question_id": 36407}
{"snippet": "HDFStore.groups()", "intent": "Return a list of all the top-level nodes .", "question_id": 36408}
{"snippet": "HDFStore.groups()", "intent": "Return a list of all the top-level nodes .", "question_id": 36409}
{"snippet": "HDFStore.info()", "intent": "Print detailed information on the store .", "question_id": 36410}
{"snippet": "HDFStore.info()", "intent": "Print detailed information on the store .", "question_id": 36411}
{"snippet": "HDFStore.info()", "intent": "Print detailed information on the store .", "question_id": 36412}
{"snippet": "HDFStore.keys()", "intent": "Return a list of keys corresponding to objects stored in HDFStore .", "question_id": 36413}
{"snippet": "HDFStore.keys(include='pandas')", "intent": "Return a list of keys corresponding to objects stored in HDFStore . With arguments `include`.", "question_id": 36414}
{"snippet": "HDFStore.keys()", "intent": "Return a list of keys corresponding to objects stored in HDFStore .", "question_id": 36415}
{"snippet": "HDFStore.keys(include='pandas')", "intent": "Return a list of keys corresponding to objects stored in HDFStore . With arguments `include`.", "question_id": 36416}
{"snippet": "HDFStore.keys()", "intent": "Return a list of keys corresponding to objects stored in HDFStore .", "question_id": 36417}
{"snippet": "HDFStore.keys(include='pandas')", "intent": "Return a list of keys corresponding to objects stored in HDFStore . With arguments `include`.", "question_id": 36418}
{"snippet": "HDFStore.put(key, value)", "intent": "Store object in HDFStore . With arguments `key`, `value`.", "question_id": 36419}
{"snippet": "HDFStore.put(key, value, format=None)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `format`.", "question_id": 36420}
{"snippet": "HDFStore.put(key, value, index=True)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `index`.", "question_id": 36421}
{"snippet": "HDFStore.put(key, value, append=False)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `append`.", "question_id": 36422}
{"snippet": "HDFStore.put(key, value, complib=None)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `complib`.", "question_id": 36423}
{"snippet": "HDFStore.put(key, value, complevel=None)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `complevel`.", "question_id": 36424}
{"snippet": "HDFStore.put(key, value, min_itemsize=None)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `min_itemsize`.", "question_id": 36425}
{"snippet": "HDFStore.put(key, value, nan_rep=None)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `nan_rep`.", "question_id": 36426}
{"snippet": "HDFStore.put(key, value, data_columns=None)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `data_columns`.", "question_id": 36427}
{"snippet": "HDFStore.put(key, value, encoding=None)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `encoding`.", "question_id": 36428}
{"snippet": "HDFStore.put(key, value)", "intent": "Store object in HDFStore . With arguments `key`, `value`.", "question_id": 36429}
{"snippet": "HDFStore.put(key, value, format=None)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `format`.", "question_id": 36430}
{"snippet": "HDFStore.put(key, value, index=True)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `index`.", "question_id": 36431}
{"snippet": "HDFStore.put(key, value, append=False)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `append`.", "question_id": 36432}
{"snippet": "HDFStore.put(key, value, complib=None)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `complib`.", "question_id": 36433}
{"snippet": "HDFStore.put(key, value, complevel=None)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `complevel`.", "question_id": 36434}
{"snippet": "HDFStore.put(key, value, min_itemsize=None)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `min_itemsize`.", "question_id": 36435}
{"snippet": "HDFStore.put(key, value, nan_rep=None)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `nan_rep`.", "question_id": 36436}
{"snippet": "HDFStore.put(key, value, data_columns=None)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `data_columns`.", "question_id": 36437}
{"snippet": "HDFStore.put(key, value, encoding=None)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `encoding`.", "question_id": 36438}
{"snippet": "HDFStore.put(key, value)", "intent": "Store object in HDFStore . With arguments `key`, `value`.", "question_id": 36439}
{"snippet": "HDFStore.put(key, value, format=None)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `format`.", "question_id": 36440}
{"snippet": "HDFStore.put(key, value, index=True)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `index`.", "question_id": 36441}
{"snippet": "HDFStore.put(key, value, append=False)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `append`.", "question_id": 36442}
{"snippet": "HDFStore.put(key, value, complib=None)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `complib`.", "question_id": 36443}
{"snippet": "HDFStore.put(key, value, complevel=None)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `complevel`.", "question_id": 36444}
{"snippet": "HDFStore.put(key, value, min_itemsize=None)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `min_itemsize`.", "question_id": 36445}
{"snippet": "HDFStore.put(key, value, nan_rep=None)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `nan_rep`.", "question_id": 36446}
{"snippet": "HDFStore.put(key, value, data_columns=None)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `data_columns`.", "question_id": 36447}
{"snippet": "HDFStore.put(key, value, encoding=None)", "intent": "Store object in HDFStore . With arguments `key`, `value`, `encoding`.", "question_id": 36448}
{"snippet": "HDFStore.select(key)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`.", "question_id": 36449}
{"snippet": "HDFStore.select(key, where=None)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`.", "question_id": 36450}
{"snippet": "HDFStore.select(key, start=None)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`, `start`.", "question_id": 36451}
{"snippet": "HDFStore.select(key, stop=None)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`, `stop`.", "question_id": 36452}
{"snippet": "HDFStore.select(key, columns=None)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`, `columns`.", "question_id": 36453}
{"snippet": "HDFStore.select(key, iterator=False)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`, `iterator`.", "question_id": 36454}
{"snippet": "HDFStore.select(key, chunksize=None)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`, `chunksize`.", "question_id": 36455}
{"snippet": "HDFStore.select(key, auto_close=False)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`, `auto_close`.", "question_id": 36456}
{"snippet": "HDFStore.select(key, where=None, start=None)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`, `start`.", "question_id": 36457}
{"snippet": "HDFStore.select(key, where=None, stop=None)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`, `stop`.", "question_id": 36458}
{"snippet": "HDFStore.select(key)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`.", "question_id": 36459}
{"snippet": "HDFStore.select(key, where=None)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`.", "question_id": 36460}
{"snippet": "HDFStore.select(key, start=None)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`, `start`.", "question_id": 36461}
{"snippet": "HDFStore.select(key, stop=None)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`, `stop`.", "question_id": 36462}
{"snippet": "HDFStore.select(key, columns=None)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`, `columns`.", "question_id": 36463}
{"snippet": "HDFStore.select(key, iterator=False)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`, `iterator`.", "question_id": 36464}
{"snippet": "HDFStore.select(key, chunksize=None)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`, `chunksize`.", "question_id": 36465}
{"snippet": "HDFStore.select(key, auto_close=False)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`, `auto_close`.", "question_id": 36466}
{"snippet": "HDFStore.select(key, where=None, start=None)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`, `start`.", "question_id": 36467}
{"snippet": "HDFStore.select(key, where=None, stop=None)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`, `stop`.", "question_id": 36468}
{"snippet": "HDFStore.select(key)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`.", "question_id": 36469}
{"snippet": "HDFStore.select(key, where=None)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`.", "question_id": 36470}
{"snippet": "HDFStore.select(key, start=None)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`, `start`.", "question_id": 36471}
{"snippet": "HDFStore.select(key, stop=None)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`, `stop`.", "question_id": 36472}
{"snippet": "HDFStore.select(key, columns=None)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`, `columns`.", "question_id": 36473}
{"snippet": "HDFStore.select(key, iterator=False)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`, `iterator`.", "question_id": 36474}
{"snippet": "HDFStore.select(key, chunksize=None)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`, `chunksize`.", "question_id": 36475}
{"snippet": "HDFStore.select(key, auto_close=False)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`, `auto_close`.", "question_id": 36476}
{"snippet": "HDFStore.select(key, where=None, start=None)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`, `start`.", "question_id": 36477}
{"snippet": "HDFStore.select(key, where=None, stop=None)", "intent": "Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `key`, `stop`.", "question_id": 36478}
{"snippet": "HDFStore.walk()", "intent": "Walk the pytables group hierarchy for pandas objects .", "question_id": 36479}
{"snippet": "HDFStore.walk(where='/')", "intent": "Walk the pytables group hierarchy for pandas objects . The `where` group itself is listed first ( preorder ) , then each of its child groups ( following an alphanumerical order ) is also traversed , following the same procedure .", "question_id": 36480}
{"snippet": "HDFStore.walk()", "intent": "Walk the pytables group hierarchy for pandas objects .", "question_id": 36481}
{"snippet": "HDFStore.walk(where='/')", "intent": "Walk the pytables group hierarchy for pandas objects . The `where` group itself is listed first ( preorder ) , then each of its child groups ( following an alphanumerical order ) is also traversed , following the same procedure .", "question_id": 36482}
{"snippet": "HDFStore.walk()", "intent": "Walk the pytables group hierarchy for pandas objects .", "question_id": 36483}
{"snippet": "HDFStore.walk(where='/')", "intent": "Walk the pytables group hierarchy for pandas objects . The `where` group itself is listed first ( preorder ) , then each of its child groups ( following an alphanumerical order ) is also traversed , following the same procedure .", "question_id": 36484}
{"snippet": "Index.all(*args, **kwargs)", "intent": "Return whether all elements are Truthy . With arguments `*args`, `**kwargs`.", "question_id": 36485}
{"snippet": "Index.all(*args, **kwargs)", "intent": "Return whether all elements are Truthy . With arguments `*args`, `**kwargs`.", "question_id": 36486}
{"snippet": "Index.all(*args, **kwargs)", "intent": "Return whether all elements are Truthy . With arguments `*args`, `**kwargs`.", "question_id": 36487}
{"snippet": "Index.any(*args, **kwargs)", "intent": "Return whether any element is Truthy . With arguments `*args`, `**kwargs`.", "question_id": 36488}
{"snippet": "Index.any(*args, **kwargs)", "intent": "Return whether any element is Truthy . With arguments `*args`, `**kwargs`.", "question_id": 36489}
{"snippet": "Index.any(*args, **kwargs)", "intent": "Return whether any element is Truthy . With arguments `*args`, `**kwargs`.", "question_id": 36490}
{"snippet": "Index.append(other)", "intent": "Append a collection of Index options together . With arguments `other`.", "question_id": 36491}
{"snippet": "Index.append(other)", "intent": "Append a collection of Index options together . With arguments `other`.", "question_id": 36492}
{"snippet": "Index.append(other)", "intent": "Append a collection of Index options together . With arguments `other`.", "question_id": 36493}
{"snippet": "Index.argmax(*args, **kwargs)", "intent": "Return int position of the largest value in the Series . With arguments `*args`, `**kwargs`.", "question_id": 36494}
{"snippet": "Index.argmax(*args, **kwargs, axis=None)", "intent": "Return int position of the largest value in the Series . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 36495}
{"snippet": "Index.argmax(*args, **kwargs, skipna=True)", "intent": "Return int position of the largest value in the Series . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 36496}
{"snippet": "Index.argmax(*args, **kwargs, axis=None, skipna=True)", "intent": "Return int position of the largest value in the Series . With arguments `*args`, `**kwargs`, `axis`, `skipna`.", "question_id": 36497}
{"snippet": "Index.argmax(*args, **kwargs)", "intent": "Return int position of the largest value in the Series . With arguments `*args`, `**kwargs`.", "question_id": 36498}
{"snippet": "Index.argmax(*args, **kwargs, axis=None)", "intent": "Return int position of the largest value in the Series . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 36499}
{"snippet": "Index.argmax(*args, **kwargs, skipna=True)", "intent": "Return int position of the largest value in the Series . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 36500}
{"snippet": "Index.argmax(*args, **kwargs, axis=None, skipna=True)", "intent": "Return int position of the largest value in the Series . With arguments `*args`, `**kwargs`, `axis`, `skipna`.", "question_id": 36501}
{"snippet": "Index.argmax(*args, **kwargs)", "intent": "Return int position of the largest value in the Series . With arguments `*args`, `**kwargs`.", "question_id": 36502}
{"snippet": "Index.argmax(*args, **kwargs, axis=None)", "intent": "Return int position of the largest value in the Series . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 36503}
{"snippet": "Index.argmax(*args, **kwargs, skipna=True)", "intent": "Return int position of the largest value in the Series . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 36504}
{"snippet": "Index.argmax(*args, **kwargs, axis=None, skipna=True)", "intent": "Return int position of the largest value in the Series . With arguments `*args`, `**kwargs`, `axis`, `skipna`.", "question_id": 36505}
{"snippet": "Index.argmin(*args, **kwargs)", "intent": "Return int position of the smallest value in the Series . With arguments `*args`, `**kwargs`.", "question_id": 36506}
{"snippet": "Index.argmin(*args, **kwargs, axis=None)", "intent": "Return int position of the smallest value in the Series . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 36507}
{"snippet": "Index.argmin(*args, **kwargs, skipna=True)", "intent": "Return int position of the smallest value in the Series . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 36508}
{"snippet": "Index.argmin(*args, **kwargs, axis=None, skipna=True)", "intent": "Return int position of the smallest value in the Series . With arguments `*args`, `**kwargs`, `axis`, `skipna`.", "question_id": 36509}
{"snippet": "Index.argmin(*args, **kwargs)", "intent": "Return int position of the smallest value in the Series . With arguments `*args`, `**kwargs`.", "question_id": 36510}
{"snippet": "Index.argmin(*args, **kwargs, axis=None)", "intent": "Return int position of the smallest value in the Series . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 36511}
{"snippet": "Index.argmin(*args, **kwargs, skipna=True)", "intent": "Return int position of the smallest value in the Series . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 36512}
{"snippet": "Index.argmin(*args, **kwargs, axis=None, skipna=True)", "intent": "Return int position of the smallest value in the Series . With arguments `*args`, `**kwargs`, `axis`, `skipna`.", "question_id": 36513}
{"snippet": "Index.argmin(*args, **kwargs)", "intent": "Return int position of the smallest value in the Series . With arguments `*args`, `**kwargs`.", "question_id": 36514}
{"snippet": "Index.argmin(*args, **kwargs, axis=None)", "intent": "Return int position of the smallest value in the Series . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 36515}
{"snippet": "Index.argmin(*args, **kwargs, skipna=True)", "intent": "Return int position of the smallest value in the Series . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 36516}
{"snippet": "Index.argmin(*args, **kwargs, axis=None, skipna=True)", "intent": "Return int position of the smallest value in the Series . With arguments `*args`, `**kwargs`, `axis`, `skipna`.", "question_id": 36517}
{"snippet": "Index.argsort(*args, **kwargs)", "intent": "Return the integer indices that would sort the index . With arguments `*args`, `**kwargs`.", "question_id": 36518}
{"snippet": "Index.argsort(*args, **kwargs)", "intent": "Return the integer indices that would sort the index . With arguments `*args`, `**kwargs`.", "question_id": 36519}
{"snippet": "Index.argsort(*args, **kwargs)", "intent": "Return the integer indices that would sort the index . With arguments `*args`, `**kwargs`.", "question_id": 36520}
{"snippet": "Index.array", "intent": "The ExtensionArray of the data backing this Series or Index.", "question_id": 36521}
{"snippet": "Index.array", "intent": "The ExtensionArray of the data backing this Series or Index.", "question_id": 36522}
{"snippet": "Index.array", "intent": "The ExtensionArray of the data backing this Series or Index.", "question_id": 36523}
{"snippet": "Index.asof(label)", "intent": "Return the `label` from the index , or , if not present , the previous one .", "question_id": 36524}
{"snippet": "Index.asof(label)", "intent": "Return the `label` from the index , or , if not present , the previous one .", "question_id": 36525}
{"snippet": "Index.asof(label)", "intent": "Return the `label` from the index , or , if not present , the previous one .", "question_id": 36526}
{"snippet": "Index.asof_locs(where, mask)", "intent": "Return the locations ( indices ) of labels in the index . As in the asof function , if the label ( a particular entry in `where` ) is not in the index , the latest index label up to the passed label is chosen and its index returned . `mask` is used to ignore NA values in the index during calculation .", "question_id": 36527}
{"snippet": "Index.asof_locs(where, mask)", "intent": "Return the locations ( indices ) of labels in the index . As in the asof function , if the label ( a particular entry in `where` ) is not in the index , the latest index label up to the passed label is chosen and its index returned . `mask` is used to ignore NA values in the index during calculation .", "question_id": 36528}
{"snippet": "Index.asof_locs(where, mask)", "intent": "Return the locations ( indices ) of labels in the index . As in the asof function , if the label ( a particular entry in `where` ) is not in the index , the latest index label up to the passed label is chosen and its index returned . `mask` is used to ignore NA values in the index during calculation .", "question_id": 36529}
{"snippet": "Index.astype(dtype)", "intent": "Create an Index with values cast to dtypes . The class of a new Index is determined by `dtype` .", "question_id": 36530}
{"snippet": "Index.astype(dtype, copy=True)", "intent": "Create an Index with values cast to dtypes . The class of a new Index is determined by `dtype` . With arguments `copy`.", "question_id": 36531}
{"snippet": "Index.astype(dtype)", "intent": "Create an Index with values cast to dtypes . The class of a new Index is determined by `dtype` .", "question_id": 36532}
{"snippet": "Index.astype(dtype, copy=True)", "intent": "Create an Index with values cast to dtypes . The class of a new Index is determined by `dtype` . With arguments `copy`.", "question_id": 36533}
{"snippet": "Index.astype(dtype)", "intent": "Create an Index with values cast to dtypes . The class of a new Index is determined by `dtype` .", "question_id": 36534}
{"snippet": "Index.astype(dtype, copy=True)", "intent": "Create an Index with values cast to dtypes . The class of a new Index is determined by `dtype` . With arguments `copy`.", "question_id": 36535}
{"snippet": "Index.copy()", "intent": "Make a copy of this object .", "question_id": 36536}
{"snippet": "Index.copy(name=None)", "intent": "Make a copy of this object . With arguments `name`.", "question_id": 36537}
{"snippet": "Index.copy(deep=False)", "intent": "Make a copy of this object . In most cases , there should be no functional difference from using `deep` , but if deep is passed it will attempt to deepcopy .", "question_id": 36538}
{"snippet": "Index.copy(dtype=None)", "intent": "Make a copy of this object . Name and `dtype` sets those attributes on the new object .", "question_id": 36539}
{"snippet": "Index.copy(names=None)", "intent": "Make a copy of this object . With arguments `names`.", "question_id": 36540}
{"snippet": "Index.copy(name=None, deep=False)", "intent": "Make a copy of this object . In most cases , there should be no functional difference from using `deep` , but if deep is passed it will attempt to deepcopy . With arguments `name`.", "question_id": 36541}
{"snippet": "Index.copy(name=None, dtype=None)", "intent": "Make a copy of this object . Name and `dtype` sets those attributes on the new object . With arguments `name`.", "question_id": 36542}
{"snippet": "Index.copy(name=None, names=None)", "intent": "Make a copy of this object . With arguments `name`, `names`.", "question_id": 36543}
{"snippet": "Index.copy(deep=False, dtype=None)", "intent": "Make a copy of this object . In most cases , there should be no functional difference from using `deep` , but if deep is passed it will attempt to deepcopy . Name and `dtype` sets those attributes on the new object .", "question_id": 36544}
{"snippet": "Index.copy(deep=False, names=None)", "intent": "Make a copy of this object . In most cases , there should be no functional difference from using `deep` , but if deep is passed it will attempt to deepcopy . With arguments `names`.", "question_id": 36545}
{"snippet": "Index.copy()", "intent": "Make a copy of this object .", "question_id": 36546}
{"snippet": "Index.copy(name=None)", "intent": "Make a copy of this object . With arguments `name`.", "question_id": 36547}
{"snippet": "Index.copy(deep=False)", "intent": "Make a copy of this object . In most cases , there should be no functional difference from using `deep` , but if deep is passed it will attempt to deepcopy .", "question_id": 36548}
{"snippet": "Index.copy(dtype=None)", "intent": "Make a copy of this object . Name and `dtype` sets those attributes on the new object .", "question_id": 36549}
{"snippet": "Index.copy(names=None)", "intent": "Make a copy of this object . With arguments `names`.", "question_id": 36550}
{"snippet": "Index.copy(name=None, deep=False)", "intent": "Make a copy of this object . In most cases , there should be no functional difference from using `deep` , but if deep is passed it will attempt to deepcopy . With arguments `name`.", "question_id": 36551}
{"snippet": "Index.copy(name=None, dtype=None)", "intent": "Make a copy of this object . Name and `dtype` sets those attributes on the new object . With arguments `name`.", "question_id": 36552}
{"snippet": "Index.copy(name=None, names=None)", "intent": "Make a copy of this object . With arguments `name`, `names`.", "question_id": 36553}
{"snippet": "Index.copy(deep=False, dtype=None)", "intent": "Make a copy of this object . In most cases , there should be no functional difference from using `deep` , but if deep is passed it will attempt to deepcopy . Name and `dtype` sets those attributes on the new object .", "question_id": 36554}
{"snippet": "Index.copy(deep=False, names=None)", "intent": "Make a copy of this object . In most cases , there should be no functional difference from using `deep` , but if deep is passed it will attempt to deepcopy . With arguments `names`.", "question_id": 36555}
{"snippet": "Index.copy()", "intent": "Make a copy of this object .", "question_id": 36556}
{"snippet": "Index.copy(name=None)", "intent": "Make a copy of this object . With arguments `name`.", "question_id": 36557}
{"snippet": "Index.copy(deep=False)", "intent": "Make a copy of this object . In most cases , there should be no functional difference from using `deep` , but if deep is passed it will attempt to deepcopy .", "question_id": 36558}
{"snippet": "Index.copy(dtype=None)", "intent": "Make a copy of this object . Name and `dtype` sets those attributes on the new object .", "question_id": 36559}
{"snippet": "Index.copy(names=None)", "intent": "Make a copy of this object . With arguments `names`.", "question_id": 36560}
{"snippet": "Index.copy(name=None, deep=False)", "intent": "Make a copy of this object . In most cases , there should be no functional difference from using `deep` , but if deep is passed it will attempt to deepcopy . With arguments `name`.", "question_id": 36561}
{"snippet": "Index.copy(name=None, dtype=None)", "intent": "Make a copy of this object . Name and `dtype` sets those attributes on the new object . With arguments `name`.", "question_id": 36562}
{"snippet": "Index.copy(name=None, names=None)", "intent": "Make a copy of this object . With arguments `name`, `names`.", "question_id": 36563}
{"snippet": "Index.copy(deep=False, dtype=None)", "intent": "Make a copy of this object . In most cases , there should be no functional difference from using `deep` , but if deep is passed it will attempt to deepcopy . Name and `dtype` sets those attributes on the new object .", "question_id": 36564}
{"snippet": "Index.copy(deep=False, names=None)", "intent": "Make a copy of this object . In most cases , there should be no functional difference from using `deep` , but if deep is passed it will attempt to deepcopy . With arguments `names`.", "question_id": 36565}
{"snippet": "Index.delete(loc)", "intent": "Make new Index with passed location ( -s ) deleted . With arguments `loc`.", "question_id": 36566}
{"snippet": "Index.delete(loc)", "intent": "Make new Index with passed location ( -s ) deleted . With arguments `loc`.", "question_id": 36567}
{"snippet": "Index.delete(loc)", "intent": "Make new Index with passed location ( -s ) deleted . With arguments `loc`.", "question_id": 36568}
{"snippet": "Index.difference(other)", "intent": "Return a new Index with elements of index not in `other` .", "question_id": 36569}
{"snippet": "Index.difference(other, sort=None)", "intent": "Return a new Index with elements of index not in `other` . With arguments `sort`.", "question_id": 36570}
{"snippet": "Index.difference(other)", "intent": "Return a new Index with elements of index not in `other` .", "question_id": 36571}
{"snippet": "Index.difference(other, sort=None)", "intent": "Return a new Index with elements of index not in `other` . With arguments `sort`.", "question_id": 36572}
{"snippet": "Index.difference(other)", "intent": "Return a new Index with elements of index not in `other` .", "question_id": 36573}
{"snippet": "Index.difference(other, sort=None)", "intent": "Return a new Index with elements of index not in `other` . With arguments `sort`.", "question_id": 36574}
{"snippet": "Index.drop(labels)", "intent": "Make new Index with passed list of `labels` deleted .", "question_id": 36575}
{"snippet": "Index.drop(labels, errors='raise')", "intent": "Make new Index with passed list of `labels` deleted . With arguments `errors`.", "question_id": 36576}
{"snippet": "Index.drop(labels)", "intent": "Make new Index with passed list of `labels` deleted .", "question_id": 36577}
{"snippet": "Index.drop(labels, errors='raise')", "intent": "Make new Index with passed list of `labels` deleted . With arguments `errors`.", "question_id": 36578}
{"snippet": "Index.drop(labels)", "intent": "Make new Index with passed list of `labels` deleted .", "question_id": 36579}
{"snippet": "Index.drop(labels, errors='raise')", "intent": "Make new Index with passed list of `labels` deleted . With arguments `errors`.", "question_id": 36580}
{"snippet": "Index.drop_duplicates()", "intent": "Return Index with duplicate values removed .", "question_id": 36581}
{"snippet": "Index.drop_duplicates(keep='first')", "intent": "Return Index with duplicate values removed . The `keep` parameter controls which duplicate values are removed .", "question_id": 36582}
{"snippet": "Index.drop_duplicates()", "intent": "Return Index with duplicate values removed .", "question_id": 36583}
{"snippet": "Index.drop_duplicates(keep='first')", "intent": "Return Index with duplicate values removed . The `keep` parameter controls which duplicate values are removed .", "question_id": 36584}
{"snippet": "Index.drop_duplicates()", "intent": "Return Index with duplicate values removed .", "question_id": 36585}
{"snippet": "Index.drop_duplicates(keep='first')", "intent": "Return Index with duplicate values removed . The `keep` parameter controls which duplicate values are removed .", "question_id": 36586}
{"snippet": "Index.droplevel()", "intent": "Return index with requested `level` ( s ) removed .", "question_id": 36587}
{"snippet": "Index.droplevel(level=0)", "intent": "Return index with requested `level` ( s ) removed .", "question_id": 36588}
{"snippet": "Index.droplevel()", "intent": "Return index with requested `level` ( s ) removed .", "question_id": 36589}
{"snippet": "Index.droplevel(level=0)", "intent": "Return index with requested `level` ( s ) removed .", "question_id": 36590}
{"snippet": "Index.droplevel()", "intent": "Return index with requested `level` ( s ) removed .", "question_id": 36591}
{"snippet": "Index.droplevel(level=0)", "intent": "Return index with requested `level` ( s ) removed .", "question_id": 36592}
{"snippet": "Index.dropna()", "intent": "Return Index without NA/NaN values .", "question_id": 36593}
{"snippet": "Index.dropna(how='any')", "intent": "Return Index without NA/NaN values . With arguments `how`.", "question_id": 36594}
{"snippet": "Index.dropna()", "intent": "Return Index without NA/NaN values .", "question_id": 36595}
{"snippet": "Index.dropna(how='any')", "intent": "Return Index without NA/NaN values . With arguments `how`.", "question_id": 36596}
{"snippet": "Index.dropna()", "intent": "Return Index without NA/NaN values .", "question_id": 36597}
{"snippet": "Index.dropna(how='any')", "intent": "Return Index without NA/NaN values . With arguments `how`.", "question_id": 36598}
{"snippet": "Index.dtype", "intent": "Return the dtype object of the underlying data.", "question_id": 36599}
{"snippet": "Index.dtype", "intent": "Return the dtype object of the underlying data.", "question_id": 36600}
{"snippet": "Index.dtype", "intent": "Return the dtype object of the underlying data.", "question_id": 36601}
{"snippet": "Index.duplicated()", "intent": "Indicate duplicate index values .", "question_id": 36602}
{"snippet": "Index.duplicated(keep='first')", "intent": "Indicate duplicate index values . By setting `keep` on False , all duplicates are True :", "question_id": 36603}
{"snippet": "Index.duplicated()", "intent": "Indicate duplicate index values .", "question_id": 36604}
{"snippet": "Index.duplicated(keep='first')", "intent": "Indicate duplicate index values . By setting `keep` on False , all duplicates are True :", "question_id": 36605}
{"snippet": "Index.duplicated()", "intent": "Indicate duplicate index values .", "question_id": 36606}
{"snippet": "Index.duplicated(keep='first')", "intent": "Indicate duplicate index values . By setting `keep` on False , all duplicates are True :", "question_id": 36607}
{"snippet": "Index.equals(other)", "intent": "Determine if two Index object are equal . With arguments `other`.", "question_id": 36608}
{"snippet": "Index.equals(other)", "intent": "Determine if two Index object are equal . With arguments `other`.", "question_id": 36609}
{"snippet": "Index.equals(other)", "intent": "Determine if two Index object are equal . With arguments `other`.", "question_id": 36610}
{"snippet": "Index.factorize()", "intent": "Encode the object as an enumerated type or categorical variable .", "question_id": 36611}
{"snippet": "Index.factorize(sort=False)", "intent": "Encode the object as an enumerated type or categorical variable . With arguments `sort`.", "question_id": 36612}
{"snippet": "Index.factorize(na_sentinel=- 1)", "intent": "Encode the object as an enumerated type or categorical variable . Missing values are indicated in codes with `na_sentinel` ( -1 by default ) .", "question_id": 36613}
{"snippet": "Index.factorize(sort=False, na_sentinel=- 1)", "intent": "Encode the object as an enumerated type or categorical variable . Missing values are indicated in codes with `na_sentinel` ( -1 by default ) . With arguments `sort`.", "question_id": 36614}
{"snippet": "Index.factorize()", "intent": "Encode the object as an enumerated type or categorical variable .", "question_id": 36615}
{"snippet": "Index.factorize(sort=False)", "intent": "Encode the object as an enumerated type or categorical variable . With arguments `sort`.", "question_id": 36616}
{"snippet": "Index.factorize(na_sentinel=- 1)", "intent": "Encode the object as an enumerated type or categorical variable . Missing values are indicated in codes with `na_sentinel` ( -1 by default ) .", "question_id": 36617}
{"snippet": "Index.factorize(sort=False, na_sentinel=- 1)", "intent": "Encode the object as an enumerated type or categorical variable . Missing values are indicated in codes with `na_sentinel` ( -1 by default ) . With arguments `sort`.", "question_id": 36618}
{"snippet": "Index.factorize()", "intent": "Encode the object as an enumerated type or categorical variable .", "question_id": 36619}
{"snippet": "Index.factorize(sort=False)", "intent": "Encode the object as an enumerated type or categorical variable . With arguments `sort`.", "question_id": 36620}
{"snippet": "Index.factorize(na_sentinel=- 1)", "intent": "Encode the object as an enumerated type or categorical variable . Missing values are indicated in codes with `na_sentinel` ( -1 by default ) .", "question_id": 36621}
{"snippet": "Index.factorize(sort=False, na_sentinel=- 1)", "intent": "Encode the object as an enumerated type or categorical variable . Missing values are indicated in codes with `na_sentinel` ( -1 by default ) . With arguments `sort`.", "question_id": 36622}
{"snippet": "Index.fillna()", "intent": "Fill NA/NaN values with the specified `value` .", "question_id": 36623}
{"snippet": "Index.fillna(value=None)", "intent": "Fill NA/NaN values with the specified `value` .", "question_id": 36624}
{"snippet": "Index.fillna(downcast=None)", "intent": "Fill NA/NaN values with the specified `value` . With arguments `downcast`.", "question_id": 36625}
{"snippet": "Index.fillna(value=None, downcast=None)", "intent": "Fill NA/NaN values with the specified `value` . With arguments `downcast`.", "question_id": 36626}
{"snippet": "Index.fillna()", "intent": "Fill NA/NaN values with the specified `value` .", "question_id": 36627}
{"snippet": "Index.fillna(value=None)", "intent": "Fill NA/NaN values with the specified `value` .", "question_id": 36628}
{"snippet": "Index.fillna(downcast=None)", "intent": "Fill NA/NaN values with the specified `value` . With arguments `downcast`.", "question_id": 36629}
{"snippet": "Index.fillna(value=None, downcast=None)", "intent": "Fill NA/NaN values with the specified `value` . With arguments `downcast`.", "question_id": 36630}
{"snippet": "Index.fillna()", "intent": "Fill NA/NaN values with the specified `value` .", "question_id": 36631}
{"snippet": "Index.fillna(value=None)", "intent": "Fill NA/NaN values with the specified `value` .", "question_id": 36632}
{"snippet": "Index.fillna(downcast=None)", "intent": "Fill NA/NaN values with the specified `value` . With arguments `downcast`.", "question_id": 36633}
{"snippet": "Index.fillna(value=None, downcast=None)", "intent": "Fill NA/NaN values with the specified `value` . With arguments `downcast`.", "question_id": 36634}
{"snippet": "Index.format()", "intent": "Render a string representation of the Index .", "question_id": 36635}
{"snippet": "Index.format(name=False)", "intent": "Render a string representation of the Index . With arguments `name`.", "question_id": 36636}
{"snippet": "Index.format(formatter=None)", "intent": "Render a string representation of the Index . With arguments `formatter`.", "question_id": 36637}
{"snippet": "Index.format(na_rep='NaN')", "intent": "Render a string representation of the Index . With arguments `na_rep`.", "question_id": 36638}
{"snippet": "Index.format(name=False, formatter=None)", "intent": "Render a string representation of the Index . With arguments `name`, `formatter`.", "question_id": 36639}
{"snippet": "Index.format(name=False, na_rep='NaN')", "intent": "Render a string representation of the Index . With arguments `name`, `na_rep`.", "question_id": 36640}
{"snippet": "Index.format(formatter=None, na_rep='NaN')", "intent": "Render a string representation of the Index . With arguments `formatter`, `na_rep`.", "question_id": 36641}
{"snippet": "Index.format(name=False, formatter=None, na_rep='NaN')", "intent": "Render a string representation of the Index . With arguments `name`, `formatter`, `na_rep`.", "question_id": 36642}
{"snippet": "Index.format()", "intent": "Render a string representation of the Index .", "question_id": 36643}
{"snippet": "Index.format(name=False)", "intent": "Render a string representation of the Index . With arguments `name`.", "question_id": 36644}
{"snippet": "Index.format(formatter=None)", "intent": "Render a string representation of the Index . With arguments `formatter`.", "question_id": 36645}
{"snippet": "Index.format(na_rep='NaN')", "intent": "Render a string representation of the Index . With arguments `na_rep`.", "question_id": 36646}
{"snippet": "Index.format(name=False, formatter=None)", "intent": "Render a string representation of the Index . With arguments `name`, `formatter`.", "question_id": 36647}
{"snippet": "Index.format(name=False, na_rep='NaN')", "intent": "Render a string representation of the Index . With arguments `name`, `na_rep`.", "question_id": 36648}
{"snippet": "Index.format(formatter=None, na_rep='NaN')", "intent": "Render a string representation of the Index . With arguments `formatter`, `na_rep`.", "question_id": 36649}
{"snippet": "Index.format(name=False, formatter=None, na_rep='NaN')", "intent": "Render a string representation of the Index . With arguments `name`, `formatter`, `na_rep`.", "question_id": 36650}
{"snippet": "Index.format()", "intent": "Render a string representation of the Index .", "question_id": 36651}
{"snippet": "Index.format(name=False)", "intent": "Render a string representation of the Index . With arguments `name`.", "question_id": 36652}
{"snippet": "Index.format(formatter=None)", "intent": "Render a string representation of the Index . With arguments `formatter`.", "question_id": 36653}
{"snippet": "Index.format(na_rep='NaN')", "intent": "Render a string representation of the Index . With arguments `na_rep`.", "question_id": 36654}
{"snippet": "Index.format(name=False, formatter=None)", "intent": "Render a string representation of the Index . With arguments `name`, `formatter`.", "question_id": 36655}
{"snippet": "Index.format(name=False, na_rep='NaN')", "intent": "Render a string representation of the Index . With arguments `name`, `na_rep`.", "question_id": 36656}
{"snippet": "Index.format(formatter=None, na_rep='NaN')", "intent": "Render a string representation of the Index . With arguments `formatter`, `na_rep`.", "question_id": 36657}
{"snippet": "Index.format(name=False, formatter=None, na_rep='NaN')", "intent": "Render a string representation of the Index . With arguments `name`, `formatter`, `na_rep`.", "question_id": 36658}
{"snippet": "Index.get_indexer(target)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`.", "question_id": 36659}
{"snippet": "Index.get_indexer(target, method=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`.", "question_id": 36660}
{"snippet": "Index.get_indexer(target, limit=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `limit`.", "question_id": 36661}
{"snippet": "Index.get_indexer(target, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `tolerance`.", "question_id": 36662}
{"snippet": "Index.get_indexer(target, method=None, limit=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `limit`.", "question_id": 36663}
{"snippet": "Index.get_indexer(target, method=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `tolerance`.", "question_id": 36664}
{"snippet": "Index.get_indexer(target, limit=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `limit`, `tolerance`.", "question_id": 36665}
{"snippet": "Index.get_indexer(target, method=None, limit=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `limit`, `tolerance`.", "question_id": 36666}
{"snippet": "Index.get_indexer(target)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`.", "question_id": 36667}
{"snippet": "Index.get_indexer(target, method=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`.", "question_id": 36668}
{"snippet": "Index.get_indexer(target, limit=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `limit`.", "question_id": 36669}
{"snippet": "Index.get_indexer(target, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `tolerance`.", "question_id": 36670}
{"snippet": "Index.get_indexer(target, method=None, limit=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `limit`.", "question_id": 36671}
{"snippet": "Index.get_indexer(target, method=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `tolerance`.", "question_id": 36672}
{"snippet": "Index.get_indexer(target, limit=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `limit`, `tolerance`.", "question_id": 36673}
{"snippet": "Index.get_indexer(target, method=None, limit=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `limit`, `tolerance`.", "question_id": 36674}
{"snippet": "Index.get_indexer(target)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`.", "question_id": 36675}
{"snippet": "Index.get_indexer(target, method=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`.", "question_id": 36676}
{"snippet": "Index.get_indexer(target, limit=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `limit`.", "question_id": 36677}
{"snippet": "Index.get_indexer(target, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `tolerance`.", "question_id": 36678}
{"snippet": "Index.get_indexer(target, method=None, limit=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `limit`.", "question_id": 36679}
{"snippet": "Index.get_indexer(target, method=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `tolerance`.", "question_id": 36680}
{"snippet": "Index.get_indexer(target, limit=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `limit`, `tolerance`.", "question_id": 36681}
{"snippet": "Index.get_indexer(target, method=None, limit=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `limit`, `tolerance`.", "question_id": 36682}
{"snippet": "Index.get_indexer_for(target, **kwargs)", "intent": "Guaranteed return of an indexer even when non-unique . With arguments `target`, `**kwargs`.", "question_id": 36683}
{"snippet": "Index.get_indexer_for(target, **kwargs)", "intent": "Guaranteed return of an indexer even when non-unique . With arguments `target`, `**kwargs`.", "question_id": 36684}
{"snippet": "Index.get_indexer_for(target, **kwargs)", "intent": "Guaranteed return of an indexer even when non-unique . With arguments `target`, `**kwargs`.", "question_id": 36685}
{"snippet": "Index.get_indexer_non_unique(target)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`.", "question_id": 36686}
{"snippet": "Index.get_indexer_non_unique(target)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`.", "question_id": 36687}
{"snippet": "Index.get_indexer_non_unique(target)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`.", "question_id": 36688}
{"snippet": "Index.get_level_values(level)", "intent": "Return an Index of values for requested `level` .", "question_id": 36689}
{"snippet": "Index.get_level_values(level)", "intent": "Return an Index of values for requested `level` .", "question_id": 36690}
{"snippet": "Index.get_level_values(level)", "intent": "Return an Index of values for requested `level` .", "question_id": 36691}
{"snippet": "Index.get_loc(key)", "intent": "Get integer location , slice or boolean mask for requested label . With arguments `key`.", "question_id": 36692}
{"snippet": "Index.get_loc(key, method=None)", "intent": "Get integer location , slice or boolean mask for requested label . With arguments `key`, `method`.", "question_id": 36693}
{"snippet": "Index.get_loc(key, tolerance=None)", "intent": "Get integer location , slice or boolean mask for requested label . With arguments `key`, `tolerance`.", "question_id": 36694}
{"snippet": "Index.get_loc(key, method=None, tolerance=None)", "intent": "Get integer location , slice or boolean mask for requested label . With arguments `key`, `method`, `tolerance`.", "question_id": 36695}
{"snippet": "Index.get_loc(key)", "intent": "Get integer location , slice or boolean mask for requested label . With arguments `key`.", "question_id": 36696}
{"snippet": "Index.get_loc(key, method=None)", "intent": "Get integer location , slice or boolean mask for requested label . With arguments `key`, `method`.", "question_id": 36697}
{"snippet": "Index.get_loc(key, tolerance=None)", "intent": "Get integer location , slice or boolean mask for requested label . With arguments `key`, `tolerance`.", "question_id": 36698}
{"snippet": "Index.get_loc(key, method=None, tolerance=None)", "intent": "Get integer location , slice or boolean mask for requested label . With arguments `key`, `method`, `tolerance`.", "question_id": 36699}
{"snippet": "Index.get_loc(key)", "intent": "Get integer location , slice or boolean mask for requested label . With arguments `key`.", "question_id": 36700}
{"snippet": "Index.get_loc(key, method=None)", "intent": "Get integer location , slice or boolean mask for requested label . With arguments `key`, `method`.", "question_id": 36701}
{"snippet": "Index.get_loc(key, tolerance=None)", "intent": "Get integer location , slice or boolean mask for requested label . With arguments `key`, `tolerance`.", "question_id": 36702}
{"snippet": "Index.get_loc(key, method=None, tolerance=None)", "intent": "Get integer location , slice or boolean mask for requested label . With arguments `key`, `method`, `tolerance`.", "question_id": 36703}
{"snippet": "Index.get_slice_bound(label, side)", "intent": "Calculate slice bound that corresponds to given `label` . With arguments `side`.", "question_id": 36704}
{"snippet": "Index.get_slice_bound(label, side, kind=None)", "intent": "Calculate slice bound that corresponds to given `label` . With arguments `side`, `kind`.", "question_id": 36705}
{"snippet": "Index.get_slice_bound(label, side)", "intent": "Calculate slice bound that corresponds to given `label` . With arguments `side`.", "question_id": 36706}
{"snippet": "Index.get_slice_bound(label, side, kind=None)", "intent": "Calculate slice bound that corresponds to given `label` . With arguments `side`, `kind`.", "question_id": 36707}
{"snippet": "Index.get_slice_bound(label, side)", "intent": "Calculate slice bound that corresponds to given `label` . With arguments `side`.", "question_id": 36708}
{"snippet": "Index.get_slice_bound(label, side, kind=None)", "intent": "Calculate slice bound that corresponds to given `label` . With arguments `side`, `kind`.", "question_id": 36709}
{"snippet": "Index.get_value(series, key)", "intent": "Fast lookup of value from 1-dimensional ndarray . With arguments `series`, `key`.", "question_id": 36710}
{"snippet": "Index.get_value(series, key)", "intent": "Fast lookup of value from 1-dimensional ndarray . With arguments `series`, `key`.", "question_id": 36711}
{"snippet": "Index.get_value(series, key)", "intent": "Fast lookup of value from 1-dimensional ndarray . With arguments `series`, `key`.", "question_id": 36712}
{"snippet": "Index.groupby(values)", "intent": "Group the index labels by a given array of `values` .", "question_id": 36713}
{"snippet": "Index.groupby(values)", "intent": "Group the index labels by a given array of `values` .", "question_id": 36714}
{"snippet": "Index.groupby(values)", "intent": "Group the index labels by a given array of `values` .", "question_id": 36715}
{"snippet": "Index.hasnans", "intent": "Return if I have any nans; enables various perf speedups.", "question_id": 36716}
{"snippet": "Index.hasnans", "intent": "Return if I have any nans; enables various perf speedups.", "question_id": 36717}
{"snippet": "Index.hasnans", "intent": "Return if I have any nans; enables various perf speedups.", "question_id": 36718}
{"snippet": "Index.holds_integer()", "intent": "Whether the type is an integer type .", "question_id": 36719}
{"snippet": "Index.holds_integer()", "intent": "Whether the type is an integer type .", "question_id": 36720}
{"snippet": "Index.holds_integer()", "intent": "Whether the type is an integer type .", "question_id": 36721}
{"snippet": "pandas.Index(**kwargs)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`.", "question_id": 36722}
{"snippet": "pandas.Index(**kwargs, data=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `data`.", "question_id": 36723}
{"snippet": "pandas.Index(**kwargs, dtype=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `dtype`.", "question_id": 36724}
{"snippet": "pandas.Index(**kwargs, copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `copy`.", "question_id": 36725}
{"snippet": "pandas.Index(**kwargs, name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `name`.", "question_id": 36726}
{"snippet": "pandas.Index(**kwargs, tupleize_cols=True)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `tupleize_cols`.", "question_id": 36727}
{"snippet": "pandas.Index(**kwargs, data=None, dtype=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `data`, `dtype`.", "question_id": 36728}
{"snippet": "pandas.Index(**kwargs, data=None, copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `data`, `copy`.", "question_id": 36729}
{"snippet": "pandas.Index(**kwargs, data=None, name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `data`, `name`.", "question_id": 36730}
{"snippet": "pandas.Index(**kwargs, data=None, tupleize_cols=True)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `data`, `tupleize_cols`.", "question_id": 36731}
{"snippet": "pandas.Index(**kwargs)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`.", "question_id": 36732}
{"snippet": "pandas.Index(**kwargs, data=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `data`.", "question_id": 36733}
{"snippet": "pandas.Index(**kwargs, dtype=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `dtype`.", "question_id": 36734}
{"snippet": "pandas.Index(**kwargs, copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `copy`.", "question_id": 36735}
{"snippet": "pandas.Index(**kwargs, name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `name`.", "question_id": 36736}
{"snippet": "pandas.Index(**kwargs, tupleize_cols=True)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `tupleize_cols`.", "question_id": 36737}
{"snippet": "pandas.Index(**kwargs, data=None, dtype=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `data`, `dtype`.", "question_id": 36738}
{"snippet": "pandas.Index(**kwargs, data=None, copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `data`, `copy`.", "question_id": 36739}
{"snippet": "pandas.Index(**kwargs, data=None, name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `data`, `name`.", "question_id": 36740}
{"snippet": "pandas.Index(**kwargs, data=None, tupleize_cols=True)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `data`, `tupleize_cols`.", "question_id": 36741}
{"snippet": "pandas.Index(**kwargs)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`.", "question_id": 36742}
{"snippet": "pandas.Index(**kwargs, data=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `data`.", "question_id": 36743}
{"snippet": "pandas.Index(**kwargs, dtype=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `dtype`.", "question_id": 36744}
{"snippet": "pandas.Index(**kwargs, copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `copy`.", "question_id": 36745}
{"snippet": "pandas.Index(**kwargs, name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `name`.", "question_id": 36746}
{"snippet": "pandas.Index(**kwargs, tupleize_cols=True)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `tupleize_cols`.", "question_id": 36747}
{"snippet": "pandas.Index(**kwargs, data=None, dtype=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `data`, `dtype`.", "question_id": 36748}
{"snippet": "pandas.Index(**kwargs, data=None, copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `data`, `copy`.", "question_id": 36749}
{"snippet": "pandas.Index(**kwargs, data=None, name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `data`, `name`.", "question_id": 36750}
{"snippet": "pandas.Index(**kwargs, data=None, tupleize_cols=True)", "intent": "Immutable sequence used for indexing and alignment . With arguments `**kwargs`, `data`, `tupleize_cols`.", "question_id": 36751}
{"snippet": "Index.identical(other)", "intent": "Similar to equals , but checks that object attributes and types are also equal . With arguments `other`.", "question_id": 36752}
{"snippet": "Index.identical(other)", "intent": "Similar to equals , but checks that object attributes and types are also equal . With arguments `other`.", "question_id": 36753}
{"snippet": "Index.identical(other)", "intent": "Similar to equals , but checks that object attributes and types are also equal . With arguments `other`.", "question_id": 36754}
{"snippet": "Index.inferred_type", "intent": "Return a string of the type inferred from the values.", "question_id": 36755}
{"snippet": "Index.inferred_type", "intent": "Return a string of the type inferred from the values.", "question_id": 36756}
{"snippet": "Index.inferred_type", "intent": "Return a string of the type inferred from the values.", "question_id": 36757}
{"snippet": "Index.insert(loc, item)", "intent": "Make new Index inserting new `item` at location . With arguments `loc`.", "question_id": 36758}
{"snippet": "Index.insert(loc, item)", "intent": "Make new Index inserting new `item` at location . With arguments `loc`.", "question_id": 36759}
{"snippet": "Index.insert(loc, item)", "intent": "Make new Index inserting new `item` at location . With arguments `loc`.", "question_id": 36760}
{"snippet": "Index.intersection(other)", "intent": "Form the intersection of two Index objects . This returns a new Index with elements common to the index and `other` .", "question_id": 36761}
{"snippet": "Index.intersection(other, sort=False)", "intent": "Form the intersection of two Index objects . This returns a new Index with elements common to the index and `other` . With arguments `sort`.", "question_id": 36762}
{"snippet": "Index.intersection(other)", "intent": "Form the intersection of two Index objects . This returns a new Index with elements common to the index and `other` .", "question_id": 36763}
{"snippet": "Index.intersection(other, sort=False)", "intent": "Form the intersection of two Index objects . This returns a new Index with elements common to the index and `other` . With arguments `sort`.", "question_id": 36764}
{"snippet": "Index.intersection(other)", "intent": "Form the intersection of two Index objects . This returns a new Index with elements common to the index and `other` .", "question_id": 36765}
{"snippet": "Index.intersection(other, sort=False)", "intent": "Form the intersection of two Index objects . This returns a new Index with elements common to the index and `other` . With arguments `sort`.", "question_id": 36766}
{"snippet": "Index.is_(other)", "intent": "More flexible , faster check like is but that works through views . With arguments `other`.", "question_id": 36767}
{"snippet": "Index.is_(other)", "intent": "More flexible , faster check like is but that works through views . With arguments `other`.", "question_id": 36768}
{"snippet": "Index.is_(other)", "intent": "More flexible , faster check like is but that works through views . With arguments `other`.", "question_id": 36769}
{"snippet": "Index.is_all_dates", "intent": "Whether or not the index values only consist of dates.", "question_id": 36770}
{"snippet": "Index.is_all_dates", "intent": "Whether or not the index values only consist of dates.", "question_id": 36771}
{"snippet": "Index.is_all_dates", "intent": "Whether or not the index values only consist of dates.", "question_id": 36772}
{"snippet": "Index.is_boolean()", "intent": "Check if the Index only consists of booleans .", "question_id": 36773}
{"snippet": "Index.is_boolean()", "intent": "Check if the Index only consists of booleans .", "question_id": 36774}
{"snippet": "Index.is_boolean()", "intent": "Check if the Index only consists of booleans .", "question_id": 36775}
{"snippet": "Index.is_categorical()", "intent": "Check if the Index holds categorical data .", "question_id": 36776}
{"snippet": "Index.is_categorical()", "intent": "Check if the Index holds categorical data .", "question_id": 36777}
{"snippet": "Index.is_categorical()", "intent": "Check if the Index holds categorical data .", "question_id": 36778}
{"snippet": "Index.is_floating()", "intent": "Check if the Index is a floating type .", "question_id": 36779}
{"snippet": "Index.is_floating()", "intent": "Check if the Index is a floating type .", "question_id": 36780}
{"snippet": "Index.is_floating()", "intent": "Check if the Index is a floating type .", "question_id": 36781}
{"snippet": "Index.is_integer()", "intent": "Check if the Index only consists of integers .", "question_id": 36782}
{"snippet": "Index.is_integer()", "intent": "Check if the Index only consists of integers .", "question_id": 36783}
{"snippet": "Index.is_integer()", "intent": "Check if the Index only consists of integers .", "question_id": 36784}
{"snippet": "Index.is_interval()", "intent": "Check if the Index holds Interval objects .", "question_id": 36785}
{"snippet": "Index.is_interval()", "intent": "Check if the Index holds Interval objects .", "question_id": 36786}
{"snippet": "Index.is_interval()", "intent": "Check if the Index holds Interval objects .", "question_id": 36787}
{"snippet": "Index.is_mixed()", "intent": "Check if the Index holds data with mixed data types .", "question_id": 36788}
{"snippet": "Index.is_mixed()", "intent": "Check if the Index holds data with mixed data types .", "question_id": 36789}
{"snippet": "Index.is_mixed()", "intent": "Check if the Index holds data with mixed data types .", "question_id": 36790}
{"snippet": "Index.is_numeric()", "intent": "Check if the Index only consists of numeric data .", "question_id": 36791}
{"snippet": "Index.is_numeric()", "intent": "Check if the Index only consists of numeric data .", "question_id": 36792}
{"snippet": "Index.is_numeric()", "intent": "Check if the Index only consists of numeric data .", "question_id": 36793}
{"snippet": "Index.is_object()", "intent": "Check if the Index is of the object dtype .", "question_id": 36794}
{"snippet": "Index.is_object()", "intent": "Check if the Index is of the object dtype .", "question_id": 36795}
{"snippet": "Index.is_object()", "intent": "Check if the Index is of the object dtype .", "question_id": 36796}
{"snippet": "Index.is_type_compatible(kind)", "intent": "Whether the index type is compatible with the provided type . With arguments `kind`.", "question_id": 36797}
{"snippet": "Index.is_type_compatible(kind)", "intent": "Whether the index type is compatible with the provided type . With arguments `kind`.", "question_id": 36798}
{"snippet": "Index.is_type_compatible(kind)", "intent": "Whether the index type is compatible with the provided type . With arguments `kind`.", "question_id": 36799}
{"snippet": "Index.is_unique", "intent": "Return if the index has unique values.", "question_id": 36800}
{"snippet": "Index.is_unique", "intent": "Return if the index has unique values.", "question_id": 36801}
{"snippet": "Index.is_unique", "intent": "Return if the index has unique values.", "question_id": 36802}
{"snippet": "Index.isin(values)", "intent": "Return a boolean array where the index `values` are in values .", "question_id": 36803}
{"snippet": "Index.isin(values, level=None)", "intent": "Return a boolean array where the index `values` are in values . In the case of MultiIndex you must either specify values as a list-like object containing tuples that are the same length as the number of levels , or specify `level` .", "question_id": 36804}
{"snippet": "Index.isin(values)", "intent": "Return a boolean array where the index `values` are in values .", "question_id": 36805}
{"snippet": "Index.isin(values, level=None)", "intent": "Return a boolean array where the index `values` are in values . In the case of MultiIndex you must either specify values as a list-like object containing tuples that are the same length as the number of levels , or specify `level` .", "question_id": 36806}
{"snippet": "Index.isin(values)", "intent": "Return a boolean array where the index `values` are in values .", "question_id": 36807}
{"snippet": "Index.isin(values, level=None)", "intent": "Return a boolean array where the index `values` are in values . In the case of MultiIndex you must either specify values as a list-like object containing tuples that are the same length as the number of levels , or specify `level` .", "question_id": 36808}
{"snippet": "Index.isna()", "intent": "Detect missing values .", "question_id": 36809}
{"snippet": "Index.isna()", "intent": "Detect missing values .", "question_id": 36810}
{"snippet": "Index.isna()", "intent": "Detect missing values .", "question_id": 36811}
{"snippet": "Index.isnull()", "intent": "Detect missing values .", "question_id": 36812}
{"snippet": "Index.isnull()", "intent": "Detect missing values .", "question_id": 36813}
{"snippet": "Index.isnull()", "intent": "Detect missing values .", "question_id": 36814}
{"snippet": "Index.item()", "intent": "Return the first element of the underlying data as a Python scalar .", "question_id": 36815}
{"snippet": "Index.item()", "intent": "Return the first element of the underlying data as a Python scalar .", "question_id": 36816}
{"snippet": "Index.item()", "intent": "Return the first element of the underlying data as a Python scalar .", "question_id": 36817}
{"snippet": "Index.join(other)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`.", "question_id": 36818}
{"snippet": "Index.join(other, how='left')", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `how`.", "question_id": 36819}
{"snippet": "Index.join(other, level=None)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `level`.", "question_id": 36820}
{"snippet": "Index.join(other, return_indexers=False)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `return_indexers`.", "question_id": 36821}
{"snippet": "Index.join(other, sort=False)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `sort`.", "question_id": 36822}
{"snippet": "Index.join(other, how='left', level=None)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `how`, `level`.", "question_id": 36823}
{"snippet": "Index.join(other, how='left', return_indexers=False)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `how`, `return_indexers`.", "question_id": 36824}
{"snippet": "Index.join(other, how='left', sort=False)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `how`, `sort`.", "question_id": 36825}
{"snippet": "Index.join(other, level=None, return_indexers=False)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `level`, `return_indexers`.", "question_id": 36826}
{"snippet": "Index.join(other, level=None, sort=False)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `level`, `sort`.", "question_id": 36827}
{"snippet": "Index.join(other)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`.", "question_id": 36828}
{"snippet": "Index.join(other, how='left')", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `how`.", "question_id": 36829}
{"snippet": "Index.join(other, level=None)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `level`.", "question_id": 36830}
{"snippet": "Index.join(other, return_indexers=False)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `return_indexers`.", "question_id": 36831}
{"snippet": "Index.join(other, sort=False)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `sort`.", "question_id": 36832}
{"snippet": "Index.join(other, how='left', level=None)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `how`, `level`.", "question_id": 36833}
{"snippet": "Index.join(other, how='left', return_indexers=False)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `how`, `return_indexers`.", "question_id": 36834}
{"snippet": "Index.join(other, how='left', sort=False)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `how`, `sort`.", "question_id": 36835}
{"snippet": "Index.join(other, level=None, return_indexers=False)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `level`, `return_indexers`.", "question_id": 36836}
{"snippet": "Index.join(other, level=None, sort=False)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `level`, `sort`.", "question_id": 36837}
{"snippet": "Index.join(other)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`.", "question_id": 36838}
{"snippet": "Index.join(other, how='left')", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `how`.", "question_id": 36839}
{"snippet": "Index.join(other, level=None)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `level`.", "question_id": 36840}
{"snippet": "Index.join(other, return_indexers=False)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `return_indexers`.", "question_id": 36841}
{"snippet": "Index.join(other, sort=False)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `sort`.", "question_id": 36842}
{"snippet": "Index.join(other, how='left', level=None)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `how`, `level`.", "question_id": 36843}
{"snippet": "Index.join(other, how='left', return_indexers=False)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `how`, `return_indexers`.", "question_id": 36844}
{"snippet": "Index.join(other, how='left', sort=False)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `how`, `sort`.", "question_id": 36845}
{"snippet": "Index.join(other, level=None, return_indexers=False)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `level`, `return_indexers`.", "question_id": 36846}
{"snippet": "Index.join(other, level=None, sort=False)", "intent": "Compute join_index and indexers to conform data structures to the new index . With arguments `other`, `level`, `sort`.", "question_id": 36847}
{"snippet": "Index.map(mapper)", "intent": "Map values using input correspondence ( a dict , Series , or function ) . With arguments `mapper`.", "question_id": 36848}
{"snippet": "Index.map(mapper, na_action=None)", "intent": "Map values using input correspondence ( a dict , Series , or function ) . With arguments `mapper`, `na_action`.", "question_id": 36849}
{"snippet": "Index.map(mapper)", "intent": "Map values using input correspondence ( a dict , Series , or function ) . With arguments `mapper`.", "question_id": 36850}
{"snippet": "Index.map(mapper, na_action=None)", "intent": "Map values using input correspondence ( a dict , Series , or function ) . With arguments `mapper`, `na_action`.", "question_id": 36851}
{"snippet": "Index.map(mapper)", "intent": "Map values using input correspondence ( a dict , Series , or function ) . With arguments `mapper`.", "question_id": 36852}
{"snippet": "Index.map(mapper, na_action=None)", "intent": "Map values using input correspondence ( a dict , Series , or function ) . With arguments `mapper`, `na_action`.", "question_id": 36853}
{"snippet": "Index.max(*args, **kwargs)", "intent": "Return the maximum value of the Index . With arguments `*args`, `**kwargs`.", "question_id": 36854}
{"snippet": "Index.max(*args, **kwargs, axis=None)", "intent": "Return the maximum value of the Index . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 36855}
{"snippet": "Index.max(*args, **kwargs, skipna=True)", "intent": "Return the maximum value of the Index . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 36856}
{"snippet": "Index.max(*args, **kwargs, axis=None, skipna=True)", "intent": "Return the maximum value of the Index . With arguments `*args`, `**kwargs`, `axis`, `skipna`.", "question_id": 36857}
{"snippet": "Index.max(*args, **kwargs)", "intent": "Return the maximum value of the Index . With arguments `*args`, `**kwargs`.", "question_id": 36858}
{"snippet": "Index.max(*args, **kwargs, axis=None)", "intent": "Return the maximum value of the Index . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 36859}
{"snippet": "Index.max(*args, **kwargs, skipna=True)", "intent": "Return the maximum value of the Index . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 36860}
{"snippet": "Index.max(*args, **kwargs, axis=None, skipna=True)", "intent": "Return the maximum value of the Index . With arguments `*args`, `**kwargs`, `axis`, `skipna`.", "question_id": 36861}
{"snippet": "Index.max(*args, **kwargs)", "intent": "Return the maximum value of the Index . With arguments `*args`, `**kwargs`.", "question_id": 36862}
{"snippet": "Index.max(*args, **kwargs, axis=None)", "intent": "Return the maximum value of the Index . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 36863}
{"snippet": "Index.max(*args, **kwargs, skipna=True)", "intent": "Return the maximum value of the Index . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 36864}
{"snippet": "Index.max(*args, **kwargs, axis=None, skipna=True)", "intent": "Return the maximum value of the Index . With arguments `*args`, `**kwargs`, `axis`, `skipna`.", "question_id": 36865}
{"snippet": "Index.memory_usage()", "intent": "Memory usage of the values .", "question_id": 36866}
{"snippet": "Index.memory_usage(deep=False)", "intent": "Memory usage of the values . With arguments `deep`.", "question_id": 36867}
{"snippet": "Index.memory_usage()", "intent": "Memory usage of the values .", "question_id": 36868}
{"snippet": "Index.memory_usage(deep=False)", "intent": "Memory usage of the values . With arguments `deep`.", "question_id": 36869}
{"snippet": "Index.memory_usage()", "intent": "Memory usage of the values .", "question_id": 36870}
{"snippet": "Index.memory_usage(deep=False)", "intent": "Memory usage of the values . With arguments `deep`.", "question_id": 36871}
{"snippet": "Index.min(*args, **kwargs)", "intent": "Return the minimum value of the Index . With arguments `*args`, `**kwargs`.", "question_id": 36872}
{"snippet": "Index.min(*args, **kwargs, axis=None)", "intent": "Return the minimum value of the Index . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 36873}
{"snippet": "Index.min(*args, **kwargs, skipna=True)", "intent": "Return the minimum value of the Index . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 36874}
{"snippet": "Index.min(*args, **kwargs, axis=None, skipna=True)", "intent": "Return the minimum value of the Index . With arguments `*args`, `**kwargs`, `axis`, `skipna`.", "question_id": 36875}
{"snippet": "Index.min(*args, **kwargs)", "intent": "Return the minimum value of the Index . With arguments `*args`, `**kwargs`.", "question_id": 36876}
{"snippet": "Index.min(*args, **kwargs, axis=None)", "intent": "Return the minimum value of the Index . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 36877}
{"snippet": "Index.min(*args, **kwargs, skipna=True)", "intent": "Return the minimum value of the Index . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 36878}
{"snippet": "Index.min(*args, **kwargs, axis=None, skipna=True)", "intent": "Return the minimum value of the Index . With arguments `*args`, `**kwargs`, `axis`, `skipna`.", "question_id": 36879}
{"snippet": "Index.min(*args, **kwargs)", "intent": "Return the minimum value of the Index . With arguments `*args`, `**kwargs`.", "question_id": 36880}
{"snippet": "Index.min(*args, **kwargs, axis=None)", "intent": "Return the minimum value of the Index . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 36881}
{"snippet": "Index.min(*args, **kwargs, skipna=True)", "intent": "Return the minimum value of the Index . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 36882}
{"snippet": "Index.min(*args, **kwargs, axis=None, skipna=True)", "intent": "Return the minimum value of the Index . With arguments `*args`, `**kwargs`, `axis`, `skipna`.", "question_id": 36883}
{"snippet": "Index.notna()", "intent": "Detect existing ( non-missing ) values .", "question_id": 36884}
{"snippet": "Index.notna()", "intent": "Detect existing ( non-missing ) values .", "question_id": 36885}
{"snippet": "Index.notna()", "intent": "Detect existing ( non-missing ) values .", "question_id": 36886}
{"snippet": "Index.notnull()", "intent": "Detect existing ( non-missing ) values .", "question_id": 36887}
{"snippet": "Index.notnull()", "intent": "Detect existing ( non-missing ) values .", "question_id": 36888}
{"snippet": "Index.notnull()", "intent": "Detect existing ( non-missing ) values .", "question_id": 36889}
{"snippet": "Index.nunique()", "intent": "Return number of unique elements in the object .", "question_id": 36890}
{"snippet": "Index.nunique(dropna=True)", "intent": "Return number of unique elements in the object . With arguments `dropna`.", "question_id": 36891}
{"snippet": "Index.nunique()", "intent": "Return number of unique elements in the object .", "question_id": 36892}
{"snippet": "Index.nunique(dropna=True)", "intent": "Return number of unique elements in the object . With arguments `dropna`.", "question_id": 36893}
{"snippet": "Index.nunique()", "intent": "Return number of unique elements in the object .", "question_id": 36894}
{"snippet": "Index.nunique(dropna=True)", "intent": "Return number of unique elements in the object . With arguments `dropna`.", "question_id": 36895}
{"snippet": "Index.putmask(mask, value)", "intent": "Return a new Index of the values set with the `mask` . With arguments `value`.", "question_id": 36896}
{"snippet": "Index.putmask(mask, value)", "intent": "Return a new Index of the values set with the `mask` . With arguments `value`.", "question_id": 36897}
{"snippet": "Index.putmask(mask, value)", "intent": "Return a new Index of the values set with the `mask` . With arguments `value`.", "question_id": 36898}
{"snippet": "Index.ravel()", "intent": "Return an ndarray of the flattened values of the underlying data .", "question_id": 36899}
{"snippet": "Index.ravel(order='C')", "intent": "Return an ndarray of the flattened values of the underlying data . With arguments `order`.", "question_id": 36900}
{"snippet": "Index.ravel()", "intent": "Return an ndarray of the flattened values of the underlying data .", "question_id": 36901}
{"snippet": "Index.ravel(order='C')", "intent": "Return an ndarray of the flattened values of the underlying data . With arguments `order`.", "question_id": 36902}
{"snippet": "Index.ravel()", "intent": "Return an ndarray of the flattened values of the underlying data .", "question_id": 36903}
{"snippet": "Index.ravel(order='C')", "intent": "Return an ndarray of the flattened values of the underlying data . With arguments `order`.", "question_id": 36904}
{"snippet": "Index.reindex(target)", "intent": "Create index with `target` \u2019 s values .", "question_id": 36905}
{"snippet": "Index.reindex(target, method=None)", "intent": "Create index with `target` \u2019 s values . With arguments `method`.", "question_id": 36906}
{"snippet": "Index.reindex(target, level=None)", "intent": "Create index with `target` \u2019 s values . With arguments `level`.", "question_id": 36907}
{"snippet": "Index.reindex(target, limit=None)", "intent": "Create index with `target` \u2019 s values . With arguments `limit`.", "question_id": 36908}
{"snippet": "Index.reindex(target, tolerance=None)", "intent": "Create index with `target` \u2019 s values . With arguments `tolerance`.", "question_id": 36909}
{"snippet": "Index.reindex(target, method=None, level=None)", "intent": "Create index with `target` \u2019 s values . With arguments `method`, `level`.", "question_id": 36910}
{"snippet": "Index.reindex(target, method=None, limit=None)", "intent": "Create index with `target` \u2019 s values . With arguments `method`, `limit`.", "question_id": 36911}
{"snippet": "Index.reindex(target, method=None, tolerance=None)", "intent": "Create index with `target` \u2019 s values . With arguments `method`, `tolerance`.", "question_id": 36912}
{"snippet": "Index.reindex(target, level=None, limit=None)", "intent": "Create index with `target` \u2019 s values . With arguments `level`, `limit`.", "question_id": 36913}
{"snippet": "Index.reindex(target, level=None, tolerance=None)", "intent": "Create index with `target` \u2019 s values . With arguments `level`, `tolerance`.", "question_id": 36914}
{"snippet": "Index.reindex(target)", "intent": "Create index with `target` \u2019 s values .", "question_id": 36915}
{"snippet": "Index.reindex(target, method=None)", "intent": "Create index with `target` \u2019 s values . With arguments `method`.", "question_id": 36916}
{"snippet": "Index.reindex(target, level=None)", "intent": "Create index with `target` \u2019 s values . With arguments `level`.", "question_id": 36917}
{"snippet": "Index.reindex(target, limit=None)", "intent": "Create index with `target` \u2019 s values . With arguments `limit`.", "question_id": 36918}
{"snippet": "Index.reindex(target, tolerance=None)", "intent": "Create index with `target` \u2019 s values . With arguments `tolerance`.", "question_id": 36919}
{"snippet": "Index.reindex(target, method=None, level=None)", "intent": "Create index with `target` \u2019 s values . With arguments `method`, `level`.", "question_id": 36920}
{"snippet": "Index.reindex(target, method=None, limit=None)", "intent": "Create index with `target` \u2019 s values . With arguments `method`, `limit`.", "question_id": 36921}
{"snippet": "Index.reindex(target, method=None, tolerance=None)", "intent": "Create index with `target` \u2019 s values . With arguments `method`, `tolerance`.", "question_id": 36922}
{"snippet": "Index.reindex(target, level=None, limit=None)", "intent": "Create index with `target` \u2019 s values . With arguments `level`, `limit`.", "question_id": 36923}
{"snippet": "Index.reindex(target, level=None, tolerance=None)", "intent": "Create index with `target` \u2019 s values . With arguments `level`, `tolerance`.", "question_id": 36924}
{"snippet": "Index.reindex(target)", "intent": "Create index with `target` \u2019 s values .", "question_id": 36925}
{"snippet": "Index.reindex(target, method=None)", "intent": "Create index with `target` \u2019 s values . With arguments `method`.", "question_id": 36926}
{"snippet": "Index.reindex(target, level=None)", "intent": "Create index with `target` \u2019 s values . With arguments `level`.", "question_id": 36927}
{"snippet": "Index.reindex(target, limit=None)", "intent": "Create index with `target` \u2019 s values . With arguments `limit`.", "question_id": 36928}
{"snippet": "Index.reindex(target, tolerance=None)", "intent": "Create index with `target` \u2019 s values . With arguments `tolerance`.", "question_id": 36929}
{"snippet": "Index.reindex(target, method=None, level=None)", "intent": "Create index with `target` \u2019 s values . With arguments `method`, `level`.", "question_id": 36930}
{"snippet": "Index.reindex(target, method=None, limit=None)", "intent": "Create index with `target` \u2019 s values . With arguments `method`, `limit`.", "question_id": 36931}
{"snippet": "Index.reindex(target, method=None, tolerance=None)", "intent": "Create index with `target` \u2019 s values . With arguments `method`, `tolerance`.", "question_id": 36932}
{"snippet": "Index.reindex(target, level=None, limit=None)", "intent": "Create index with `target` \u2019 s values . With arguments `level`, `limit`.", "question_id": 36933}
{"snippet": "Index.reindex(target, level=None, tolerance=None)", "intent": "Create index with `target` \u2019 s values . With arguments `level`, `tolerance`.", "question_id": 36934}
{"snippet": "Index.rename(name)", "intent": "Alter Index or MultiIndex `name` .", "question_id": 36935}
{"snippet": "Index.rename(name, inplace=False)", "intent": "Alter Index or MultiIndex `name` . With arguments `inplace`.", "question_id": 36936}
{"snippet": "Index.rename(name)", "intent": "Alter Index or MultiIndex `name` .", "question_id": 36937}
{"snippet": "Index.rename(name, inplace=False)", "intent": "Alter Index or MultiIndex `name` . With arguments `inplace`.", "question_id": 36938}
{"snippet": "Index.rename(name)", "intent": "Alter Index or MultiIndex `name` .", "question_id": 36939}
{"snippet": "Index.rename(name, inplace=False)", "intent": "Alter Index or MultiIndex `name` . With arguments `inplace`.", "question_id": 36940}
{"snippet": "Index.repeat(repeats)", "intent": "Repeat elements of a Index . With arguments `repeats`.", "question_id": 36941}
{"snippet": "Index.repeat(repeats, axis=None)", "intent": "Repeat elements of a Index . With arguments `repeats`, `axis`.", "question_id": 36942}
{"snippet": "Index.repeat(repeats)", "intent": "Repeat elements of a Index . With arguments `repeats`.", "question_id": 36943}
{"snippet": "Index.repeat(repeats, axis=None)", "intent": "Repeat elements of a Index . With arguments `repeats`, `axis`.", "question_id": 36944}
{"snippet": "Index.repeat(repeats)", "intent": "Repeat elements of a Index . With arguments `repeats`.", "question_id": 36945}
{"snippet": "Index.repeat(repeats, axis=None)", "intent": "Repeat elements of a Index . With arguments `repeats`, `axis`.", "question_id": 36946}
{"snippet": "Index.searchsorted(value)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted Index self such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved .", "question_id": 36947}
{"snippet": "Index.searchsorted(value, side='left')", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted Index self such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `side`.", "question_id": 36948}
{"snippet": "Index.searchsorted(value, sorter=None)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted Index self such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `sorter`.", "question_id": 36949}
{"snippet": "Index.searchsorted(value, side='left', sorter=None)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted Index self such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `side`, `sorter`.", "question_id": 36950}
{"snippet": "Index.searchsorted(value)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted Index self such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved .", "question_id": 36951}
{"snippet": "Index.searchsorted(value, side='left')", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted Index self such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `side`.", "question_id": 36952}
{"snippet": "Index.searchsorted(value, sorter=None)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted Index self such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `sorter`.", "question_id": 36953}
{"snippet": "Index.searchsorted(value, side='left', sorter=None)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted Index self such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `side`, `sorter`.", "question_id": 36954}
{"snippet": "Index.searchsorted(value)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted Index self such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved .", "question_id": 36955}
{"snippet": "Index.searchsorted(value, side='left')", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted Index self such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `side`.", "question_id": 36956}
{"snippet": "Index.searchsorted(value, sorter=None)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted Index self such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `sorter`.", "question_id": 36957}
{"snippet": "Index.searchsorted(value, side='left', sorter=None)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted Index self such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `side`, `sorter`.", "question_id": 36958}
{"snippet": "Index.set_names(names)", "intent": "Set Index or MultiIndex name . Able to set new `names` partially and by `level` .", "question_id": 36959}
{"snippet": "Index.set_names(names, level=None)", "intent": "Set Index or MultiIndex name . Able to set new `names` partially and by `level` .", "question_id": 36960}
{"snippet": "Index.set_names(names, inplace=False)", "intent": "Set Index or MultiIndex name . Able to set new `names` partially and by `level` . With arguments `inplace`.", "question_id": 36961}
{"snippet": "Index.set_names(names, level=None, inplace=False)", "intent": "Set Index or MultiIndex name . Able to set new `names` partially and by `level` . With arguments `inplace`.", "question_id": 36962}
{"snippet": "Index.set_names(names)", "intent": "Set Index or MultiIndex name . Able to set new `names` partially and by `level` .", "question_id": 36963}
{"snippet": "Index.set_names(names, level=None)", "intent": "Set Index or MultiIndex name . Able to set new `names` partially and by `level` .", "question_id": 36964}
{"snippet": "Index.set_names(names, inplace=False)", "intent": "Set Index or MultiIndex name . Able to set new `names` partially and by `level` . With arguments `inplace`.", "question_id": 36965}
{"snippet": "Index.set_names(names, level=None, inplace=False)", "intent": "Set Index or MultiIndex name . Able to set new `names` partially and by `level` . With arguments `inplace`.", "question_id": 36966}
{"snippet": "Index.set_names(names)", "intent": "Set Index or MultiIndex name . Able to set new `names` partially and by `level` .", "question_id": 36967}
{"snippet": "Index.set_names(names, level=None)", "intent": "Set Index or MultiIndex name . Able to set new `names` partially and by `level` .", "question_id": 36968}
{"snippet": "Index.set_names(names, inplace=False)", "intent": "Set Index or MultiIndex name . Able to set new `names` partially and by `level` . With arguments `inplace`.", "question_id": 36969}
{"snippet": "Index.set_names(names, level=None, inplace=False)", "intent": "Set Index or MultiIndex name . Able to set new `names` partially and by `level` . With arguments `inplace`.", "question_id": 36970}
{"snippet": "Index.set_value(arr, key, value)", "intent": "Fast lookup of `value` from 1-dimensional ndarray . With arguments `arr`, `key`.", "question_id": 36971}
{"snippet": "Index.set_value(arr, key, value)", "intent": "Fast lookup of `value` from 1-dimensional ndarray . With arguments `arr`, `key`.", "question_id": 36972}
{"snippet": "Index.set_value(arr, key, value)", "intent": "Fast lookup of `value` from 1-dimensional ndarray . With arguments `arr`, `key`.", "question_id": 36973}
{"snippet": "Index.shift()", "intent": "Shift index by desired number of time frequency increments .", "question_id": 36974}
{"snippet": "Index.shift(periods=1)", "intent": "Shift index by desired number of time frequency increments . With arguments `periods`.", "question_id": 36975}
{"snippet": "Index.shift(freq=None)", "intent": "Shift index by desired number of time frequency increments . The default value of `freq` is the freq attribute of the index , which is \u2018 MS \u2019 ( month start ) in this example .", "question_id": 36976}
{"snippet": "Index.shift(periods=1, freq=None)", "intent": "Shift index by desired number of time frequency increments . The default value of `freq` is the freq attribute of the index , which is \u2018 MS \u2019 ( month start ) in this example . With arguments `periods`.", "question_id": 36977}
{"snippet": "Index.shift()", "intent": "Shift index by desired number of time frequency increments .", "question_id": 36978}
{"snippet": "Index.shift(periods=1)", "intent": "Shift index by desired number of time frequency increments . With arguments `periods`.", "question_id": 36979}
{"snippet": "Index.shift(freq=None)", "intent": "Shift index by desired number of time frequency increments . The default value of `freq` is the freq attribute of the index , which is \u2018 MS \u2019 ( month start ) in this example .", "question_id": 36980}
{"snippet": "Index.shift(periods=1, freq=None)", "intent": "Shift index by desired number of time frequency increments . The default value of `freq` is the freq attribute of the index , which is \u2018 MS \u2019 ( month start ) in this example . With arguments `periods`.", "question_id": 36981}
{"snippet": "Index.shift()", "intent": "Shift index by desired number of time frequency increments .", "question_id": 36982}
{"snippet": "Index.shift(periods=1)", "intent": "Shift index by desired number of time frequency increments . With arguments `periods`.", "question_id": 36983}
{"snippet": "Index.shift(freq=None)", "intent": "Shift index by desired number of time frequency increments . The default value of `freq` is the freq attribute of the index , which is \u2018 MS \u2019 ( month start ) in this example .", "question_id": 36984}
{"snippet": "Index.shift(periods=1, freq=None)", "intent": "Shift index by desired number of time frequency increments . The default value of `freq` is the freq attribute of the index , which is \u2018 MS \u2019 ( month start ) in this example . With arguments `periods`.", "question_id": 36985}
{"snippet": "Index.slice_indexer()", "intent": "Compute the slice indexer for input labels and `step` .", "question_id": 36986}
{"snippet": "Index.slice_indexer(start=None)", "intent": "Compute the slice indexer for input labels and `step` . With arguments `start`.", "question_id": 36987}
{"snippet": "Index.slice_indexer(end=None)", "intent": "Compute the slice indexer for input labels and `step` . With arguments `end`.", "question_id": 36988}
{"snippet": "Index.slice_indexer(step=None)", "intent": "Compute the slice indexer for input labels and `step` .", "question_id": 36989}
{"snippet": "Index.slice_indexer(kind=None)", "intent": "Compute the slice indexer for input labels and `step` . With arguments `kind`.", "question_id": 36990}
{"snippet": "Index.slice_indexer(start=None, end=None)", "intent": "Compute the slice indexer for input labels and `step` . With arguments `start`, `end`.", "question_id": 36991}
{"snippet": "Index.slice_indexer(start=None, step=None)", "intent": "Compute the slice indexer for input labels and `step` . With arguments `start`.", "question_id": 36992}
{"snippet": "Index.slice_indexer(start=None, kind=None)", "intent": "Compute the slice indexer for input labels and `step` . With arguments `start`, `kind`.", "question_id": 36993}
{"snippet": "Index.slice_indexer(end=None, step=None)", "intent": "Compute the slice indexer for input labels and `step` . With arguments `end`.", "question_id": 36994}
{"snippet": "Index.slice_indexer(end=None, kind=None)", "intent": "Compute the slice indexer for input labels and `step` . With arguments `end`, `kind`.", "question_id": 36995}
{"snippet": "Index.slice_indexer()", "intent": "Compute the slice indexer for input labels and `step` .", "question_id": 36996}
{"snippet": "Index.slice_indexer(start=None)", "intent": "Compute the slice indexer for input labels and `step` . With arguments `start`.", "question_id": 36997}
{"snippet": "Index.slice_indexer(end=None)", "intent": "Compute the slice indexer for input labels and `step` . With arguments `end`.", "question_id": 36998}
{"snippet": "Index.slice_indexer(step=None)", "intent": "Compute the slice indexer for input labels and `step` .", "question_id": 36999}
{"snippet": "Index.slice_indexer(kind=None)", "intent": "Compute the slice indexer for input labels and `step` . With arguments `kind`.", "question_id": 37000}
{"snippet": "Index.slice_indexer(start=None, end=None)", "intent": "Compute the slice indexer for input labels and `step` . With arguments `start`, `end`.", "question_id": 37001}
{"snippet": "Index.slice_indexer(start=None, step=None)", "intent": "Compute the slice indexer for input labels and `step` . With arguments `start`.", "question_id": 37002}
{"snippet": "Index.slice_indexer(start=None, kind=None)", "intent": "Compute the slice indexer for input labels and `step` . With arguments `start`, `kind`.", "question_id": 37003}
{"snippet": "Index.slice_indexer(end=None, step=None)", "intent": "Compute the slice indexer for input labels and `step` . With arguments `end`.", "question_id": 37004}
{"snippet": "Index.slice_indexer(end=None, kind=None)", "intent": "Compute the slice indexer for input labels and `step` . With arguments `end`, `kind`.", "question_id": 37005}
{"snippet": "Index.slice_indexer()", "intent": "Compute the slice indexer for input labels and `step` .", "question_id": 37006}
{"snippet": "Index.slice_indexer(start=None)", "intent": "Compute the slice indexer for input labels and `step` . With arguments `start`.", "question_id": 37007}
{"snippet": "Index.slice_indexer(end=None)", "intent": "Compute the slice indexer for input labels and `step` . With arguments `end`.", "question_id": 37008}
{"snippet": "Index.slice_indexer(step=None)", "intent": "Compute the slice indexer for input labels and `step` .", "question_id": 37009}
{"snippet": "Index.slice_indexer(kind=None)", "intent": "Compute the slice indexer for input labels and `step` . With arguments `kind`.", "question_id": 37010}
{"snippet": "Index.slice_indexer(start=None, end=None)", "intent": "Compute the slice indexer for input labels and `step` . With arguments `start`, `end`.", "question_id": 37011}
{"snippet": "Index.slice_indexer(start=None, step=None)", "intent": "Compute the slice indexer for input labels and `step` . With arguments `start`.", "question_id": 37012}
{"snippet": "Index.slice_indexer(start=None, kind=None)", "intent": "Compute the slice indexer for input labels and `step` . With arguments `start`, `kind`.", "question_id": 37013}
{"snippet": "Index.slice_indexer(end=None, step=None)", "intent": "Compute the slice indexer for input labels and `step` . With arguments `end`.", "question_id": 37014}
{"snippet": "Index.slice_indexer(end=None, kind=None)", "intent": "Compute the slice indexer for input labels and `step` . With arguments `end`, `kind`.", "question_id": 37015}
{"snippet": "Index.slice_locs()", "intent": "Compute slice locations for input labels .", "question_id": 37016}
{"snippet": "Index.slice_locs(start=None)", "intent": "Compute slice locations for input labels . With arguments `start`.", "question_id": 37017}
{"snippet": "Index.slice_locs(end=None)", "intent": "Compute slice locations for input labels . With arguments `end`.", "question_id": 37018}
{"snippet": "Index.slice_locs(step=None)", "intent": "Compute slice locations for input labels . With arguments `step`.", "question_id": 37019}
{"snippet": "Index.slice_locs(kind=None)", "intent": "Compute slice locations for input labels . With arguments `kind`.", "question_id": 37020}
{"snippet": "Index.slice_locs(start=None, end=None)", "intent": "Compute slice locations for input labels . With arguments `start`, `end`.", "question_id": 37021}
{"snippet": "Index.slice_locs(start=None, step=None)", "intent": "Compute slice locations for input labels . With arguments `start`, `step`.", "question_id": 37022}
{"snippet": "Index.slice_locs(start=None, kind=None)", "intent": "Compute slice locations for input labels . With arguments `start`, `kind`.", "question_id": 37023}
{"snippet": "Index.slice_locs(end=None, step=None)", "intent": "Compute slice locations for input labels . With arguments `end`, `step`.", "question_id": 37024}
{"snippet": "Index.slice_locs(end=None, kind=None)", "intent": "Compute slice locations for input labels . With arguments `end`, `kind`.", "question_id": 37025}
{"snippet": "Index.slice_locs()", "intent": "Compute slice locations for input labels .", "question_id": 37026}
{"snippet": "Index.slice_locs(start=None)", "intent": "Compute slice locations for input labels . With arguments `start`.", "question_id": 37027}
{"snippet": "Index.slice_locs(end=None)", "intent": "Compute slice locations for input labels . With arguments `end`.", "question_id": 37028}
{"snippet": "Index.slice_locs(step=None)", "intent": "Compute slice locations for input labels . With arguments `step`.", "question_id": 37029}
{"snippet": "Index.slice_locs(kind=None)", "intent": "Compute slice locations for input labels . With arguments `kind`.", "question_id": 37030}
{"snippet": "Index.slice_locs(start=None, end=None)", "intent": "Compute slice locations for input labels . With arguments `start`, `end`.", "question_id": 37031}
{"snippet": "Index.slice_locs(start=None, step=None)", "intent": "Compute slice locations for input labels . With arguments `start`, `step`.", "question_id": 37032}
{"snippet": "Index.slice_locs(start=None, kind=None)", "intent": "Compute slice locations for input labels . With arguments `start`, `kind`.", "question_id": 37033}
{"snippet": "Index.slice_locs(end=None, step=None)", "intent": "Compute slice locations for input labels . With arguments `end`, `step`.", "question_id": 37034}
{"snippet": "Index.slice_locs(end=None, kind=None)", "intent": "Compute slice locations for input labels . With arguments `end`, `kind`.", "question_id": 37035}
{"snippet": "Index.slice_locs()", "intent": "Compute slice locations for input labels .", "question_id": 37036}
{"snippet": "Index.slice_locs(start=None)", "intent": "Compute slice locations for input labels . With arguments `start`.", "question_id": 37037}
{"snippet": "Index.slice_locs(end=None)", "intent": "Compute slice locations for input labels . With arguments `end`.", "question_id": 37038}
{"snippet": "Index.slice_locs(step=None)", "intent": "Compute slice locations for input labels . With arguments `step`.", "question_id": 37039}
{"snippet": "Index.slice_locs(kind=None)", "intent": "Compute slice locations for input labels . With arguments `kind`.", "question_id": 37040}
{"snippet": "Index.slice_locs(start=None, end=None)", "intent": "Compute slice locations for input labels . With arguments `start`, `end`.", "question_id": 37041}
{"snippet": "Index.slice_locs(start=None, step=None)", "intent": "Compute slice locations for input labels . With arguments `start`, `step`.", "question_id": 37042}
{"snippet": "Index.slice_locs(start=None, kind=None)", "intent": "Compute slice locations for input labels . With arguments `start`, `kind`.", "question_id": 37043}
{"snippet": "Index.slice_locs(end=None, step=None)", "intent": "Compute slice locations for input labels . With arguments `end`, `step`.", "question_id": 37044}
{"snippet": "Index.slice_locs(end=None, kind=None)", "intent": "Compute slice locations for input labels . With arguments `end`, `kind`.", "question_id": 37045}
{"snippet": "Index.sort(*args, **kwargs)", "intent": "Use sort_values instead . With arguments `*args`, `**kwargs`.", "question_id": 37046}
{"snippet": "Index.sort(*args, **kwargs)", "intent": "Use sort_values instead . With arguments `*args`, `**kwargs`.", "question_id": 37047}
{"snippet": "Index.sort(*args, **kwargs)", "intent": "Use sort_values instead . With arguments `*args`, `**kwargs`.", "question_id": 37048}
{"snippet": "Index.sort_values()", "intent": "Return a sorted copy of the index .", "question_id": 37049}
{"snippet": "Index.sort_values(return_indexer=False)", "intent": "Return a sorted copy of the index . With arguments `return_indexer`.", "question_id": 37050}
{"snippet": "Index.sort_values(ascending=True)", "intent": "Return a sorted copy of the index . Sort values in `ascending` order ( default behavior ) .", "question_id": 37051}
{"snippet": "Index.sort_values(na_position='last')", "intent": "Return a sorted copy of the index . With arguments `na_position`.", "question_id": 37052}
{"snippet": "Index.sort_values(key=None)", "intent": "Return a sorted copy of the index . With arguments `key`.", "question_id": 37053}
{"snippet": "Index.sort_values(return_indexer=False, ascending=True)", "intent": "Return a sorted copy of the index . Sort values in `ascending` order ( default behavior ) . With arguments `return_indexer`.", "question_id": 37054}
{"snippet": "Index.sort_values(return_indexer=False, na_position='last')", "intent": "Return a sorted copy of the index . With arguments `return_indexer`, `na_position`.", "question_id": 37055}
{"snippet": "Index.sort_values(return_indexer=False, key=None)", "intent": "Return a sorted copy of the index . With arguments `return_indexer`, `key`.", "question_id": 37056}
{"snippet": "Index.sort_values(ascending=True, na_position='last')", "intent": "Return a sorted copy of the index . Sort values in `ascending` order ( default behavior ) . With arguments `na_position`.", "question_id": 37057}
{"snippet": "Index.sort_values(ascending=True, key=None)", "intent": "Return a sorted copy of the index . Sort values in `ascending` order ( default behavior ) . With arguments `key`.", "question_id": 37058}
{"snippet": "Index.sort_values()", "intent": "Return a sorted copy of the index .", "question_id": 37059}
{"snippet": "Index.sort_values(return_indexer=False)", "intent": "Return a sorted copy of the index . With arguments `return_indexer`.", "question_id": 37060}
{"snippet": "Index.sort_values(ascending=True)", "intent": "Return a sorted copy of the index . Sort values in `ascending` order ( default behavior ) .", "question_id": 37061}
{"snippet": "Index.sort_values(na_position='last')", "intent": "Return a sorted copy of the index . With arguments `na_position`.", "question_id": 37062}
{"snippet": "Index.sort_values(key=None)", "intent": "Return a sorted copy of the index . With arguments `key`.", "question_id": 37063}
{"snippet": "Index.sort_values(return_indexer=False, ascending=True)", "intent": "Return a sorted copy of the index . Sort values in `ascending` order ( default behavior ) . With arguments `return_indexer`.", "question_id": 37064}
{"snippet": "Index.sort_values(return_indexer=False, na_position='last')", "intent": "Return a sorted copy of the index . With arguments `return_indexer`, `na_position`.", "question_id": 37065}
{"snippet": "Index.sort_values(return_indexer=False, key=None)", "intent": "Return a sorted copy of the index . With arguments `return_indexer`, `key`.", "question_id": 37066}
{"snippet": "Index.sort_values(ascending=True, na_position='last')", "intent": "Return a sorted copy of the index . Sort values in `ascending` order ( default behavior ) . With arguments `na_position`.", "question_id": 37067}
{"snippet": "Index.sort_values(ascending=True, key=None)", "intent": "Return a sorted copy of the index . Sort values in `ascending` order ( default behavior ) . With arguments `key`.", "question_id": 37068}
{"snippet": "Index.sort_values()", "intent": "Return a sorted copy of the index .", "question_id": 37069}
{"snippet": "Index.sort_values(return_indexer=False)", "intent": "Return a sorted copy of the index . With arguments `return_indexer`.", "question_id": 37070}
{"snippet": "Index.sort_values(ascending=True)", "intent": "Return a sorted copy of the index . Sort values in `ascending` order ( default behavior ) .", "question_id": 37071}
{"snippet": "Index.sort_values(na_position='last')", "intent": "Return a sorted copy of the index . With arguments `na_position`.", "question_id": 37072}
{"snippet": "Index.sort_values(key=None)", "intent": "Return a sorted copy of the index . With arguments `key`.", "question_id": 37073}
{"snippet": "Index.sort_values(return_indexer=False, ascending=True)", "intent": "Return a sorted copy of the index . Sort values in `ascending` order ( default behavior ) . With arguments `return_indexer`.", "question_id": 37074}
{"snippet": "Index.sort_values(return_indexer=False, na_position='last')", "intent": "Return a sorted copy of the index . With arguments `return_indexer`, `na_position`.", "question_id": 37075}
{"snippet": "Index.sort_values(return_indexer=False, key=None)", "intent": "Return a sorted copy of the index . With arguments `return_indexer`, `key`.", "question_id": 37076}
{"snippet": "Index.sort_values(ascending=True, na_position='last')", "intent": "Return a sorted copy of the index . Sort values in `ascending` order ( default behavior ) . With arguments `na_position`.", "question_id": 37077}
{"snippet": "Index.sort_values(ascending=True, key=None)", "intent": "Return a sorted copy of the index . Sort values in `ascending` order ( default behavior ) . With arguments `key`.", "question_id": 37078}
{"snippet": "Index.sortlevel()", "intent": "For internal compatibility with the Index API .", "question_id": 37079}
{"snippet": "Index.sortlevel(level=None)", "intent": "For internal compatibility with the Index API . With arguments `level`.", "question_id": 37080}
{"snippet": "Index.sortlevel(ascending=True)", "intent": "For internal compatibility with the Index API . With arguments `ascending`.", "question_id": 37081}
{"snippet": "Index.sortlevel(sort_remaining=None)", "intent": "For internal compatibility with the Index API . With arguments `sort_remaining`.", "question_id": 37082}
{"snippet": "Index.sortlevel(level=None, ascending=True)", "intent": "For internal compatibility with the Index API . With arguments `level`, `ascending`.", "question_id": 37083}
{"snippet": "Index.sortlevel(level=None, sort_remaining=None)", "intent": "For internal compatibility with the Index API . With arguments `level`, `sort_remaining`.", "question_id": 37084}
{"snippet": "Index.sortlevel(ascending=True, sort_remaining=None)", "intent": "For internal compatibility with the Index API . With arguments `ascending`, `sort_remaining`.", "question_id": 37085}
{"snippet": "Index.sortlevel(level=None, ascending=True, sort_remaining=None)", "intent": "For internal compatibility with the Index API . With arguments `level`, `ascending`, `sort_remaining`.", "question_id": 37086}
{"snippet": "Index.sortlevel()", "intent": "For internal compatibility with the Index API .", "question_id": 37087}
{"snippet": "Index.sortlevel(level=None)", "intent": "For internal compatibility with the Index API . With arguments `level`.", "question_id": 37088}
{"snippet": "Index.sortlevel(ascending=True)", "intent": "For internal compatibility with the Index API . With arguments `ascending`.", "question_id": 37089}
{"snippet": "Index.sortlevel(sort_remaining=None)", "intent": "For internal compatibility with the Index API . With arguments `sort_remaining`.", "question_id": 37090}
{"snippet": "Index.sortlevel(level=None, ascending=True)", "intent": "For internal compatibility with the Index API . With arguments `level`, `ascending`.", "question_id": 37091}
{"snippet": "Index.sortlevel(level=None, sort_remaining=None)", "intent": "For internal compatibility with the Index API . With arguments `level`, `sort_remaining`.", "question_id": 37092}
{"snippet": "Index.sortlevel(ascending=True, sort_remaining=None)", "intent": "For internal compatibility with the Index API . With arguments `ascending`, `sort_remaining`.", "question_id": 37093}
{"snippet": "Index.sortlevel(level=None, ascending=True, sort_remaining=None)", "intent": "For internal compatibility with the Index API . With arguments `level`, `ascending`, `sort_remaining`.", "question_id": 37094}
{"snippet": "Index.sortlevel()", "intent": "For internal compatibility with the Index API .", "question_id": 37095}
{"snippet": "Index.sortlevel(level=None)", "intent": "For internal compatibility with the Index API . With arguments `level`.", "question_id": 37096}
{"snippet": "Index.sortlevel(ascending=True)", "intent": "For internal compatibility with the Index API . With arguments `ascending`.", "question_id": 37097}
{"snippet": "Index.sortlevel(sort_remaining=None)", "intent": "For internal compatibility with the Index API . With arguments `sort_remaining`.", "question_id": 37098}
{"snippet": "Index.sortlevel(level=None, ascending=True)", "intent": "For internal compatibility with the Index API . With arguments `level`, `ascending`.", "question_id": 37099}
{"snippet": "Index.sortlevel(level=None, sort_remaining=None)", "intent": "For internal compatibility with the Index API . With arguments `level`, `sort_remaining`.", "question_id": 37100}
{"snippet": "Index.sortlevel(ascending=True, sort_remaining=None)", "intent": "For internal compatibility with the Index API . With arguments `ascending`, `sort_remaining`.", "question_id": 37101}
{"snippet": "Index.sortlevel(level=None, ascending=True, sort_remaining=None)", "intent": "For internal compatibility with the Index API . With arguments `level`, `ascending`, `sort_remaining`.", "question_id": 37102}
{"snippet": "Index.str()", "intent": "Vectorized string functions for Series and Index .", "question_id": 37103}
{"snippet": "Index.str()", "intent": "Vectorized string functions for Series and Index .", "question_id": 37104}
{"snippet": "Index.str()", "intent": "Vectorized string functions for Series and Index .", "question_id": 37105}
{"snippet": "Index.symmetric_difference(other)", "intent": "Compute the symmetric difference of two Index objects . With arguments `other`.", "question_id": 37106}
{"snippet": "Index.symmetric_difference(other, result_name=None)", "intent": "Compute the symmetric difference of two Index objects . With arguments `other`, `result_name`.", "question_id": 37107}
{"snippet": "Index.symmetric_difference(other, sort=None)", "intent": "Compute the symmetric difference of two Index objects . With arguments `other`, `sort`.", "question_id": 37108}
{"snippet": "Index.symmetric_difference(other, result_name=None, sort=None)", "intent": "Compute the symmetric difference of two Index objects . With arguments `other`, `result_name`, `sort`.", "question_id": 37109}
{"snippet": "Index.symmetric_difference(other)", "intent": "Compute the symmetric difference of two Index objects . With arguments `other`.", "question_id": 37110}
{"snippet": "Index.symmetric_difference(other, result_name=None)", "intent": "Compute the symmetric difference of two Index objects . With arguments `other`, `result_name`.", "question_id": 37111}
{"snippet": "Index.symmetric_difference(other, sort=None)", "intent": "Compute the symmetric difference of two Index objects . With arguments `other`, `sort`.", "question_id": 37112}
{"snippet": "Index.symmetric_difference(other, result_name=None, sort=None)", "intent": "Compute the symmetric difference of two Index objects . With arguments `other`, `result_name`, `sort`.", "question_id": 37113}
{"snippet": "Index.symmetric_difference(other)", "intent": "Compute the symmetric difference of two Index objects . With arguments `other`.", "question_id": 37114}
{"snippet": "Index.symmetric_difference(other, result_name=None)", "intent": "Compute the symmetric difference of two Index objects . With arguments `other`, `result_name`.", "question_id": 37115}
{"snippet": "Index.symmetric_difference(other, sort=None)", "intent": "Compute the symmetric difference of two Index objects . With arguments `other`, `sort`.", "question_id": 37116}
{"snippet": "Index.symmetric_difference(other, result_name=None, sort=None)", "intent": "Compute the symmetric difference of two Index objects . With arguments `other`, `result_name`, `sort`.", "question_id": 37117}
{"snippet": "Index.take(indices, **kwargs)", "intent": "Return a new Index of the values selected by the `indices` . With arguments `**kwargs`.", "question_id": 37118}
{"snippet": "Index.take(indices, **kwargs, axis=0)", "intent": "Return a new Index of the values selected by the `indices` . With arguments `**kwargs`, `axis`.", "question_id": 37119}
{"snippet": "Index.take(indices, **kwargs, allow_fill=True)", "intent": "Return a new Index of the values selected by the `indices` . With arguments `**kwargs`, `allow_fill`.", "question_id": 37120}
{"snippet": "Index.take(indices, **kwargs, fill_value=None)", "intent": "Return a new Index of the values selected by the `indices` . With arguments `**kwargs`, `fill_value`.", "question_id": 37121}
{"snippet": "Index.take(indices, **kwargs, axis=0, allow_fill=True)", "intent": "Return a new Index of the values selected by the `indices` . With arguments `**kwargs`, `axis`, `allow_fill`.", "question_id": 37122}
{"snippet": "Index.take(indices, **kwargs, axis=0, fill_value=None)", "intent": "Return a new Index of the values selected by the `indices` . With arguments `**kwargs`, `axis`, `fill_value`.", "question_id": 37123}
{"snippet": "Index.take(indices, **kwargs, allow_fill=True, fill_value=None)", "intent": "Return a new Index of the values selected by the `indices` . With arguments `**kwargs`, `allow_fill`, `fill_value`.", "question_id": 37124}
{"snippet": "Index.take(indices, **kwargs, axis=0, allow_fill=True, fill_value=None)", "intent": "Return a new Index of the values selected by the `indices` . With arguments `**kwargs`, `axis`, `allow_fill`, `fill_value`.", "question_id": 37125}
{"snippet": "Index.take(indices, **kwargs)", "intent": "Return a new Index of the values selected by the `indices` . With arguments `**kwargs`.", "question_id": 37126}
{"snippet": "Index.take(indices, **kwargs, axis=0)", "intent": "Return a new Index of the values selected by the `indices` . With arguments `**kwargs`, `axis`.", "question_id": 37127}
{"snippet": "Index.take(indices, **kwargs, allow_fill=True)", "intent": "Return a new Index of the values selected by the `indices` . With arguments `**kwargs`, `allow_fill`.", "question_id": 37128}
{"snippet": "Index.take(indices, **kwargs, fill_value=None)", "intent": "Return a new Index of the values selected by the `indices` . With arguments `**kwargs`, `fill_value`.", "question_id": 37129}
{"snippet": "Index.take(indices, **kwargs, axis=0, allow_fill=True)", "intent": "Return a new Index of the values selected by the `indices` . With arguments `**kwargs`, `axis`, `allow_fill`.", "question_id": 37130}
{"snippet": "Index.take(indices, **kwargs, axis=0, fill_value=None)", "intent": "Return a new Index of the values selected by the `indices` . With arguments `**kwargs`, `axis`, `fill_value`.", "question_id": 37131}
{"snippet": "Index.take(indices, **kwargs, allow_fill=True, fill_value=None)", "intent": "Return a new Index of the values selected by the `indices` . With arguments `**kwargs`, `allow_fill`, `fill_value`.", "question_id": 37132}
{"snippet": "Index.take(indices, **kwargs, axis=0, allow_fill=True, fill_value=None)", "intent": "Return a new Index of the values selected by the `indices` . With arguments `**kwargs`, `axis`, `allow_fill`, `fill_value`.", "question_id": 37133}
{"snippet": "Index.take(indices, **kwargs)", "intent": "Return a new Index of the values selected by the `indices` . With arguments `**kwargs`.", "question_id": 37134}
{"snippet": "Index.take(indices, **kwargs, axis=0)", "intent": "Return a new Index of the values selected by the `indices` . With arguments `**kwargs`, `axis`.", "question_id": 37135}
{"snippet": "Index.take(indices, **kwargs, allow_fill=True)", "intent": "Return a new Index of the values selected by the `indices` . With arguments `**kwargs`, `allow_fill`.", "question_id": 37136}
{"snippet": "Index.take(indices, **kwargs, fill_value=None)", "intent": "Return a new Index of the values selected by the `indices` . With arguments `**kwargs`, `fill_value`.", "question_id": 37137}
{"snippet": "Index.take(indices, **kwargs, axis=0, allow_fill=True)", "intent": "Return a new Index of the values selected by the `indices` . With arguments `**kwargs`, `axis`, `allow_fill`.", "question_id": 37138}
{"snippet": "Index.take(indices, **kwargs, axis=0, fill_value=None)", "intent": "Return a new Index of the values selected by the `indices` . With arguments `**kwargs`, `axis`, `fill_value`.", "question_id": 37139}
{"snippet": "Index.take(indices, **kwargs, allow_fill=True, fill_value=None)", "intent": "Return a new Index of the values selected by the `indices` . With arguments `**kwargs`, `allow_fill`, `fill_value`.", "question_id": 37140}
{"snippet": "Index.take(indices, **kwargs, axis=0, allow_fill=True, fill_value=None)", "intent": "Return a new Index of the values selected by the `indices` . With arguments `**kwargs`, `axis`, `allow_fill`, `fill_value`.", "question_id": 37141}
{"snippet": "Index.to_flat_index()", "intent": "Identity method .", "question_id": 37142}
{"snippet": "Index.to_flat_index()", "intent": "Identity method .", "question_id": 37143}
{"snippet": "Index.to_flat_index()", "intent": "Identity method .", "question_id": 37144}
{"snippet": "Index.to_frame()", "intent": "Create a DataFrame with a column containing the Index .", "question_id": 37145}
{"snippet": "Index.to_frame(index=True)", "intent": "Create a DataFrame with a column containing the Index . With arguments `index`.", "question_id": 37146}
{"snippet": "Index.to_frame(name=None)", "intent": "Create a DataFrame with a column containing the Index . To override the `name` of the resulting column , specify name :", "question_id": 37147}
{"snippet": "Index.to_frame(index=True, name=None)", "intent": "Create a DataFrame with a column containing the Index . To override the `name` of the resulting column , specify name : With arguments `index`.", "question_id": 37148}
{"snippet": "Index.to_frame()", "intent": "Create a DataFrame with a column containing the Index .", "question_id": 37149}
{"snippet": "Index.to_frame(index=True)", "intent": "Create a DataFrame with a column containing the Index . With arguments `index`.", "question_id": 37150}
{"snippet": "Index.to_frame(name=None)", "intent": "Create a DataFrame with a column containing the Index . To override the `name` of the resulting column , specify name :", "question_id": 37151}
{"snippet": "Index.to_frame(index=True, name=None)", "intent": "Create a DataFrame with a column containing the Index . To override the `name` of the resulting column , specify name : With arguments `index`.", "question_id": 37152}
{"snippet": "Index.to_frame()", "intent": "Create a DataFrame with a column containing the Index .", "question_id": 37153}
{"snippet": "Index.to_frame(index=True)", "intent": "Create a DataFrame with a column containing the Index . With arguments `index`.", "question_id": 37154}
{"snippet": "Index.to_frame(name=None)", "intent": "Create a DataFrame with a column containing the Index . To override the `name` of the resulting column , specify name :", "question_id": 37155}
{"snippet": "Index.to_frame(index=True, name=None)", "intent": "Create a DataFrame with a column containing the Index . To override the `name` of the resulting column , specify name : With arguments `index`.", "question_id": 37156}
{"snippet": "Index.to_list()", "intent": "Return a list of the values .", "question_id": 37157}
{"snippet": "Index.to_list()", "intent": "Return a list of the values .", "question_id": 37158}
{"snippet": "Index.to_list()", "intent": "Return a list of the values .", "question_id": 37159}
{"snippet": "Index.to_native_types(**kwargs)", "intent": "Format specified values of self and return them . With arguments `**kwargs`.", "question_id": 37160}
{"snippet": "Index.to_native_types(**kwargs, slicer=None)", "intent": "Format specified values of self and return them . With arguments `**kwargs`, `slicer`.", "question_id": 37161}
{"snippet": "Index.to_native_types(**kwargs)", "intent": "Format specified values of self and return them . With arguments `**kwargs`.", "question_id": 37162}
{"snippet": "Index.to_native_types(**kwargs, slicer=None)", "intent": "Format specified values of self and return them . With arguments `**kwargs`, `slicer`.", "question_id": 37163}
{"snippet": "Index.to_native_types(**kwargs)", "intent": "Format specified values of self and return them . With arguments `**kwargs`.", "question_id": 37164}
{"snippet": "Index.to_native_types(**kwargs, slicer=None)", "intent": "Format specified values of self and return them . With arguments `**kwargs`, `slicer`.", "question_id": 37165}
{"snippet": "Index.to_numpy(**kwargs)", "intent": "A NumPy ndarray representing the values in this Series or Index . With arguments `**kwargs`.", "question_id": 37166}
{"snippet": "Index.to_numpy(**kwargs, dtype=None)", "intent": "A NumPy ndarray representing the values in this Series or Index . When self contains an ExtensionArray , the `dtype` may be different . With arguments `**kwargs`.", "question_id": 37167}
{"snippet": "Index.to_numpy(**kwargs, copy=False)", "intent": "A NumPy ndarray representing the values in this Series or Index . With arguments `**kwargs`, `copy`.", "question_id": 37168}
{"snippet": "Index.to_numpy(**kwargs, na_value=NoDefault.no_default)", "intent": "A NumPy ndarray representing the values in this Series or Index . With arguments `**kwargs`, `na_value`.", "question_id": 37169}
{"snippet": "Index.to_numpy(**kwargs, dtype=None, copy=False)", "intent": "A NumPy ndarray representing the values in this Series or Index . When self contains an ExtensionArray , the `dtype` may be different . With arguments `**kwargs`, `copy`.", "question_id": 37170}
{"snippet": "Index.to_numpy(**kwargs, dtype=None, na_value=NoDefault.no_default)", "intent": "A NumPy ndarray representing the values in this Series or Index . When self contains an ExtensionArray , the `dtype` may be different . With arguments `**kwargs`, `na_value`.", "question_id": 37171}
{"snippet": "Index.to_numpy(**kwargs, copy=False, na_value=NoDefault.no_default)", "intent": "A NumPy ndarray representing the values in this Series or Index . With arguments `**kwargs`, `copy`, `na_value`.", "question_id": 37172}
{"snippet": "Index.to_numpy(**kwargs, dtype=None, copy=False, na_value=NoDefault.no_default)", "intent": "A NumPy ndarray representing the values in this Series or Index . When self contains an ExtensionArray , the `dtype` may be different . With arguments `**kwargs`, `copy`, `na_value`.", "question_id": 37173}
{"snippet": "Index.to_numpy(**kwargs)", "intent": "A NumPy ndarray representing the values in this Series or Index . With arguments `**kwargs`.", "question_id": 37174}
{"snippet": "Index.to_numpy(**kwargs, dtype=None)", "intent": "A NumPy ndarray representing the values in this Series or Index . When self contains an ExtensionArray , the `dtype` may be different . With arguments `**kwargs`.", "question_id": 37175}
{"snippet": "Index.to_numpy(**kwargs, copy=False)", "intent": "A NumPy ndarray representing the values in this Series or Index . With arguments `**kwargs`, `copy`.", "question_id": 37176}
{"snippet": "Index.to_numpy(**kwargs, na_value=NoDefault.no_default)", "intent": "A NumPy ndarray representing the values in this Series or Index . With arguments `**kwargs`, `na_value`.", "question_id": 37177}
{"snippet": "Index.to_numpy(**kwargs, dtype=None, copy=False)", "intent": "A NumPy ndarray representing the values in this Series or Index . When self contains an ExtensionArray , the `dtype` may be different . With arguments `**kwargs`, `copy`.", "question_id": 37178}
{"snippet": "Index.to_numpy(**kwargs, dtype=None, na_value=NoDefault.no_default)", "intent": "A NumPy ndarray representing the values in this Series or Index . When self contains an ExtensionArray , the `dtype` may be different . With arguments `**kwargs`, `na_value`.", "question_id": 37179}
{"snippet": "Index.to_numpy(**kwargs, copy=False, na_value=NoDefault.no_default)", "intent": "A NumPy ndarray representing the values in this Series or Index . With arguments `**kwargs`, `copy`, `na_value`.", "question_id": 37180}
{"snippet": "Index.to_numpy(**kwargs, dtype=None, copy=False, na_value=NoDefault.no_default)", "intent": "A NumPy ndarray representing the values in this Series or Index . When self contains an ExtensionArray , the `dtype` may be different . With arguments `**kwargs`, `copy`, `na_value`.", "question_id": 37181}
{"snippet": "Index.to_numpy(**kwargs)", "intent": "A NumPy ndarray representing the values in this Series or Index . With arguments `**kwargs`.", "question_id": 37182}
{"snippet": "Index.to_numpy(**kwargs, dtype=None)", "intent": "A NumPy ndarray representing the values in this Series or Index . When self contains an ExtensionArray , the `dtype` may be different . With arguments `**kwargs`.", "question_id": 37183}
{"snippet": "Index.to_numpy(**kwargs, copy=False)", "intent": "A NumPy ndarray representing the values in this Series or Index . With arguments `**kwargs`, `copy`.", "question_id": 37184}
{"snippet": "Index.to_numpy(**kwargs, na_value=NoDefault.no_default)", "intent": "A NumPy ndarray representing the values in this Series or Index . With arguments `**kwargs`, `na_value`.", "question_id": 37185}
{"snippet": "Index.to_numpy(**kwargs, dtype=None, copy=False)", "intent": "A NumPy ndarray representing the values in this Series or Index . When self contains an ExtensionArray , the `dtype` may be different . With arguments `**kwargs`, `copy`.", "question_id": 37186}
{"snippet": "Index.to_numpy(**kwargs, dtype=None, na_value=NoDefault.no_default)", "intent": "A NumPy ndarray representing the values in this Series or Index . When self contains an ExtensionArray , the `dtype` may be different . With arguments `**kwargs`, `na_value`.", "question_id": 37187}
{"snippet": "Index.to_numpy(**kwargs, copy=False, na_value=NoDefault.no_default)", "intent": "A NumPy ndarray representing the values in this Series or Index . With arguments `**kwargs`, `copy`, `na_value`.", "question_id": 37188}
{"snippet": "Index.to_numpy(**kwargs, dtype=None, copy=False, na_value=NoDefault.no_default)", "intent": "A NumPy ndarray representing the values in this Series or Index . When self contains an ExtensionArray , the `dtype` may be different . With arguments `**kwargs`, `copy`, `na_value`.", "question_id": 37189}
{"snippet": "Index.to_series()", "intent": "Create a Series with both `index` and values equal to the index keys .", "question_id": 37190}
{"snippet": "Index.to_series(index=None)", "intent": "Create a Series with both `index` and values equal to the index keys .", "question_id": 37191}
{"snippet": "Index.to_series(name=None)", "intent": "Create a Series with both `index` and values equal to the index keys . By default , the original Index and original `name` is reused .", "question_id": 37192}
{"snippet": "Index.to_series(index=None, name=None)", "intent": "Create a Series with both `index` and values equal to the index keys . By default , the original Index and original `name` is reused .", "question_id": 37193}
{"snippet": "Index.to_series()", "intent": "Create a Series with both `index` and values equal to the index keys .", "question_id": 37194}
{"snippet": "Index.to_series(index=None)", "intent": "Create a Series with both `index` and values equal to the index keys .", "question_id": 37195}
{"snippet": "Index.to_series(name=None)", "intent": "Create a Series with both `index` and values equal to the index keys . By default , the original Index and original `name` is reused .", "question_id": 37196}
{"snippet": "Index.to_series(index=None, name=None)", "intent": "Create a Series with both `index` and values equal to the index keys . By default , the original Index and original `name` is reused .", "question_id": 37197}
{"snippet": "Index.to_series()", "intent": "Create a Series with both `index` and values equal to the index keys .", "question_id": 37198}
{"snippet": "Index.to_series(index=None)", "intent": "Create a Series with both `index` and values equal to the index keys .", "question_id": 37199}
{"snippet": "Index.to_series(name=None)", "intent": "Create a Series with both `index` and values equal to the index keys . By default , the original Index and original `name` is reused .", "question_id": 37200}
{"snippet": "Index.to_series(index=None, name=None)", "intent": "Create a Series with both `index` and values equal to the index keys . By default , the original Index and original `name` is reused .", "question_id": 37201}
{"snippet": "Index.tolist()", "intent": "Return a list of the values .", "question_id": 37202}
{"snippet": "Index.tolist()", "intent": "Return a list of the values .", "question_id": 37203}
{"snippet": "Index.tolist()", "intent": "Return a list of the values .", "question_id": 37204}
{"snippet": "Index.transpose(*args, **kwargs)", "intent": "Return the transpose , which is by definition self . With arguments `*args`, `**kwargs`.", "question_id": 37205}
{"snippet": "Index.transpose(*args, **kwargs)", "intent": "Return the transpose , which is by definition self . With arguments `*args`, `**kwargs`.", "question_id": 37206}
{"snippet": "Index.transpose(*args, **kwargs)", "intent": "Return the transpose , which is by definition self . With arguments `*args`, `**kwargs`.", "question_id": 37207}
{"snippet": "Index.union(other)", "intent": "Form the union of two Index objects . With arguments `other`.", "question_id": 37208}
{"snippet": "Index.union(other, sort=None)", "intent": "Form the union of two Index objects . With arguments `other`, `sort`.", "question_id": 37209}
{"snippet": "Index.union(other)", "intent": "Form the union of two Index objects . With arguments `other`.", "question_id": 37210}
{"snippet": "Index.union(other, sort=None)", "intent": "Form the union of two Index objects . With arguments `other`, `sort`.", "question_id": 37211}
{"snippet": "Index.union(other)", "intent": "Form the union of two Index objects . With arguments `other`.", "question_id": 37212}
{"snippet": "Index.union(other, sort=None)", "intent": "Form the union of two Index objects . With arguments `other`, `sort`.", "question_id": 37213}
{"snippet": "Index.unique()", "intent": "Return unique values in the index .", "question_id": 37214}
{"snippet": "Index.unique(level=None)", "intent": "Return unique values in the index . With arguments `level`.", "question_id": 37215}
{"snippet": "Index.unique()", "intent": "Return unique values in the index .", "question_id": 37216}
{"snippet": "Index.unique(level=None)", "intent": "Return unique values in the index . With arguments `level`.", "question_id": 37217}
{"snippet": "Index.unique()", "intent": "Return unique values in the index .", "question_id": 37218}
{"snippet": "Index.unique(level=None)", "intent": "Return unique values in the index . With arguments `level`.", "question_id": 37219}
{"snippet": "Index.value_counts()", "intent": "Return a Series containing counts of unique values .", "question_id": 37220}
{"snippet": "Index.value_counts(normalize=False)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values .", "question_id": 37221}
{"snippet": "Index.value_counts(sort=True)", "intent": "Return a Series containing counts of unique values . With arguments `sort`.", "question_id": 37222}
{"snippet": "Index.value_counts(ascending=False)", "intent": "Return a Series containing counts of unique values . With arguments `ascending`.", "question_id": 37223}
{"snippet": "Index.value_counts(bins=None)", "intent": "Return a Series containing counts of unique values . `bins`", "question_id": 37224}
{"snippet": "Index.value_counts(dropna=True)", "intent": "Return a Series containing counts of unique values . `dropna`", "question_id": 37225}
{"snippet": "Index.value_counts(normalize=False, sort=True)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values . With arguments `sort`.", "question_id": 37226}
{"snippet": "Index.value_counts(normalize=False, ascending=False)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values . With arguments `ascending`.", "question_id": 37227}
{"snippet": "Index.value_counts(normalize=False, bins=None)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values . `bins`", "question_id": 37228}
{"snippet": "Index.value_counts(normalize=False, dropna=True)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values . `dropna`", "question_id": 37229}
{"snippet": "Index.value_counts()", "intent": "Return a Series containing counts of unique values .", "question_id": 37230}
{"snippet": "Index.value_counts(normalize=False)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values .", "question_id": 37231}
{"snippet": "Index.value_counts(sort=True)", "intent": "Return a Series containing counts of unique values . With arguments `sort`.", "question_id": 37232}
{"snippet": "Index.value_counts(ascending=False)", "intent": "Return a Series containing counts of unique values . With arguments `ascending`.", "question_id": 37233}
{"snippet": "Index.value_counts(bins=None)", "intent": "Return a Series containing counts of unique values . `bins`", "question_id": 37234}
{"snippet": "Index.value_counts(dropna=True)", "intent": "Return a Series containing counts of unique values . `dropna`", "question_id": 37235}
{"snippet": "Index.value_counts(normalize=False, sort=True)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values . With arguments `sort`.", "question_id": 37236}
{"snippet": "Index.value_counts(normalize=False, ascending=False)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values . With arguments `ascending`.", "question_id": 37237}
{"snippet": "Index.value_counts(normalize=False, bins=None)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values . `bins`", "question_id": 37238}
{"snippet": "Index.value_counts(normalize=False, dropna=True)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values . `dropna`", "question_id": 37239}
{"snippet": "Index.value_counts()", "intent": "Return a Series containing counts of unique values .", "question_id": 37240}
{"snippet": "Index.value_counts(normalize=False)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values .", "question_id": 37241}
{"snippet": "Index.value_counts(sort=True)", "intent": "Return a Series containing counts of unique values . With arguments `sort`.", "question_id": 37242}
{"snippet": "Index.value_counts(ascending=False)", "intent": "Return a Series containing counts of unique values . With arguments `ascending`.", "question_id": 37243}
{"snippet": "Index.value_counts(bins=None)", "intent": "Return a Series containing counts of unique values . `bins`", "question_id": 37244}
{"snippet": "Index.value_counts(dropna=True)", "intent": "Return a Series containing counts of unique values . `dropna`", "question_id": 37245}
{"snippet": "Index.value_counts(normalize=False, sort=True)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values . With arguments `sort`.", "question_id": 37246}
{"snippet": "Index.value_counts(normalize=False, ascending=False)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values . With arguments `ascending`.", "question_id": 37247}
{"snippet": "Index.value_counts(normalize=False, bins=None)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values . `bins`", "question_id": 37248}
{"snippet": "Index.value_counts(normalize=False, dropna=True)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values . `dropna`", "question_id": 37249}
{"snippet": "Index.where(cond)", "intent": "Replace values where the condition is False . With arguments `cond`.", "question_id": 37250}
{"snippet": "Index.where(cond, other=None)", "intent": "Replace values where the condition is False . The replacement is taken from `other` . With arguments `cond`.", "question_id": 37251}
{"snippet": "Index.where(cond)", "intent": "Replace values where the condition is False . With arguments `cond`.", "question_id": 37252}
{"snippet": "Index.where(cond, other=None)", "intent": "Replace values where the condition is False . The replacement is taken from `other` . With arguments `cond`.", "question_id": 37253}
{"snippet": "Index.where(cond)", "intent": "Replace values where the condition is False . With arguments `cond`.", "question_id": 37254}
{"snippet": "Index.where(cond, other=None)", "intent": "Replace values where the condition is False . The replacement is taken from `other` . With arguments `cond`.", "question_id": 37255}
{"snippet": "pandas.IndexSlice", "intent": "Create an object to more easily perform multi-index slicing.", "question_id": 37256}
{"snippet": "pandas.IndexSlice", "intent": "Create an object to more easily perform multi-index slicing.", "question_id": 37257}
{"snippet": "pandas.IndexSlice", "intent": "Create an object to more easily perform multi-index slicing.", "question_id": 37258}
{"snippet": "pandas.Int16Dtype", "intent": "An ExtensionDtype for int16 integer data.", "question_id": 37259}
{"snippet": "pandas.Int16Dtype", "intent": "An ExtensionDtype for int16 integer data.", "question_id": 37260}
{"snippet": "pandas.Int16Dtype", "intent": "An ExtensionDtype for int16 integer data.", "question_id": 37261}
{"snippet": "pandas.Int32Dtype", "intent": "An ExtensionDtype for int32 integer data.", "question_id": 37262}
{"snippet": "pandas.Int32Dtype", "intent": "An ExtensionDtype for int32 integer data.", "question_id": 37263}
{"snippet": "pandas.Int32Dtype", "intent": "An ExtensionDtype for int32 integer data.", "question_id": 37264}
{"snippet": "pandas.Int64Dtype", "intent": "An ExtensionDtype for int64 integer data.", "question_id": 37265}
{"snippet": "pandas.Int64Dtype", "intent": "An ExtensionDtype for int64 integer data.", "question_id": 37266}
{"snippet": "pandas.Int64Dtype", "intent": "An ExtensionDtype for int64 integer data.", "question_id": 37267}
{"snippet": "pandas.Int64Index()", "intent": "Immutable sequence used for indexing and alignment .", "question_id": 37268}
{"snippet": "pandas.Int64Index(data=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`.", "question_id": 37269}
{"snippet": "pandas.Int64Index(dtype=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`.", "question_id": 37270}
{"snippet": "pandas.Int64Index(copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `copy`.", "question_id": 37271}
{"snippet": "pandas.Int64Index(name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `name`.", "question_id": 37272}
{"snippet": "pandas.Int64Index(data=None, dtype=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `dtype`.", "question_id": 37273}
{"snippet": "pandas.Int64Index(data=None, copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `copy`.", "question_id": 37274}
{"snippet": "pandas.Int64Index(data=None, name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `name`.", "question_id": 37275}
{"snippet": "pandas.Int64Index(dtype=None, copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`, `copy`.", "question_id": 37276}
{"snippet": "pandas.Int64Index(dtype=None, name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`, `name`.", "question_id": 37277}
{"snippet": "pandas.Int64Index()", "intent": "Immutable sequence used for indexing and alignment .", "question_id": 37278}
{"snippet": "pandas.Int64Index(data=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`.", "question_id": 37279}
{"snippet": "pandas.Int64Index(dtype=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`.", "question_id": 37280}
{"snippet": "pandas.Int64Index(copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `copy`.", "question_id": 37281}
{"snippet": "pandas.Int64Index(name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `name`.", "question_id": 37282}
{"snippet": "pandas.Int64Index(data=None, dtype=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `dtype`.", "question_id": 37283}
{"snippet": "pandas.Int64Index(data=None, copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `copy`.", "question_id": 37284}
{"snippet": "pandas.Int64Index(data=None, name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `name`.", "question_id": 37285}
{"snippet": "pandas.Int64Index(dtype=None, copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`, `copy`.", "question_id": 37286}
{"snippet": "pandas.Int64Index(dtype=None, name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`, `name`.", "question_id": 37287}
{"snippet": "pandas.Int64Index()", "intent": "Immutable sequence used for indexing and alignment .", "question_id": 37288}
{"snippet": "pandas.Int64Index(data=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`.", "question_id": 37289}
{"snippet": "pandas.Int64Index(dtype=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`.", "question_id": 37290}
{"snippet": "pandas.Int64Index(copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `copy`.", "question_id": 37291}
{"snippet": "pandas.Int64Index(name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `name`.", "question_id": 37292}
{"snippet": "pandas.Int64Index(data=None, dtype=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `dtype`.", "question_id": 37293}
{"snippet": "pandas.Int64Index(data=None, copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `copy`.", "question_id": 37294}
{"snippet": "pandas.Int64Index(data=None, name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `name`.", "question_id": 37295}
{"snippet": "pandas.Int64Index(dtype=None, copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`, `copy`.", "question_id": 37296}
{"snippet": "pandas.Int64Index(dtype=None, name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`, `name`.", "question_id": 37297}
{"snippet": "pandas.Int8Dtype", "intent": "An ExtensionDtype for int8 integer data.", "question_id": 37298}
{"snippet": "pandas.Int8Dtype", "intent": "An ExtensionDtype for int8 integer data.", "question_id": 37299}
{"snippet": "pandas.Int8Dtype", "intent": "An ExtensionDtype for int8 integer data.", "question_id": 37300}
{"snippet": "Interval.closed", "intent": "Whether the interval is closed on the left-side, right-side, both or neither.", "question_id": 37301}
{"snippet": "Interval.closed", "intent": "Whether the interval is closed on the left-side, right-side, both or neither.", "question_id": 37302}
{"snippet": "Interval.closed", "intent": "Whether the interval is closed on the left-side, right-side, both or neither.", "question_id": 37303}
{"snippet": "Interval.closed_left", "intent": "Check if the interval is closed on the left side.", "question_id": 37304}
{"snippet": "Interval.closed_left", "intent": "Check if the interval is closed on the left side.", "question_id": 37305}
{"snippet": "Interval.closed_left", "intent": "Check if the interval is closed on the left side.", "question_id": 37306}
{"snippet": "Interval.closed_right", "intent": "Check if the interval is closed on the right side.", "question_id": 37307}
{"snippet": "Interval.closed_right", "intent": "Check if the interval is closed on the right side.", "question_id": 37308}
{"snippet": "Interval.closed_right", "intent": "Check if the interval is closed on the right side.", "question_id": 37309}
{"snippet": "pandas.Interval", "intent": "Immutable object implementing an Interval, a bounded slice-like interval.", "question_id": 37310}
{"snippet": "pandas.Interval", "intent": "Immutable object implementing an Interval, a bounded slice-like interval.", "question_id": 37311}
{"snippet": "pandas.Interval", "intent": "Immutable object implementing an Interval, a bounded slice-like interval.", "question_id": 37312}
{"snippet": "Interval.is_empty", "intent": "Indicates if an interval is empty, meaning it contains no points.", "question_id": 37313}
{"snippet": "Interval.is_empty", "intent": "Indicates if an interval is empty, meaning it contains no points.", "question_id": 37314}
{"snippet": "Interval.is_empty", "intent": "Indicates if an interval is empty, meaning it contains no points.", "question_id": 37315}
{"snippet": "Interval.left", "intent": "Left bound for the interval.", "question_id": 37316}
{"snippet": "Interval.left", "intent": "Left bound for the interval.", "question_id": 37317}
{"snippet": "Interval.left", "intent": "Left bound for the interval.", "question_id": 37318}
{"snippet": "Interval.length", "intent": "Return the length of the Interval.", "question_id": 37319}
{"snippet": "Interval.length", "intent": "Return the length of the Interval.", "question_id": 37320}
{"snippet": "Interval.length", "intent": "Return the length of the Interval.", "question_id": 37321}
{"snippet": "Interval.mid", "intent": "Return the midpoint of the Interval.", "question_id": 37322}
{"snippet": "Interval.mid", "intent": "Return the midpoint of the Interval.", "question_id": 37323}
{"snippet": "Interval.mid", "intent": "Return the midpoint of the Interval.", "question_id": 37324}
{"snippet": "Interval.open_left", "intent": "Check if the interval is open on the left side.", "question_id": 37325}
{"snippet": "Interval.open_left", "intent": "Check if the interval is open on the left side.", "question_id": 37326}
{"snippet": "Interval.open_left", "intent": "Check if the interval is open on the left side.", "question_id": 37327}
{"snippet": "Interval.open_right", "intent": "Check if the interval is open on the right side.", "question_id": 37328}
{"snippet": "Interval.open_right", "intent": "Check if the interval is open on the right side.", "question_id": 37329}
{"snippet": "Interval.open_right", "intent": "Check if the interval is open on the right side.", "question_id": 37330}
{"snippet": "Interval.overlaps()", "intent": "Check whether two Interval objects overlap .", "question_id": 37331}
{"snippet": "Interval.overlaps()", "intent": "Check whether two Interval objects overlap .", "question_id": 37332}
{"snippet": "Interval.overlaps()", "intent": "Check whether two Interval objects overlap .", "question_id": 37333}
{"snippet": "Interval.right", "intent": "Right bound for the interval.", "question_id": 37334}
{"snippet": "Interval.right", "intent": "Right bound for the interval.", "question_id": 37335}
{"snippet": "Interval.right", "intent": "Right bound for the interval.", "question_id": 37336}
{"snippet": "pandas.IntervalDtype()", "intent": "An ExtensionDtype for Interval data .", "question_id": 37337}
{"snippet": "pandas.IntervalDtype(subtype=None)", "intent": "An ExtensionDtype for Interval data . With arguments `subtype`.", "question_id": 37338}
{"snippet": "pandas.IntervalDtype(closed=None)", "intent": "An ExtensionDtype for Interval data . With arguments `closed`.", "question_id": 37339}
{"snippet": "pandas.IntervalDtype(subtype=None, closed=None)", "intent": "An ExtensionDtype for Interval data . With arguments `subtype`, `closed`.", "question_id": 37340}
{"snippet": "pandas.IntervalDtype()", "intent": "An ExtensionDtype for Interval data .", "question_id": 37341}
{"snippet": "pandas.IntervalDtype(subtype=None)", "intent": "An ExtensionDtype for Interval data . With arguments `subtype`.", "question_id": 37342}
{"snippet": "pandas.IntervalDtype(closed=None)", "intent": "An ExtensionDtype for Interval data . With arguments `closed`.", "question_id": 37343}
{"snippet": "pandas.IntervalDtype(subtype=None, closed=None)", "intent": "An ExtensionDtype for Interval data . With arguments `subtype`, `closed`.", "question_id": 37344}
{"snippet": "pandas.IntervalDtype()", "intent": "An ExtensionDtype for Interval data .", "question_id": 37345}
{"snippet": "pandas.IntervalDtype(subtype=None)", "intent": "An ExtensionDtype for Interval data . With arguments `subtype`.", "question_id": 37346}
{"snippet": "pandas.IntervalDtype(closed=None)", "intent": "An ExtensionDtype for Interval data . With arguments `closed`.", "question_id": 37347}
{"snippet": "pandas.IntervalDtype(subtype=None, closed=None)", "intent": "An ExtensionDtype for Interval data . With arguments `subtype`, `closed`.", "question_id": 37348}
{"snippet": "IntervalIndex.closed", "intent": "Whether the intervals are closed on the left-side, right-side, both or neither.", "question_id": 37349}
{"snippet": "IntervalIndex.closed", "intent": "Whether the intervals are closed on the left-side, right-side, both or neither.", "question_id": 37350}
{"snippet": "IntervalIndex.closed", "intent": "Whether the intervals are closed on the left-side, right-side, both or neither.", "question_id": 37351}
{"snippet": "IntervalIndex.contains(*args, **kwargs)", "intent": "Check elementwise if the Intervals contain the value . With arguments `*args`, `**kwargs`.", "question_id": 37352}
{"snippet": "IntervalIndex.contains(*args, **kwargs)", "intent": "Check elementwise if the Intervals contain the value . With arguments `*args`, `**kwargs`.", "question_id": 37353}
{"snippet": "IntervalIndex.contains(*args, **kwargs)", "intent": "Check elementwise if the Intervals contain the value . With arguments `*args`, `**kwargs`.", "question_id": 37354}
{"snippet": "IntervalIndex.from_arrays(left, right)", "intent": "Construct from two arrays defining the `left` and `right` bounds .", "question_id": 37355}
{"snippet": "IntervalIndex.from_arrays(left, right, closed='right')", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `closed`.", "question_id": 37356}
{"snippet": "IntervalIndex.from_arrays(left, right, name=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `name`.", "question_id": 37357}
{"snippet": "IntervalIndex.from_arrays(left, right, copy=False)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `copy`.", "question_id": 37358}
{"snippet": "IntervalIndex.from_arrays(left, right, dtype=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `dtype`.", "question_id": 37359}
{"snippet": "IntervalIndex.from_arrays(left, right, closed='right', name=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `closed`, `name`.", "question_id": 37360}
{"snippet": "IntervalIndex.from_arrays(left, right, closed='right', copy=False)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `closed`, `copy`.", "question_id": 37361}
{"snippet": "IntervalIndex.from_arrays(left, right, closed='right', dtype=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `closed`, `dtype`.", "question_id": 37362}
{"snippet": "IntervalIndex.from_arrays(left, right, name=None, copy=False)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `name`, `copy`.", "question_id": 37363}
{"snippet": "IntervalIndex.from_arrays(left, right, name=None, dtype=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `name`, `dtype`.", "question_id": 37364}
{"snippet": "IntervalIndex.from_arrays(left, right)", "intent": "Construct from two arrays defining the `left` and `right` bounds .", "question_id": 37365}
{"snippet": "IntervalIndex.from_arrays(left, right, closed='right')", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `closed`.", "question_id": 37366}
{"snippet": "IntervalIndex.from_arrays(left, right, name=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `name`.", "question_id": 37367}
{"snippet": "IntervalIndex.from_arrays(left, right, copy=False)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `copy`.", "question_id": 37368}
{"snippet": "IntervalIndex.from_arrays(left, right, dtype=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `dtype`.", "question_id": 37369}
{"snippet": "IntervalIndex.from_arrays(left, right, closed='right', name=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `closed`, `name`.", "question_id": 37370}
{"snippet": "IntervalIndex.from_arrays(left, right, closed='right', copy=False)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `closed`, `copy`.", "question_id": 37371}
{"snippet": "IntervalIndex.from_arrays(left, right, closed='right', dtype=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `closed`, `dtype`.", "question_id": 37372}
{"snippet": "IntervalIndex.from_arrays(left, right, name=None, copy=False)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `name`, `copy`.", "question_id": 37373}
{"snippet": "IntervalIndex.from_arrays(left, right, name=None, dtype=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `name`, `dtype`.", "question_id": 37374}
{"snippet": "IntervalIndex.from_arrays(left, right)", "intent": "Construct from two arrays defining the `left` and `right` bounds .", "question_id": 37375}
{"snippet": "IntervalIndex.from_arrays(left, right, closed='right')", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `closed`.", "question_id": 37376}
{"snippet": "IntervalIndex.from_arrays(left, right, name=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `name`.", "question_id": 37377}
{"snippet": "IntervalIndex.from_arrays(left, right, copy=False)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `copy`.", "question_id": 37378}
{"snippet": "IntervalIndex.from_arrays(left, right, dtype=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `dtype`.", "question_id": 37379}
{"snippet": "IntervalIndex.from_arrays(left, right, closed='right', name=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `closed`, `name`.", "question_id": 37380}
{"snippet": "IntervalIndex.from_arrays(left, right, closed='right', copy=False)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `closed`, `copy`.", "question_id": 37381}
{"snippet": "IntervalIndex.from_arrays(left, right, closed='right', dtype=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `closed`, `dtype`.", "question_id": 37382}
{"snippet": "IntervalIndex.from_arrays(left, right, name=None, copy=False)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `name`, `copy`.", "question_id": 37383}
{"snippet": "IntervalIndex.from_arrays(left, right, name=None, dtype=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `name`, `dtype`.", "question_id": 37384}
{"snippet": "IntervalIndex.from_breaks(breaks)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`.", "question_id": 37385}
{"snippet": "IntervalIndex.from_breaks(breaks, closed='right')", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `closed`.", "question_id": 37386}
{"snippet": "IntervalIndex.from_breaks(breaks, name=None)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `name`.", "question_id": 37387}
{"snippet": "IntervalIndex.from_breaks(breaks, copy=False)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `copy`.", "question_id": 37388}
{"snippet": "IntervalIndex.from_breaks(breaks, dtype=None)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `dtype`.", "question_id": 37389}
{"snippet": "IntervalIndex.from_breaks(breaks, closed='right', name=None)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `closed`, `name`.", "question_id": 37390}
{"snippet": "IntervalIndex.from_breaks(breaks, closed='right', copy=False)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `closed`, `copy`.", "question_id": 37391}
{"snippet": "IntervalIndex.from_breaks(breaks, closed='right', dtype=None)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `closed`, `dtype`.", "question_id": 37392}
{"snippet": "IntervalIndex.from_breaks(breaks, name=None, copy=False)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `name`, `copy`.", "question_id": 37393}
{"snippet": "IntervalIndex.from_breaks(breaks, name=None, dtype=None)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `name`, `dtype`.", "question_id": 37394}
{"snippet": "IntervalIndex.from_breaks(breaks)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`.", "question_id": 37395}
{"snippet": "IntervalIndex.from_breaks(breaks, closed='right')", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `closed`.", "question_id": 37396}
{"snippet": "IntervalIndex.from_breaks(breaks, name=None)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `name`.", "question_id": 37397}
{"snippet": "IntervalIndex.from_breaks(breaks, copy=False)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `copy`.", "question_id": 37398}
{"snippet": "IntervalIndex.from_breaks(breaks, dtype=None)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `dtype`.", "question_id": 37399}
{"snippet": "IntervalIndex.from_breaks(breaks, closed='right', name=None)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `closed`, `name`.", "question_id": 37400}
{"snippet": "IntervalIndex.from_breaks(breaks, closed='right', copy=False)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `closed`, `copy`.", "question_id": 37401}
{"snippet": "IntervalIndex.from_breaks(breaks, closed='right', dtype=None)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `closed`, `dtype`.", "question_id": 37402}
{"snippet": "IntervalIndex.from_breaks(breaks, name=None, copy=False)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `name`, `copy`.", "question_id": 37403}
{"snippet": "IntervalIndex.from_breaks(breaks, name=None, dtype=None)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `name`, `dtype`.", "question_id": 37404}
{"snippet": "IntervalIndex.from_breaks(breaks)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`.", "question_id": 37405}
{"snippet": "IntervalIndex.from_breaks(breaks, closed='right')", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `closed`.", "question_id": 37406}
{"snippet": "IntervalIndex.from_breaks(breaks, name=None)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `name`.", "question_id": 37407}
{"snippet": "IntervalIndex.from_breaks(breaks, copy=False)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `copy`.", "question_id": 37408}
{"snippet": "IntervalIndex.from_breaks(breaks, dtype=None)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `dtype`.", "question_id": 37409}
{"snippet": "IntervalIndex.from_breaks(breaks, closed='right', name=None)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `closed`, `name`.", "question_id": 37410}
{"snippet": "IntervalIndex.from_breaks(breaks, closed='right', copy=False)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `closed`, `copy`.", "question_id": 37411}
{"snippet": "IntervalIndex.from_breaks(breaks, closed='right', dtype=None)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `closed`, `dtype`.", "question_id": 37412}
{"snippet": "IntervalIndex.from_breaks(breaks, name=None, copy=False)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `name`, `copy`.", "question_id": 37413}
{"snippet": "IntervalIndex.from_breaks(breaks, name=None, dtype=None)", "intent": "Construct an IntervalIndex from an array of splits . With arguments `breaks`, `name`, `dtype`.", "question_id": 37414}
{"snippet": "IntervalIndex.from_tuples(data)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`.", "question_id": 37415}
{"snippet": "IntervalIndex.from_tuples(data, closed='right')", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `closed`.", "question_id": 37416}
{"snippet": "IntervalIndex.from_tuples(data, name=None)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `name`.", "question_id": 37417}
{"snippet": "IntervalIndex.from_tuples(data, copy=False)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `copy`.", "question_id": 37418}
{"snippet": "IntervalIndex.from_tuples(data, dtype=None)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `dtype`.", "question_id": 37419}
{"snippet": "IntervalIndex.from_tuples(data, closed='right', name=None)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `closed`, `name`.", "question_id": 37420}
{"snippet": "IntervalIndex.from_tuples(data, closed='right', copy=False)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `closed`, `copy`.", "question_id": 37421}
{"snippet": "IntervalIndex.from_tuples(data, closed='right', dtype=None)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `closed`, `dtype`.", "question_id": 37422}
{"snippet": "IntervalIndex.from_tuples(data, name=None, copy=False)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `name`, `copy`.", "question_id": 37423}
{"snippet": "IntervalIndex.from_tuples(data, name=None, dtype=None)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `name`, `dtype`.", "question_id": 37424}
{"snippet": "IntervalIndex.from_tuples(data)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`.", "question_id": 37425}
{"snippet": "IntervalIndex.from_tuples(data, closed='right')", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `closed`.", "question_id": 37426}
{"snippet": "IntervalIndex.from_tuples(data, name=None)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `name`.", "question_id": 37427}
{"snippet": "IntervalIndex.from_tuples(data, copy=False)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `copy`.", "question_id": 37428}
{"snippet": "IntervalIndex.from_tuples(data, dtype=None)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `dtype`.", "question_id": 37429}
{"snippet": "IntervalIndex.from_tuples(data, closed='right', name=None)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `closed`, `name`.", "question_id": 37430}
{"snippet": "IntervalIndex.from_tuples(data, closed='right', copy=False)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `closed`, `copy`.", "question_id": 37431}
{"snippet": "IntervalIndex.from_tuples(data, closed='right', dtype=None)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `closed`, `dtype`.", "question_id": 37432}
{"snippet": "IntervalIndex.from_tuples(data, name=None, copy=False)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `name`, `copy`.", "question_id": 37433}
{"snippet": "IntervalIndex.from_tuples(data, name=None, dtype=None)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `name`, `dtype`.", "question_id": 37434}
{"snippet": "IntervalIndex.from_tuples(data)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`.", "question_id": 37435}
{"snippet": "IntervalIndex.from_tuples(data, closed='right')", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `closed`.", "question_id": 37436}
{"snippet": "IntervalIndex.from_tuples(data, name=None)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `name`.", "question_id": 37437}
{"snippet": "IntervalIndex.from_tuples(data, copy=False)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `copy`.", "question_id": 37438}
{"snippet": "IntervalIndex.from_tuples(data, dtype=None)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `dtype`.", "question_id": 37439}
{"snippet": "IntervalIndex.from_tuples(data, closed='right', name=None)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `closed`, `name`.", "question_id": 37440}
{"snippet": "IntervalIndex.from_tuples(data, closed='right', copy=False)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `closed`, `copy`.", "question_id": 37441}
{"snippet": "IntervalIndex.from_tuples(data, closed='right', dtype=None)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `closed`, `dtype`.", "question_id": 37442}
{"snippet": "IntervalIndex.from_tuples(data, name=None, copy=False)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `name`, `copy`.", "question_id": 37443}
{"snippet": "IntervalIndex.from_tuples(data, name=None, dtype=None)", "intent": "Construct an IntervalIndex from an array-like of tuples . With arguments `data`, `name`, `dtype`.", "question_id": 37444}
{"snippet": "IntervalIndex.get_indexer(target)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`.", "question_id": 37445}
{"snippet": "IntervalIndex.get_indexer(target, method=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`.", "question_id": 37446}
{"snippet": "IntervalIndex.get_indexer(target, limit=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `limit`.", "question_id": 37447}
{"snippet": "IntervalIndex.get_indexer(target, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `tolerance`.", "question_id": 37448}
{"snippet": "IntervalIndex.get_indexer(target, method=None, limit=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `limit`.", "question_id": 37449}
{"snippet": "IntervalIndex.get_indexer(target, method=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `tolerance`.", "question_id": 37450}
{"snippet": "IntervalIndex.get_indexer(target, limit=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `limit`, `tolerance`.", "question_id": 37451}
{"snippet": "IntervalIndex.get_indexer(target, method=None, limit=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `limit`, `tolerance`.", "question_id": 37452}
{"snippet": "IntervalIndex.get_indexer(target)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`.", "question_id": 37453}
{"snippet": "IntervalIndex.get_indexer(target, method=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`.", "question_id": 37454}
{"snippet": "IntervalIndex.get_indexer(target, limit=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `limit`.", "question_id": 37455}
{"snippet": "IntervalIndex.get_indexer(target, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `tolerance`.", "question_id": 37456}
{"snippet": "IntervalIndex.get_indexer(target, method=None, limit=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `limit`.", "question_id": 37457}
{"snippet": "IntervalIndex.get_indexer(target, method=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `tolerance`.", "question_id": 37458}
{"snippet": "IntervalIndex.get_indexer(target, limit=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `limit`, `tolerance`.", "question_id": 37459}
{"snippet": "IntervalIndex.get_indexer(target, method=None, limit=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `limit`, `tolerance`.", "question_id": 37460}
{"snippet": "IntervalIndex.get_indexer(target)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`.", "question_id": 37461}
{"snippet": "IntervalIndex.get_indexer(target, method=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`.", "question_id": 37462}
{"snippet": "IntervalIndex.get_indexer(target, limit=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `limit`.", "question_id": 37463}
{"snippet": "IntervalIndex.get_indexer(target, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `tolerance`.", "question_id": 37464}
{"snippet": "IntervalIndex.get_indexer(target, method=None, limit=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `limit`.", "question_id": 37465}
{"snippet": "IntervalIndex.get_indexer(target, method=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `tolerance`.", "question_id": 37466}
{"snippet": "IntervalIndex.get_indexer(target, limit=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `limit`, `tolerance`.", "question_id": 37467}
{"snippet": "IntervalIndex.get_indexer(target, method=None, limit=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `limit`, `tolerance`.", "question_id": 37468}
{"snippet": "IntervalIndex.get_loc(key)", "intent": "Get integer location , slice or boolean mask for requested label . With arguments `key`.", "question_id": 37469}
{"snippet": "IntervalIndex.get_loc(key, method=None)", "intent": "Get integer location , slice or boolean mask for requested label . With arguments `key`, `method`.", "question_id": 37470}
{"snippet": "IntervalIndex.get_loc(key, tolerance=None)", "intent": "Get integer location , slice or boolean mask for requested label . With arguments `key`, `tolerance`.", "question_id": 37471}
{"snippet": "IntervalIndex.get_loc(key, method=None, tolerance=None)", "intent": "Get integer location , slice or boolean mask for requested label . With arguments `key`, `method`, `tolerance`.", "question_id": 37472}
{"snippet": "IntervalIndex.get_loc(key)", "intent": "Get integer location , slice or boolean mask for requested label . With arguments `key`.", "question_id": 37473}
{"snippet": "IntervalIndex.get_loc(key, method=None)", "intent": "Get integer location , slice or boolean mask for requested label . With arguments `key`, `method`.", "question_id": 37474}
{"snippet": "IntervalIndex.get_loc(key, tolerance=None)", "intent": "Get integer location , slice or boolean mask for requested label . With arguments `key`, `tolerance`.", "question_id": 37475}
{"snippet": "IntervalIndex.get_loc(key, method=None, tolerance=None)", "intent": "Get integer location , slice or boolean mask for requested label . With arguments `key`, `method`, `tolerance`.", "question_id": 37476}
{"snippet": "IntervalIndex.get_loc(key)", "intent": "Get integer location , slice or boolean mask for requested label . With arguments `key`.", "question_id": 37477}
{"snippet": "IntervalIndex.get_loc(key, method=None)", "intent": "Get integer location , slice or boolean mask for requested label . With arguments `key`, `method`.", "question_id": 37478}
{"snippet": "IntervalIndex.get_loc(key, tolerance=None)", "intent": "Get integer location , slice or boolean mask for requested label . With arguments `key`, `tolerance`.", "question_id": 37479}
{"snippet": "IntervalIndex.get_loc(key, method=None, tolerance=None)", "intent": "Get integer location , slice or boolean mask for requested label . With arguments `key`, `method`, `tolerance`.", "question_id": 37480}
{"snippet": "pandas.IntervalIndex(data)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`.", "question_id": 37481}
{"snippet": "pandas.IntervalIndex(data, closed=None)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`.", "question_id": 37482}
{"snippet": "pandas.IntervalIndex(data, dtype=None)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`, `dtype`.", "question_id": 37483}
{"snippet": "pandas.IntervalIndex(data, copy=False)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`, `copy`.", "question_id": 37484}
{"snippet": "pandas.IntervalIndex(data, name=None)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`, `name`.", "question_id": 37485}
{"snippet": "pandas.IntervalIndex(data, verify_integrity=True)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`, `verify_integrity`.", "question_id": 37486}
{"snippet": "pandas.IntervalIndex(data, closed=None, dtype=None)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`, `dtype`.", "question_id": 37487}
{"snippet": "pandas.IntervalIndex(data, closed=None, copy=False)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`, `copy`.", "question_id": 37488}
{"snippet": "pandas.IntervalIndex(data, closed=None, name=None)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`, `name`.", "question_id": 37489}
{"snippet": "pandas.IntervalIndex(data, closed=None, verify_integrity=True)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`, `verify_integrity`.", "question_id": 37490}
{"snippet": "pandas.IntervalIndex(data)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`.", "question_id": 37491}
{"snippet": "pandas.IntervalIndex(data, closed=None)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`.", "question_id": 37492}
{"snippet": "pandas.IntervalIndex(data, dtype=None)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`, `dtype`.", "question_id": 37493}
{"snippet": "pandas.IntervalIndex(data, copy=False)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`, `copy`.", "question_id": 37494}
{"snippet": "pandas.IntervalIndex(data, name=None)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`, `name`.", "question_id": 37495}
{"snippet": "pandas.IntervalIndex(data, verify_integrity=True)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`, `verify_integrity`.", "question_id": 37496}
{"snippet": "pandas.IntervalIndex(data, closed=None, dtype=None)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`, `dtype`.", "question_id": 37497}
{"snippet": "pandas.IntervalIndex(data, closed=None, copy=False)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`, `copy`.", "question_id": 37498}
{"snippet": "pandas.IntervalIndex(data, closed=None, name=None)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`, `name`.", "question_id": 37499}
{"snippet": "pandas.IntervalIndex(data, closed=None, verify_integrity=True)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`, `verify_integrity`.", "question_id": 37500}
{"snippet": "pandas.IntervalIndex(data)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`.", "question_id": 37501}
{"snippet": "pandas.IntervalIndex(data, closed=None)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`.", "question_id": 37502}
{"snippet": "pandas.IntervalIndex(data, dtype=None)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`, `dtype`.", "question_id": 37503}
{"snippet": "pandas.IntervalIndex(data, copy=False)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`, `copy`.", "question_id": 37504}
{"snippet": "pandas.IntervalIndex(data, name=None)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`, `name`.", "question_id": 37505}
{"snippet": "pandas.IntervalIndex(data, verify_integrity=True)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`, `verify_integrity`.", "question_id": 37506}
{"snippet": "pandas.IntervalIndex(data, closed=None, dtype=None)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`, `dtype`.", "question_id": 37507}
{"snippet": "pandas.IntervalIndex(data, closed=None, copy=False)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`, `copy`.", "question_id": 37508}
{"snippet": "pandas.IntervalIndex(data, closed=None, name=None)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`, `name`.", "question_id": 37509}
{"snippet": "pandas.IntervalIndex(data, closed=None, verify_integrity=True)", "intent": "Immutable index of intervals that are `closed` on the same side . With arguments `data`, `verify_integrity`.", "question_id": 37510}
{"snippet": "IntervalIndex.is_non_overlapping_monotonic", "intent": "Return True if the IntervalArray is non-overlapping (no Intervals share points) and is either monotonic increasing or monotonic decreasing, else False.", "question_id": 37511}
{"snippet": "IntervalIndex.is_non_overlapping_monotonic", "intent": "Return True if the IntervalArray is non-overlapping (no Intervals share points) and is either monotonic increasing or monotonic decreasing, else False.", "question_id": 37512}
{"snippet": "IntervalIndex.is_non_overlapping_monotonic", "intent": "Return True if the IntervalArray is non-overlapping (no Intervals share points) and is either monotonic increasing or monotonic decreasing, else False.", "question_id": 37513}
{"snippet": "IntervalIndex.overlaps(*args, **kwargs)", "intent": "Check elementwise if an Interval overlaps the values in the IntervalArray . With arguments `*args`, `**kwargs`.", "question_id": 37514}
{"snippet": "IntervalIndex.overlaps(*args, **kwargs)", "intent": "Check elementwise if an Interval overlaps the values in the IntervalArray . With arguments `*args`, `**kwargs`.", "question_id": 37515}
{"snippet": "IntervalIndex.overlaps(*args, **kwargs)", "intent": "Check elementwise if an Interval overlaps the values in the IntervalArray . With arguments `*args`, `**kwargs`.", "question_id": 37516}
{"snippet": "IntervalIndex.set_closed(*args, **kwargs)", "intent": "Return an IntervalArray identical to the current one , but closed on the specified side . With arguments `*args`, `**kwargs`.", "question_id": 37517}
{"snippet": "IntervalIndex.set_closed(*args, **kwargs)", "intent": "Return an IntervalArray identical to the current one , but closed on the specified side . With arguments `*args`, `**kwargs`.", "question_id": 37518}
{"snippet": "IntervalIndex.set_closed(*args, **kwargs)", "intent": "Return an IntervalArray identical to the current one , but closed on the specified side . With arguments `*args`, `**kwargs`.", "question_id": 37519}
{"snippet": "IntervalIndex.to_tuples(*args, **kwargs)", "intent": "Return an ndarray of tuples of the form ( left , right ) . With arguments `*args`, `**kwargs`.", "question_id": 37520}
{"snippet": "IntervalIndex.to_tuples(*args, **kwargs)", "intent": "Return an ndarray of tuples of the form ( left , right ) . With arguments `*args`, `**kwargs`.", "question_id": 37521}
{"snippet": "IntervalIndex.to_tuples(*args, **kwargs)", "intent": "Return an ndarray of tuples of the form ( left , right ) . With arguments `*args`, `**kwargs`.", "question_id": 37522}
{"snippet": "MultiIndex.droplevel()", "intent": "Return index with requested `level` ( s ) removed .", "question_id": 37523}
{"snippet": "MultiIndex.droplevel(level=0)", "intent": "Return index with requested `level` ( s ) removed .", "question_id": 37524}
{"snippet": "MultiIndex.droplevel()", "intent": "Return index with requested `level` ( s ) removed .", "question_id": 37525}
{"snippet": "MultiIndex.droplevel(level=0)", "intent": "Return index with requested `level` ( s ) removed .", "question_id": 37526}
{"snippet": "MultiIndex.droplevel()", "intent": "Return index with requested `level` ( s ) removed .", "question_id": 37527}
{"snippet": "MultiIndex.droplevel(level=0)", "intent": "Return index with requested `level` ( s ) removed .", "question_id": 37528}
{"snippet": "MultiIndex.dtypes", "intent": "Return the dtypes as a Series for the underlying MultiIndex", "question_id": 37529}
{"snippet": "MultiIndex.dtypes", "intent": "Return the dtypes as a Series for the underlying MultiIndex", "question_id": 37530}
{"snippet": "MultiIndex.dtypes", "intent": "Return the dtypes as a Series for the underlying MultiIndex", "question_id": 37531}
{"snippet": "MultiIndex.from_arrays(arrays)", "intent": "Convert `arrays` to MultiIndex .", "question_id": 37532}
{"snippet": "MultiIndex.from_arrays(arrays, sortorder=None)", "intent": "Convert `arrays` to MultiIndex . With arguments `sortorder`.", "question_id": 37533}
{"snippet": "MultiIndex.from_arrays(arrays, names=NoDefault.no_default)", "intent": "Convert `arrays` to MultiIndex . With arguments `names`.", "question_id": 37534}
{"snippet": "MultiIndex.from_arrays(arrays, sortorder=None, names=NoDefault.no_default)", "intent": "Convert `arrays` to MultiIndex . With arguments `sortorder`, `names`.", "question_id": 37535}
{"snippet": "MultiIndex.from_arrays(arrays)", "intent": "Convert `arrays` to MultiIndex .", "question_id": 37536}
{"snippet": "MultiIndex.from_arrays(arrays, sortorder=None)", "intent": "Convert `arrays` to MultiIndex . With arguments `sortorder`.", "question_id": 37537}
{"snippet": "MultiIndex.from_arrays(arrays, names=NoDefault.no_default)", "intent": "Convert `arrays` to MultiIndex . With arguments `names`.", "question_id": 37538}
{"snippet": "MultiIndex.from_arrays(arrays, sortorder=None, names=NoDefault.no_default)", "intent": "Convert `arrays` to MultiIndex . With arguments `sortorder`, `names`.", "question_id": 37539}
{"snippet": "MultiIndex.from_arrays(arrays)", "intent": "Convert `arrays` to MultiIndex .", "question_id": 37540}
{"snippet": "MultiIndex.from_arrays(arrays, sortorder=None)", "intent": "Convert `arrays` to MultiIndex . With arguments `sortorder`.", "question_id": 37541}
{"snippet": "MultiIndex.from_arrays(arrays, names=NoDefault.no_default)", "intent": "Convert `arrays` to MultiIndex . With arguments `names`.", "question_id": 37542}
{"snippet": "MultiIndex.from_arrays(arrays, sortorder=None, names=NoDefault.no_default)", "intent": "Convert `arrays` to MultiIndex . With arguments `sortorder`, `names`.", "question_id": 37543}
{"snippet": "MultiIndex.from_frame(df)", "intent": "Make a MultiIndex from a DataFrame . With arguments `df`.", "question_id": 37544}
{"snippet": "MultiIndex.from_frame(df, sortorder=None)", "intent": "Make a MultiIndex from a DataFrame . With arguments `df`, `sortorder`.", "question_id": 37545}
{"snippet": "MultiIndex.from_frame(df, names=None)", "intent": "Make a MultiIndex from a DataFrame . Using explicit `names` , instead of the column names With arguments `df`.", "question_id": 37546}
{"snippet": "MultiIndex.from_frame(df, sortorder=None, names=None)", "intent": "Make a MultiIndex from a DataFrame . Using explicit `names` , instead of the column names With arguments `df`, `sortorder`.", "question_id": 37547}
{"snippet": "MultiIndex.from_frame(df)", "intent": "Make a MultiIndex from a DataFrame . With arguments `df`.", "question_id": 37548}
{"snippet": "MultiIndex.from_frame(df, sortorder=None)", "intent": "Make a MultiIndex from a DataFrame . With arguments `df`, `sortorder`.", "question_id": 37549}
{"snippet": "MultiIndex.from_frame(df, names=None)", "intent": "Make a MultiIndex from a DataFrame . Using explicit `names` , instead of the column names With arguments `df`.", "question_id": 37550}
{"snippet": "MultiIndex.from_frame(df, sortorder=None, names=None)", "intent": "Make a MultiIndex from a DataFrame . Using explicit `names` , instead of the column names With arguments `df`, `sortorder`.", "question_id": 37551}
{"snippet": "MultiIndex.from_frame(df)", "intent": "Make a MultiIndex from a DataFrame . With arguments `df`.", "question_id": 37552}
{"snippet": "MultiIndex.from_frame(df, sortorder=None)", "intent": "Make a MultiIndex from a DataFrame . With arguments `df`, `sortorder`.", "question_id": 37553}
{"snippet": "MultiIndex.from_frame(df, names=None)", "intent": "Make a MultiIndex from a DataFrame . Using explicit `names` , instead of the column names With arguments `df`.", "question_id": 37554}
{"snippet": "MultiIndex.from_frame(df, sortorder=None, names=None)", "intent": "Make a MultiIndex from a DataFrame . Using explicit `names` , instead of the column names With arguments `df`, `sortorder`.", "question_id": 37555}
{"snippet": "MultiIndex.from_product(iterables)", "intent": "Make a MultiIndex from the cartesian product of multiple `iterables` .", "question_id": 37556}
{"snippet": "MultiIndex.from_product(iterables, sortorder=None)", "intent": "Make a MultiIndex from the cartesian product of multiple `iterables` . With arguments `sortorder`.", "question_id": 37557}
{"snippet": "MultiIndex.from_product(iterables, names=NoDefault.no_default)", "intent": "Make a MultiIndex from the cartesian product of multiple `iterables` . With arguments `names`.", "question_id": 37558}
{"snippet": "MultiIndex.from_product(iterables, sortorder=None, names=NoDefault.no_default)", "intent": "Make a MultiIndex from the cartesian product of multiple `iterables` . With arguments `sortorder`, `names`.", "question_id": 37559}
{"snippet": "MultiIndex.from_product(iterables)", "intent": "Make a MultiIndex from the cartesian product of multiple `iterables` .", "question_id": 37560}
{"snippet": "MultiIndex.from_product(iterables, sortorder=None)", "intent": "Make a MultiIndex from the cartesian product of multiple `iterables` . With arguments `sortorder`.", "question_id": 37561}
{"snippet": "MultiIndex.from_product(iterables, names=NoDefault.no_default)", "intent": "Make a MultiIndex from the cartesian product of multiple `iterables` . With arguments `names`.", "question_id": 37562}
{"snippet": "MultiIndex.from_product(iterables, sortorder=None, names=NoDefault.no_default)", "intent": "Make a MultiIndex from the cartesian product of multiple `iterables` . With arguments `sortorder`, `names`.", "question_id": 37563}
{"snippet": "MultiIndex.from_product(iterables)", "intent": "Make a MultiIndex from the cartesian product of multiple `iterables` .", "question_id": 37564}
{"snippet": "MultiIndex.from_product(iterables, sortorder=None)", "intent": "Make a MultiIndex from the cartesian product of multiple `iterables` . With arguments `sortorder`.", "question_id": 37565}
{"snippet": "MultiIndex.from_product(iterables, names=NoDefault.no_default)", "intent": "Make a MultiIndex from the cartesian product of multiple `iterables` . With arguments `names`.", "question_id": 37566}
{"snippet": "MultiIndex.from_product(iterables, sortorder=None, names=NoDefault.no_default)", "intent": "Make a MultiIndex from the cartesian product of multiple `iterables` . With arguments `sortorder`, `names`.", "question_id": 37567}
{"snippet": "MultiIndex.from_tuples(tuples)", "intent": "Convert list of `tuples` to MultiIndex .", "question_id": 37568}
{"snippet": "MultiIndex.from_tuples(tuples, sortorder=None)", "intent": "Convert list of `tuples` to MultiIndex . With arguments `sortorder`.", "question_id": 37569}
{"snippet": "MultiIndex.from_tuples(tuples, names=None)", "intent": "Convert list of `tuples` to MultiIndex . With arguments `names`.", "question_id": 37570}
{"snippet": "MultiIndex.from_tuples(tuples, sortorder=None, names=None)", "intent": "Convert list of `tuples` to MultiIndex . With arguments `sortorder`, `names`.", "question_id": 37571}
{"snippet": "MultiIndex.from_tuples(tuples)", "intent": "Convert list of `tuples` to MultiIndex .", "question_id": 37572}
{"snippet": "MultiIndex.from_tuples(tuples, sortorder=None)", "intent": "Convert list of `tuples` to MultiIndex . With arguments `sortorder`.", "question_id": 37573}
{"snippet": "MultiIndex.from_tuples(tuples, names=None)", "intent": "Convert list of `tuples` to MultiIndex . With arguments `names`.", "question_id": 37574}
{"snippet": "MultiIndex.from_tuples(tuples, sortorder=None, names=None)", "intent": "Convert list of `tuples` to MultiIndex . With arguments `sortorder`, `names`.", "question_id": 37575}
{"snippet": "MultiIndex.from_tuples(tuples)", "intent": "Convert list of `tuples` to MultiIndex .", "question_id": 37576}
{"snippet": "MultiIndex.from_tuples(tuples, sortorder=None)", "intent": "Convert list of `tuples` to MultiIndex . With arguments `sortorder`.", "question_id": 37577}
{"snippet": "MultiIndex.from_tuples(tuples, names=None)", "intent": "Convert list of `tuples` to MultiIndex . With arguments `names`.", "question_id": 37578}
{"snippet": "MultiIndex.from_tuples(tuples, sortorder=None, names=None)", "intent": "Convert list of `tuples` to MultiIndex . With arguments `sortorder`, `names`.", "question_id": 37579}
{"snippet": "MultiIndex.get_indexer(target)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`.", "question_id": 37580}
{"snippet": "MultiIndex.get_indexer(target, method=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`.", "question_id": 37581}
{"snippet": "MultiIndex.get_indexer(target, limit=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `limit`.", "question_id": 37582}
{"snippet": "MultiIndex.get_indexer(target, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `tolerance`.", "question_id": 37583}
{"snippet": "MultiIndex.get_indexer(target, method=None, limit=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `limit`.", "question_id": 37584}
{"snippet": "MultiIndex.get_indexer(target, method=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `tolerance`.", "question_id": 37585}
{"snippet": "MultiIndex.get_indexer(target, limit=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `limit`, `tolerance`.", "question_id": 37586}
{"snippet": "MultiIndex.get_indexer(target, method=None, limit=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `limit`, `tolerance`.", "question_id": 37587}
{"snippet": "MultiIndex.get_indexer(target)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`.", "question_id": 37588}
{"snippet": "MultiIndex.get_indexer(target, method=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`.", "question_id": 37589}
{"snippet": "MultiIndex.get_indexer(target, limit=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `limit`.", "question_id": 37590}
{"snippet": "MultiIndex.get_indexer(target, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `tolerance`.", "question_id": 37591}
{"snippet": "MultiIndex.get_indexer(target, method=None, limit=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `limit`.", "question_id": 37592}
{"snippet": "MultiIndex.get_indexer(target, method=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `tolerance`.", "question_id": 37593}
{"snippet": "MultiIndex.get_indexer(target, limit=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `limit`, `tolerance`.", "question_id": 37594}
{"snippet": "MultiIndex.get_indexer(target, method=None, limit=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `limit`, `tolerance`.", "question_id": 37595}
{"snippet": "MultiIndex.get_indexer(target)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`.", "question_id": 37596}
{"snippet": "MultiIndex.get_indexer(target, method=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`.", "question_id": 37597}
{"snippet": "MultiIndex.get_indexer(target, limit=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `limit`.", "question_id": 37598}
{"snippet": "MultiIndex.get_indexer(target, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `tolerance`.", "question_id": 37599}
{"snippet": "MultiIndex.get_indexer(target, method=None, limit=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `limit`.", "question_id": 37600}
{"snippet": "MultiIndex.get_indexer(target, method=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `tolerance`.", "question_id": 37601}
{"snippet": "MultiIndex.get_indexer(target, limit=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `limit`, `tolerance`.", "question_id": 37602}
{"snippet": "MultiIndex.get_indexer(target, method=None, limit=None, tolerance=None)", "intent": "Compute indexer and mask for new index given the current index . With arguments `target`, `method`, `limit`, `tolerance`.", "question_id": 37603}
{"snippet": "MultiIndex.get_level_values(level)", "intent": "Return vector of label values for requested `level` .", "question_id": 37604}
{"snippet": "MultiIndex.get_level_values(level)", "intent": "Return vector of label values for requested `level` .", "question_id": 37605}
{"snippet": "MultiIndex.get_level_values(level)", "intent": "Return vector of label values for requested `level` .", "question_id": 37606}
{"snippet": "MultiIndex.get_loc(key)", "intent": "Get location for a label or a tuple of labels . The `key` can not be a slice , list of same-level labels , a boolean mask , or a sequence of such .", "question_id": 37607}
{"snippet": "MultiIndex.get_loc(key, method=None)", "intent": "Get location for a label or a tuple of labels . The `key` can not be a slice , list of same-level labels , a boolean mask , or a sequence of such . With arguments `method`.", "question_id": 37608}
{"snippet": "MultiIndex.get_loc(key)", "intent": "Get location for a label or a tuple of labels . The `key` can not be a slice , list of same-level labels , a boolean mask , or a sequence of such .", "question_id": 37609}
{"snippet": "MultiIndex.get_loc(key, method=None)", "intent": "Get location for a label or a tuple of labels . The `key` can not be a slice , list of same-level labels , a boolean mask , or a sequence of such . With arguments `method`.", "question_id": 37610}
{"snippet": "MultiIndex.get_loc(key)", "intent": "Get location for a label or a tuple of labels . The `key` can not be a slice , list of same-level labels , a boolean mask , or a sequence of such .", "question_id": 37611}
{"snippet": "MultiIndex.get_loc(key, method=None)", "intent": "Get location for a label or a tuple of labels . The `key` can not be a slice , list of same-level labels , a boolean mask , or a sequence of such . With arguments `method`.", "question_id": 37612}
{"snippet": "MultiIndex.get_loc_level(key)", "intent": "Get location and sliced index for requested label ( s ) /level ( s ) . With arguments `key`.", "question_id": 37613}
{"snippet": "MultiIndex.get_loc_level(key, level=0)", "intent": "Get location and sliced index for requested label ( s ) /level ( s ) . With arguments `key`, `level`.", "question_id": 37614}
{"snippet": "MultiIndex.get_loc_level(key, drop_level=True)", "intent": "Get location and sliced index for requested label ( s ) /level ( s ) . With arguments `key`, `drop_level`.", "question_id": 37615}
{"snippet": "MultiIndex.get_loc_level(key, level=0, drop_level=True)", "intent": "Get location and sliced index for requested label ( s ) /level ( s ) . With arguments `key`, `level`, `drop_level`.", "question_id": 37616}
{"snippet": "MultiIndex.get_loc_level(key)", "intent": "Get location and sliced index for requested label ( s ) /level ( s ) . With arguments `key`.", "question_id": 37617}
{"snippet": "MultiIndex.get_loc_level(key, level=0)", "intent": "Get location and sliced index for requested label ( s ) /level ( s ) . With arguments `key`, `level`.", "question_id": 37618}
{"snippet": "MultiIndex.get_loc_level(key, drop_level=True)", "intent": "Get location and sliced index for requested label ( s ) /level ( s ) . With arguments `key`, `drop_level`.", "question_id": 37619}
{"snippet": "MultiIndex.get_loc_level(key, level=0, drop_level=True)", "intent": "Get location and sliced index for requested label ( s ) /level ( s ) . With arguments `key`, `level`, `drop_level`.", "question_id": 37620}
{"snippet": "MultiIndex.get_loc_level(key)", "intent": "Get location and sliced index for requested label ( s ) /level ( s ) . With arguments `key`.", "question_id": 37621}
{"snippet": "MultiIndex.get_loc_level(key, level=0)", "intent": "Get location and sliced index for requested label ( s ) /level ( s ) . With arguments `key`, `level`.", "question_id": 37622}
{"snippet": "MultiIndex.get_loc_level(key, drop_level=True)", "intent": "Get location and sliced index for requested label ( s ) /level ( s ) . With arguments `key`, `drop_level`.", "question_id": 37623}
{"snippet": "MultiIndex.get_loc_level(key, level=0, drop_level=True)", "intent": "Get location and sliced index for requested label ( s ) /level ( s ) . With arguments `key`, `level`, `drop_level`.", "question_id": 37624}
{"snippet": "MultiIndex.get_locs(seq)", "intent": "Get location for a sequence of labels . With arguments `seq`.", "question_id": 37625}
{"snippet": "MultiIndex.get_locs(seq)", "intent": "Get location for a sequence of labels . With arguments `seq`.", "question_id": 37626}
{"snippet": "MultiIndex.get_locs(seq)", "intent": "Get location for a sequence of labels . With arguments `seq`.", "question_id": 37627}
{"snippet": "pandas.MultiIndex()", "intent": "A multi-level , or hierarchical , index object for pandas objects .", "question_id": 37628}
{"snippet": "pandas.MultiIndex(levels=None)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `levels`.", "question_id": 37629}
{"snippet": "pandas.MultiIndex(codes=None)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `codes`.", "question_id": 37630}
{"snippet": "pandas.MultiIndex(sortorder=None)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `sortorder`.", "question_id": 37631}
{"snippet": "pandas.MultiIndex(names=None)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `names`.", "question_id": 37632}
{"snippet": "pandas.MultiIndex(dtype=None)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `dtype`.", "question_id": 37633}
{"snippet": "pandas.MultiIndex(copy=False)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `copy`.", "question_id": 37634}
{"snippet": "pandas.MultiIndex(name=None)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `name`.", "question_id": 37635}
{"snippet": "pandas.MultiIndex(verify_integrity=True)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `verify_integrity`.", "question_id": 37636}
{"snippet": "pandas.MultiIndex(levels=None, codes=None)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `levels`, `codes`.", "question_id": 37637}
{"snippet": "pandas.MultiIndex()", "intent": "A multi-level , or hierarchical , index object for pandas objects .", "question_id": 37638}
{"snippet": "pandas.MultiIndex(levels=None)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `levels`.", "question_id": 37639}
{"snippet": "pandas.MultiIndex(codes=None)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `codes`.", "question_id": 37640}
{"snippet": "pandas.MultiIndex(sortorder=None)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `sortorder`.", "question_id": 37641}
{"snippet": "pandas.MultiIndex(names=None)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `names`.", "question_id": 37642}
{"snippet": "pandas.MultiIndex(dtype=None)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `dtype`.", "question_id": 37643}
{"snippet": "pandas.MultiIndex(copy=False)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `copy`.", "question_id": 37644}
{"snippet": "pandas.MultiIndex(name=None)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `name`.", "question_id": 37645}
{"snippet": "pandas.MultiIndex(verify_integrity=True)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `verify_integrity`.", "question_id": 37646}
{"snippet": "pandas.MultiIndex(levels=None, codes=None)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `levels`, `codes`.", "question_id": 37647}
{"snippet": "pandas.MultiIndex()", "intent": "A multi-level , or hierarchical , index object for pandas objects .", "question_id": 37648}
{"snippet": "pandas.MultiIndex(levels=None)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `levels`.", "question_id": 37649}
{"snippet": "pandas.MultiIndex(codes=None)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `codes`.", "question_id": 37650}
{"snippet": "pandas.MultiIndex(sortorder=None)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `sortorder`.", "question_id": 37651}
{"snippet": "pandas.MultiIndex(names=None)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `names`.", "question_id": 37652}
{"snippet": "pandas.MultiIndex(dtype=None)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `dtype`.", "question_id": 37653}
{"snippet": "pandas.MultiIndex(copy=False)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `copy`.", "question_id": 37654}
{"snippet": "pandas.MultiIndex(name=None)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `name`.", "question_id": 37655}
{"snippet": "pandas.MultiIndex(verify_integrity=True)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `verify_integrity`.", "question_id": 37656}
{"snippet": "pandas.MultiIndex(levels=None, codes=None)", "intent": "A multi-level , or hierarchical , index object for pandas objects . With arguments `levels`, `codes`.", "question_id": 37657}
{"snippet": "MultiIndex.remove_unused_levels()", "intent": "Create new MultiIndex from current that removes unused levels .", "question_id": 37658}
{"snippet": "MultiIndex.remove_unused_levels()", "intent": "Create new MultiIndex from current that removes unused levels .", "question_id": 37659}
{"snippet": "MultiIndex.remove_unused_levels()", "intent": "Create new MultiIndex from current that removes unused levels .", "question_id": 37660}
{"snippet": "MultiIndex.reorder_levels(order)", "intent": "Rearrange levels using input `order` .", "question_id": 37661}
{"snippet": "MultiIndex.reorder_levels(order)", "intent": "Rearrange levels using input `order` .", "question_id": 37662}
{"snippet": "MultiIndex.reorder_levels(order)", "intent": "Rearrange levels using input `order` .", "question_id": 37663}
{"snippet": "MultiIndex.set_codes(codes)", "intent": "Set new `codes` on MultiIndex .", "question_id": 37664}
{"snippet": "MultiIndex.set_codes(codes, level=None)", "intent": "Set new `codes` on MultiIndex . With arguments `level`.", "question_id": 37665}
{"snippet": "MultiIndex.set_codes(codes, inplace=None)", "intent": "Set new `codes` on MultiIndex . With arguments `inplace`.", "question_id": 37666}
{"snippet": "MultiIndex.set_codes(codes, verify_integrity=True)", "intent": "Set new `codes` on MultiIndex . With arguments `verify_integrity`.", "question_id": 37667}
{"snippet": "MultiIndex.set_codes(codes, level=None, inplace=None)", "intent": "Set new `codes` on MultiIndex . With arguments `level`, `inplace`.", "question_id": 37668}
{"snippet": "MultiIndex.set_codes(codes, level=None, verify_integrity=True)", "intent": "Set new `codes` on MultiIndex . With arguments `level`, `verify_integrity`.", "question_id": 37669}
{"snippet": "MultiIndex.set_codes(codes, inplace=None, verify_integrity=True)", "intent": "Set new `codes` on MultiIndex . With arguments `inplace`, `verify_integrity`.", "question_id": 37670}
{"snippet": "MultiIndex.set_codes(codes, level=None, inplace=None, verify_integrity=True)", "intent": "Set new `codes` on MultiIndex . With arguments `level`, `inplace`, `verify_integrity`.", "question_id": 37671}
{"snippet": "MultiIndex.set_codes(codes)", "intent": "Set new `codes` on MultiIndex .", "question_id": 37672}
{"snippet": "MultiIndex.set_codes(codes, level=None)", "intent": "Set new `codes` on MultiIndex . With arguments `level`.", "question_id": 37673}
{"snippet": "MultiIndex.set_codes(codes, inplace=None)", "intent": "Set new `codes` on MultiIndex . With arguments `inplace`.", "question_id": 37674}
{"snippet": "MultiIndex.set_codes(codes, verify_integrity=True)", "intent": "Set new `codes` on MultiIndex . With arguments `verify_integrity`.", "question_id": 37675}
{"snippet": "MultiIndex.set_codes(codes, level=None, inplace=None)", "intent": "Set new `codes` on MultiIndex . With arguments `level`, `inplace`.", "question_id": 37676}
{"snippet": "MultiIndex.set_codes(codes, level=None, verify_integrity=True)", "intent": "Set new `codes` on MultiIndex . With arguments `level`, `verify_integrity`.", "question_id": 37677}
{"snippet": "MultiIndex.set_codes(codes, inplace=None, verify_integrity=True)", "intent": "Set new `codes` on MultiIndex . With arguments `inplace`, `verify_integrity`.", "question_id": 37678}
{"snippet": "MultiIndex.set_codes(codes, level=None, inplace=None, verify_integrity=True)", "intent": "Set new `codes` on MultiIndex . With arguments `level`, `inplace`, `verify_integrity`.", "question_id": 37679}
{"snippet": "MultiIndex.set_codes(codes)", "intent": "Set new `codes` on MultiIndex .", "question_id": 37680}
{"snippet": "MultiIndex.set_codes(codes, level=None)", "intent": "Set new `codes` on MultiIndex . With arguments `level`.", "question_id": 37681}
{"snippet": "MultiIndex.set_codes(codes, inplace=None)", "intent": "Set new `codes` on MultiIndex . With arguments `inplace`.", "question_id": 37682}
{"snippet": "MultiIndex.set_codes(codes, verify_integrity=True)", "intent": "Set new `codes` on MultiIndex . With arguments `verify_integrity`.", "question_id": 37683}
{"snippet": "MultiIndex.set_codes(codes, level=None, inplace=None)", "intent": "Set new `codes` on MultiIndex . With arguments `level`, `inplace`.", "question_id": 37684}
{"snippet": "MultiIndex.set_codes(codes, level=None, verify_integrity=True)", "intent": "Set new `codes` on MultiIndex . With arguments `level`, `verify_integrity`.", "question_id": 37685}
{"snippet": "MultiIndex.set_codes(codes, inplace=None, verify_integrity=True)", "intent": "Set new `codes` on MultiIndex . With arguments `inplace`, `verify_integrity`.", "question_id": 37686}
{"snippet": "MultiIndex.set_codes(codes, level=None, inplace=None, verify_integrity=True)", "intent": "Set new `codes` on MultiIndex . With arguments `level`, `inplace`, `verify_integrity`.", "question_id": 37687}
{"snippet": "MultiIndex.set_levels(levels)", "intent": "Set new `levels` on MultiIndex .", "question_id": 37688}
{"snippet": "MultiIndex.set_levels(levels, level=None)", "intent": "Set new `levels` on MultiIndex . With arguments `level`.", "question_id": 37689}
{"snippet": "MultiIndex.set_levels(levels, inplace=None)", "intent": "Set new `levels` on MultiIndex . With arguments `inplace`.", "question_id": 37690}
{"snippet": "MultiIndex.set_levels(levels, verify_integrity=True)", "intent": "Set new `levels` on MultiIndex . With arguments `verify_integrity`.", "question_id": 37691}
{"snippet": "MultiIndex.set_levels(levels, level=None, inplace=None)", "intent": "Set new `levels` on MultiIndex . With arguments `level`, `inplace`.", "question_id": 37692}
{"snippet": "MultiIndex.set_levels(levels, level=None, verify_integrity=True)", "intent": "Set new `levels` on MultiIndex . With arguments `level`, `verify_integrity`.", "question_id": 37693}
{"snippet": "MultiIndex.set_levels(levels, inplace=None, verify_integrity=True)", "intent": "Set new `levels` on MultiIndex . With arguments `inplace`, `verify_integrity`.", "question_id": 37694}
{"snippet": "MultiIndex.set_levels(levels, level=None, inplace=None, verify_integrity=True)", "intent": "Set new `levels` on MultiIndex . With arguments `level`, `inplace`, `verify_integrity`.", "question_id": 37695}
{"snippet": "MultiIndex.set_levels(levels)", "intent": "Set new `levels` on MultiIndex .", "question_id": 37696}
{"snippet": "MultiIndex.set_levels(levels, level=None)", "intent": "Set new `levels` on MultiIndex . With arguments `level`.", "question_id": 37697}
{"snippet": "MultiIndex.set_levels(levels, inplace=None)", "intent": "Set new `levels` on MultiIndex . With arguments `inplace`.", "question_id": 37698}
{"snippet": "MultiIndex.set_levels(levels, verify_integrity=True)", "intent": "Set new `levels` on MultiIndex . With arguments `verify_integrity`.", "question_id": 37699}
{"snippet": "MultiIndex.set_levels(levels, level=None, inplace=None)", "intent": "Set new `levels` on MultiIndex . With arguments `level`, `inplace`.", "question_id": 37700}
{"snippet": "MultiIndex.set_levels(levels, level=None, verify_integrity=True)", "intent": "Set new `levels` on MultiIndex . With arguments `level`, `verify_integrity`.", "question_id": 37701}
{"snippet": "MultiIndex.set_levels(levels, inplace=None, verify_integrity=True)", "intent": "Set new `levels` on MultiIndex . With arguments `inplace`, `verify_integrity`.", "question_id": 37702}
{"snippet": "MultiIndex.set_levels(levels, level=None, inplace=None, verify_integrity=True)", "intent": "Set new `levels` on MultiIndex . With arguments `level`, `inplace`, `verify_integrity`.", "question_id": 37703}
{"snippet": "MultiIndex.set_levels(levels)", "intent": "Set new `levels` on MultiIndex .", "question_id": 37704}
{"snippet": "MultiIndex.set_levels(levels, level=None)", "intent": "Set new `levels` on MultiIndex . With arguments `level`.", "question_id": 37705}
{"snippet": "MultiIndex.set_levels(levels, inplace=None)", "intent": "Set new `levels` on MultiIndex . With arguments `inplace`.", "question_id": 37706}
{"snippet": "MultiIndex.set_levels(levels, verify_integrity=True)", "intent": "Set new `levels` on MultiIndex . With arguments `verify_integrity`.", "question_id": 37707}
{"snippet": "MultiIndex.set_levels(levels, level=None, inplace=None)", "intent": "Set new `levels` on MultiIndex . With arguments `level`, `inplace`.", "question_id": 37708}
{"snippet": "MultiIndex.set_levels(levels, level=None, verify_integrity=True)", "intent": "Set new `levels` on MultiIndex . With arguments `level`, `verify_integrity`.", "question_id": 37709}
{"snippet": "MultiIndex.set_levels(levels, inplace=None, verify_integrity=True)", "intent": "Set new `levels` on MultiIndex . With arguments `inplace`, `verify_integrity`.", "question_id": 37710}
{"snippet": "MultiIndex.set_levels(levels, level=None, inplace=None, verify_integrity=True)", "intent": "Set new `levels` on MultiIndex . With arguments `level`, `inplace`, `verify_integrity`.", "question_id": 37711}
{"snippet": "MultiIndex.sortlevel()", "intent": "Sort MultiIndex at the requested `level` .", "question_id": 37712}
{"snippet": "MultiIndex.sortlevel(level=0)", "intent": "Sort MultiIndex at the requested `level` .", "question_id": 37713}
{"snippet": "MultiIndex.sortlevel(ascending=True)", "intent": "Sort MultiIndex at the requested `level` . With arguments `ascending`.", "question_id": 37714}
{"snippet": "MultiIndex.sortlevel(sort_remaining=True)", "intent": "Sort MultiIndex at the requested `level` . With arguments `sort_remaining`.", "question_id": 37715}
{"snippet": "MultiIndex.sortlevel(level=0, ascending=True)", "intent": "Sort MultiIndex at the requested `level` . With arguments `ascending`.", "question_id": 37716}
{"snippet": "MultiIndex.sortlevel(level=0, sort_remaining=True)", "intent": "Sort MultiIndex at the requested `level` . With arguments `sort_remaining`.", "question_id": 37717}
{"snippet": "MultiIndex.sortlevel(ascending=True, sort_remaining=True)", "intent": "Sort MultiIndex at the requested `level` . With arguments `ascending`, `sort_remaining`.", "question_id": 37718}
{"snippet": "MultiIndex.sortlevel(level=0, ascending=True, sort_remaining=True)", "intent": "Sort MultiIndex at the requested `level` . With arguments `ascending`, `sort_remaining`.", "question_id": 37719}
{"snippet": "MultiIndex.sortlevel()", "intent": "Sort MultiIndex at the requested `level` .", "question_id": 37720}
{"snippet": "MultiIndex.sortlevel(level=0)", "intent": "Sort MultiIndex at the requested `level` .", "question_id": 37721}
{"snippet": "MultiIndex.sortlevel(ascending=True)", "intent": "Sort MultiIndex at the requested `level` . With arguments `ascending`.", "question_id": 37722}
{"snippet": "MultiIndex.sortlevel(sort_remaining=True)", "intent": "Sort MultiIndex at the requested `level` . With arguments `sort_remaining`.", "question_id": 37723}
{"snippet": "MultiIndex.sortlevel(level=0, ascending=True)", "intent": "Sort MultiIndex at the requested `level` . With arguments `ascending`.", "question_id": 37724}
{"snippet": "MultiIndex.sortlevel(level=0, sort_remaining=True)", "intent": "Sort MultiIndex at the requested `level` . With arguments `sort_remaining`.", "question_id": 37725}
{"snippet": "MultiIndex.sortlevel(ascending=True, sort_remaining=True)", "intent": "Sort MultiIndex at the requested `level` . With arguments `ascending`, `sort_remaining`.", "question_id": 37726}
{"snippet": "MultiIndex.sortlevel(level=0, ascending=True, sort_remaining=True)", "intent": "Sort MultiIndex at the requested `level` . With arguments `ascending`, `sort_remaining`.", "question_id": 37727}
{"snippet": "MultiIndex.sortlevel()", "intent": "Sort MultiIndex at the requested `level` .", "question_id": 37728}
{"snippet": "MultiIndex.sortlevel(level=0)", "intent": "Sort MultiIndex at the requested `level` .", "question_id": 37729}
{"snippet": "MultiIndex.sortlevel(ascending=True)", "intent": "Sort MultiIndex at the requested `level` . With arguments `ascending`.", "question_id": 37730}
{"snippet": "MultiIndex.sortlevel(sort_remaining=True)", "intent": "Sort MultiIndex at the requested `level` . With arguments `sort_remaining`.", "question_id": 37731}
{"snippet": "MultiIndex.sortlevel(level=0, ascending=True)", "intent": "Sort MultiIndex at the requested `level` . With arguments `ascending`.", "question_id": 37732}
{"snippet": "MultiIndex.sortlevel(level=0, sort_remaining=True)", "intent": "Sort MultiIndex at the requested `level` . With arguments `sort_remaining`.", "question_id": 37733}
{"snippet": "MultiIndex.sortlevel(ascending=True, sort_remaining=True)", "intent": "Sort MultiIndex at the requested `level` . With arguments `ascending`, `sort_remaining`.", "question_id": 37734}
{"snippet": "MultiIndex.sortlevel(level=0, ascending=True, sort_remaining=True)", "intent": "Sort MultiIndex at the requested `level` . With arguments `ascending`, `sort_remaining`.", "question_id": 37735}
{"snippet": "MultiIndex.swaplevel()", "intent": "Swap level `i` with level `j` .", "question_id": 37736}
{"snippet": "MultiIndex.swaplevel(i=- 2)", "intent": "Swap level `i` with level `j` .", "question_id": 37737}
{"snippet": "MultiIndex.swaplevel(j=- 1)", "intent": "Swap level `i` with level `j` .", "question_id": 37738}
{"snippet": "MultiIndex.swaplevel(i=- 2, j=- 1)", "intent": "Swap level `i` with level `j` .", "question_id": 37739}
{"snippet": "MultiIndex.swaplevel()", "intent": "Swap level `i` with level `j` .", "question_id": 37740}
{"snippet": "MultiIndex.swaplevel(i=- 2)", "intent": "Swap level `i` with level `j` .", "question_id": 37741}
{"snippet": "MultiIndex.swaplevel(j=- 1)", "intent": "Swap level `i` with level `j` .", "question_id": 37742}
{"snippet": "MultiIndex.swaplevel(i=- 2, j=- 1)", "intent": "Swap level `i` with level `j` .", "question_id": 37743}
{"snippet": "MultiIndex.swaplevel()", "intent": "Swap level `i` with level `j` .", "question_id": 37744}
{"snippet": "MultiIndex.swaplevel(i=- 2)", "intent": "Swap level `i` with level `j` .", "question_id": 37745}
{"snippet": "MultiIndex.swaplevel(j=- 1)", "intent": "Swap level `i` with level `j` .", "question_id": 37746}
{"snippet": "MultiIndex.swaplevel(i=- 2, j=- 1)", "intent": "Swap level `i` with level `j` .", "question_id": 37747}
{"snippet": "MultiIndex.to_flat_index()", "intent": "Convert a MultiIndex to an Index of Tuples containing the level values .", "question_id": 37748}
{"snippet": "MultiIndex.to_flat_index()", "intent": "Convert a MultiIndex to an Index of Tuples containing the level values .", "question_id": 37749}
{"snippet": "MultiIndex.to_flat_index()", "intent": "Convert a MultiIndex to an Index of Tuples containing the level values .", "question_id": 37750}
{"snippet": "MultiIndex.to_frame()", "intent": "Create a DataFrame with the levels of the MultiIndex as columns .", "question_id": 37751}
{"snippet": "MultiIndex.to_frame(index=True)", "intent": "Create a DataFrame with the levels of the MultiIndex as columns . With arguments `index`.", "question_id": 37752}
{"snippet": "MultiIndex.to_frame(name=None)", "intent": "Create a DataFrame with the levels of the MultiIndex as columns . With arguments `name`.", "question_id": 37753}
{"snippet": "MultiIndex.to_frame(index=True, name=None)", "intent": "Create a DataFrame with the levels of the MultiIndex as columns . With arguments `index`, `name`.", "question_id": 37754}
{"snippet": "MultiIndex.to_frame()", "intent": "Create a DataFrame with the levels of the MultiIndex as columns .", "question_id": 37755}
{"snippet": "MultiIndex.to_frame(index=True)", "intent": "Create a DataFrame with the levels of the MultiIndex as columns . With arguments `index`.", "question_id": 37756}
{"snippet": "MultiIndex.to_frame(name=None)", "intent": "Create a DataFrame with the levels of the MultiIndex as columns . With arguments `name`.", "question_id": 37757}
{"snippet": "MultiIndex.to_frame(index=True, name=None)", "intent": "Create a DataFrame with the levels of the MultiIndex as columns . With arguments `index`, `name`.", "question_id": 37758}
{"snippet": "MultiIndex.to_frame()", "intent": "Create a DataFrame with the levels of the MultiIndex as columns .", "question_id": 37759}
{"snippet": "MultiIndex.to_frame(index=True)", "intent": "Create a DataFrame with the levels of the MultiIndex as columns . With arguments `index`.", "question_id": 37760}
{"snippet": "MultiIndex.to_frame(name=None)", "intent": "Create a DataFrame with the levels of the MultiIndex as columns . With arguments `name`.", "question_id": 37761}
{"snippet": "MultiIndex.to_frame(index=True, name=None)", "intent": "Create a DataFrame with the levels of the MultiIndex as columns . With arguments `index`, `name`.", "question_id": 37762}
{"snippet": "Period.asfreq()", "intent": "Convert Period to desired frequency , at the start or end of the interval .", "question_id": 37763}
{"snippet": "Period.asfreq()", "intent": "Convert Period to desired frequency , at the start or end of the interval .", "question_id": 37764}
{"snippet": "Period.asfreq()", "intent": "Convert Period to desired frequency , at the start or end of the interval .", "question_id": 37765}
{"snippet": "Period.day", "intent": "Get day of the month that a Period falls on.", "question_id": 37766}
{"snippet": "Period.day", "intent": "Get day of the month that a Period falls on.", "question_id": 37767}
{"snippet": "Period.day", "intent": "Get day of the month that a Period falls on.", "question_id": 37768}
{"snippet": "Period.day_of_week", "intent": "Day of the week the period lies in, with Monday=0 and Sunday=6.", "question_id": 37769}
{"snippet": "Period.day_of_week", "intent": "Day of the week the period lies in, with Monday=0 and Sunday=6.", "question_id": 37770}
{"snippet": "Period.day_of_week", "intent": "Day of the week the period lies in, with Monday=0 and Sunday=6.", "question_id": 37771}
{"snippet": "Period.day_of_year", "intent": "Return the day of the year.", "question_id": 37772}
{"snippet": "Period.day_of_year", "intent": "Return the day of the year.", "question_id": 37773}
{"snippet": "Period.day_of_year", "intent": "Return the day of the year.", "question_id": 37774}
{"snippet": "Period.dayofweek", "intent": "Day of the week the period lies in, with Monday=0 and Sunday=6.", "question_id": 37775}
{"snippet": "Period.dayofweek", "intent": "Day of the week the period lies in, with Monday=0 and Sunday=6.", "question_id": 37776}
{"snippet": "Period.dayofweek", "intent": "Day of the week the period lies in, with Monday=0 and Sunday=6.", "question_id": 37777}
{"snippet": "Period.dayofyear", "intent": "Return the day of the year.", "question_id": 37778}
{"snippet": "Period.dayofyear", "intent": "Return the day of the year.", "question_id": 37779}
{"snippet": "Period.dayofyear", "intent": "Return the day of the year.", "question_id": 37780}
{"snippet": "Period.days_in_month", "intent": "Get the total number of days in the month that this period falls on.", "question_id": 37781}
{"snippet": "Period.days_in_month", "intent": "Get the total number of days in the month that this period falls on.", "question_id": 37782}
{"snippet": "Period.days_in_month", "intent": "Get the total number of days in the month that this period falls on.", "question_id": 37783}
{"snippet": "Period.daysinmonth", "intent": "Get the total number of days of the month that the Period falls in.", "question_id": 37784}
{"snippet": "Period.daysinmonth", "intent": "Get the total number of days of the month that the Period falls in.", "question_id": 37785}
{"snippet": "Period.daysinmonth", "intent": "Get the total number of days of the month that the Period falls in.", "question_id": 37786}
{"snippet": "Period.hour", "intent": "Get the hour of the day component of the Period.", "question_id": 37787}
{"snippet": "Period.hour", "intent": "Get the hour of the day component of the Period.", "question_id": 37788}
{"snippet": "Period.hour", "intent": "Get the hour of the day component of the Period.", "question_id": 37789}
{"snippet": "pandas.Period()", "intent": "Represents a period of time .", "question_id": 37790}
{"snippet": "pandas.Period(value=None)", "intent": "Represents a period of time . With arguments `value`.", "question_id": 37791}
{"snippet": "pandas.Period(freq=None)", "intent": "Represents a period of time . With arguments `freq`.", "question_id": 37792}
{"snippet": "pandas.Period(ordinal=None)", "intent": "Represents a period of time . With arguments `ordinal`.", "question_id": 37793}
{"snippet": "pandas.Period(year=None)", "intent": "Represents a period of time . With arguments `year`.", "question_id": 37794}
{"snippet": "pandas.Period(month=None)", "intent": "Represents a period of time . With arguments `month`.", "question_id": 37795}
{"snippet": "pandas.Period(quarter=None)", "intent": "Represents a period of time . With arguments `quarter`.", "question_id": 37796}
{"snippet": "pandas.Period(day=None)", "intent": "Represents a period of time . With arguments `day`.", "question_id": 37797}
{"snippet": "pandas.Period(hour=None)", "intent": "Represents a period of time . With arguments `hour`.", "question_id": 37798}
{"snippet": "pandas.Period(minute=None)", "intent": "Represents a period of time . With arguments `minute`.", "question_id": 37799}
{"snippet": "pandas.Period()", "intent": "Represents a period of time .", "question_id": 37800}
{"snippet": "pandas.Period(value=None)", "intent": "Represents a period of time . With arguments `value`.", "question_id": 37801}
{"snippet": "pandas.Period(freq=None)", "intent": "Represents a period of time . With arguments `freq`.", "question_id": 37802}
{"snippet": "pandas.Period(ordinal=None)", "intent": "Represents a period of time . With arguments `ordinal`.", "question_id": 37803}
{"snippet": "pandas.Period(year=None)", "intent": "Represents a period of time . With arguments `year`.", "question_id": 37804}
{"snippet": "pandas.Period(month=None)", "intent": "Represents a period of time . With arguments `month`.", "question_id": 37805}
{"snippet": "pandas.Period(quarter=None)", "intent": "Represents a period of time . With arguments `quarter`.", "question_id": 37806}
{"snippet": "pandas.Period(day=None)", "intent": "Represents a period of time . With arguments `day`.", "question_id": 37807}
{"snippet": "pandas.Period(hour=None)", "intent": "Represents a period of time . With arguments `hour`.", "question_id": 37808}
{"snippet": "pandas.Period(minute=None)", "intent": "Represents a period of time . With arguments `minute`.", "question_id": 37809}
{"snippet": "pandas.Period()", "intent": "Represents a period of time .", "question_id": 37810}
{"snippet": "pandas.Period(value=None)", "intent": "Represents a period of time . With arguments `value`.", "question_id": 37811}
{"snippet": "pandas.Period(freq=None)", "intent": "Represents a period of time . With arguments `freq`.", "question_id": 37812}
{"snippet": "pandas.Period(ordinal=None)", "intent": "Represents a period of time . With arguments `ordinal`.", "question_id": 37813}
{"snippet": "pandas.Period(year=None)", "intent": "Represents a period of time . With arguments `year`.", "question_id": 37814}
{"snippet": "pandas.Period(month=None)", "intent": "Represents a period of time . With arguments `month`.", "question_id": 37815}
{"snippet": "pandas.Period(quarter=None)", "intent": "Represents a period of time . With arguments `quarter`.", "question_id": 37816}
{"snippet": "pandas.Period(day=None)", "intent": "Represents a period of time . With arguments `day`.", "question_id": 37817}
{"snippet": "pandas.Period(hour=None)", "intent": "Represents a period of time . With arguments `hour`.", "question_id": 37818}
{"snippet": "pandas.Period(minute=None)", "intent": "Represents a period of time . With arguments `minute`.", "question_id": 37819}
{"snippet": "Period.minute", "intent": "Get minute of the hour component of the Period.", "question_id": 37820}
{"snippet": "Period.minute", "intent": "Get minute of the hour component of the Period.", "question_id": 37821}
{"snippet": "Period.minute", "intent": "Get minute of the hour component of the Period.", "question_id": 37822}
{"snippet": "Period.qyear", "intent": "Fiscal year the Period lies in according to its starting-quarter.", "question_id": 37823}
{"snippet": "Period.qyear", "intent": "Fiscal year the Period lies in according to its starting-quarter.", "question_id": 37824}
{"snippet": "Period.qyear", "intent": "Fiscal year the Period lies in according to its starting-quarter.", "question_id": 37825}
{"snippet": "Period.second", "intent": "Get the second component of the Period.", "question_id": 37826}
{"snippet": "Period.second", "intent": "Get the second component of the Period.", "question_id": 37827}
{"snippet": "Period.second", "intent": "Get the second component of the Period.", "question_id": 37828}
{"snippet": "Period.start_time", "intent": "Get the Timestamp for the start of the period.", "question_id": 37829}
{"snippet": "Period.start_time", "intent": "Get the Timestamp for the start of the period.", "question_id": 37830}
{"snippet": "Period.start_time", "intent": "Get the Timestamp for the start of the period.", "question_id": 37831}
{"snippet": "Period.strftime()", "intent": "Returns the string representation of the Period , depending on the selected fmt .", "question_id": 37832}
{"snippet": "Period.strftime()", "intent": "Returns the string representation of the Period , depending on the selected fmt .", "question_id": 37833}
{"snippet": "Period.strftime()", "intent": "Returns the string representation of the Period , depending on the selected fmt .", "question_id": 37834}
{"snippet": "Period.to_timestamp()", "intent": "Return the Timestamp representation of the Period .", "question_id": 37835}
{"snippet": "Period.to_timestamp()", "intent": "Return the Timestamp representation of the Period .", "question_id": 37836}
{"snippet": "Period.to_timestamp()", "intent": "Return the Timestamp representation of the Period .", "question_id": 37837}
{"snippet": "Period.week", "intent": "Get the week of the year on the given Period.", "question_id": 37838}
{"snippet": "Period.week", "intent": "Get the week of the year on the given Period.", "question_id": 37839}
{"snippet": "Period.week", "intent": "Get the week of the year on the given Period.", "question_id": 37840}
{"snippet": "Period.weekday", "intent": "Day of the week the period lies in, with Monday=0 and Sunday=6.", "question_id": 37841}
{"snippet": "Period.weekday", "intent": "Day of the week the period lies in, with Monday=0 and Sunday=6.", "question_id": 37842}
{"snippet": "Period.weekday", "intent": "Day of the week the period lies in, with Monday=0 and Sunday=6.", "question_id": 37843}
{"snippet": "pandas.PeriodDtype()", "intent": "An ExtensionDtype for Period data .", "question_id": 37844}
{"snippet": "pandas.PeriodDtype(freq=None)", "intent": "An ExtensionDtype for Period data . With arguments `freq`.", "question_id": 37845}
{"snippet": "pandas.PeriodDtype()", "intent": "An ExtensionDtype for Period data .", "question_id": 37846}
{"snippet": "pandas.PeriodDtype(freq=None)", "intent": "An ExtensionDtype for Period data . With arguments `freq`.", "question_id": 37847}
{"snippet": "pandas.PeriodDtype()", "intent": "An ExtensionDtype for Period data .", "question_id": 37848}
{"snippet": "pandas.PeriodDtype(freq=None)", "intent": "An ExtensionDtype for Period data . With arguments `freq`.", "question_id": 37849}
{"snippet": "PeriodIndex.asfreq()", "intent": "Convert the PeriodArray to the specified frequency `freq` .", "question_id": 37850}
{"snippet": "PeriodIndex.asfreq(freq=None)", "intent": "Convert the PeriodArray to the specified frequency `freq` .", "question_id": 37851}
{"snippet": "PeriodIndex.asfreq(how='E')", "intent": "Convert the PeriodArray to the specified frequency `freq` . With arguments `how`.", "question_id": 37852}
{"snippet": "PeriodIndex.asfreq(freq=None, how='E')", "intent": "Convert the PeriodArray to the specified frequency `freq` . With arguments `how`.", "question_id": 37853}
{"snippet": "PeriodIndex.asfreq()", "intent": "Convert the PeriodArray to the specified frequency `freq` .", "question_id": 37854}
{"snippet": "PeriodIndex.asfreq(freq=None)", "intent": "Convert the PeriodArray to the specified frequency `freq` .", "question_id": 37855}
{"snippet": "PeriodIndex.asfreq(how='E')", "intent": "Convert the PeriodArray to the specified frequency `freq` . With arguments `how`.", "question_id": 37856}
{"snippet": "PeriodIndex.asfreq(freq=None, how='E')", "intent": "Convert the PeriodArray to the specified frequency `freq` . With arguments `how`.", "question_id": 37857}
{"snippet": "PeriodIndex.asfreq()", "intent": "Convert the PeriodArray to the specified frequency `freq` .", "question_id": 37858}
{"snippet": "PeriodIndex.asfreq(freq=None)", "intent": "Convert the PeriodArray to the specified frequency `freq` .", "question_id": 37859}
{"snippet": "PeriodIndex.asfreq(how='E')", "intent": "Convert the PeriodArray to the specified frequency `freq` . With arguments `how`.", "question_id": 37860}
{"snippet": "PeriodIndex.asfreq(freq=None, how='E')", "intent": "Convert the PeriodArray to the specified frequency `freq` . With arguments `how`.", "question_id": 37861}
{"snippet": "pandas.PeriodIndex(**fields)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`.", "question_id": 37862}
{"snippet": "pandas.PeriodIndex(**fields, data=None)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`, `data`.", "question_id": 37863}
{"snippet": "pandas.PeriodIndex(**fields, ordinal=None)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`.", "question_id": 37864}
{"snippet": "pandas.PeriodIndex(**fields, freq=None)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`, `freq`.", "question_id": 37865}
{"snippet": "pandas.PeriodIndex(**fields, dtype=None)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`, `dtype`.", "question_id": 37866}
{"snippet": "pandas.PeriodIndex(**fields, copy=False)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`, `copy`.", "question_id": 37867}
{"snippet": "pandas.PeriodIndex(**fields, name=None)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`, `name`.", "question_id": 37868}
{"snippet": "pandas.PeriodIndex(**fields, data=None, ordinal=None)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`, `data`.", "question_id": 37869}
{"snippet": "pandas.PeriodIndex(**fields, data=None, freq=None)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`, `data`, `freq`.", "question_id": 37870}
{"snippet": "pandas.PeriodIndex(**fields, data=None, dtype=None)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`, `data`, `dtype`.", "question_id": 37871}
{"snippet": "pandas.PeriodIndex(**fields)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`.", "question_id": 37872}
{"snippet": "pandas.PeriodIndex(**fields, data=None)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`, `data`.", "question_id": 37873}
{"snippet": "pandas.PeriodIndex(**fields, ordinal=None)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`.", "question_id": 37874}
{"snippet": "pandas.PeriodIndex(**fields, freq=None)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`, `freq`.", "question_id": 37875}
{"snippet": "pandas.PeriodIndex(**fields, dtype=None)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`, `dtype`.", "question_id": 37876}
{"snippet": "pandas.PeriodIndex(**fields, copy=False)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`, `copy`.", "question_id": 37877}
{"snippet": "pandas.PeriodIndex(**fields, name=None)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`, `name`.", "question_id": 37878}
{"snippet": "pandas.PeriodIndex(**fields, data=None, ordinal=None)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`, `data`.", "question_id": 37879}
{"snippet": "pandas.PeriodIndex(**fields, data=None, freq=None)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`, `data`, `freq`.", "question_id": 37880}
{"snippet": "pandas.PeriodIndex(**fields, data=None, dtype=None)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`, `data`, `dtype`.", "question_id": 37881}
{"snippet": "pandas.PeriodIndex(**fields)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`.", "question_id": 37882}
{"snippet": "pandas.PeriodIndex(**fields, data=None)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`, `data`.", "question_id": 37883}
{"snippet": "pandas.PeriodIndex(**fields, ordinal=None)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`.", "question_id": 37884}
{"snippet": "pandas.PeriodIndex(**fields, freq=None)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`, `freq`.", "question_id": 37885}
{"snippet": "pandas.PeriodIndex(**fields, dtype=None)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`, `dtype`.", "question_id": 37886}
{"snippet": "pandas.PeriodIndex(**fields, copy=False)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`, `copy`.", "question_id": 37887}
{"snippet": "pandas.PeriodIndex(**fields, name=None)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`, `name`.", "question_id": 37888}
{"snippet": "pandas.PeriodIndex(**fields, data=None, ordinal=None)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`, `data`.", "question_id": 37889}
{"snippet": "pandas.PeriodIndex(**fields, data=None, freq=None)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`, `data`, `freq`.", "question_id": 37890}
{"snippet": "pandas.PeriodIndex(**fields, data=None, dtype=None)", "intent": "Immutable ndarray holding `ordinal` values indicating regular periods in time . With arguments `**fields`, `data`, `dtype`.", "question_id": 37891}
{"snippet": "PeriodIndex.strftime(*args, **kwargs)", "intent": "Convert to Index using specified date_format . With arguments `*args`, `**kwargs`.", "question_id": 37892}
{"snippet": "PeriodIndex.strftime(*args, **kwargs)", "intent": "Convert to Index using specified date_format . With arguments `*args`, `**kwargs`.", "question_id": 37893}
{"snippet": "PeriodIndex.strftime(*args, **kwargs)", "intent": "Convert to Index using specified date_format . With arguments `*args`, `**kwargs`.", "question_id": 37894}
{"snippet": "PeriodIndex.to_timestamp()", "intent": "Cast to DatetimeArray/Index .", "question_id": 37895}
{"snippet": "PeriodIndex.to_timestamp(freq=None)", "intent": "Cast to DatetimeArray/Index . With arguments `freq`.", "question_id": 37896}
{"snippet": "PeriodIndex.to_timestamp(how='start')", "intent": "Cast to DatetimeArray/Index . With arguments `how`.", "question_id": 37897}
{"snippet": "PeriodIndex.to_timestamp(freq=None, how='start')", "intent": "Cast to DatetimeArray/Index . With arguments `freq`, `how`.", "question_id": 37898}
{"snippet": "PeriodIndex.to_timestamp()", "intent": "Cast to DatetimeArray/Index .", "question_id": 37899}
{"snippet": "PeriodIndex.to_timestamp(freq=None)", "intent": "Cast to DatetimeArray/Index . With arguments `freq`.", "question_id": 37900}
{"snippet": "PeriodIndex.to_timestamp(how='start')", "intent": "Cast to DatetimeArray/Index . With arguments `how`.", "question_id": 37901}
{"snippet": "PeriodIndex.to_timestamp(freq=None, how='start')", "intent": "Cast to DatetimeArray/Index . With arguments `freq`, `how`.", "question_id": 37902}
{"snippet": "PeriodIndex.to_timestamp()", "intent": "Cast to DatetimeArray/Index .", "question_id": 37903}
{"snippet": "PeriodIndex.to_timestamp(freq=None)", "intent": "Cast to DatetimeArray/Index . With arguments `freq`.", "question_id": 37904}
{"snippet": "PeriodIndex.to_timestamp(how='start')", "intent": "Cast to DatetimeArray/Index . With arguments `how`.", "question_id": 37905}
{"snippet": "PeriodIndex.to_timestamp(freq=None, how='start')", "intent": "Cast to DatetimeArray/Index . With arguments `freq`, `how`.", "question_id": 37906}
{"snippet": "RangeIndex.from_range(data)", "intent": "Create RangeIndex from a range object . With arguments `data`.", "question_id": 37907}
{"snippet": "RangeIndex.from_range(data, name=None)", "intent": "Create RangeIndex from a range object . With arguments `data`, `name`.", "question_id": 37908}
{"snippet": "RangeIndex.from_range(data, dtype=None)", "intent": "Create RangeIndex from a range object . With arguments `data`, `dtype`.", "question_id": 37909}
{"snippet": "RangeIndex.from_range(data, name=None, dtype=None)", "intent": "Create RangeIndex from a range object . With arguments `data`, `name`, `dtype`.", "question_id": 37910}
{"snippet": "RangeIndex.from_range(data)", "intent": "Create RangeIndex from a range object . With arguments `data`.", "question_id": 37911}
{"snippet": "RangeIndex.from_range(data, name=None)", "intent": "Create RangeIndex from a range object . With arguments `data`, `name`.", "question_id": 37912}
{"snippet": "RangeIndex.from_range(data, dtype=None)", "intent": "Create RangeIndex from a range object . With arguments `data`, `dtype`.", "question_id": 37913}
{"snippet": "RangeIndex.from_range(data, name=None, dtype=None)", "intent": "Create RangeIndex from a range object . With arguments `data`, `name`, `dtype`.", "question_id": 37914}
{"snippet": "RangeIndex.from_range(data)", "intent": "Create RangeIndex from a range object . With arguments `data`.", "question_id": 37915}
{"snippet": "RangeIndex.from_range(data, name=None)", "intent": "Create RangeIndex from a range object . With arguments `data`, `name`.", "question_id": 37916}
{"snippet": "RangeIndex.from_range(data, dtype=None)", "intent": "Create RangeIndex from a range object . With arguments `data`, `dtype`.", "question_id": 37917}
{"snippet": "RangeIndex.from_range(data, name=None, dtype=None)", "intent": "Create RangeIndex from a range object . With arguments `data`, `name`, `dtype`.", "question_id": 37918}
{"snippet": "pandas.RangeIndex()", "intent": "Immutable Index implementing a monotonic integer range .", "question_id": 37919}
{"snippet": "pandas.RangeIndex(start=None)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `start`.", "question_id": 37920}
{"snippet": "pandas.RangeIndex(stop=None)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `stop`.", "question_id": 37921}
{"snippet": "pandas.RangeIndex(step=None)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `step`.", "question_id": 37922}
{"snippet": "pandas.RangeIndex(dtype=None)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `dtype`.", "question_id": 37923}
{"snippet": "pandas.RangeIndex(copy=False)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `copy`.", "question_id": 37924}
{"snippet": "pandas.RangeIndex(name=None)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `name`.", "question_id": 37925}
{"snippet": "pandas.RangeIndex(start=None, stop=None)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `start`, `stop`.", "question_id": 37926}
{"snippet": "pandas.RangeIndex(start=None, step=None)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `start`, `step`.", "question_id": 37927}
{"snippet": "pandas.RangeIndex(start=None, dtype=None)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `start`, `dtype`.", "question_id": 37928}
{"snippet": "pandas.RangeIndex()", "intent": "Immutable Index implementing a monotonic integer range .", "question_id": 37929}
{"snippet": "pandas.RangeIndex(start=None)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `start`.", "question_id": 37930}
{"snippet": "pandas.RangeIndex(stop=None)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `stop`.", "question_id": 37931}
{"snippet": "pandas.RangeIndex(step=None)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `step`.", "question_id": 37932}
{"snippet": "pandas.RangeIndex(dtype=None)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `dtype`.", "question_id": 37933}
{"snippet": "pandas.RangeIndex(copy=False)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `copy`.", "question_id": 37934}
{"snippet": "pandas.RangeIndex(name=None)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `name`.", "question_id": 37935}
{"snippet": "pandas.RangeIndex(start=None, stop=None)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `start`, `stop`.", "question_id": 37936}
{"snippet": "pandas.RangeIndex(start=None, step=None)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `start`, `step`.", "question_id": 37937}
{"snippet": "pandas.RangeIndex(start=None, dtype=None)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `start`, `dtype`.", "question_id": 37938}
{"snippet": "pandas.RangeIndex()", "intent": "Immutable Index implementing a monotonic integer range .", "question_id": 37939}
{"snippet": "pandas.RangeIndex(start=None)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `start`.", "question_id": 37940}
{"snippet": "pandas.RangeIndex(stop=None)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `stop`.", "question_id": 37941}
{"snippet": "pandas.RangeIndex(step=None)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `step`.", "question_id": 37942}
{"snippet": "pandas.RangeIndex(dtype=None)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `dtype`.", "question_id": 37943}
{"snippet": "pandas.RangeIndex(copy=False)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `copy`.", "question_id": 37944}
{"snippet": "pandas.RangeIndex(name=None)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `name`.", "question_id": 37945}
{"snippet": "pandas.RangeIndex(start=None, stop=None)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `start`, `stop`.", "question_id": 37946}
{"snippet": "pandas.RangeIndex(start=None, step=None)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `start`, `step`.", "question_id": 37947}
{"snippet": "pandas.RangeIndex(start=None, dtype=None)", "intent": "Immutable Index implementing a monotonic integer range . With arguments `start`, `dtype`.", "question_id": 37948}
{"snippet": "Series.__array__()", "intent": "Return the values as a NumPy array .", "question_id": 37949}
{"snippet": "Series.__array__(dtype=None)", "intent": "Return the values as a NumPy array . With arguments `dtype`.", "question_id": 37950}
{"snippet": "Series.__array__()", "intent": "Return the values as a NumPy array .", "question_id": 37951}
{"snippet": "Series.__array__(dtype=None)", "intent": "Return the values as a NumPy array . With arguments `dtype`.", "question_id": 37952}
{"snippet": "Series.__array__()", "intent": "Return the values as a NumPy array .", "question_id": 37953}
{"snippet": "Series.__array__(dtype=None)", "intent": "Return the values as a NumPy array . With arguments `dtype`.", "question_id": 37954}
{"snippet": "Series.__iter__()", "intent": "Return an iterator of the values .", "question_id": 37955}
{"snippet": "Series.__iter__()", "intent": "Return an iterator of the values .", "question_id": 37956}
{"snippet": "Series.__iter__()", "intent": "Return an iterator of the values .", "question_id": 37957}
{"snippet": "Series.abs()", "intent": "Return a Series/DataFrame with absolute numeric value of each element .", "question_id": 37958}
{"snippet": "Series.abs()", "intent": "Return a Series/DataFrame with absolute numeric value of each element .", "question_id": 37959}
{"snippet": "Series.abs()", "intent": "Return a Series/DataFrame with absolute numeric value of each element .", "question_id": 37960}
{"snippet": "Series.add(other)", "intent": "Return Addition of series and `other` , element-wise ( binary operator add ) .", "question_id": 37961}
{"snippet": "Series.add(other, level=None)", "intent": "Return Addition of series and `other` , element-wise ( binary operator add ) . With arguments `level`.", "question_id": 37962}
{"snippet": "Series.add(other, fill_value=None)", "intent": "Return Addition of series and `other` , element-wise ( binary operator add ) . Equivalent to series + other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 37963}
{"snippet": "Series.add(other, axis=0)", "intent": "Return Addition of series and `other` , element-wise ( binary operator add ) . With arguments `axis`.", "question_id": 37964}
{"snippet": "Series.add(other, level=None, fill_value=None)", "intent": "Return Addition of series and `other` , element-wise ( binary operator add ) . Equivalent to series + other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 37965}
{"snippet": "Series.add(other, level=None, axis=0)", "intent": "Return Addition of series and `other` , element-wise ( binary operator add ) . With arguments `level`, `axis`.", "question_id": 37966}
{"snippet": "Series.add(other, fill_value=None, axis=0)", "intent": "Return Addition of series and `other` , element-wise ( binary operator add ) . Equivalent to series + other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 37967}
{"snippet": "Series.add(other, level=None, fill_value=None, axis=0)", "intent": "Return Addition of series and `other` , element-wise ( binary operator add ) . Equivalent to series + other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 37968}
{"snippet": "Series.add(other)", "intent": "Return Addition of series and `other` , element-wise ( binary operator add ) .", "question_id": 37969}
{"snippet": "Series.add(other, level=None)", "intent": "Return Addition of series and `other` , element-wise ( binary operator add ) . With arguments `level`.", "question_id": 37970}
{"snippet": "Series.add(other, fill_value=None)", "intent": "Return Addition of series and `other` , element-wise ( binary operator add ) . Equivalent to series + other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 37971}
{"snippet": "Series.add(other, axis=0)", "intent": "Return Addition of series and `other` , element-wise ( binary operator add ) . With arguments `axis`.", "question_id": 37972}
{"snippet": "Series.add(other, level=None, fill_value=None)", "intent": "Return Addition of series and `other` , element-wise ( binary operator add ) . Equivalent to series + other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 37973}
{"snippet": "Series.add(other, level=None, axis=0)", "intent": "Return Addition of series and `other` , element-wise ( binary operator add ) . With arguments `level`, `axis`.", "question_id": 37974}
{"snippet": "Series.add(other, fill_value=None, axis=0)", "intent": "Return Addition of series and `other` , element-wise ( binary operator add ) . Equivalent to series + other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 37975}
{"snippet": "Series.add(other, level=None, fill_value=None, axis=0)", "intent": "Return Addition of series and `other` , element-wise ( binary operator add ) . Equivalent to series + other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 37976}
{"snippet": "Series.add(other)", "intent": "Return Addition of series and `other` , element-wise ( binary operator add ) .", "question_id": 37977}
{"snippet": "Series.add(other, level=None)", "intent": "Return Addition of series and `other` , element-wise ( binary operator add ) . With arguments `level`.", "question_id": 37978}
{"snippet": "Series.add(other, fill_value=None)", "intent": "Return Addition of series and `other` , element-wise ( binary operator add ) . Equivalent to series + other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 37979}
{"snippet": "Series.add(other, axis=0)", "intent": "Return Addition of series and `other` , element-wise ( binary operator add ) . With arguments `axis`.", "question_id": 37980}
{"snippet": "Series.add(other, level=None, fill_value=None)", "intent": "Return Addition of series and `other` , element-wise ( binary operator add ) . Equivalent to series + other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 37981}
{"snippet": "Series.add(other, level=None, axis=0)", "intent": "Return Addition of series and `other` , element-wise ( binary operator add ) . With arguments `level`, `axis`.", "question_id": 37982}
{"snippet": "Series.add(other, fill_value=None, axis=0)", "intent": "Return Addition of series and `other` , element-wise ( binary operator add ) . Equivalent to series + other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 37983}
{"snippet": "Series.add(other, level=None, fill_value=None, axis=0)", "intent": "Return Addition of series and `other` , element-wise ( binary operator add ) . Equivalent to series + other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 37984}
{"snippet": "Series.add_prefix(prefix)", "intent": "Prefix labels with string `prefix` .", "question_id": 37985}
{"snippet": "Series.add_prefix(prefix)", "intent": "Prefix labels with string `prefix` .", "question_id": 37986}
{"snippet": "Series.add_prefix(prefix)", "intent": "Prefix labels with string `prefix` .", "question_id": 37987}
{"snippet": "Series.add_suffix(suffix)", "intent": "Suffix labels with string `suffix` .", "question_id": 37988}
{"snippet": "Series.add_suffix(suffix)", "intent": "Suffix labels with string `suffix` .", "question_id": 37989}
{"snippet": "Series.add_suffix(suffix)", "intent": "Suffix labels with string `suffix` .", "question_id": 37990}
{"snippet": "Series.agg(*args, **kwargs)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 37991}
{"snippet": "Series.agg(*args, **kwargs, func=None)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`, `func`.", "question_id": 37992}
{"snippet": "Series.agg(*args, **kwargs, axis=0)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 37993}
{"snippet": "Series.agg(*args, **kwargs, func=None, axis=0)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`, `func`.", "question_id": 37994}
{"snippet": "Series.agg(*args, **kwargs)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 37995}
{"snippet": "Series.agg(*args, **kwargs, func=None)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`, `func`.", "question_id": 37996}
{"snippet": "Series.agg(*args, **kwargs, axis=0)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 37997}
{"snippet": "Series.agg(*args, **kwargs, func=None, axis=0)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`, `func`.", "question_id": 37998}
{"snippet": "Series.agg(*args, **kwargs)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 37999}
{"snippet": "Series.agg(*args, **kwargs, func=None)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`, `func`.", "question_id": 38000}
{"snippet": "Series.agg(*args, **kwargs, axis=0)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38001}
{"snippet": "Series.agg(*args, **kwargs, func=None, axis=0)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`, `func`.", "question_id": 38002}
{"snippet": "Series.aggregate(*args, **kwargs)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38003}
{"snippet": "Series.aggregate(*args, **kwargs, func=None)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`, `func`.", "question_id": 38004}
{"snippet": "Series.aggregate(*args, **kwargs, axis=0)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38005}
{"snippet": "Series.aggregate(*args, **kwargs, func=None, axis=0)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`, `func`.", "question_id": 38006}
{"snippet": "Series.aggregate(*args, **kwargs)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38007}
{"snippet": "Series.aggregate(*args, **kwargs, func=None)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`, `func`.", "question_id": 38008}
{"snippet": "Series.aggregate(*args, **kwargs, axis=0)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38009}
{"snippet": "Series.aggregate(*args, **kwargs, func=None, axis=0)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`, `func`.", "question_id": 38010}
{"snippet": "Series.aggregate(*args, **kwargs)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38011}
{"snippet": "Series.aggregate(*args, **kwargs, func=None)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`, `func`.", "question_id": 38012}
{"snippet": "Series.aggregate(*args, **kwargs, axis=0)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38013}
{"snippet": "Series.aggregate(*args, **kwargs, func=None, axis=0)", "intent": "Aggregate using one or more operations over the specified `axis` . With arguments `*args`, `**kwargs`, `func`.", "question_id": 38014}
{"snippet": "Series.align(other)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`.", "question_id": 38015}
{"snippet": "Series.align(other, join='outer')", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`.", "question_id": 38016}
{"snippet": "Series.align(other, axis=None)", "intent": "Align two objects on their axes with the specified `join` `method` . Join method is specified for each `axis` Index . With arguments `other`.", "question_id": 38017}
{"snippet": "Series.align(other, level=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `level`.", "question_id": 38018}
{"snippet": "Series.align(other, copy=True)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `copy`.", "question_id": 38019}
{"snippet": "Series.align(other, fill_value=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `fill_value`.", "question_id": 38020}
{"snippet": "Series.align(other, method=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`.", "question_id": 38021}
{"snippet": "Series.align(other, limit=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `limit`.", "question_id": 38022}
{"snippet": "Series.align(other, fill_axis=0)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `fill_axis`.", "question_id": 38023}
{"snippet": "Series.align(other, broadcast_axis=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `broadcast_axis`.", "question_id": 38024}
{"snippet": "Series.align(other)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`.", "question_id": 38025}
{"snippet": "Series.align(other, join='outer')", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`.", "question_id": 38026}
{"snippet": "Series.align(other, axis=None)", "intent": "Align two objects on their axes with the specified `join` `method` . Join method is specified for each `axis` Index . With arguments `other`.", "question_id": 38027}
{"snippet": "Series.align(other, level=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `level`.", "question_id": 38028}
{"snippet": "Series.align(other, copy=True)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `copy`.", "question_id": 38029}
{"snippet": "Series.align(other, fill_value=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `fill_value`.", "question_id": 38030}
{"snippet": "Series.align(other, method=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`.", "question_id": 38031}
{"snippet": "Series.align(other, limit=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `limit`.", "question_id": 38032}
{"snippet": "Series.align(other, fill_axis=0)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `fill_axis`.", "question_id": 38033}
{"snippet": "Series.align(other, broadcast_axis=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `broadcast_axis`.", "question_id": 38034}
{"snippet": "Series.align(other)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`.", "question_id": 38035}
{"snippet": "Series.align(other, join='outer')", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`.", "question_id": 38036}
{"snippet": "Series.align(other, axis=None)", "intent": "Align two objects on their axes with the specified `join` `method` . Join method is specified for each `axis` Index . With arguments `other`.", "question_id": 38037}
{"snippet": "Series.align(other, level=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `level`.", "question_id": 38038}
{"snippet": "Series.align(other, copy=True)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `copy`.", "question_id": 38039}
{"snippet": "Series.align(other, fill_value=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `fill_value`.", "question_id": 38040}
{"snippet": "Series.align(other, method=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`.", "question_id": 38041}
{"snippet": "Series.align(other, limit=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `limit`.", "question_id": 38042}
{"snippet": "Series.align(other, fill_axis=0)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `fill_axis`.", "question_id": 38043}
{"snippet": "Series.align(other, broadcast_axis=None)", "intent": "Align two objects on their axes with the specified `join` `method` . With arguments `other`, `broadcast_axis`.", "question_id": 38044}
{"snippet": "Series.all(**kwargs)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`.", "question_id": 38045}
{"snippet": "Series.all(**kwargs, axis=0)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`.", "question_id": 38046}
{"snippet": "Series.all(**kwargs, bool_only=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`.", "question_id": 38047}
{"snippet": "Series.all(**kwargs, skipna=True)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 38048}
{"snippet": "Series.all(**kwargs, level=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `level`.", "question_id": 38049}
{"snippet": "Series.all(**kwargs, axis=0, bool_only=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`.", "question_id": 38050}
{"snippet": "Series.all(**kwargs, axis=0, skipna=True)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 38051}
{"snippet": "Series.all(**kwargs, axis=0, level=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `level`.", "question_id": 38052}
{"snippet": "Series.all(**kwargs, bool_only=None, skipna=True)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`, `skipna`.", "question_id": 38053}
{"snippet": "Series.all(**kwargs, bool_only=None, level=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`, `level`.", "question_id": 38054}
{"snippet": "Series.all(**kwargs)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`.", "question_id": 38055}
{"snippet": "Series.all(**kwargs, axis=0)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`.", "question_id": 38056}
{"snippet": "Series.all(**kwargs, bool_only=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`.", "question_id": 38057}
{"snippet": "Series.all(**kwargs, skipna=True)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 38058}
{"snippet": "Series.all(**kwargs, level=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `level`.", "question_id": 38059}
{"snippet": "Series.all(**kwargs, axis=0, bool_only=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`.", "question_id": 38060}
{"snippet": "Series.all(**kwargs, axis=0, skipna=True)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 38061}
{"snippet": "Series.all(**kwargs, axis=0, level=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `level`.", "question_id": 38062}
{"snippet": "Series.all(**kwargs, bool_only=None, skipna=True)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`, `skipna`.", "question_id": 38063}
{"snippet": "Series.all(**kwargs, bool_only=None, level=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`, `level`.", "question_id": 38064}
{"snippet": "Series.all(**kwargs)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`.", "question_id": 38065}
{"snippet": "Series.all(**kwargs, axis=0)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`.", "question_id": 38066}
{"snippet": "Series.all(**kwargs, bool_only=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`.", "question_id": 38067}
{"snippet": "Series.all(**kwargs, skipna=True)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 38068}
{"snippet": "Series.all(**kwargs, level=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `level`.", "question_id": 38069}
{"snippet": "Series.all(**kwargs, axis=0, bool_only=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`.", "question_id": 38070}
{"snippet": "Series.all(**kwargs, axis=0, skipna=True)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 38071}
{"snippet": "Series.all(**kwargs, axis=0, level=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `level`.", "question_id": 38072}
{"snippet": "Series.all(**kwargs, bool_only=None, skipna=True)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`, `skipna`.", "question_id": 38073}
{"snippet": "Series.all(**kwargs, bool_only=None, level=None)", "intent": "Return whether all elements are True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`, `level`.", "question_id": 38074}
{"snippet": "Series.any(**kwargs)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`.", "question_id": 38075}
{"snippet": "Series.any(**kwargs, axis=0)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`.", "question_id": 38076}
{"snippet": "Series.any(**kwargs, bool_only=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`.", "question_id": 38077}
{"snippet": "Series.any(**kwargs, skipna=True)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 38078}
{"snippet": "Series.any(**kwargs, level=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `level`.", "question_id": 38079}
{"snippet": "Series.any(**kwargs, axis=0, bool_only=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`.", "question_id": 38080}
{"snippet": "Series.any(**kwargs, axis=0, skipna=True)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 38081}
{"snippet": "Series.any(**kwargs, axis=0, level=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `level`.", "question_id": 38082}
{"snippet": "Series.any(**kwargs, bool_only=None, skipna=True)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`, `skipna`.", "question_id": 38083}
{"snippet": "Series.any(**kwargs, bool_only=None, level=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`, `level`.", "question_id": 38084}
{"snippet": "Series.any(**kwargs)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`.", "question_id": 38085}
{"snippet": "Series.any(**kwargs, axis=0)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`.", "question_id": 38086}
{"snippet": "Series.any(**kwargs, bool_only=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`.", "question_id": 38087}
{"snippet": "Series.any(**kwargs, skipna=True)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 38088}
{"snippet": "Series.any(**kwargs, level=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `level`.", "question_id": 38089}
{"snippet": "Series.any(**kwargs, axis=0, bool_only=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`.", "question_id": 38090}
{"snippet": "Series.any(**kwargs, axis=0, skipna=True)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 38091}
{"snippet": "Series.any(**kwargs, axis=0, level=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `level`.", "question_id": 38092}
{"snippet": "Series.any(**kwargs, bool_only=None, skipna=True)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`, `skipna`.", "question_id": 38093}
{"snippet": "Series.any(**kwargs, bool_only=None, level=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`, `level`.", "question_id": 38094}
{"snippet": "Series.any(**kwargs)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`.", "question_id": 38095}
{"snippet": "Series.any(**kwargs, axis=0)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`.", "question_id": 38096}
{"snippet": "Series.any(**kwargs, bool_only=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`.", "question_id": 38097}
{"snippet": "Series.any(**kwargs, skipna=True)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 38098}
{"snippet": "Series.any(**kwargs, level=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `level`.", "question_id": 38099}
{"snippet": "Series.any(**kwargs, axis=0, bool_only=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`.", "question_id": 38100}
{"snippet": "Series.any(**kwargs, axis=0, skipna=True)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 38101}
{"snippet": "Series.any(**kwargs, axis=0, level=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `level`.", "question_id": 38102}
{"snippet": "Series.any(**kwargs, bool_only=None, skipna=True)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`, `skipna`.", "question_id": 38103}
{"snippet": "Series.any(**kwargs, bool_only=None, level=None)", "intent": "Return whether any element is True , potentially over an `axis` . With arguments `**kwargs`, `bool_only`, `level`.", "question_id": 38104}
{"snippet": "Series.append(to_append)", "intent": "Concatenate two or more Series . With arguments `to_append`.", "question_id": 38105}
{"snippet": "Series.append(to_append, ignore_index=False)", "intent": "Concatenate two or more Series . With `ignore_index` set to True : With arguments `to_append`.", "question_id": 38106}
{"snippet": "Series.append(to_append, verify_integrity=False)", "intent": "Concatenate two or more Series . With `verify_integrity` set to True : With arguments `to_append`.", "question_id": 38107}
{"snippet": "Series.append(to_append, ignore_index=False, verify_integrity=False)", "intent": "Concatenate two or more Series . With `ignore_index` set to True : With `verify_integrity` set to True : With arguments `to_append`.", "question_id": 38108}
{"snippet": "Series.append(to_append)", "intent": "Concatenate two or more Series . With arguments `to_append`.", "question_id": 38109}
{"snippet": "Series.append(to_append, ignore_index=False)", "intent": "Concatenate two or more Series . With `ignore_index` set to True : With arguments `to_append`.", "question_id": 38110}
{"snippet": "Series.append(to_append, verify_integrity=False)", "intent": "Concatenate two or more Series . With `verify_integrity` set to True : With arguments `to_append`.", "question_id": 38111}
{"snippet": "Series.append(to_append, ignore_index=False, verify_integrity=False)", "intent": "Concatenate two or more Series . With `ignore_index` set to True : With `verify_integrity` set to True : With arguments `to_append`.", "question_id": 38112}
{"snippet": "Series.append(to_append)", "intent": "Concatenate two or more Series . With arguments `to_append`.", "question_id": 38113}
{"snippet": "Series.append(to_append, ignore_index=False)", "intent": "Concatenate two or more Series . With `ignore_index` set to True : With arguments `to_append`.", "question_id": 38114}
{"snippet": "Series.append(to_append, verify_integrity=False)", "intent": "Concatenate two or more Series . With `verify_integrity` set to True : With arguments `to_append`.", "question_id": 38115}
{"snippet": "Series.append(to_append, ignore_index=False, verify_integrity=False)", "intent": "Concatenate two or more Series . With `ignore_index` set to True : With `verify_integrity` set to True : With arguments `to_append`.", "question_id": 38116}
{"snippet": "Series.apply(func, **kwargs)", "intent": "Invoke function on values of Series . With arguments `func`, `**kwargs`.", "question_id": 38117}
{"snippet": "Series.apply(func, **kwargs, convert_dtype=True)", "intent": "Invoke function on values of Series . With arguments `func`, `**kwargs`, `convert_dtype`.", "question_id": 38118}
{"snippet": "Series.apply(func, **kwargs, args=())", "intent": "Invoke function on values of Series . Define a custom function that needs additional positional arguments and pass these additional arguments using the `args` keyword . With arguments `func`, `**kwargs`.", "question_id": 38119}
{"snippet": "Series.apply(func, **kwargs, convert_dtype=True, args=())", "intent": "Invoke function on values of Series . Define a custom function that needs additional positional arguments and pass these additional arguments using the `args` keyword . With arguments `func`, `**kwargs`, `convert_dtype`.", "question_id": 38120}
{"snippet": "Series.apply(func, **kwargs)", "intent": "Invoke function on values of Series . With arguments `func`, `**kwargs`.", "question_id": 38121}
{"snippet": "Series.apply(func, **kwargs, convert_dtype=True)", "intent": "Invoke function on values of Series . With arguments `func`, `**kwargs`, `convert_dtype`.", "question_id": 38122}
{"snippet": "Series.apply(func, **kwargs, args=())", "intent": "Invoke function on values of Series . Define a custom function that needs additional positional arguments and pass these additional arguments using the `args` keyword . With arguments `func`, `**kwargs`.", "question_id": 38123}
{"snippet": "Series.apply(func, **kwargs, convert_dtype=True, args=())", "intent": "Invoke function on values of Series . Define a custom function that needs additional positional arguments and pass these additional arguments using the `args` keyword . With arguments `func`, `**kwargs`, `convert_dtype`.", "question_id": 38124}
{"snippet": "Series.apply(func, **kwargs)", "intent": "Invoke function on values of Series . With arguments `func`, `**kwargs`.", "question_id": 38125}
{"snippet": "Series.apply(func, **kwargs, convert_dtype=True)", "intent": "Invoke function on values of Series . With arguments `func`, `**kwargs`, `convert_dtype`.", "question_id": 38126}
{"snippet": "Series.apply(func, **kwargs, args=())", "intent": "Invoke function on values of Series . Define a custom function that needs additional positional arguments and pass these additional arguments using the `args` keyword . With arguments `func`, `**kwargs`.", "question_id": 38127}
{"snippet": "Series.apply(func, **kwargs, convert_dtype=True, args=())", "intent": "Invoke function on values of Series . Define a custom function that needs additional positional arguments and pass these additional arguments using the `args` keyword . With arguments `func`, `**kwargs`, `convert_dtype`.", "question_id": 38128}
{"snippet": "Series.argmax(*args, **kwargs)", "intent": "Return int position of the largest value in the Series . With arguments `*args`, `**kwargs`.", "question_id": 38129}
{"snippet": "Series.argmax(*args, **kwargs, axis=None)", "intent": "Return int position of the largest value in the Series . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 38130}
{"snippet": "Series.argmax(*args, **kwargs, skipna=True)", "intent": "Return int position of the largest value in the Series . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38131}
{"snippet": "Series.argmax(*args, **kwargs, axis=None, skipna=True)", "intent": "Return int position of the largest value in the Series . With arguments `*args`, `**kwargs`, `axis`, `skipna`.", "question_id": 38132}
{"snippet": "Series.argmax(*args, **kwargs)", "intent": "Return int position of the largest value in the Series . With arguments `*args`, `**kwargs`.", "question_id": 38133}
{"snippet": "Series.argmax(*args, **kwargs, axis=None)", "intent": "Return int position of the largest value in the Series . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 38134}
{"snippet": "Series.argmax(*args, **kwargs, skipna=True)", "intent": "Return int position of the largest value in the Series . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38135}
{"snippet": "Series.argmax(*args, **kwargs, axis=None, skipna=True)", "intent": "Return int position of the largest value in the Series . With arguments `*args`, `**kwargs`, `axis`, `skipna`.", "question_id": 38136}
{"snippet": "Series.argmax(*args, **kwargs)", "intent": "Return int position of the largest value in the Series . With arguments `*args`, `**kwargs`.", "question_id": 38137}
{"snippet": "Series.argmax(*args, **kwargs, axis=None)", "intent": "Return int position of the largest value in the Series . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 38138}
{"snippet": "Series.argmax(*args, **kwargs, skipna=True)", "intent": "Return int position of the largest value in the Series . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38139}
{"snippet": "Series.argmax(*args, **kwargs, axis=None, skipna=True)", "intent": "Return int position of the largest value in the Series . With arguments `*args`, `**kwargs`, `axis`, `skipna`.", "question_id": 38140}
{"snippet": "Series.argmin(*args, **kwargs)", "intent": "Return int position of the smallest value in the Series . With arguments `*args`, `**kwargs`.", "question_id": 38141}
{"snippet": "Series.argmin(*args, **kwargs, axis=None)", "intent": "Return int position of the smallest value in the Series . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 38142}
{"snippet": "Series.argmin(*args, **kwargs, skipna=True)", "intent": "Return int position of the smallest value in the Series . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38143}
{"snippet": "Series.argmin(*args, **kwargs, axis=None, skipna=True)", "intent": "Return int position of the smallest value in the Series . With arguments `*args`, `**kwargs`, `axis`, `skipna`.", "question_id": 38144}
{"snippet": "Series.argmin(*args, **kwargs)", "intent": "Return int position of the smallest value in the Series . With arguments `*args`, `**kwargs`.", "question_id": 38145}
{"snippet": "Series.argmin(*args, **kwargs, axis=None)", "intent": "Return int position of the smallest value in the Series . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 38146}
{"snippet": "Series.argmin(*args, **kwargs, skipna=True)", "intent": "Return int position of the smallest value in the Series . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38147}
{"snippet": "Series.argmin(*args, **kwargs, axis=None, skipna=True)", "intent": "Return int position of the smallest value in the Series . With arguments `*args`, `**kwargs`, `axis`, `skipna`.", "question_id": 38148}
{"snippet": "Series.argmin(*args, **kwargs)", "intent": "Return int position of the smallest value in the Series . With arguments `*args`, `**kwargs`.", "question_id": 38149}
{"snippet": "Series.argmin(*args, **kwargs, axis=None)", "intent": "Return int position of the smallest value in the Series . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 38150}
{"snippet": "Series.argmin(*args, **kwargs, skipna=True)", "intent": "Return int position of the smallest value in the Series . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38151}
{"snippet": "Series.argmin(*args, **kwargs, axis=None, skipna=True)", "intent": "Return int position of the smallest value in the Series . With arguments `*args`, `**kwargs`, `axis`, `skipna`.", "question_id": 38152}
{"snippet": "Series.argsort()", "intent": "Return the integer indices that would sort the Series values .", "question_id": 38153}
{"snippet": "Series.argsort(axis=0)", "intent": "Return the integer indices that would sort the Series values . With arguments `axis`.", "question_id": 38154}
{"snippet": "Series.argsort(kind='quicksort')", "intent": "Return the integer indices that would sort the Series values . With arguments `kind`.", "question_id": 38155}
{"snippet": "Series.argsort(order=None)", "intent": "Return the integer indices that would sort the Series values . With arguments `order`.", "question_id": 38156}
{"snippet": "Series.argsort(axis=0, kind='quicksort')", "intent": "Return the integer indices that would sort the Series values . With arguments `axis`, `kind`.", "question_id": 38157}
{"snippet": "Series.argsort(axis=0, order=None)", "intent": "Return the integer indices that would sort the Series values . With arguments `axis`, `order`.", "question_id": 38158}
{"snippet": "Series.argsort(kind='quicksort', order=None)", "intent": "Return the integer indices that would sort the Series values . With arguments `kind`, `order`.", "question_id": 38159}
{"snippet": "Series.argsort(axis=0, kind='quicksort', order=None)", "intent": "Return the integer indices that would sort the Series values . With arguments `axis`, `kind`, `order`.", "question_id": 38160}
{"snippet": "Series.argsort()", "intent": "Return the integer indices that would sort the Series values .", "question_id": 38161}
{"snippet": "Series.argsort(axis=0)", "intent": "Return the integer indices that would sort the Series values . With arguments `axis`.", "question_id": 38162}
{"snippet": "Series.argsort(kind='quicksort')", "intent": "Return the integer indices that would sort the Series values . With arguments `kind`.", "question_id": 38163}
{"snippet": "Series.argsort(order=None)", "intent": "Return the integer indices that would sort the Series values . With arguments `order`.", "question_id": 38164}
{"snippet": "Series.argsort(axis=0, kind='quicksort')", "intent": "Return the integer indices that would sort the Series values . With arguments `axis`, `kind`.", "question_id": 38165}
{"snippet": "Series.argsort(axis=0, order=None)", "intent": "Return the integer indices that would sort the Series values . With arguments `axis`, `order`.", "question_id": 38166}
{"snippet": "Series.argsort(kind='quicksort', order=None)", "intent": "Return the integer indices that would sort the Series values . With arguments `kind`, `order`.", "question_id": 38167}
{"snippet": "Series.argsort(axis=0, kind='quicksort', order=None)", "intent": "Return the integer indices that would sort the Series values . With arguments `axis`, `kind`, `order`.", "question_id": 38168}
{"snippet": "Series.argsort()", "intent": "Return the integer indices that would sort the Series values .", "question_id": 38169}
{"snippet": "Series.argsort(axis=0)", "intent": "Return the integer indices that would sort the Series values . With arguments `axis`.", "question_id": 38170}
{"snippet": "Series.argsort(kind='quicksort')", "intent": "Return the integer indices that would sort the Series values . With arguments `kind`.", "question_id": 38171}
{"snippet": "Series.argsort(order=None)", "intent": "Return the integer indices that would sort the Series values . With arguments `order`.", "question_id": 38172}
{"snippet": "Series.argsort(axis=0, kind='quicksort')", "intent": "Return the integer indices that would sort the Series values . With arguments `axis`, `kind`.", "question_id": 38173}
{"snippet": "Series.argsort(axis=0, order=None)", "intent": "Return the integer indices that would sort the Series values . With arguments `axis`, `order`.", "question_id": 38174}
{"snippet": "Series.argsort(kind='quicksort', order=None)", "intent": "Return the integer indices that would sort the Series values . With arguments `kind`, `order`.", "question_id": 38175}
{"snippet": "Series.argsort(axis=0, kind='quicksort', order=None)", "intent": "Return the integer indices that would sort the Series values . With arguments `axis`, `kind`, `order`.", "question_id": 38176}
{"snippet": "Series.asfreq(freq)", "intent": "Convert time series to specified frequency . With arguments `freq`.", "question_id": 38177}
{"snippet": "Series.asfreq(freq, method=None)", "intent": "Convert time series to specified frequency . The values corresponding to any timesteps in the new index which were not present in the original index will be null ( NaN ) , unless a `method` for filling such unknowns is provided ( see the method parameter below ) . With arguments `freq`.", "question_id": 38178}
{"snippet": "Series.asfreq(freq, how=None)", "intent": "Convert time series to specified frequency . With arguments `freq`, `how`.", "question_id": 38179}
{"snippet": "Series.asfreq(freq, normalize=False)", "intent": "Convert time series to specified frequency . With arguments `freq`, `normalize`.", "question_id": 38180}
{"snippet": "Series.asfreq(freq, fill_value=None)", "intent": "Convert time series to specified frequency . With arguments `freq`, `fill_value`.", "question_id": 38181}
{"snippet": "Series.asfreq(freq, method=None, how=None)", "intent": "Convert time series to specified frequency . The values corresponding to any timesteps in the new index which were not present in the original index will be null ( NaN ) , unless a `method` for filling such unknowns is provided ( see the method parameter below ) . With arguments `freq`, `how`.", "question_id": 38182}
{"snippet": "Series.asfreq(freq, method=None, normalize=False)", "intent": "Convert time series to specified frequency . The values corresponding to any timesteps in the new index which were not present in the original index will be null ( NaN ) , unless a `method` for filling such unknowns is provided ( see the method parameter below ) . With arguments `freq`, `normalize`.", "question_id": 38183}
{"snippet": "Series.asfreq(freq, method=None, fill_value=None)", "intent": "Convert time series to specified frequency . The values corresponding to any timesteps in the new index which were not present in the original index will be null ( NaN ) , unless a `method` for filling such unknowns is provided ( see the method parameter below ) . With arguments `freq`, `fill_value`.", "question_id": 38184}
{"snippet": "Series.asfreq(freq, how=None, normalize=False)", "intent": "Convert time series to specified frequency . With arguments `freq`, `how`, `normalize`.", "question_id": 38185}
{"snippet": "Series.asfreq(freq, how=None, fill_value=None)", "intent": "Convert time series to specified frequency . With arguments `freq`, `how`, `fill_value`.", "question_id": 38186}
{"snippet": "Series.asfreq(freq)", "intent": "Convert time series to specified frequency . With arguments `freq`.", "question_id": 38187}
{"snippet": "Series.asfreq(freq, method=None)", "intent": "Convert time series to specified frequency . The values corresponding to any timesteps in the new index which were not present in the original index will be null ( NaN ) , unless a `method` for filling such unknowns is provided ( see the method parameter below ) . With arguments `freq`.", "question_id": 38188}
{"snippet": "Series.asfreq(freq, how=None)", "intent": "Convert time series to specified frequency . With arguments `freq`, `how`.", "question_id": 38189}
{"snippet": "Series.asfreq(freq, normalize=False)", "intent": "Convert time series to specified frequency . With arguments `freq`, `normalize`.", "question_id": 38190}
{"snippet": "Series.asfreq(freq, fill_value=None)", "intent": "Convert time series to specified frequency . With arguments `freq`, `fill_value`.", "question_id": 38191}
{"snippet": "Series.asfreq(freq, method=None, how=None)", "intent": "Convert time series to specified frequency . The values corresponding to any timesteps in the new index which were not present in the original index will be null ( NaN ) , unless a `method` for filling such unknowns is provided ( see the method parameter below ) . With arguments `freq`, `how`.", "question_id": 38192}
{"snippet": "Series.asfreq(freq, method=None, normalize=False)", "intent": "Convert time series to specified frequency . The values corresponding to any timesteps in the new index which were not present in the original index will be null ( NaN ) , unless a `method` for filling such unknowns is provided ( see the method parameter below ) . With arguments `freq`, `normalize`.", "question_id": 38193}
{"snippet": "Series.asfreq(freq, method=None, fill_value=None)", "intent": "Convert time series to specified frequency . The values corresponding to any timesteps in the new index which were not present in the original index will be null ( NaN ) , unless a `method` for filling such unknowns is provided ( see the method parameter below ) . With arguments `freq`, `fill_value`.", "question_id": 38194}
{"snippet": "Series.asfreq(freq, how=None, normalize=False)", "intent": "Convert time series to specified frequency . With arguments `freq`, `how`, `normalize`.", "question_id": 38195}
{"snippet": "Series.asfreq(freq, how=None, fill_value=None)", "intent": "Convert time series to specified frequency . With arguments `freq`, `how`, `fill_value`.", "question_id": 38196}
{"snippet": "Series.asfreq(freq)", "intent": "Convert time series to specified frequency . With arguments `freq`.", "question_id": 38197}
{"snippet": "Series.asfreq(freq, method=None)", "intent": "Convert time series to specified frequency . The values corresponding to any timesteps in the new index which were not present in the original index will be null ( NaN ) , unless a `method` for filling such unknowns is provided ( see the method parameter below ) . With arguments `freq`.", "question_id": 38198}
{"snippet": "Series.asfreq(freq, how=None)", "intent": "Convert time series to specified frequency . With arguments `freq`, `how`.", "question_id": 38199}
{"snippet": "Series.asfreq(freq, normalize=False)", "intent": "Convert time series to specified frequency . With arguments `freq`, `normalize`.", "question_id": 38200}
{"snippet": "Series.asfreq(freq, fill_value=None)", "intent": "Convert time series to specified frequency . With arguments `freq`, `fill_value`.", "question_id": 38201}
{"snippet": "Series.asfreq(freq, method=None, how=None)", "intent": "Convert time series to specified frequency . The values corresponding to any timesteps in the new index which were not present in the original index will be null ( NaN ) , unless a `method` for filling such unknowns is provided ( see the method parameter below ) . With arguments `freq`, `how`.", "question_id": 38202}
{"snippet": "Series.asfreq(freq, method=None, normalize=False)", "intent": "Convert time series to specified frequency . The values corresponding to any timesteps in the new index which were not present in the original index will be null ( NaN ) , unless a `method` for filling such unknowns is provided ( see the method parameter below ) . With arguments `freq`, `normalize`.", "question_id": 38203}
{"snippet": "Series.asfreq(freq, method=None, fill_value=None)", "intent": "Convert time series to specified frequency . The values corresponding to any timesteps in the new index which were not present in the original index will be null ( NaN ) , unless a `method` for filling such unknowns is provided ( see the method parameter below ) . With arguments `freq`, `fill_value`.", "question_id": 38204}
{"snippet": "Series.asfreq(freq, how=None, normalize=False)", "intent": "Convert time series to specified frequency . With arguments `freq`, `how`, `normalize`.", "question_id": 38205}
{"snippet": "Series.asfreq(freq, how=None, fill_value=None)", "intent": "Convert time series to specified frequency . With arguments `freq`, `how`, `fill_value`.", "question_id": 38206}
{"snippet": "Series.asof(where)", "intent": "Return the last row ( s ) without any NaNs before `where` .", "question_id": 38207}
{"snippet": "Series.asof(where, subset=None)", "intent": "Return the last row ( s ) without any NaNs before `where` . In case of a DataFrame , the last row without NaN considering only the `subset` of columns ( if not None )", "question_id": 38208}
{"snippet": "Series.asof(where)", "intent": "Return the last row ( s ) without any NaNs before `where` .", "question_id": 38209}
{"snippet": "Series.asof(where, subset=None)", "intent": "Return the last row ( s ) without any NaNs before `where` . In case of a DataFrame , the last row without NaN considering only the `subset` of columns ( if not None )", "question_id": 38210}
{"snippet": "Series.asof(where)", "intent": "Return the last row ( s ) without any NaNs before `where` .", "question_id": 38211}
{"snippet": "Series.asof(where, subset=None)", "intent": "Return the last row ( s ) without any NaNs before `where` . In case of a DataFrame , the last row without NaN considering only the `subset` of columns ( if not None )", "question_id": 38212}
{"snippet": "Series.astype(dtype)", "intent": "Cast a pandas object to a specified `dtype` dtype .", "question_id": 38213}
{"snippet": "Series.astype(dtype, copy=True)", "intent": "Cast a pandas object to a specified `dtype` dtype . With arguments `copy`.", "question_id": 38214}
{"snippet": "Series.astype(dtype, errors='raise')", "intent": "Cast a pandas object to a specified `dtype` dtype . With arguments `errors`.", "question_id": 38215}
{"snippet": "Series.astype(dtype, copy=True, errors='raise')", "intent": "Cast a pandas object to a specified `dtype` dtype . With arguments `copy`, `errors`.", "question_id": 38216}
{"snippet": "Series.astype(dtype)", "intent": "Cast a pandas object to a specified `dtype` dtype .", "question_id": 38217}
{"snippet": "Series.astype(dtype, copy=True)", "intent": "Cast a pandas object to a specified `dtype` dtype . With arguments `copy`.", "question_id": 38218}
{"snippet": "Series.astype(dtype, errors='raise')", "intent": "Cast a pandas object to a specified `dtype` dtype . With arguments `errors`.", "question_id": 38219}
{"snippet": "Series.astype(dtype, copy=True, errors='raise')", "intent": "Cast a pandas object to a specified `dtype` dtype . With arguments `copy`, `errors`.", "question_id": 38220}
{"snippet": "Series.astype(dtype)", "intent": "Cast a pandas object to a specified `dtype` dtype .", "question_id": 38221}
{"snippet": "Series.astype(dtype, copy=True)", "intent": "Cast a pandas object to a specified `dtype` dtype . With arguments `copy`.", "question_id": 38222}
{"snippet": "Series.astype(dtype, errors='raise')", "intent": "Cast a pandas object to a specified `dtype` dtype . With arguments `errors`.", "question_id": 38223}
{"snippet": "Series.astype(dtype, copy=True, errors='raise')", "intent": "Cast a pandas object to a specified `dtype` dtype . With arguments `copy`, `errors`.", "question_id": 38224}
{"snippet": "Series.at_time(time)", "intent": "Select values at particular `time` of day ( e.g. , 9:30AM ) .", "question_id": 38225}
{"snippet": "Series.at_time(time, asof=False)", "intent": "Select values at particular `time` of day ( e.g. , 9:30AM ) . With arguments `asof`.", "question_id": 38226}
{"snippet": "Series.at_time(time, axis=None)", "intent": "Select values at particular `time` of day ( e.g. , 9:30AM ) . With arguments `axis`.", "question_id": 38227}
{"snippet": "Series.at_time(time, asof=False, axis=None)", "intent": "Select values at particular `time` of day ( e.g. , 9:30AM ) . With arguments `asof`, `axis`.", "question_id": 38228}
{"snippet": "Series.at_time(time)", "intent": "Select values at particular `time` of day ( e.g. , 9:30AM ) .", "question_id": 38229}
{"snippet": "Series.at_time(time, asof=False)", "intent": "Select values at particular `time` of day ( e.g. , 9:30AM ) . With arguments `asof`.", "question_id": 38230}
{"snippet": "Series.at_time(time, axis=None)", "intent": "Select values at particular `time` of day ( e.g. , 9:30AM ) . With arguments `axis`.", "question_id": 38231}
{"snippet": "Series.at_time(time, asof=False, axis=None)", "intent": "Select values at particular `time` of day ( e.g. , 9:30AM ) . With arguments `asof`, `axis`.", "question_id": 38232}
{"snippet": "Series.at_time(time)", "intent": "Select values at particular `time` of day ( e.g. , 9:30AM ) .", "question_id": 38233}
{"snippet": "Series.at_time(time, asof=False)", "intent": "Select values at particular `time` of day ( e.g. , 9:30AM ) . With arguments `asof`.", "question_id": 38234}
{"snippet": "Series.at_time(time, axis=None)", "intent": "Select values at particular `time` of day ( e.g. , 9:30AM ) . With arguments `axis`.", "question_id": 38235}
{"snippet": "Series.at_time(time, asof=False, axis=None)", "intent": "Select values at particular `time` of day ( e.g. , 9:30AM ) . With arguments `asof`, `axis`.", "question_id": 38236}
{"snippet": "Series.autocorr()", "intent": "Compute the lag-N autocorrelation .", "question_id": 38237}
{"snippet": "Series.autocorr(lag=1)", "intent": "Compute the lag-N autocorrelation . With arguments `lag`.", "question_id": 38238}
{"snippet": "Series.autocorr()", "intent": "Compute the lag-N autocorrelation .", "question_id": 38239}
{"snippet": "Series.autocorr(lag=1)", "intent": "Compute the lag-N autocorrelation . With arguments `lag`.", "question_id": 38240}
{"snippet": "Series.autocorr()", "intent": "Compute the lag-N autocorrelation .", "question_id": 38241}
{"snippet": "Series.autocorr(lag=1)", "intent": "Compute the lag-N autocorrelation . With arguments `lag`.", "question_id": 38242}
{"snippet": "Series.backfill()", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' .", "question_id": 38243}
{"snippet": "Series.backfill(axis=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`.", "question_id": 38244}
{"snippet": "Series.backfill(inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`.", "question_id": 38245}
{"snippet": "Series.backfill(limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `limit`.", "question_id": 38246}
{"snippet": "Series.backfill(downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `downcast`.", "question_id": 38247}
{"snippet": "Series.backfill(axis=None, inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `inplace`.", "question_id": 38248}
{"snippet": "Series.backfill(axis=None, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `limit`.", "question_id": 38249}
{"snippet": "Series.backfill(axis=None, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `downcast`.", "question_id": 38250}
{"snippet": "Series.backfill(inplace=False, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`, `limit`.", "question_id": 38251}
{"snippet": "Series.backfill(inplace=False, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`, `downcast`.", "question_id": 38252}
{"snippet": "Series.backfill()", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' .", "question_id": 38253}
{"snippet": "Series.backfill(axis=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`.", "question_id": 38254}
{"snippet": "Series.backfill(inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`.", "question_id": 38255}
{"snippet": "Series.backfill(limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `limit`.", "question_id": 38256}
{"snippet": "Series.backfill(downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `downcast`.", "question_id": 38257}
{"snippet": "Series.backfill(axis=None, inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `inplace`.", "question_id": 38258}
{"snippet": "Series.backfill(axis=None, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `limit`.", "question_id": 38259}
{"snippet": "Series.backfill(axis=None, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `downcast`.", "question_id": 38260}
{"snippet": "Series.backfill(inplace=False, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`, `limit`.", "question_id": 38261}
{"snippet": "Series.backfill(inplace=False, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`, `downcast`.", "question_id": 38262}
{"snippet": "Series.backfill()", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' .", "question_id": 38263}
{"snippet": "Series.backfill(axis=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`.", "question_id": 38264}
{"snippet": "Series.backfill(inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`.", "question_id": 38265}
{"snippet": "Series.backfill(limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `limit`.", "question_id": 38266}
{"snippet": "Series.backfill(downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `downcast`.", "question_id": 38267}
{"snippet": "Series.backfill(axis=None, inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `inplace`.", "question_id": 38268}
{"snippet": "Series.backfill(axis=None, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `limit`.", "question_id": 38269}
{"snippet": "Series.backfill(axis=None, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `downcast`.", "question_id": 38270}
{"snippet": "Series.backfill(inplace=False, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`, `limit`.", "question_id": 38271}
{"snippet": "Series.backfill(inplace=False, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`, `downcast`.", "question_id": 38272}
{"snippet": "Series.between(left, right)", "intent": "Return boolean Series equivalent to `left` < = series < = `right` .", "question_id": 38273}
{"snippet": "Series.between(left, right, inclusive='both')", "intent": "Return boolean Series equivalent to `left` < = series < = `right` . With `inclusive` set to `` neither '' boundary values are excluded :", "question_id": 38274}
{"snippet": "Series.between(left, right)", "intent": "Return boolean Series equivalent to `left` < = series < = `right` .", "question_id": 38275}
{"snippet": "Series.between(left, right, inclusive='both')", "intent": "Return boolean Series equivalent to `left` < = series < = `right` . With `inclusive` set to `` neither '' boundary values are excluded :", "question_id": 38276}
{"snippet": "Series.between(left, right)", "intent": "Return boolean Series equivalent to `left` < = series < = `right` .", "question_id": 38277}
{"snippet": "Series.between(left, right, inclusive='both')", "intent": "Return boolean Series equivalent to `left` < = series < = `right` . With `inclusive` set to `` neither '' boundary values are excluded :", "question_id": 38278}
{"snippet": "Series.between_time(start_time, end_time)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times .", "question_id": 38279}
{"snippet": "Series.between_time(start_time, end_time, include_start=True)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_start`.", "question_id": 38280}
{"snippet": "Series.between_time(start_time, end_time, include_end=True)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_end`.", "question_id": 38281}
{"snippet": "Series.between_time(start_time, end_time, axis=None)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `axis`.", "question_id": 38282}
{"snippet": "Series.between_time(start_time, end_time, include_start=True, include_end=True)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_start`, `include_end`.", "question_id": 38283}
{"snippet": "Series.between_time(start_time, end_time, include_start=True, axis=None)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_start`, `axis`.", "question_id": 38284}
{"snippet": "Series.between_time(start_time, end_time, include_end=True, axis=None)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_end`, `axis`.", "question_id": 38285}
{"snippet": "Series.between_time(start_time, end_time, include_start=True, include_end=True, axis=None)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_start`, `include_end`, `axis`.", "question_id": 38286}
{"snippet": "Series.between_time(start_time, end_time)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times .", "question_id": 38287}
{"snippet": "Series.between_time(start_time, end_time, include_start=True)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_start`.", "question_id": 38288}
{"snippet": "Series.between_time(start_time, end_time, include_end=True)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_end`.", "question_id": 38289}
{"snippet": "Series.between_time(start_time, end_time, axis=None)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `axis`.", "question_id": 38290}
{"snippet": "Series.between_time(start_time, end_time, include_start=True, include_end=True)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_start`, `include_end`.", "question_id": 38291}
{"snippet": "Series.between_time(start_time, end_time, include_start=True, axis=None)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_start`, `axis`.", "question_id": 38292}
{"snippet": "Series.between_time(start_time, end_time, include_end=True, axis=None)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_end`, `axis`.", "question_id": 38293}
{"snippet": "Series.between_time(start_time, end_time, include_start=True, include_end=True, axis=None)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_start`, `include_end`, `axis`.", "question_id": 38294}
{"snippet": "Series.between_time(start_time, end_time)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times .", "question_id": 38295}
{"snippet": "Series.between_time(start_time, end_time, include_start=True)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_start`.", "question_id": 38296}
{"snippet": "Series.between_time(start_time, end_time, include_end=True)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_end`.", "question_id": 38297}
{"snippet": "Series.between_time(start_time, end_time, axis=None)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `axis`.", "question_id": 38298}
{"snippet": "Series.between_time(start_time, end_time, include_start=True, include_end=True)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_start`, `include_end`.", "question_id": 38299}
{"snippet": "Series.between_time(start_time, end_time, include_start=True, axis=None)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_start`, `axis`.", "question_id": 38300}
{"snippet": "Series.between_time(start_time, end_time, include_end=True, axis=None)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_end`, `axis`.", "question_id": 38301}
{"snippet": "Series.between_time(start_time, end_time, include_start=True, include_end=True, axis=None)", "intent": "Select values between particular times of the day ( e.g. , 9:00-9:30 AM ) . By setting `start_time` to be later than `end_time` , you can get the times that are not between the two times . With arguments `include_start`, `include_end`, `axis`.", "question_id": 38302}
{"snippet": "Series.bfill()", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' .", "question_id": 38303}
{"snippet": "Series.bfill(axis=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`.", "question_id": 38304}
{"snippet": "Series.bfill(inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`.", "question_id": 38305}
{"snippet": "Series.bfill(limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `limit`.", "question_id": 38306}
{"snippet": "Series.bfill(downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `downcast`.", "question_id": 38307}
{"snippet": "Series.bfill(axis=None, inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `inplace`.", "question_id": 38308}
{"snippet": "Series.bfill(axis=None, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `limit`.", "question_id": 38309}
{"snippet": "Series.bfill(axis=None, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `downcast`.", "question_id": 38310}
{"snippet": "Series.bfill(inplace=False, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`, `limit`.", "question_id": 38311}
{"snippet": "Series.bfill(inplace=False, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`, `downcast`.", "question_id": 38312}
{"snippet": "Series.bfill()", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' .", "question_id": 38313}
{"snippet": "Series.bfill(axis=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`.", "question_id": 38314}
{"snippet": "Series.bfill(inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`.", "question_id": 38315}
{"snippet": "Series.bfill(limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `limit`.", "question_id": 38316}
{"snippet": "Series.bfill(downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `downcast`.", "question_id": 38317}
{"snippet": "Series.bfill(axis=None, inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `inplace`.", "question_id": 38318}
{"snippet": "Series.bfill(axis=None, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `limit`.", "question_id": 38319}
{"snippet": "Series.bfill(axis=None, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `downcast`.", "question_id": 38320}
{"snippet": "Series.bfill(inplace=False, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`, `limit`.", "question_id": 38321}
{"snippet": "Series.bfill(inplace=False, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`, `downcast`.", "question_id": 38322}
{"snippet": "Series.bfill()", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' .", "question_id": 38323}
{"snippet": "Series.bfill(axis=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`.", "question_id": 38324}
{"snippet": "Series.bfill(inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`.", "question_id": 38325}
{"snippet": "Series.bfill(limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `limit`.", "question_id": 38326}
{"snippet": "Series.bfill(downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `downcast`.", "question_id": 38327}
{"snippet": "Series.bfill(axis=None, inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `inplace`.", "question_id": 38328}
{"snippet": "Series.bfill(axis=None, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `limit`.", "question_id": 38329}
{"snippet": "Series.bfill(axis=None, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `axis`, `downcast`.", "question_id": 38330}
{"snippet": "Series.bfill(inplace=False, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`, `limit`.", "question_id": 38331}
{"snippet": "Series.bfill(inplace=False, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='bfill ' . With arguments `inplace`, `downcast`.", "question_id": 38332}
{"snippet": "Series.bool()", "intent": "Return the bool of a single element Series or DataFrame .", "question_id": 38333}
{"snippet": "Series.bool()", "intent": "Return the bool of a single element Series or DataFrame .", "question_id": 38334}
{"snippet": "Series.bool()", "intent": "Return the bool of a single element Series or DataFrame .", "question_id": 38335}
{"snippet": "Series.cat.add_categories(*args, **kwargs)", "intent": "Add new categories . With arguments `*args`, `**kwargs`.", "question_id": 38336}
{"snippet": "Series.cat.add_categories(*args, **kwargs)", "intent": "Add new categories . With arguments `*args`, `**kwargs`.", "question_id": 38337}
{"snippet": "Series.cat.add_categories(*args, **kwargs)", "intent": "Add new categories . With arguments `*args`, `**kwargs`.", "question_id": 38338}
{"snippet": "Series.cat.as_ordered(*args, **kwargs)", "intent": "Set the Categorical to be ordered . With arguments `*args`, `**kwargs`.", "question_id": 38339}
{"snippet": "Series.cat.as_ordered(*args, **kwargs)", "intent": "Set the Categorical to be ordered . With arguments `*args`, `**kwargs`.", "question_id": 38340}
{"snippet": "Series.cat.as_ordered(*args, **kwargs)", "intent": "Set the Categorical to be ordered . With arguments `*args`, `**kwargs`.", "question_id": 38341}
{"snippet": "Series.cat.as_unordered(*args, **kwargs)", "intent": "Set the Categorical to be unordered . With arguments `*args`, `**kwargs`.", "question_id": 38342}
{"snippet": "Series.cat.as_unordered(*args, **kwargs)", "intent": "Set the Categorical to be unordered . With arguments `*args`, `**kwargs`.", "question_id": 38343}
{"snippet": "Series.cat.as_unordered(*args, **kwargs)", "intent": "Set the Categorical to be unordered . With arguments `*args`, `**kwargs`.", "question_id": 38344}
{"snippet": "Series.cat.categories", "intent": "The categories of this categorical.", "question_id": 38345}
{"snippet": "Series.cat.categories", "intent": "The categories of this categorical.", "question_id": 38346}
{"snippet": "Series.cat.categories", "intent": "The categories of this categorical.", "question_id": 38347}
{"snippet": "Series.cat.codes", "intent": "Return Series of codes as well as the index.", "question_id": 38348}
{"snippet": "Series.cat.codes", "intent": "Return Series of codes as well as the index.", "question_id": 38349}
{"snippet": "Series.cat.codes", "intent": "Return Series of codes as well as the index.", "question_id": 38350}
{"snippet": "Series.cat()", "intent": "Accessor object for categorical properties of the Series values .", "question_id": 38351}
{"snippet": "Series.cat()", "intent": "Accessor object for categorical properties of the Series values .", "question_id": 38352}
{"snippet": "Series.cat()", "intent": "Accessor object for categorical properties of the Series values .", "question_id": 38353}
{"snippet": "Series.cat.ordered", "intent": "Whether the categories have an ordered relationship.", "question_id": 38354}
{"snippet": "Series.cat.ordered", "intent": "Whether the categories have an ordered relationship.", "question_id": 38355}
{"snippet": "Series.cat.ordered", "intent": "Whether the categories have an ordered relationship.", "question_id": 38356}
{"snippet": "Series.cat.remove_categories(*args, **kwargs)", "intent": "Remove the specified categories . With arguments `*args`, `**kwargs`.", "question_id": 38357}
{"snippet": "Series.cat.remove_categories(*args, **kwargs)", "intent": "Remove the specified categories . With arguments `*args`, `**kwargs`.", "question_id": 38358}
{"snippet": "Series.cat.remove_categories(*args, **kwargs)", "intent": "Remove the specified categories . With arguments `*args`, `**kwargs`.", "question_id": 38359}
{"snippet": "Series.cat.remove_unused_categories(*args, **kwargs)", "intent": "Remove categories which are not used . With arguments `*args`, `**kwargs`.", "question_id": 38360}
{"snippet": "Series.cat.remove_unused_categories(*args, **kwargs)", "intent": "Remove categories which are not used . With arguments `*args`, `**kwargs`.", "question_id": 38361}
{"snippet": "Series.cat.remove_unused_categories(*args, **kwargs)", "intent": "Remove categories which are not used . With arguments `*args`, `**kwargs`.", "question_id": 38362}
{"snippet": "Series.cat.rename_categories(*args, **kwargs)", "intent": "Rename categories . With arguments `*args`, `**kwargs`.", "question_id": 38363}
{"snippet": "Series.cat.rename_categories(*args, **kwargs)", "intent": "Rename categories . With arguments `*args`, `**kwargs`.", "question_id": 38364}
{"snippet": "Series.cat.rename_categories(*args, **kwargs)", "intent": "Rename categories . With arguments `*args`, `**kwargs`.", "question_id": 38365}
{"snippet": "Series.cat.reorder_categories(*args, **kwargs)", "intent": "Reorder categories as specified in new_categories . With arguments `*args`, `**kwargs`.", "question_id": 38366}
{"snippet": "Series.cat.reorder_categories(*args, **kwargs)", "intent": "Reorder categories as specified in new_categories . With arguments `*args`, `**kwargs`.", "question_id": 38367}
{"snippet": "Series.cat.reorder_categories(*args, **kwargs)", "intent": "Reorder categories as specified in new_categories . With arguments `*args`, `**kwargs`.", "question_id": 38368}
{"snippet": "Series.cat.set_categories(*args, **kwargs)", "intent": "Set the categories to the specified new_categories . With arguments `*args`, `**kwargs`.", "question_id": 38369}
{"snippet": "Series.cat.set_categories(*args, **kwargs)", "intent": "Set the categories to the specified new_categories . With arguments `*args`, `**kwargs`.", "question_id": 38370}
{"snippet": "Series.cat.set_categories(*args, **kwargs)", "intent": "Set the categories to the specified new_categories . With arguments `*args`, `**kwargs`.", "question_id": 38371}
{"snippet": "Series.clip(*args, **kwargs)", "intent": "Trim values at input threshold ( s ) . With arguments `*args`, `**kwargs`.", "question_id": 38372}
{"snippet": "Series.clip(*args, **kwargs, lower=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`.", "question_id": 38373}
{"snippet": "Series.clip(*args, **kwargs, upper=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`.", "question_id": 38374}
{"snippet": "Series.clip(*args, **kwargs, axis=None)", "intent": "Trim values at input threshold ( s ) . Thresholds can be singular values or array like , and in the latter case the clipping is performed element-wise in the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38375}
{"snippet": "Series.clip(*args, **kwargs, inplace=False)", "intent": "Trim values at input threshold ( s ) . With arguments `*args`, `**kwargs`, `inplace`.", "question_id": 38376}
{"snippet": "Series.clip(*args, **kwargs, lower=None, upper=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`.", "question_id": 38377}
{"snippet": "Series.clip(*args, **kwargs, lower=None, axis=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : Thresholds can be singular values or array like , and in the latter case the clipping is performed element-wise in the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38378}
{"snippet": "Series.clip(*args, **kwargs, lower=None, inplace=False)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`, `inplace`.", "question_id": 38379}
{"snippet": "Series.clip(*args, **kwargs, upper=None, axis=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : Thresholds can be singular values or array like , and in the latter case the clipping is performed element-wise in the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38380}
{"snippet": "Series.clip(*args, **kwargs, upper=None, inplace=False)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`, `inplace`.", "question_id": 38381}
{"snippet": "Series.clip(*args, **kwargs)", "intent": "Trim values at input threshold ( s ) . With arguments `*args`, `**kwargs`.", "question_id": 38382}
{"snippet": "Series.clip(*args, **kwargs, lower=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`.", "question_id": 38383}
{"snippet": "Series.clip(*args, **kwargs, upper=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`.", "question_id": 38384}
{"snippet": "Series.clip(*args, **kwargs, axis=None)", "intent": "Trim values at input threshold ( s ) . Thresholds can be singular values or array like , and in the latter case the clipping is performed element-wise in the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38385}
{"snippet": "Series.clip(*args, **kwargs, inplace=False)", "intent": "Trim values at input threshold ( s ) . With arguments `*args`, `**kwargs`, `inplace`.", "question_id": 38386}
{"snippet": "Series.clip(*args, **kwargs, lower=None, upper=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`.", "question_id": 38387}
{"snippet": "Series.clip(*args, **kwargs, lower=None, axis=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : Thresholds can be singular values or array like , and in the latter case the clipping is performed element-wise in the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38388}
{"snippet": "Series.clip(*args, **kwargs, lower=None, inplace=False)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`, `inplace`.", "question_id": 38389}
{"snippet": "Series.clip(*args, **kwargs, upper=None, axis=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : Thresholds can be singular values or array like , and in the latter case the clipping is performed element-wise in the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38390}
{"snippet": "Series.clip(*args, **kwargs, upper=None, inplace=False)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`, `inplace`.", "question_id": 38391}
{"snippet": "Series.clip(*args, **kwargs)", "intent": "Trim values at input threshold ( s ) . With arguments `*args`, `**kwargs`.", "question_id": 38392}
{"snippet": "Series.clip(*args, **kwargs, lower=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`.", "question_id": 38393}
{"snippet": "Series.clip(*args, **kwargs, upper=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`.", "question_id": 38394}
{"snippet": "Series.clip(*args, **kwargs, axis=None)", "intent": "Trim values at input threshold ( s ) . Thresholds can be singular values or array like , and in the latter case the clipping is performed element-wise in the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38395}
{"snippet": "Series.clip(*args, **kwargs, inplace=False)", "intent": "Trim values at input threshold ( s ) . With arguments `*args`, `**kwargs`, `inplace`.", "question_id": 38396}
{"snippet": "Series.clip(*args, **kwargs, lower=None, upper=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`.", "question_id": 38397}
{"snippet": "Series.clip(*args, **kwargs, lower=None, axis=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : Thresholds can be singular values or array like , and in the latter case the clipping is performed element-wise in the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38398}
{"snippet": "Series.clip(*args, **kwargs, lower=None, inplace=False)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`, `inplace`.", "question_id": 38399}
{"snippet": "Series.clip(*args, **kwargs, upper=None, axis=None)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : Thresholds can be singular values or array like , and in the latter case the clipping is performed element-wise in the specified `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38400}
{"snippet": "Series.clip(*args, **kwargs, upper=None, inplace=False)", "intent": "Trim values at input threshold ( s ) . Clips per column using `lower` and `upper` thresholds : With arguments `*args`, `**kwargs`, `inplace`.", "question_id": 38401}
{"snippet": "Series.combine(other, func)", "intent": "Combine the Series with a Series or scalar according to `func` . Combine the Series and `other` using func to perform elementwise selection for combined Series .", "question_id": 38402}
{"snippet": "Series.combine(other, func, fill_value=None)", "intent": "Combine the Series with a Series or scalar according to `func` . Combine the Series and `other` using func to perform elementwise selection for combined Series . `fill_value` is assumed when value is missing at some index from one of the two objects being combined .", "question_id": 38403}
{"snippet": "Series.combine(other, func)", "intent": "Combine the Series with a Series or scalar according to `func` . Combine the Series and `other` using func to perform elementwise selection for combined Series .", "question_id": 38404}
{"snippet": "Series.combine(other, func, fill_value=None)", "intent": "Combine the Series with a Series or scalar according to `func` . Combine the Series and `other` using func to perform elementwise selection for combined Series . `fill_value` is assumed when value is missing at some index from one of the two objects being combined .", "question_id": 38405}
{"snippet": "Series.combine(other, func)", "intent": "Combine the Series with a Series or scalar according to `func` . Combine the Series and `other` using func to perform elementwise selection for combined Series .", "question_id": 38406}
{"snippet": "Series.combine(other, func, fill_value=None)", "intent": "Combine the Series with a Series or scalar according to `func` . Combine the Series and `other` using func to perform elementwise selection for combined Series . `fill_value` is assumed when value is missing at some index from one of the two objects being combined .", "question_id": 38407}
{"snippet": "Series.combine_first(other)", "intent": "Update null elements with value in the same location in \u2018 `other` \u2019 .", "question_id": 38408}
{"snippet": "Series.combine_first(other)", "intent": "Update null elements with value in the same location in \u2018 `other` \u2019 .", "question_id": 38409}
{"snippet": "Series.combine_first(other)", "intent": "Update null elements with value in the same location in \u2018 `other` \u2019 .", "question_id": 38410}
{"snippet": "Series.compare(other)", "intent": "Compare to another Series and show the differences . With arguments `other`.", "question_id": 38411}
{"snippet": "Series.compare(other, align_axis=1)", "intent": "Compare to another Series and show the differences . With arguments `other`, `align_axis`.", "question_id": 38412}
{"snippet": "Series.compare(other, keep_shape=False)", "intent": "Compare to another Series and show the differences . With arguments `other`, `keep_shape`.", "question_id": 38413}
{"snippet": "Series.compare(other, keep_equal=False)", "intent": "Compare to another Series and show the differences . With arguments `other`, `keep_equal`.", "question_id": 38414}
{"snippet": "Series.compare(other, align_axis=1, keep_shape=False)", "intent": "Compare to another Series and show the differences . With arguments `other`, `align_axis`, `keep_shape`.", "question_id": 38415}
{"snippet": "Series.compare(other, align_axis=1, keep_equal=False)", "intent": "Compare to another Series and show the differences . With arguments `other`, `align_axis`, `keep_equal`.", "question_id": 38416}
{"snippet": "Series.compare(other, keep_shape=False, keep_equal=False)", "intent": "Compare to another Series and show the differences . With arguments `other`, `keep_shape`, `keep_equal`.", "question_id": 38417}
{"snippet": "Series.compare(other, align_axis=1, keep_shape=False, keep_equal=False)", "intent": "Compare to another Series and show the differences . With arguments `other`, `align_axis`, `keep_shape`, `keep_equal`.", "question_id": 38418}
{"snippet": "Series.compare(other)", "intent": "Compare to another Series and show the differences . With arguments `other`.", "question_id": 38419}
{"snippet": "Series.compare(other, align_axis=1)", "intent": "Compare to another Series and show the differences . With arguments `other`, `align_axis`.", "question_id": 38420}
{"snippet": "Series.compare(other, keep_shape=False)", "intent": "Compare to another Series and show the differences . With arguments `other`, `keep_shape`.", "question_id": 38421}
{"snippet": "Series.compare(other, keep_equal=False)", "intent": "Compare to another Series and show the differences . With arguments `other`, `keep_equal`.", "question_id": 38422}
{"snippet": "Series.compare(other, align_axis=1, keep_shape=False)", "intent": "Compare to another Series and show the differences . With arguments `other`, `align_axis`, `keep_shape`.", "question_id": 38423}
{"snippet": "Series.compare(other, align_axis=1, keep_equal=False)", "intent": "Compare to another Series and show the differences . With arguments `other`, `align_axis`, `keep_equal`.", "question_id": 38424}
{"snippet": "Series.compare(other, keep_shape=False, keep_equal=False)", "intent": "Compare to another Series and show the differences . With arguments `other`, `keep_shape`, `keep_equal`.", "question_id": 38425}
{"snippet": "Series.compare(other, align_axis=1, keep_shape=False, keep_equal=False)", "intent": "Compare to another Series and show the differences . With arguments `other`, `align_axis`, `keep_shape`, `keep_equal`.", "question_id": 38426}
{"snippet": "Series.compare(other)", "intent": "Compare to another Series and show the differences . With arguments `other`.", "question_id": 38427}
{"snippet": "Series.compare(other, align_axis=1)", "intent": "Compare to another Series and show the differences . With arguments `other`, `align_axis`.", "question_id": 38428}
{"snippet": "Series.compare(other, keep_shape=False)", "intent": "Compare to another Series and show the differences . With arguments `other`, `keep_shape`.", "question_id": 38429}
{"snippet": "Series.compare(other, keep_equal=False)", "intent": "Compare to another Series and show the differences . With arguments `other`, `keep_equal`.", "question_id": 38430}
{"snippet": "Series.compare(other, align_axis=1, keep_shape=False)", "intent": "Compare to another Series and show the differences . With arguments `other`, `align_axis`, `keep_shape`.", "question_id": 38431}
{"snippet": "Series.compare(other, align_axis=1, keep_equal=False)", "intent": "Compare to another Series and show the differences . With arguments `other`, `align_axis`, `keep_equal`.", "question_id": 38432}
{"snippet": "Series.compare(other, keep_shape=False, keep_equal=False)", "intent": "Compare to another Series and show the differences . With arguments `other`, `keep_shape`, `keep_equal`.", "question_id": 38433}
{"snippet": "Series.compare(other, align_axis=1, keep_shape=False, keep_equal=False)", "intent": "Compare to another Series and show the differences . With arguments `other`, `align_axis`, `keep_shape`, `keep_equal`.", "question_id": 38434}
{"snippet": "Series.convert_dtypes()", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA .", "question_id": 38435}
{"snippet": "Series.convert_dtypes(infer_objects=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction .", "question_id": 38436}
{"snippet": "Series.convert_dtypes(convert_string=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 38437}
{"snippet": "Series.convert_dtypes(convert_integer=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 38438}
{"snippet": "Series.convert_dtypes(convert_boolean=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 38439}
{"snippet": "Series.convert_dtypes(convert_floating=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . With arguments `convert_floating`.", "question_id": 38440}
{"snippet": "Series.convert_dtypes(infer_objects=True, convert_string=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 38441}
{"snippet": "Series.convert_dtypes(infer_objects=True, convert_integer=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 38442}
{"snippet": "Series.convert_dtypes(infer_objects=True, convert_boolean=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 38443}
{"snippet": "Series.convert_dtypes(infer_objects=True, convert_floating=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction . With arguments `convert_floating`.", "question_id": 38444}
{"snippet": "Series.convert_dtypes()", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA .", "question_id": 38445}
{"snippet": "Series.convert_dtypes(infer_objects=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction .", "question_id": 38446}
{"snippet": "Series.convert_dtypes(convert_string=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 38447}
{"snippet": "Series.convert_dtypes(convert_integer=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 38448}
{"snippet": "Series.convert_dtypes(convert_boolean=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 38449}
{"snippet": "Series.convert_dtypes(convert_floating=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . With arguments `convert_floating`.", "question_id": 38450}
{"snippet": "Series.convert_dtypes(infer_objects=True, convert_string=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 38451}
{"snippet": "Series.convert_dtypes(infer_objects=True, convert_integer=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 38452}
{"snippet": "Series.convert_dtypes(infer_objects=True, convert_boolean=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 38453}
{"snippet": "Series.convert_dtypes(infer_objects=True, convert_floating=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction . With arguments `convert_floating`.", "question_id": 38454}
{"snippet": "Series.convert_dtypes()", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA .", "question_id": 38455}
{"snippet": "Series.convert_dtypes(infer_objects=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction .", "question_id": 38456}
{"snippet": "Series.convert_dtypes(convert_string=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 38457}
{"snippet": "Series.convert_dtypes(convert_integer=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 38458}
{"snippet": "Series.convert_dtypes(convert_boolean=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 38459}
{"snippet": "Series.convert_dtypes(convert_floating=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . With arguments `convert_floating`.", "question_id": 38460}
{"snippet": "Series.convert_dtypes(infer_objects=True, convert_string=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 38461}
{"snippet": "Series.convert_dtypes(infer_objects=True, convert_integer=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 38462}
{"snippet": "Series.convert_dtypes(infer_objects=True, convert_boolean=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction . By using the options `convert_string` , `convert_integer` , `convert_boolean` and convert_boolean , it is possible to turn off individual conversions to StringDtype , the integer extension types , BooleanDtype or floating extension types , respectively .", "question_id": 38463}
{"snippet": "Series.convert_dtypes(infer_objects=True, convert_floating=True)", "intent": "Convert columns to best possible dtypes using dtypes supporting pd.NA . For object-dtyped columns , if `infer_objects` is True , use the inference rules as during normal Series/DataFrame construction . With arguments `convert_floating`.", "question_id": 38464}
{"snippet": "Series.copy()", "intent": "Make a copy of this object \u2019 s indices and data .", "question_id": 38465}
{"snippet": "Series.copy(deep=True)", "intent": "Make a copy of this object \u2019 s indices and data . Shallow copy versus default ( `deep` ) copy :", "question_id": 38466}
{"snippet": "Series.copy()", "intent": "Make a copy of this object \u2019 s indices and data .", "question_id": 38467}
{"snippet": "Series.copy(deep=True)", "intent": "Make a copy of this object \u2019 s indices and data . Shallow copy versus default ( `deep` ) copy :", "question_id": 38468}
{"snippet": "Series.copy()", "intent": "Make a copy of this object \u2019 s indices and data .", "question_id": 38469}
{"snippet": "Series.copy(deep=True)", "intent": "Make a copy of this object \u2019 s indices and data . Shallow copy versus default ( `deep` ) copy :", "question_id": 38470}
{"snippet": "Series.corr(other)", "intent": "Compute correlation with `other` Series , excluding missing values .", "question_id": 38471}
{"snippet": "Series.corr(other, method='pearson')", "intent": "Compute correlation with `other` Series , excluding missing values . With arguments `method`.", "question_id": 38472}
{"snippet": "Series.corr(other, min_periods=None)", "intent": "Compute correlation with `other` Series , excluding missing values . With arguments `min_periods`.", "question_id": 38473}
{"snippet": "Series.corr(other, method='pearson', min_periods=None)", "intent": "Compute correlation with `other` Series , excluding missing values . With arguments `method`, `min_periods`.", "question_id": 38474}
{"snippet": "Series.corr(other)", "intent": "Compute correlation with `other` Series , excluding missing values .", "question_id": 38475}
{"snippet": "Series.corr(other, method='pearson')", "intent": "Compute correlation with `other` Series , excluding missing values . With arguments `method`.", "question_id": 38476}
{"snippet": "Series.corr(other, min_periods=None)", "intent": "Compute correlation with `other` Series , excluding missing values . With arguments `min_periods`.", "question_id": 38477}
{"snippet": "Series.corr(other, method='pearson', min_periods=None)", "intent": "Compute correlation with `other` Series , excluding missing values . With arguments `method`, `min_periods`.", "question_id": 38478}
{"snippet": "Series.corr(other)", "intent": "Compute correlation with `other` Series , excluding missing values .", "question_id": 38479}
{"snippet": "Series.corr(other, method='pearson')", "intent": "Compute correlation with `other` Series , excluding missing values . With arguments `method`.", "question_id": 38480}
{"snippet": "Series.corr(other, min_periods=None)", "intent": "Compute correlation with `other` Series , excluding missing values . With arguments `min_periods`.", "question_id": 38481}
{"snippet": "Series.corr(other, method='pearson', min_periods=None)", "intent": "Compute correlation with `other` Series , excluding missing values . With arguments `method`, `min_periods`.", "question_id": 38482}
{"snippet": "Series.count()", "intent": "Return number of non-NA/null observations in the Series .", "question_id": 38483}
{"snippet": "Series.count(level=None)", "intent": "Return number of non-NA/null observations in the Series . With arguments `level`.", "question_id": 38484}
{"snippet": "Series.count()", "intent": "Return number of non-NA/null observations in the Series .", "question_id": 38485}
{"snippet": "Series.count(level=None)", "intent": "Return number of non-NA/null observations in the Series . With arguments `level`.", "question_id": 38486}
{"snippet": "Series.count()", "intent": "Return number of non-NA/null observations in the Series .", "question_id": 38487}
{"snippet": "Series.count(level=None)", "intent": "Return number of non-NA/null observations in the Series . With arguments `level`.", "question_id": 38488}
{"snippet": "Series.cov(other)", "intent": "Compute covariance with Series , excluding missing values . With arguments `other`.", "question_id": 38489}
{"snippet": "Series.cov(other, min_periods=None)", "intent": "Compute covariance with Series , excluding missing values . With arguments `other`, `min_periods`.", "question_id": 38490}
{"snippet": "Series.cov(other, ddof=1)", "intent": "Compute covariance with Series , excluding missing values . With arguments `other`, `ddof`.", "question_id": 38491}
{"snippet": "Series.cov(other, min_periods=None, ddof=1)", "intent": "Compute covariance with Series , excluding missing values . With arguments `other`, `min_periods`, `ddof`.", "question_id": 38492}
{"snippet": "Series.cov(other)", "intent": "Compute covariance with Series , excluding missing values . With arguments `other`.", "question_id": 38493}
{"snippet": "Series.cov(other, min_periods=None)", "intent": "Compute covariance with Series , excluding missing values . With arguments `other`, `min_periods`.", "question_id": 38494}
{"snippet": "Series.cov(other, ddof=1)", "intent": "Compute covariance with Series , excluding missing values . With arguments `other`, `ddof`.", "question_id": 38495}
{"snippet": "Series.cov(other, min_periods=None, ddof=1)", "intent": "Compute covariance with Series , excluding missing values . With arguments `other`, `min_periods`, `ddof`.", "question_id": 38496}
{"snippet": "Series.cov(other)", "intent": "Compute covariance with Series , excluding missing values . With arguments `other`.", "question_id": 38497}
{"snippet": "Series.cov(other, min_periods=None)", "intent": "Compute covariance with Series , excluding missing values . With arguments `other`, `min_periods`.", "question_id": 38498}
{"snippet": "Series.cov(other, ddof=1)", "intent": "Compute covariance with Series , excluding missing values . With arguments `other`, `ddof`.", "question_id": 38499}
{"snippet": "Series.cov(other, min_periods=None, ddof=1)", "intent": "Compute covariance with Series , excluding missing values . With arguments `other`, `min_periods`, `ddof`.", "question_id": 38500}
{"snippet": "Series.cummax(*args, **kwargs)", "intent": "Return cumulative maximum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38501}
{"snippet": "Series.cummax(*args, **kwargs, axis=None)", "intent": "Return cumulative maximum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38502}
{"snippet": "Series.cummax(*args, **kwargs, skipna=True)", "intent": "Return cumulative maximum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38503}
{"snippet": "Series.cummax(*args, **kwargs, axis=None, skipna=True)", "intent": "Return cumulative maximum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38504}
{"snippet": "Series.cummax(*args, **kwargs)", "intent": "Return cumulative maximum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38505}
{"snippet": "Series.cummax(*args, **kwargs, axis=None)", "intent": "Return cumulative maximum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38506}
{"snippet": "Series.cummax(*args, **kwargs, skipna=True)", "intent": "Return cumulative maximum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38507}
{"snippet": "Series.cummax(*args, **kwargs, axis=None, skipna=True)", "intent": "Return cumulative maximum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38508}
{"snippet": "Series.cummax(*args, **kwargs)", "intent": "Return cumulative maximum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38509}
{"snippet": "Series.cummax(*args, **kwargs, axis=None)", "intent": "Return cumulative maximum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38510}
{"snippet": "Series.cummax(*args, **kwargs, skipna=True)", "intent": "Return cumulative maximum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38511}
{"snippet": "Series.cummax(*args, **kwargs, axis=None, skipna=True)", "intent": "Return cumulative maximum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38512}
{"snippet": "Series.cummin(*args, **kwargs)", "intent": "Return cumulative minimum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38513}
{"snippet": "Series.cummin(*args, **kwargs, axis=None)", "intent": "Return cumulative minimum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38514}
{"snippet": "Series.cummin(*args, **kwargs, skipna=True)", "intent": "Return cumulative minimum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38515}
{"snippet": "Series.cummin(*args, **kwargs, axis=None, skipna=True)", "intent": "Return cumulative minimum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38516}
{"snippet": "Series.cummin(*args, **kwargs)", "intent": "Return cumulative minimum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38517}
{"snippet": "Series.cummin(*args, **kwargs, axis=None)", "intent": "Return cumulative minimum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38518}
{"snippet": "Series.cummin(*args, **kwargs, skipna=True)", "intent": "Return cumulative minimum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38519}
{"snippet": "Series.cummin(*args, **kwargs, axis=None, skipna=True)", "intent": "Return cumulative minimum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38520}
{"snippet": "Series.cummin(*args, **kwargs)", "intent": "Return cumulative minimum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38521}
{"snippet": "Series.cummin(*args, **kwargs, axis=None)", "intent": "Return cumulative minimum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38522}
{"snippet": "Series.cummin(*args, **kwargs, skipna=True)", "intent": "Return cumulative minimum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38523}
{"snippet": "Series.cummin(*args, **kwargs, axis=None, skipna=True)", "intent": "Return cumulative minimum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38524}
{"snippet": "Series.cumprod(*args, **kwargs)", "intent": "Return cumulative product over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38525}
{"snippet": "Series.cumprod(*args, **kwargs, axis=None)", "intent": "Return cumulative product over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38526}
{"snippet": "Series.cumprod(*args, **kwargs, skipna=True)", "intent": "Return cumulative product over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38527}
{"snippet": "Series.cumprod(*args, **kwargs, axis=None, skipna=True)", "intent": "Return cumulative product over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38528}
{"snippet": "Series.cumprod(*args, **kwargs)", "intent": "Return cumulative product over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38529}
{"snippet": "Series.cumprod(*args, **kwargs, axis=None)", "intent": "Return cumulative product over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38530}
{"snippet": "Series.cumprod(*args, **kwargs, skipna=True)", "intent": "Return cumulative product over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38531}
{"snippet": "Series.cumprod(*args, **kwargs, axis=None, skipna=True)", "intent": "Return cumulative product over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38532}
{"snippet": "Series.cumprod(*args, **kwargs)", "intent": "Return cumulative product over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38533}
{"snippet": "Series.cumprod(*args, **kwargs, axis=None)", "intent": "Return cumulative product over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38534}
{"snippet": "Series.cumprod(*args, **kwargs, skipna=True)", "intent": "Return cumulative product over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38535}
{"snippet": "Series.cumprod(*args, **kwargs, axis=None, skipna=True)", "intent": "Return cumulative product over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38536}
{"snippet": "Series.cumsum(*args, **kwargs)", "intent": "Return cumulative sum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38537}
{"snippet": "Series.cumsum(*args, **kwargs, axis=None)", "intent": "Return cumulative sum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38538}
{"snippet": "Series.cumsum(*args, **kwargs, skipna=True)", "intent": "Return cumulative sum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38539}
{"snippet": "Series.cumsum(*args, **kwargs, axis=None, skipna=True)", "intent": "Return cumulative sum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38540}
{"snippet": "Series.cumsum(*args, **kwargs)", "intent": "Return cumulative sum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38541}
{"snippet": "Series.cumsum(*args, **kwargs, axis=None)", "intent": "Return cumulative sum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38542}
{"snippet": "Series.cumsum(*args, **kwargs, skipna=True)", "intent": "Return cumulative sum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38543}
{"snippet": "Series.cumsum(*args, **kwargs, axis=None, skipna=True)", "intent": "Return cumulative sum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38544}
{"snippet": "Series.cumsum(*args, **kwargs)", "intent": "Return cumulative sum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38545}
{"snippet": "Series.cumsum(*args, **kwargs, axis=None)", "intent": "Return cumulative sum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`.", "question_id": 38546}
{"snippet": "Series.cumsum(*args, **kwargs, skipna=True)", "intent": "Return cumulative sum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38547}
{"snippet": "Series.cumsum(*args, **kwargs, axis=None, skipna=True)", "intent": "Return cumulative sum over a DataFrame or Series `axis` . With arguments `*args`, `**kwargs`, `skipna`.", "question_id": 38548}
{"snippet": "Series.describe()", "intent": "Generate descriptive statistics .", "question_id": 38549}
{"snippet": "Series.describe(percentiles=None)", "intent": "Generate descriptive statistics . For numeric data , the result \u2019 s index will include count , mean , std , min , max as well as lower , 50 and upper `percentiles` .", "question_id": 38550}
{"snippet": "Series.describe(include=None)", "intent": "Generate descriptive statistics . Descriptive statistics `include` those that summarize the central tendency , dispersion and shape of a dataset \u2019 s distribution , excluding NaN values .", "question_id": 38551}
{"snippet": "Series.describe(exclude=None)", "intent": "Generate descriptive statistics . The include and `exclude` parameters can be used to limit which columns in a DataFrame are analyzed for the output .", "question_id": 38552}
{"snippet": "Series.describe(datetime_is_numeric=False)", "intent": "Generate descriptive statistics . With arguments `datetime_is_numeric`.", "question_id": 38553}
{"snippet": "Series.describe(percentiles=None, include=None)", "intent": "Generate descriptive statistics . For numeric data , the result \u2019 s index will include count , mean , std , min , max as well as lower , 50 and upper `percentiles` . Descriptive statistics `include` those that summarize the central tendency , dispersion and shape of a dataset \u2019 s distribution , excluding NaN values .", "question_id": 38554}
{"snippet": "Series.describe(percentiles=None, exclude=None)", "intent": "Generate descriptive statistics . For numeric data , the result \u2019 s index will include count , mean , std , min , max as well as lower , 50 and upper `percentiles` . The include and `exclude` parameters can be used to limit which columns in a DataFrame are analyzed for the output .", "question_id": 38555}
{"snippet": "Series.describe(percentiles=None, datetime_is_numeric=False)", "intent": "Generate descriptive statistics . For numeric data , the result \u2019 s index will include count , mean , std , min , max as well as lower , 50 and upper `percentiles` . With arguments `datetime_is_numeric`.", "question_id": 38556}
{"snippet": "Series.describe(include=None, exclude=None)", "intent": "Generate descriptive statistics . Descriptive statistics `include` those that summarize the central tendency , dispersion and shape of a dataset \u2019 s distribution , excluding NaN values . The include and `exclude` parameters can be used to limit which columns in a DataFrame are analyzed for the output .", "question_id": 38557}
{"snippet": "Series.describe(include=None, datetime_is_numeric=False)", "intent": "Generate descriptive statistics . Descriptive statistics `include` those that summarize the central tendency , dispersion and shape of a dataset \u2019 s distribution , excluding NaN values . With arguments `datetime_is_numeric`.", "question_id": 38558}
{"snippet": "Series.describe()", "intent": "Generate descriptive statistics .", "question_id": 38559}
{"snippet": "Series.describe(percentiles=None)", "intent": "Generate descriptive statistics . For numeric data , the result \u2019 s index will include count , mean , std , min , max as well as lower , 50 and upper `percentiles` .", "question_id": 38560}
{"snippet": "Series.describe(include=None)", "intent": "Generate descriptive statistics . Descriptive statistics `include` those that summarize the central tendency , dispersion and shape of a dataset \u2019 s distribution , excluding NaN values .", "question_id": 38561}
{"snippet": "Series.describe(exclude=None)", "intent": "Generate descriptive statistics . The include and `exclude` parameters can be used to limit which columns in a DataFrame are analyzed for the output .", "question_id": 38562}
{"snippet": "Series.describe(datetime_is_numeric=False)", "intent": "Generate descriptive statistics . With arguments `datetime_is_numeric`.", "question_id": 38563}
{"snippet": "Series.describe(percentiles=None, include=None)", "intent": "Generate descriptive statistics . For numeric data , the result \u2019 s index will include count , mean , std , min , max as well as lower , 50 and upper `percentiles` . Descriptive statistics `include` those that summarize the central tendency , dispersion and shape of a dataset \u2019 s distribution , excluding NaN values .", "question_id": 38564}
{"snippet": "Series.describe(percentiles=None, exclude=None)", "intent": "Generate descriptive statistics . For numeric data , the result \u2019 s index will include count , mean , std , min , max as well as lower , 50 and upper `percentiles` . The include and `exclude` parameters can be used to limit which columns in a DataFrame are analyzed for the output .", "question_id": 38565}
{"snippet": "Series.describe(percentiles=None, datetime_is_numeric=False)", "intent": "Generate descriptive statistics . For numeric data , the result \u2019 s index will include count , mean , std , min , max as well as lower , 50 and upper `percentiles` . With arguments `datetime_is_numeric`.", "question_id": 38566}
{"snippet": "Series.describe(include=None, exclude=None)", "intent": "Generate descriptive statistics . Descriptive statistics `include` those that summarize the central tendency , dispersion and shape of a dataset \u2019 s distribution , excluding NaN values . The include and `exclude` parameters can be used to limit which columns in a DataFrame are analyzed for the output .", "question_id": 38567}
{"snippet": "Series.describe(include=None, datetime_is_numeric=False)", "intent": "Generate descriptive statistics . Descriptive statistics `include` those that summarize the central tendency , dispersion and shape of a dataset \u2019 s distribution , excluding NaN values . With arguments `datetime_is_numeric`.", "question_id": 38568}
{"snippet": "Series.describe()", "intent": "Generate descriptive statistics .", "question_id": 38569}
{"snippet": "Series.describe(percentiles=None)", "intent": "Generate descriptive statistics . For numeric data , the result \u2019 s index will include count , mean , std , min , max as well as lower , 50 and upper `percentiles` .", "question_id": 38570}
{"snippet": "Series.describe(include=None)", "intent": "Generate descriptive statistics . Descriptive statistics `include` those that summarize the central tendency , dispersion and shape of a dataset \u2019 s distribution , excluding NaN values .", "question_id": 38571}
{"snippet": "Series.describe(exclude=None)", "intent": "Generate descriptive statistics . The include and `exclude` parameters can be used to limit which columns in a DataFrame are analyzed for the output .", "question_id": 38572}
{"snippet": "Series.describe(datetime_is_numeric=False)", "intent": "Generate descriptive statistics . With arguments `datetime_is_numeric`.", "question_id": 38573}
{"snippet": "Series.describe(percentiles=None, include=None)", "intent": "Generate descriptive statistics . For numeric data , the result \u2019 s index will include count , mean , std , min , max as well as lower , 50 and upper `percentiles` . Descriptive statistics `include` those that summarize the central tendency , dispersion and shape of a dataset \u2019 s distribution , excluding NaN values .", "question_id": 38574}
{"snippet": "Series.describe(percentiles=None, exclude=None)", "intent": "Generate descriptive statistics . For numeric data , the result \u2019 s index will include count , mean , std , min , max as well as lower , 50 and upper `percentiles` . The include and `exclude` parameters can be used to limit which columns in a DataFrame are analyzed for the output .", "question_id": 38575}
{"snippet": "Series.describe(percentiles=None, datetime_is_numeric=False)", "intent": "Generate descriptive statistics . For numeric data , the result \u2019 s index will include count , mean , std , min , max as well as lower , 50 and upper `percentiles` . With arguments `datetime_is_numeric`.", "question_id": 38576}
{"snippet": "Series.describe(include=None, exclude=None)", "intent": "Generate descriptive statistics . Descriptive statistics `include` those that summarize the central tendency , dispersion and shape of a dataset \u2019 s distribution , excluding NaN values . The include and `exclude` parameters can be used to limit which columns in a DataFrame are analyzed for the output .", "question_id": 38577}
{"snippet": "Series.describe(include=None, datetime_is_numeric=False)", "intent": "Generate descriptive statistics . Descriptive statistics `include` those that summarize the central tendency , dispersion and shape of a dataset \u2019 s distribution , excluding NaN values . With arguments `datetime_is_numeric`.", "question_id": 38578}
{"snippet": "Series.diff()", "intent": "First discrete difference of element .", "question_id": 38579}
{"snippet": "Series.diff(periods=1)", "intent": "First discrete difference of element . With arguments `periods`.", "question_id": 38580}
{"snippet": "Series.diff()", "intent": "First discrete difference of element .", "question_id": 38581}
{"snippet": "Series.diff(periods=1)", "intent": "First discrete difference of element . With arguments `periods`.", "question_id": 38582}
{"snippet": "Series.diff()", "intent": "First discrete difference of element .", "question_id": 38583}
{"snippet": "Series.diff(periods=1)", "intent": "First discrete difference of element . With arguments `periods`.", "question_id": 38584}
{"snippet": "Series.div(other)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) .", "question_id": 38585}
{"snippet": "Series.div(other, level=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `level`.", "question_id": 38586}
{"snippet": "Series.div(other, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 38587}
{"snippet": "Series.div(other, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `axis`.", "question_id": 38588}
{"snippet": "Series.div(other, level=None, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 38589}
{"snippet": "Series.div(other, level=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `level`, `axis`.", "question_id": 38590}
{"snippet": "Series.div(other, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 38591}
{"snippet": "Series.div(other, level=None, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 38592}
{"snippet": "Series.div(other)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) .", "question_id": 38593}
{"snippet": "Series.div(other, level=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `level`.", "question_id": 38594}
{"snippet": "Series.div(other, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 38595}
{"snippet": "Series.div(other, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `axis`.", "question_id": 38596}
{"snippet": "Series.div(other, level=None, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 38597}
{"snippet": "Series.div(other, level=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `level`, `axis`.", "question_id": 38598}
{"snippet": "Series.div(other, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 38599}
{"snippet": "Series.div(other, level=None, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 38600}
{"snippet": "Series.div(other)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) .", "question_id": 38601}
{"snippet": "Series.div(other, level=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `level`.", "question_id": 38602}
{"snippet": "Series.div(other, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 38603}
{"snippet": "Series.div(other, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `axis`.", "question_id": 38604}
{"snippet": "Series.div(other, level=None, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 38605}
{"snippet": "Series.div(other, level=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `level`, `axis`.", "question_id": 38606}
{"snippet": "Series.div(other, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 38607}
{"snippet": "Series.div(other, level=None, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 38608}
{"snippet": "Series.divide(other)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) .", "question_id": 38609}
{"snippet": "Series.divide(other, level=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `level`.", "question_id": 38610}
{"snippet": "Series.divide(other, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 38611}
{"snippet": "Series.divide(other, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `axis`.", "question_id": 38612}
{"snippet": "Series.divide(other, level=None, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 38613}
{"snippet": "Series.divide(other, level=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `level`, `axis`.", "question_id": 38614}
{"snippet": "Series.divide(other, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 38615}
{"snippet": "Series.divide(other, level=None, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 38616}
{"snippet": "Series.divide(other)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) .", "question_id": 38617}
{"snippet": "Series.divide(other, level=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `level`.", "question_id": 38618}
{"snippet": "Series.divide(other, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 38619}
{"snippet": "Series.divide(other, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `axis`.", "question_id": 38620}
{"snippet": "Series.divide(other, level=None, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 38621}
{"snippet": "Series.divide(other, level=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `level`, `axis`.", "question_id": 38622}
{"snippet": "Series.divide(other, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 38623}
{"snippet": "Series.divide(other, level=None, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 38624}
{"snippet": "Series.divide(other)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) .", "question_id": 38625}
{"snippet": "Series.divide(other, level=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `level`.", "question_id": 38626}
{"snippet": "Series.divide(other, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 38627}
{"snippet": "Series.divide(other, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `axis`.", "question_id": 38628}
{"snippet": "Series.divide(other, level=None, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 38629}
{"snippet": "Series.divide(other, level=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `level`, `axis`.", "question_id": 38630}
{"snippet": "Series.divide(other, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 38631}
{"snippet": "Series.divide(other, level=None, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 38632}
{"snippet": "Series.divmod(other)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator divmod ) .", "question_id": 38633}
{"snippet": "Series.divmod(other, level=None)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator divmod ) . With arguments `level`.", "question_id": 38634}
{"snippet": "Series.divmod(other, fill_value=None)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator divmod ) . Equivalent to divmod ( series , other ) , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 38635}
{"snippet": "Series.divmod(other, axis=0)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator divmod ) . With arguments `axis`.", "question_id": 38636}
{"snippet": "Series.divmod(other, level=None, fill_value=None)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator divmod ) . Equivalent to divmod ( series , other ) , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 38637}
{"snippet": "Series.divmod(other, level=None, axis=0)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator divmod ) . With arguments `level`, `axis`.", "question_id": 38638}
{"snippet": "Series.divmod(other, fill_value=None, axis=0)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator divmod ) . Equivalent to divmod ( series , other ) , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 38639}
{"snippet": "Series.divmod(other, level=None, fill_value=None, axis=0)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator divmod ) . Equivalent to divmod ( series , other ) , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 38640}
{"snippet": "Series.divmod(other)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator divmod ) .", "question_id": 38641}
{"snippet": "Series.divmod(other, level=None)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator divmod ) . With arguments `level`.", "question_id": 38642}
{"snippet": "Series.divmod(other, fill_value=None)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator divmod ) . Equivalent to divmod ( series , other ) , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 38643}
{"snippet": "Series.divmod(other, axis=0)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator divmod ) . With arguments `axis`.", "question_id": 38644}
{"snippet": "Series.divmod(other, level=None, fill_value=None)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator divmod ) . Equivalent to divmod ( series , other ) , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 38645}
{"snippet": "Series.divmod(other, level=None, axis=0)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator divmod ) . With arguments `level`, `axis`.", "question_id": 38646}
{"snippet": "Series.divmod(other, fill_value=None, axis=0)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator divmod ) . Equivalent to divmod ( series , other ) , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 38647}
{"snippet": "Series.divmod(other, level=None, fill_value=None, axis=0)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator divmod ) . Equivalent to divmod ( series , other ) , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 38648}
{"snippet": "Series.divmod(other)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator divmod ) .", "question_id": 38649}
{"snippet": "Series.divmod(other, level=None)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator divmod ) . With arguments `level`.", "question_id": 38650}
{"snippet": "Series.divmod(other, fill_value=None)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator divmod ) . Equivalent to divmod ( series , other ) , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 38651}
{"snippet": "Series.divmod(other, axis=0)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator divmod ) . With arguments `axis`.", "question_id": 38652}
{"snippet": "Series.divmod(other, level=None, fill_value=None)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator divmod ) . Equivalent to divmod ( series , other ) , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 38653}
{"snippet": "Series.divmod(other, level=None, axis=0)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator divmod ) . With arguments `level`, `axis`.", "question_id": 38654}
{"snippet": "Series.divmod(other, fill_value=None, axis=0)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator divmod ) . Equivalent to divmod ( series , other ) , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 38655}
{"snippet": "Series.divmod(other, level=None, fill_value=None, axis=0)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator divmod ) . Equivalent to divmod ( series , other ) , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 38656}
{"snippet": "Series.dot(other)", "intent": "Compute the dot product between the Series and the columns of `other` .", "question_id": 38657}
{"snippet": "Series.dot(other)", "intent": "Compute the dot product between the Series and the columns of `other` .", "question_id": 38658}
{"snippet": "Series.dot(other)", "intent": "Compute the dot product between the Series and the columns of `other` .", "question_id": 38659}
{"snippet": "Series.drop()", "intent": "Return Series with specified `index` `labels` removed .", "question_id": 38660}
{"snippet": "Series.drop(labels=None)", "intent": "Return Series with specified `index` `labels` removed .", "question_id": 38661}
{"snippet": "Series.drop(axis=0)", "intent": "Return Series with specified `index` `labels` removed . With arguments `axis`.", "question_id": 38662}
{"snippet": "Series.drop(index=None)", "intent": "Return Series with specified `index` `labels` removed .", "question_id": 38663}
{"snippet": "Series.drop(columns=None)", "intent": "Return Series with specified `index` `labels` removed . With arguments `columns`.", "question_id": 38664}
{"snippet": "Series.drop(level=None)", "intent": "Return Series with specified `index` `labels` removed . When using a multi-index , labels on different levels can be removed by specifying the `level` .", "question_id": 38665}
{"snippet": "Series.drop(inplace=False)", "intent": "Return Series with specified `index` `labels` removed . With arguments `inplace`.", "question_id": 38666}
{"snippet": "Series.drop(errors='raise')", "intent": "Return Series with specified `index` `labels` removed . With arguments `errors`.", "question_id": 38667}
{"snippet": "Series.drop(labels=None, axis=0)", "intent": "Return Series with specified `index` `labels` removed . With arguments `axis`.", "question_id": 38668}
{"snippet": "Series.drop(labels=None, index=None)", "intent": "Return Series with specified `index` `labels` removed .", "question_id": 38669}
{"snippet": "Series.drop()", "intent": "Return Series with specified `index` `labels` removed .", "question_id": 38670}
{"snippet": "Series.drop(labels=None)", "intent": "Return Series with specified `index` `labels` removed .", "question_id": 38671}
{"snippet": "Series.drop(axis=0)", "intent": "Return Series with specified `index` `labels` removed . With arguments `axis`.", "question_id": 38672}
{"snippet": "Series.drop(index=None)", "intent": "Return Series with specified `index` `labels` removed .", "question_id": 38673}
{"snippet": "Series.drop(columns=None)", "intent": "Return Series with specified `index` `labels` removed . With arguments `columns`.", "question_id": 38674}
{"snippet": "Series.drop(level=None)", "intent": "Return Series with specified `index` `labels` removed . When using a multi-index , labels on different levels can be removed by specifying the `level` .", "question_id": 38675}
{"snippet": "Series.drop(inplace=False)", "intent": "Return Series with specified `index` `labels` removed . With arguments `inplace`.", "question_id": 38676}
{"snippet": "Series.drop(errors='raise')", "intent": "Return Series with specified `index` `labels` removed . With arguments `errors`.", "question_id": 38677}
{"snippet": "Series.drop(labels=None, axis=0)", "intent": "Return Series with specified `index` `labels` removed . With arguments `axis`.", "question_id": 38678}
{"snippet": "Series.drop(labels=None, index=None)", "intent": "Return Series with specified `index` `labels` removed .", "question_id": 38679}
{"snippet": "Series.drop()", "intent": "Return Series with specified `index` `labels` removed .", "question_id": 38680}
{"snippet": "Series.drop(labels=None)", "intent": "Return Series with specified `index` `labels` removed .", "question_id": 38681}
{"snippet": "Series.drop(axis=0)", "intent": "Return Series with specified `index` `labels` removed . With arguments `axis`.", "question_id": 38682}
{"snippet": "Series.drop(index=None)", "intent": "Return Series with specified `index` `labels` removed .", "question_id": 38683}
{"snippet": "Series.drop(columns=None)", "intent": "Return Series with specified `index` `labels` removed . With arguments `columns`.", "question_id": 38684}
{"snippet": "Series.drop(level=None)", "intent": "Return Series with specified `index` `labels` removed . When using a multi-index , labels on different levels can be removed by specifying the `level` .", "question_id": 38685}
{"snippet": "Series.drop(inplace=False)", "intent": "Return Series with specified `index` `labels` removed . With arguments `inplace`.", "question_id": 38686}
{"snippet": "Series.drop(errors='raise')", "intent": "Return Series with specified `index` `labels` removed . With arguments `errors`.", "question_id": 38687}
{"snippet": "Series.drop(labels=None, axis=0)", "intent": "Return Series with specified `index` `labels` removed . With arguments `axis`.", "question_id": 38688}
{"snippet": "Series.drop(labels=None, index=None)", "intent": "Return Series with specified `index` `labels` removed .", "question_id": 38689}
{"snippet": "Series.drop_duplicates()", "intent": "Return Series with duplicate values removed .", "question_id": 38690}
{"snippet": "Series.drop_duplicates(keep='first')", "intent": "Return Series with duplicate values removed . With the \u2018 `keep` \u2019 parameter , the selection behaviour of duplicated values can be changed .", "question_id": 38691}
{"snippet": "Series.drop_duplicates(inplace=False)", "intent": "Return Series with duplicate values removed . Setting the value of \u2018 `inplace` \u2019 to True performs the operation inplace and returns None .", "question_id": 38692}
{"snippet": "Series.drop_duplicates(keep='first', inplace=False)", "intent": "Return Series with duplicate values removed . With the \u2018 `keep` \u2019 parameter , the selection behaviour of duplicated values can be changed . Setting the value of \u2018 `inplace` \u2019 to True performs the operation inplace and returns None .", "question_id": 38693}
{"snippet": "Series.drop_duplicates()", "intent": "Return Series with duplicate values removed .", "question_id": 38694}
{"snippet": "Series.drop_duplicates(keep='first')", "intent": "Return Series with duplicate values removed . With the \u2018 `keep` \u2019 parameter , the selection behaviour of duplicated values can be changed .", "question_id": 38695}
{"snippet": "Series.drop_duplicates(inplace=False)", "intent": "Return Series with duplicate values removed . Setting the value of \u2018 `inplace` \u2019 to True performs the operation inplace and returns None .", "question_id": 38696}
{"snippet": "Series.drop_duplicates(keep='first', inplace=False)", "intent": "Return Series with duplicate values removed . With the \u2018 `keep` \u2019 parameter , the selection behaviour of duplicated values can be changed . Setting the value of \u2018 `inplace` \u2019 to True performs the operation inplace and returns None .", "question_id": 38697}
{"snippet": "Series.drop_duplicates()", "intent": "Return Series with duplicate values removed .", "question_id": 38698}
{"snippet": "Series.drop_duplicates(keep='first')", "intent": "Return Series with duplicate values removed . With the \u2018 `keep` \u2019 parameter , the selection behaviour of duplicated values can be changed .", "question_id": 38699}
{"snippet": "Series.drop_duplicates(inplace=False)", "intent": "Return Series with duplicate values removed . Setting the value of \u2018 `inplace` \u2019 to True performs the operation inplace and returns None .", "question_id": 38700}
{"snippet": "Series.drop_duplicates(keep='first', inplace=False)", "intent": "Return Series with duplicate values removed . With the \u2018 `keep` \u2019 parameter , the selection behaviour of duplicated values can be changed . Setting the value of \u2018 `inplace` \u2019 to True performs the operation inplace and returns None .", "question_id": 38701}
{"snippet": "Series.droplevel(level)", "intent": "Return Series/DataFrame with requested index / column `level` ( s ) removed .", "question_id": 38702}
{"snippet": "Series.droplevel(level, axis=0)", "intent": "Return Series/DataFrame with requested index / column `level` ( s ) removed . With arguments `axis`.", "question_id": 38703}
{"snippet": "Series.droplevel(level)", "intent": "Return Series/DataFrame with requested index / column `level` ( s ) removed .", "question_id": 38704}
{"snippet": "Series.droplevel(level, axis=0)", "intent": "Return Series/DataFrame with requested index / column `level` ( s ) removed . With arguments `axis`.", "question_id": 38705}
{"snippet": "Series.droplevel(level)", "intent": "Return Series/DataFrame with requested index / column `level` ( s ) removed .", "question_id": 38706}
{"snippet": "Series.droplevel(level, axis=0)", "intent": "Return Series/DataFrame with requested index / column `level` ( s ) removed . With arguments `axis`.", "question_id": 38707}
{"snippet": "Series.dropna()", "intent": "Return a new Series with missing values removed .", "question_id": 38708}
{"snippet": "Series.dropna(axis=0)", "intent": "Return a new Series with missing values removed . With arguments `axis`.", "question_id": 38709}
{"snippet": "Series.dropna(inplace=False)", "intent": "Return a new Series with missing values removed . With arguments `inplace`.", "question_id": 38710}
{"snippet": "Series.dropna(how=None)", "intent": "Return a new Series with missing values removed . See the User Guide for more on which values are considered missing , and `how` to work with missing data .", "question_id": 38711}
{"snippet": "Series.dropna(axis=0, inplace=False)", "intent": "Return a new Series with missing values removed . With arguments `axis`, `inplace`.", "question_id": 38712}
{"snippet": "Series.dropna(axis=0, how=None)", "intent": "Return a new Series with missing values removed . See the User Guide for more on which values are considered missing , and `how` to work with missing data . With arguments `axis`.", "question_id": 38713}
{"snippet": "Series.dropna(inplace=False, how=None)", "intent": "Return a new Series with missing values removed . See the User Guide for more on which values are considered missing , and `how` to work with missing data . With arguments `inplace`.", "question_id": 38714}
{"snippet": "Series.dropna(axis=0, inplace=False, how=None)", "intent": "Return a new Series with missing values removed . See the User Guide for more on which values are considered missing , and `how` to work with missing data . With arguments `axis`, `inplace`.", "question_id": 38715}
{"snippet": "Series.dropna()", "intent": "Return a new Series with missing values removed .", "question_id": 38716}
{"snippet": "Series.dropna(axis=0)", "intent": "Return a new Series with missing values removed . With arguments `axis`.", "question_id": 38717}
{"snippet": "Series.dropna(inplace=False)", "intent": "Return a new Series with missing values removed . With arguments `inplace`.", "question_id": 38718}
{"snippet": "Series.dropna(how=None)", "intent": "Return a new Series with missing values removed . See the User Guide for more on which values are considered missing , and `how` to work with missing data .", "question_id": 38719}
{"snippet": "Series.dropna(axis=0, inplace=False)", "intent": "Return a new Series with missing values removed . With arguments `axis`, `inplace`.", "question_id": 38720}
{"snippet": "Series.dropna(axis=0, how=None)", "intent": "Return a new Series with missing values removed . See the User Guide for more on which values are considered missing , and `how` to work with missing data . With arguments `axis`.", "question_id": 38721}
{"snippet": "Series.dropna(inplace=False, how=None)", "intent": "Return a new Series with missing values removed . See the User Guide for more on which values are considered missing , and `how` to work with missing data . With arguments `inplace`.", "question_id": 38722}
{"snippet": "Series.dropna(axis=0, inplace=False, how=None)", "intent": "Return a new Series with missing values removed . See the User Guide for more on which values are considered missing , and `how` to work with missing data . With arguments `axis`, `inplace`.", "question_id": 38723}
{"snippet": "Series.dropna()", "intent": "Return a new Series with missing values removed .", "question_id": 38724}
{"snippet": "Series.dropna(axis=0)", "intent": "Return a new Series with missing values removed . With arguments `axis`.", "question_id": 38725}
{"snippet": "Series.dropna(inplace=False)", "intent": "Return a new Series with missing values removed . With arguments `inplace`.", "question_id": 38726}
{"snippet": "Series.dropna(how=None)", "intent": "Return a new Series with missing values removed . See the User Guide for more on which values are considered missing , and `how` to work with missing data .", "question_id": 38727}
{"snippet": "Series.dropna(axis=0, inplace=False)", "intent": "Return a new Series with missing values removed . With arguments `axis`, `inplace`.", "question_id": 38728}
{"snippet": "Series.dropna(axis=0, how=None)", "intent": "Return a new Series with missing values removed . See the User Guide for more on which values are considered missing , and `how` to work with missing data . With arguments `axis`.", "question_id": 38729}
{"snippet": "Series.dropna(inplace=False, how=None)", "intent": "Return a new Series with missing values removed . See the User Guide for more on which values are considered missing , and `how` to work with missing data . With arguments `inplace`.", "question_id": 38730}
{"snippet": "Series.dropna(axis=0, inplace=False, how=None)", "intent": "Return a new Series with missing values removed . See the User Guide for more on which values are considered missing , and `how` to work with missing data . With arguments `axis`, `inplace`.", "question_id": 38731}
{"snippet": "Series.dt.ceil(*args, **kwargs)", "intent": "Perform ceil operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 38732}
{"snippet": "Series.dt.ceil(*args, **kwargs)", "intent": "Perform ceil operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 38733}
{"snippet": "Series.dt.ceil(*args, **kwargs)", "intent": "Perform ceil operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 38734}
{"snippet": "Series.dt.components", "intent": "Return a Dataframe of the components of the Timedeltas.", "question_id": 38735}
{"snippet": "Series.dt.components", "intent": "Return a Dataframe of the components of the Timedeltas.", "question_id": 38736}
{"snippet": "Series.dt.components", "intent": "Return a Dataframe of the components of the Timedeltas.", "question_id": 38737}
{"snippet": "Series.dt.date", "intent": "Returns numpy array of python datetime.date objects (namely, the date part of Timestamps without timezone information).", "question_id": 38738}
{"snippet": "Series.dt.date", "intent": "Returns numpy array of python datetime.date objects (namely, the date part of Timestamps without timezone information).", "question_id": 38739}
{"snippet": "Series.dt.date", "intent": "Returns numpy array of python datetime.date objects (namely, the date part of Timestamps without timezone information).", "question_id": 38740}
{"snippet": "Series.dt.day", "intent": "The day of the datetime.", "question_id": 38741}
{"snippet": "Series.dt.day", "intent": "The day of the datetime.", "question_id": 38742}
{"snippet": "Series.dt.day", "intent": "The day of the datetime.", "question_id": 38743}
{"snippet": "Series.dt.day_name(*args, **kwargs)", "intent": "Return the day names of the DateTimeIndex with specified locale . With arguments `*args`, `**kwargs`.", "question_id": 38744}
{"snippet": "Series.dt.day_name(*args, **kwargs)", "intent": "Return the day names of the DateTimeIndex with specified locale . With arguments `*args`, `**kwargs`.", "question_id": 38745}
{"snippet": "Series.dt.day_name(*args, **kwargs)", "intent": "Return the day names of the DateTimeIndex with specified locale . With arguments `*args`, `**kwargs`.", "question_id": 38746}
{"snippet": "Series.dt.day_of_week", "intent": "The day of the week with Monday=0, Sunday=6.", "question_id": 38747}
{"snippet": "Series.dt.day_of_week", "intent": "The day of the week with Monday=0, Sunday=6.", "question_id": 38748}
{"snippet": "Series.dt.day_of_week", "intent": "The day of the week with Monday=0, Sunday=6.", "question_id": 38749}
{"snippet": "Series.dt.day_of_year", "intent": "The ordinal day of the year.", "question_id": 38750}
{"snippet": "Series.dt.day_of_year", "intent": "The ordinal day of the year.", "question_id": 38751}
{"snippet": "Series.dt.day_of_year", "intent": "The ordinal day of the year.", "question_id": 38752}
{"snippet": "Series.dt.dayofweek", "intent": "The day of the week with Monday=0, Sunday=6.", "question_id": 38753}
{"snippet": "Series.dt.dayofweek", "intent": "The day of the week with Monday=0, Sunday=6.", "question_id": 38754}
{"snippet": "Series.dt.dayofweek", "intent": "The day of the week with Monday=0, Sunday=6.", "question_id": 38755}
{"snippet": "Series.dt.dayofyear", "intent": "The ordinal day of the year.", "question_id": 38756}
{"snippet": "Series.dt.dayofyear", "intent": "The ordinal day of the year.", "question_id": 38757}
{"snippet": "Series.dt.dayofyear", "intent": "The ordinal day of the year.", "question_id": 38758}
{"snippet": "Series.dt.days", "intent": "Number of days for each element.", "question_id": 38759}
{"snippet": "Series.dt.days", "intent": "Number of days for each element.", "question_id": 38760}
{"snippet": "Series.dt.days", "intent": "Number of days for each element.", "question_id": 38761}
{"snippet": "Series.dt.days_in_month", "intent": "The number of days in the month.", "question_id": 38762}
{"snippet": "Series.dt.days_in_month", "intent": "The number of days in the month.", "question_id": 38763}
{"snippet": "Series.dt.days_in_month", "intent": "The number of days in the month.", "question_id": 38764}
{"snippet": "Series.dt.daysinmonth", "intent": "The number of days in the month.", "question_id": 38765}
{"snippet": "Series.dt.daysinmonth", "intent": "The number of days in the month.", "question_id": 38766}
{"snippet": "Series.dt.daysinmonth", "intent": "The number of days in the month.", "question_id": 38767}
{"snippet": "Series.dt.floor(*args, **kwargs)", "intent": "Perform floor operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 38768}
{"snippet": "Series.dt.floor(*args, **kwargs)", "intent": "Perform floor operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 38769}
{"snippet": "Series.dt.floor(*args, **kwargs)", "intent": "Perform floor operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 38770}
{"snippet": "Series.dt.hour", "intent": "The hours of the datetime.", "question_id": 38771}
{"snippet": "Series.dt.hour", "intent": "The hours of the datetime.", "question_id": 38772}
{"snippet": "Series.dt.hour", "intent": "The hours of the datetime.", "question_id": 38773}
{"snippet": "Series.dt()", "intent": "Accessor object for datetimelike properties of the Series values .", "question_id": 38774}
{"snippet": "Series.dt()", "intent": "Accessor object for datetimelike properties of the Series values .", "question_id": 38775}
{"snippet": "Series.dt()", "intent": "Accessor object for datetimelike properties of the Series values .", "question_id": 38776}
{"snippet": "Series.dt.is_leap_year", "intent": "Boolean indicator if the date belongs to a leap year.", "question_id": 38777}
{"snippet": "Series.dt.is_leap_year", "intent": "Boolean indicator if the date belongs to a leap year.", "question_id": 38778}
{"snippet": "Series.dt.is_leap_year", "intent": "Boolean indicator if the date belongs to a leap year.", "question_id": 38779}
{"snippet": "Series.dt.is_month_end", "intent": "Indicates whether the date is the last day of the month.", "question_id": 38780}
{"snippet": "Series.dt.is_month_end", "intent": "Indicates whether the date is the last day of the month.", "question_id": 38781}
{"snippet": "Series.dt.is_month_end", "intent": "Indicates whether the date is the last day of the month.", "question_id": 38782}
{"snippet": "Series.dt.is_month_start", "intent": "Indicates whether the date is the first day of the month.", "question_id": 38783}
{"snippet": "Series.dt.is_month_start", "intent": "Indicates whether the date is the first day of the month.", "question_id": 38784}
{"snippet": "Series.dt.is_month_start", "intent": "Indicates whether the date is the first day of the month.", "question_id": 38785}
{"snippet": "Series.dt.is_quarter_end", "intent": "Indicator for whether the date is the last day of a quarter.", "question_id": 38786}
{"snippet": "Series.dt.is_quarter_end", "intent": "Indicator for whether the date is the last day of a quarter.", "question_id": 38787}
{"snippet": "Series.dt.is_quarter_end", "intent": "Indicator for whether the date is the last day of a quarter.", "question_id": 38788}
{"snippet": "Series.dt.is_quarter_start", "intent": "Indicator for whether the date is the first day of a quarter.", "question_id": 38789}
{"snippet": "Series.dt.is_quarter_start", "intent": "Indicator for whether the date is the first day of a quarter.", "question_id": 38790}
{"snippet": "Series.dt.is_quarter_start", "intent": "Indicator for whether the date is the first day of a quarter.", "question_id": 38791}
{"snippet": "Series.dt.is_year_end", "intent": "Indicate whether the date is the last day of the year.", "question_id": 38792}
{"snippet": "Series.dt.is_year_end", "intent": "Indicate whether the date is the last day of the year.", "question_id": 38793}
{"snippet": "Series.dt.is_year_end", "intent": "Indicate whether the date is the last day of the year.", "question_id": 38794}
{"snippet": "Series.dt.is_year_start", "intent": "Indicate whether the date is the first day of a year.", "question_id": 38795}
{"snippet": "Series.dt.is_year_start", "intent": "Indicate whether the date is the first day of a year.", "question_id": 38796}
{"snippet": "Series.dt.is_year_start", "intent": "Indicate whether the date is the first day of a year.", "question_id": 38797}
{"snippet": "Series.dt.microsecond", "intent": "The microseconds of the datetime.", "question_id": 38798}
{"snippet": "Series.dt.microsecond", "intent": "The microseconds of the datetime.", "question_id": 38799}
{"snippet": "Series.dt.microsecond", "intent": "The microseconds of the datetime.", "question_id": 38800}
{"snippet": "Series.dt.microseconds", "intent": "Number of microseconds (>= 0 and less than 1 second) for each element.", "question_id": 38801}
{"snippet": "Series.dt.microseconds", "intent": "Number of microseconds (>= 0 and less than 1 second) for each element.", "question_id": 38802}
{"snippet": "Series.dt.microseconds", "intent": "Number of microseconds (>= 0 and less than 1 second) for each element.", "question_id": 38803}
{"snippet": "Series.dt.minute", "intent": "The minutes of the datetime.", "question_id": 38804}
{"snippet": "Series.dt.minute", "intent": "The minutes of the datetime.", "question_id": 38805}
{"snippet": "Series.dt.minute", "intent": "The minutes of the datetime.", "question_id": 38806}
{"snippet": "Series.dt.month", "intent": "The month as January=1, December=12.", "question_id": 38807}
{"snippet": "Series.dt.month", "intent": "The month as January=1, December=12.", "question_id": 38808}
{"snippet": "Series.dt.month", "intent": "The month as January=1, December=12.", "question_id": 38809}
{"snippet": "Series.dt.month_name(*args, **kwargs)", "intent": "Return the month names of the DateTimeIndex with specified locale . With arguments `*args`, `**kwargs`.", "question_id": 38810}
{"snippet": "Series.dt.month_name(*args, **kwargs)", "intent": "Return the month names of the DateTimeIndex with specified locale . With arguments `*args`, `**kwargs`.", "question_id": 38811}
{"snippet": "Series.dt.month_name(*args, **kwargs)", "intent": "Return the month names of the DateTimeIndex with specified locale . With arguments `*args`, `**kwargs`.", "question_id": 38812}
{"snippet": "Series.dt.nanosecond", "intent": "The nanoseconds of the datetime.", "question_id": 38813}
{"snippet": "Series.dt.nanosecond", "intent": "The nanoseconds of the datetime.", "question_id": 38814}
{"snippet": "Series.dt.nanosecond", "intent": "The nanoseconds of the datetime.", "question_id": 38815}
{"snippet": "Series.dt.nanoseconds", "intent": "Number of nanoseconds (>= 0 and less than 1 microsecond) for each element.", "question_id": 38816}
{"snippet": "Series.dt.nanoseconds", "intent": "Number of nanoseconds (>= 0 and less than 1 microsecond) for each element.", "question_id": 38817}
{"snippet": "Series.dt.nanoseconds", "intent": "Number of nanoseconds (>= 0 and less than 1 microsecond) for each element.", "question_id": 38818}
{"snippet": "Series.dt.normalize(*args, **kwargs)", "intent": "Convert times to midnight . With arguments `*args`, `**kwargs`.", "question_id": 38819}
{"snippet": "Series.dt.normalize(*args, **kwargs)", "intent": "Convert times to midnight . With arguments `*args`, `**kwargs`.", "question_id": 38820}
{"snippet": "Series.dt.normalize(*args, **kwargs)", "intent": "Convert times to midnight . With arguments `*args`, `**kwargs`.", "question_id": 38821}
{"snippet": "Series.dt.quarter", "intent": "The quarter of the date.", "question_id": 38822}
{"snippet": "Series.dt.quarter", "intent": "The quarter of the date.", "question_id": 38823}
{"snippet": "Series.dt.quarter", "intent": "The quarter of the date.", "question_id": 38824}
{"snippet": "Series.dt.round(*args, **kwargs)", "intent": "Perform round operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 38825}
{"snippet": "Series.dt.round(*args, **kwargs)", "intent": "Perform round operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 38826}
{"snippet": "Series.dt.round(*args, **kwargs)", "intent": "Perform round operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 38827}
{"snippet": "Series.dt.second", "intent": "The seconds of the datetime.", "question_id": 38828}
{"snippet": "Series.dt.second", "intent": "The seconds of the datetime.", "question_id": 38829}
{"snippet": "Series.dt.second", "intent": "The seconds of the datetime.", "question_id": 38830}
{"snippet": "Series.dt.seconds", "intent": "Number of seconds (>= 0 and less than 1 day) for each element.", "question_id": 38831}
{"snippet": "Series.dt.seconds", "intent": "Number of seconds (>= 0 and less than 1 day) for each element.", "question_id": 38832}
{"snippet": "Series.dt.seconds", "intent": "Number of seconds (>= 0 and less than 1 day) for each element.", "question_id": 38833}
{"snippet": "Series.dt.strftime(*args, **kwargs)", "intent": "Convert to Index using specified date_format . With arguments `*args`, `**kwargs`.", "question_id": 38834}
{"snippet": "Series.dt.strftime(*args, **kwargs)", "intent": "Convert to Index using specified date_format . With arguments `*args`, `**kwargs`.", "question_id": 38835}
{"snippet": "Series.dt.strftime(*args, **kwargs)", "intent": "Convert to Index using specified date_format . With arguments `*args`, `**kwargs`.", "question_id": 38836}
{"snippet": "Series.dt.time", "intent": "Returns numpy array of datetime.time.", "question_id": 38837}
{"snippet": "Series.dt.time", "intent": "Returns numpy array of datetime.time.", "question_id": 38838}
{"snippet": "Series.dt.time", "intent": "Returns numpy array of datetime.time.", "question_id": 38839}
{"snippet": "Series.dt.timetz", "intent": "Returns numpy array of datetime.time also containing timezone information.", "question_id": 38840}
{"snippet": "Series.dt.timetz", "intent": "Returns numpy array of datetime.time also containing timezone information.", "question_id": 38841}
{"snippet": "Series.dt.timetz", "intent": "Returns numpy array of datetime.time also containing timezone information.", "question_id": 38842}
{"snippet": "Series.dt.to_period(*args, **kwargs)", "intent": "Cast to PeriodArray/Index at a particular frequency . With arguments `*args`, `**kwargs`.", "question_id": 38843}
{"snippet": "Series.dt.to_period(*args, **kwargs)", "intent": "Cast to PeriodArray/Index at a particular frequency . With arguments `*args`, `**kwargs`.", "question_id": 38844}
{"snippet": "Series.dt.to_period(*args, **kwargs)", "intent": "Cast to PeriodArray/Index at a particular frequency . With arguments `*args`, `**kwargs`.", "question_id": 38845}
{"snippet": "Series.dt.to_pydatetime()", "intent": "Return the data as an array of native Python datetime objects .", "question_id": 38846}
{"snippet": "Series.dt.to_pydatetime()", "intent": "Return the data as an array of native Python datetime objects .", "question_id": 38847}
{"snippet": "Series.dt.to_pydatetime()", "intent": "Return the data as an array of native Python datetime objects .", "question_id": 38848}
{"snippet": "Series.dt.to_pytimedelta()", "intent": "Return an array of native datetime.timedelta objects .", "question_id": 38849}
{"snippet": "Series.dt.to_pytimedelta()", "intent": "Return an array of native datetime.timedelta objects .", "question_id": 38850}
{"snippet": "Series.dt.to_pytimedelta()", "intent": "Return an array of native datetime.timedelta objects .", "question_id": 38851}
{"snippet": "Series.dt.total_seconds(*args, **kwargs)", "intent": "Return total duration of each element expressed in seconds . With arguments `*args`, `**kwargs`.", "question_id": 38852}
{"snippet": "Series.dt.total_seconds(*args, **kwargs)", "intent": "Return total duration of each element expressed in seconds . With arguments `*args`, `**kwargs`.", "question_id": 38853}
{"snippet": "Series.dt.total_seconds(*args, **kwargs)", "intent": "Return total duration of each element expressed in seconds . With arguments `*args`, `**kwargs`.", "question_id": 38854}
{"snippet": "Series.dt.tz", "intent": "Return timezone, if any.", "question_id": 38855}
{"snippet": "Series.dt.tz", "intent": "Return timezone, if any.", "question_id": 38856}
{"snippet": "Series.dt.tz", "intent": "Return timezone, if any.", "question_id": 38857}
{"snippet": "Series.dt.tz_convert(*args, **kwargs)", "intent": "Convert tz-aware Datetime Array/Index from one time zone to another . With arguments `*args`, `**kwargs`.", "question_id": 38858}
{"snippet": "Series.dt.tz_convert(*args, **kwargs)", "intent": "Convert tz-aware Datetime Array/Index from one time zone to another . With arguments `*args`, `**kwargs`.", "question_id": 38859}
{"snippet": "Series.dt.tz_convert(*args, **kwargs)", "intent": "Convert tz-aware Datetime Array/Index from one time zone to another . With arguments `*args`, `**kwargs`.", "question_id": 38860}
{"snippet": "Series.dt.tz_localize(*args, **kwargs)", "intent": "Localize tz-naive Datetime Array/Index to tz-aware Datetime Array/Index . With arguments `*args`, `**kwargs`.", "question_id": 38861}
{"snippet": "Series.dt.tz_localize(*args, **kwargs)", "intent": "Localize tz-naive Datetime Array/Index to tz-aware Datetime Array/Index . With arguments `*args`, `**kwargs`.", "question_id": 38862}
{"snippet": "Series.dt.tz_localize(*args, **kwargs)", "intent": "Localize tz-naive Datetime Array/Index to tz-aware Datetime Array/Index . With arguments `*args`, `**kwargs`.", "question_id": 38863}
{"snippet": "Series.dt.week", "intent": "The week ordinal of the year.", "question_id": 38864}
{"snippet": "Series.dt.week", "intent": "The week ordinal of the year.", "question_id": 38865}
{"snippet": "Series.dt.week", "intent": "The week ordinal of the year.", "question_id": 38866}
{"snippet": "Series.dt.weekday", "intent": "The day of the week with Monday=0, Sunday=6.", "question_id": 38867}
{"snippet": "Series.dt.weekday", "intent": "The day of the week with Monday=0, Sunday=6.", "question_id": 38868}
{"snippet": "Series.dt.weekday", "intent": "The day of the week with Monday=0, Sunday=6.", "question_id": 38869}
{"snippet": "Series.dt.weekofyear", "intent": "The week ordinal of the year.", "question_id": 38870}
{"snippet": "Series.dt.weekofyear", "intent": "The week ordinal of the year.", "question_id": 38871}
{"snippet": "Series.dt.weekofyear", "intent": "The week ordinal of the year.", "question_id": 38872}
{"snippet": "Series.dt.year", "intent": "The year of the datetime.", "question_id": 38873}
{"snippet": "Series.dt.year", "intent": "The year of the datetime.", "question_id": 38874}
{"snippet": "Series.dt.year", "intent": "The year of the datetime.", "question_id": 38875}
{"snippet": "Series.duplicated()", "intent": "Indicate duplicate Series values .", "question_id": 38876}
{"snippet": "Series.duplicated(keep='first')", "intent": "Indicate duplicate Series values . By setting `keep` on False , all duplicates are True :", "question_id": 38877}
{"snippet": "Series.duplicated()", "intent": "Indicate duplicate Series values .", "question_id": 38878}
{"snippet": "Series.duplicated(keep='first')", "intent": "Indicate duplicate Series values . By setting `keep` on False , all duplicates are True :", "question_id": 38879}
{"snippet": "Series.duplicated()", "intent": "Indicate duplicate Series values .", "question_id": 38880}
{"snippet": "Series.duplicated(keep='first')", "intent": "Indicate duplicate Series values . By setting `keep` on False , all duplicates are True :", "question_id": 38881}
{"snippet": "Series.eq(other)", "intent": "Return Equal to of series and `other` , element-wise ( binary operator eq ) .", "question_id": 38882}
{"snippet": "Series.eq(other, level=None)", "intent": "Return Equal to of series and `other` , element-wise ( binary operator eq ) . With arguments `level`.", "question_id": 38883}
{"snippet": "Series.eq(other, fill_value=None)", "intent": "Return Equal to of series and `other` , element-wise ( binary operator eq ) . Equivalent to series == other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 38884}
{"snippet": "Series.eq(other, axis=0)", "intent": "Return Equal to of series and `other` , element-wise ( binary operator eq ) . With arguments `axis`.", "question_id": 38885}
{"snippet": "Series.eq(other, level=None, fill_value=None)", "intent": "Return Equal to of series and `other` , element-wise ( binary operator eq ) . Equivalent to series == other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 38886}
{"snippet": "Series.eq(other, level=None, axis=0)", "intent": "Return Equal to of series and `other` , element-wise ( binary operator eq ) . With arguments `level`, `axis`.", "question_id": 38887}
{"snippet": "Series.eq(other, fill_value=None, axis=0)", "intent": "Return Equal to of series and `other` , element-wise ( binary operator eq ) . Equivalent to series == other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 38888}
{"snippet": "Series.eq(other, level=None, fill_value=None, axis=0)", "intent": "Return Equal to of series and `other` , element-wise ( binary operator eq ) . Equivalent to series == other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 38889}
{"snippet": "Series.eq(other)", "intent": "Return Equal to of series and `other` , element-wise ( binary operator eq ) .", "question_id": 38890}
{"snippet": "Series.eq(other, level=None)", "intent": "Return Equal to of series and `other` , element-wise ( binary operator eq ) . With arguments `level`.", "question_id": 38891}
{"snippet": "Series.eq(other, fill_value=None)", "intent": "Return Equal to of series and `other` , element-wise ( binary operator eq ) . Equivalent to series == other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 38892}
{"snippet": "Series.eq(other, axis=0)", "intent": "Return Equal to of series and `other` , element-wise ( binary operator eq ) . With arguments `axis`.", "question_id": 38893}
{"snippet": "Series.eq(other, level=None, fill_value=None)", "intent": "Return Equal to of series and `other` , element-wise ( binary operator eq ) . Equivalent to series == other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 38894}
{"snippet": "Series.eq(other, level=None, axis=0)", "intent": "Return Equal to of series and `other` , element-wise ( binary operator eq ) . With arguments `level`, `axis`.", "question_id": 38895}
{"snippet": "Series.eq(other, fill_value=None, axis=0)", "intent": "Return Equal to of series and `other` , element-wise ( binary operator eq ) . Equivalent to series == other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 38896}
{"snippet": "Series.eq(other, level=None, fill_value=None, axis=0)", "intent": "Return Equal to of series and `other` , element-wise ( binary operator eq ) . Equivalent to series == other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 38897}
{"snippet": "Series.eq(other)", "intent": "Return Equal to of series and `other` , element-wise ( binary operator eq ) .", "question_id": 38898}
{"snippet": "Series.eq(other, level=None)", "intent": "Return Equal to of series and `other` , element-wise ( binary operator eq ) . With arguments `level`.", "question_id": 38899}
{"snippet": "Series.eq(other, fill_value=None)", "intent": "Return Equal to of series and `other` , element-wise ( binary operator eq ) . Equivalent to series == other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 38900}
{"snippet": "Series.eq(other, axis=0)", "intent": "Return Equal to of series and `other` , element-wise ( binary operator eq ) . With arguments `axis`.", "question_id": 38901}
{"snippet": "Series.eq(other, level=None, fill_value=None)", "intent": "Return Equal to of series and `other` , element-wise ( binary operator eq ) . Equivalent to series == other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 38902}
{"snippet": "Series.eq(other, level=None, axis=0)", "intent": "Return Equal to of series and `other` , element-wise ( binary operator eq ) . With arguments `level`, `axis`.", "question_id": 38903}
{"snippet": "Series.eq(other, fill_value=None, axis=0)", "intent": "Return Equal to of series and `other` , element-wise ( binary operator eq ) . Equivalent to series == other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 38904}
{"snippet": "Series.eq(other, level=None, fill_value=None, axis=0)", "intent": "Return Equal to of series and `other` , element-wise ( binary operator eq ) . Equivalent to series == other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 38905}
{"snippet": "Series.equals(other)", "intent": "Test whether two objects contain the same elements . This function allows two Series or DataFrames to be compared against each `other` to see if they have the same shape and elements .", "question_id": 38906}
{"snippet": "Series.equals(other)", "intent": "Test whether two objects contain the same elements . This function allows two Series or DataFrames to be compared against each `other` to see if they have the same shape and elements .", "question_id": 38907}
{"snippet": "Series.equals(other)", "intent": "Test whether two objects contain the same elements . This function allows two Series or DataFrames to be compared against each `other` to see if they have the same shape and elements .", "question_id": 38908}
{"snippet": "Series.ewm()", "intent": "Provide exponential weighted ( EW ) functions .", "question_id": 38909}
{"snippet": "Series.ewm(com=None)", "intent": "Provide exponential weighted ( EW ) functions . Exactly one parameter : `com` , `span` , `halflife` , or `alpha` must be provided .", "question_id": 38910}
{"snippet": "Series.ewm(span=None)", "intent": "Provide exponential weighted ( EW ) functions . Exactly one parameter : `com` , `span` , `halflife` , or `alpha` must be provided .", "question_id": 38911}
{"snippet": "Series.ewm(halflife=None)", "intent": "Provide exponential weighted ( EW ) functions . Exactly one parameter : `com` , `span` , `halflife` , or `alpha` must be provided .", "question_id": 38912}
{"snippet": "Series.ewm(alpha=None)", "intent": "Provide exponential weighted ( EW ) functions . Exactly one parameter : `com` , `span` , `halflife` , or `alpha` must be provided .", "question_id": 38913}
{"snippet": "Series.ewm(min_periods=0)", "intent": "Provide exponential weighted ( EW ) functions . With arguments `min_periods`.", "question_id": 38914}
{"snippet": "Series.ewm(adjust=True)", "intent": "Provide exponential weighted ( EW ) functions . With arguments `adjust`.", "question_id": 38915}
{"snippet": "Series.ewm(ignore_na=False)", "intent": "Provide exponential weighted ( EW ) functions . With arguments `ignore_na`.", "question_id": 38916}
{"snippet": "Series.ewm(axis=0)", "intent": "Provide exponential weighted ( EW ) functions . With arguments `axis`.", "question_id": 38917}
{"snippet": "Series.ewm(times=None)", "intent": "Provide exponential weighted ( EW ) functions . Specifying `times` with a timedelta halflife when computing mean .", "question_id": 38918}
{"snippet": "Series.ewm()", "intent": "Provide exponential weighted ( EW ) functions .", "question_id": 38919}
{"snippet": "Series.ewm(com=None)", "intent": "Provide exponential weighted ( EW ) functions . Exactly one parameter : `com` , `span` , `halflife` , or `alpha` must be provided .", "question_id": 38920}
{"snippet": "Series.ewm(span=None)", "intent": "Provide exponential weighted ( EW ) functions . Exactly one parameter : `com` , `span` , `halflife` , or `alpha` must be provided .", "question_id": 38921}
{"snippet": "Series.ewm(halflife=None)", "intent": "Provide exponential weighted ( EW ) functions . Exactly one parameter : `com` , `span` , `halflife` , or `alpha` must be provided .", "question_id": 38922}
{"snippet": "Series.ewm(alpha=None)", "intent": "Provide exponential weighted ( EW ) functions . Exactly one parameter : `com` , `span` , `halflife` , or `alpha` must be provided .", "question_id": 38923}
{"snippet": "Series.ewm(min_periods=0)", "intent": "Provide exponential weighted ( EW ) functions . With arguments `min_periods`.", "question_id": 38924}
{"snippet": "Series.ewm(adjust=True)", "intent": "Provide exponential weighted ( EW ) functions . With arguments `adjust`.", "question_id": 38925}
{"snippet": "Series.ewm(ignore_na=False)", "intent": "Provide exponential weighted ( EW ) functions . With arguments `ignore_na`.", "question_id": 38926}
{"snippet": "Series.ewm(axis=0)", "intent": "Provide exponential weighted ( EW ) functions . With arguments `axis`.", "question_id": 38927}
{"snippet": "Series.ewm(times=None)", "intent": "Provide exponential weighted ( EW ) functions . Specifying `times` with a timedelta halflife when computing mean .", "question_id": 38928}
{"snippet": "Series.ewm()", "intent": "Provide exponential weighted ( EW ) functions .", "question_id": 38929}
{"snippet": "Series.ewm(com=None)", "intent": "Provide exponential weighted ( EW ) functions . Exactly one parameter : `com` , `span` , `halflife` , or `alpha` must be provided .", "question_id": 38930}
{"snippet": "Series.ewm(span=None)", "intent": "Provide exponential weighted ( EW ) functions . Exactly one parameter : `com` , `span` , `halflife` , or `alpha` must be provided .", "question_id": 38931}
{"snippet": "Series.ewm(halflife=None)", "intent": "Provide exponential weighted ( EW ) functions . Exactly one parameter : `com` , `span` , `halflife` , or `alpha` must be provided .", "question_id": 38932}
{"snippet": "Series.ewm(alpha=None)", "intent": "Provide exponential weighted ( EW ) functions . Exactly one parameter : `com` , `span` , `halflife` , or `alpha` must be provided .", "question_id": 38933}
{"snippet": "Series.ewm(min_periods=0)", "intent": "Provide exponential weighted ( EW ) functions . With arguments `min_periods`.", "question_id": 38934}
{"snippet": "Series.ewm(adjust=True)", "intent": "Provide exponential weighted ( EW ) functions . With arguments `adjust`.", "question_id": 38935}
{"snippet": "Series.ewm(ignore_na=False)", "intent": "Provide exponential weighted ( EW ) functions . With arguments `ignore_na`.", "question_id": 38936}
{"snippet": "Series.ewm(axis=0)", "intent": "Provide exponential weighted ( EW ) functions . With arguments `axis`.", "question_id": 38937}
{"snippet": "Series.ewm(times=None)", "intent": "Provide exponential weighted ( EW ) functions . Specifying `times` with a timedelta halflife when computing mean .", "question_id": 38938}
{"snippet": "Series.expanding()", "intent": "Provide expanding transformations .", "question_id": 38939}
{"snippet": "Series.expanding(min_periods=1)", "intent": "Provide expanding transformations . With arguments `min_periods`.", "question_id": 38940}
{"snippet": "Series.expanding(center=None)", "intent": "Provide expanding transformations . This can be changed to the `center` of the window by setting center=True .", "question_id": 38941}
{"snippet": "Series.expanding(axis=0)", "intent": "Provide expanding transformations . With arguments `axis`.", "question_id": 38942}
{"snippet": "Series.expanding(method='single')", "intent": "Provide expanding transformations . With arguments `method`.", "question_id": 38943}
{"snippet": "Series.expanding(min_periods=1, center=None)", "intent": "Provide expanding transformations . This can be changed to the `center` of the window by setting center=True . With arguments `min_periods`.", "question_id": 38944}
{"snippet": "Series.expanding(min_periods=1, axis=0)", "intent": "Provide expanding transformations . With arguments `min_periods`, `axis`.", "question_id": 38945}
{"snippet": "Series.expanding(min_periods=1, method='single')", "intent": "Provide expanding transformations . With arguments `min_periods`, `method`.", "question_id": 38946}
{"snippet": "Series.expanding(center=None, axis=0)", "intent": "Provide expanding transformations . This can be changed to the `center` of the window by setting center=True . With arguments `axis`.", "question_id": 38947}
{"snippet": "Series.expanding(center=None, method='single')", "intent": "Provide expanding transformations . This can be changed to the `center` of the window by setting center=True . With arguments `method`.", "question_id": 38948}
{"snippet": "Series.expanding()", "intent": "Provide expanding transformations .", "question_id": 38949}
{"snippet": "Series.expanding(min_periods=1)", "intent": "Provide expanding transformations . With arguments `min_periods`.", "question_id": 38950}
{"snippet": "Series.expanding(center=None)", "intent": "Provide expanding transformations . This can be changed to the `center` of the window by setting center=True .", "question_id": 38951}
{"snippet": "Series.expanding(axis=0)", "intent": "Provide expanding transformations . With arguments `axis`.", "question_id": 38952}
{"snippet": "Series.expanding(method='single')", "intent": "Provide expanding transformations . With arguments `method`.", "question_id": 38953}
{"snippet": "Series.expanding(min_periods=1, center=None)", "intent": "Provide expanding transformations . This can be changed to the `center` of the window by setting center=True . With arguments `min_periods`.", "question_id": 38954}
{"snippet": "Series.expanding(min_periods=1, axis=0)", "intent": "Provide expanding transformations . With arguments `min_periods`, `axis`.", "question_id": 38955}
{"snippet": "Series.expanding(min_periods=1, method='single')", "intent": "Provide expanding transformations . With arguments `min_periods`, `method`.", "question_id": 38956}
{"snippet": "Series.expanding(center=None, axis=0)", "intent": "Provide expanding transformations . This can be changed to the `center` of the window by setting center=True . With arguments `axis`.", "question_id": 38957}
{"snippet": "Series.expanding(center=None, method='single')", "intent": "Provide expanding transformations . This can be changed to the `center` of the window by setting center=True . With arguments `method`.", "question_id": 38958}
{"snippet": "Series.expanding()", "intent": "Provide expanding transformations .", "question_id": 38959}
{"snippet": "Series.expanding(min_periods=1)", "intent": "Provide expanding transformations . With arguments `min_periods`.", "question_id": 38960}
{"snippet": "Series.expanding(center=None)", "intent": "Provide expanding transformations . This can be changed to the `center` of the window by setting center=True .", "question_id": 38961}
{"snippet": "Series.expanding(axis=0)", "intent": "Provide expanding transformations . With arguments `axis`.", "question_id": 38962}
{"snippet": "Series.expanding(method='single')", "intent": "Provide expanding transformations . With arguments `method`.", "question_id": 38963}
{"snippet": "Series.expanding(min_periods=1, center=None)", "intent": "Provide expanding transformations . This can be changed to the `center` of the window by setting center=True . With arguments `min_periods`.", "question_id": 38964}
{"snippet": "Series.expanding(min_periods=1, axis=0)", "intent": "Provide expanding transformations . With arguments `min_periods`, `axis`.", "question_id": 38965}
{"snippet": "Series.expanding(min_periods=1, method='single')", "intent": "Provide expanding transformations . With arguments `min_periods`, `method`.", "question_id": 38966}
{"snippet": "Series.expanding(center=None, axis=0)", "intent": "Provide expanding transformations . This can be changed to the `center` of the window by setting center=True . With arguments `axis`.", "question_id": 38967}
{"snippet": "Series.expanding(center=None, method='single')", "intent": "Provide expanding transformations . This can be changed to the `center` of the window by setting center=True . With arguments `method`.", "question_id": 38968}
{"snippet": "Series.explode()", "intent": "Transform each element of a list-like to a row .", "question_id": 38969}
{"snippet": "Series.explode(ignore_index=False)", "intent": "Transform each element of a list-like to a row . With arguments `ignore_index`.", "question_id": 38970}
{"snippet": "Series.explode()", "intent": "Transform each element of a list-like to a row .", "question_id": 38971}
{"snippet": "Series.explode(ignore_index=False)", "intent": "Transform each element of a list-like to a row . With arguments `ignore_index`.", "question_id": 38972}
{"snippet": "Series.explode()", "intent": "Transform each element of a list-like to a row .", "question_id": 38973}
{"snippet": "Series.explode(ignore_index=False)", "intent": "Transform each element of a list-like to a row . With arguments `ignore_index`.", "question_id": 38974}
{"snippet": "Series.factorize()", "intent": "Encode the object as an enumerated type or categorical variable .", "question_id": 38975}
{"snippet": "Series.factorize(sort=False)", "intent": "Encode the object as an enumerated type or categorical variable . With arguments `sort`.", "question_id": 38976}
{"snippet": "Series.factorize(na_sentinel=- 1)", "intent": "Encode the object as an enumerated type or categorical variable . Missing values are indicated in codes with `na_sentinel` ( -1 by default ) .", "question_id": 38977}
{"snippet": "Series.factorize(sort=False, na_sentinel=- 1)", "intent": "Encode the object as an enumerated type or categorical variable . Missing values are indicated in codes with `na_sentinel` ( -1 by default ) . With arguments `sort`.", "question_id": 38978}
{"snippet": "Series.factorize()", "intent": "Encode the object as an enumerated type or categorical variable .", "question_id": 38979}
{"snippet": "Series.factorize(sort=False)", "intent": "Encode the object as an enumerated type or categorical variable . With arguments `sort`.", "question_id": 38980}
{"snippet": "Series.factorize(na_sentinel=- 1)", "intent": "Encode the object as an enumerated type or categorical variable . Missing values are indicated in codes with `na_sentinel` ( -1 by default ) .", "question_id": 38981}
{"snippet": "Series.factorize(sort=False, na_sentinel=- 1)", "intent": "Encode the object as an enumerated type or categorical variable . Missing values are indicated in codes with `na_sentinel` ( -1 by default ) . With arguments `sort`.", "question_id": 38982}
{"snippet": "Series.factorize()", "intent": "Encode the object as an enumerated type or categorical variable .", "question_id": 38983}
{"snippet": "Series.factorize(sort=False)", "intent": "Encode the object as an enumerated type or categorical variable . With arguments `sort`.", "question_id": 38984}
{"snippet": "Series.factorize(na_sentinel=- 1)", "intent": "Encode the object as an enumerated type or categorical variable . Missing values are indicated in codes with `na_sentinel` ( -1 by default ) .", "question_id": 38985}
{"snippet": "Series.factorize(sort=False, na_sentinel=- 1)", "intent": "Encode the object as an enumerated type or categorical variable . Missing values are indicated in codes with `na_sentinel` ( -1 by default ) . With arguments `sort`.", "question_id": 38986}
{"snippet": "Series.ffill()", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' .", "question_id": 38987}
{"snippet": "Series.ffill(axis=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`.", "question_id": 38988}
{"snippet": "Series.ffill(inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`.", "question_id": 38989}
{"snippet": "Series.ffill(limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `limit`.", "question_id": 38990}
{"snippet": "Series.ffill(downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `downcast`.", "question_id": 38991}
{"snippet": "Series.ffill(axis=None, inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `inplace`.", "question_id": 38992}
{"snippet": "Series.ffill(axis=None, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `limit`.", "question_id": 38993}
{"snippet": "Series.ffill(axis=None, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `downcast`.", "question_id": 38994}
{"snippet": "Series.ffill(inplace=False, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`, `limit`.", "question_id": 38995}
{"snippet": "Series.ffill(inplace=False, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`, `downcast`.", "question_id": 38996}
{"snippet": "Series.ffill()", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' .", "question_id": 38997}
{"snippet": "Series.ffill(axis=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`.", "question_id": 38998}
{"snippet": "Series.ffill(inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`.", "question_id": 38999}
{"snippet": "Series.ffill(limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `limit`.", "question_id": 39000}
{"snippet": "Series.ffill(downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `downcast`.", "question_id": 39001}
{"snippet": "Series.ffill(axis=None, inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `inplace`.", "question_id": 39002}
{"snippet": "Series.ffill(axis=None, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `limit`.", "question_id": 39003}
{"snippet": "Series.ffill(axis=None, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `downcast`.", "question_id": 39004}
{"snippet": "Series.ffill(inplace=False, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`, `limit`.", "question_id": 39005}
{"snippet": "Series.ffill(inplace=False, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`, `downcast`.", "question_id": 39006}
{"snippet": "Series.ffill()", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' .", "question_id": 39007}
{"snippet": "Series.ffill(axis=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`.", "question_id": 39008}
{"snippet": "Series.ffill(inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`.", "question_id": 39009}
{"snippet": "Series.ffill(limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `limit`.", "question_id": 39010}
{"snippet": "Series.ffill(downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `downcast`.", "question_id": 39011}
{"snippet": "Series.ffill(axis=None, inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `inplace`.", "question_id": 39012}
{"snippet": "Series.ffill(axis=None, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `limit`.", "question_id": 39013}
{"snippet": "Series.ffill(axis=None, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `downcast`.", "question_id": 39014}
{"snippet": "Series.ffill(inplace=False, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`, `limit`.", "question_id": 39015}
{"snippet": "Series.ffill(inplace=False, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`, `downcast`.", "question_id": 39016}
{"snippet": "Series.fillna()", "intent": "Fill NA/NaN values using the specified `method` .", "question_id": 39017}
{"snippet": "Series.fillna(value=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`.", "question_id": 39018}
{"snippet": "Series.fillna(method=None)", "intent": "Fill NA/NaN values using the specified `method` .", "question_id": 39019}
{"snippet": "Series.fillna(axis=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `axis`.", "question_id": 39020}
{"snippet": "Series.fillna(inplace=False)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `inplace`.", "question_id": 39021}
{"snippet": "Series.fillna(limit=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `limit`.", "question_id": 39022}
{"snippet": "Series.fillna(downcast=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `downcast`.", "question_id": 39023}
{"snippet": "Series.fillna(value=None, method=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`.", "question_id": 39024}
{"snippet": "Series.fillna(value=None, axis=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`, `axis`.", "question_id": 39025}
{"snippet": "Series.fillna(value=None, inplace=False)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`, `inplace`.", "question_id": 39026}
{"snippet": "Series.fillna()", "intent": "Fill NA/NaN values using the specified `method` .", "question_id": 39027}
{"snippet": "Series.fillna(value=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`.", "question_id": 39028}
{"snippet": "Series.fillna(method=None)", "intent": "Fill NA/NaN values using the specified `method` .", "question_id": 39029}
{"snippet": "Series.fillna(axis=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `axis`.", "question_id": 39030}
{"snippet": "Series.fillna(inplace=False)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `inplace`.", "question_id": 39031}
{"snippet": "Series.fillna(limit=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `limit`.", "question_id": 39032}
{"snippet": "Series.fillna(downcast=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `downcast`.", "question_id": 39033}
{"snippet": "Series.fillna(value=None, method=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`.", "question_id": 39034}
{"snippet": "Series.fillna(value=None, axis=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`, `axis`.", "question_id": 39035}
{"snippet": "Series.fillna(value=None, inplace=False)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`, `inplace`.", "question_id": 39036}
{"snippet": "Series.fillna()", "intent": "Fill NA/NaN values using the specified `method` .", "question_id": 39037}
{"snippet": "Series.fillna(value=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`.", "question_id": 39038}
{"snippet": "Series.fillna(method=None)", "intent": "Fill NA/NaN values using the specified `method` .", "question_id": 39039}
{"snippet": "Series.fillna(axis=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `axis`.", "question_id": 39040}
{"snippet": "Series.fillna(inplace=False)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `inplace`.", "question_id": 39041}
{"snippet": "Series.fillna(limit=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `limit`.", "question_id": 39042}
{"snippet": "Series.fillna(downcast=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `downcast`.", "question_id": 39043}
{"snippet": "Series.fillna(value=None, method=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`.", "question_id": 39044}
{"snippet": "Series.fillna(value=None, axis=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`, `axis`.", "question_id": 39045}
{"snippet": "Series.fillna(value=None, inplace=False)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`, `inplace`.", "question_id": 39046}
{"snippet": "Series.filter()", "intent": "Subset the dataframe rows or columns according to the specified index labels .", "question_id": 39047}
{"snippet": "Series.filter(items=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 39048}
{"snippet": "Series.filter(like=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 39049}
{"snippet": "Series.filter(regex=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 39050}
{"snippet": "Series.filter(axis=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . `axis` defaults to the info axis that is used when indexing with [ ] .", "question_id": 39051}
{"snippet": "Series.filter(items=None, like=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 39052}
{"snippet": "Series.filter(items=None, regex=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 39053}
{"snippet": "Series.filter(items=None, axis=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive . `axis` defaults to the info axis that is used when indexing with [ ] .", "question_id": 39054}
{"snippet": "Series.filter(like=None, regex=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 39055}
{"snippet": "Series.filter(like=None, axis=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive . `axis` defaults to the info axis that is used when indexing with [ ] .", "question_id": 39056}
{"snippet": "Series.filter()", "intent": "Subset the dataframe rows or columns according to the specified index labels .", "question_id": 39057}
{"snippet": "Series.filter(items=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 39058}
{"snippet": "Series.filter(like=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 39059}
{"snippet": "Series.filter(regex=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 39060}
{"snippet": "Series.filter(axis=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . `axis` defaults to the info axis that is used when indexing with [ ] .", "question_id": 39061}
{"snippet": "Series.filter(items=None, like=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 39062}
{"snippet": "Series.filter(items=None, regex=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 39063}
{"snippet": "Series.filter(items=None, axis=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive . `axis` defaults to the info axis that is used when indexing with [ ] .", "question_id": 39064}
{"snippet": "Series.filter(like=None, regex=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 39065}
{"snippet": "Series.filter(like=None, axis=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive . `axis` defaults to the info axis that is used when indexing with [ ] .", "question_id": 39066}
{"snippet": "Series.filter()", "intent": "Subset the dataframe rows or columns according to the specified index labels .", "question_id": 39067}
{"snippet": "Series.filter(items=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 39068}
{"snippet": "Series.filter(like=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 39069}
{"snippet": "Series.filter(regex=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 39070}
{"snippet": "Series.filter(axis=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . `axis` defaults to the info axis that is used when indexing with [ ] .", "question_id": 39071}
{"snippet": "Series.filter(items=None, like=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 39072}
{"snippet": "Series.filter(items=None, regex=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 39073}
{"snippet": "Series.filter(items=None, axis=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive . `axis` defaults to the info axis that is used when indexing with [ ] .", "question_id": 39074}
{"snippet": "Series.filter(like=None, regex=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive .", "question_id": 39075}
{"snippet": "Series.filter(like=None, axis=None)", "intent": "Subset the dataframe rows or columns according to the specified index labels . The `items` , `like` , and `regex` parameters are enforced to be mutually exclusive . `axis` defaults to the info axis that is used when indexing with [ ] .", "question_id": 39076}
{"snippet": "Series.first(offset)", "intent": "Select initial periods of time series data based on a date `offset` .", "question_id": 39077}
{"snippet": "Series.first(offset)", "intent": "Select initial periods of time series data based on a date `offset` .", "question_id": 39078}
{"snippet": "Series.first(offset)", "intent": "Select initial periods of time series data based on a date `offset` .", "question_id": 39079}
{"snippet": "Series.first_valid_index()", "intent": "Return index for first non-NA value or None , if no NA value is found .", "question_id": 39080}
{"snippet": "Series.first_valid_index()", "intent": "Return index for first non-NA value or None , if no NA value is found .", "question_id": 39081}
{"snippet": "Series.first_valid_index()", "intent": "Return index for first non-NA value or None , if no NA value is found .", "question_id": 39082}
{"snippet": "Series.floordiv(other)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator floordiv ) .", "question_id": 39083}
{"snippet": "Series.floordiv(other, level=None)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator floordiv ) . With arguments `level`.", "question_id": 39084}
{"snippet": "Series.floordiv(other, fill_value=None)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator floordiv ) . Equivalent to series // other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39085}
{"snippet": "Series.floordiv(other, axis=0)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator floordiv ) . With arguments `axis`.", "question_id": 39086}
{"snippet": "Series.floordiv(other, level=None, fill_value=None)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator floordiv ) . Equivalent to series // other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39087}
{"snippet": "Series.floordiv(other, level=None, axis=0)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator floordiv ) . With arguments `level`, `axis`.", "question_id": 39088}
{"snippet": "Series.floordiv(other, fill_value=None, axis=0)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator floordiv ) . Equivalent to series // other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39089}
{"snippet": "Series.floordiv(other, level=None, fill_value=None, axis=0)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator floordiv ) . Equivalent to series // other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39090}
{"snippet": "Series.floordiv(other)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator floordiv ) .", "question_id": 39091}
{"snippet": "Series.floordiv(other, level=None)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator floordiv ) . With arguments `level`.", "question_id": 39092}
{"snippet": "Series.floordiv(other, fill_value=None)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator floordiv ) . Equivalent to series // other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39093}
{"snippet": "Series.floordiv(other, axis=0)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator floordiv ) . With arguments `axis`.", "question_id": 39094}
{"snippet": "Series.floordiv(other, level=None, fill_value=None)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator floordiv ) . Equivalent to series // other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39095}
{"snippet": "Series.floordiv(other, level=None, axis=0)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator floordiv ) . With arguments `level`, `axis`.", "question_id": 39096}
{"snippet": "Series.floordiv(other, fill_value=None, axis=0)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator floordiv ) . Equivalent to series // other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39097}
{"snippet": "Series.floordiv(other, level=None, fill_value=None, axis=0)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator floordiv ) . Equivalent to series // other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39098}
{"snippet": "Series.floordiv(other)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator floordiv ) .", "question_id": 39099}
{"snippet": "Series.floordiv(other, level=None)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator floordiv ) . With arguments `level`.", "question_id": 39100}
{"snippet": "Series.floordiv(other, fill_value=None)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator floordiv ) . Equivalent to series // other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39101}
{"snippet": "Series.floordiv(other, axis=0)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator floordiv ) . With arguments `axis`.", "question_id": 39102}
{"snippet": "Series.floordiv(other, level=None, fill_value=None)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator floordiv ) . Equivalent to series // other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39103}
{"snippet": "Series.floordiv(other, level=None, axis=0)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator floordiv ) . With arguments `level`, `axis`.", "question_id": 39104}
{"snippet": "Series.floordiv(other, fill_value=None, axis=0)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator floordiv ) . Equivalent to series // other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39105}
{"snippet": "Series.floordiv(other, level=None, fill_value=None, axis=0)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator floordiv ) . Equivalent to series // other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39106}
{"snippet": "Series.ge(other)", "intent": "Return Greater than or equal to of series and `other` , element-wise ( binary operator ge ) .", "question_id": 39107}
{"snippet": "Series.ge(other, level=None)", "intent": "Return Greater than or equal to of series and `other` , element-wise ( binary operator ge ) . With arguments `level`.", "question_id": 39108}
{"snippet": "Series.ge(other, fill_value=None)", "intent": "Return Greater than or equal to of series and `other` , element-wise ( binary operator ge ) . Equivalent to series > = other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39109}
{"snippet": "Series.ge(other, axis=0)", "intent": "Return Greater than or equal to of series and `other` , element-wise ( binary operator ge ) . With arguments `axis`.", "question_id": 39110}
{"snippet": "Series.ge(other, level=None, fill_value=None)", "intent": "Return Greater than or equal to of series and `other` , element-wise ( binary operator ge ) . Equivalent to series > = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39111}
{"snippet": "Series.ge(other, level=None, axis=0)", "intent": "Return Greater than or equal to of series and `other` , element-wise ( binary operator ge ) . With arguments `level`, `axis`.", "question_id": 39112}
{"snippet": "Series.ge(other, fill_value=None, axis=0)", "intent": "Return Greater than or equal to of series and `other` , element-wise ( binary operator ge ) . Equivalent to series > = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39113}
{"snippet": "Series.ge(other, level=None, fill_value=None, axis=0)", "intent": "Return Greater than or equal to of series and `other` , element-wise ( binary operator ge ) . Equivalent to series > = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39114}
{"snippet": "Series.ge(other)", "intent": "Return Greater than or equal to of series and `other` , element-wise ( binary operator ge ) .", "question_id": 39115}
{"snippet": "Series.ge(other, level=None)", "intent": "Return Greater than or equal to of series and `other` , element-wise ( binary operator ge ) . With arguments `level`.", "question_id": 39116}
{"snippet": "Series.ge(other, fill_value=None)", "intent": "Return Greater than or equal to of series and `other` , element-wise ( binary operator ge ) . Equivalent to series > = other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39117}
{"snippet": "Series.ge(other, axis=0)", "intent": "Return Greater than or equal to of series and `other` , element-wise ( binary operator ge ) . With arguments `axis`.", "question_id": 39118}
{"snippet": "Series.ge(other, level=None, fill_value=None)", "intent": "Return Greater than or equal to of series and `other` , element-wise ( binary operator ge ) . Equivalent to series > = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39119}
{"snippet": "Series.ge(other, level=None, axis=0)", "intent": "Return Greater than or equal to of series and `other` , element-wise ( binary operator ge ) . With arguments `level`, `axis`.", "question_id": 39120}
{"snippet": "Series.ge(other, fill_value=None, axis=0)", "intent": "Return Greater than or equal to of series and `other` , element-wise ( binary operator ge ) . Equivalent to series > = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39121}
{"snippet": "Series.ge(other, level=None, fill_value=None, axis=0)", "intent": "Return Greater than or equal to of series and `other` , element-wise ( binary operator ge ) . Equivalent to series > = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39122}
{"snippet": "Series.ge(other)", "intent": "Return Greater than or equal to of series and `other` , element-wise ( binary operator ge ) .", "question_id": 39123}
{"snippet": "Series.ge(other, level=None)", "intent": "Return Greater than or equal to of series and `other` , element-wise ( binary operator ge ) . With arguments `level`.", "question_id": 39124}
{"snippet": "Series.ge(other, fill_value=None)", "intent": "Return Greater than or equal to of series and `other` , element-wise ( binary operator ge ) . Equivalent to series > = other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39125}
{"snippet": "Series.ge(other, axis=0)", "intent": "Return Greater than or equal to of series and `other` , element-wise ( binary operator ge ) . With arguments `axis`.", "question_id": 39126}
{"snippet": "Series.ge(other, level=None, fill_value=None)", "intent": "Return Greater than or equal to of series and `other` , element-wise ( binary operator ge ) . Equivalent to series > = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39127}
{"snippet": "Series.ge(other, level=None, axis=0)", "intent": "Return Greater than or equal to of series and `other` , element-wise ( binary operator ge ) . With arguments `level`, `axis`.", "question_id": 39128}
{"snippet": "Series.ge(other, fill_value=None, axis=0)", "intent": "Return Greater than or equal to of series and `other` , element-wise ( binary operator ge ) . Equivalent to series > = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39129}
{"snippet": "Series.ge(other, level=None, fill_value=None, axis=0)", "intent": "Return Greater than or equal to of series and `other` , element-wise ( binary operator ge ) . Equivalent to series > = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39130}
{"snippet": "Series.get(key)", "intent": "Get item from object for given `key` ( ex : DataFrame column ) .", "question_id": 39131}
{"snippet": "Series.get(key, default=None)", "intent": "Get item from object for given `key` ( ex : DataFrame column ) . Returns `default` value if not found .", "question_id": 39132}
{"snippet": "Series.get(key)", "intent": "Get item from object for given `key` ( ex : DataFrame column ) .", "question_id": 39133}
{"snippet": "Series.get(key, default=None)", "intent": "Get item from object for given `key` ( ex : DataFrame column ) . Returns `default` value if not found .", "question_id": 39134}
{"snippet": "Series.get(key)", "intent": "Get item from object for given `key` ( ex : DataFrame column ) .", "question_id": 39135}
{"snippet": "Series.get(key, default=None)", "intent": "Get item from object for given `key` ( ex : DataFrame column ) . Returns `default` value if not found .", "question_id": 39136}
{"snippet": "Series.groupby()", "intent": "Group Series using a mapper or `by` a Series of columns .", "question_id": 39137}
{"snippet": "Series.groupby(by=None)", "intent": "Group Series using a mapper or `by` a Series of columns .", "question_id": 39138}
{"snippet": "Series.groupby(axis=0)", "intent": "Group Series using a mapper or `by` a Series of columns . With arguments `axis`.", "question_id": 39139}
{"snippet": "Series.groupby(level=None)", "intent": "Group Series using a mapper or `by` a Series of columns . We can groupby different levels of a hierarchical index using the `level` parameter :", "question_id": 39140}
{"snippet": "Series.groupby(as_index=True)", "intent": "Group Series using a mapper or `by` a Series of columns . With arguments `as_index`.", "question_id": 39141}
{"snippet": "Series.groupby(sort=True)", "intent": "Group Series using a mapper or `by` a Series of columns . With arguments `sort`.", "question_id": 39142}
{"snippet": "Series.groupby(group_keys=True)", "intent": "Group Series using a mapper or `by` a Series of columns . With arguments `group_keys`.", "question_id": 39143}
{"snippet": "Series.groupby(squeeze=NoDefault.no_default)", "intent": "Group Series using a mapper or `by` a Series of columns . With arguments `squeeze`.", "question_id": 39144}
{"snippet": "Series.groupby(observed=False)", "intent": "Group Series using a mapper or `by` a Series of columns . With arguments `observed`.", "question_id": 39145}
{"snippet": "Series.groupby(dropna=True)", "intent": "Group Series using a mapper or `by` a Series of columns . We can also choose to include NA in group keys or not by defining `dropna` parameter , the default setting is True :", "question_id": 39146}
{"snippet": "Series.groupby()", "intent": "Group Series using a mapper or `by` a Series of columns .", "question_id": 39147}
{"snippet": "Series.groupby(by=None)", "intent": "Group Series using a mapper or `by` a Series of columns .", "question_id": 39148}
{"snippet": "Series.groupby(axis=0)", "intent": "Group Series using a mapper or `by` a Series of columns . With arguments `axis`.", "question_id": 39149}
{"snippet": "Series.groupby(level=None)", "intent": "Group Series using a mapper or `by` a Series of columns . We can groupby different levels of a hierarchical index using the `level` parameter :", "question_id": 39150}
{"snippet": "Series.groupby(as_index=True)", "intent": "Group Series using a mapper or `by` a Series of columns . With arguments `as_index`.", "question_id": 39151}
{"snippet": "Series.groupby(sort=True)", "intent": "Group Series using a mapper or `by` a Series of columns . With arguments `sort`.", "question_id": 39152}
{"snippet": "Series.groupby(group_keys=True)", "intent": "Group Series using a mapper or `by` a Series of columns . With arguments `group_keys`.", "question_id": 39153}
{"snippet": "Series.groupby(squeeze=NoDefault.no_default)", "intent": "Group Series using a mapper or `by` a Series of columns . With arguments `squeeze`.", "question_id": 39154}
{"snippet": "Series.groupby(observed=False)", "intent": "Group Series using a mapper or `by` a Series of columns . With arguments `observed`.", "question_id": 39155}
{"snippet": "Series.groupby(dropna=True)", "intent": "Group Series using a mapper or `by` a Series of columns . We can also choose to include NA in group keys or not by defining `dropna` parameter , the default setting is True :", "question_id": 39156}
{"snippet": "Series.groupby()", "intent": "Group Series using a mapper or `by` a Series of columns .", "question_id": 39157}
{"snippet": "Series.groupby(by=None)", "intent": "Group Series using a mapper or `by` a Series of columns .", "question_id": 39158}
{"snippet": "Series.groupby(axis=0)", "intent": "Group Series using a mapper or `by` a Series of columns . With arguments `axis`.", "question_id": 39159}
{"snippet": "Series.groupby(level=None)", "intent": "Group Series using a mapper or `by` a Series of columns . We can groupby different levels of a hierarchical index using the `level` parameter :", "question_id": 39160}
{"snippet": "Series.groupby(as_index=True)", "intent": "Group Series using a mapper or `by` a Series of columns . With arguments `as_index`.", "question_id": 39161}
{"snippet": "Series.groupby(sort=True)", "intent": "Group Series using a mapper or `by` a Series of columns . With arguments `sort`.", "question_id": 39162}
{"snippet": "Series.groupby(group_keys=True)", "intent": "Group Series using a mapper or `by` a Series of columns . With arguments `group_keys`.", "question_id": 39163}
{"snippet": "Series.groupby(squeeze=NoDefault.no_default)", "intent": "Group Series using a mapper or `by` a Series of columns . With arguments `squeeze`.", "question_id": 39164}
{"snippet": "Series.groupby(observed=False)", "intent": "Group Series using a mapper or `by` a Series of columns . With arguments `observed`.", "question_id": 39165}
{"snippet": "Series.groupby(dropna=True)", "intent": "Group Series using a mapper or `by` a Series of columns . We can also choose to include NA in group keys or not by defining `dropna` parameter , the default setting is True :", "question_id": 39166}
{"snippet": "Series.gt(other)", "intent": "Return Greater than of series and `other` , element-wise ( binary operator gt ) .", "question_id": 39167}
{"snippet": "Series.gt(other, level=None)", "intent": "Return Greater than of series and `other` , element-wise ( binary operator gt ) . With arguments `level`.", "question_id": 39168}
{"snippet": "Series.gt(other, fill_value=None)", "intent": "Return Greater than of series and `other` , element-wise ( binary operator gt ) . Equivalent to series > other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39169}
{"snippet": "Series.gt(other, axis=0)", "intent": "Return Greater than of series and `other` , element-wise ( binary operator gt ) . With arguments `axis`.", "question_id": 39170}
{"snippet": "Series.gt(other, level=None, fill_value=None)", "intent": "Return Greater than of series and `other` , element-wise ( binary operator gt ) . Equivalent to series > other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39171}
{"snippet": "Series.gt(other, level=None, axis=0)", "intent": "Return Greater than of series and `other` , element-wise ( binary operator gt ) . With arguments `level`, `axis`.", "question_id": 39172}
{"snippet": "Series.gt(other, fill_value=None, axis=0)", "intent": "Return Greater than of series and `other` , element-wise ( binary operator gt ) . Equivalent to series > other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39173}
{"snippet": "Series.gt(other, level=None, fill_value=None, axis=0)", "intent": "Return Greater than of series and `other` , element-wise ( binary operator gt ) . Equivalent to series > other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39174}
{"snippet": "Series.gt(other)", "intent": "Return Greater than of series and `other` , element-wise ( binary operator gt ) .", "question_id": 39175}
{"snippet": "Series.gt(other, level=None)", "intent": "Return Greater than of series and `other` , element-wise ( binary operator gt ) . With arguments `level`.", "question_id": 39176}
{"snippet": "Series.gt(other, fill_value=None)", "intent": "Return Greater than of series and `other` , element-wise ( binary operator gt ) . Equivalent to series > other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39177}
{"snippet": "Series.gt(other, axis=0)", "intent": "Return Greater than of series and `other` , element-wise ( binary operator gt ) . With arguments `axis`.", "question_id": 39178}
{"snippet": "Series.gt(other, level=None, fill_value=None)", "intent": "Return Greater than of series and `other` , element-wise ( binary operator gt ) . Equivalent to series > other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39179}
{"snippet": "Series.gt(other, level=None, axis=0)", "intent": "Return Greater than of series and `other` , element-wise ( binary operator gt ) . With arguments `level`, `axis`.", "question_id": 39180}
{"snippet": "Series.gt(other, fill_value=None, axis=0)", "intent": "Return Greater than of series and `other` , element-wise ( binary operator gt ) . Equivalent to series > other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39181}
{"snippet": "Series.gt(other, level=None, fill_value=None, axis=0)", "intent": "Return Greater than of series and `other` , element-wise ( binary operator gt ) . Equivalent to series > other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39182}
{"snippet": "Series.gt(other)", "intent": "Return Greater than of series and `other` , element-wise ( binary operator gt ) .", "question_id": 39183}
{"snippet": "Series.gt(other, level=None)", "intent": "Return Greater than of series and `other` , element-wise ( binary operator gt ) . With arguments `level`.", "question_id": 39184}
{"snippet": "Series.gt(other, fill_value=None)", "intent": "Return Greater than of series and `other` , element-wise ( binary operator gt ) . Equivalent to series > other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39185}
{"snippet": "Series.gt(other, axis=0)", "intent": "Return Greater than of series and `other` , element-wise ( binary operator gt ) . With arguments `axis`.", "question_id": 39186}
{"snippet": "Series.gt(other, level=None, fill_value=None)", "intent": "Return Greater than of series and `other` , element-wise ( binary operator gt ) . Equivalent to series > other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39187}
{"snippet": "Series.gt(other, level=None, axis=0)", "intent": "Return Greater than of series and `other` , element-wise ( binary operator gt ) . With arguments `level`, `axis`.", "question_id": 39188}
{"snippet": "Series.gt(other, fill_value=None, axis=0)", "intent": "Return Greater than of series and `other` , element-wise ( binary operator gt ) . Equivalent to series > other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39189}
{"snippet": "Series.gt(other, level=None, fill_value=None, axis=0)", "intent": "Return Greater than of series and `other` , element-wise ( binary operator gt ) . Equivalent to series > other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39190}
{"snippet": "Series.head()", "intent": "Return the first `n` rows .", "question_id": 39191}
{"snippet": "Series.head(n=5)", "intent": "Return the first `n` rows .", "question_id": 39192}
{"snippet": "Series.head()", "intent": "Return the first `n` rows .", "question_id": 39193}
{"snippet": "Series.head(n=5)", "intent": "Return the first `n` rows .", "question_id": 39194}
{"snippet": "Series.head()", "intent": "Return the first `n` rows .", "question_id": 39195}
{"snippet": "Series.head(n=5)", "intent": "Return the first `n` rows .", "question_id": 39196}
{"snippet": "Series.hist(**kwargs)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`.", "question_id": 39197}
{"snippet": "Series.hist(**kwargs, by=None)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `by`.", "question_id": 39198}
{"snippet": "Series.hist(**kwargs, ax=None)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `ax`.", "question_id": 39199}
{"snippet": "Series.hist(**kwargs, grid=True)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `grid`.", "question_id": 39200}
{"snippet": "Series.hist(**kwargs, xlabelsize=None)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `xlabelsize`.", "question_id": 39201}
{"snippet": "Series.hist(**kwargs, xrot=None)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `xrot`.", "question_id": 39202}
{"snippet": "Series.hist(**kwargs, ylabelsize=None)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `ylabelsize`.", "question_id": 39203}
{"snippet": "Series.hist(**kwargs, yrot=None)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `yrot`.", "question_id": 39204}
{"snippet": "Series.hist(**kwargs, figsize=None)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `figsize`.", "question_id": 39205}
{"snippet": "Series.hist(**kwargs, bins=10)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `bins`.", "question_id": 39206}
{"snippet": "Series.hist(**kwargs)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`.", "question_id": 39207}
{"snippet": "Series.hist(**kwargs, by=None)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `by`.", "question_id": 39208}
{"snippet": "Series.hist(**kwargs, ax=None)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `ax`.", "question_id": 39209}
{"snippet": "Series.hist(**kwargs, grid=True)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `grid`.", "question_id": 39210}
{"snippet": "Series.hist(**kwargs, xlabelsize=None)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `xlabelsize`.", "question_id": 39211}
{"snippet": "Series.hist(**kwargs, xrot=None)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `xrot`.", "question_id": 39212}
{"snippet": "Series.hist(**kwargs, ylabelsize=None)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `ylabelsize`.", "question_id": 39213}
{"snippet": "Series.hist(**kwargs, yrot=None)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `yrot`.", "question_id": 39214}
{"snippet": "Series.hist(**kwargs, figsize=None)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `figsize`.", "question_id": 39215}
{"snippet": "Series.hist(**kwargs, bins=10)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `bins`.", "question_id": 39216}
{"snippet": "Series.hist(**kwargs)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`.", "question_id": 39217}
{"snippet": "Series.hist(**kwargs, by=None)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `by`.", "question_id": 39218}
{"snippet": "Series.hist(**kwargs, ax=None)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `ax`.", "question_id": 39219}
{"snippet": "Series.hist(**kwargs, grid=True)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `grid`.", "question_id": 39220}
{"snippet": "Series.hist(**kwargs, xlabelsize=None)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `xlabelsize`.", "question_id": 39221}
{"snippet": "Series.hist(**kwargs, xrot=None)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `xrot`.", "question_id": 39222}
{"snippet": "Series.hist(**kwargs, ylabelsize=None)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `ylabelsize`.", "question_id": 39223}
{"snippet": "Series.hist(**kwargs, yrot=None)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `yrot`.", "question_id": 39224}
{"snippet": "Series.hist(**kwargs, figsize=None)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `figsize`.", "question_id": 39225}
{"snippet": "Series.hist(**kwargs, bins=10)", "intent": "Draw histogram of the input series using matplotlib . With arguments `**kwargs`, `bins`.", "question_id": 39226}
{"snippet": "pandas.Series()", "intent": "One-dimensional ndarray with axis labels ( including time series ) .", "question_id": 39227}
{"snippet": "pandas.Series(data=None)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . Statistical methods from ndarray have been overridden to automatically exclude missing `data` ( currently represented as NaN ) .", "question_id": 39228}
{"snippet": "pandas.Series(index=None)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . The object supports both integer- and label-based indexing and provides a host of methods for performing operations involving the `index` .", "question_id": 39229}
{"snippet": "pandas.Series(dtype=None)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . With arguments `dtype`.", "question_id": 39230}
{"snippet": "pandas.Series(name=None)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . With arguments `name`.", "question_id": 39231}
{"snippet": "pandas.Series(copy=False)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . Due to input data type the Series has a `copy` of the original data even though copy=False , so the data is unchanged .", "question_id": 39232}
{"snippet": "pandas.Series(fastpath=False)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . With arguments `fastpath`.", "question_id": 39233}
{"snippet": "pandas.Series(data=None, index=None)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . Statistical methods from ndarray have been overridden to automatically exclude missing `data` ( currently represented as NaN ) . The object supports both integer- and label-based indexing and provides a host of methods for performing operations involving the `index` .", "question_id": 39234}
{"snippet": "pandas.Series(data=None, dtype=None)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . Statistical methods from ndarray have been overridden to automatically exclude missing `data` ( currently represented as NaN ) . With arguments `dtype`.", "question_id": 39235}
{"snippet": "pandas.Series(data=None, name=None)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . Statistical methods from ndarray have been overridden to automatically exclude missing `data` ( currently represented as NaN ) . With arguments `name`.", "question_id": 39236}
{"snippet": "pandas.Series()", "intent": "One-dimensional ndarray with axis labels ( including time series ) .", "question_id": 39237}
{"snippet": "pandas.Series(data=None)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . Statistical methods from ndarray have been overridden to automatically exclude missing `data` ( currently represented as NaN ) .", "question_id": 39238}
{"snippet": "pandas.Series(index=None)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . The object supports both integer- and label-based indexing and provides a host of methods for performing operations involving the `index` .", "question_id": 39239}
{"snippet": "pandas.Series(dtype=None)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . With arguments `dtype`.", "question_id": 39240}
{"snippet": "pandas.Series(name=None)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . With arguments `name`.", "question_id": 39241}
{"snippet": "pandas.Series(copy=False)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . Due to input data type the Series has a `copy` of the original data even though copy=False , so the data is unchanged .", "question_id": 39242}
{"snippet": "pandas.Series(fastpath=False)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . With arguments `fastpath`.", "question_id": 39243}
{"snippet": "pandas.Series(data=None, index=None)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . Statistical methods from ndarray have been overridden to automatically exclude missing `data` ( currently represented as NaN ) . The object supports both integer- and label-based indexing and provides a host of methods for performing operations involving the `index` .", "question_id": 39244}
{"snippet": "pandas.Series(data=None, dtype=None)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . Statistical methods from ndarray have been overridden to automatically exclude missing `data` ( currently represented as NaN ) . With arguments `dtype`.", "question_id": 39245}
{"snippet": "pandas.Series(data=None, name=None)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . Statistical methods from ndarray have been overridden to automatically exclude missing `data` ( currently represented as NaN ) . With arguments `name`.", "question_id": 39246}
{"snippet": "pandas.Series()", "intent": "One-dimensional ndarray with axis labels ( including time series ) .", "question_id": 39247}
{"snippet": "pandas.Series(data=None)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . Statistical methods from ndarray have been overridden to automatically exclude missing `data` ( currently represented as NaN ) .", "question_id": 39248}
{"snippet": "pandas.Series(index=None)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . The object supports both integer- and label-based indexing and provides a host of methods for performing operations involving the `index` .", "question_id": 39249}
{"snippet": "pandas.Series(dtype=None)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . With arguments `dtype`.", "question_id": 39250}
{"snippet": "pandas.Series(name=None)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . With arguments `name`.", "question_id": 39251}
{"snippet": "pandas.Series(copy=False)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . Due to input data type the Series has a `copy` of the original data even though copy=False , so the data is unchanged .", "question_id": 39252}
{"snippet": "pandas.Series(fastpath=False)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . With arguments `fastpath`.", "question_id": 39253}
{"snippet": "pandas.Series(data=None, index=None)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . Statistical methods from ndarray have been overridden to automatically exclude missing `data` ( currently represented as NaN ) . The object supports both integer- and label-based indexing and provides a host of methods for performing operations involving the `index` .", "question_id": 39254}
{"snippet": "pandas.Series(data=None, dtype=None)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . Statistical methods from ndarray have been overridden to automatically exclude missing `data` ( currently represented as NaN ) . With arguments `dtype`.", "question_id": 39255}
{"snippet": "pandas.Series(data=None, name=None)", "intent": "One-dimensional ndarray with axis labels ( including time series ) . Statistical methods from ndarray have been overridden to automatically exclude missing `data` ( currently represented as NaN ) . With arguments `name`.", "question_id": 39256}
{"snippet": "Series.idxmax(*args, **kwargs)", "intent": "Return the row label of the maximum value . With arguments `*args`, `**kwargs`.", "question_id": 39257}
{"snippet": "Series.idxmax(*args, **kwargs, axis=0)", "intent": "Return the row label of the maximum value . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 39258}
{"snippet": "Series.idxmax(*args, **kwargs, skipna=True)", "intent": "Return the row label of the maximum value . If `skipna` is False and there is an NA value in the data , the function returns nan . With arguments `*args`, `**kwargs`.", "question_id": 39259}
{"snippet": "Series.idxmax(*args, **kwargs, axis=0, skipna=True)", "intent": "Return the row label of the maximum value . If `skipna` is False and there is an NA value in the data , the function returns nan . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 39260}
{"snippet": "Series.idxmax(*args, **kwargs)", "intent": "Return the row label of the maximum value . With arguments `*args`, `**kwargs`.", "question_id": 39261}
{"snippet": "Series.idxmax(*args, **kwargs, axis=0)", "intent": "Return the row label of the maximum value . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 39262}
{"snippet": "Series.idxmax(*args, **kwargs, skipna=True)", "intent": "Return the row label of the maximum value . If `skipna` is False and there is an NA value in the data , the function returns nan . With arguments `*args`, `**kwargs`.", "question_id": 39263}
{"snippet": "Series.idxmax(*args, **kwargs, axis=0, skipna=True)", "intent": "Return the row label of the maximum value . If `skipna` is False and there is an NA value in the data , the function returns nan . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 39264}
{"snippet": "Series.idxmax(*args, **kwargs)", "intent": "Return the row label of the maximum value . With arguments `*args`, `**kwargs`.", "question_id": 39265}
{"snippet": "Series.idxmax(*args, **kwargs, axis=0)", "intent": "Return the row label of the maximum value . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 39266}
{"snippet": "Series.idxmax(*args, **kwargs, skipna=True)", "intent": "Return the row label of the maximum value . If `skipna` is False and there is an NA value in the data , the function returns nan . With arguments `*args`, `**kwargs`.", "question_id": 39267}
{"snippet": "Series.idxmax(*args, **kwargs, axis=0, skipna=True)", "intent": "Return the row label of the maximum value . If `skipna` is False and there is an NA value in the data , the function returns nan . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 39268}
{"snippet": "Series.idxmin(*args, **kwargs)", "intent": "Return the row label of the minimum value . With arguments `*args`, `**kwargs`.", "question_id": 39269}
{"snippet": "Series.idxmin(*args, **kwargs, axis=0)", "intent": "Return the row label of the minimum value . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 39270}
{"snippet": "Series.idxmin(*args, **kwargs, skipna=True)", "intent": "Return the row label of the minimum value . If `skipna` is False and there is an NA value in the data , the function returns nan . With arguments `*args`, `**kwargs`.", "question_id": 39271}
{"snippet": "Series.idxmin(*args, **kwargs, axis=0, skipna=True)", "intent": "Return the row label of the minimum value . If `skipna` is False and there is an NA value in the data , the function returns nan . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 39272}
{"snippet": "Series.idxmin(*args, **kwargs)", "intent": "Return the row label of the minimum value . With arguments `*args`, `**kwargs`.", "question_id": 39273}
{"snippet": "Series.idxmin(*args, **kwargs, axis=0)", "intent": "Return the row label of the minimum value . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 39274}
{"snippet": "Series.idxmin(*args, **kwargs, skipna=True)", "intent": "Return the row label of the minimum value . If `skipna` is False and there is an NA value in the data , the function returns nan . With arguments `*args`, `**kwargs`.", "question_id": 39275}
{"snippet": "Series.idxmin(*args, **kwargs, axis=0, skipna=True)", "intent": "Return the row label of the minimum value . If `skipna` is False and there is an NA value in the data , the function returns nan . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 39276}
{"snippet": "Series.idxmin(*args, **kwargs)", "intent": "Return the row label of the minimum value . With arguments `*args`, `**kwargs`.", "question_id": 39277}
{"snippet": "Series.idxmin(*args, **kwargs, axis=0)", "intent": "Return the row label of the minimum value . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 39278}
{"snippet": "Series.idxmin(*args, **kwargs, skipna=True)", "intent": "Return the row label of the minimum value . If `skipna` is False and there is an NA value in the data , the function returns nan . With arguments `*args`, `**kwargs`.", "question_id": 39279}
{"snippet": "Series.idxmin(*args, **kwargs, axis=0, skipna=True)", "intent": "Return the row label of the minimum value . If `skipna` is False and there is an NA value in the data , the function returns nan . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 39280}
{"snippet": "Series.index", "intent": "The index (axis labels) of the Series.", "question_id": 39281}
{"snippet": "Series.index", "intent": "The index (axis labels) of the Series.", "question_id": 39282}
{"snippet": "Series.index", "intent": "The index (axis labels) of the Series.", "question_id": 39283}
{"snippet": "Series.infer_objects()", "intent": "Attempt to infer better dtypes for object columns .", "question_id": 39284}
{"snippet": "Series.infer_objects()", "intent": "Attempt to infer better dtypes for object columns .", "question_id": 39285}
{"snippet": "Series.infer_objects()", "intent": "Attempt to infer better dtypes for object columns .", "question_id": 39286}
{"snippet": "Series.interpolate(**kwargs)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`.", "question_id": 39287}
{"snippet": "Series.interpolate(**kwargs, method='linear')", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`.", "question_id": 39288}
{"snippet": "Series.interpolate(**kwargs, axis=0)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `axis`.", "question_id": 39289}
{"snippet": "Series.interpolate(**kwargs, limit=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit`.", "question_id": 39290}
{"snippet": "Series.interpolate(**kwargs, inplace=False)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `inplace`.", "question_id": 39291}
{"snippet": "Series.interpolate(**kwargs, limit_direction=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit_direction`.", "question_id": 39292}
{"snippet": "Series.interpolate(**kwargs, limit_area=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit_area`.", "question_id": 39293}
{"snippet": "Series.interpolate(**kwargs, downcast=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `downcast`.", "question_id": 39294}
{"snippet": "Series.interpolate(**kwargs, method='linear', axis=0)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `axis`.", "question_id": 39295}
{"snippet": "Series.interpolate(**kwargs, method='linear', limit=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit`.", "question_id": 39296}
{"snippet": "Series.interpolate(**kwargs)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`.", "question_id": 39297}
{"snippet": "Series.interpolate(**kwargs, method='linear')", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`.", "question_id": 39298}
{"snippet": "Series.interpolate(**kwargs, axis=0)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `axis`.", "question_id": 39299}
{"snippet": "Series.interpolate(**kwargs, limit=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit`.", "question_id": 39300}
{"snippet": "Series.interpolate(**kwargs, inplace=False)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `inplace`.", "question_id": 39301}
{"snippet": "Series.interpolate(**kwargs, limit_direction=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit_direction`.", "question_id": 39302}
{"snippet": "Series.interpolate(**kwargs, limit_area=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit_area`.", "question_id": 39303}
{"snippet": "Series.interpolate(**kwargs, downcast=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `downcast`.", "question_id": 39304}
{"snippet": "Series.interpolate(**kwargs, method='linear', axis=0)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `axis`.", "question_id": 39305}
{"snippet": "Series.interpolate(**kwargs, method='linear', limit=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit`.", "question_id": 39306}
{"snippet": "Series.interpolate(**kwargs)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`.", "question_id": 39307}
{"snippet": "Series.interpolate(**kwargs, method='linear')", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`.", "question_id": 39308}
{"snippet": "Series.interpolate(**kwargs, axis=0)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `axis`.", "question_id": 39309}
{"snippet": "Series.interpolate(**kwargs, limit=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit`.", "question_id": 39310}
{"snippet": "Series.interpolate(**kwargs, inplace=False)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `inplace`.", "question_id": 39311}
{"snippet": "Series.interpolate(**kwargs, limit_direction=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit_direction`.", "question_id": 39312}
{"snippet": "Series.interpolate(**kwargs, limit_area=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit_area`.", "question_id": 39313}
{"snippet": "Series.interpolate(**kwargs, downcast=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `downcast`.", "question_id": 39314}
{"snippet": "Series.interpolate(**kwargs, method='linear', axis=0)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `axis`.", "question_id": 39315}
{"snippet": "Series.interpolate(**kwargs, method='linear', limit=None)", "intent": "Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit`.", "question_id": 39316}
{"snippet": "Series.isin(values)", "intent": "Whether elements in Series are contained in `values` .", "question_id": 39317}
{"snippet": "Series.isin(values)", "intent": "Whether elements in Series are contained in `values` .", "question_id": 39318}
{"snippet": "Series.isin(values)", "intent": "Whether elements in Series are contained in `values` .", "question_id": 39319}
{"snippet": "Series.isna()", "intent": "Detect missing values .", "question_id": 39320}
{"snippet": "Series.isna()", "intent": "Detect missing values .", "question_id": 39321}
{"snippet": "Series.isna()", "intent": "Detect missing values .", "question_id": 39322}
{"snippet": "Series.isnull()", "intent": "Detect missing values .", "question_id": 39323}
{"snippet": "Series.isnull()", "intent": "Detect missing values .", "question_id": 39324}
{"snippet": "Series.isnull()", "intent": "Detect missing values .", "question_id": 39325}
{"snippet": "Series.item()", "intent": "Return the first element of the underlying data as a Python scalar .", "question_id": 39326}
{"snippet": "Series.item()", "intent": "Return the first element of the underlying data as a Python scalar .", "question_id": 39327}
{"snippet": "Series.item()", "intent": "Return the first element of the underlying data as a Python scalar .", "question_id": 39328}
{"snippet": "Series.items()", "intent": "Lazily iterate over ( index , value ) tuples .", "question_id": 39329}
{"snippet": "Series.items()", "intent": "Lazily iterate over ( index , value ) tuples .", "question_id": 39330}
{"snippet": "Series.items()", "intent": "Lazily iterate over ( index , value ) tuples .", "question_id": 39331}
{"snippet": "Series.iteritems()", "intent": "Lazily iterate over ( index , value ) tuples .", "question_id": 39332}
{"snippet": "Series.iteritems()", "intent": "Lazily iterate over ( index , value ) tuples .", "question_id": 39333}
{"snippet": "Series.iteritems()", "intent": "Lazily iterate over ( index , value ) tuples .", "question_id": 39334}
{"snippet": "Series.keys()", "intent": "Return alias for index .", "question_id": 39335}
{"snippet": "Series.keys()", "intent": "Return alias for index .", "question_id": 39336}
{"snippet": "Series.keys()", "intent": "Return alias for index .", "question_id": 39337}
{"snippet": "Series.kurt(**kwargs)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`.", "question_id": 39338}
{"snippet": "Series.kurt(**kwargs, axis=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`.", "question_id": 39339}
{"snippet": "Series.kurt(**kwargs, skipna=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39340}
{"snippet": "Series.kurt(**kwargs, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39341}
{"snippet": "Series.kurt(**kwargs, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39342}
{"snippet": "Series.kurt(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39343}
{"snippet": "Series.kurt(**kwargs, axis=None, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39344}
{"snippet": "Series.kurt(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39345}
{"snippet": "Series.kurt(**kwargs, skipna=None, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 39346}
{"snippet": "Series.kurt(**kwargs, skipna=None, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 39347}
{"snippet": "Series.kurt(**kwargs)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`.", "question_id": 39348}
{"snippet": "Series.kurt(**kwargs, axis=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`.", "question_id": 39349}
{"snippet": "Series.kurt(**kwargs, skipna=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39350}
{"snippet": "Series.kurt(**kwargs, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39351}
{"snippet": "Series.kurt(**kwargs, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39352}
{"snippet": "Series.kurt(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39353}
{"snippet": "Series.kurt(**kwargs, axis=None, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39354}
{"snippet": "Series.kurt(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39355}
{"snippet": "Series.kurt(**kwargs, skipna=None, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 39356}
{"snippet": "Series.kurt(**kwargs, skipna=None, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 39357}
{"snippet": "Series.kurt(**kwargs)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`.", "question_id": 39358}
{"snippet": "Series.kurt(**kwargs, axis=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`.", "question_id": 39359}
{"snippet": "Series.kurt(**kwargs, skipna=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39360}
{"snippet": "Series.kurt(**kwargs, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39361}
{"snippet": "Series.kurt(**kwargs, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39362}
{"snippet": "Series.kurt(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39363}
{"snippet": "Series.kurt(**kwargs, axis=None, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39364}
{"snippet": "Series.kurt(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39365}
{"snippet": "Series.kurt(**kwargs, skipna=None, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 39366}
{"snippet": "Series.kurt(**kwargs, skipna=None, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 39367}
{"snippet": "Series.kurtosis(**kwargs)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`.", "question_id": 39368}
{"snippet": "Series.kurtosis(**kwargs, axis=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`.", "question_id": 39369}
{"snippet": "Series.kurtosis(**kwargs, skipna=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39370}
{"snippet": "Series.kurtosis(**kwargs, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39371}
{"snippet": "Series.kurtosis(**kwargs, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39372}
{"snippet": "Series.kurtosis(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39373}
{"snippet": "Series.kurtosis(**kwargs, axis=None, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39374}
{"snippet": "Series.kurtosis(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39375}
{"snippet": "Series.kurtosis(**kwargs, skipna=None, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 39376}
{"snippet": "Series.kurtosis(**kwargs, skipna=None, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 39377}
{"snippet": "Series.kurtosis(**kwargs)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`.", "question_id": 39378}
{"snippet": "Series.kurtosis(**kwargs, axis=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`.", "question_id": 39379}
{"snippet": "Series.kurtosis(**kwargs, skipna=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39380}
{"snippet": "Series.kurtosis(**kwargs, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39381}
{"snippet": "Series.kurtosis(**kwargs, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39382}
{"snippet": "Series.kurtosis(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39383}
{"snippet": "Series.kurtosis(**kwargs, axis=None, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39384}
{"snippet": "Series.kurtosis(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39385}
{"snippet": "Series.kurtosis(**kwargs, skipna=None, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 39386}
{"snippet": "Series.kurtosis(**kwargs, skipna=None, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 39387}
{"snippet": "Series.kurtosis(**kwargs)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`.", "question_id": 39388}
{"snippet": "Series.kurtosis(**kwargs, axis=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`.", "question_id": 39389}
{"snippet": "Series.kurtosis(**kwargs, skipna=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39390}
{"snippet": "Series.kurtosis(**kwargs, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39391}
{"snippet": "Series.kurtosis(**kwargs, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39392}
{"snippet": "Series.kurtosis(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39393}
{"snippet": "Series.kurtosis(**kwargs, axis=None, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39394}
{"snippet": "Series.kurtosis(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39395}
{"snippet": "Series.kurtosis(**kwargs, skipna=None, level=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 39396}
{"snippet": "Series.kurtosis(**kwargs, skipna=None, numeric_only=None)", "intent": "Return unbiased kurtosis over requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 39397}
{"snippet": "Series.last(offset)", "intent": "Select final periods of time series data based on a date `offset` .", "question_id": 39398}
{"snippet": "Series.last(offset)", "intent": "Select final periods of time series data based on a date `offset` .", "question_id": 39399}
{"snippet": "Series.last(offset)", "intent": "Select final periods of time series data based on a date `offset` .", "question_id": 39400}
{"snippet": "Series.last_valid_index()", "intent": "Return index for last non-NA value or None , if no NA value is found .", "question_id": 39401}
{"snippet": "Series.last_valid_index()", "intent": "Return index for last non-NA value or None , if no NA value is found .", "question_id": 39402}
{"snippet": "Series.last_valid_index()", "intent": "Return index for last non-NA value or None , if no NA value is found .", "question_id": 39403}
{"snippet": "Series.le(other)", "intent": "Return Less than or equal to of series and `other` , element-wise ( binary operator le ) .", "question_id": 39404}
{"snippet": "Series.le(other, level=None)", "intent": "Return Less than or equal to of series and `other` , element-wise ( binary operator le ) . With arguments `level`.", "question_id": 39405}
{"snippet": "Series.le(other, fill_value=None)", "intent": "Return Less than or equal to of series and `other` , element-wise ( binary operator le ) . Equivalent to series < = other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39406}
{"snippet": "Series.le(other, axis=0)", "intent": "Return Less than or equal to of series and `other` , element-wise ( binary operator le ) . With arguments `axis`.", "question_id": 39407}
{"snippet": "Series.le(other, level=None, fill_value=None)", "intent": "Return Less than or equal to of series and `other` , element-wise ( binary operator le ) . Equivalent to series < = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39408}
{"snippet": "Series.le(other, level=None, axis=0)", "intent": "Return Less than or equal to of series and `other` , element-wise ( binary operator le ) . With arguments `level`, `axis`.", "question_id": 39409}
{"snippet": "Series.le(other, fill_value=None, axis=0)", "intent": "Return Less than or equal to of series and `other` , element-wise ( binary operator le ) . Equivalent to series < = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39410}
{"snippet": "Series.le(other, level=None, fill_value=None, axis=0)", "intent": "Return Less than or equal to of series and `other` , element-wise ( binary operator le ) . Equivalent to series < = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39411}
{"snippet": "Series.le(other)", "intent": "Return Less than or equal to of series and `other` , element-wise ( binary operator le ) .", "question_id": 39412}
{"snippet": "Series.le(other, level=None)", "intent": "Return Less than or equal to of series and `other` , element-wise ( binary operator le ) . With arguments `level`.", "question_id": 39413}
{"snippet": "Series.le(other, fill_value=None)", "intent": "Return Less than or equal to of series and `other` , element-wise ( binary operator le ) . Equivalent to series < = other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39414}
{"snippet": "Series.le(other, axis=0)", "intent": "Return Less than or equal to of series and `other` , element-wise ( binary operator le ) . With arguments `axis`.", "question_id": 39415}
{"snippet": "Series.le(other, level=None, fill_value=None)", "intent": "Return Less than or equal to of series and `other` , element-wise ( binary operator le ) . Equivalent to series < = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39416}
{"snippet": "Series.le(other, level=None, axis=0)", "intent": "Return Less than or equal to of series and `other` , element-wise ( binary operator le ) . With arguments `level`, `axis`.", "question_id": 39417}
{"snippet": "Series.le(other, fill_value=None, axis=0)", "intent": "Return Less than or equal to of series and `other` , element-wise ( binary operator le ) . Equivalent to series < = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39418}
{"snippet": "Series.le(other, level=None, fill_value=None, axis=0)", "intent": "Return Less than or equal to of series and `other` , element-wise ( binary operator le ) . Equivalent to series < = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39419}
{"snippet": "Series.le(other)", "intent": "Return Less than or equal to of series and `other` , element-wise ( binary operator le ) .", "question_id": 39420}
{"snippet": "Series.le(other, level=None)", "intent": "Return Less than or equal to of series and `other` , element-wise ( binary operator le ) . With arguments `level`.", "question_id": 39421}
{"snippet": "Series.le(other, fill_value=None)", "intent": "Return Less than or equal to of series and `other` , element-wise ( binary operator le ) . Equivalent to series < = other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39422}
{"snippet": "Series.le(other, axis=0)", "intent": "Return Less than or equal to of series and `other` , element-wise ( binary operator le ) . With arguments `axis`.", "question_id": 39423}
{"snippet": "Series.le(other, level=None, fill_value=None)", "intent": "Return Less than or equal to of series and `other` , element-wise ( binary operator le ) . Equivalent to series < = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39424}
{"snippet": "Series.le(other, level=None, axis=0)", "intent": "Return Less than or equal to of series and `other` , element-wise ( binary operator le ) . With arguments `level`, `axis`.", "question_id": 39425}
{"snippet": "Series.le(other, fill_value=None, axis=0)", "intent": "Return Less than or equal to of series and `other` , element-wise ( binary operator le ) . Equivalent to series < = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39426}
{"snippet": "Series.le(other, level=None, fill_value=None, axis=0)", "intent": "Return Less than or equal to of series and `other` , element-wise ( binary operator le ) . Equivalent to series < = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39427}
{"snippet": "Series.lt(other)", "intent": "Return Less than of series and `other` , element-wise ( binary operator lt ) .", "question_id": 39428}
{"snippet": "Series.lt(other, level=None)", "intent": "Return Less than of series and `other` , element-wise ( binary operator lt ) . With arguments `level`.", "question_id": 39429}
{"snippet": "Series.lt(other, fill_value=None)", "intent": "Return Less than of series and `other` , element-wise ( binary operator lt ) . Equivalent to series < other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39430}
{"snippet": "Series.lt(other, axis=0)", "intent": "Return Less than of series and `other` , element-wise ( binary operator lt ) . With arguments `axis`.", "question_id": 39431}
{"snippet": "Series.lt(other, level=None, fill_value=None)", "intent": "Return Less than of series and `other` , element-wise ( binary operator lt ) . Equivalent to series < other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39432}
{"snippet": "Series.lt(other, level=None, axis=0)", "intent": "Return Less than of series and `other` , element-wise ( binary operator lt ) . With arguments `level`, `axis`.", "question_id": 39433}
{"snippet": "Series.lt(other, fill_value=None, axis=0)", "intent": "Return Less than of series and `other` , element-wise ( binary operator lt ) . Equivalent to series < other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39434}
{"snippet": "Series.lt(other, level=None, fill_value=None, axis=0)", "intent": "Return Less than of series and `other` , element-wise ( binary operator lt ) . Equivalent to series < other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39435}
{"snippet": "Series.lt(other)", "intent": "Return Less than of series and `other` , element-wise ( binary operator lt ) .", "question_id": 39436}
{"snippet": "Series.lt(other, level=None)", "intent": "Return Less than of series and `other` , element-wise ( binary operator lt ) . With arguments `level`.", "question_id": 39437}
{"snippet": "Series.lt(other, fill_value=None)", "intent": "Return Less than of series and `other` , element-wise ( binary operator lt ) . Equivalent to series < other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39438}
{"snippet": "Series.lt(other, axis=0)", "intent": "Return Less than of series and `other` , element-wise ( binary operator lt ) . With arguments `axis`.", "question_id": 39439}
{"snippet": "Series.lt(other, level=None, fill_value=None)", "intent": "Return Less than of series and `other` , element-wise ( binary operator lt ) . Equivalent to series < other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39440}
{"snippet": "Series.lt(other, level=None, axis=0)", "intent": "Return Less than of series and `other` , element-wise ( binary operator lt ) . With arguments `level`, `axis`.", "question_id": 39441}
{"snippet": "Series.lt(other, fill_value=None, axis=0)", "intent": "Return Less than of series and `other` , element-wise ( binary operator lt ) . Equivalent to series < other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39442}
{"snippet": "Series.lt(other, level=None, fill_value=None, axis=0)", "intent": "Return Less than of series and `other` , element-wise ( binary operator lt ) . Equivalent to series < other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39443}
{"snippet": "Series.lt(other)", "intent": "Return Less than of series and `other` , element-wise ( binary operator lt ) .", "question_id": 39444}
{"snippet": "Series.lt(other, level=None)", "intent": "Return Less than of series and `other` , element-wise ( binary operator lt ) . With arguments `level`.", "question_id": 39445}
{"snippet": "Series.lt(other, fill_value=None)", "intent": "Return Less than of series and `other` , element-wise ( binary operator lt ) . Equivalent to series < other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39446}
{"snippet": "Series.lt(other, axis=0)", "intent": "Return Less than of series and `other` , element-wise ( binary operator lt ) . With arguments `axis`.", "question_id": 39447}
{"snippet": "Series.lt(other, level=None, fill_value=None)", "intent": "Return Less than of series and `other` , element-wise ( binary operator lt ) . Equivalent to series < other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39448}
{"snippet": "Series.lt(other, level=None, axis=0)", "intent": "Return Less than of series and `other` , element-wise ( binary operator lt ) . With arguments `level`, `axis`.", "question_id": 39449}
{"snippet": "Series.lt(other, fill_value=None, axis=0)", "intent": "Return Less than of series and `other` , element-wise ( binary operator lt ) . Equivalent to series < other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39450}
{"snippet": "Series.lt(other, level=None, fill_value=None, axis=0)", "intent": "Return Less than of series and `other` , element-wise ( binary operator lt ) . Equivalent to series < other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39451}
{"snippet": "Series.mad()", "intent": "Return the mean absolute deviation of the values over the requested `axis` .", "question_id": 39452}
{"snippet": "Series.mad(axis=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` .", "question_id": 39453}
{"snippet": "Series.mad(skipna=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `skipna`.", "question_id": 39454}
{"snippet": "Series.mad(level=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `level`.", "question_id": 39455}
{"snippet": "Series.mad(axis=None, skipna=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `skipna`.", "question_id": 39456}
{"snippet": "Series.mad(axis=None, level=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `level`.", "question_id": 39457}
{"snippet": "Series.mad(skipna=None, level=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `skipna`, `level`.", "question_id": 39458}
{"snippet": "Series.mad(axis=None, skipna=None, level=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `skipna`, `level`.", "question_id": 39459}
{"snippet": "Series.mad()", "intent": "Return the mean absolute deviation of the values over the requested `axis` .", "question_id": 39460}
{"snippet": "Series.mad(axis=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` .", "question_id": 39461}
{"snippet": "Series.mad(skipna=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `skipna`.", "question_id": 39462}
{"snippet": "Series.mad(level=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `level`.", "question_id": 39463}
{"snippet": "Series.mad(axis=None, skipna=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `skipna`.", "question_id": 39464}
{"snippet": "Series.mad(axis=None, level=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `level`.", "question_id": 39465}
{"snippet": "Series.mad(skipna=None, level=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `skipna`, `level`.", "question_id": 39466}
{"snippet": "Series.mad(axis=None, skipna=None, level=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `skipna`, `level`.", "question_id": 39467}
{"snippet": "Series.mad()", "intent": "Return the mean absolute deviation of the values over the requested `axis` .", "question_id": 39468}
{"snippet": "Series.mad(axis=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` .", "question_id": 39469}
{"snippet": "Series.mad(skipna=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `skipna`.", "question_id": 39470}
{"snippet": "Series.mad(level=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `level`.", "question_id": 39471}
{"snippet": "Series.mad(axis=None, skipna=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `skipna`.", "question_id": 39472}
{"snippet": "Series.mad(axis=None, level=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `level`.", "question_id": 39473}
{"snippet": "Series.mad(skipna=None, level=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `skipna`, `level`.", "question_id": 39474}
{"snippet": "Series.mad(axis=None, skipna=None, level=None)", "intent": "Return the mean absolute deviation of the values over the requested `axis` . With arguments `skipna`, `level`.", "question_id": 39475}
{"snippet": "Series.map(arg)", "intent": "Map values of Series according to input correspondence . When `arg` is a dictionary , values in Series that are not in the dictionary ( as keys ) are converted to NaN .", "question_id": 39476}
{"snippet": "Series.map(arg, na_action=None)", "intent": "Map values of Series according to input correspondence . When `arg` is a dictionary , values in Series that are not in the dictionary ( as keys ) are converted to NaN . With arguments `na_action`.", "question_id": 39477}
{"snippet": "Series.map(arg)", "intent": "Map values of Series according to input correspondence . When `arg` is a dictionary , values in Series that are not in the dictionary ( as keys ) are converted to NaN .", "question_id": 39478}
{"snippet": "Series.map(arg, na_action=None)", "intent": "Map values of Series according to input correspondence . When `arg` is a dictionary , values in Series that are not in the dictionary ( as keys ) are converted to NaN . With arguments `na_action`.", "question_id": 39479}
{"snippet": "Series.map(arg)", "intent": "Map values of Series according to input correspondence . When `arg` is a dictionary , values in Series that are not in the dictionary ( as keys ) are converted to NaN .", "question_id": 39480}
{"snippet": "Series.map(arg, na_action=None)", "intent": "Map values of Series according to input correspondence . When `arg` is a dictionary , values in Series that are not in the dictionary ( as keys ) are converted to NaN . With arguments `na_action`.", "question_id": 39481}
{"snippet": "Series.mask(cond)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used .", "question_id": 39482}
{"snippet": "Series.mask(cond, other=nan)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used .", "question_id": 39483}
{"snippet": "Series.mask(cond, inplace=False)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `inplace`.", "question_id": 39484}
{"snippet": "Series.mask(cond, axis=None)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `axis`.", "question_id": 39485}
{"snippet": "Series.mask(cond, level=None)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `level`.", "question_id": 39486}
{"snippet": "Series.mask(cond, errors='raise')", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `errors`.", "question_id": 39487}
{"snippet": "Series.mask(cond, try_cast=NoDefault.no_default)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `try_cast`.", "question_id": 39488}
{"snippet": "Series.mask(cond, other=nan, inplace=False)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `inplace`.", "question_id": 39489}
{"snippet": "Series.mask(cond, other=nan, axis=None)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `axis`.", "question_id": 39490}
{"snippet": "Series.mask(cond, other=nan, level=None)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `level`.", "question_id": 39491}
{"snippet": "Series.mask(cond)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used .", "question_id": 39492}
{"snippet": "Series.mask(cond, other=nan)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used .", "question_id": 39493}
{"snippet": "Series.mask(cond, inplace=False)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `inplace`.", "question_id": 39494}
{"snippet": "Series.mask(cond, axis=None)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `axis`.", "question_id": 39495}
{"snippet": "Series.mask(cond, level=None)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `level`.", "question_id": 39496}
{"snippet": "Series.mask(cond, errors='raise')", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `errors`.", "question_id": 39497}
{"snippet": "Series.mask(cond, try_cast=NoDefault.no_default)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `try_cast`.", "question_id": 39498}
{"snippet": "Series.mask(cond, other=nan, inplace=False)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `inplace`.", "question_id": 39499}
{"snippet": "Series.mask(cond, other=nan, axis=None)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `axis`.", "question_id": 39500}
{"snippet": "Series.mask(cond, other=nan, level=None)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `level`.", "question_id": 39501}
{"snippet": "Series.mask(cond)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used .", "question_id": 39502}
{"snippet": "Series.mask(cond, other=nan)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used .", "question_id": 39503}
{"snippet": "Series.mask(cond, inplace=False)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `inplace`.", "question_id": 39504}
{"snippet": "Series.mask(cond, axis=None)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `axis`.", "question_id": 39505}
{"snippet": "Series.mask(cond, level=None)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `level`.", "question_id": 39506}
{"snippet": "Series.mask(cond, errors='raise')", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `errors`.", "question_id": 39507}
{"snippet": "Series.mask(cond, try_cast=NoDefault.no_default)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `try_cast`.", "question_id": 39508}
{"snippet": "Series.mask(cond, other=nan, inplace=False)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `inplace`.", "question_id": 39509}
{"snippet": "Series.mask(cond, other=nan, axis=None)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `axis`.", "question_id": 39510}
{"snippet": "Series.mask(cond, other=nan, level=None)", "intent": "Replace values where the condition is True . For each element in the calling DataFrame , if `cond` is False the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `level`.", "question_id": 39511}
{"snippet": "Series.max(**kwargs)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39512}
{"snippet": "Series.max(**kwargs, axis=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39513}
{"snippet": "Series.max(**kwargs, skipna=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39514}
{"snippet": "Series.max(**kwargs, level=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39515}
{"snippet": "Series.max(**kwargs, numeric_only=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39516}
{"snippet": "Series.max(**kwargs, axis=None, skipna=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39517}
{"snippet": "Series.max(**kwargs, axis=None, level=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39518}
{"snippet": "Series.max(**kwargs, axis=None, numeric_only=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39519}
{"snippet": "Series.max(**kwargs, skipna=None, level=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 39520}
{"snippet": "Series.max(**kwargs, skipna=None, numeric_only=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 39521}
{"snippet": "Series.max(**kwargs)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39522}
{"snippet": "Series.max(**kwargs, axis=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39523}
{"snippet": "Series.max(**kwargs, skipna=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39524}
{"snippet": "Series.max(**kwargs, level=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39525}
{"snippet": "Series.max(**kwargs, numeric_only=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39526}
{"snippet": "Series.max(**kwargs, axis=None, skipna=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39527}
{"snippet": "Series.max(**kwargs, axis=None, level=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39528}
{"snippet": "Series.max(**kwargs, axis=None, numeric_only=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39529}
{"snippet": "Series.max(**kwargs, skipna=None, level=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 39530}
{"snippet": "Series.max(**kwargs, skipna=None, numeric_only=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 39531}
{"snippet": "Series.max(**kwargs)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39532}
{"snippet": "Series.max(**kwargs, axis=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39533}
{"snippet": "Series.max(**kwargs, skipna=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39534}
{"snippet": "Series.max(**kwargs, level=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39535}
{"snippet": "Series.max(**kwargs, numeric_only=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39536}
{"snippet": "Series.max(**kwargs, axis=None, skipna=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39537}
{"snippet": "Series.max(**kwargs, axis=None, level=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39538}
{"snippet": "Series.max(**kwargs, axis=None, numeric_only=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39539}
{"snippet": "Series.max(**kwargs, skipna=None, level=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 39540}
{"snippet": "Series.max(**kwargs, skipna=None, numeric_only=None)", "intent": "Return the maximum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 39541}
{"snippet": "Series.mean(**kwargs)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39542}
{"snippet": "Series.mean(**kwargs, axis=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39543}
{"snippet": "Series.mean(**kwargs, skipna=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39544}
{"snippet": "Series.mean(**kwargs, level=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39545}
{"snippet": "Series.mean(**kwargs, numeric_only=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39546}
{"snippet": "Series.mean(**kwargs, axis=None, skipna=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39547}
{"snippet": "Series.mean(**kwargs, axis=None, level=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39548}
{"snippet": "Series.mean(**kwargs, axis=None, numeric_only=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39549}
{"snippet": "Series.mean(**kwargs, skipna=None, level=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 39550}
{"snippet": "Series.mean(**kwargs, skipna=None, numeric_only=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 39551}
{"snippet": "Series.mean(**kwargs)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39552}
{"snippet": "Series.mean(**kwargs, axis=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39553}
{"snippet": "Series.mean(**kwargs, skipna=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39554}
{"snippet": "Series.mean(**kwargs, level=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39555}
{"snippet": "Series.mean(**kwargs, numeric_only=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39556}
{"snippet": "Series.mean(**kwargs, axis=None, skipna=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39557}
{"snippet": "Series.mean(**kwargs, axis=None, level=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39558}
{"snippet": "Series.mean(**kwargs, axis=None, numeric_only=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39559}
{"snippet": "Series.mean(**kwargs, skipna=None, level=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 39560}
{"snippet": "Series.mean(**kwargs, skipna=None, numeric_only=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 39561}
{"snippet": "Series.mean(**kwargs)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39562}
{"snippet": "Series.mean(**kwargs, axis=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39563}
{"snippet": "Series.mean(**kwargs, skipna=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39564}
{"snippet": "Series.mean(**kwargs, level=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39565}
{"snippet": "Series.mean(**kwargs, numeric_only=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39566}
{"snippet": "Series.mean(**kwargs, axis=None, skipna=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39567}
{"snippet": "Series.mean(**kwargs, axis=None, level=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39568}
{"snippet": "Series.mean(**kwargs, axis=None, numeric_only=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39569}
{"snippet": "Series.mean(**kwargs, skipna=None, level=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 39570}
{"snippet": "Series.mean(**kwargs, skipna=None, numeric_only=None)", "intent": "Return the mean of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 39571}
{"snippet": "Series.median(**kwargs)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39572}
{"snippet": "Series.median(**kwargs, axis=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39573}
{"snippet": "Series.median(**kwargs, skipna=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39574}
{"snippet": "Series.median(**kwargs, level=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39575}
{"snippet": "Series.median(**kwargs, numeric_only=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39576}
{"snippet": "Series.median(**kwargs, axis=None, skipna=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39577}
{"snippet": "Series.median(**kwargs, axis=None, level=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39578}
{"snippet": "Series.median(**kwargs, axis=None, numeric_only=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39579}
{"snippet": "Series.median(**kwargs, skipna=None, level=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 39580}
{"snippet": "Series.median(**kwargs, skipna=None, numeric_only=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 39581}
{"snippet": "Series.median(**kwargs)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39582}
{"snippet": "Series.median(**kwargs, axis=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39583}
{"snippet": "Series.median(**kwargs, skipna=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39584}
{"snippet": "Series.median(**kwargs, level=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39585}
{"snippet": "Series.median(**kwargs, numeric_only=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39586}
{"snippet": "Series.median(**kwargs, axis=None, skipna=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39587}
{"snippet": "Series.median(**kwargs, axis=None, level=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39588}
{"snippet": "Series.median(**kwargs, axis=None, numeric_only=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39589}
{"snippet": "Series.median(**kwargs, skipna=None, level=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 39590}
{"snippet": "Series.median(**kwargs, skipna=None, numeric_only=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 39591}
{"snippet": "Series.median(**kwargs)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39592}
{"snippet": "Series.median(**kwargs, axis=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39593}
{"snippet": "Series.median(**kwargs, skipna=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39594}
{"snippet": "Series.median(**kwargs, level=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39595}
{"snippet": "Series.median(**kwargs, numeric_only=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39596}
{"snippet": "Series.median(**kwargs, axis=None, skipna=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39597}
{"snippet": "Series.median(**kwargs, axis=None, level=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39598}
{"snippet": "Series.median(**kwargs, axis=None, numeric_only=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39599}
{"snippet": "Series.median(**kwargs, skipna=None, level=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 39600}
{"snippet": "Series.median(**kwargs, skipna=None, numeric_only=None)", "intent": "Return the median of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 39601}
{"snippet": "Series.memory_usage()", "intent": "Return the memory usage of the Series .", "question_id": 39602}
{"snippet": "Series.memory_usage(index=True)", "intent": "Return the memory usage of the Series . The memory usage can optionally include the contribution of the `index` and of elements of object dtype .", "question_id": 39603}
{"snippet": "Series.memory_usage(deep=False)", "intent": "Return the memory usage of the Series . With arguments `deep`.", "question_id": 39604}
{"snippet": "Series.memory_usage(index=True, deep=False)", "intent": "Return the memory usage of the Series . The memory usage can optionally include the contribution of the `index` and of elements of object dtype . With arguments `deep`.", "question_id": 39605}
{"snippet": "Series.memory_usage()", "intent": "Return the memory usage of the Series .", "question_id": 39606}
{"snippet": "Series.memory_usage(index=True)", "intent": "Return the memory usage of the Series . The memory usage can optionally include the contribution of the `index` and of elements of object dtype .", "question_id": 39607}
{"snippet": "Series.memory_usage(deep=False)", "intent": "Return the memory usage of the Series . With arguments `deep`.", "question_id": 39608}
{"snippet": "Series.memory_usage(index=True, deep=False)", "intent": "Return the memory usage of the Series . The memory usage can optionally include the contribution of the `index` and of elements of object dtype . With arguments `deep`.", "question_id": 39609}
{"snippet": "Series.memory_usage()", "intent": "Return the memory usage of the Series .", "question_id": 39610}
{"snippet": "Series.memory_usage(index=True)", "intent": "Return the memory usage of the Series . The memory usage can optionally include the contribution of the `index` and of elements of object dtype .", "question_id": 39611}
{"snippet": "Series.memory_usage(deep=False)", "intent": "Return the memory usage of the Series . With arguments `deep`.", "question_id": 39612}
{"snippet": "Series.memory_usage(index=True, deep=False)", "intent": "Return the memory usage of the Series . The memory usage can optionally include the contribution of the `index` and of elements of object dtype . With arguments `deep`.", "question_id": 39613}
{"snippet": "Series.min(**kwargs)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39614}
{"snippet": "Series.min(**kwargs, axis=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39615}
{"snippet": "Series.min(**kwargs, skipna=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39616}
{"snippet": "Series.min(**kwargs, level=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39617}
{"snippet": "Series.min(**kwargs, numeric_only=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39618}
{"snippet": "Series.min(**kwargs, axis=None, skipna=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39619}
{"snippet": "Series.min(**kwargs, axis=None, level=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39620}
{"snippet": "Series.min(**kwargs, axis=None, numeric_only=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39621}
{"snippet": "Series.min(**kwargs, skipna=None, level=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 39622}
{"snippet": "Series.min(**kwargs, skipna=None, numeric_only=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 39623}
{"snippet": "Series.min(**kwargs)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39624}
{"snippet": "Series.min(**kwargs, axis=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39625}
{"snippet": "Series.min(**kwargs, skipna=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39626}
{"snippet": "Series.min(**kwargs, level=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39627}
{"snippet": "Series.min(**kwargs, numeric_only=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39628}
{"snippet": "Series.min(**kwargs, axis=None, skipna=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39629}
{"snippet": "Series.min(**kwargs, axis=None, level=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39630}
{"snippet": "Series.min(**kwargs, axis=None, numeric_only=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39631}
{"snippet": "Series.min(**kwargs, skipna=None, level=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 39632}
{"snippet": "Series.min(**kwargs, skipna=None, numeric_only=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 39633}
{"snippet": "Series.min(**kwargs)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39634}
{"snippet": "Series.min(**kwargs, axis=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39635}
{"snippet": "Series.min(**kwargs, skipna=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39636}
{"snippet": "Series.min(**kwargs, level=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39637}
{"snippet": "Series.min(**kwargs, numeric_only=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39638}
{"snippet": "Series.min(**kwargs, axis=None, skipna=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 39639}
{"snippet": "Series.min(**kwargs, axis=None, level=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39640}
{"snippet": "Series.min(**kwargs, axis=None, numeric_only=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39641}
{"snippet": "Series.min(**kwargs, skipna=None, level=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 39642}
{"snippet": "Series.min(**kwargs, skipna=None, numeric_only=None)", "intent": "Return the minimum of the values over the requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 39643}
{"snippet": "Series.mod(other)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator mod ) .", "question_id": 39644}
{"snippet": "Series.mod(other, level=None)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator mod ) . With arguments `level`.", "question_id": 39645}
{"snippet": "Series.mod(other, fill_value=None)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator mod ) . Equivalent to series % other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39646}
{"snippet": "Series.mod(other, axis=0)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator mod ) . With arguments `axis`.", "question_id": 39647}
{"snippet": "Series.mod(other, level=None, fill_value=None)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator mod ) . Equivalent to series % other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39648}
{"snippet": "Series.mod(other, level=None, axis=0)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator mod ) . With arguments `level`, `axis`.", "question_id": 39649}
{"snippet": "Series.mod(other, fill_value=None, axis=0)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator mod ) . Equivalent to series % other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39650}
{"snippet": "Series.mod(other, level=None, fill_value=None, axis=0)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator mod ) . Equivalent to series % other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39651}
{"snippet": "Series.mod(other)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator mod ) .", "question_id": 39652}
{"snippet": "Series.mod(other, level=None)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator mod ) . With arguments `level`.", "question_id": 39653}
{"snippet": "Series.mod(other, fill_value=None)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator mod ) . Equivalent to series % other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39654}
{"snippet": "Series.mod(other, axis=0)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator mod ) . With arguments `axis`.", "question_id": 39655}
{"snippet": "Series.mod(other, level=None, fill_value=None)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator mod ) . Equivalent to series % other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39656}
{"snippet": "Series.mod(other, level=None, axis=0)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator mod ) . With arguments `level`, `axis`.", "question_id": 39657}
{"snippet": "Series.mod(other, fill_value=None, axis=0)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator mod ) . Equivalent to series % other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39658}
{"snippet": "Series.mod(other, level=None, fill_value=None, axis=0)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator mod ) . Equivalent to series % other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39659}
{"snippet": "Series.mod(other)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator mod ) .", "question_id": 39660}
{"snippet": "Series.mod(other, level=None)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator mod ) . With arguments `level`.", "question_id": 39661}
{"snippet": "Series.mod(other, fill_value=None)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator mod ) . Equivalent to series % other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39662}
{"snippet": "Series.mod(other, axis=0)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator mod ) . With arguments `axis`.", "question_id": 39663}
{"snippet": "Series.mod(other, level=None, fill_value=None)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator mod ) . Equivalent to series % other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39664}
{"snippet": "Series.mod(other, level=None, axis=0)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator mod ) . With arguments `level`, `axis`.", "question_id": 39665}
{"snippet": "Series.mod(other, fill_value=None, axis=0)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator mod ) . Equivalent to series % other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39666}
{"snippet": "Series.mod(other, level=None, fill_value=None, axis=0)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator mod ) . Equivalent to series % other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39667}
{"snippet": "Series.mode()", "intent": "Return the mode ( s ) of the Series .", "question_id": 39668}
{"snippet": "Series.mode(dropna=True)", "intent": "Return the mode ( s ) of the Series . With arguments `dropna`.", "question_id": 39669}
{"snippet": "Series.mode()", "intent": "Return the mode ( s ) of the Series .", "question_id": 39670}
{"snippet": "Series.mode(dropna=True)", "intent": "Return the mode ( s ) of the Series . With arguments `dropna`.", "question_id": 39671}
{"snippet": "Series.mode()", "intent": "Return the mode ( s ) of the Series .", "question_id": 39672}
{"snippet": "Series.mode(dropna=True)", "intent": "Return the mode ( s ) of the Series . With arguments `dropna`.", "question_id": 39673}
{"snippet": "Series.mul(other)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) .", "question_id": 39674}
{"snippet": "Series.mul(other, level=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . With arguments `level`.", "question_id": 39675}
{"snippet": "Series.mul(other, fill_value=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . Equivalent to series * other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39676}
{"snippet": "Series.mul(other, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . With arguments `axis`.", "question_id": 39677}
{"snippet": "Series.mul(other, level=None, fill_value=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . Equivalent to series * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39678}
{"snippet": "Series.mul(other, level=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . With arguments `level`, `axis`.", "question_id": 39679}
{"snippet": "Series.mul(other, fill_value=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . Equivalent to series * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39680}
{"snippet": "Series.mul(other, level=None, fill_value=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . Equivalent to series * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39681}
{"snippet": "Series.mul(other)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) .", "question_id": 39682}
{"snippet": "Series.mul(other, level=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . With arguments `level`.", "question_id": 39683}
{"snippet": "Series.mul(other, fill_value=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . Equivalent to series * other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39684}
{"snippet": "Series.mul(other, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . With arguments `axis`.", "question_id": 39685}
{"snippet": "Series.mul(other, level=None, fill_value=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . Equivalent to series * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39686}
{"snippet": "Series.mul(other, level=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . With arguments `level`, `axis`.", "question_id": 39687}
{"snippet": "Series.mul(other, fill_value=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . Equivalent to series * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39688}
{"snippet": "Series.mul(other, level=None, fill_value=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . Equivalent to series * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39689}
{"snippet": "Series.mul(other)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) .", "question_id": 39690}
{"snippet": "Series.mul(other, level=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . With arguments `level`.", "question_id": 39691}
{"snippet": "Series.mul(other, fill_value=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . Equivalent to series * other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39692}
{"snippet": "Series.mul(other, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . With arguments `axis`.", "question_id": 39693}
{"snippet": "Series.mul(other, level=None, fill_value=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . Equivalent to series * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39694}
{"snippet": "Series.mul(other, level=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . With arguments `level`, `axis`.", "question_id": 39695}
{"snippet": "Series.mul(other, fill_value=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . Equivalent to series * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39696}
{"snippet": "Series.mul(other, level=None, fill_value=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . Equivalent to series * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39697}
{"snippet": "Series.multiply(other)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) .", "question_id": 39698}
{"snippet": "Series.multiply(other, level=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . With arguments `level`.", "question_id": 39699}
{"snippet": "Series.multiply(other, fill_value=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . Equivalent to series * other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39700}
{"snippet": "Series.multiply(other, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . With arguments `axis`.", "question_id": 39701}
{"snippet": "Series.multiply(other, level=None, fill_value=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . Equivalent to series * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39702}
{"snippet": "Series.multiply(other, level=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . With arguments `level`, `axis`.", "question_id": 39703}
{"snippet": "Series.multiply(other, fill_value=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . Equivalent to series * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39704}
{"snippet": "Series.multiply(other, level=None, fill_value=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . Equivalent to series * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39705}
{"snippet": "Series.multiply(other)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) .", "question_id": 39706}
{"snippet": "Series.multiply(other, level=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . With arguments `level`.", "question_id": 39707}
{"snippet": "Series.multiply(other, fill_value=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . Equivalent to series * other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39708}
{"snippet": "Series.multiply(other, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . With arguments `axis`.", "question_id": 39709}
{"snippet": "Series.multiply(other, level=None, fill_value=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . Equivalent to series * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39710}
{"snippet": "Series.multiply(other, level=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . With arguments `level`, `axis`.", "question_id": 39711}
{"snippet": "Series.multiply(other, fill_value=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . Equivalent to series * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39712}
{"snippet": "Series.multiply(other, level=None, fill_value=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . Equivalent to series * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39713}
{"snippet": "Series.multiply(other)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) .", "question_id": 39714}
{"snippet": "Series.multiply(other, level=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . With arguments `level`.", "question_id": 39715}
{"snippet": "Series.multiply(other, fill_value=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . Equivalent to series * other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39716}
{"snippet": "Series.multiply(other, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . With arguments `axis`.", "question_id": 39717}
{"snippet": "Series.multiply(other, level=None, fill_value=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . Equivalent to series * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39718}
{"snippet": "Series.multiply(other, level=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . With arguments `level`, `axis`.", "question_id": 39719}
{"snippet": "Series.multiply(other, fill_value=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . Equivalent to series * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39720}
{"snippet": "Series.multiply(other, level=None, fill_value=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator mul ) . Equivalent to series * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39721}
{"snippet": "Series.ne(other)", "intent": "Return Not equal to of series and `other` , element-wise ( binary operator ne ) .", "question_id": 39722}
{"snippet": "Series.ne(other, level=None)", "intent": "Return Not equal to of series and `other` , element-wise ( binary operator ne ) . With arguments `level`.", "question_id": 39723}
{"snippet": "Series.ne(other, fill_value=None)", "intent": "Return Not equal to of series and `other` , element-wise ( binary operator ne ) . Equivalent to series ! = other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39724}
{"snippet": "Series.ne(other, axis=0)", "intent": "Return Not equal to of series and `other` , element-wise ( binary operator ne ) . With arguments `axis`.", "question_id": 39725}
{"snippet": "Series.ne(other, level=None, fill_value=None)", "intent": "Return Not equal to of series and `other` , element-wise ( binary operator ne ) . Equivalent to series ! = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39726}
{"snippet": "Series.ne(other, level=None, axis=0)", "intent": "Return Not equal to of series and `other` , element-wise ( binary operator ne ) . With arguments `level`, `axis`.", "question_id": 39727}
{"snippet": "Series.ne(other, fill_value=None, axis=0)", "intent": "Return Not equal to of series and `other` , element-wise ( binary operator ne ) . Equivalent to series ! = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39728}
{"snippet": "Series.ne(other, level=None, fill_value=None, axis=0)", "intent": "Return Not equal to of series and `other` , element-wise ( binary operator ne ) . Equivalent to series ! = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39729}
{"snippet": "Series.ne(other)", "intent": "Return Not equal to of series and `other` , element-wise ( binary operator ne ) .", "question_id": 39730}
{"snippet": "Series.ne(other, level=None)", "intent": "Return Not equal to of series and `other` , element-wise ( binary operator ne ) . With arguments `level`.", "question_id": 39731}
{"snippet": "Series.ne(other, fill_value=None)", "intent": "Return Not equal to of series and `other` , element-wise ( binary operator ne ) . Equivalent to series ! = other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39732}
{"snippet": "Series.ne(other, axis=0)", "intent": "Return Not equal to of series and `other` , element-wise ( binary operator ne ) . With arguments `axis`.", "question_id": 39733}
{"snippet": "Series.ne(other, level=None, fill_value=None)", "intent": "Return Not equal to of series and `other` , element-wise ( binary operator ne ) . Equivalent to series ! = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39734}
{"snippet": "Series.ne(other, level=None, axis=0)", "intent": "Return Not equal to of series and `other` , element-wise ( binary operator ne ) . With arguments `level`, `axis`.", "question_id": 39735}
{"snippet": "Series.ne(other, fill_value=None, axis=0)", "intent": "Return Not equal to of series and `other` , element-wise ( binary operator ne ) . Equivalent to series ! = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39736}
{"snippet": "Series.ne(other, level=None, fill_value=None, axis=0)", "intent": "Return Not equal to of series and `other` , element-wise ( binary operator ne ) . Equivalent to series ! = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39737}
{"snippet": "Series.ne(other)", "intent": "Return Not equal to of series and `other` , element-wise ( binary operator ne ) .", "question_id": 39738}
{"snippet": "Series.ne(other, level=None)", "intent": "Return Not equal to of series and `other` , element-wise ( binary operator ne ) . With arguments `level`.", "question_id": 39739}
{"snippet": "Series.ne(other, fill_value=None)", "intent": "Return Not equal to of series and `other` , element-wise ( binary operator ne ) . Equivalent to series ! = other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39740}
{"snippet": "Series.ne(other, axis=0)", "intent": "Return Not equal to of series and `other` , element-wise ( binary operator ne ) . With arguments `axis`.", "question_id": 39741}
{"snippet": "Series.ne(other, level=None, fill_value=None)", "intent": "Return Not equal to of series and `other` , element-wise ( binary operator ne ) . Equivalent to series ! = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39742}
{"snippet": "Series.ne(other, level=None, axis=0)", "intent": "Return Not equal to of series and `other` , element-wise ( binary operator ne ) . With arguments `level`, `axis`.", "question_id": 39743}
{"snippet": "Series.ne(other, fill_value=None, axis=0)", "intent": "Return Not equal to of series and `other` , element-wise ( binary operator ne ) . Equivalent to series ! = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39744}
{"snippet": "Series.ne(other, level=None, fill_value=None, axis=0)", "intent": "Return Not equal to of series and `other` , element-wise ( binary operator ne ) . Equivalent to series ! = other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39745}
{"snippet": "Series.nlargest()", "intent": "Return the largest `n` elements .", "question_id": 39746}
{"snippet": "Series.nlargest(n=5)", "intent": "Return the largest `n` elements .", "question_id": 39747}
{"snippet": "Series.nlargest(keep='first')", "intent": "Return the largest `n` elements . Default `keep` value is \u2018 first \u2019 so Malta will be kept .", "question_id": 39748}
{"snippet": "Series.nlargest(n=5, keep='first')", "intent": "Return the largest `n` elements . Default `keep` value is \u2018 first \u2019 so Malta will be kept .", "question_id": 39749}
{"snippet": "Series.nlargest()", "intent": "Return the largest `n` elements .", "question_id": 39750}
{"snippet": "Series.nlargest(n=5)", "intent": "Return the largest `n` elements .", "question_id": 39751}
{"snippet": "Series.nlargest(keep='first')", "intent": "Return the largest `n` elements . Default `keep` value is \u2018 first \u2019 so Malta will be kept .", "question_id": 39752}
{"snippet": "Series.nlargest(n=5, keep='first')", "intent": "Return the largest `n` elements . Default `keep` value is \u2018 first \u2019 so Malta will be kept .", "question_id": 39753}
{"snippet": "Series.nlargest()", "intent": "Return the largest `n` elements .", "question_id": 39754}
{"snippet": "Series.nlargest(n=5)", "intent": "Return the largest `n` elements .", "question_id": 39755}
{"snippet": "Series.nlargest(keep='first')", "intent": "Return the largest `n` elements . Default `keep` value is \u2018 first \u2019 so Malta will be kept .", "question_id": 39756}
{"snippet": "Series.nlargest(n=5, keep='first')", "intent": "Return the largest `n` elements . Default `keep` value is \u2018 first \u2019 so Malta will be kept .", "question_id": 39757}
{"snippet": "Series.notna()", "intent": "Detect existing ( non-missing ) values .", "question_id": 39758}
{"snippet": "Series.notna()", "intent": "Detect existing ( non-missing ) values .", "question_id": 39759}
{"snippet": "Series.notna()", "intent": "Detect existing ( non-missing ) values .", "question_id": 39760}
{"snippet": "Series.notnull()", "intent": "Detect existing ( non-missing ) values .", "question_id": 39761}
{"snippet": "Series.notnull()", "intent": "Detect existing ( non-missing ) values .", "question_id": 39762}
{"snippet": "Series.notnull()", "intent": "Detect existing ( non-missing ) values .", "question_id": 39763}
{"snippet": "Series.nsmallest()", "intent": "Return the smallest `n` elements .", "question_id": 39764}
{"snippet": "Series.nsmallest(n=5)", "intent": "Return the smallest `n` elements .", "question_id": 39765}
{"snippet": "Series.nsmallest(keep='first')", "intent": "Return the smallest `n` elements . Default `keep` value is \u2018 first \u2019 so Nauru and Tuvalu will be kept .", "question_id": 39766}
{"snippet": "Series.nsmallest(n=5, keep='first')", "intent": "Return the smallest `n` elements . Default `keep` value is \u2018 first \u2019 so Nauru and Tuvalu will be kept .", "question_id": 39767}
{"snippet": "Series.nsmallest()", "intent": "Return the smallest `n` elements .", "question_id": 39768}
{"snippet": "Series.nsmallest(n=5)", "intent": "Return the smallest `n` elements .", "question_id": 39769}
{"snippet": "Series.nsmallest(keep='first')", "intent": "Return the smallest `n` elements . Default `keep` value is \u2018 first \u2019 so Nauru and Tuvalu will be kept .", "question_id": 39770}
{"snippet": "Series.nsmallest(n=5, keep='first')", "intent": "Return the smallest `n` elements . Default `keep` value is \u2018 first \u2019 so Nauru and Tuvalu will be kept .", "question_id": 39771}
{"snippet": "Series.nsmallest()", "intent": "Return the smallest `n` elements .", "question_id": 39772}
{"snippet": "Series.nsmallest(n=5)", "intent": "Return the smallest `n` elements .", "question_id": 39773}
{"snippet": "Series.nsmallest(keep='first')", "intent": "Return the smallest `n` elements . Default `keep` value is \u2018 first \u2019 so Nauru and Tuvalu will be kept .", "question_id": 39774}
{"snippet": "Series.nsmallest(n=5, keep='first')", "intent": "Return the smallest `n` elements . Default `keep` value is \u2018 first \u2019 so Nauru and Tuvalu will be kept .", "question_id": 39775}
{"snippet": "Series.nunique()", "intent": "Return number of unique elements in the object .", "question_id": 39776}
{"snippet": "Series.nunique(dropna=True)", "intent": "Return number of unique elements in the object . With arguments `dropna`.", "question_id": 39777}
{"snippet": "Series.nunique()", "intent": "Return number of unique elements in the object .", "question_id": 39778}
{"snippet": "Series.nunique(dropna=True)", "intent": "Return number of unique elements in the object . With arguments `dropna`.", "question_id": 39779}
{"snippet": "Series.nunique()", "intent": "Return number of unique elements in the object .", "question_id": 39780}
{"snippet": "Series.nunique(dropna=True)", "intent": "Return number of unique elements in the object . With arguments `dropna`.", "question_id": 39781}
{"snippet": "Series.pad()", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' .", "question_id": 39782}
{"snippet": "Series.pad(axis=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`.", "question_id": 39783}
{"snippet": "Series.pad(inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`.", "question_id": 39784}
{"snippet": "Series.pad(limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `limit`.", "question_id": 39785}
{"snippet": "Series.pad(downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `downcast`.", "question_id": 39786}
{"snippet": "Series.pad(axis=None, inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `inplace`.", "question_id": 39787}
{"snippet": "Series.pad(axis=None, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `limit`.", "question_id": 39788}
{"snippet": "Series.pad(axis=None, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `downcast`.", "question_id": 39789}
{"snippet": "Series.pad(inplace=False, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`, `limit`.", "question_id": 39790}
{"snippet": "Series.pad(inplace=False, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`, `downcast`.", "question_id": 39791}
{"snippet": "Series.pad()", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' .", "question_id": 39792}
{"snippet": "Series.pad(axis=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`.", "question_id": 39793}
{"snippet": "Series.pad(inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`.", "question_id": 39794}
{"snippet": "Series.pad(limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `limit`.", "question_id": 39795}
{"snippet": "Series.pad(downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `downcast`.", "question_id": 39796}
{"snippet": "Series.pad(axis=None, inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `inplace`.", "question_id": 39797}
{"snippet": "Series.pad(axis=None, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `limit`.", "question_id": 39798}
{"snippet": "Series.pad(axis=None, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `downcast`.", "question_id": 39799}
{"snippet": "Series.pad(inplace=False, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`, `limit`.", "question_id": 39800}
{"snippet": "Series.pad(inplace=False, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`, `downcast`.", "question_id": 39801}
{"snippet": "Series.pad()", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' .", "question_id": 39802}
{"snippet": "Series.pad(axis=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`.", "question_id": 39803}
{"snippet": "Series.pad(inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`.", "question_id": 39804}
{"snippet": "Series.pad(limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `limit`.", "question_id": 39805}
{"snippet": "Series.pad(downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `downcast`.", "question_id": 39806}
{"snippet": "Series.pad(axis=None, inplace=False)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `inplace`.", "question_id": 39807}
{"snippet": "Series.pad(axis=None, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `limit`.", "question_id": 39808}
{"snippet": "Series.pad(axis=None, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `axis`, `downcast`.", "question_id": 39809}
{"snippet": "Series.pad(inplace=False, limit=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`, `limit`.", "question_id": 39810}
{"snippet": "Series.pad(inplace=False, downcast=None)", "intent": "Synonym for DataFrame.fillna ( ) with method='ffill ' . With arguments `inplace`, `downcast`.", "question_id": 39811}
{"snippet": "Series.pct_change(**kwargs)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`.", "question_id": 39812}
{"snippet": "Series.pct_change(**kwargs, periods=1)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `periods`.", "question_id": 39813}
{"snippet": "Series.pct_change(**kwargs, fill_method='pad')", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `fill_method`.", "question_id": 39814}
{"snippet": "Series.pct_change(**kwargs, limit=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `limit`.", "question_id": 39815}
{"snippet": "Series.pct_change(**kwargs, freq=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `freq`.", "question_id": 39816}
{"snippet": "Series.pct_change(**kwargs, periods=1, fill_method='pad')", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `periods`, `fill_method`.", "question_id": 39817}
{"snippet": "Series.pct_change(**kwargs, periods=1, limit=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `periods`, `limit`.", "question_id": 39818}
{"snippet": "Series.pct_change(**kwargs, periods=1, freq=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `periods`, `freq`.", "question_id": 39819}
{"snippet": "Series.pct_change(**kwargs, fill_method='pad', limit=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `fill_method`, `limit`.", "question_id": 39820}
{"snippet": "Series.pct_change(**kwargs, fill_method='pad', freq=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `fill_method`, `freq`.", "question_id": 39821}
{"snippet": "Series.pct_change(**kwargs)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`.", "question_id": 39822}
{"snippet": "Series.pct_change(**kwargs, periods=1)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `periods`.", "question_id": 39823}
{"snippet": "Series.pct_change(**kwargs, fill_method='pad')", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `fill_method`.", "question_id": 39824}
{"snippet": "Series.pct_change(**kwargs, limit=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `limit`.", "question_id": 39825}
{"snippet": "Series.pct_change(**kwargs, freq=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `freq`.", "question_id": 39826}
{"snippet": "Series.pct_change(**kwargs, periods=1, fill_method='pad')", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `periods`, `fill_method`.", "question_id": 39827}
{"snippet": "Series.pct_change(**kwargs, periods=1, limit=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `periods`, `limit`.", "question_id": 39828}
{"snippet": "Series.pct_change(**kwargs, periods=1, freq=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `periods`, `freq`.", "question_id": 39829}
{"snippet": "Series.pct_change(**kwargs, fill_method='pad', limit=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `fill_method`, `limit`.", "question_id": 39830}
{"snippet": "Series.pct_change(**kwargs, fill_method='pad', freq=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `fill_method`, `freq`.", "question_id": 39831}
{"snippet": "Series.pct_change(**kwargs)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`.", "question_id": 39832}
{"snippet": "Series.pct_change(**kwargs, periods=1)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `periods`.", "question_id": 39833}
{"snippet": "Series.pct_change(**kwargs, fill_method='pad')", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `fill_method`.", "question_id": 39834}
{"snippet": "Series.pct_change(**kwargs, limit=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `limit`.", "question_id": 39835}
{"snippet": "Series.pct_change(**kwargs, freq=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `freq`.", "question_id": 39836}
{"snippet": "Series.pct_change(**kwargs, periods=1, fill_method='pad')", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `periods`, `fill_method`.", "question_id": 39837}
{"snippet": "Series.pct_change(**kwargs, periods=1, limit=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `periods`, `limit`.", "question_id": 39838}
{"snippet": "Series.pct_change(**kwargs, periods=1, freq=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `periods`, `freq`.", "question_id": 39839}
{"snippet": "Series.pct_change(**kwargs, fill_method='pad', limit=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `fill_method`, `limit`.", "question_id": 39840}
{"snippet": "Series.pct_change(**kwargs, fill_method='pad', freq=None)", "intent": "Percentage change between the current and a prior element . With arguments `**kwargs`, `fill_method`, `freq`.", "question_id": 39841}
{"snippet": "Series.pipe(func, *args, **kwargs)", "intent": "Apply `func` ( self , * args , * * kwargs ) . With arguments `*args`, `**kwargs`.", "question_id": 39842}
{"snippet": "Series.pipe(func, *args, **kwargs)", "intent": "Apply `func` ( self , * args , * * kwargs ) . With arguments `*args`, `**kwargs`.", "question_id": 39843}
{"snippet": "Series.pipe(func, *args, **kwargs)", "intent": "Apply `func` ( self , * args , * * kwargs ) . With arguments `*args`, `**kwargs`.", "question_id": 39844}
{"snippet": "Series.plot.area(**kwargs)", "intent": "Draw a stacked area plot . With arguments `**kwargs`.", "question_id": 39845}
{"snippet": "Series.plot.area(**kwargs, x=None)", "intent": "Draw a stacked area plot . Draw with a different `x` : With arguments `**kwargs`.", "question_id": 39846}
{"snippet": "Series.plot.area(**kwargs, y=None)", "intent": "Draw a stacked area plot . With arguments `**kwargs`, `y`.", "question_id": 39847}
{"snippet": "Series.plot.area(**kwargs, x=None, y=None)", "intent": "Draw a stacked area plot . Draw with a different `x` : With arguments `**kwargs`, `y`.", "question_id": 39848}
{"snippet": "Series.plot.area(**kwargs)", "intent": "Draw a stacked area plot . With arguments `**kwargs`.", "question_id": 39849}
{"snippet": "Series.plot.area(**kwargs, x=None)", "intent": "Draw a stacked area plot . Draw with a different `x` : With arguments `**kwargs`.", "question_id": 39850}
{"snippet": "Series.plot.area(**kwargs, y=None)", "intent": "Draw a stacked area plot . With arguments `**kwargs`, `y`.", "question_id": 39851}
{"snippet": "Series.plot.area(**kwargs, x=None, y=None)", "intent": "Draw a stacked area plot . Draw with a different `x` : With arguments `**kwargs`, `y`.", "question_id": 39852}
{"snippet": "Series.plot.area(**kwargs)", "intent": "Draw a stacked area plot . With arguments `**kwargs`.", "question_id": 39853}
{"snippet": "Series.plot.area(**kwargs, x=None)", "intent": "Draw a stacked area plot . Draw with a different `x` : With arguments `**kwargs`.", "question_id": 39854}
{"snippet": "Series.plot.area(**kwargs, y=None)", "intent": "Draw a stacked area plot . With arguments `**kwargs`, `y`.", "question_id": 39855}
{"snippet": "Series.plot.area(**kwargs, x=None, y=None)", "intent": "Draw a stacked area plot . Draw with a different `x` : With arguments `**kwargs`, `y`.", "question_id": 39856}
{"snippet": "Series.plot.bar(**kwargs)", "intent": "Vertical bar plot . With arguments `**kwargs`.", "question_id": 39857}
{"snippet": "Series.plot.bar(**kwargs, x=None)", "intent": "Vertical bar plot . With arguments `**kwargs`, `x`.", "question_id": 39858}
{"snippet": "Series.plot.bar(**kwargs, y=None)", "intent": "Vertical bar plot . With arguments `**kwargs`, `y`.", "question_id": 39859}
{"snippet": "Series.plot.bar(**kwargs, x=None, y=None)", "intent": "Vertical bar plot . With arguments `**kwargs`, `x`, `y`.", "question_id": 39860}
{"snippet": "Series.plot.bar(**kwargs)", "intent": "Vertical bar plot . With arguments `**kwargs`.", "question_id": 39861}
{"snippet": "Series.plot.bar(**kwargs, x=None)", "intent": "Vertical bar plot . With arguments `**kwargs`, `x`.", "question_id": 39862}
{"snippet": "Series.plot.bar(**kwargs, y=None)", "intent": "Vertical bar plot . With arguments `**kwargs`, `y`.", "question_id": 39863}
{"snippet": "Series.plot.bar(**kwargs, x=None, y=None)", "intent": "Vertical bar plot . With arguments `**kwargs`, `x`, `y`.", "question_id": 39864}
{"snippet": "Series.plot.bar(**kwargs)", "intent": "Vertical bar plot . With arguments `**kwargs`.", "question_id": 39865}
{"snippet": "Series.plot.bar(**kwargs, x=None)", "intent": "Vertical bar plot . With arguments `**kwargs`, `x`.", "question_id": 39866}
{"snippet": "Series.plot.bar(**kwargs, y=None)", "intent": "Vertical bar plot . With arguments `**kwargs`, `y`.", "question_id": 39867}
{"snippet": "Series.plot.bar(**kwargs, x=None, y=None)", "intent": "Vertical bar plot . With arguments `**kwargs`, `x`, `y`.", "question_id": 39868}
{"snippet": "Series.plot.barh(**kwargs)", "intent": "Make a horizontal bar plot . With arguments `**kwargs`.", "question_id": 39869}
{"snippet": "Series.plot.barh(**kwargs, x=None)", "intent": "Make a horizontal bar plot . With arguments `**kwargs`, `x`.", "question_id": 39870}
{"snippet": "Series.plot.barh(**kwargs, y=None)", "intent": "Make a horizontal bar plot . With arguments `**kwargs`, `y`.", "question_id": 39871}
{"snippet": "Series.plot.barh(**kwargs, x=None, y=None)", "intent": "Make a horizontal bar plot . With arguments `**kwargs`, `x`, `y`.", "question_id": 39872}
{"snippet": "Series.plot.barh(**kwargs)", "intent": "Make a horizontal bar plot . With arguments `**kwargs`.", "question_id": 39873}
{"snippet": "Series.plot.barh(**kwargs, x=None)", "intent": "Make a horizontal bar plot . With arguments `**kwargs`, `x`.", "question_id": 39874}
{"snippet": "Series.plot.barh(**kwargs, y=None)", "intent": "Make a horizontal bar plot . With arguments `**kwargs`, `y`.", "question_id": 39875}
{"snippet": "Series.plot.barh(**kwargs, x=None, y=None)", "intent": "Make a horizontal bar plot . With arguments `**kwargs`, `x`, `y`.", "question_id": 39876}
{"snippet": "Series.plot.barh(**kwargs)", "intent": "Make a horizontal bar plot . With arguments `**kwargs`.", "question_id": 39877}
{"snippet": "Series.plot.barh(**kwargs, x=None)", "intent": "Make a horizontal bar plot . With arguments `**kwargs`, `x`.", "question_id": 39878}
{"snippet": "Series.plot.barh(**kwargs, y=None)", "intent": "Make a horizontal bar plot . With arguments `**kwargs`, `y`.", "question_id": 39879}
{"snippet": "Series.plot.barh(**kwargs, x=None, y=None)", "intent": "Make a horizontal bar plot . With arguments `**kwargs`, `x`, `y`.", "question_id": 39880}
{"snippet": "Series.plot.box(**kwargs)", "intent": "Make a box plot of the DataFrame columns . With arguments `**kwargs`.", "question_id": 39881}
{"snippet": "Series.plot.box(**kwargs, by=None)", "intent": "Make a box plot of the DataFrame columns . The position of the whiskers is set `by` default to 1.5 * IQR ( IQR = Q3 - Q1 ) from the edges of the box . With arguments `**kwargs`.", "question_id": 39882}
{"snippet": "Series.plot.box(**kwargs)", "intent": "Make a box plot of the DataFrame columns . With arguments `**kwargs`.", "question_id": 39883}
{"snippet": "Series.plot.box(**kwargs, by=None)", "intent": "Make a box plot of the DataFrame columns . The position of the whiskers is set `by` default to 1.5 * IQR ( IQR = Q3 - Q1 ) from the edges of the box . With arguments `**kwargs`.", "question_id": 39884}
{"snippet": "Series.plot.box(**kwargs)", "intent": "Make a box plot of the DataFrame columns . With arguments `**kwargs`.", "question_id": 39885}
{"snippet": "Series.plot.box(**kwargs, by=None)", "intent": "Make a box plot of the DataFrame columns . The position of the whiskers is set `by` default to 1.5 * IQR ( IQR = Q3 - Q1 ) from the edges of the box . With arguments `**kwargs`.", "question_id": 39886}
{"snippet": "Series.plot.density(**kwargs)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . With arguments `**kwargs`.", "question_id": 39887}
{"snippet": "Series.plot.density(**kwargs, bw_method=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . With arguments `**kwargs`, `bw_method`.", "question_id": 39888}
{"snippet": "Series.plot.density(**kwargs, ind=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . Finally , the `ind` parameter determines the evaluation points for the plot of the estimated PDF : With arguments `**kwargs`.", "question_id": 39889}
{"snippet": "Series.plot.density(**kwargs, bw_method=None, ind=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . Finally , the `ind` parameter determines the evaluation points for the plot of the estimated PDF : With arguments `**kwargs`, `bw_method`.", "question_id": 39890}
{"snippet": "Series.plot.density(**kwargs)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . With arguments `**kwargs`.", "question_id": 39891}
{"snippet": "Series.plot.density(**kwargs, bw_method=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . With arguments `**kwargs`, `bw_method`.", "question_id": 39892}
{"snippet": "Series.plot.density(**kwargs, ind=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . Finally , the `ind` parameter determines the evaluation points for the plot of the estimated PDF : With arguments `**kwargs`.", "question_id": 39893}
{"snippet": "Series.plot.density(**kwargs, bw_method=None, ind=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . Finally , the `ind` parameter determines the evaluation points for the plot of the estimated PDF : With arguments `**kwargs`, `bw_method`.", "question_id": 39894}
{"snippet": "Series.plot.density(**kwargs)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . With arguments `**kwargs`.", "question_id": 39895}
{"snippet": "Series.plot.density(**kwargs, bw_method=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . With arguments `**kwargs`, `bw_method`.", "question_id": 39896}
{"snippet": "Series.plot.density(**kwargs, ind=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . Finally , the `ind` parameter determines the evaluation points for the plot of the estimated PDF : With arguments `**kwargs`.", "question_id": 39897}
{"snippet": "Series.plot.density(**kwargs, bw_method=None, ind=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . Finally , the `ind` parameter determines the evaluation points for the plot of the estimated PDF : With arguments `**kwargs`, `bw_method`.", "question_id": 39898}
{"snippet": "Series.plot.hist(**kwargs)", "intent": "Draw one histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`.", "question_id": 39899}
{"snippet": "Series.plot.hist(**kwargs, by=None)", "intent": "Draw one histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `by`.", "question_id": 39900}
{"snippet": "Series.plot.hist(**kwargs, bins=10)", "intent": "Draw one histogram of the DataFrame \u2019 s columns . This function groups the values of all given Series in the DataFrame into `bins` and draws all bins in one matplotlib.axes.Axes . With arguments `**kwargs`.", "question_id": 39901}
{"snippet": "Series.plot.hist(**kwargs, by=None, bins=10)", "intent": "Draw one histogram of the DataFrame \u2019 s columns . This function groups the values of all given Series in the DataFrame into `bins` and draws all bins in one matplotlib.axes.Axes . With arguments `**kwargs`, `by`.", "question_id": 39902}
{"snippet": "Series.plot.hist(**kwargs)", "intent": "Draw one histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`.", "question_id": 39903}
{"snippet": "Series.plot.hist(**kwargs, by=None)", "intent": "Draw one histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `by`.", "question_id": 39904}
{"snippet": "Series.plot.hist(**kwargs, bins=10)", "intent": "Draw one histogram of the DataFrame \u2019 s columns . This function groups the values of all given Series in the DataFrame into `bins` and draws all bins in one matplotlib.axes.Axes . With arguments `**kwargs`.", "question_id": 39905}
{"snippet": "Series.plot.hist(**kwargs, by=None, bins=10)", "intent": "Draw one histogram of the DataFrame \u2019 s columns . This function groups the values of all given Series in the DataFrame into `bins` and draws all bins in one matplotlib.axes.Axes . With arguments `**kwargs`, `by`.", "question_id": 39906}
{"snippet": "Series.plot.hist(**kwargs)", "intent": "Draw one histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`.", "question_id": 39907}
{"snippet": "Series.plot.hist(**kwargs, by=None)", "intent": "Draw one histogram of the DataFrame \u2019 s columns . With arguments `**kwargs`, `by`.", "question_id": 39908}
{"snippet": "Series.plot.hist(**kwargs, bins=10)", "intent": "Draw one histogram of the DataFrame \u2019 s columns . This function groups the values of all given Series in the DataFrame into `bins` and draws all bins in one matplotlib.axes.Axes . With arguments `**kwargs`.", "question_id": 39909}
{"snippet": "Series.plot.hist(**kwargs, by=None, bins=10)", "intent": "Draw one histogram of the DataFrame \u2019 s columns . This function groups the values of all given Series in the DataFrame into `bins` and draws all bins in one matplotlib.axes.Axes . With arguments `**kwargs`, `by`.", "question_id": 39910}
{"snippet": "Series.plot(*args, **kwargs)", "intent": "Make plots of Series or DataFrame . With arguments `*args`, `**kwargs`.", "question_id": 39911}
{"snippet": "Series.plot(*args, **kwargs)", "intent": "Make plots of Series or DataFrame . With arguments `*args`, `**kwargs`.", "question_id": 39912}
{"snippet": "Series.plot(*args, **kwargs)", "intent": "Make plots of Series or DataFrame . With arguments `*args`, `**kwargs`.", "question_id": 39913}
{"snippet": "Series.plot.kde(**kwargs)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . With arguments `**kwargs`.", "question_id": 39914}
{"snippet": "Series.plot.kde(**kwargs, bw_method=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . With arguments `**kwargs`, `bw_method`.", "question_id": 39915}
{"snippet": "Series.plot.kde(**kwargs, ind=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . Finally , the `ind` parameter determines the evaluation points for the plot of the estimated PDF : With arguments `**kwargs`.", "question_id": 39916}
{"snippet": "Series.plot.kde(**kwargs, bw_method=None, ind=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . Finally , the `ind` parameter determines the evaluation points for the plot of the estimated PDF : With arguments `**kwargs`, `bw_method`.", "question_id": 39917}
{"snippet": "Series.plot.kde(**kwargs)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . With arguments `**kwargs`.", "question_id": 39918}
{"snippet": "Series.plot.kde(**kwargs, bw_method=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . With arguments `**kwargs`, `bw_method`.", "question_id": 39919}
{"snippet": "Series.plot.kde(**kwargs, ind=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . Finally , the `ind` parameter determines the evaluation points for the plot of the estimated PDF : With arguments `**kwargs`.", "question_id": 39920}
{"snippet": "Series.plot.kde(**kwargs, bw_method=None, ind=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . Finally , the `ind` parameter determines the evaluation points for the plot of the estimated PDF : With arguments `**kwargs`, `bw_method`.", "question_id": 39921}
{"snippet": "Series.plot.kde(**kwargs)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . With arguments `**kwargs`.", "question_id": 39922}
{"snippet": "Series.plot.kde(**kwargs, bw_method=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . With arguments `**kwargs`, `bw_method`.", "question_id": 39923}
{"snippet": "Series.plot.kde(**kwargs, ind=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . Finally , the `ind` parameter determines the evaluation points for the plot of the estimated PDF : With arguments `**kwargs`.", "question_id": 39924}
{"snippet": "Series.plot.kde(**kwargs, bw_method=None, ind=None)", "intent": "Generate Kernel Density Estimate plot using Gaussian kernels . Finally , the `ind` parameter determines the evaluation points for the plot of the estimated PDF : With arguments `**kwargs`, `bw_method`.", "question_id": 39925}
{"snippet": "Series.plot.line(**kwargs)", "intent": "Plot Series or DataFrame as lines . With arguments `**kwargs`.", "question_id": 39926}
{"snippet": "Series.plot.line(**kwargs, x=None)", "intent": "Plot Series or DataFrame as lines . With arguments `**kwargs`, `x`.", "question_id": 39927}
{"snippet": "Series.plot.line(**kwargs, y=None)", "intent": "Plot Series or DataFrame as lines . With arguments `**kwargs`, `y`.", "question_id": 39928}
{"snippet": "Series.plot.line(**kwargs, x=None, y=None)", "intent": "Plot Series or DataFrame as lines . With arguments `**kwargs`, `x`, `y`.", "question_id": 39929}
{"snippet": "Series.plot.line(**kwargs)", "intent": "Plot Series or DataFrame as lines . With arguments `**kwargs`.", "question_id": 39930}
{"snippet": "Series.plot.line(**kwargs, x=None)", "intent": "Plot Series or DataFrame as lines . With arguments `**kwargs`, `x`.", "question_id": 39931}
{"snippet": "Series.plot.line(**kwargs, y=None)", "intent": "Plot Series or DataFrame as lines . With arguments `**kwargs`, `y`.", "question_id": 39932}
{"snippet": "Series.plot.line(**kwargs, x=None, y=None)", "intent": "Plot Series or DataFrame as lines . With arguments `**kwargs`, `x`, `y`.", "question_id": 39933}
{"snippet": "Series.plot.line(**kwargs)", "intent": "Plot Series or DataFrame as lines . With arguments `**kwargs`.", "question_id": 39934}
{"snippet": "Series.plot.line(**kwargs, x=None)", "intent": "Plot Series or DataFrame as lines . With arguments `**kwargs`, `x`.", "question_id": 39935}
{"snippet": "Series.plot.line(**kwargs, y=None)", "intent": "Plot Series or DataFrame as lines . With arguments `**kwargs`, `y`.", "question_id": 39936}
{"snippet": "Series.plot.line(**kwargs, x=None, y=None)", "intent": "Plot Series or DataFrame as lines . With arguments `**kwargs`, `x`, `y`.", "question_id": 39937}
{"snippet": "Series.plot.pie(**kwargs)", "intent": "Generate a pie plot . With arguments `**kwargs`.", "question_id": 39938}
{"snippet": "Series.plot.pie(**kwargs)", "intent": "Generate a pie plot . With arguments `**kwargs`.", "question_id": 39939}
{"snippet": "Series.plot.pie(**kwargs)", "intent": "Generate a pie plot . With arguments `**kwargs`.", "question_id": 39940}
{"snippet": "Series.pop(item)", "intent": "Return `item` and drops from series .", "question_id": 39941}
{"snippet": "Series.pop(item)", "intent": "Return `item` and drops from series .", "question_id": 39942}
{"snippet": "Series.pop(item)", "intent": "Return `item` and drops from series .", "question_id": 39943}
{"snippet": "Series.pow(other)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator pow ) .", "question_id": 39944}
{"snippet": "Series.pow(other, level=None)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator pow ) . With arguments `level`.", "question_id": 39945}
{"snippet": "Series.pow(other, fill_value=None)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator pow ) . Equivalent to series * * other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39946}
{"snippet": "Series.pow(other, axis=0)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator pow ) . With arguments `axis`.", "question_id": 39947}
{"snippet": "Series.pow(other, level=None, fill_value=None)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator pow ) . Equivalent to series * * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39948}
{"snippet": "Series.pow(other, level=None, axis=0)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator pow ) . With arguments `level`, `axis`.", "question_id": 39949}
{"snippet": "Series.pow(other, fill_value=None, axis=0)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator pow ) . Equivalent to series * * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39950}
{"snippet": "Series.pow(other, level=None, fill_value=None, axis=0)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator pow ) . Equivalent to series * * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39951}
{"snippet": "Series.pow(other)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator pow ) .", "question_id": 39952}
{"snippet": "Series.pow(other, level=None)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator pow ) . With arguments `level`.", "question_id": 39953}
{"snippet": "Series.pow(other, fill_value=None)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator pow ) . Equivalent to series * * other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39954}
{"snippet": "Series.pow(other, axis=0)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator pow ) . With arguments `axis`.", "question_id": 39955}
{"snippet": "Series.pow(other, level=None, fill_value=None)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator pow ) . Equivalent to series * * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39956}
{"snippet": "Series.pow(other, level=None, axis=0)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator pow ) . With arguments `level`, `axis`.", "question_id": 39957}
{"snippet": "Series.pow(other, fill_value=None, axis=0)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator pow ) . Equivalent to series * * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39958}
{"snippet": "Series.pow(other, level=None, fill_value=None, axis=0)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator pow ) . Equivalent to series * * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39959}
{"snippet": "Series.pow(other)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator pow ) .", "question_id": 39960}
{"snippet": "Series.pow(other, level=None)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator pow ) . With arguments `level`.", "question_id": 39961}
{"snippet": "Series.pow(other, fill_value=None)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator pow ) . Equivalent to series * * other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 39962}
{"snippet": "Series.pow(other, axis=0)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator pow ) . With arguments `axis`.", "question_id": 39963}
{"snippet": "Series.pow(other, level=None, fill_value=None)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator pow ) . Equivalent to series * * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 39964}
{"snippet": "Series.pow(other, level=None, axis=0)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator pow ) . With arguments `level`, `axis`.", "question_id": 39965}
{"snippet": "Series.pow(other, fill_value=None, axis=0)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator pow ) . Equivalent to series * * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 39966}
{"snippet": "Series.pow(other, level=None, fill_value=None, axis=0)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator pow ) . Equivalent to series * * other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 39967}
{"snippet": "Series.prod(**kwargs)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39968}
{"snippet": "Series.prod(**kwargs, axis=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39969}
{"snippet": "Series.prod(**kwargs, skipna=None)", "intent": "Return the product of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 39970}
{"snippet": "Series.prod(**kwargs, level=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39971}
{"snippet": "Series.prod(**kwargs, numeric_only=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39972}
{"snippet": "Series.prod(**kwargs, min_count=0)", "intent": "Return the product of the values over the requested `axis` . This can be controlled with the `min_count` parameter With arguments `**kwargs`.", "question_id": 39973}
{"snippet": "Series.prod(**kwargs, axis=None, skipna=None)", "intent": "Return the product of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 39974}
{"snippet": "Series.prod(**kwargs, axis=None, level=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39975}
{"snippet": "Series.prod(**kwargs, axis=None, numeric_only=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39976}
{"snippet": "Series.prod(**kwargs, axis=None, min_count=0)", "intent": "Return the product of the values over the requested `axis` . This can be controlled with the `min_count` parameter With arguments `**kwargs`.", "question_id": 39977}
{"snippet": "Series.prod(**kwargs)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39978}
{"snippet": "Series.prod(**kwargs, axis=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39979}
{"snippet": "Series.prod(**kwargs, skipna=None)", "intent": "Return the product of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 39980}
{"snippet": "Series.prod(**kwargs, level=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39981}
{"snippet": "Series.prod(**kwargs, numeric_only=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39982}
{"snippet": "Series.prod(**kwargs, min_count=0)", "intent": "Return the product of the values over the requested `axis` . This can be controlled with the `min_count` parameter With arguments `**kwargs`.", "question_id": 39983}
{"snippet": "Series.prod(**kwargs, axis=None, skipna=None)", "intent": "Return the product of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 39984}
{"snippet": "Series.prod(**kwargs, axis=None, level=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39985}
{"snippet": "Series.prod(**kwargs, axis=None, numeric_only=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39986}
{"snippet": "Series.prod(**kwargs, axis=None, min_count=0)", "intent": "Return the product of the values over the requested `axis` . This can be controlled with the `min_count` parameter With arguments `**kwargs`.", "question_id": 39987}
{"snippet": "Series.prod(**kwargs)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39988}
{"snippet": "Series.prod(**kwargs, axis=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39989}
{"snippet": "Series.prod(**kwargs, skipna=None)", "intent": "Return the product of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 39990}
{"snippet": "Series.prod(**kwargs, level=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39991}
{"snippet": "Series.prod(**kwargs, numeric_only=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39992}
{"snippet": "Series.prod(**kwargs, min_count=0)", "intent": "Return the product of the values over the requested `axis` . This can be controlled with the `min_count` parameter With arguments `**kwargs`.", "question_id": 39993}
{"snippet": "Series.prod(**kwargs, axis=None, skipna=None)", "intent": "Return the product of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 39994}
{"snippet": "Series.prod(**kwargs, axis=None, level=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 39995}
{"snippet": "Series.prod(**kwargs, axis=None, numeric_only=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 39996}
{"snippet": "Series.prod(**kwargs, axis=None, min_count=0)", "intent": "Return the product of the values over the requested `axis` . This can be controlled with the `min_count` parameter With arguments `**kwargs`.", "question_id": 39997}
{"snippet": "Series.product(**kwargs)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39998}
{"snippet": "Series.product(**kwargs, axis=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 39999}
{"snippet": "Series.product(**kwargs, skipna=None)", "intent": "Return the product of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 40000}
{"snippet": "Series.product(**kwargs, level=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 40001}
{"snippet": "Series.product(**kwargs, numeric_only=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 40002}
{"snippet": "Series.product(**kwargs, min_count=0)", "intent": "Return the product of the values over the requested `axis` . This can be controlled with the `min_count` parameter With arguments `**kwargs`.", "question_id": 40003}
{"snippet": "Series.product(**kwargs, axis=None, skipna=None)", "intent": "Return the product of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 40004}
{"snippet": "Series.product(**kwargs, axis=None, level=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 40005}
{"snippet": "Series.product(**kwargs, axis=None, numeric_only=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 40006}
{"snippet": "Series.product(**kwargs, axis=None, min_count=0)", "intent": "Return the product of the values over the requested `axis` . This can be controlled with the `min_count` parameter With arguments `**kwargs`.", "question_id": 40007}
{"snippet": "Series.product(**kwargs)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 40008}
{"snippet": "Series.product(**kwargs, axis=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 40009}
{"snippet": "Series.product(**kwargs, skipna=None)", "intent": "Return the product of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 40010}
{"snippet": "Series.product(**kwargs, level=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 40011}
{"snippet": "Series.product(**kwargs, numeric_only=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 40012}
{"snippet": "Series.product(**kwargs, min_count=0)", "intent": "Return the product of the values over the requested `axis` . This can be controlled with the `min_count` parameter With arguments `**kwargs`.", "question_id": 40013}
{"snippet": "Series.product(**kwargs, axis=None, skipna=None)", "intent": "Return the product of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 40014}
{"snippet": "Series.product(**kwargs, axis=None, level=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 40015}
{"snippet": "Series.product(**kwargs, axis=None, numeric_only=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 40016}
{"snippet": "Series.product(**kwargs, axis=None, min_count=0)", "intent": "Return the product of the values over the requested `axis` . This can be controlled with the `min_count` parameter With arguments `**kwargs`.", "question_id": 40017}
{"snippet": "Series.product(**kwargs)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 40018}
{"snippet": "Series.product(**kwargs, axis=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 40019}
{"snippet": "Series.product(**kwargs, skipna=None)", "intent": "Return the product of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 40020}
{"snippet": "Series.product(**kwargs, level=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 40021}
{"snippet": "Series.product(**kwargs, numeric_only=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 40022}
{"snippet": "Series.product(**kwargs, min_count=0)", "intent": "Return the product of the values over the requested `axis` . This can be controlled with the `min_count` parameter With arguments `**kwargs`.", "question_id": 40023}
{"snippet": "Series.product(**kwargs, axis=None, skipna=None)", "intent": "Return the product of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 40024}
{"snippet": "Series.product(**kwargs, axis=None, level=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 40025}
{"snippet": "Series.product(**kwargs, axis=None, numeric_only=None)", "intent": "Return the product of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 40026}
{"snippet": "Series.product(**kwargs, axis=None, min_count=0)", "intent": "Return the product of the values over the requested `axis` . This can be controlled with the `min_count` parameter With arguments `**kwargs`.", "question_id": 40027}
{"snippet": "Series.quantile()", "intent": "Return value at the given quantile .", "question_id": 40028}
{"snippet": "Series.quantile(q=0.5)", "intent": "Return value at the given quantile . With arguments `q`.", "question_id": 40029}
{"snippet": "Series.quantile(interpolation='linear')", "intent": "Return value at the given quantile . With arguments `interpolation`.", "question_id": 40030}
{"snippet": "Series.quantile(q=0.5, interpolation='linear')", "intent": "Return value at the given quantile . With arguments `q`, `interpolation`.", "question_id": 40031}
{"snippet": "Series.quantile()", "intent": "Return value at the given quantile .", "question_id": 40032}
{"snippet": "Series.quantile(q=0.5)", "intent": "Return value at the given quantile . With arguments `q`.", "question_id": 40033}
{"snippet": "Series.quantile(interpolation='linear')", "intent": "Return value at the given quantile . With arguments `interpolation`.", "question_id": 40034}
{"snippet": "Series.quantile(q=0.5, interpolation='linear')", "intent": "Return value at the given quantile . With arguments `q`, `interpolation`.", "question_id": 40035}
{"snippet": "Series.quantile()", "intent": "Return value at the given quantile .", "question_id": 40036}
{"snippet": "Series.quantile(q=0.5)", "intent": "Return value at the given quantile . With arguments `q`.", "question_id": 40037}
{"snippet": "Series.quantile(interpolation='linear')", "intent": "Return value at the given quantile . With arguments `interpolation`.", "question_id": 40038}
{"snippet": "Series.quantile(q=0.5, interpolation='linear')", "intent": "Return value at the given quantile . With arguments `q`, `interpolation`.", "question_id": 40039}
{"snippet": "Series.radd(other)", "intent": "Return Addition of series and `other` , element-wise ( binary operator radd ) .", "question_id": 40040}
{"snippet": "Series.radd(other, level=None)", "intent": "Return Addition of series and `other` , element-wise ( binary operator radd ) . With arguments `level`.", "question_id": 40041}
{"snippet": "Series.radd(other, fill_value=None)", "intent": "Return Addition of series and `other` , element-wise ( binary operator radd ) . Equivalent to other + series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40042}
{"snippet": "Series.radd(other, axis=0)", "intent": "Return Addition of series and `other` , element-wise ( binary operator radd ) . With arguments `axis`.", "question_id": 40043}
{"snippet": "Series.radd(other, level=None, fill_value=None)", "intent": "Return Addition of series and `other` , element-wise ( binary operator radd ) . Equivalent to other + series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40044}
{"snippet": "Series.radd(other, level=None, axis=0)", "intent": "Return Addition of series and `other` , element-wise ( binary operator radd ) . With arguments `level`, `axis`.", "question_id": 40045}
{"snippet": "Series.radd(other, fill_value=None, axis=0)", "intent": "Return Addition of series and `other` , element-wise ( binary operator radd ) . Equivalent to other + series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40046}
{"snippet": "Series.radd(other, level=None, fill_value=None, axis=0)", "intent": "Return Addition of series and `other` , element-wise ( binary operator radd ) . Equivalent to other + series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40047}
{"snippet": "Series.radd(other)", "intent": "Return Addition of series and `other` , element-wise ( binary operator radd ) .", "question_id": 40048}
{"snippet": "Series.radd(other, level=None)", "intent": "Return Addition of series and `other` , element-wise ( binary operator radd ) . With arguments `level`.", "question_id": 40049}
{"snippet": "Series.radd(other, fill_value=None)", "intent": "Return Addition of series and `other` , element-wise ( binary operator radd ) . Equivalent to other + series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40050}
{"snippet": "Series.radd(other, axis=0)", "intent": "Return Addition of series and `other` , element-wise ( binary operator radd ) . With arguments `axis`.", "question_id": 40051}
{"snippet": "Series.radd(other, level=None, fill_value=None)", "intent": "Return Addition of series and `other` , element-wise ( binary operator radd ) . Equivalent to other + series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40052}
{"snippet": "Series.radd(other, level=None, axis=0)", "intent": "Return Addition of series and `other` , element-wise ( binary operator radd ) . With arguments `level`, `axis`.", "question_id": 40053}
{"snippet": "Series.radd(other, fill_value=None, axis=0)", "intent": "Return Addition of series and `other` , element-wise ( binary operator radd ) . Equivalent to other + series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40054}
{"snippet": "Series.radd(other, level=None, fill_value=None, axis=0)", "intent": "Return Addition of series and `other` , element-wise ( binary operator radd ) . Equivalent to other + series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40055}
{"snippet": "Series.radd(other)", "intent": "Return Addition of series and `other` , element-wise ( binary operator radd ) .", "question_id": 40056}
{"snippet": "Series.radd(other, level=None)", "intent": "Return Addition of series and `other` , element-wise ( binary operator radd ) . With arguments `level`.", "question_id": 40057}
{"snippet": "Series.radd(other, fill_value=None)", "intent": "Return Addition of series and `other` , element-wise ( binary operator radd ) . Equivalent to other + series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40058}
{"snippet": "Series.radd(other, axis=0)", "intent": "Return Addition of series and `other` , element-wise ( binary operator radd ) . With arguments `axis`.", "question_id": 40059}
{"snippet": "Series.radd(other, level=None, fill_value=None)", "intent": "Return Addition of series and `other` , element-wise ( binary operator radd ) . Equivalent to other + series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40060}
{"snippet": "Series.radd(other, level=None, axis=0)", "intent": "Return Addition of series and `other` , element-wise ( binary operator radd ) . With arguments `level`, `axis`.", "question_id": 40061}
{"snippet": "Series.radd(other, fill_value=None, axis=0)", "intent": "Return Addition of series and `other` , element-wise ( binary operator radd ) . Equivalent to other + series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40062}
{"snippet": "Series.radd(other, level=None, fill_value=None, axis=0)", "intent": "Return Addition of series and `other` , element-wise ( binary operator radd ) . Equivalent to other + series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40063}
{"snippet": "Series.rank()", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` .", "question_id": 40064}
{"snippet": "Series.rank(axis=0)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` .", "question_id": 40065}
{"snippet": "Series.rank(method='average')", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . The following example shows how the `method` behaves with the above parameters :", "question_id": 40066}
{"snippet": "Series.rank(numeric_only=None)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `numeric_only`.", "question_id": 40067}
{"snippet": "Series.rank(na_option='keep')", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `na_option`.", "question_id": 40068}
{"snippet": "Series.rank(ascending=True)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `ascending`.", "question_id": 40069}
{"snippet": "Series.rank(pct=False)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `pct`.", "question_id": 40070}
{"snippet": "Series.rank(axis=0, method='average')", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . The following example shows how the `method` behaves with the above parameters :", "question_id": 40071}
{"snippet": "Series.rank(axis=0, numeric_only=None)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `numeric_only`.", "question_id": 40072}
{"snippet": "Series.rank(axis=0, na_option='keep')", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `na_option`.", "question_id": 40073}
{"snippet": "Series.rank()", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` .", "question_id": 40074}
{"snippet": "Series.rank(axis=0)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` .", "question_id": 40075}
{"snippet": "Series.rank(method='average')", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . The following example shows how the `method` behaves with the above parameters :", "question_id": 40076}
{"snippet": "Series.rank(numeric_only=None)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `numeric_only`.", "question_id": 40077}
{"snippet": "Series.rank(na_option='keep')", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `na_option`.", "question_id": 40078}
{"snippet": "Series.rank(ascending=True)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `ascending`.", "question_id": 40079}
{"snippet": "Series.rank(pct=False)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `pct`.", "question_id": 40080}
{"snippet": "Series.rank(axis=0, method='average')", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . The following example shows how the `method` behaves with the above parameters :", "question_id": 40081}
{"snippet": "Series.rank(axis=0, numeric_only=None)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `numeric_only`.", "question_id": 40082}
{"snippet": "Series.rank(axis=0, na_option='keep')", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `na_option`.", "question_id": 40083}
{"snippet": "Series.rank()", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` .", "question_id": 40084}
{"snippet": "Series.rank(axis=0)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` .", "question_id": 40085}
{"snippet": "Series.rank(method='average')", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . The following example shows how the `method` behaves with the above parameters :", "question_id": 40086}
{"snippet": "Series.rank(numeric_only=None)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `numeric_only`.", "question_id": 40087}
{"snippet": "Series.rank(na_option='keep')", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `na_option`.", "question_id": 40088}
{"snippet": "Series.rank(ascending=True)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `ascending`.", "question_id": 40089}
{"snippet": "Series.rank(pct=False)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `pct`.", "question_id": 40090}
{"snippet": "Series.rank(axis=0, method='average')", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . The following example shows how the `method` behaves with the above parameters :", "question_id": 40091}
{"snippet": "Series.rank(axis=0, numeric_only=None)", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `numeric_only`.", "question_id": 40092}
{"snippet": "Series.rank(axis=0, na_option='keep')", "intent": "Compute numerical data ranks ( 1 through n ) along `axis` . With arguments `na_option`.", "question_id": 40093}
{"snippet": "Series.ravel()", "intent": "Return the flattened underlying data as an ndarray .", "question_id": 40094}
{"snippet": "Series.ravel(order='C')", "intent": "Return the flattened underlying data as an ndarray . With arguments `order`.", "question_id": 40095}
{"snippet": "Series.ravel()", "intent": "Return the flattened underlying data as an ndarray .", "question_id": 40096}
{"snippet": "Series.ravel(order='C')", "intent": "Return the flattened underlying data as an ndarray . With arguments `order`.", "question_id": 40097}
{"snippet": "Series.ravel()", "intent": "Return the flattened underlying data as an ndarray .", "question_id": 40098}
{"snippet": "Series.ravel(order='C')", "intent": "Return the flattened underlying data as an ndarray . With arguments `order`.", "question_id": 40099}
{"snippet": "Series.rdiv(other)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) .", "question_id": 40100}
{"snippet": "Series.rdiv(other, level=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . With arguments `level`.", "question_id": 40101}
{"snippet": "Series.rdiv(other, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40102}
{"snippet": "Series.rdiv(other, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . With arguments `axis`.", "question_id": 40103}
{"snippet": "Series.rdiv(other, level=None, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40104}
{"snippet": "Series.rdiv(other, level=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . With arguments `level`, `axis`.", "question_id": 40105}
{"snippet": "Series.rdiv(other, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40106}
{"snippet": "Series.rdiv(other, level=None, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40107}
{"snippet": "Series.rdiv(other)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) .", "question_id": 40108}
{"snippet": "Series.rdiv(other, level=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . With arguments `level`.", "question_id": 40109}
{"snippet": "Series.rdiv(other, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40110}
{"snippet": "Series.rdiv(other, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . With arguments `axis`.", "question_id": 40111}
{"snippet": "Series.rdiv(other, level=None, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40112}
{"snippet": "Series.rdiv(other, level=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . With arguments `level`, `axis`.", "question_id": 40113}
{"snippet": "Series.rdiv(other, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40114}
{"snippet": "Series.rdiv(other, level=None, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40115}
{"snippet": "Series.rdiv(other)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) .", "question_id": 40116}
{"snippet": "Series.rdiv(other, level=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . With arguments `level`.", "question_id": 40117}
{"snippet": "Series.rdiv(other, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40118}
{"snippet": "Series.rdiv(other, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . With arguments `axis`.", "question_id": 40119}
{"snippet": "Series.rdiv(other, level=None, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40120}
{"snippet": "Series.rdiv(other, level=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . With arguments `level`, `axis`.", "question_id": 40121}
{"snippet": "Series.rdiv(other, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40122}
{"snippet": "Series.rdiv(other, level=None, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40123}
{"snippet": "Series.rdivmod(other)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator rdivmod ) .", "question_id": 40124}
{"snippet": "Series.rdivmod(other, level=None)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator rdivmod ) . With arguments `level`.", "question_id": 40125}
{"snippet": "Series.rdivmod(other, fill_value=None)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator rdivmod ) . Equivalent to other divmod series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40126}
{"snippet": "Series.rdivmod(other, axis=0)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator rdivmod ) . With arguments `axis`.", "question_id": 40127}
{"snippet": "Series.rdivmod(other, level=None, fill_value=None)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator rdivmod ) . Equivalent to other divmod series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40128}
{"snippet": "Series.rdivmod(other, level=None, axis=0)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator rdivmod ) . With arguments `level`, `axis`.", "question_id": 40129}
{"snippet": "Series.rdivmod(other, fill_value=None, axis=0)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator rdivmod ) . Equivalent to other divmod series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40130}
{"snippet": "Series.rdivmod(other, level=None, fill_value=None, axis=0)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator rdivmod ) . Equivalent to other divmod series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40131}
{"snippet": "Series.rdivmod(other)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator rdivmod ) .", "question_id": 40132}
{"snippet": "Series.rdivmod(other, level=None)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator rdivmod ) . With arguments `level`.", "question_id": 40133}
{"snippet": "Series.rdivmod(other, fill_value=None)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator rdivmod ) . Equivalent to other divmod series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40134}
{"snippet": "Series.rdivmod(other, axis=0)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator rdivmod ) . With arguments `axis`.", "question_id": 40135}
{"snippet": "Series.rdivmod(other, level=None, fill_value=None)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator rdivmod ) . Equivalent to other divmod series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40136}
{"snippet": "Series.rdivmod(other, level=None, axis=0)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator rdivmod ) . With arguments `level`, `axis`.", "question_id": 40137}
{"snippet": "Series.rdivmod(other, fill_value=None, axis=0)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator rdivmod ) . Equivalent to other divmod series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40138}
{"snippet": "Series.rdivmod(other, level=None, fill_value=None, axis=0)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator rdivmod ) . Equivalent to other divmod series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40139}
{"snippet": "Series.rdivmod(other)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator rdivmod ) .", "question_id": 40140}
{"snippet": "Series.rdivmod(other, level=None)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator rdivmod ) . With arguments `level`.", "question_id": 40141}
{"snippet": "Series.rdivmod(other, fill_value=None)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator rdivmod ) . Equivalent to other divmod series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40142}
{"snippet": "Series.rdivmod(other, axis=0)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator rdivmod ) . With arguments `axis`.", "question_id": 40143}
{"snippet": "Series.rdivmod(other, level=None, fill_value=None)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator rdivmod ) . Equivalent to other divmod series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40144}
{"snippet": "Series.rdivmod(other, level=None, axis=0)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator rdivmod ) . With arguments `level`, `axis`.", "question_id": 40145}
{"snippet": "Series.rdivmod(other, fill_value=None, axis=0)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator rdivmod ) . Equivalent to other divmod series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40146}
{"snippet": "Series.rdivmod(other, level=None, fill_value=None, axis=0)", "intent": "Return Integer division and modulo of series and `other` , element-wise ( binary operator rdivmod ) . Equivalent to other divmod series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40147}
{"snippet": "Series.reindex(**kwargs)", "intent": "Conform Series to new `index` with optional filling logic . With arguments `**kwargs`.", "question_id": 40148}
{"snippet": "Series.reindex(**kwargs, index=None)", "intent": "Conform Series to new `index` with optional filling logic . With arguments `**kwargs`.", "question_id": 40149}
{"snippet": "Series.reindex(**kwargs)", "intent": "Conform Series to new `index` with optional filling logic . With arguments `**kwargs`.", "question_id": 40150}
{"snippet": "Series.reindex(**kwargs, index=None)", "intent": "Conform Series to new `index` with optional filling logic . With arguments `**kwargs`.", "question_id": 40151}
{"snippet": "Series.reindex(**kwargs)", "intent": "Conform Series to new `index` with optional filling logic . With arguments `**kwargs`.", "question_id": 40152}
{"snippet": "Series.reindex(**kwargs, index=None)", "intent": "Conform Series to new `index` with optional filling logic . With arguments `**kwargs`.", "question_id": 40153}
{"snippet": "Series.reindex_like(other)", "intent": "Return an object with matching indices as `other` object .", "question_id": 40154}
{"snippet": "Series.reindex_like(other, method=None)", "intent": "Return an object with matching indices as `other` object . With arguments `method`.", "question_id": 40155}
{"snippet": "Series.reindex_like(other, copy=True)", "intent": "Return an object with matching indices as `other` object . With arguments `copy`.", "question_id": 40156}
{"snippet": "Series.reindex_like(other, limit=None)", "intent": "Return an object with matching indices as `other` object . With arguments `limit`.", "question_id": 40157}
{"snippet": "Series.reindex_like(other, tolerance=None)", "intent": "Return an object with matching indices as `other` object . With arguments `tolerance`.", "question_id": 40158}
{"snippet": "Series.reindex_like(other, method=None, copy=True)", "intent": "Return an object with matching indices as `other` object . With arguments `method`, `copy`.", "question_id": 40159}
{"snippet": "Series.reindex_like(other, method=None, limit=None)", "intent": "Return an object with matching indices as `other` object . With arguments `method`, `limit`.", "question_id": 40160}
{"snippet": "Series.reindex_like(other, method=None, tolerance=None)", "intent": "Return an object with matching indices as `other` object . With arguments `method`, `tolerance`.", "question_id": 40161}
{"snippet": "Series.reindex_like(other, copy=True, limit=None)", "intent": "Return an object with matching indices as `other` object . With arguments `copy`, `limit`.", "question_id": 40162}
{"snippet": "Series.reindex_like(other, copy=True, tolerance=None)", "intent": "Return an object with matching indices as `other` object . With arguments `copy`, `tolerance`.", "question_id": 40163}
{"snippet": "Series.reindex_like(other)", "intent": "Return an object with matching indices as `other` object .", "question_id": 40164}
{"snippet": "Series.reindex_like(other, method=None)", "intent": "Return an object with matching indices as `other` object . With arguments `method`.", "question_id": 40165}
{"snippet": "Series.reindex_like(other, copy=True)", "intent": "Return an object with matching indices as `other` object . With arguments `copy`.", "question_id": 40166}
{"snippet": "Series.reindex_like(other, limit=None)", "intent": "Return an object with matching indices as `other` object . With arguments `limit`.", "question_id": 40167}
{"snippet": "Series.reindex_like(other, tolerance=None)", "intent": "Return an object with matching indices as `other` object . With arguments `tolerance`.", "question_id": 40168}
{"snippet": "Series.reindex_like(other, method=None, copy=True)", "intent": "Return an object with matching indices as `other` object . With arguments `method`, `copy`.", "question_id": 40169}
{"snippet": "Series.reindex_like(other, method=None, limit=None)", "intent": "Return an object with matching indices as `other` object . With arguments `method`, `limit`.", "question_id": 40170}
{"snippet": "Series.reindex_like(other, method=None, tolerance=None)", "intent": "Return an object with matching indices as `other` object . With arguments `method`, `tolerance`.", "question_id": 40171}
{"snippet": "Series.reindex_like(other, copy=True, limit=None)", "intent": "Return an object with matching indices as `other` object . With arguments `copy`, `limit`.", "question_id": 40172}
{"snippet": "Series.reindex_like(other, copy=True, tolerance=None)", "intent": "Return an object with matching indices as `other` object . With arguments `copy`, `tolerance`.", "question_id": 40173}
{"snippet": "Series.reindex_like(other)", "intent": "Return an object with matching indices as `other` object .", "question_id": 40174}
{"snippet": "Series.reindex_like(other, method=None)", "intent": "Return an object with matching indices as `other` object . With arguments `method`.", "question_id": 40175}
{"snippet": "Series.reindex_like(other, copy=True)", "intent": "Return an object with matching indices as `other` object . With arguments `copy`.", "question_id": 40176}
{"snippet": "Series.reindex_like(other, limit=None)", "intent": "Return an object with matching indices as `other` object . With arguments `limit`.", "question_id": 40177}
{"snippet": "Series.reindex_like(other, tolerance=None)", "intent": "Return an object with matching indices as `other` object . With arguments `tolerance`.", "question_id": 40178}
{"snippet": "Series.reindex_like(other, method=None, copy=True)", "intent": "Return an object with matching indices as `other` object . With arguments `method`, `copy`.", "question_id": 40179}
{"snippet": "Series.reindex_like(other, method=None, limit=None)", "intent": "Return an object with matching indices as `other` object . With arguments `method`, `limit`.", "question_id": 40180}
{"snippet": "Series.reindex_like(other, method=None, tolerance=None)", "intent": "Return an object with matching indices as `other` object . With arguments `method`, `tolerance`.", "question_id": 40181}
{"snippet": "Series.reindex_like(other, copy=True, limit=None)", "intent": "Return an object with matching indices as `other` object . With arguments `copy`, `limit`.", "question_id": 40182}
{"snippet": "Series.reindex_like(other, copy=True, tolerance=None)", "intent": "Return an object with matching indices as `other` object . With arguments `copy`, `tolerance`.", "question_id": 40183}
{"snippet": "Series.rename()", "intent": "Alter Series `index` labels or name .", "question_id": 40184}
{"snippet": "Series.rename(index=None)", "intent": "Alter Series `index` labels or name .", "question_id": 40185}
{"snippet": "Series.rename(axis=None)", "intent": "Alter Series `index` labels or name . With arguments `axis`.", "question_id": 40186}
{"snippet": "Series.rename(copy=True)", "intent": "Alter Series `index` labels or name . With arguments `copy`.", "question_id": 40187}
{"snippet": "Series.rename(inplace=False)", "intent": "Alter Series `index` labels or name . With arguments `inplace`.", "question_id": 40188}
{"snippet": "Series.rename(level=None)", "intent": "Alter Series `index` labels or name . With arguments `level`.", "question_id": 40189}
{"snippet": "Series.rename(errors='ignore')", "intent": "Alter Series `index` labels or name . With arguments `errors`.", "question_id": 40190}
{"snippet": "Series.rename(index=None, axis=None)", "intent": "Alter Series `index` labels or name . With arguments `axis`.", "question_id": 40191}
{"snippet": "Series.rename(index=None, copy=True)", "intent": "Alter Series `index` labels or name . With arguments `copy`.", "question_id": 40192}
{"snippet": "Series.rename(index=None, inplace=False)", "intent": "Alter Series `index` labels or name . With arguments `inplace`.", "question_id": 40193}
{"snippet": "Series.rename()", "intent": "Alter Series `index` labels or name .", "question_id": 40194}
{"snippet": "Series.rename(index=None)", "intent": "Alter Series `index` labels or name .", "question_id": 40195}
{"snippet": "Series.rename(axis=None)", "intent": "Alter Series `index` labels or name . With arguments `axis`.", "question_id": 40196}
{"snippet": "Series.rename(copy=True)", "intent": "Alter Series `index` labels or name . With arguments `copy`.", "question_id": 40197}
{"snippet": "Series.rename(inplace=False)", "intent": "Alter Series `index` labels or name . With arguments `inplace`.", "question_id": 40198}
{"snippet": "Series.rename(level=None)", "intent": "Alter Series `index` labels or name . With arguments `level`.", "question_id": 40199}
{"snippet": "Series.rename(errors='ignore')", "intent": "Alter Series `index` labels or name . With arguments `errors`.", "question_id": 40200}
{"snippet": "Series.rename(index=None, axis=None)", "intent": "Alter Series `index` labels or name . With arguments `axis`.", "question_id": 40201}
{"snippet": "Series.rename(index=None, copy=True)", "intent": "Alter Series `index` labels or name . With arguments `copy`.", "question_id": 40202}
{"snippet": "Series.rename(index=None, inplace=False)", "intent": "Alter Series `index` labels or name . With arguments `inplace`.", "question_id": 40203}
{"snippet": "Series.rename()", "intent": "Alter Series `index` labels or name .", "question_id": 40204}
{"snippet": "Series.rename(index=None)", "intent": "Alter Series `index` labels or name .", "question_id": 40205}
{"snippet": "Series.rename(axis=None)", "intent": "Alter Series `index` labels or name . With arguments `axis`.", "question_id": 40206}
{"snippet": "Series.rename(copy=True)", "intent": "Alter Series `index` labels or name . With arguments `copy`.", "question_id": 40207}
{"snippet": "Series.rename(inplace=False)", "intent": "Alter Series `index` labels or name . With arguments `inplace`.", "question_id": 40208}
{"snippet": "Series.rename(level=None)", "intent": "Alter Series `index` labels or name . With arguments `level`.", "question_id": 40209}
{"snippet": "Series.rename(errors='ignore')", "intent": "Alter Series `index` labels or name . With arguments `errors`.", "question_id": 40210}
{"snippet": "Series.rename(index=None, axis=None)", "intent": "Alter Series `index` labels or name . With arguments `axis`.", "question_id": 40211}
{"snippet": "Series.rename(index=None, copy=True)", "intent": "Alter Series `index` labels or name . With arguments `copy`.", "question_id": 40212}
{"snippet": "Series.rename(index=None, inplace=False)", "intent": "Alter Series `index` labels or name . With arguments `inplace`.", "question_id": 40213}
{"snippet": "Series.rename_axis()", "intent": "Set the name of the `axis` for the `index` or `columns` .", "question_id": 40214}
{"snippet": "Series.rename_axis(mapper=None)", "intent": "Set the name of the `axis` for the `index` or `columns` . The second calling convention will modify the names of the corresponding index if `mapper` is a list or a scalar .", "question_id": 40215}
{"snippet": "Series.rename_axis(index=None)", "intent": "Set the name of the `axis` for the `index` or `columns` .", "question_id": 40216}
{"snippet": "Series.rename_axis(columns=None)", "intent": "Set the name of the `axis` for the `index` or `columns` .", "question_id": 40217}
{"snippet": "Series.rename_axis(axis=None)", "intent": "Set the name of the `axis` for the `index` or `columns` .", "question_id": 40218}
{"snippet": "Series.rename_axis(copy=True)", "intent": "Set the name of the `axis` for the `index` or `columns` . In this case , the parameter `copy` is ignored .", "question_id": 40219}
{"snippet": "Series.rename_axis(inplace=False)", "intent": "Set the name of the `axis` for the `index` or `columns` . With arguments `inplace`.", "question_id": 40220}
{"snippet": "Series.rename_axis(mapper=None, index=None)", "intent": "Set the name of the `axis` for the `index` or `columns` . The second calling convention will modify the names of the corresponding index if `mapper` is a list or a scalar .", "question_id": 40221}
{"snippet": "Series.rename_axis(mapper=None, columns=None)", "intent": "Set the name of the `axis` for the `index` or `columns` . The second calling convention will modify the names of the corresponding index if `mapper` is a list or a scalar .", "question_id": 40222}
{"snippet": "Series.rename_axis(mapper=None, axis=None)", "intent": "Set the name of the `axis` for the `index` or `columns` . The second calling convention will modify the names of the corresponding index if `mapper` is a list or a scalar .", "question_id": 40223}
{"snippet": "Series.rename_axis()", "intent": "Set the name of the `axis` for the `index` or `columns` .", "question_id": 40224}
{"snippet": "Series.rename_axis(mapper=None)", "intent": "Set the name of the `axis` for the `index` or `columns` . The second calling convention will modify the names of the corresponding index if `mapper` is a list or a scalar .", "question_id": 40225}
{"snippet": "Series.rename_axis(index=None)", "intent": "Set the name of the `axis` for the `index` or `columns` .", "question_id": 40226}
{"snippet": "Series.rename_axis(columns=None)", "intent": "Set the name of the `axis` for the `index` or `columns` .", "question_id": 40227}
{"snippet": "Series.rename_axis(axis=None)", "intent": "Set the name of the `axis` for the `index` or `columns` .", "question_id": 40228}
{"snippet": "Series.rename_axis(copy=True)", "intent": "Set the name of the `axis` for the `index` or `columns` . In this case , the parameter `copy` is ignored .", "question_id": 40229}
{"snippet": "Series.rename_axis(inplace=False)", "intent": "Set the name of the `axis` for the `index` or `columns` . With arguments `inplace`.", "question_id": 40230}
{"snippet": "Series.rename_axis(mapper=None, index=None)", "intent": "Set the name of the `axis` for the `index` or `columns` . The second calling convention will modify the names of the corresponding index if `mapper` is a list or a scalar .", "question_id": 40231}
{"snippet": "Series.rename_axis(mapper=None, columns=None)", "intent": "Set the name of the `axis` for the `index` or `columns` . The second calling convention will modify the names of the corresponding index if `mapper` is a list or a scalar .", "question_id": 40232}
{"snippet": "Series.rename_axis(mapper=None, axis=None)", "intent": "Set the name of the `axis` for the `index` or `columns` . The second calling convention will modify the names of the corresponding index if `mapper` is a list or a scalar .", "question_id": 40233}
{"snippet": "Series.rename_axis()", "intent": "Set the name of the `axis` for the `index` or `columns` .", "question_id": 40234}
{"snippet": "Series.rename_axis(mapper=None)", "intent": "Set the name of the `axis` for the `index` or `columns` . The second calling convention will modify the names of the corresponding index if `mapper` is a list or a scalar .", "question_id": 40235}
{"snippet": "Series.rename_axis(index=None)", "intent": "Set the name of the `axis` for the `index` or `columns` .", "question_id": 40236}
{"snippet": "Series.rename_axis(columns=None)", "intent": "Set the name of the `axis` for the `index` or `columns` .", "question_id": 40237}
{"snippet": "Series.rename_axis(axis=None)", "intent": "Set the name of the `axis` for the `index` or `columns` .", "question_id": 40238}
{"snippet": "Series.rename_axis(copy=True)", "intent": "Set the name of the `axis` for the `index` or `columns` . In this case , the parameter `copy` is ignored .", "question_id": 40239}
{"snippet": "Series.rename_axis(inplace=False)", "intent": "Set the name of the `axis` for the `index` or `columns` . With arguments `inplace`.", "question_id": 40240}
{"snippet": "Series.rename_axis(mapper=None, index=None)", "intent": "Set the name of the `axis` for the `index` or `columns` . The second calling convention will modify the names of the corresponding index if `mapper` is a list or a scalar .", "question_id": 40241}
{"snippet": "Series.rename_axis(mapper=None, columns=None)", "intent": "Set the name of the `axis` for the `index` or `columns` . The second calling convention will modify the names of the corresponding index if `mapper` is a list or a scalar .", "question_id": 40242}
{"snippet": "Series.rename_axis(mapper=None, axis=None)", "intent": "Set the name of the `axis` for the `index` or `columns` . The second calling convention will modify the names of the corresponding index if `mapper` is a list or a scalar .", "question_id": 40243}
{"snippet": "Series.reorder_levels(order)", "intent": "Rearrange index levels using input `order` .", "question_id": 40244}
{"snippet": "Series.reorder_levels(order)", "intent": "Rearrange index levels using input `order` .", "question_id": 40245}
{"snippet": "Series.reorder_levels(order)", "intent": "Rearrange index levels using input `order` .", "question_id": 40246}
{"snippet": "Series.repeat(repeats)", "intent": "Repeat elements of a Series . With arguments `repeats`.", "question_id": 40247}
{"snippet": "Series.repeat(repeats, axis=None)", "intent": "Repeat elements of a Series . With arguments `repeats`, `axis`.", "question_id": 40248}
{"snippet": "Series.repeat(repeats)", "intent": "Repeat elements of a Series . With arguments `repeats`.", "question_id": 40249}
{"snippet": "Series.repeat(repeats, axis=None)", "intent": "Repeat elements of a Series . With arguments `repeats`, `axis`.", "question_id": 40250}
{"snippet": "Series.repeat(repeats)", "intent": "Repeat elements of a Series . With arguments `repeats`.", "question_id": 40251}
{"snippet": "Series.repeat(repeats, axis=None)", "intent": "Repeat elements of a Series . With arguments `repeats`, `axis`.", "question_id": 40252}
{"snippet": "Series.replace()", "intent": "Replace values given in `to_replace` with `value` .", "question_id": 40253}
{"snippet": "Series.replace(to_replace=None)", "intent": "Replace values given in `to_replace` with `value` .", "question_id": 40254}
{"snippet": "Series.replace(value=None)", "intent": "Replace values given in `to_replace` with `value` .", "question_id": 40255}
{"snippet": "Series.replace(inplace=False)", "intent": "Replace values given in `to_replace` with `value` . With arguments `inplace`.", "question_id": 40256}
{"snippet": "Series.replace(limit=None)", "intent": "Replace values given in `to_replace` with `value` . With arguments `limit`.", "question_id": 40257}
{"snippet": "Series.replace(regex=False)", "intent": "Replace values given in `to_replace` with `value` . With arguments `regex`.", "question_id": 40258}
{"snippet": "Series.replace(method='pad')", "intent": "Replace values given in `to_replace` with `value` . When value=None and to_replace is a scalar , list or tuple , replace uses the `method` parameter ( default \u2018 pad \u2019 ) to do the replacement .", "question_id": 40259}
{"snippet": "Series.replace(to_replace=None, value=None)", "intent": "Replace values given in `to_replace` with `value` .", "question_id": 40260}
{"snippet": "Series.replace(to_replace=None, inplace=False)", "intent": "Replace values given in `to_replace` with `value` . With arguments `inplace`.", "question_id": 40261}
{"snippet": "Series.replace(to_replace=None, limit=None)", "intent": "Replace values given in `to_replace` with `value` . With arguments `limit`.", "question_id": 40262}
{"snippet": "Series.replace()", "intent": "Replace values given in `to_replace` with `value` .", "question_id": 40263}
{"snippet": "Series.replace(to_replace=None)", "intent": "Replace values given in `to_replace` with `value` .", "question_id": 40264}
{"snippet": "Series.replace(value=None)", "intent": "Replace values given in `to_replace` with `value` .", "question_id": 40265}
{"snippet": "Series.replace(inplace=False)", "intent": "Replace values given in `to_replace` with `value` . With arguments `inplace`.", "question_id": 40266}
{"snippet": "Series.replace(limit=None)", "intent": "Replace values given in `to_replace` with `value` . With arguments `limit`.", "question_id": 40267}
{"snippet": "Series.replace(regex=False)", "intent": "Replace values given in `to_replace` with `value` . With arguments `regex`.", "question_id": 40268}
{"snippet": "Series.replace(method='pad')", "intent": "Replace values given in `to_replace` with `value` . When value=None and to_replace is a scalar , list or tuple , replace uses the `method` parameter ( default \u2018 pad \u2019 ) to do the replacement .", "question_id": 40269}
{"snippet": "Series.replace(to_replace=None, value=None)", "intent": "Replace values given in `to_replace` with `value` .", "question_id": 40270}
{"snippet": "Series.replace(to_replace=None, inplace=False)", "intent": "Replace values given in `to_replace` with `value` . With arguments `inplace`.", "question_id": 40271}
{"snippet": "Series.replace(to_replace=None, limit=None)", "intent": "Replace values given in `to_replace` with `value` . With arguments `limit`.", "question_id": 40272}
{"snippet": "Series.replace()", "intent": "Replace values given in `to_replace` with `value` .", "question_id": 40273}
{"snippet": "Series.replace(to_replace=None)", "intent": "Replace values given in `to_replace` with `value` .", "question_id": 40274}
{"snippet": "Series.replace(value=None)", "intent": "Replace values given in `to_replace` with `value` .", "question_id": 40275}
{"snippet": "Series.replace(inplace=False)", "intent": "Replace values given in `to_replace` with `value` . With arguments `inplace`.", "question_id": 40276}
{"snippet": "Series.replace(limit=None)", "intent": "Replace values given in `to_replace` with `value` . With arguments `limit`.", "question_id": 40277}
{"snippet": "Series.replace(regex=False)", "intent": "Replace values given in `to_replace` with `value` . With arguments `regex`.", "question_id": 40278}
{"snippet": "Series.replace(method='pad')", "intent": "Replace values given in `to_replace` with `value` . When value=None and to_replace is a scalar , list or tuple , replace uses the `method` parameter ( default \u2018 pad \u2019 ) to do the replacement .", "question_id": 40279}
{"snippet": "Series.replace(to_replace=None, value=None)", "intent": "Replace values given in `to_replace` with `value` .", "question_id": 40280}
{"snippet": "Series.replace(to_replace=None, inplace=False)", "intent": "Replace values given in `to_replace` with `value` . With arguments `inplace`.", "question_id": 40281}
{"snippet": "Series.replace(to_replace=None, limit=None)", "intent": "Replace values given in `to_replace` with `value` . With arguments `limit`.", "question_id": 40282}
{"snippet": "Series.resample(rule)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` .", "question_id": 40283}
{"snippet": "Series.resample(rule, axis=0)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . With arguments `axis`.", "question_id": 40284}
{"snippet": "Series.resample(rule, closed=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . With arguments `closed`.", "question_id": 40285}
{"snippet": "Series.resample(rule, label=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . The object must have a datetime-like index ( DatetimeIndex , PeriodIndex , or TimedeltaIndex ) , or the caller must pass the `label` of a datetime-like series/index to the on/level keyword parameter .", "question_id": 40286}
{"snippet": "Series.resample(rule, convention='start')", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` .", "question_id": 40287}
{"snippet": "Series.resample(rule, kind=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . With arguments `kind`.", "question_id": 40288}
{"snippet": "Series.resample(rule, loffset=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . To replace the use of the deprecated `loffset` argument :", "question_id": 40289}
{"snippet": "Series.resample(rule, base=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . To replace the use of the deprecated `base` argument , you can now use offset , in this example it is equivalent to have base=2 :", "question_id": 40290}
{"snippet": "Series.resample(rule, on=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . For DataFrame objects , the keyword `on` can be used to specify the column instead of the index for resampling .", "question_id": 40291}
{"snippet": "Series.resample(rule, level=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . For a DataFrame with MultiIndex , the keyword `level` can be used to specify on which level the resampling needs to take place .", "question_id": 40292}
{"snippet": "Series.resample(rule)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` .", "question_id": 40293}
{"snippet": "Series.resample(rule, axis=0)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . With arguments `axis`.", "question_id": 40294}
{"snippet": "Series.resample(rule, closed=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . With arguments `closed`.", "question_id": 40295}
{"snippet": "Series.resample(rule, label=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . The object must have a datetime-like index ( DatetimeIndex , PeriodIndex , or TimedeltaIndex ) , or the caller must pass the `label` of a datetime-like series/index to the on/level keyword parameter .", "question_id": 40296}
{"snippet": "Series.resample(rule, convention='start')", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` .", "question_id": 40297}
{"snippet": "Series.resample(rule, kind=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . With arguments `kind`.", "question_id": 40298}
{"snippet": "Series.resample(rule, loffset=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . To replace the use of the deprecated `loffset` argument :", "question_id": 40299}
{"snippet": "Series.resample(rule, base=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . To replace the use of the deprecated `base` argument , you can now use offset , in this example it is equivalent to have base=2 :", "question_id": 40300}
{"snippet": "Series.resample(rule, on=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . For DataFrame objects , the keyword `on` can be used to specify the column instead of the index for resampling .", "question_id": 40301}
{"snippet": "Series.resample(rule, level=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . For a DataFrame with MultiIndex , the keyword `level` can be used to specify on which level the resampling needs to take place .", "question_id": 40302}
{"snippet": "Series.resample(rule)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` .", "question_id": 40303}
{"snippet": "Series.resample(rule, axis=0)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . With arguments `axis`.", "question_id": 40304}
{"snippet": "Series.resample(rule, closed=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . With arguments `closed`.", "question_id": 40305}
{"snippet": "Series.resample(rule, label=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . The object must have a datetime-like index ( DatetimeIndex , PeriodIndex , or TimedeltaIndex ) , or the caller must pass the `label` of a datetime-like series/index to the on/level keyword parameter .", "question_id": 40306}
{"snippet": "Series.resample(rule, convention='start')", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` .", "question_id": 40307}
{"snippet": "Series.resample(rule, kind=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . With arguments `kind`.", "question_id": 40308}
{"snippet": "Series.resample(rule, loffset=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . To replace the use of the deprecated `loffset` argument :", "question_id": 40309}
{"snippet": "Series.resample(rule, base=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . To replace the use of the deprecated `base` argument , you can now use offset , in this example it is equivalent to have base=2 :", "question_id": 40310}
{"snippet": "Series.resample(rule, on=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . For DataFrame objects , the keyword `on` can be used to specify the column instead of the index for resampling .", "question_id": 40311}
{"snippet": "Series.resample(rule, level=None)", "intent": "Resample time-series data . For a Series with a PeriodIndex , the keyword `convention` can be used to control whether to use the start or end of `rule` . For a DataFrame with MultiIndex , the keyword `level` can be used to specify on which level the resampling needs to take place .", "question_id": 40312}
{"snippet": "Series.reset_index()", "intent": "Generate a new DataFrame or Series with the index reset .", "question_id": 40313}
{"snippet": "Series.reset_index(level=None)", "intent": "Generate a new DataFrame or Series with the index reset . The `level` parameter is interesting for Series with a multi-level index .", "question_id": 40314}
{"snippet": "Series.reset_index(drop=False)", "intent": "Generate a new DataFrame or Series with the index reset . To generate a new Series with the default set `drop` to True .", "question_id": 40315}
{"snippet": "Series.reset_index(name=None)", "intent": "Generate a new DataFrame or Series with the index reset . To specify the `name` of the new column use name .", "question_id": 40316}
{"snippet": "Series.reset_index(inplace=False)", "intent": "Generate a new DataFrame or Series with the index reset . To update the Series in place , without generating a new one set `inplace` to True .", "question_id": 40317}
{"snippet": "Series.reset_index(level=None, drop=False)", "intent": "Generate a new DataFrame or Series with the index reset . The `level` parameter is interesting for Series with a multi-level index . To generate a new Series with the default set `drop` to True .", "question_id": 40318}
{"snippet": "Series.reset_index(level=None, name=None)", "intent": "Generate a new DataFrame or Series with the index reset . The `level` parameter is interesting for Series with a multi-level index . To specify the `name` of the new column use name .", "question_id": 40319}
{"snippet": "Series.reset_index(level=None, inplace=False)", "intent": "Generate a new DataFrame or Series with the index reset . The `level` parameter is interesting for Series with a multi-level index . To update the Series in place , without generating a new one set `inplace` to True .", "question_id": 40320}
{"snippet": "Series.reset_index(drop=False, name=None)", "intent": "Generate a new DataFrame or Series with the index reset . To generate a new Series with the default set `drop` to True . To specify the `name` of the new column use name .", "question_id": 40321}
{"snippet": "Series.reset_index(drop=False, inplace=False)", "intent": "Generate a new DataFrame or Series with the index reset . To generate a new Series with the default set `drop` to True . To update the Series in place , without generating a new one set `inplace` to True .", "question_id": 40322}
{"snippet": "Series.reset_index()", "intent": "Generate a new DataFrame or Series with the index reset .", "question_id": 40323}
{"snippet": "Series.reset_index(level=None)", "intent": "Generate a new DataFrame or Series with the index reset . The `level` parameter is interesting for Series with a multi-level index .", "question_id": 40324}
{"snippet": "Series.reset_index(drop=False)", "intent": "Generate a new DataFrame or Series with the index reset . To generate a new Series with the default set `drop` to True .", "question_id": 40325}
{"snippet": "Series.reset_index(name=None)", "intent": "Generate a new DataFrame or Series with the index reset . To specify the `name` of the new column use name .", "question_id": 40326}
{"snippet": "Series.reset_index(inplace=False)", "intent": "Generate a new DataFrame or Series with the index reset . To update the Series in place , without generating a new one set `inplace` to True .", "question_id": 40327}
{"snippet": "Series.reset_index(level=None, drop=False)", "intent": "Generate a new DataFrame or Series with the index reset . The `level` parameter is interesting for Series with a multi-level index . To generate a new Series with the default set `drop` to True .", "question_id": 40328}
{"snippet": "Series.reset_index(level=None, name=None)", "intent": "Generate a new DataFrame or Series with the index reset . The `level` parameter is interesting for Series with a multi-level index . To specify the `name` of the new column use name .", "question_id": 40329}
{"snippet": "Series.reset_index(level=None, inplace=False)", "intent": "Generate a new DataFrame or Series with the index reset . The `level` parameter is interesting for Series with a multi-level index . To update the Series in place , without generating a new one set `inplace` to True .", "question_id": 40330}
{"snippet": "Series.reset_index(drop=False, name=None)", "intent": "Generate a new DataFrame or Series with the index reset . To generate a new Series with the default set `drop` to True . To specify the `name` of the new column use name .", "question_id": 40331}
{"snippet": "Series.reset_index(drop=False, inplace=False)", "intent": "Generate a new DataFrame or Series with the index reset . To generate a new Series with the default set `drop` to True . To update the Series in place , without generating a new one set `inplace` to True .", "question_id": 40332}
{"snippet": "Series.reset_index()", "intent": "Generate a new DataFrame or Series with the index reset .", "question_id": 40333}
{"snippet": "Series.reset_index(level=None)", "intent": "Generate a new DataFrame or Series with the index reset . The `level` parameter is interesting for Series with a multi-level index .", "question_id": 40334}
{"snippet": "Series.reset_index(drop=False)", "intent": "Generate a new DataFrame or Series with the index reset . To generate a new Series with the default set `drop` to True .", "question_id": 40335}
{"snippet": "Series.reset_index(name=None)", "intent": "Generate a new DataFrame or Series with the index reset . To specify the `name` of the new column use name .", "question_id": 40336}
{"snippet": "Series.reset_index(inplace=False)", "intent": "Generate a new DataFrame or Series with the index reset . To update the Series in place , without generating a new one set `inplace` to True .", "question_id": 40337}
{"snippet": "Series.reset_index(level=None, drop=False)", "intent": "Generate a new DataFrame or Series with the index reset . The `level` parameter is interesting for Series with a multi-level index . To generate a new Series with the default set `drop` to True .", "question_id": 40338}
{"snippet": "Series.reset_index(level=None, name=None)", "intent": "Generate a new DataFrame or Series with the index reset . The `level` parameter is interesting for Series with a multi-level index . To specify the `name` of the new column use name .", "question_id": 40339}
{"snippet": "Series.reset_index(level=None, inplace=False)", "intent": "Generate a new DataFrame or Series with the index reset . The `level` parameter is interesting for Series with a multi-level index . To update the Series in place , without generating a new one set `inplace` to True .", "question_id": 40340}
{"snippet": "Series.reset_index(drop=False, name=None)", "intent": "Generate a new DataFrame or Series with the index reset . To generate a new Series with the default set `drop` to True . To specify the `name` of the new column use name .", "question_id": 40341}
{"snippet": "Series.reset_index(drop=False, inplace=False)", "intent": "Generate a new DataFrame or Series with the index reset . To generate a new Series with the default set `drop` to True . To update the Series in place , without generating a new one set `inplace` to True .", "question_id": 40342}
{"snippet": "Series.rfloordiv(other)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator rfloordiv ) .", "question_id": 40343}
{"snippet": "Series.rfloordiv(other, level=None)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator rfloordiv ) . With arguments `level`.", "question_id": 40344}
{"snippet": "Series.rfloordiv(other, fill_value=None)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator rfloordiv ) . Equivalent to other // series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40345}
{"snippet": "Series.rfloordiv(other, axis=0)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator rfloordiv ) . With arguments `axis`.", "question_id": 40346}
{"snippet": "Series.rfloordiv(other, level=None, fill_value=None)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator rfloordiv ) . Equivalent to other // series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40347}
{"snippet": "Series.rfloordiv(other, level=None, axis=0)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator rfloordiv ) . With arguments `level`, `axis`.", "question_id": 40348}
{"snippet": "Series.rfloordiv(other, fill_value=None, axis=0)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator rfloordiv ) . Equivalent to other // series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40349}
{"snippet": "Series.rfloordiv(other, level=None, fill_value=None, axis=0)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator rfloordiv ) . Equivalent to other // series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40350}
{"snippet": "Series.rfloordiv(other)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator rfloordiv ) .", "question_id": 40351}
{"snippet": "Series.rfloordiv(other, level=None)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator rfloordiv ) . With arguments `level`.", "question_id": 40352}
{"snippet": "Series.rfloordiv(other, fill_value=None)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator rfloordiv ) . Equivalent to other // series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40353}
{"snippet": "Series.rfloordiv(other, axis=0)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator rfloordiv ) . With arguments `axis`.", "question_id": 40354}
{"snippet": "Series.rfloordiv(other, level=None, fill_value=None)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator rfloordiv ) . Equivalent to other // series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40355}
{"snippet": "Series.rfloordiv(other, level=None, axis=0)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator rfloordiv ) . With arguments `level`, `axis`.", "question_id": 40356}
{"snippet": "Series.rfloordiv(other, fill_value=None, axis=0)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator rfloordiv ) . Equivalent to other // series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40357}
{"snippet": "Series.rfloordiv(other, level=None, fill_value=None, axis=0)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator rfloordiv ) . Equivalent to other // series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40358}
{"snippet": "Series.rfloordiv(other)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator rfloordiv ) .", "question_id": 40359}
{"snippet": "Series.rfloordiv(other, level=None)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator rfloordiv ) . With arguments `level`.", "question_id": 40360}
{"snippet": "Series.rfloordiv(other, fill_value=None)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator rfloordiv ) . Equivalent to other // series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40361}
{"snippet": "Series.rfloordiv(other, axis=0)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator rfloordiv ) . With arguments `axis`.", "question_id": 40362}
{"snippet": "Series.rfloordiv(other, level=None, fill_value=None)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator rfloordiv ) . Equivalent to other // series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40363}
{"snippet": "Series.rfloordiv(other, level=None, axis=0)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator rfloordiv ) . With arguments `level`, `axis`.", "question_id": 40364}
{"snippet": "Series.rfloordiv(other, fill_value=None, axis=0)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator rfloordiv ) . Equivalent to other // series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40365}
{"snippet": "Series.rfloordiv(other, level=None, fill_value=None, axis=0)", "intent": "Return Integer division of series and `other` , element-wise ( binary operator rfloordiv ) . Equivalent to other // series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40366}
{"snippet": "Series.rmod(other)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator rmod ) .", "question_id": 40367}
{"snippet": "Series.rmod(other, level=None)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator rmod ) . With arguments `level`.", "question_id": 40368}
{"snippet": "Series.rmod(other, fill_value=None)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator rmod ) . Equivalent to other % series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40369}
{"snippet": "Series.rmod(other, axis=0)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator rmod ) . With arguments `axis`.", "question_id": 40370}
{"snippet": "Series.rmod(other, level=None, fill_value=None)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator rmod ) . Equivalent to other % series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40371}
{"snippet": "Series.rmod(other, level=None, axis=0)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator rmod ) . With arguments `level`, `axis`.", "question_id": 40372}
{"snippet": "Series.rmod(other, fill_value=None, axis=0)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator rmod ) . Equivalent to other % series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40373}
{"snippet": "Series.rmod(other, level=None, fill_value=None, axis=0)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator rmod ) . Equivalent to other % series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40374}
{"snippet": "Series.rmod(other)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator rmod ) .", "question_id": 40375}
{"snippet": "Series.rmod(other, level=None)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator rmod ) . With arguments `level`.", "question_id": 40376}
{"snippet": "Series.rmod(other, fill_value=None)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator rmod ) . Equivalent to other % series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40377}
{"snippet": "Series.rmod(other, axis=0)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator rmod ) . With arguments `axis`.", "question_id": 40378}
{"snippet": "Series.rmod(other, level=None, fill_value=None)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator rmod ) . Equivalent to other % series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40379}
{"snippet": "Series.rmod(other, level=None, axis=0)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator rmod ) . With arguments `level`, `axis`.", "question_id": 40380}
{"snippet": "Series.rmod(other, fill_value=None, axis=0)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator rmod ) . Equivalent to other % series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40381}
{"snippet": "Series.rmod(other, level=None, fill_value=None, axis=0)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator rmod ) . Equivalent to other % series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40382}
{"snippet": "Series.rmod(other)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator rmod ) .", "question_id": 40383}
{"snippet": "Series.rmod(other, level=None)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator rmod ) . With arguments `level`.", "question_id": 40384}
{"snippet": "Series.rmod(other, fill_value=None)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator rmod ) . Equivalent to other % series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40385}
{"snippet": "Series.rmod(other, axis=0)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator rmod ) . With arguments `axis`.", "question_id": 40386}
{"snippet": "Series.rmod(other, level=None, fill_value=None)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator rmod ) . Equivalent to other % series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40387}
{"snippet": "Series.rmod(other, level=None, axis=0)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator rmod ) . With arguments `level`, `axis`.", "question_id": 40388}
{"snippet": "Series.rmod(other, fill_value=None, axis=0)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator rmod ) . Equivalent to other % series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40389}
{"snippet": "Series.rmod(other, level=None, fill_value=None, axis=0)", "intent": "Return Modulo of series and `other` , element-wise ( binary operator rmod ) . Equivalent to other % series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40390}
{"snippet": "Series.rmul(other)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator rmul ) .", "question_id": 40391}
{"snippet": "Series.rmul(other, level=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator rmul ) . With arguments `level`.", "question_id": 40392}
{"snippet": "Series.rmul(other, fill_value=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator rmul ) . Equivalent to other * series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40393}
{"snippet": "Series.rmul(other, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator rmul ) . With arguments `axis`.", "question_id": 40394}
{"snippet": "Series.rmul(other, level=None, fill_value=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator rmul ) . Equivalent to other * series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40395}
{"snippet": "Series.rmul(other, level=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator rmul ) . With arguments `level`, `axis`.", "question_id": 40396}
{"snippet": "Series.rmul(other, fill_value=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator rmul ) . Equivalent to other * series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40397}
{"snippet": "Series.rmul(other, level=None, fill_value=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator rmul ) . Equivalent to other * series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40398}
{"snippet": "Series.rmul(other)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator rmul ) .", "question_id": 40399}
{"snippet": "Series.rmul(other, level=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator rmul ) . With arguments `level`.", "question_id": 40400}
{"snippet": "Series.rmul(other, fill_value=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator rmul ) . Equivalent to other * series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40401}
{"snippet": "Series.rmul(other, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator rmul ) . With arguments `axis`.", "question_id": 40402}
{"snippet": "Series.rmul(other, level=None, fill_value=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator rmul ) . Equivalent to other * series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40403}
{"snippet": "Series.rmul(other, level=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator rmul ) . With arguments `level`, `axis`.", "question_id": 40404}
{"snippet": "Series.rmul(other, fill_value=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator rmul ) . Equivalent to other * series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40405}
{"snippet": "Series.rmul(other, level=None, fill_value=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator rmul ) . Equivalent to other * series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40406}
{"snippet": "Series.rmul(other)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator rmul ) .", "question_id": 40407}
{"snippet": "Series.rmul(other, level=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator rmul ) . With arguments `level`.", "question_id": 40408}
{"snippet": "Series.rmul(other, fill_value=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator rmul ) . Equivalent to other * series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40409}
{"snippet": "Series.rmul(other, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator rmul ) . With arguments `axis`.", "question_id": 40410}
{"snippet": "Series.rmul(other, level=None, fill_value=None)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator rmul ) . Equivalent to other * series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40411}
{"snippet": "Series.rmul(other, level=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator rmul ) . With arguments `level`, `axis`.", "question_id": 40412}
{"snippet": "Series.rmul(other, fill_value=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator rmul ) . Equivalent to other * series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40413}
{"snippet": "Series.rmul(other, level=None, fill_value=None, axis=0)", "intent": "Return Multiplication of series and `other` , element-wise ( binary operator rmul ) . Equivalent to other * series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40414}
{"snippet": "Series.rolling(window)", "intent": "Provide rolling `window` calculations .", "question_id": 40415}
{"snippet": "Series.rolling(window, min_periods=None)", "intent": "Provide rolling `window` calculations . Rolling sum with a window length of 2 , `min_periods` defaults to the window length .", "question_id": 40416}
{"snippet": "Series.rolling(window, center=False)", "intent": "Provide rolling `window` calculations . This can be changed to the `center` of the window by setting center=True .", "question_id": 40417}
{"snippet": "Series.rolling(window, win_type=None)", "intent": "Provide rolling `window` calculations . If win_type=None , all points are evenly weighted ; otherwise , `win_type` can accept a string of any scipy.signal window function .", "question_id": 40418}
{"snippet": "Series.rolling(window, on=None)", "intent": "Provide rolling `window` calculations . Please see the third example below `on` how to add the additional parameters .", "question_id": 40419}
{"snippet": "Series.rolling(window, axis=0)", "intent": "Provide rolling `window` calculations . With arguments `axis`.", "question_id": 40420}
{"snippet": "Series.rolling(window, closed=None)", "intent": "Provide rolling `window` calculations . With arguments `closed`.", "question_id": 40421}
{"snippet": "Series.rolling(window, method='single')", "intent": "Provide rolling `window` calculations . The additional parameters must match the keywords specified in the Scipy window type `method` signature .", "question_id": 40422}
{"snippet": "Series.rolling(window, min_periods=None, center=False)", "intent": "Provide rolling `window` calculations . Rolling sum with a window length of 2 , `min_periods` defaults to the window length . This can be changed to the `center` of the window by setting center=True .", "question_id": 40423}
{"snippet": "Series.rolling(window, min_periods=None, win_type=None)", "intent": "Provide rolling `window` calculations . Rolling sum with a window length of 2 , `min_periods` defaults to the window length . If win_type=None , all points are evenly weighted ; otherwise , `win_type` can accept a string of any scipy.signal window function .", "question_id": 40424}
{"snippet": "Series.rolling(window)", "intent": "Provide rolling `window` calculations .", "question_id": 40425}
{"snippet": "Series.rolling(window, min_periods=None)", "intent": "Provide rolling `window` calculations . Rolling sum with a window length of 2 , `min_periods` defaults to the window length .", "question_id": 40426}
{"snippet": "Series.rolling(window, center=False)", "intent": "Provide rolling `window` calculations . This can be changed to the `center` of the window by setting center=True .", "question_id": 40427}
{"snippet": "Series.rolling(window, win_type=None)", "intent": "Provide rolling `window` calculations . If win_type=None , all points are evenly weighted ; otherwise , `win_type` can accept a string of any scipy.signal window function .", "question_id": 40428}
{"snippet": "Series.rolling(window, on=None)", "intent": "Provide rolling `window` calculations . Please see the third example below `on` how to add the additional parameters .", "question_id": 40429}
{"snippet": "Series.rolling(window, axis=0)", "intent": "Provide rolling `window` calculations . With arguments `axis`.", "question_id": 40430}
{"snippet": "Series.rolling(window, closed=None)", "intent": "Provide rolling `window` calculations . With arguments `closed`.", "question_id": 40431}
{"snippet": "Series.rolling(window, method='single')", "intent": "Provide rolling `window` calculations . The additional parameters must match the keywords specified in the Scipy window type `method` signature .", "question_id": 40432}
{"snippet": "Series.rolling(window, min_periods=None, center=False)", "intent": "Provide rolling `window` calculations . Rolling sum with a window length of 2 , `min_periods` defaults to the window length . This can be changed to the `center` of the window by setting center=True .", "question_id": 40433}
{"snippet": "Series.rolling(window, min_periods=None, win_type=None)", "intent": "Provide rolling `window` calculations . Rolling sum with a window length of 2 , `min_periods` defaults to the window length . If win_type=None , all points are evenly weighted ; otherwise , `win_type` can accept a string of any scipy.signal window function .", "question_id": 40434}
{"snippet": "Series.rolling(window)", "intent": "Provide rolling `window` calculations .", "question_id": 40435}
{"snippet": "Series.rolling(window, min_periods=None)", "intent": "Provide rolling `window` calculations . Rolling sum with a window length of 2 , `min_periods` defaults to the window length .", "question_id": 40436}
{"snippet": "Series.rolling(window, center=False)", "intent": "Provide rolling `window` calculations . This can be changed to the `center` of the window by setting center=True .", "question_id": 40437}
{"snippet": "Series.rolling(window, win_type=None)", "intent": "Provide rolling `window` calculations . If win_type=None , all points are evenly weighted ; otherwise , `win_type` can accept a string of any scipy.signal window function .", "question_id": 40438}
{"snippet": "Series.rolling(window, on=None)", "intent": "Provide rolling `window` calculations . Please see the third example below `on` how to add the additional parameters .", "question_id": 40439}
{"snippet": "Series.rolling(window, axis=0)", "intent": "Provide rolling `window` calculations . With arguments `axis`.", "question_id": 40440}
{"snippet": "Series.rolling(window, closed=None)", "intent": "Provide rolling `window` calculations . With arguments `closed`.", "question_id": 40441}
{"snippet": "Series.rolling(window, method='single')", "intent": "Provide rolling `window` calculations . The additional parameters must match the keywords specified in the Scipy window type `method` signature .", "question_id": 40442}
{"snippet": "Series.rolling(window, min_periods=None, center=False)", "intent": "Provide rolling `window` calculations . Rolling sum with a window length of 2 , `min_periods` defaults to the window length . This can be changed to the `center` of the window by setting center=True .", "question_id": 40443}
{"snippet": "Series.rolling(window, min_periods=None, win_type=None)", "intent": "Provide rolling `window` calculations . Rolling sum with a window length of 2 , `min_periods` defaults to the window length . If win_type=None , all points are evenly weighted ; otherwise , `win_type` can accept a string of any scipy.signal window function .", "question_id": 40444}
{"snippet": "Series.round(*args, **kwargs)", "intent": "Round each value in a Series to the given number of `decimals` . With arguments `*args`, `**kwargs`.", "question_id": 40445}
{"snippet": "Series.round(*args, **kwargs, decimals=0)", "intent": "Round each value in a Series to the given number of `decimals` . With arguments `*args`, `**kwargs`.", "question_id": 40446}
{"snippet": "Series.round(*args, **kwargs)", "intent": "Round each value in a Series to the given number of `decimals` . With arguments `*args`, `**kwargs`.", "question_id": 40447}
{"snippet": "Series.round(*args, **kwargs, decimals=0)", "intent": "Round each value in a Series to the given number of `decimals` . With arguments `*args`, `**kwargs`.", "question_id": 40448}
{"snippet": "Series.round(*args, **kwargs)", "intent": "Round each value in a Series to the given number of `decimals` . With arguments `*args`, `**kwargs`.", "question_id": 40449}
{"snippet": "Series.round(*args, **kwargs, decimals=0)", "intent": "Round each value in a Series to the given number of `decimals` . With arguments `*args`, `**kwargs`.", "question_id": 40450}
{"snippet": "Series.rpow(other)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator rpow ) .", "question_id": 40451}
{"snippet": "Series.rpow(other, level=None)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator rpow ) . With arguments `level`.", "question_id": 40452}
{"snippet": "Series.rpow(other, fill_value=None)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator rpow ) . Equivalent to other * * series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40453}
{"snippet": "Series.rpow(other, axis=0)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator rpow ) . With arguments `axis`.", "question_id": 40454}
{"snippet": "Series.rpow(other, level=None, fill_value=None)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator rpow ) . Equivalent to other * * series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40455}
{"snippet": "Series.rpow(other, level=None, axis=0)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator rpow ) . With arguments `level`, `axis`.", "question_id": 40456}
{"snippet": "Series.rpow(other, fill_value=None, axis=0)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator rpow ) . Equivalent to other * * series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40457}
{"snippet": "Series.rpow(other, level=None, fill_value=None, axis=0)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator rpow ) . Equivalent to other * * series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40458}
{"snippet": "Series.rpow(other)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator rpow ) .", "question_id": 40459}
{"snippet": "Series.rpow(other, level=None)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator rpow ) . With arguments `level`.", "question_id": 40460}
{"snippet": "Series.rpow(other, fill_value=None)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator rpow ) . Equivalent to other * * series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40461}
{"snippet": "Series.rpow(other, axis=0)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator rpow ) . With arguments `axis`.", "question_id": 40462}
{"snippet": "Series.rpow(other, level=None, fill_value=None)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator rpow ) . Equivalent to other * * series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40463}
{"snippet": "Series.rpow(other, level=None, axis=0)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator rpow ) . With arguments `level`, `axis`.", "question_id": 40464}
{"snippet": "Series.rpow(other, fill_value=None, axis=0)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator rpow ) . Equivalent to other * * series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40465}
{"snippet": "Series.rpow(other, level=None, fill_value=None, axis=0)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator rpow ) . Equivalent to other * * series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40466}
{"snippet": "Series.rpow(other)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator rpow ) .", "question_id": 40467}
{"snippet": "Series.rpow(other, level=None)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator rpow ) . With arguments `level`.", "question_id": 40468}
{"snippet": "Series.rpow(other, fill_value=None)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator rpow ) . Equivalent to other * * series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40469}
{"snippet": "Series.rpow(other, axis=0)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator rpow ) . With arguments `axis`.", "question_id": 40470}
{"snippet": "Series.rpow(other, level=None, fill_value=None)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator rpow ) . Equivalent to other * * series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40471}
{"snippet": "Series.rpow(other, level=None, axis=0)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator rpow ) . With arguments `level`, `axis`.", "question_id": 40472}
{"snippet": "Series.rpow(other, fill_value=None, axis=0)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator rpow ) . Equivalent to other * * series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40473}
{"snippet": "Series.rpow(other, level=None, fill_value=None, axis=0)", "intent": "Return Exponential power of series and `other` , element-wise ( binary operator rpow ) . Equivalent to other * * series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40474}
{"snippet": "Series.rsub(other)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator rsub ) .", "question_id": 40475}
{"snippet": "Series.rsub(other, level=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator rsub ) . With arguments `level`.", "question_id": 40476}
{"snippet": "Series.rsub(other, fill_value=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator rsub ) . Equivalent to other - series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40477}
{"snippet": "Series.rsub(other, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator rsub ) . With arguments `axis`.", "question_id": 40478}
{"snippet": "Series.rsub(other, level=None, fill_value=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator rsub ) . Equivalent to other - series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40479}
{"snippet": "Series.rsub(other, level=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator rsub ) . With arguments `level`, `axis`.", "question_id": 40480}
{"snippet": "Series.rsub(other, fill_value=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator rsub ) . Equivalent to other - series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40481}
{"snippet": "Series.rsub(other, level=None, fill_value=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator rsub ) . Equivalent to other - series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40482}
{"snippet": "Series.rsub(other)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator rsub ) .", "question_id": 40483}
{"snippet": "Series.rsub(other, level=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator rsub ) . With arguments `level`.", "question_id": 40484}
{"snippet": "Series.rsub(other, fill_value=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator rsub ) . Equivalent to other - series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40485}
{"snippet": "Series.rsub(other, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator rsub ) . With arguments `axis`.", "question_id": 40486}
{"snippet": "Series.rsub(other, level=None, fill_value=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator rsub ) . Equivalent to other - series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40487}
{"snippet": "Series.rsub(other, level=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator rsub ) . With arguments `level`, `axis`.", "question_id": 40488}
{"snippet": "Series.rsub(other, fill_value=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator rsub ) . Equivalent to other - series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40489}
{"snippet": "Series.rsub(other, level=None, fill_value=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator rsub ) . Equivalent to other - series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40490}
{"snippet": "Series.rsub(other)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator rsub ) .", "question_id": 40491}
{"snippet": "Series.rsub(other, level=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator rsub ) . With arguments `level`.", "question_id": 40492}
{"snippet": "Series.rsub(other, fill_value=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator rsub ) . Equivalent to other - series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40493}
{"snippet": "Series.rsub(other, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator rsub ) . With arguments `axis`.", "question_id": 40494}
{"snippet": "Series.rsub(other, level=None, fill_value=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator rsub ) . Equivalent to other - series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40495}
{"snippet": "Series.rsub(other, level=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator rsub ) . With arguments `level`, `axis`.", "question_id": 40496}
{"snippet": "Series.rsub(other, fill_value=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator rsub ) . Equivalent to other - series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40497}
{"snippet": "Series.rsub(other, level=None, fill_value=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator rsub ) . Equivalent to other - series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40498}
{"snippet": "Series.rtruediv(other)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) .", "question_id": 40499}
{"snippet": "Series.rtruediv(other, level=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . With arguments `level`.", "question_id": 40500}
{"snippet": "Series.rtruediv(other, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40501}
{"snippet": "Series.rtruediv(other, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . With arguments `axis`.", "question_id": 40502}
{"snippet": "Series.rtruediv(other, level=None, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40503}
{"snippet": "Series.rtruediv(other, level=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . With arguments `level`, `axis`.", "question_id": 40504}
{"snippet": "Series.rtruediv(other, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40505}
{"snippet": "Series.rtruediv(other, level=None, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40506}
{"snippet": "Series.rtruediv(other)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) .", "question_id": 40507}
{"snippet": "Series.rtruediv(other, level=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . With arguments `level`.", "question_id": 40508}
{"snippet": "Series.rtruediv(other, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40509}
{"snippet": "Series.rtruediv(other, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . With arguments `axis`.", "question_id": 40510}
{"snippet": "Series.rtruediv(other, level=None, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40511}
{"snippet": "Series.rtruediv(other, level=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . With arguments `level`, `axis`.", "question_id": 40512}
{"snippet": "Series.rtruediv(other, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40513}
{"snippet": "Series.rtruediv(other, level=None, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40514}
{"snippet": "Series.rtruediv(other)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) .", "question_id": 40515}
{"snippet": "Series.rtruediv(other, level=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . With arguments `level`.", "question_id": 40516}
{"snippet": "Series.rtruediv(other, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / series , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 40517}
{"snippet": "Series.rtruediv(other, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . With arguments `axis`.", "question_id": 40518}
{"snippet": "Series.rtruediv(other, level=None, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 40519}
{"snippet": "Series.rtruediv(other, level=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . With arguments `level`, `axis`.", "question_id": 40520}
{"snippet": "Series.rtruediv(other, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 40521}
{"snippet": "Series.rtruediv(other, level=None, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator rtruediv ) . Equivalent to other / series , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 40522}
{"snippet": "Series.sample()", "intent": "Return a random sample of items from an `axis` of object .", "question_id": 40523}
{"snippet": "Series.sample(n=None)", "intent": "Return a random sample of items from an `axis` of object . With arguments `n`.", "question_id": 40524}
{"snippet": "Series.sample(frac=None)", "intent": "Return a random sample of items from an `axis` of object . If `frac` > 1 , replacement should be set to True .", "question_id": 40525}
{"snippet": "Series.sample(replace=False)", "intent": "Return a random sample of items from an `axis` of object . An upsample sample of the DataFrame with replacement : Note that `replace` parameter has to be True for frac parameter > 1 .", "question_id": 40526}
{"snippet": "Series.sample(weights=None)", "intent": "Return a random sample of items from an `axis` of object . Using a DataFrame column as `weights` .", "question_id": 40527}
{"snippet": "Series.sample(random_state=None)", "intent": "Return a random sample of items from an `axis` of object . You can use `random_state` for reproducibility .", "question_id": 40528}
{"snippet": "Series.sample(axis=None)", "intent": "Return a random sample of items from an `axis` of object .", "question_id": 40529}
{"snippet": "Series.sample(ignore_index=False)", "intent": "Return a random sample of items from an `axis` of object . With arguments `ignore_index`.", "question_id": 40530}
{"snippet": "Series.sample(n=None, frac=None)", "intent": "Return a random sample of items from an `axis` of object . If `frac` > 1 , replacement should be set to True . With arguments `n`.", "question_id": 40531}
{"snippet": "Series.sample(n=None, replace=False)", "intent": "Return a random sample of items from an `axis` of object . An upsample sample of the DataFrame with replacement : Note that `replace` parameter has to be True for frac parameter > 1 . With arguments `n`.", "question_id": 40532}
{"snippet": "Series.sample()", "intent": "Return a random sample of items from an `axis` of object .", "question_id": 40533}
{"snippet": "Series.sample(n=None)", "intent": "Return a random sample of items from an `axis` of object . With arguments `n`.", "question_id": 40534}
{"snippet": "Series.sample(frac=None)", "intent": "Return a random sample of items from an `axis` of object . If `frac` > 1 , replacement should be set to True .", "question_id": 40535}
{"snippet": "Series.sample(replace=False)", "intent": "Return a random sample of items from an `axis` of object . An upsample sample of the DataFrame with replacement : Note that `replace` parameter has to be True for frac parameter > 1 .", "question_id": 40536}
{"snippet": "Series.sample(weights=None)", "intent": "Return a random sample of items from an `axis` of object . Using a DataFrame column as `weights` .", "question_id": 40537}
{"snippet": "Series.sample(random_state=None)", "intent": "Return a random sample of items from an `axis` of object . You can use `random_state` for reproducibility .", "question_id": 40538}
{"snippet": "Series.sample(axis=None)", "intent": "Return a random sample of items from an `axis` of object .", "question_id": 40539}
{"snippet": "Series.sample(ignore_index=False)", "intent": "Return a random sample of items from an `axis` of object . With arguments `ignore_index`.", "question_id": 40540}
{"snippet": "Series.sample(n=None, frac=None)", "intent": "Return a random sample of items from an `axis` of object . If `frac` > 1 , replacement should be set to True . With arguments `n`.", "question_id": 40541}
{"snippet": "Series.sample(n=None, replace=False)", "intent": "Return a random sample of items from an `axis` of object . An upsample sample of the DataFrame with replacement : Note that `replace` parameter has to be True for frac parameter > 1 . With arguments `n`.", "question_id": 40542}
{"snippet": "Series.sample()", "intent": "Return a random sample of items from an `axis` of object .", "question_id": 40543}
{"snippet": "Series.sample(n=None)", "intent": "Return a random sample of items from an `axis` of object . With arguments `n`.", "question_id": 40544}
{"snippet": "Series.sample(frac=None)", "intent": "Return a random sample of items from an `axis` of object . If `frac` > 1 , replacement should be set to True .", "question_id": 40545}
{"snippet": "Series.sample(replace=False)", "intent": "Return a random sample of items from an `axis` of object . An upsample sample of the DataFrame with replacement : Note that `replace` parameter has to be True for frac parameter > 1 .", "question_id": 40546}
{"snippet": "Series.sample(weights=None)", "intent": "Return a random sample of items from an `axis` of object . Using a DataFrame column as `weights` .", "question_id": 40547}
{"snippet": "Series.sample(random_state=None)", "intent": "Return a random sample of items from an `axis` of object . You can use `random_state` for reproducibility .", "question_id": 40548}
{"snippet": "Series.sample(axis=None)", "intent": "Return a random sample of items from an `axis` of object .", "question_id": 40549}
{"snippet": "Series.sample(ignore_index=False)", "intent": "Return a random sample of items from an `axis` of object . With arguments `ignore_index`.", "question_id": 40550}
{"snippet": "Series.sample(n=None, frac=None)", "intent": "Return a random sample of items from an `axis` of object . If `frac` > 1 , replacement should be set to True . With arguments `n`.", "question_id": 40551}
{"snippet": "Series.sample(n=None, replace=False)", "intent": "Return a random sample of items from an `axis` of object . An upsample sample of the DataFrame with replacement : Note that `replace` parameter has to be True for frac parameter > 1 . With arguments `n`.", "question_id": 40552}
{"snippet": "Series.searchsorted(value)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted Series self such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved .", "question_id": 40553}
{"snippet": "Series.searchsorted(value, side='left')", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted Series self such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `side`.", "question_id": 40554}
{"snippet": "Series.searchsorted(value, sorter=None)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted Series self such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `sorter`.", "question_id": 40555}
{"snippet": "Series.searchsorted(value, side='left', sorter=None)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted Series self such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `side`, `sorter`.", "question_id": 40556}
{"snippet": "Series.searchsorted(value)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted Series self such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved .", "question_id": 40557}
{"snippet": "Series.searchsorted(value, side='left')", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted Series self such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `side`.", "question_id": 40558}
{"snippet": "Series.searchsorted(value, sorter=None)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted Series self such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `sorter`.", "question_id": 40559}
{"snippet": "Series.searchsorted(value, side='left', sorter=None)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted Series self such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `side`, `sorter`.", "question_id": 40560}
{"snippet": "Series.searchsorted(value)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted Series self such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved .", "question_id": 40561}
{"snippet": "Series.searchsorted(value, side='left')", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted Series self such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `side`.", "question_id": 40562}
{"snippet": "Series.searchsorted(value, sorter=None)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted Series self such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `sorter`.", "question_id": 40563}
{"snippet": "Series.searchsorted(value, side='left', sorter=None)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted Series self such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `side`, `sorter`.", "question_id": 40564}
{"snippet": "Series.sem(**kwargs)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`.", "question_id": 40565}
{"snippet": "Series.sem(**kwargs, axis=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`.", "question_id": 40566}
{"snippet": "Series.sem(**kwargs, skipna=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 40567}
{"snippet": "Series.sem(**kwargs, level=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 40568}
{"snippet": "Series.sem(**kwargs, ddof=1)", "intent": "Return unbiased standard error of the mean over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 40569}
{"snippet": "Series.sem(**kwargs, numeric_only=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 40570}
{"snippet": "Series.sem(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 40571}
{"snippet": "Series.sem(**kwargs, axis=None, level=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 40572}
{"snippet": "Series.sem(**kwargs, axis=None, ddof=1)", "intent": "Return unbiased standard error of the mean over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 40573}
{"snippet": "Series.sem(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 40574}
{"snippet": "Series.sem(**kwargs)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`.", "question_id": 40575}
{"snippet": "Series.sem(**kwargs, axis=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`.", "question_id": 40576}
{"snippet": "Series.sem(**kwargs, skipna=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 40577}
{"snippet": "Series.sem(**kwargs, level=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 40578}
{"snippet": "Series.sem(**kwargs, ddof=1)", "intent": "Return unbiased standard error of the mean over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 40579}
{"snippet": "Series.sem(**kwargs, numeric_only=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 40580}
{"snippet": "Series.sem(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 40581}
{"snippet": "Series.sem(**kwargs, axis=None, level=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 40582}
{"snippet": "Series.sem(**kwargs, axis=None, ddof=1)", "intent": "Return unbiased standard error of the mean over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 40583}
{"snippet": "Series.sem(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 40584}
{"snippet": "Series.sem(**kwargs)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`.", "question_id": 40585}
{"snippet": "Series.sem(**kwargs, axis=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`.", "question_id": 40586}
{"snippet": "Series.sem(**kwargs, skipna=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 40587}
{"snippet": "Series.sem(**kwargs, level=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 40588}
{"snippet": "Series.sem(**kwargs, ddof=1)", "intent": "Return unbiased standard error of the mean over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 40589}
{"snippet": "Series.sem(**kwargs, numeric_only=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 40590}
{"snippet": "Series.sem(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 40591}
{"snippet": "Series.sem(**kwargs, axis=None, level=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 40592}
{"snippet": "Series.sem(**kwargs, axis=None, ddof=1)", "intent": "Return unbiased standard error of the mean over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 40593}
{"snippet": "Series.sem(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased standard error of the mean over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 40594}
{"snippet": "Series.set_axis(labels)", "intent": "Assign desired index to given `axis` . Indexes for row `labels` can be changed by assigning a list-like or Index .", "question_id": 40595}
{"snippet": "Series.set_axis(labels, axis=0)", "intent": "Assign desired index to given `axis` . Indexes for row `labels` can be changed by assigning a list-like or Index .", "question_id": 40596}
{"snippet": "Series.set_axis(labels, inplace=False)", "intent": "Assign desired index to given `axis` . Indexes for row `labels` can be changed by assigning a list-like or Index . With arguments `inplace`.", "question_id": 40597}
{"snippet": "Series.set_axis(labels, axis=0, inplace=False)", "intent": "Assign desired index to given `axis` . Indexes for row `labels` can be changed by assigning a list-like or Index . With arguments `inplace`.", "question_id": 40598}
{"snippet": "Series.set_axis(labels)", "intent": "Assign desired index to given `axis` . Indexes for row `labels` can be changed by assigning a list-like or Index .", "question_id": 40599}
{"snippet": "Series.set_axis(labels, axis=0)", "intent": "Assign desired index to given `axis` . Indexes for row `labels` can be changed by assigning a list-like or Index .", "question_id": 40600}
{"snippet": "Series.set_axis(labels, inplace=False)", "intent": "Assign desired index to given `axis` . Indexes for row `labels` can be changed by assigning a list-like or Index . With arguments `inplace`.", "question_id": 40601}
{"snippet": "Series.set_axis(labels, axis=0, inplace=False)", "intent": "Assign desired index to given `axis` . Indexes for row `labels` can be changed by assigning a list-like or Index . With arguments `inplace`.", "question_id": 40602}
{"snippet": "Series.set_axis(labels)", "intent": "Assign desired index to given `axis` . Indexes for row `labels` can be changed by assigning a list-like or Index .", "question_id": 40603}
{"snippet": "Series.set_axis(labels, axis=0)", "intent": "Assign desired index to given `axis` . Indexes for row `labels` can be changed by assigning a list-like or Index .", "question_id": 40604}
{"snippet": "Series.set_axis(labels, inplace=False)", "intent": "Assign desired index to given `axis` . Indexes for row `labels` can be changed by assigning a list-like or Index . With arguments `inplace`.", "question_id": 40605}
{"snippet": "Series.set_axis(labels, axis=0, inplace=False)", "intent": "Assign desired index to given `axis` . Indexes for row `labels` can be changed by assigning a list-like or Index . With arguments `inplace`.", "question_id": 40606}
{"snippet": "Series.set_flags()", "intent": "Return a new object with updated flags .", "question_id": 40607}
{"snippet": "Series.set_flags(copy=False)", "intent": "Return a new object with updated flags . With arguments `copy`.", "question_id": 40608}
{"snippet": "Series.set_flags(allows_duplicate_labels=None)", "intent": "Return a new object with updated flags . With arguments `allows_duplicate_labels`.", "question_id": 40609}
{"snippet": "Series.set_flags(copy=False, allows_duplicate_labels=None)", "intent": "Return a new object with updated flags . With arguments `copy`, `allows_duplicate_labels`.", "question_id": 40610}
{"snippet": "Series.set_flags()", "intent": "Return a new object with updated flags .", "question_id": 40611}
{"snippet": "Series.set_flags(copy=False)", "intent": "Return a new object with updated flags . With arguments `copy`.", "question_id": 40612}
{"snippet": "Series.set_flags(allows_duplicate_labels=None)", "intent": "Return a new object with updated flags . With arguments `allows_duplicate_labels`.", "question_id": 40613}
{"snippet": "Series.set_flags(copy=False, allows_duplicate_labels=None)", "intent": "Return a new object with updated flags . With arguments `copy`, `allows_duplicate_labels`.", "question_id": 40614}
{"snippet": "Series.set_flags()", "intent": "Return a new object with updated flags .", "question_id": 40615}
{"snippet": "Series.set_flags(copy=False)", "intent": "Return a new object with updated flags . With arguments `copy`.", "question_id": 40616}
{"snippet": "Series.set_flags(allows_duplicate_labels=None)", "intent": "Return a new object with updated flags . With arguments `allows_duplicate_labels`.", "question_id": 40617}
{"snippet": "Series.set_flags(copy=False, allows_duplicate_labels=None)", "intent": "Return a new object with updated flags . With arguments `copy`, `allows_duplicate_labels`.", "question_id": 40618}
{"snippet": "Series.shift()", "intent": "Shift index by desired number of `periods` with an optional time `freq` .", "question_id": 40619}
{"snippet": "Series.shift(periods=1)", "intent": "Shift index by desired number of `periods` with an optional time `freq` .", "question_id": 40620}
{"snippet": "Series.shift(freq=None)", "intent": "Shift index by desired number of `periods` with an optional time `freq` .", "question_id": 40621}
{"snippet": "Series.shift(axis=0)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `axis`.", "question_id": 40622}
{"snippet": "Series.shift(fill_value=None)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `fill_value`.", "question_id": 40623}
{"snippet": "Series.shift(periods=1, freq=None)", "intent": "Shift index by desired number of `periods` with an optional time `freq` .", "question_id": 40624}
{"snippet": "Series.shift(periods=1, axis=0)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `axis`.", "question_id": 40625}
{"snippet": "Series.shift(periods=1, fill_value=None)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `fill_value`.", "question_id": 40626}
{"snippet": "Series.shift(freq=None, axis=0)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `axis`.", "question_id": 40627}
{"snippet": "Series.shift(freq=None, fill_value=None)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `fill_value`.", "question_id": 40628}
{"snippet": "Series.shift()", "intent": "Shift index by desired number of `periods` with an optional time `freq` .", "question_id": 40629}
{"snippet": "Series.shift(periods=1)", "intent": "Shift index by desired number of `periods` with an optional time `freq` .", "question_id": 40630}
{"snippet": "Series.shift(freq=None)", "intent": "Shift index by desired number of `periods` with an optional time `freq` .", "question_id": 40631}
{"snippet": "Series.shift(axis=0)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `axis`.", "question_id": 40632}
{"snippet": "Series.shift(fill_value=None)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `fill_value`.", "question_id": 40633}
{"snippet": "Series.shift(periods=1, freq=None)", "intent": "Shift index by desired number of `periods` with an optional time `freq` .", "question_id": 40634}
{"snippet": "Series.shift(periods=1, axis=0)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `axis`.", "question_id": 40635}
{"snippet": "Series.shift(periods=1, fill_value=None)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `fill_value`.", "question_id": 40636}
{"snippet": "Series.shift(freq=None, axis=0)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `axis`.", "question_id": 40637}
{"snippet": "Series.shift(freq=None, fill_value=None)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `fill_value`.", "question_id": 40638}
{"snippet": "Series.shift()", "intent": "Shift index by desired number of `periods` with an optional time `freq` .", "question_id": 40639}
{"snippet": "Series.shift(periods=1)", "intent": "Shift index by desired number of `periods` with an optional time `freq` .", "question_id": 40640}
{"snippet": "Series.shift(freq=None)", "intent": "Shift index by desired number of `periods` with an optional time `freq` .", "question_id": 40641}
{"snippet": "Series.shift(axis=0)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `axis`.", "question_id": 40642}
{"snippet": "Series.shift(fill_value=None)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `fill_value`.", "question_id": 40643}
{"snippet": "Series.shift(periods=1, freq=None)", "intent": "Shift index by desired number of `periods` with an optional time `freq` .", "question_id": 40644}
{"snippet": "Series.shift(periods=1, axis=0)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `axis`.", "question_id": 40645}
{"snippet": "Series.shift(periods=1, fill_value=None)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `fill_value`.", "question_id": 40646}
{"snippet": "Series.shift(freq=None, axis=0)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `axis`.", "question_id": 40647}
{"snippet": "Series.shift(freq=None, fill_value=None)", "intent": "Shift index by desired number of `periods` with an optional time `freq` . With arguments `fill_value`.", "question_id": 40648}
{"snippet": "Series.skew(**kwargs)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`.", "question_id": 40649}
{"snippet": "Series.skew(**kwargs, axis=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`.", "question_id": 40650}
{"snippet": "Series.skew(**kwargs, skipna=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 40651}
{"snippet": "Series.skew(**kwargs, level=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 40652}
{"snippet": "Series.skew(**kwargs, numeric_only=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 40653}
{"snippet": "Series.skew(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 40654}
{"snippet": "Series.skew(**kwargs, axis=None, level=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 40655}
{"snippet": "Series.skew(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 40656}
{"snippet": "Series.skew(**kwargs, skipna=None, level=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 40657}
{"snippet": "Series.skew(**kwargs, skipna=None, numeric_only=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 40658}
{"snippet": "Series.skew(**kwargs)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`.", "question_id": 40659}
{"snippet": "Series.skew(**kwargs, axis=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`.", "question_id": 40660}
{"snippet": "Series.skew(**kwargs, skipna=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 40661}
{"snippet": "Series.skew(**kwargs, level=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 40662}
{"snippet": "Series.skew(**kwargs, numeric_only=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 40663}
{"snippet": "Series.skew(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 40664}
{"snippet": "Series.skew(**kwargs, axis=None, level=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 40665}
{"snippet": "Series.skew(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 40666}
{"snippet": "Series.skew(**kwargs, skipna=None, level=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 40667}
{"snippet": "Series.skew(**kwargs, skipna=None, numeric_only=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 40668}
{"snippet": "Series.skew(**kwargs)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`.", "question_id": 40669}
{"snippet": "Series.skew(**kwargs, axis=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`.", "question_id": 40670}
{"snippet": "Series.skew(**kwargs, skipna=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 40671}
{"snippet": "Series.skew(**kwargs, level=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 40672}
{"snippet": "Series.skew(**kwargs, numeric_only=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 40673}
{"snippet": "Series.skew(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 40674}
{"snippet": "Series.skew(**kwargs, axis=None, level=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 40675}
{"snippet": "Series.skew(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 40676}
{"snippet": "Series.skew(**kwargs, skipna=None, level=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `skipna`, `level`.", "question_id": 40677}
{"snippet": "Series.skew(**kwargs, skipna=None, numeric_only=None)", "intent": "Return unbiased skew over requested `axis` . With arguments `**kwargs`, `skipna`, `numeric_only`.", "question_id": 40678}
{"snippet": "Series.slice_shift()", "intent": "Equivalent to shift without copying data .", "question_id": 40679}
{"snippet": "Series.slice_shift(periods=1)", "intent": "Equivalent to shift without copying data . The shifted data will not include the dropped `periods` and the shifted `axis` will be smaller than the original .", "question_id": 40680}
{"snippet": "Series.slice_shift(axis=0)", "intent": "Equivalent to shift without copying data . The shifted data will not include the dropped `periods` and the shifted `axis` will be smaller than the original .", "question_id": 40681}
{"snippet": "Series.slice_shift(periods=1, axis=0)", "intent": "Equivalent to shift without copying data . The shifted data will not include the dropped `periods` and the shifted `axis` will be smaller than the original .", "question_id": 40682}
{"snippet": "Series.slice_shift()", "intent": "Equivalent to shift without copying data .", "question_id": 40683}
{"snippet": "Series.slice_shift(periods=1)", "intent": "Equivalent to shift without copying data . The shifted data will not include the dropped `periods` and the shifted `axis` will be smaller than the original .", "question_id": 40684}
{"snippet": "Series.slice_shift(axis=0)", "intent": "Equivalent to shift without copying data . The shifted data will not include the dropped `periods` and the shifted `axis` will be smaller than the original .", "question_id": 40685}
{"snippet": "Series.slice_shift(periods=1, axis=0)", "intent": "Equivalent to shift without copying data . The shifted data will not include the dropped `periods` and the shifted `axis` will be smaller than the original .", "question_id": 40686}
{"snippet": "Series.slice_shift()", "intent": "Equivalent to shift without copying data .", "question_id": 40687}
{"snippet": "Series.slice_shift(periods=1)", "intent": "Equivalent to shift without copying data . The shifted data will not include the dropped `periods` and the shifted `axis` will be smaller than the original .", "question_id": 40688}
{"snippet": "Series.slice_shift(axis=0)", "intent": "Equivalent to shift without copying data . The shifted data will not include the dropped `periods` and the shifted `axis` will be smaller than the original .", "question_id": 40689}
{"snippet": "Series.slice_shift(periods=1, axis=0)", "intent": "Equivalent to shift without copying data . The shifted data will not include the dropped `periods` and the shifted `axis` will be smaller than the original .", "question_id": 40690}
{"snippet": "Series.sort_index()", "intent": "Sort Series by index labels .", "question_id": 40691}
{"snippet": "Series.sort_index(axis=0)", "intent": "Sort Series by index labels . With arguments `axis`.", "question_id": 40692}
{"snippet": "Series.sort_index(level=None)", "intent": "Sort Series by index labels . Specify index `level` to sort", "question_id": 40693}
{"snippet": "Series.sort_index(ascending=True)", "intent": "Sort Series by index labels . With arguments `ascending`.", "question_id": 40694}
{"snippet": "Series.sort_index(inplace=False)", "intent": "Sort Series by index labels . Returns a new Series sorted by label if `inplace` argument is False , otherwise updates the original series and returns None .", "question_id": 40695}
{"snippet": "Series.sort_index(kind='quicksort')", "intent": "Sort Series by index labels . With arguments `kind`.", "question_id": 40696}
{"snippet": "Series.sort_index(na_position='last')", "intent": "Sort Series by index labels . By default NaNs are put at the end , but use `na_position` to place them at the beginning", "question_id": 40697}
{"snippet": "Series.sort_index(sort_remaining=True)", "intent": "Sort Series by index labels . With arguments `sort_remaining`.", "question_id": 40698}
{"snippet": "Series.sort_index(ignore_index=False)", "intent": "Sort Series by index labels . With arguments `ignore_index`.", "question_id": 40699}
{"snippet": "Series.sort_index(key=None)", "intent": "Sort Series by index labels . Apply a `key` function before sorting", "question_id": 40700}
{"snippet": "Series.sort_index()", "intent": "Sort Series by index labels .", "question_id": 40701}
{"snippet": "Series.sort_index(axis=0)", "intent": "Sort Series by index labels . With arguments `axis`.", "question_id": 40702}
{"snippet": "Series.sort_index(level=None)", "intent": "Sort Series by index labels . Specify index `level` to sort", "question_id": 40703}
{"snippet": "Series.sort_index(ascending=True)", "intent": "Sort Series by index labels . With arguments `ascending`.", "question_id": 40704}
{"snippet": "Series.sort_index(inplace=False)", "intent": "Sort Series by index labels . Returns a new Series sorted by label if `inplace` argument is False , otherwise updates the original series and returns None .", "question_id": 40705}
{"snippet": "Series.sort_index(kind='quicksort')", "intent": "Sort Series by index labels . With arguments `kind`.", "question_id": 40706}
{"snippet": "Series.sort_index(na_position='last')", "intent": "Sort Series by index labels . By default NaNs are put at the end , but use `na_position` to place them at the beginning", "question_id": 40707}
{"snippet": "Series.sort_index(sort_remaining=True)", "intent": "Sort Series by index labels . With arguments `sort_remaining`.", "question_id": 40708}
{"snippet": "Series.sort_index(ignore_index=False)", "intent": "Sort Series by index labels . With arguments `ignore_index`.", "question_id": 40709}
{"snippet": "Series.sort_index(key=None)", "intent": "Sort Series by index labels . Apply a `key` function before sorting", "question_id": 40710}
{"snippet": "Series.sort_index()", "intent": "Sort Series by index labels .", "question_id": 40711}
{"snippet": "Series.sort_index(axis=0)", "intent": "Sort Series by index labels . With arguments `axis`.", "question_id": 40712}
{"snippet": "Series.sort_index(level=None)", "intent": "Sort Series by index labels . Specify index `level` to sort", "question_id": 40713}
{"snippet": "Series.sort_index(ascending=True)", "intent": "Sort Series by index labels . With arguments `ascending`.", "question_id": 40714}
{"snippet": "Series.sort_index(inplace=False)", "intent": "Sort Series by index labels . Returns a new Series sorted by label if `inplace` argument is False , otherwise updates the original series and returns None .", "question_id": 40715}
{"snippet": "Series.sort_index(kind='quicksort')", "intent": "Sort Series by index labels . With arguments `kind`.", "question_id": 40716}
{"snippet": "Series.sort_index(na_position='last')", "intent": "Sort Series by index labels . By default NaNs are put at the end , but use `na_position` to place them at the beginning", "question_id": 40717}
{"snippet": "Series.sort_index(sort_remaining=True)", "intent": "Sort Series by index labels . With arguments `sort_remaining`.", "question_id": 40718}
{"snippet": "Series.sort_index(ignore_index=False)", "intent": "Sort Series by index labels . With arguments `ignore_index`.", "question_id": 40719}
{"snippet": "Series.sort_index(key=None)", "intent": "Sort Series by index labels . Apply a `key` function before sorting", "question_id": 40720}
{"snippet": "Series.sort_values()", "intent": "Sort by the values .", "question_id": 40721}
{"snippet": "Series.sort_values(axis=0)", "intent": "Sort by the values . With arguments `axis`.", "question_id": 40722}
{"snippet": "Series.sort_values(ascending=True)", "intent": "Sort by the values . Sort a Series in `ascending` or descending order by some criterion .", "question_id": 40723}
{"snippet": "Series.sort_values(inplace=False)", "intent": "Sort by the values . Sort values `inplace`", "question_id": 40724}
{"snippet": "Series.sort_values(kind='quicksort')", "intent": "Sort by the values . With arguments `kind`.", "question_id": 40725}
{"snippet": "Series.sort_values(na_position='last')", "intent": "Sort by the values . With arguments `na_position`.", "question_id": 40726}
{"snippet": "Series.sort_values(ignore_index=False)", "intent": "Sort by the values . With arguments `ignore_index`.", "question_id": 40727}
{"snippet": "Series.sort_values(key=None)", "intent": "Sort by the values . Sort using a `key` function .", "question_id": 40728}
{"snippet": "Series.sort_values(axis=0, ascending=True)", "intent": "Sort by the values . Sort a Series in `ascending` or descending order by some criterion . With arguments `axis`.", "question_id": 40729}
{"snippet": "Series.sort_values(axis=0, inplace=False)", "intent": "Sort by the values . Sort values `inplace` With arguments `axis`.", "question_id": 40730}
{"snippet": "Series.sort_values()", "intent": "Sort by the values .", "question_id": 40731}
{"snippet": "Series.sort_values(axis=0)", "intent": "Sort by the values . With arguments `axis`.", "question_id": 40732}
{"snippet": "Series.sort_values(ascending=True)", "intent": "Sort by the values . Sort a Series in `ascending` or descending order by some criterion .", "question_id": 40733}
{"snippet": "Series.sort_values(inplace=False)", "intent": "Sort by the values . Sort values `inplace`", "question_id": 40734}
{"snippet": "Series.sort_values(kind='quicksort')", "intent": "Sort by the values . With arguments `kind`.", "question_id": 40735}
{"snippet": "Series.sort_values(na_position='last')", "intent": "Sort by the values . With arguments `na_position`.", "question_id": 40736}
{"snippet": "Series.sort_values(ignore_index=False)", "intent": "Sort by the values . With arguments `ignore_index`.", "question_id": 40737}
{"snippet": "Series.sort_values(key=None)", "intent": "Sort by the values . Sort using a `key` function .", "question_id": 40738}
{"snippet": "Series.sort_values(axis=0, ascending=True)", "intent": "Sort by the values . Sort a Series in `ascending` or descending order by some criterion . With arguments `axis`.", "question_id": 40739}
{"snippet": "Series.sort_values(axis=0, inplace=False)", "intent": "Sort by the values . Sort values `inplace` With arguments `axis`.", "question_id": 40740}
{"snippet": "Series.sort_values()", "intent": "Sort by the values .", "question_id": 40741}
{"snippet": "Series.sort_values(axis=0)", "intent": "Sort by the values . With arguments `axis`.", "question_id": 40742}
{"snippet": "Series.sort_values(ascending=True)", "intent": "Sort by the values . Sort a Series in `ascending` or descending order by some criterion .", "question_id": 40743}
{"snippet": "Series.sort_values(inplace=False)", "intent": "Sort by the values . Sort values `inplace`", "question_id": 40744}
{"snippet": "Series.sort_values(kind='quicksort')", "intent": "Sort by the values . With arguments `kind`.", "question_id": 40745}
{"snippet": "Series.sort_values(na_position='last')", "intent": "Sort by the values . With arguments `na_position`.", "question_id": 40746}
{"snippet": "Series.sort_values(ignore_index=False)", "intent": "Sort by the values . With arguments `ignore_index`.", "question_id": 40747}
{"snippet": "Series.sort_values(key=None)", "intent": "Sort by the values . Sort using a `key` function .", "question_id": 40748}
{"snippet": "Series.sort_values(axis=0, ascending=True)", "intent": "Sort by the values . Sort a Series in `ascending` or descending order by some criterion . With arguments `axis`.", "question_id": 40749}
{"snippet": "Series.sort_values(axis=0, inplace=False)", "intent": "Sort by the values . Sort values `inplace` With arguments `axis`.", "question_id": 40750}
{"snippet": "Series.sparse.density", "intent": "The percent of non- fill_value points, as decimal.", "question_id": 40751}
{"snippet": "Series.sparse.density", "intent": "The percent of non- fill_value points, as decimal.", "question_id": 40752}
{"snippet": "Series.sparse.density", "intent": "The percent of non- fill_value points, as decimal.", "question_id": 40753}
{"snippet": "Series.sparse.fill_value", "intent": "Elements in data that are fill_value are not stored.", "question_id": 40754}
{"snippet": "Series.sparse.fill_value", "intent": "Elements in data that are fill_value are not stored.", "question_id": 40755}
{"snippet": "Series.sparse.fill_value", "intent": "Elements in data that are fill_value are not stored.", "question_id": 40756}
{"snippet": "Series.sparse.from_coo(A)", "intent": "Create a Series with sparse values from a scipy.sparse.coo_matrix . With arguments `A`.", "question_id": 40757}
{"snippet": "Series.sparse.from_coo(A, dense_index=False)", "intent": "Create a Series with sparse values from a scipy.sparse.coo_matrix . With arguments `A`, `dense_index`.", "question_id": 40758}
{"snippet": "Series.sparse.from_coo(A)", "intent": "Create a Series with sparse values from a scipy.sparse.coo_matrix . With arguments `A`.", "question_id": 40759}
{"snippet": "Series.sparse.from_coo(A, dense_index=False)", "intent": "Create a Series with sparse values from a scipy.sparse.coo_matrix . With arguments `A`, `dense_index`.", "question_id": 40760}
{"snippet": "Series.sparse.from_coo(A)", "intent": "Create a Series with sparse values from a scipy.sparse.coo_matrix . With arguments `A`.", "question_id": 40761}
{"snippet": "Series.sparse.from_coo(A, dense_index=False)", "intent": "Create a Series with sparse values from a scipy.sparse.coo_matrix . With arguments `A`, `dense_index`.", "question_id": 40762}
{"snippet": "Series.sparse()", "intent": "Accessor for SparseSparse from other sparse matrix data types .", "question_id": 40763}
{"snippet": "Series.sparse()", "intent": "Accessor for SparseSparse from other sparse matrix data types .", "question_id": 40764}
{"snippet": "Series.sparse()", "intent": "Accessor for SparseSparse from other sparse matrix data types .", "question_id": 40765}
{"snippet": "Series.sparse.npoints", "intent": "The number of non- fill_value points.", "question_id": 40766}
{"snippet": "Series.sparse.npoints", "intent": "The number of non- fill_value points.", "question_id": 40767}
{"snippet": "Series.sparse.npoints", "intent": "The number of non- fill_value points.", "question_id": 40768}
{"snippet": "Series.sparse.sp_values", "intent": "An ndarray containing the non- fill_value values.", "question_id": 40769}
{"snippet": "Series.sparse.sp_values", "intent": "An ndarray containing the non- fill_value values.", "question_id": 40770}
{"snippet": "Series.sparse.sp_values", "intent": "An ndarray containing the non- fill_value values.", "question_id": 40771}
{"snippet": "Series.sparse.to_coo()", "intent": "Create a scipy.sparse.coo_matrix from a Series with MultiIndex .", "question_id": 40772}
{"snippet": "Series.sparse.to_coo(row_levels=(0,))", "intent": "Create a scipy.sparse.coo_matrix from a Series with MultiIndex . Use `row_levels` and `column_levels` to determine the row and column coordinates respectively .", "question_id": 40773}
{"snippet": "Series.sparse.to_coo(column_levels=(1,))", "intent": "Create a scipy.sparse.coo_matrix from a Series with MultiIndex . Use `row_levels` and `column_levels` to determine the row and column coordinates respectively .", "question_id": 40774}
{"snippet": "Series.sparse.to_coo(sort_labels=False)", "intent": "Create a scipy.sparse.coo_matrix from a Series with MultiIndex . With arguments `sort_labels`.", "question_id": 40775}
{"snippet": "Series.sparse.to_coo(row_levels=(0,), column_levels=(1,))", "intent": "Create a scipy.sparse.coo_matrix from a Series with MultiIndex . Use `row_levels` and `column_levels` to determine the row and column coordinates respectively .", "question_id": 40776}
{"snippet": "Series.sparse.to_coo(row_levels=(0,), sort_labels=False)", "intent": "Create a scipy.sparse.coo_matrix from a Series with MultiIndex . Use `row_levels` and `column_levels` to determine the row and column coordinates respectively . With arguments `sort_labels`.", "question_id": 40777}
{"snippet": "Series.sparse.to_coo(column_levels=(1,), sort_labels=False)", "intent": "Create a scipy.sparse.coo_matrix from a Series with MultiIndex . Use `row_levels` and `column_levels` to determine the row and column coordinates respectively . With arguments `sort_labels`.", "question_id": 40778}
{"snippet": "Series.sparse.to_coo(row_levels=(0,), column_levels=(1,), sort_labels=False)", "intent": "Create a scipy.sparse.coo_matrix from a Series with MultiIndex . Use `row_levels` and `column_levels` to determine the row and column coordinates respectively . With arguments `sort_labels`.", "question_id": 40779}
{"snippet": "Series.sparse.to_coo()", "intent": "Create a scipy.sparse.coo_matrix from a Series with MultiIndex .", "question_id": 40780}
{"snippet": "Series.sparse.to_coo(row_levels=(0,))", "intent": "Create a scipy.sparse.coo_matrix from a Series with MultiIndex . Use `row_levels` and `column_levels` to determine the row and column coordinates respectively .", "question_id": 40781}
{"snippet": "Series.sparse.to_coo(column_levels=(1,))", "intent": "Create a scipy.sparse.coo_matrix from a Series with MultiIndex . Use `row_levels` and `column_levels` to determine the row and column coordinates respectively .", "question_id": 40782}
{"snippet": "Series.sparse.to_coo(sort_labels=False)", "intent": "Create a scipy.sparse.coo_matrix from a Series with MultiIndex . With arguments `sort_labels`.", "question_id": 40783}
{"snippet": "Series.sparse.to_coo(row_levels=(0,), column_levels=(1,))", "intent": "Create a scipy.sparse.coo_matrix from a Series with MultiIndex . Use `row_levels` and `column_levels` to determine the row and column coordinates respectively .", "question_id": 40784}
{"snippet": "Series.sparse.to_coo(row_levels=(0,), sort_labels=False)", "intent": "Create a scipy.sparse.coo_matrix from a Series with MultiIndex . Use `row_levels` and `column_levels` to determine the row and column coordinates respectively . With arguments `sort_labels`.", "question_id": 40785}
{"snippet": "Series.sparse.to_coo(column_levels=(1,), sort_labels=False)", "intent": "Create a scipy.sparse.coo_matrix from a Series with MultiIndex . Use `row_levels` and `column_levels` to determine the row and column coordinates respectively . With arguments `sort_labels`.", "question_id": 40786}
{"snippet": "Series.sparse.to_coo(row_levels=(0,), column_levels=(1,), sort_labels=False)", "intent": "Create a scipy.sparse.coo_matrix from a Series with MultiIndex . Use `row_levels` and `column_levels` to determine the row and column coordinates respectively . With arguments `sort_labels`.", "question_id": 40787}
{"snippet": "Series.sparse.to_coo()", "intent": "Create a scipy.sparse.coo_matrix from a Series with MultiIndex .", "question_id": 40788}
{"snippet": "Series.sparse.to_coo(row_levels=(0,))", "intent": "Create a scipy.sparse.coo_matrix from a Series with MultiIndex . Use `row_levels` and `column_levels` to determine the row and column coordinates respectively .", "question_id": 40789}
{"snippet": "Series.sparse.to_coo(column_levels=(1,))", "intent": "Create a scipy.sparse.coo_matrix from a Series with MultiIndex . Use `row_levels` and `column_levels` to determine the row and column coordinates respectively .", "question_id": 40790}
{"snippet": "Series.sparse.to_coo(sort_labels=False)", "intent": "Create a scipy.sparse.coo_matrix from a Series with MultiIndex . With arguments `sort_labels`.", "question_id": 40791}
{"snippet": "Series.sparse.to_coo(row_levels=(0,), column_levels=(1,))", "intent": "Create a scipy.sparse.coo_matrix from a Series with MultiIndex . Use `row_levels` and `column_levels` to determine the row and column coordinates respectively .", "question_id": 40792}
{"snippet": "Series.sparse.to_coo(row_levels=(0,), sort_labels=False)", "intent": "Create a scipy.sparse.coo_matrix from a Series with MultiIndex . Use `row_levels` and `column_levels` to determine the row and column coordinates respectively . With arguments `sort_labels`.", "question_id": 40793}
{"snippet": "Series.sparse.to_coo(column_levels=(1,), sort_labels=False)", "intent": "Create a scipy.sparse.coo_matrix from a Series with MultiIndex . Use `row_levels` and `column_levels` to determine the row and column coordinates respectively . With arguments `sort_labels`.", "question_id": 40794}
{"snippet": "Series.sparse.to_coo(row_levels=(0,), column_levels=(1,), sort_labels=False)", "intent": "Create a scipy.sparse.coo_matrix from a Series with MultiIndex . Use `row_levels` and `column_levels` to determine the row and column coordinates respectively . With arguments `sort_labels`.", "question_id": 40795}
{"snippet": "Series.squeeze()", "intent": "Squeeze 1 dimensional `axis` objects into scalars .", "question_id": 40796}
{"snippet": "Series.squeeze(axis=None)", "intent": "Squeeze 1 dimensional `axis` objects into scalars .", "question_id": 40797}
{"snippet": "Series.squeeze()", "intent": "Squeeze 1 dimensional `axis` objects into scalars .", "question_id": 40798}
{"snippet": "Series.squeeze(axis=None)", "intent": "Squeeze 1 dimensional `axis` objects into scalars .", "question_id": 40799}
{"snippet": "Series.squeeze()", "intent": "Squeeze 1 dimensional `axis` objects into scalars .", "question_id": 40800}
{"snippet": "Series.squeeze(axis=None)", "intent": "Squeeze 1 dimensional `axis` objects into scalars .", "question_id": 40801}
{"snippet": "Series.std(**kwargs)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`.", "question_id": 40802}
{"snippet": "Series.std(**kwargs, axis=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`.", "question_id": 40803}
{"snippet": "Series.std(**kwargs, skipna=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 40804}
{"snippet": "Series.std(**kwargs, level=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 40805}
{"snippet": "Series.std(**kwargs, ddof=1)", "intent": "Return sample standard deviation over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 40806}
{"snippet": "Series.std(**kwargs, numeric_only=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 40807}
{"snippet": "Series.std(**kwargs, axis=None, skipna=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 40808}
{"snippet": "Series.std(**kwargs, axis=None, level=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 40809}
{"snippet": "Series.std(**kwargs, axis=None, ddof=1)", "intent": "Return sample standard deviation over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 40810}
{"snippet": "Series.std(**kwargs, axis=None, numeric_only=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 40811}
{"snippet": "Series.std(**kwargs)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`.", "question_id": 40812}
{"snippet": "Series.std(**kwargs, axis=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`.", "question_id": 40813}
{"snippet": "Series.std(**kwargs, skipna=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 40814}
{"snippet": "Series.std(**kwargs, level=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 40815}
{"snippet": "Series.std(**kwargs, ddof=1)", "intent": "Return sample standard deviation over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 40816}
{"snippet": "Series.std(**kwargs, numeric_only=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 40817}
{"snippet": "Series.std(**kwargs, axis=None, skipna=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 40818}
{"snippet": "Series.std(**kwargs, axis=None, level=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 40819}
{"snippet": "Series.std(**kwargs, axis=None, ddof=1)", "intent": "Return sample standard deviation over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 40820}
{"snippet": "Series.std(**kwargs, axis=None, numeric_only=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 40821}
{"snippet": "Series.std(**kwargs)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`.", "question_id": 40822}
{"snippet": "Series.std(**kwargs, axis=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`.", "question_id": 40823}
{"snippet": "Series.std(**kwargs, skipna=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 40824}
{"snippet": "Series.std(**kwargs, level=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 40825}
{"snippet": "Series.std(**kwargs, ddof=1)", "intent": "Return sample standard deviation over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 40826}
{"snippet": "Series.std(**kwargs, numeric_only=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 40827}
{"snippet": "Series.std(**kwargs, axis=None, skipna=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 40828}
{"snippet": "Series.std(**kwargs, axis=None, level=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 40829}
{"snippet": "Series.std(**kwargs, axis=None, ddof=1)", "intent": "Return sample standard deviation over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 40830}
{"snippet": "Series.std(**kwargs, axis=None, numeric_only=None)", "intent": "Return sample standard deviation over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 40831}
{"snippet": "Series.str.capitalize()", "intent": "Convert strings in the Series/Index to be capitalized .", "question_id": 40832}
{"snippet": "Series.str.capitalize()", "intent": "Convert strings in the Series/Index to be capitalized .", "question_id": 40833}
{"snippet": "Series.str.capitalize()", "intent": "Convert strings in the Series/Index to be capitalized .", "question_id": 40834}
{"snippet": "Series.str.casefold()", "intent": "Convert strings in the Series/Index to be casefolded .", "question_id": 40835}
{"snippet": "Series.str.casefold()", "intent": "Convert strings in the Series/Index to be casefolded .", "question_id": 40836}
{"snippet": "Series.str.casefold()", "intent": "Convert strings in the Series/Index to be casefolded .", "question_id": 40837}
{"snippet": "Series.str.cat()", "intent": "Concatenate strings in the Series/Index with given separator .", "question_id": 40838}
{"snippet": "Series.str.cat(others=None)", "intent": "Concatenate strings in the Series/Index with given separator . If `others` is specified , this function concatenates the Series/Index and elements of others element-wise .", "question_id": 40839}
{"snippet": "Series.str.cat(sep=None)", "intent": "Concatenate strings in the Series/Index with given separator . If others is not passed , then all values in the Series/Index are concatenated into a single string with a given `sep` .", "question_id": 40840}
{"snippet": "Series.str.cat(na_rep=None)", "intent": "Concatenate strings in the Series/Index with given separator . Using `na_rep` , they can be given a representation :", "question_id": 40841}
{"snippet": "Series.str.cat(join='left')", "intent": "Concatenate strings in the Series/Index with given separator . With arguments `join`.", "question_id": 40842}
{"snippet": "Series.str.cat(others=None, sep=None)", "intent": "Concatenate strings in the Series/Index with given separator . If `others` is specified , this function concatenates the Series/Index and elements of others element-wise . If others is not passed , then all values in the Series/Index are concatenated into a single string with a given `sep` .", "question_id": 40843}
{"snippet": "Series.str.cat(others=None, na_rep=None)", "intent": "Concatenate strings in the Series/Index with given separator . If `others` is specified , this function concatenates the Series/Index and elements of others element-wise . Using `na_rep` , they can be given a representation :", "question_id": 40844}
{"snippet": "Series.str.cat(others=None, join='left')", "intent": "Concatenate strings in the Series/Index with given separator . If `others` is specified , this function concatenates the Series/Index and elements of others element-wise . With arguments `join`.", "question_id": 40845}
{"snippet": "Series.str.cat(sep=None, na_rep=None)", "intent": "Concatenate strings in the Series/Index with given separator . If others is not passed , then all values in the Series/Index are concatenated into a single string with a given `sep` . Using `na_rep` , they can be given a representation :", "question_id": 40846}
{"snippet": "Series.str.cat(sep=None, join='left')", "intent": "Concatenate strings in the Series/Index with given separator . If others is not passed , then all values in the Series/Index are concatenated into a single string with a given `sep` . With arguments `join`.", "question_id": 40847}
{"snippet": "Series.str.cat()", "intent": "Concatenate strings in the Series/Index with given separator .", "question_id": 40848}
{"snippet": "Series.str.cat(others=None)", "intent": "Concatenate strings in the Series/Index with given separator . If `others` is specified , this function concatenates the Series/Index and elements of others element-wise .", "question_id": 40849}
{"snippet": "Series.str.cat(sep=None)", "intent": "Concatenate strings in the Series/Index with given separator . If others is not passed , then all values in the Series/Index are concatenated into a single string with a given `sep` .", "question_id": 40850}
{"snippet": "Series.str.cat(na_rep=None)", "intent": "Concatenate strings in the Series/Index with given separator . Using `na_rep` , they can be given a representation :", "question_id": 40851}
{"snippet": "Series.str.cat(join='left')", "intent": "Concatenate strings in the Series/Index with given separator . With arguments `join`.", "question_id": 40852}
{"snippet": "Series.str.cat(others=None, sep=None)", "intent": "Concatenate strings in the Series/Index with given separator . If `others` is specified , this function concatenates the Series/Index and elements of others element-wise . If others is not passed , then all values in the Series/Index are concatenated into a single string with a given `sep` .", "question_id": 40853}
{"snippet": "Series.str.cat(others=None, na_rep=None)", "intent": "Concatenate strings in the Series/Index with given separator . If `others` is specified , this function concatenates the Series/Index and elements of others element-wise . Using `na_rep` , they can be given a representation :", "question_id": 40854}
{"snippet": "Series.str.cat(others=None, join='left')", "intent": "Concatenate strings in the Series/Index with given separator . If `others` is specified , this function concatenates the Series/Index and elements of others element-wise . With arguments `join`.", "question_id": 40855}
{"snippet": "Series.str.cat(sep=None, na_rep=None)", "intent": "Concatenate strings in the Series/Index with given separator . If others is not passed , then all values in the Series/Index are concatenated into a single string with a given `sep` . Using `na_rep` , they can be given a representation :", "question_id": 40856}
{"snippet": "Series.str.cat(sep=None, join='left')", "intent": "Concatenate strings in the Series/Index with given separator . If others is not passed , then all values in the Series/Index are concatenated into a single string with a given `sep` . With arguments `join`.", "question_id": 40857}
{"snippet": "Series.str.cat()", "intent": "Concatenate strings in the Series/Index with given separator .", "question_id": 40858}
{"snippet": "Series.str.cat(others=None)", "intent": "Concatenate strings in the Series/Index with given separator . If `others` is specified , this function concatenates the Series/Index and elements of others element-wise .", "question_id": 40859}
{"snippet": "Series.str.cat(sep=None)", "intent": "Concatenate strings in the Series/Index with given separator . If others is not passed , then all values in the Series/Index are concatenated into a single string with a given `sep` .", "question_id": 40860}
{"snippet": "Series.str.cat(na_rep=None)", "intent": "Concatenate strings in the Series/Index with given separator . Using `na_rep` , they can be given a representation :", "question_id": 40861}
{"snippet": "Series.str.cat(join='left')", "intent": "Concatenate strings in the Series/Index with given separator . With arguments `join`.", "question_id": 40862}
{"snippet": "Series.str.cat(others=None, sep=None)", "intent": "Concatenate strings in the Series/Index with given separator . If `others` is specified , this function concatenates the Series/Index and elements of others element-wise . If others is not passed , then all values in the Series/Index are concatenated into a single string with a given `sep` .", "question_id": 40863}
{"snippet": "Series.str.cat(others=None, na_rep=None)", "intent": "Concatenate strings in the Series/Index with given separator . If `others` is specified , this function concatenates the Series/Index and elements of others element-wise . Using `na_rep` , they can be given a representation :", "question_id": 40864}
{"snippet": "Series.str.cat(others=None, join='left')", "intent": "Concatenate strings in the Series/Index with given separator . If `others` is specified , this function concatenates the Series/Index and elements of others element-wise . With arguments `join`.", "question_id": 40865}
{"snippet": "Series.str.cat(sep=None, na_rep=None)", "intent": "Concatenate strings in the Series/Index with given separator . If others is not passed , then all values in the Series/Index are concatenated into a single string with a given `sep` . Using `na_rep` , they can be given a representation :", "question_id": 40866}
{"snippet": "Series.str.cat(sep=None, join='left')", "intent": "Concatenate strings in the Series/Index with given separator . If others is not passed , then all values in the Series/Index are concatenated into a single string with a given `sep` . With arguments `join`.", "question_id": 40867}
{"snippet": "Series.str.center(width)", "intent": "Pad left and right side of strings in the Series/Index . With arguments `width`.", "question_id": 40868}
{"snippet": "Series.str.center(width, fillchar=' ')", "intent": "Pad left and right side of strings in the Series/Index . With arguments `width`, `fillchar`.", "question_id": 40869}
{"snippet": "Series.str.center(width)", "intent": "Pad left and right side of strings in the Series/Index . With arguments `width`.", "question_id": 40870}
{"snippet": "Series.str.center(width, fillchar=' ')", "intent": "Pad left and right side of strings in the Series/Index . With arguments `width`, `fillchar`.", "question_id": 40871}
{"snippet": "Series.str.center(width)", "intent": "Pad left and right side of strings in the Series/Index . With arguments `width`.", "question_id": 40872}
{"snippet": "Series.str.center(width, fillchar=' ')", "intent": "Pad left and right side of strings in the Series/Index . With arguments `width`, `fillchar`.", "question_id": 40873}
{"snippet": "Series.str.contains(pat)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True .", "question_id": 40874}
{"snippet": "Series.str.contains(pat, case=True)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True . Specifying `case` sensitivity using case .", "question_id": 40875}
{"snippet": "Series.str.contains(pat, flags=0)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True . Ignoring case sensitivity using `flags` with regex .", "question_id": 40876}
{"snippet": "Series.str.contains(pat, na=None)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True . Specifying `na` to be False instead of NaN replaces NaN values with False .", "question_id": 40877}
{"snippet": "Series.str.contains(pat, regex=True)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True .", "question_id": 40878}
{"snippet": "Series.str.contains(pat, case=True, flags=0)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True . Specifying `case` sensitivity using case . Ignoring case sensitivity using `flags` with regex .", "question_id": 40879}
{"snippet": "Series.str.contains(pat, case=True, na=None)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True . Specifying `case` sensitivity using case . Specifying `na` to be False instead of NaN replaces NaN values with False .", "question_id": 40880}
{"snippet": "Series.str.contains(pat, case=True, regex=True)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True . Specifying `case` sensitivity using case .", "question_id": 40881}
{"snippet": "Series.str.contains(pat, flags=0, na=None)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True . Ignoring case sensitivity using `flags` with regex . Specifying `na` to be False instead of NaN replaces NaN values with False .", "question_id": 40882}
{"snippet": "Series.str.contains(pat, flags=0, regex=True)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True . Ignoring case sensitivity using `flags` with regex .", "question_id": 40883}
{"snippet": "Series.str.contains(pat)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True .", "question_id": 40884}
{"snippet": "Series.str.contains(pat, case=True)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True . Specifying `case` sensitivity using case .", "question_id": 40885}
{"snippet": "Series.str.contains(pat, flags=0)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True . Ignoring case sensitivity using `flags` with regex .", "question_id": 40886}
{"snippet": "Series.str.contains(pat, na=None)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True . Specifying `na` to be False instead of NaN replaces NaN values with False .", "question_id": 40887}
{"snippet": "Series.str.contains(pat, regex=True)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True .", "question_id": 40888}
{"snippet": "Series.str.contains(pat, case=True, flags=0)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True . Specifying `case` sensitivity using case . Ignoring case sensitivity using `flags` with regex .", "question_id": 40889}
{"snippet": "Series.str.contains(pat, case=True, na=None)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True . Specifying `case` sensitivity using case . Specifying `na` to be False instead of NaN replaces NaN values with False .", "question_id": 40890}
{"snippet": "Series.str.contains(pat, case=True, regex=True)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True . Specifying `case` sensitivity using case .", "question_id": 40891}
{"snippet": "Series.str.contains(pat, flags=0, na=None)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True . Ignoring case sensitivity using `flags` with regex . Specifying `na` to be False instead of NaN replaces NaN values with False .", "question_id": 40892}
{"snippet": "Series.str.contains(pat, flags=0, regex=True)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True . Ignoring case sensitivity using `flags` with regex .", "question_id": 40893}
{"snippet": "Series.str.contains(pat)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True .", "question_id": 40894}
{"snippet": "Series.str.contains(pat, case=True)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True . Specifying `case` sensitivity using case .", "question_id": 40895}
{"snippet": "Series.str.contains(pat, flags=0)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True . Ignoring case sensitivity using `flags` with regex .", "question_id": 40896}
{"snippet": "Series.str.contains(pat, na=None)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True . Specifying `na` to be False instead of NaN replaces NaN values with False .", "question_id": 40897}
{"snippet": "Series.str.contains(pat, regex=True)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True .", "question_id": 40898}
{"snippet": "Series.str.contains(pat, case=True, flags=0)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True . Specifying `case` sensitivity using case . Ignoring case sensitivity using `flags` with regex .", "question_id": 40899}
{"snippet": "Series.str.contains(pat, case=True, na=None)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True . Specifying `case` sensitivity using case . Specifying `na` to be False instead of NaN replaces NaN values with False .", "question_id": 40900}
{"snippet": "Series.str.contains(pat, case=True, regex=True)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True . Specifying `case` sensitivity using case .", "question_id": 40901}
{"snippet": "Series.str.contains(pat, flags=0, na=None)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True . Ignoring case sensitivity using `flags` with regex . Specifying `na` to be False instead of NaN replaces NaN values with False .", "question_id": 40902}
{"snippet": "Series.str.contains(pat, flags=0, regex=True)", "intent": "Test if pattern or `regex` is contained within a string of a Series or Index . Ensure `pat` is a not a literal pattern when regex is set to True . Ignoring case sensitivity using `flags` with regex .", "question_id": 40903}
{"snippet": "Series.str.count(pat)", "intent": "Count occurrences of pattern in each string of the Series/Index . Some characters need to be escaped when passing in `pat` .", "question_id": 40904}
{"snippet": "Series.str.count(pat, flags=0)", "intent": "Count occurrences of pattern in each string of the Series/Index . Some characters need to be escaped when passing in `pat` . With arguments `flags`.", "question_id": 40905}
{"snippet": "Series.str.count(pat)", "intent": "Count occurrences of pattern in each string of the Series/Index . Some characters need to be escaped when passing in `pat` .", "question_id": 40906}
{"snippet": "Series.str.count(pat, flags=0)", "intent": "Count occurrences of pattern in each string of the Series/Index . Some characters need to be escaped when passing in `pat` . With arguments `flags`.", "question_id": 40907}
{"snippet": "Series.str.count(pat)", "intent": "Count occurrences of pattern in each string of the Series/Index . Some characters need to be escaped when passing in `pat` .", "question_id": 40908}
{"snippet": "Series.str.count(pat, flags=0)", "intent": "Count occurrences of pattern in each string of the Series/Index . Some characters need to be escaped when passing in `pat` . With arguments `flags`.", "question_id": 40909}
{"snippet": "Series.str.decode(encoding)", "intent": "Decode character string in the Series/Index using indicated `encoding` .", "question_id": 40910}
{"snippet": "Series.str.decode(encoding, errors='strict')", "intent": "Decode character string in the Series/Index using indicated `encoding` . With arguments `errors`.", "question_id": 40911}
{"snippet": "Series.str.decode(encoding)", "intent": "Decode character string in the Series/Index using indicated `encoding` .", "question_id": 40912}
{"snippet": "Series.str.decode(encoding, errors='strict')", "intent": "Decode character string in the Series/Index using indicated `encoding` . With arguments `errors`.", "question_id": 40913}
{"snippet": "Series.str.decode(encoding)", "intent": "Decode character string in the Series/Index using indicated `encoding` .", "question_id": 40914}
{"snippet": "Series.str.decode(encoding, errors='strict')", "intent": "Decode character string in the Series/Index using indicated `encoding` . With arguments `errors`.", "question_id": 40915}
{"snippet": "Series.str.encode(encoding)", "intent": "Encode character string in the Series/Index using indicated `encoding` .", "question_id": 40916}
{"snippet": "Series.str.encode(encoding, errors='strict')", "intent": "Encode character string in the Series/Index using indicated `encoding` . With arguments `errors`.", "question_id": 40917}
{"snippet": "Series.str.encode(encoding)", "intent": "Encode character string in the Series/Index using indicated `encoding` .", "question_id": 40918}
{"snippet": "Series.str.encode(encoding, errors='strict')", "intent": "Encode character string in the Series/Index using indicated `encoding` . With arguments `errors`.", "question_id": 40919}
{"snippet": "Series.str.encode(encoding)", "intent": "Encode character string in the Series/Index using indicated `encoding` .", "question_id": 40920}
{"snippet": "Series.str.encode(encoding, errors='strict')", "intent": "Encode character string in the Series/Index using indicated `encoding` . With arguments `errors`.", "question_id": 40921}
{"snippet": "Series.str.endswith(pat)", "intent": "Test if the end of each string element matches a pattern . With arguments `pat`.", "question_id": 40922}
{"snippet": "Series.str.endswith(pat, na=None)", "intent": "Test if the end of each string element matches a pattern . Specifying `na` to be False instead of NaN . With arguments `pat`.", "question_id": 40923}
{"snippet": "Series.str.endswith(pat)", "intent": "Test if the end of each string element matches a pattern . With arguments `pat`.", "question_id": 40924}
{"snippet": "Series.str.endswith(pat, na=None)", "intent": "Test if the end of each string element matches a pattern . Specifying `na` to be False instead of NaN . With arguments `pat`.", "question_id": 40925}
{"snippet": "Series.str.endswith(pat)", "intent": "Test if the end of each string element matches a pattern . With arguments `pat`.", "question_id": 40926}
{"snippet": "Series.str.endswith(pat, na=None)", "intent": "Test if the end of each string element matches a pattern . Specifying `na` to be False instead of NaN . With arguments `pat`.", "question_id": 40927}
{"snippet": "Series.str.extract(pat)", "intent": "Extract capture groups in the regex `pat` as columns in a DataFrame .", "question_id": 40928}
{"snippet": "Series.str.extract(pat, flags=0)", "intent": "Extract capture groups in the regex `pat` as columns in a DataFrame . With arguments `flags`.", "question_id": 40929}
{"snippet": "Series.str.extract(pat, expand=True)", "intent": "Extract capture groups in the regex `pat` as columns in a DataFrame . With arguments `expand`.", "question_id": 40930}
{"snippet": "Series.str.extract(pat, flags=0, expand=True)", "intent": "Extract capture groups in the regex `pat` as columns in a DataFrame . With arguments `flags`, `expand`.", "question_id": 40931}
{"snippet": "Series.str.extract(pat)", "intent": "Extract capture groups in the regex `pat` as columns in a DataFrame .", "question_id": 40932}
{"snippet": "Series.str.extract(pat, flags=0)", "intent": "Extract capture groups in the regex `pat` as columns in a DataFrame . With arguments `flags`.", "question_id": 40933}
{"snippet": "Series.str.extract(pat, expand=True)", "intent": "Extract capture groups in the regex `pat` as columns in a DataFrame . With arguments `expand`.", "question_id": 40934}
{"snippet": "Series.str.extract(pat, flags=0, expand=True)", "intent": "Extract capture groups in the regex `pat` as columns in a DataFrame . With arguments `flags`, `expand`.", "question_id": 40935}
{"snippet": "Series.str.extract(pat)", "intent": "Extract capture groups in the regex `pat` as columns in a DataFrame .", "question_id": 40936}
{"snippet": "Series.str.extract(pat, flags=0)", "intent": "Extract capture groups in the regex `pat` as columns in a DataFrame . With arguments `flags`.", "question_id": 40937}
{"snippet": "Series.str.extract(pat, expand=True)", "intent": "Extract capture groups in the regex `pat` as columns in a DataFrame . With arguments `expand`.", "question_id": 40938}
{"snippet": "Series.str.extract(pat, flags=0, expand=True)", "intent": "Extract capture groups in the regex `pat` as columns in a DataFrame . With arguments `flags`, `expand`.", "question_id": 40939}
{"snippet": "Series.str.extractall(pat)", "intent": "Extract capture groups in the regex `pat` as columns in DataFrame .", "question_id": 40940}
{"snippet": "Series.str.extractall(pat, flags=0)", "intent": "Extract capture groups in the regex `pat` as columns in DataFrame . With arguments `flags`.", "question_id": 40941}
{"snippet": "Series.str.extractall(pat)", "intent": "Extract capture groups in the regex `pat` as columns in DataFrame .", "question_id": 40942}
{"snippet": "Series.str.extractall(pat, flags=0)", "intent": "Extract capture groups in the regex `pat` as columns in DataFrame . With arguments `flags`.", "question_id": 40943}
{"snippet": "Series.str.extractall(pat)", "intent": "Extract capture groups in the regex `pat` as columns in DataFrame .", "question_id": 40944}
{"snippet": "Series.str.extractall(pat, flags=0)", "intent": "Extract capture groups in the regex `pat` as columns in DataFrame . With arguments `flags`.", "question_id": 40945}
{"snippet": "Series.str.find(sub)", "intent": "Return lowest indexes in each strings in the Series/Index . With arguments `sub`.", "question_id": 40946}
{"snippet": "Series.str.find(sub, start=0)", "intent": "Return lowest indexes in each strings in the Series/Index . Each of returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 40947}
{"snippet": "Series.str.find(sub, end=None)", "intent": "Return lowest indexes in each strings in the Series/Index . Each of returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 40948}
{"snippet": "Series.str.find(sub, start=0, end=None)", "intent": "Return lowest indexes in each strings in the Series/Index . Each of returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 40949}
{"snippet": "Series.str.find(sub)", "intent": "Return lowest indexes in each strings in the Series/Index . With arguments `sub`.", "question_id": 40950}
{"snippet": "Series.str.find(sub, start=0)", "intent": "Return lowest indexes in each strings in the Series/Index . Each of returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 40951}
{"snippet": "Series.str.find(sub, end=None)", "intent": "Return lowest indexes in each strings in the Series/Index . Each of returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 40952}
{"snippet": "Series.str.find(sub, start=0, end=None)", "intent": "Return lowest indexes in each strings in the Series/Index . Each of returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 40953}
{"snippet": "Series.str.find(sub)", "intent": "Return lowest indexes in each strings in the Series/Index . With arguments `sub`.", "question_id": 40954}
{"snippet": "Series.str.find(sub, start=0)", "intent": "Return lowest indexes in each strings in the Series/Index . Each of returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 40955}
{"snippet": "Series.str.find(sub, end=None)", "intent": "Return lowest indexes in each strings in the Series/Index . Each of returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 40956}
{"snippet": "Series.str.find(sub, start=0, end=None)", "intent": "Return lowest indexes in each strings in the Series/Index . Each of returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 40957}
{"snippet": "Series.str.findall(pat)", "intent": "Find all occurrences of pattern or regular expression in the Series/Index . With arguments `pat`.", "question_id": 40958}
{"snippet": "Series.str.findall(pat, flags=0)", "intent": "Find all occurrences of pattern or regular expression in the Series/Index . With arguments `pat`, `flags`.", "question_id": 40959}
{"snippet": "Series.str.findall(pat)", "intent": "Find all occurrences of pattern or regular expression in the Series/Index . With arguments `pat`.", "question_id": 40960}
{"snippet": "Series.str.findall(pat, flags=0)", "intent": "Find all occurrences of pattern or regular expression in the Series/Index . With arguments `pat`, `flags`.", "question_id": 40961}
{"snippet": "Series.str.findall(pat)", "intent": "Find all occurrences of pattern or regular expression in the Series/Index . With arguments `pat`.", "question_id": 40962}
{"snippet": "Series.str.findall(pat, flags=0)", "intent": "Find all occurrences of pattern or regular expression in the Series/Index . With arguments `pat`, `flags`.", "question_id": 40963}
{"snippet": "Series.str.fullmatch(pat)", "intent": "Determine if each string entirely matches a regular expression . With arguments `pat`.", "question_id": 40964}
{"snippet": "Series.str.fullmatch(pat, case=True)", "intent": "Determine if each string entirely matches a regular expression . With arguments `pat`, `case`.", "question_id": 40965}
{"snippet": "Series.str.fullmatch(pat, flags=0)", "intent": "Determine if each string entirely matches a regular expression . With arguments `pat`, `flags`.", "question_id": 40966}
{"snippet": "Series.str.fullmatch(pat, na=None)", "intent": "Determine if each string entirely matches a regular expression . With arguments `pat`, `na`.", "question_id": 40967}
{"snippet": "Series.str.fullmatch(pat, case=True, flags=0)", "intent": "Determine if each string entirely matches a regular expression . With arguments `pat`, `case`, `flags`.", "question_id": 40968}
{"snippet": "Series.str.fullmatch(pat, case=True, na=None)", "intent": "Determine if each string entirely matches a regular expression . With arguments `pat`, `case`, `na`.", "question_id": 40969}
{"snippet": "Series.str.fullmatch(pat, flags=0, na=None)", "intent": "Determine if each string entirely matches a regular expression . With arguments `pat`, `flags`, `na`.", "question_id": 40970}
{"snippet": "Series.str.fullmatch(pat, case=True, flags=0, na=None)", "intent": "Determine if each string entirely matches a regular expression . With arguments `pat`, `case`, `flags`, `na`.", "question_id": 40971}
{"snippet": "Series.str.fullmatch(pat)", "intent": "Determine if each string entirely matches a regular expression . With arguments `pat`.", "question_id": 40972}
{"snippet": "Series.str.fullmatch(pat, case=True)", "intent": "Determine if each string entirely matches a regular expression . With arguments `pat`, `case`.", "question_id": 40973}
{"snippet": "Series.str.fullmatch(pat, flags=0)", "intent": "Determine if each string entirely matches a regular expression . With arguments `pat`, `flags`.", "question_id": 40974}
{"snippet": "Series.str.fullmatch(pat, na=None)", "intent": "Determine if each string entirely matches a regular expression . With arguments `pat`, `na`.", "question_id": 40975}
{"snippet": "Series.str.fullmatch(pat, case=True, flags=0)", "intent": "Determine if each string entirely matches a regular expression . With arguments `pat`, `case`, `flags`.", "question_id": 40976}
{"snippet": "Series.str.fullmatch(pat, case=True, na=None)", "intent": "Determine if each string entirely matches a regular expression . With arguments `pat`, `case`, `na`.", "question_id": 40977}
{"snippet": "Series.str.fullmatch(pat, flags=0, na=None)", "intent": "Determine if each string entirely matches a regular expression . With arguments `pat`, `flags`, `na`.", "question_id": 40978}
{"snippet": "Series.str.fullmatch(pat, case=True, flags=0, na=None)", "intent": "Determine if each string entirely matches a regular expression . With arguments `pat`, `case`, `flags`, `na`.", "question_id": 40979}
{"snippet": "Series.str.fullmatch(pat)", "intent": "Determine if each string entirely matches a regular expression . With arguments `pat`.", "question_id": 40980}
{"snippet": "Series.str.fullmatch(pat, case=True)", "intent": "Determine if each string entirely matches a regular expression . With arguments `pat`, `case`.", "question_id": 40981}
{"snippet": "Series.str.fullmatch(pat, flags=0)", "intent": "Determine if each string entirely matches a regular expression . With arguments `pat`, `flags`.", "question_id": 40982}
{"snippet": "Series.str.fullmatch(pat, na=None)", "intent": "Determine if each string entirely matches a regular expression . With arguments `pat`, `na`.", "question_id": 40983}
{"snippet": "Series.str.fullmatch(pat, case=True, flags=0)", "intent": "Determine if each string entirely matches a regular expression . With arguments `pat`, `case`, `flags`.", "question_id": 40984}
{"snippet": "Series.str.fullmatch(pat, case=True, na=None)", "intent": "Determine if each string entirely matches a regular expression . With arguments `pat`, `case`, `na`.", "question_id": 40985}
{"snippet": "Series.str.fullmatch(pat, flags=0, na=None)", "intent": "Determine if each string entirely matches a regular expression . With arguments `pat`, `flags`, `na`.", "question_id": 40986}
{"snippet": "Series.str.fullmatch(pat, case=True, flags=0, na=None)", "intent": "Determine if each string entirely matches a regular expression . With arguments `pat`, `case`, `flags`, `na`.", "question_id": 40987}
{"snippet": "Series.str.get(i)", "intent": "Extract element from each component at specified position . With arguments `i`.", "question_id": 40988}
{"snippet": "Series.str.get(i)", "intent": "Extract element from each component at specified position . With arguments `i`.", "question_id": 40989}
{"snippet": "Series.str.get(i)", "intent": "Extract element from each component at specified position . With arguments `i`.", "question_id": 40990}
{"snippet": "Series.str.get_dummies()", "intent": "Return DataFrame of dummy/indicator variables for Series .", "question_id": 40991}
{"snippet": "Series.str.get_dummies(sep='|')", "intent": "Return DataFrame of dummy/indicator variables for Series . Each string in Series is split by `sep` and returned as a DataFrame of dummy/indicator variables .", "question_id": 40992}
{"snippet": "Series.str.get_dummies()", "intent": "Return DataFrame of dummy/indicator variables for Series .", "question_id": 40993}
{"snippet": "Series.str.get_dummies(sep='|')", "intent": "Return DataFrame of dummy/indicator variables for Series . Each string in Series is split by `sep` and returned as a DataFrame of dummy/indicator variables .", "question_id": 40994}
{"snippet": "Series.str.get_dummies()", "intent": "Return DataFrame of dummy/indicator variables for Series .", "question_id": 40995}
{"snippet": "Series.str.get_dummies(sep='|')", "intent": "Return DataFrame of dummy/indicator variables for Series . Each string in Series is split by `sep` and returned as a DataFrame of dummy/indicator variables .", "question_id": 40996}
{"snippet": "Series.str()", "intent": "Vectorized string functions for Series and Index .", "question_id": 40997}
{"snippet": "Series.str()", "intent": "Vectorized string functions for Series and Index .", "question_id": 40998}
{"snippet": "Series.str()", "intent": "Vectorized string functions for Series and Index .", "question_id": 40999}
{"snippet": "Series.str.index(sub)", "intent": "Return lowest indexes in each string in Series/Index . With arguments `sub`.", "question_id": 41000}
{"snippet": "Series.str.index(sub, start=0)", "intent": "Return lowest indexes in each string in Series/Index . Each of the returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41001}
{"snippet": "Series.str.index(sub, end=None)", "intent": "Return lowest indexes in each string in Series/Index . Each of the returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41002}
{"snippet": "Series.str.index(sub, start=0, end=None)", "intent": "Return lowest indexes in each string in Series/Index . Each of the returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41003}
{"snippet": "Series.str.index(sub)", "intent": "Return lowest indexes in each string in Series/Index . With arguments `sub`.", "question_id": 41004}
{"snippet": "Series.str.index(sub, start=0)", "intent": "Return lowest indexes in each string in Series/Index . Each of the returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41005}
{"snippet": "Series.str.index(sub, end=None)", "intent": "Return lowest indexes in each string in Series/Index . Each of the returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41006}
{"snippet": "Series.str.index(sub, start=0, end=None)", "intent": "Return lowest indexes in each string in Series/Index . Each of the returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41007}
{"snippet": "Series.str.index(sub)", "intent": "Return lowest indexes in each string in Series/Index . With arguments `sub`.", "question_id": 41008}
{"snippet": "Series.str.index(sub, start=0)", "intent": "Return lowest indexes in each string in Series/Index . Each of the returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41009}
{"snippet": "Series.str.index(sub, end=None)", "intent": "Return lowest indexes in each string in Series/Index . Each of the returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41010}
{"snippet": "Series.str.index(sub, start=0, end=None)", "intent": "Return lowest indexes in each string in Series/Index . Each of the returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41011}
{"snippet": "Series.str.isalnum()", "intent": "Check whether all characters in each string are alphanumeric .", "question_id": 41012}
{"snippet": "Series.str.isalnum()", "intent": "Check whether all characters in each string are alphanumeric .", "question_id": 41013}
{"snippet": "Series.str.isalnum()", "intent": "Check whether all characters in each string are alphanumeric .", "question_id": 41014}
{"snippet": "Series.str.isalpha()", "intent": "Check whether all characters in each string are alphabetic .", "question_id": 41015}
{"snippet": "Series.str.isalpha()", "intent": "Check whether all characters in each string are alphabetic .", "question_id": 41016}
{"snippet": "Series.str.isalpha()", "intent": "Check whether all characters in each string are alphabetic .", "question_id": 41017}
{"snippet": "Series.str.isdecimal()", "intent": "Check whether all characters in each string are decimal .", "question_id": 41018}
{"snippet": "Series.str.isdecimal()", "intent": "Check whether all characters in each string are decimal .", "question_id": 41019}
{"snippet": "Series.str.isdecimal()", "intent": "Check whether all characters in each string are decimal .", "question_id": 41020}
{"snippet": "Series.str.isdigit()", "intent": "Check whether all characters in each string are digits .", "question_id": 41021}
{"snippet": "Series.str.isdigit()", "intent": "Check whether all characters in each string are digits .", "question_id": 41022}
{"snippet": "Series.str.isdigit()", "intent": "Check whether all characters in each string are digits .", "question_id": 41023}
{"snippet": "Series.str.islower()", "intent": "Check whether all characters in each string are lowercase .", "question_id": 41024}
{"snippet": "Series.str.islower()", "intent": "Check whether all characters in each string are lowercase .", "question_id": 41025}
{"snippet": "Series.str.islower()", "intent": "Check whether all characters in each string are lowercase .", "question_id": 41026}
{"snippet": "Series.str.isnumeric()", "intent": "Check whether all characters in each string are numeric .", "question_id": 41027}
{"snippet": "Series.str.isnumeric()", "intent": "Check whether all characters in each string are numeric .", "question_id": 41028}
{"snippet": "Series.str.isnumeric()", "intent": "Check whether all characters in each string are numeric .", "question_id": 41029}
{"snippet": "Series.str.isspace()", "intent": "Check whether all characters in each string are whitespace .", "question_id": 41030}
{"snippet": "Series.str.isspace()", "intent": "Check whether all characters in each string are whitespace .", "question_id": 41031}
{"snippet": "Series.str.isspace()", "intent": "Check whether all characters in each string are whitespace .", "question_id": 41032}
{"snippet": "Series.str.istitle()", "intent": "Check whether all characters in each string are titlecase .", "question_id": 41033}
{"snippet": "Series.str.istitle()", "intent": "Check whether all characters in each string are titlecase .", "question_id": 41034}
{"snippet": "Series.str.istitle()", "intent": "Check whether all characters in each string are titlecase .", "question_id": 41035}
{"snippet": "Series.str.isupper()", "intent": "Check whether all characters in each string are uppercase .", "question_id": 41036}
{"snippet": "Series.str.isupper()", "intent": "Check whether all characters in each string are uppercase .", "question_id": 41037}
{"snippet": "Series.str.isupper()", "intent": "Check whether all characters in each string are uppercase .", "question_id": 41038}
{"snippet": "Series.str.join(sep)", "intent": "Join lists contained as elements in the Series/Index with passed delimiter . With arguments `sep`.", "question_id": 41039}
{"snippet": "Series.str.join(sep)", "intent": "Join lists contained as elements in the Series/Index with passed delimiter . With arguments `sep`.", "question_id": 41040}
{"snippet": "Series.str.join(sep)", "intent": "Join lists contained as elements in the Series/Index with passed delimiter . With arguments `sep`.", "question_id": 41041}
{"snippet": "Series.str.len()", "intent": "Compute the length of each element in the Series/Index .", "question_id": 41042}
{"snippet": "Series.str.len()", "intent": "Compute the length of each element in the Series/Index .", "question_id": 41043}
{"snippet": "Series.str.len()", "intent": "Compute the length of each element in the Series/Index .", "question_id": 41044}
{"snippet": "Series.str.ljust(width)", "intent": "Pad right side of strings in the Series/Index . With arguments `width`.", "question_id": 41045}
{"snippet": "Series.str.ljust(width, fillchar=' ')", "intent": "Pad right side of strings in the Series/Index . With arguments `width`, `fillchar`.", "question_id": 41046}
{"snippet": "Series.str.ljust(width)", "intent": "Pad right side of strings in the Series/Index . With arguments `width`.", "question_id": 41047}
{"snippet": "Series.str.ljust(width, fillchar=' ')", "intent": "Pad right side of strings in the Series/Index . With arguments `width`, `fillchar`.", "question_id": 41048}
{"snippet": "Series.str.ljust(width)", "intent": "Pad right side of strings in the Series/Index . With arguments `width`.", "question_id": 41049}
{"snippet": "Series.str.ljust(width, fillchar=' ')", "intent": "Pad right side of strings in the Series/Index . With arguments `width`, `fillchar`.", "question_id": 41050}
{"snippet": "Series.str.lower()", "intent": "Convert strings in the Series/Index to lowercase .", "question_id": 41051}
{"snippet": "Series.str.lower()", "intent": "Convert strings in the Series/Index to lowercase .", "question_id": 41052}
{"snippet": "Series.str.lower()", "intent": "Convert strings in the Series/Index to lowercase .", "question_id": 41053}
{"snippet": "Series.str.lstrip()", "intent": "Remove leading characters .", "question_id": 41054}
{"snippet": "Series.str.lstrip(to_strip=None)", "intent": "Remove leading characters . With arguments `to_strip`.", "question_id": 41055}
{"snippet": "Series.str.lstrip()", "intent": "Remove leading characters .", "question_id": 41056}
{"snippet": "Series.str.lstrip(to_strip=None)", "intent": "Remove leading characters . With arguments `to_strip`.", "question_id": 41057}
{"snippet": "Series.str.lstrip()", "intent": "Remove leading characters .", "question_id": 41058}
{"snippet": "Series.str.lstrip(to_strip=None)", "intent": "Remove leading characters . With arguments `to_strip`.", "question_id": 41059}
{"snippet": "Series.str.match(pat)", "intent": "Determine if each string starts with a match of a regular expression . With arguments `pat`.", "question_id": 41060}
{"snippet": "Series.str.match(pat, case=True)", "intent": "Determine if each string starts with a match of a regular expression . With arguments `pat`, `case`.", "question_id": 41061}
{"snippet": "Series.str.match(pat, flags=0)", "intent": "Determine if each string starts with a match of a regular expression . With arguments `pat`, `flags`.", "question_id": 41062}
{"snippet": "Series.str.match(pat, na=None)", "intent": "Determine if each string starts with a match of a regular expression . With arguments `pat`, `na`.", "question_id": 41063}
{"snippet": "Series.str.match(pat, case=True, flags=0)", "intent": "Determine if each string starts with a match of a regular expression . With arguments `pat`, `case`, `flags`.", "question_id": 41064}
{"snippet": "Series.str.match(pat, case=True, na=None)", "intent": "Determine if each string starts with a match of a regular expression . With arguments `pat`, `case`, `na`.", "question_id": 41065}
{"snippet": "Series.str.match(pat, flags=0, na=None)", "intent": "Determine if each string starts with a match of a regular expression . With arguments `pat`, `flags`, `na`.", "question_id": 41066}
{"snippet": "Series.str.match(pat, case=True, flags=0, na=None)", "intent": "Determine if each string starts with a match of a regular expression . With arguments `pat`, `case`, `flags`, `na`.", "question_id": 41067}
{"snippet": "Series.str.match(pat)", "intent": "Determine if each string starts with a match of a regular expression . With arguments `pat`.", "question_id": 41068}
{"snippet": "Series.str.match(pat, case=True)", "intent": "Determine if each string starts with a match of a regular expression . With arguments `pat`, `case`.", "question_id": 41069}
{"snippet": "Series.str.match(pat, flags=0)", "intent": "Determine if each string starts with a match of a regular expression . With arguments `pat`, `flags`.", "question_id": 41070}
{"snippet": "Series.str.match(pat, na=None)", "intent": "Determine if each string starts with a match of a regular expression . With arguments `pat`, `na`.", "question_id": 41071}
{"snippet": "Series.str.match(pat, case=True, flags=0)", "intent": "Determine if each string starts with a match of a regular expression . With arguments `pat`, `case`, `flags`.", "question_id": 41072}
{"snippet": "Series.str.match(pat, case=True, na=None)", "intent": "Determine if each string starts with a match of a regular expression . With arguments `pat`, `case`, `na`.", "question_id": 41073}
{"snippet": "Series.str.match(pat, flags=0, na=None)", "intent": "Determine if each string starts with a match of a regular expression . With arguments `pat`, `flags`, `na`.", "question_id": 41074}
{"snippet": "Series.str.match(pat, case=True, flags=0, na=None)", "intent": "Determine if each string starts with a match of a regular expression . With arguments `pat`, `case`, `flags`, `na`.", "question_id": 41075}
{"snippet": "Series.str.match(pat)", "intent": "Determine if each string starts with a match of a regular expression . With arguments `pat`.", "question_id": 41076}
{"snippet": "Series.str.match(pat, case=True)", "intent": "Determine if each string starts with a match of a regular expression . With arguments `pat`, `case`.", "question_id": 41077}
{"snippet": "Series.str.match(pat, flags=0)", "intent": "Determine if each string starts with a match of a regular expression . With arguments `pat`, `flags`.", "question_id": 41078}
{"snippet": "Series.str.match(pat, na=None)", "intent": "Determine if each string starts with a match of a regular expression . With arguments `pat`, `na`.", "question_id": 41079}
{"snippet": "Series.str.match(pat, case=True, flags=0)", "intent": "Determine if each string starts with a match of a regular expression . With arguments `pat`, `case`, `flags`.", "question_id": 41080}
{"snippet": "Series.str.match(pat, case=True, na=None)", "intent": "Determine if each string starts with a match of a regular expression . With arguments `pat`, `case`, `na`.", "question_id": 41081}
{"snippet": "Series.str.match(pat, flags=0, na=None)", "intent": "Determine if each string starts with a match of a regular expression . With arguments `pat`, `flags`, `na`.", "question_id": 41082}
{"snippet": "Series.str.match(pat, case=True, flags=0, na=None)", "intent": "Determine if each string starts with a match of a regular expression . With arguments `pat`, `case`, `flags`, `na`.", "question_id": 41083}
{"snippet": "Series.str.normalize(form)", "intent": "Return the Unicode normal `form` for the strings in the Series/Index .", "question_id": 41084}
{"snippet": "Series.str.normalize(form)", "intent": "Return the Unicode normal `form` for the strings in the Series/Index .", "question_id": 41085}
{"snippet": "Series.str.normalize(form)", "intent": "Return the Unicode normal `form` for the strings in the Series/Index .", "question_id": 41086}
{"snippet": "Series.str.pad(width)", "intent": "Pad strings in the Series/Index up to `width` .", "question_id": 41087}
{"snippet": "Series.str.pad(width, side='left')", "intent": "Pad strings in the Series/Index up to `width` . With arguments `side`.", "question_id": 41088}
{"snippet": "Series.str.pad(width, fillchar=' ')", "intent": "Pad strings in the Series/Index up to `width` . With arguments `fillchar`.", "question_id": 41089}
{"snippet": "Series.str.pad(width, side='left', fillchar=' ')", "intent": "Pad strings in the Series/Index up to `width` . With arguments `side`, `fillchar`.", "question_id": 41090}
{"snippet": "Series.str.pad(width)", "intent": "Pad strings in the Series/Index up to `width` .", "question_id": 41091}
{"snippet": "Series.str.pad(width, side='left')", "intent": "Pad strings in the Series/Index up to `width` . With arguments `side`.", "question_id": 41092}
{"snippet": "Series.str.pad(width, fillchar=' ')", "intent": "Pad strings in the Series/Index up to `width` . With arguments `fillchar`.", "question_id": 41093}
{"snippet": "Series.str.pad(width, side='left', fillchar=' ')", "intent": "Pad strings in the Series/Index up to `width` . With arguments `side`, `fillchar`.", "question_id": 41094}
{"snippet": "Series.str.pad(width)", "intent": "Pad strings in the Series/Index up to `width` .", "question_id": 41095}
{"snippet": "Series.str.pad(width, side='left')", "intent": "Pad strings in the Series/Index up to `width` . With arguments `side`.", "question_id": 41096}
{"snippet": "Series.str.pad(width, fillchar=' ')", "intent": "Pad strings in the Series/Index up to `width` . With arguments `fillchar`.", "question_id": 41097}
{"snippet": "Series.str.pad(width, side='left', fillchar=' ')", "intent": "Pad strings in the Series/Index up to `width` . With arguments `side`, `fillchar`.", "question_id": 41098}
{"snippet": "Series.str.partition()", "intent": "Split the string at the first occurrence of `sep` .", "question_id": 41099}
{"snippet": "Series.str.partition(sep=' ')", "intent": "Split the string at the first occurrence of `sep` .", "question_id": 41100}
{"snippet": "Series.str.partition(expand=True)", "intent": "Split the string at the first occurrence of `sep` . With arguments `expand`.", "question_id": 41101}
{"snippet": "Series.str.partition(sep=' ', expand=True)", "intent": "Split the string at the first occurrence of `sep` . With arguments `expand`.", "question_id": 41102}
{"snippet": "Series.str.partition()", "intent": "Split the string at the first occurrence of `sep` .", "question_id": 41103}
{"snippet": "Series.str.partition(sep=' ')", "intent": "Split the string at the first occurrence of `sep` .", "question_id": 41104}
{"snippet": "Series.str.partition(expand=True)", "intent": "Split the string at the first occurrence of `sep` . With arguments `expand`.", "question_id": 41105}
{"snippet": "Series.str.partition(sep=' ', expand=True)", "intent": "Split the string at the first occurrence of `sep` . With arguments `expand`.", "question_id": 41106}
{"snippet": "Series.str.partition()", "intent": "Split the string at the first occurrence of `sep` .", "question_id": 41107}
{"snippet": "Series.str.partition(sep=' ')", "intent": "Split the string at the first occurrence of `sep` .", "question_id": 41108}
{"snippet": "Series.str.partition(expand=True)", "intent": "Split the string at the first occurrence of `sep` . With arguments `expand`.", "question_id": 41109}
{"snippet": "Series.str.partition(sep=' ', expand=True)", "intent": "Split the string at the first occurrence of `sep` . With arguments `expand`.", "question_id": 41110}
{"snippet": "Series.str.repeat(repeats)", "intent": "Duplicate each string in the Series or Index . Single int `repeats` string in Series", "question_id": 41111}
{"snippet": "Series.str.repeat(repeats)", "intent": "Duplicate each string in the Series or Index . Single int `repeats` string in Series", "question_id": 41112}
{"snippet": "Series.str.repeat(repeats)", "intent": "Duplicate each string in the Series or Index . Single int `repeats` string in Series", "question_id": 41113}
{"snippet": "Series.str.replace(pat, repl)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) .", "question_id": 41114}
{"snippet": "Series.str.replace(pat, repl, n=- 1)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) . With arguments `n`.", "question_id": 41115}
{"snippet": "Series.str.replace(pat, repl, case=None)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) . Use of `case` , flags , or regex=False with a compiled regex will raise an error .", "question_id": 41116}
{"snippet": "Series.str.replace(pat, repl, flags=0)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) .", "question_id": 41117}
{"snippet": "Series.str.replace(pat, repl, regex=None)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) . Equivalent to str.replace ( ) or re.sub ( ) , depending on the `regex` value .", "question_id": 41118}
{"snippet": "Series.str.replace(pat, repl, n=- 1, case=None)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) . Use of `case` , flags , or regex=False with a compiled regex will raise an error . With arguments `n`.", "question_id": 41119}
{"snippet": "Series.str.replace(pat, repl, n=- 1, flags=0)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) . With arguments `n`.", "question_id": 41120}
{"snippet": "Series.str.replace(pat, repl, n=- 1, regex=None)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) . Equivalent to str.replace ( ) or re.sub ( ) , depending on the `regex` value . With arguments `n`.", "question_id": 41121}
{"snippet": "Series.str.replace(pat, repl, case=None, flags=0)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) . Use of `case` , flags , or regex=False with a compiled regex will raise an error .", "question_id": 41122}
{"snippet": "Series.str.replace(pat, repl, case=None, regex=None)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) . Use of `case` , flags , or regex=False with a compiled regex will raise an error . Equivalent to str.replace ( ) or re.sub ( ) , depending on the `regex` value .", "question_id": 41123}
{"snippet": "Series.str.replace(pat, repl)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) .", "question_id": 41124}
{"snippet": "Series.str.replace(pat, repl, n=- 1)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) . With arguments `n`.", "question_id": 41125}
{"snippet": "Series.str.replace(pat, repl, case=None)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) . Use of `case` , flags , or regex=False with a compiled regex will raise an error .", "question_id": 41126}
{"snippet": "Series.str.replace(pat, repl, flags=0)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) .", "question_id": 41127}
{"snippet": "Series.str.replace(pat, repl, regex=None)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) . Equivalent to str.replace ( ) or re.sub ( ) , depending on the `regex` value .", "question_id": 41128}
{"snippet": "Series.str.replace(pat, repl, n=- 1, case=None)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) . Use of `case` , flags , or regex=False with a compiled regex will raise an error . With arguments `n`.", "question_id": 41129}
{"snippet": "Series.str.replace(pat, repl, n=- 1, flags=0)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) . With arguments `n`.", "question_id": 41130}
{"snippet": "Series.str.replace(pat, repl, n=- 1, regex=None)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) . Equivalent to str.replace ( ) or re.sub ( ) , depending on the `regex` value . With arguments `n`.", "question_id": 41131}
{"snippet": "Series.str.replace(pat, repl, case=None, flags=0)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) . Use of `case` , flags , or regex=False with a compiled regex will raise an error .", "question_id": 41132}
{"snippet": "Series.str.replace(pat, repl, case=None, regex=None)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) . Use of `case` , flags , or regex=False with a compiled regex will raise an error . Equivalent to str.replace ( ) or re.sub ( ) , depending on the `regex` value .", "question_id": 41133}
{"snippet": "Series.str.replace(pat, repl)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) .", "question_id": 41134}
{"snippet": "Series.str.replace(pat, repl, n=- 1)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) . With arguments `n`.", "question_id": 41135}
{"snippet": "Series.str.replace(pat, repl, case=None)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) . Use of `case` , flags , or regex=False with a compiled regex will raise an error .", "question_id": 41136}
{"snippet": "Series.str.replace(pat, repl, flags=0)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) .", "question_id": 41137}
{"snippet": "Series.str.replace(pat, repl, regex=None)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) . Equivalent to str.replace ( ) or re.sub ( ) , depending on the `regex` value .", "question_id": 41138}
{"snippet": "Series.str.replace(pat, repl, n=- 1, case=None)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) . Use of `case` , flags , or regex=False with a compiled regex will raise an error . With arguments `n`.", "question_id": 41139}
{"snippet": "Series.str.replace(pat, repl, n=- 1, flags=0)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) . With arguments `n`.", "question_id": 41140}
{"snippet": "Series.str.replace(pat, repl, n=- 1, regex=None)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) . Equivalent to str.replace ( ) or re.sub ( ) , depending on the `regex` value . With arguments `n`.", "question_id": 41141}
{"snippet": "Series.str.replace(pat, repl, case=None, flags=0)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) . Use of `case` , flags , or regex=False with a compiled regex will raise an error .", "question_id": 41142}
{"snippet": "Series.str.replace(pat, repl, case=None, regex=None)", "intent": "Replace each occurrence of pattern/regex in the Series/Index . When `pat` is a compiled regex , all `flags` should be included in the compiled regex . When `repl` is a string , it replaces matching regex patterns as with re.sub ( ) . Use of `case` , flags , or regex=False with a compiled regex will raise an error . Equivalent to str.replace ( ) or re.sub ( ) , depending on the `regex` value .", "question_id": 41143}
{"snippet": "Series.str.rfind(sub)", "intent": "Return highest indexes in each strings in the Series/Index . With arguments `sub`.", "question_id": 41144}
{"snippet": "Series.str.rfind(sub, start=0)", "intent": "Return highest indexes in each strings in the Series/Index . Each of returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41145}
{"snippet": "Series.str.rfind(sub, end=None)", "intent": "Return highest indexes in each strings in the Series/Index . Each of returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41146}
{"snippet": "Series.str.rfind(sub, start=0, end=None)", "intent": "Return highest indexes in each strings in the Series/Index . Each of returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41147}
{"snippet": "Series.str.rfind(sub)", "intent": "Return highest indexes in each strings in the Series/Index . With arguments `sub`.", "question_id": 41148}
{"snippet": "Series.str.rfind(sub, start=0)", "intent": "Return highest indexes in each strings in the Series/Index . Each of returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41149}
{"snippet": "Series.str.rfind(sub, end=None)", "intent": "Return highest indexes in each strings in the Series/Index . Each of returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41150}
{"snippet": "Series.str.rfind(sub, start=0, end=None)", "intent": "Return highest indexes in each strings in the Series/Index . Each of returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41151}
{"snippet": "Series.str.rfind(sub)", "intent": "Return highest indexes in each strings in the Series/Index . With arguments `sub`.", "question_id": 41152}
{"snippet": "Series.str.rfind(sub, start=0)", "intent": "Return highest indexes in each strings in the Series/Index . Each of returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41153}
{"snippet": "Series.str.rfind(sub, end=None)", "intent": "Return highest indexes in each strings in the Series/Index . Each of returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41154}
{"snippet": "Series.str.rfind(sub, start=0, end=None)", "intent": "Return highest indexes in each strings in the Series/Index . Each of returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41155}
{"snippet": "Series.str.rindex(sub)", "intent": "Return highest indexes in each string in Series/Index . With arguments `sub`.", "question_id": 41156}
{"snippet": "Series.str.rindex(sub, start=0)", "intent": "Return highest indexes in each string in Series/Index . Each of the returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41157}
{"snippet": "Series.str.rindex(sub, end=None)", "intent": "Return highest indexes in each string in Series/Index . Each of the returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41158}
{"snippet": "Series.str.rindex(sub, start=0, end=None)", "intent": "Return highest indexes in each string in Series/Index . Each of the returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41159}
{"snippet": "Series.str.rindex(sub)", "intent": "Return highest indexes in each string in Series/Index . With arguments `sub`.", "question_id": 41160}
{"snippet": "Series.str.rindex(sub, start=0)", "intent": "Return highest indexes in each string in Series/Index . Each of the returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41161}
{"snippet": "Series.str.rindex(sub, end=None)", "intent": "Return highest indexes in each string in Series/Index . Each of the returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41162}
{"snippet": "Series.str.rindex(sub, start=0, end=None)", "intent": "Return highest indexes in each string in Series/Index . Each of the returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41163}
{"snippet": "Series.str.rindex(sub)", "intent": "Return highest indexes in each string in Series/Index . With arguments `sub`.", "question_id": 41164}
{"snippet": "Series.str.rindex(sub, start=0)", "intent": "Return highest indexes in each string in Series/Index . Each of the returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41165}
{"snippet": "Series.str.rindex(sub, end=None)", "intent": "Return highest indexes in each string in Series/Index . Each of the returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41166}
{"snippet": "Series.str.rindex(sub, start=0, end=None)", "intent": "Return highest indexes in each string in Series/Index . Each of the returned indexes corresponds to the position where the substring is fully contained between [ `start` : `end` ] . With arguments `sub`.", "question_id": 41167}
{"snippet": "Series.str.rjust(width)", "intent": "Pad left side of strings in the Series/Index . With arguments `width`.", "question_id": 41168}
{"snippet": "Series.str.rjust(width, fillchar=' ')", "intent": "Pad left side of strings in the Series/Index . With arguments `width`, `fillchar`.", "question_id": 41169}
{"snippet": "Series.str.rjust(width)", "intent": "Pad left side of strings in the Series/Index . With arguments `width`.", "question_id": 41170}
{"snippet": "Series.str.rjust(width, fillchar=' ')", "intent": "Pad left side of strings in the Series/Index . With arguments `width`, `fillchar`.", "question_id": 41171}
{"snippet": "Series.str.rjust(width)", "intent": "Pad left side of strings in the Series/Index . With arguments `width`.", "question_id": 41172}
{"snippet": "Series.str.rjust(width, fillchar=' ')", "intent": "Pad left side of strings in the Series/Index . With arguments `width`, `fillchar`.", "question_id": 41173}
{"snippet": "Series.str.rpartition()", "intent": "Split the string at the last occurrence of `sep` .", "question_id": 41174}
{"snippet": "Series.str.rpartition(sep=' ')", "intent": "Split the string at the last occurrence of `sep` .", "question_id": 41175}
{"snippet": "Series.str.rpartition(expand=True)", "intent": "Split the string at the last occurrence of `sep` . With arguments `expand`.", "question_id": 41176}
{"snippet": "Series.str.rpartition(sep=' ', expand=True)", "intent": "Split the string at the last occurrence of `sep` . With arguments `expand`.", "question_id": 41177}
{"snippet": "Series.str.rpartition()", "intent": "Split the string at the last occurrence of `sep` .", "question_id": 41178}
{"snippet": "Series.str.rpartition(sep=' ')", "intent": "Split the string at the last occurrence of `sep` .", "question_id": 41179}
{"snippet": "Series.str.rpartition(expand=True)", "intent": "Split the string at the last occurrence of `sep` . With arguments `expand`.", "question_id": 41180}
{"snippet": "Series.str.rpartition(sep=' ', expand=True)", "intent": "Split the string at the last occurrence of `sep` . With arguments `expand`.", "question_id": 41181}
{"snippet": "Series.str.rpartition()", "intent": "Split the string at the last occurrence of `sep` .", "question_id": 41182}
{"snippet": "Series.str.rpartition(sep=' ')", "intent": "Split the string at the last occurrence of `sep` .", "question_id": 41183}
{"snippet": "Series.str.rpartition(expand=True)", "intent": "Split the string at the last occurrence of `sep` . With arguments `expand`.", "question_id": 41184}
{"snippet": "Series.str.rpartition(sep=' ', expand=True)", "intent": "Split the string at the last occurrence of `sep` . With arguments `expand`.", "question_id": 41185}
{"snippet": "Series.str.rsplit()", "intent": "Split strings around given separator/delimiter .", "question_id": 41186}
{"snippet": "Series.str.rsplit(pat=None)", "intent": "Split strings around given separator/delimiter . The `pat` parameter can be used to split by other characters .", "question_id": 41187}
{"snippet": "Series.str.rsplit(n=- 1)", "intent": "Split strings around given separator/delimiter . The handling of the `n` keyword depends on the number of found splits :", "question_id": 41188}
{"snippet": "Series.str.rsplit(expand=False)", "intent": "Split strings around given separator/delimiter . When using expand=True , the split elements will `expand` out into separate columns .", "question_id": 41189}
{"snippet": "Series.str.rsplit(pat=None, n=- 1)", "intent": "Split strings around given separator/delimiter . The `pat` parameter can be used to split by other characters . The handling of the `n` keyword depends on the number of found splits :", "question_id": 41190}
{"snippet": "Series.str.rsplit(pat=None, expand=False)", "intent": "Split strings around given separator/delimiter . The `pat` parameter can be used to split by other characters . When using expand=True , the split elements will `expand` out into separate columns .", "question_id": 41191}
{"snippet": "Series.str.rsplit(n=- 1, expand=False)", "intent": "Split strings around given separator/delimiter . The handling of the `n` keyword depends on the number of found splits : When using expand=True , the split elements will `expand` out into separate columns .", "question_id": 41192}
{"snippet": "Series.str.rsplit(pat=None, n=- 1, expand=False)", "intent": "Split strings around given separator/delimiter . The `pat` parameter can be used to split by other characters . The handling of the `n` keyword depends on the number of found splits : When using expand=True , the split elements will `expand` out into separate columns .", "question_id": 41193}
{"snippet": "Series.str.rsplit()", "intent": "Split strings around given separator/delimiter .", "question_id": 41194}
{"snippet": "Series.str.rsplit(pat=None)", "intent": "Split strings around given separator/delimiter . The `pat` parameter can be used to split by other characters .", "question_id": 41195}
{"snippet": "Series.str.rsplit(n=- 1)", "intent": "Split strings around given separator/delimiter . The handling of the `n` keyword depends on the number of found splits :", "question_id": 41196}
{"snippet": "Series.str.rsplit(expand=False)", "intent": "Split strings around given separator/delimiter . When using expand=True , the split elements will `expand` out into separate columns .", "question_id": 41197}
{"snippet": "Series.str.rsplit(pat=None, n=- 1)", "intent": "Split strings around given separator/delimiter . The `pat` parameter can be used to split by other characters . The handling of the `n` keyword depends on the number of found splits :", "question_id": 41198}
{"snippet": "Series.str.rsplit(pat=None, expand=False)", "intent": "Split strings around given separator/delimiter . The `pat` parameter can be used to split by other characters . When using expand=True , the split elements will `expand` out into separate columns .", "question_id": 41199}
{"snippet": "Series.str.rsplit(n=- 1, expand=False)", "intent": "Split strings around given separator/delimiter . The handling of the `n` keyword depends on the number of found splits : When using expand=True , the split elements will `expand` out into separate columns .", "question_id": 41200}
{"snippet": "Series.str.rsplit(pat=None, n=- 1, expand=False)", "intent": "Split strings around given separator/delimiter . The `pat` parameter can be used to split by other characters . The handling of the `n` keyword depends on the number of found splits : When using expand=True , the split elements will `expand` out into separate columns .", "question_id": 41201}
{"snippet": "Series.str.rsplit()", "intent": "Split strings around given separator/delimiter .", "question_id": 41202}
{"snippet": "Series.str.rsplit(pat=None)", "intent": "Split strings around given separator/delimiter . The `pat` parameter can be used to split by other characters .", "question_id": 41203}
{"snippet": "Series.str.rsplit(n=- 1)", "intent": "Split strings around given separator/delimiter . The handling of the `n` keyword depends on the number of found splits :", "question_id": 41204}
{"snippet": "Series.str.rsplit(expand=False)", "intent": "Split strings around given separator/delimiter . When using expand=True , the split elements will `expand` out into separate columns .", "question_id": 41205}
{"snippet": "Series.str.rsplit(pat=None, n=- 1)", "intent": "Split strings around given separator/delimiter . The `pat` parameter can be used to split by other characters . The handling of the `n` keyword depends on the number of found splits :", "question_id": 41206}
{"snippet": "Series.str.rsplit(pat=None, expand=False)", "intent": "Split strings around given separator/delimiter . The `pat` parameter can be used to split by other characters . When using expand=True , the split elements will `expand` out into separate columns .", "question_id": 41207}
{"snippet": "Series.str.rsplit(n=- 1, expand=False)", "intent": "Split strings around given separator/delimiter . The handling of the `n` keyword depends on the number of found splits : When using expand=True , the split elements will `expand` out into separate columns .", "question_id": 41208}
{"snippet": "Series.str.rsplit(pat=None, n=- 1, expand=False)", "intent": "Split strings around given separator/delimiter . The `pat` parameter can be used to split by other characters . The handling of the `n` keyword depends on the number of found splits : When using expand=True , the split elements will `expand` out into separate columns .", "question_id": 41209}
{"snippet": "Series.str.rstrip()", "intent": "Remove trailing characters .", "question_id": 41210}
{"snippet": "Series.str.rstrip(to_strip=None)", "intent": "Remove trailing characters . With arguments `to_strip`.", "question_id": 41211}
{"snippet": "Series.str.rstrip()", "intent": "Remove trailing characters .", "question_id": 41212}
{"snippet": "Series.str.rstrip(to_strip=None)", "intent": "Remove trailing characters . With arguments `to_strip`.", "question_id": 41213}
{"snippet": "Series.str.rstrip()", "intent": "Remove trailing characters .", "question_id": 41214}
{"snippet": "Series.str.rstrip(to_strip=None)", "intent": "Remove trailing characters . With arguments `to_strip`.", "question_id": 41215}
{"snippet": "Series.str.slice()", "intent": "Slice substrings from each element in the Series or Index .", "question_id": 41216}
{"snippet": "Series.str.slice(start=None)", "intent": "Slice substrings from each element in the Series or Index . With arguments `start`.", "question_id": 41217}
{"snippet": "Series.str.slice(stop=None)", "intent": "Slice substrings from each element in the Series or Index . With arguments `stop`.", "question_id": 41218}
{"snippet": "Series.str.slice(step=None)", "intent": "Slice substrings from each element in the Series or Index . With arguments `step`.", "question_id": 41219}
{"snippet": "Series.str.slice(start=None, stop=None)", "intent": "Slice substrings from each element in the Series or Index . With arguments `start`, `stop`.", "question_id": 41220}
{"snippet": "Series.str.slice(start=None, step=None)", "intent": "Slice substrings from each element in the Series or Index . With arguments `start`, `step`.", "question_id": 41221}
{"snippet": "Series.str.slice(stop=None, step=None)", "intent": "Slice substrings from each element in the Series or Index . With arguments `stop`, `step`.", "question_id": 41222}
{"snippet": "Series.str.slice(start=None, stop=None, step=None)", "intent": "Slice substrings from each element in the Series or Index . With arguments `start`, `stop`, `step`.", "question_id": 41223}
{"snippet": "Series.str.slice()", "intent": "Slice substrings from each element in the Series or Index .", "question_id": 41224}
{"snippet": "Series.str.slice(start=None)", "intent": "Slice substrings from each element in the Series or Index . With arguments `start`.", "question_id": 41225}
{"snippet": "Series.str.slice(stop=None)", "intent": "Slice substrings from each element in the Series or Index . With arguments `stop`.", "question_id": 41226}
{"snippet": "Series.str.slice(step=None)", "intent": "Slice substrings from each element in the Series or Index . With arguments `step`.", "question_id": 41227}
{"snippet": "Series.str.slice(start=None, stop=None)", "intent": "Slice substrings from each element in the Series or Index . With arguments `start`, `stop`.", "question_id": 41228}
{"snippet": "Series.str.slice(start=None, step=None)", "intent": "Slice substrings from each element in the Series or Index . With arguments `start`, `step`.", "question_id": 41229}
{"snippet": "Series.str.slice(stop=None, step=None)", "intent": "Slice substrings from each element in the Series or Index . With arguments `stop`, `step`.", "question_id": 41230}
{"snippet": "Series.str.slice(start=None, stop=None, step=None)", "intent": "Slice substrings from each element in the Series or Index . With arguments `start`, `stop`, `step`.", "question_id": 41231}
{"snippet": "Series.str.slice()", "intent": "Slice substrings from each element in the Series or Index .", "question_id": 41232}
{"snippet": "Series.str.slice(start=None)", "intent": "Slice substrings from each element in the Series or Index . With arguments `start`.", "question_id": 41233}
{"snippet": "Series.str.slice(stop=None)", "intent": "Slice substrings from each element in the Series or Index . With arguments `stop`.", "question_id": 41234}
{"snippet": "Series.str.slice(step=None)", "intent": "Slice substrings from each element in the Series or Index . With arguments `step`.", "question_id": 41235}
{"snippet": "Series.str.slice(start=None, stop=None)", "intent": "Slice substrings from each element in the Series or Index . With arguments `start`, `stop`.", "question_id": 41236}
{"snippet": "Series.str.slice(start=None, step=None)", "intent": "Slice substrings from each element in the Series or Index . With arguments `start`, `step`.", "question_id": 41237}
{"snippet": "Series.str.slice(stop=None, step=None)", "intent": "Slice substrings from each element in the Series or Index . With arguments `stop`, `step`.", "question_id": 41238}
{"snippet": "Series.str.slice(start=None, stop=None, step=None)", "intent": "Slice substrings from each element in the Series or Index . With arguments `start`, `stop`, `step`.", "question_id": 41239}
{"snippet": "Series.str.slice_replace()", "intent": "Replace a positional slice of a string with another value .", "question_id": 41240}
{"snippet": "Series.str.slice_replace(start=None)", "intent": "Replace a positional slice of a string with another value . Specify just `start` , meaning replace start until the end of the string with `repl` .", "question_id": 41241}
{"snippet": "Series.str.slice_replace(stop=None)", "intent": "Replace a positional slice of a string with another value . Specify just `stop` , meaning the start of the string to stop is replaced with repl , and the rest of the string is included .", "question_id": 41242}
{"snippet": "Series.str.slice_replace(repl=None)", "intent": "Replace a positional slice of a string with another value . Specify just `start` , meaning replace start until the end of the string with `repl` .", "question_id": 41243}
{"snippet": "Series.str.slice_replace(start=None, stop=None)", "intent": "Replace a positional slice of a string with another value . Specify just `start` , meaning replace start until the end of the string with `repl` . Specify just `stop` , meaning the start of the string to stop is replaced with repl , and the rest of the string is included .", "question_id": 41244}
{"snippet": "Series.str.slice_replace(start=None, repl=None)", "intent": "Replace a positional slice of a string with another value . Specify just `start` , meaning replace start until the end of the string with `repl` .", "question_id": 41245}
{"snippet": "Series.str.slice_replace(stop=None, repl=None)", "intent": "Replace a positional slice of a string with another value . Specify just `stop` , meaning the start of the string to stop is replaced with repl , and the rest of the string is included . Specify just `start` , meaning replace start until the end of the string with `repl` .", "question_id": 41246}
{"snippet": "Series.str.slice_replace(start=None, stop=None, repl=None)", "intent": "Replace a positional slice of a string with another value . Specify just `start` , meaning replace start until the end of the string with `repl` . Specify just `stop` , meaning the start of the string to stop is replaced with repl , and the rest of the string is included .", "question_id": 41247}
{"snippet": "Series.str.slice_replace()", "intent": "Replace a positional slice of a string with another value .", "question_id": 41248}
{"snippet": "Series.str.slice_replace(start=None)", "intent": "Replace a positional slice of a string with another value . Specify just `start` , meaning replace start until the end of the string with `repl` .", "question_id": 41249}
{"snippet": "Series.str.slice_replace(stop=None)", "intent": "Replace a positional slice of a string with another value . Specify just `stop` , meaning the start of the string to stop is replaced with repl , and the rest of the string is included .", "question_id": 41250}
{"snippet": "Series.str.slice_replace(repl=None)", "intent": "Replace a positional slice of a string with another value . Specify just `start` , meaning replace start until the end of the string with `repl` .", "question_id": 41251}
{"snippet": "Series.str.slice_replace(start=None, stop=None)", "intent": "Replace a positional slice of a string with another value . Specify just `start` , meaning replace start until the end of the string with `repl` . Specify just `stop` , meaning the start of the string to stop is replaced with repl , and the rest of the string is included .", "question_id": 41252}
{"snippet": "Series.str.slice_replace(start=None, repl=None)", "intent": "Replace a positional slice of a string with another value . Specify just `start` , meaning replace start until the end of the string with `repl` .", "question_id": 41253}
{"snippet": "Series.str.slice_replace(stop=None, repl=None)", "intent": "Replace a positional slice of a string with another value . Specify just `stop` , meaning the start of the string to stop is replaced with repl , and the rest of the string is included . Specify just `start` , meaning replace start until the end of the string with `repl` .", "question_id": 41254}
{"snippet": "Series.str.slice_replace(start=None, stop=None, repl=None)", "intent": "Replace a positional slice of a string with another value . Specify just `start` , meaning replace start until the end of the string with `repl` . Specify just `stop` , meaning the start of the string to stop is replaced with repl , and the rest of the string is included .", "question_id": 41255}
{"snippet": "Series.str.slice_replace()", "intent": "Replace a positional slice of a string with another value .", "question_id": 41256}
{"snippet": "Series.str.slice_replace(start=None)", "intent": "Replace a positional slice of a string with another value . Specify just `start` , meaning replace start until the end of the string with `repl` .", "question_id": 41257}
{"snippet": "Series.str.slice_replace(stop=None)", "intent": "Replace a positional slice of a string with another value . Specify just `stop` , meaning the start of the string to stop is replaced with repl , and the rest of the string is included .", "question_id": 41258}
{"snippet": "Series.str.slice_replace(repl=None)", "intent": "Replace a positional slice of a string with another value . Specify just `start` , meaning replace start until the end of the string with `repl` .", "question_id": 41259}
{"snippet": "Series.str.slice_replace(start=None, stop=None)", "intent": "Replace a positional slice of a string with another value . Specify just `start` , meaning replace start until the end of the string with `repl` . Specify just `stop` , meaning the start of the string to stop is replaced with repl , and the rest of the string is included .", "question_id": 41260}
{"snippet": "Series.str.slice_replace(start=None, repl=None)", "intent": "Replace a positional slice of a string with another value . Specify just `start` , meaning replace start until the end of the string with `repl` .", "question_id": 41261}
{"snippet": "Series.str.slice_replace(stop=None, repl=None)", "intent": "Replace a positional slice of a string with another value . Specify just `stop` , meaning the start of the string to stop is replaced with repl , and the rest of the string is included . Specify just `start` , meaning replace start until the end of the string with `repl` .", "question_id": 41262}
{"snippet": "Series.str.slice_replace(start=None, stop=None, repl=None)", "intent": "Replace a positional slice of a string with another value . Specify just `start` , meaning replace start until the end of the string with `repl` . Specify just `stop` , meaning the start of the string to stop is replaced with repl , and the rest of the string is included .", "question_id": 41263}
{"snippet": "Series.str.split()", "intent": "Split strings around given separator/delimiter .", "question_id": 41264}
{"snippet": "Series.str.split(pat=None)", "intent": "Split strings around given separator/delimiter . The `pat` parameter can be used to split by other characters .", "question_id": 41265}
{"snippet": "Series.str.split(n=- 1)", "intent": "Split strings around given separator/delimiter . The handling of the `n` keyword depends on the number of found splits :", "question_id": 41266}
{"snippet": "Series.str.split(expand=False)", "intent": "Split strings around given separator/delimiter . When using expand=True , the split elements will `expand` out into separate columns .", "question_id": 41267}
{"snippet": "Series.str.split(pat=None, n=- 1)", "intent": "Split strings around given separator/delimiter . The `pat` parameter can be used to split by other characters . The handling of the `n` keyword depends on the number of found splits :", "question_id": 41268}
{"snippet": "Series.str.split(pat=None, expand=False)", "intent": "Split strings around given separator/delimiter . The `pat` parameter can be used to split by other characters . When using expand=True , the split elements will `expand` out into separate columns .", "question_id": 41269}
{"snippet": "Series.str.split(n=- 1, expand=False)", "intent": "Split strings around given separator/delimiter . The handling of the `n` keyword depends on the number of found splits : When using expand=True , the split elements will `expand` out into separate columns .", "question_id": 41270}
{"snippet": "Series.str.split(pat=None, n=- 1, expand=False)", "intent": "Split strings around given separator/delimiter . The `pat` parameter can be used to split by other characters . The handling of the `n` keyword depends on the number of found splits : When using expand=True , the split elements will `expand` out into separate columns .", "question_id": 41271}
{"snippet": "Series.str.split()", "intent": "Split strings around given separator/delimiter .", "question_id": 41272}
{"snippet": "Series.str.split(pat=None)", "intent": "Split strings around given separator/delimiter . The `pat` parameter can be used to split by other characters .", "question_id": 41273}
{"snippet": "Series.str.split(n=- 1)", "intent": "Split strings around given separator/delimiter . The handling of the `n` keyword depends on the number of found splits :", "question_id": 41274}
{"snippet": "Series.str.split(expand=False)", "intent": "Split strings around given separator/delimiter . When using expand=True , the split elements will `expand` out into separate columns .", "question_id": 41275}
{"snippet": "Series.str.split(pat=None, n=- 1)", "intent": "Split strings around given separator/delimiter . The `pat` parameter can be used to split by other characters . The handling of the `n` keyword depends on the number of found splits :", "question_id": 41276}
{"snippet": "Series.str.split(pat=None, expand=False)", "intent": "Split strings around given separator/delimiter . The `pat` parameter can be used to split by other characters . When using expand=True , the split elements will `expand` out into separate columns .", "question_id": 41277}
{"snippet": "Series.str.split(n=- 1, expand=False)", "intent": "Split strings around given separator/delimiter . The handling of the `n` keyword depends on the number of found splits : When using expand=True , the split elements will `expand` out into separate columns .", "question_id": 41278}
{"snippet": "Series.str.split(pat=None, n=- 1, expand=False)", "intent": "Split strings around given separator/delimiter . The `pat` parameter can be used to split by other characters . The handling of the `n` keyword depends on the number of found splits : When using expand=True , the split elements will `expand` out into separate columns .", "question_id": 41279}
{"snippet": "Series.str.split()", "intent": "Split strings around given separator/delimiter .", "question_id": 41280}
{"snippet": "Series.str.split(pat=None)", "intent": "Split strings around given separator/delimiter . The `pat` parameter can be used to split by other characters .", "question_id": 41281}
{"snippet": "Series.str.split(n=- 1)", "intent": "Split strings around given separator/delimiter . The handling of the `n` keyword depends on the number of found splits :", "question_id": 41282}
{"snippet": "Series.str.split(expand=False)", "intent": "Split strings around given separator/delimiter . When using expand=True , the split elements will `expand` out into separate columns .", "question_id": 41283}
{"snippet": "Series.str.split(pat=None, n=- 1)", "intent": "Split strings around given separator/delimiter . The `pat` parameter can be used to split by other characters . The handling of the `n` keyword depends on the number of found splits :", "question_id": 41284}
{"snippet": "Series.str.split(pat=None, expand=False)", "intent": "Split strings around given separator/delimiter . The `pat` parameter can be used to split by other characters . When using expand=True , the split elements will `expand` out into separate columns .", "question_id": 41285}
{"snippet": "Series.str.split(n=- 1, expand=False)", "intent": "Split strings around given separator/delimiter . The handling of the `n` keyword depends on the number of found splits : When using expand=True , the split elements will `expand` out into separate columns .", "question_id": 41286}
{"snippet": "Series.str.split(pat=None, n=- 1, expand=False)", "intent": "Split strings around given separator/delimiter . The `pat` parameter can be used to split by other characters . The handling of the `n` keyword depends on the number of found splits : When using expand=True , the split elements will `expand` out into separate columns .", "question_id": 41287}
{"snippet": "Series.str.startswith(pat)", "intent": "Test if the start of each string element matches a pattern . With arguments `pat`.", "question_id": 41288}
{"snippet": "Series.str.startswith(pat, na=None)", "intent": "Test if the start of each string element matches a pattern . Specifying `na` to be False instead of NaN . With arguments `pat`.", "question_id": 41289}
{"snippet": "Series.str.startswith(pat)", "intent": "Test if the start of each string element matches a pattern . With arguments `pat`.", "question_id": 41290}
{"snippet": "Series.str.startswith(pat, na=None)", "intent": "Test if the start of each string element matches a pattern . Specifying `na` to be False instead of NaN . With arguments `pat`.", "question_id": 41291}
{"snippet": "Series.str.startswith(pat)", "intent": "Test if the start of each string element matches a pattern . With arguments `pat`.", "question_id": 41292}
{"snippet": "Series.str.startswith(pat, na=None)", "intent": "Test if the start of each string element matches a pattern . Specifying `na` to be False instead of NaN . With arguments `pat`.", "question_id": 41293}
{"snippet": "Series.str.strip()", "intent": "Remove leading and trailing characters .", "question_id": 41294}
{"snippet": "Series.str.strip(to_strip=None)", "intent": "Remove leading and trailing characters . With arguments `to_strip`.", "question_id": 41295}
{"snippet": "Series.str.strip()", "intent": "Remove leading and trailing characters .", "question_id": 41296}
{"snippet": "Series.str.strip(to_strip=None)", "intent": "Remove leading and trailing characters . With arguments `to_strip`.", "question_id": 41297}
{"snippet": "Series.str.strip()", "intent": "Remove leading and trailing characters .", "question_id": 41298}
{"snippet": "Series.str.strip(to_strip=None)", "intent": "Remove leading and trailing characters . With arguments `to_strip`.", "question_id": 41299}
{"snippet": "Series.str.swapcase()", "intent": "Convert strings in the Series/Index to be swapcased .", "question_id": 41300}
{"snippet": "Series.str.swapcase()", "intent": "Convert strings in the Series/Index to be swapcased .", "question_id": 41301}
{"snippet": "Series.str.swapcase()", "intent": "Convert strings in the Series/Index to be swapcased .", "question_id": 41302}
{"snippet": "Series.str.title()", "intent": "Convert strings in the Series/Index to titlecase .", "question_id": 41303}
{"snippet": "Series.str.title()", "intent": "Convert strings in the Series/Index to titlecase .", "question_id": 41304}
{"snippet": "Series.str.title()", "intent": "Convert strings in the Series/Index to titlecase .", "question_id": 41305}
{"snippet": "Series.str.translate(table)", "intent": "Map all characters in the string through the given mapping `table` .", "question_id": 41306}
{"snippet": "Series.str.translate(table)", "intent": "Map all characters in the string through the given mapping `table` .", "question_id": 41307}
{"snippet": "Series.str.translate(table)", "intent": "Map all characters in the string through the given mapping `table` .", "question_id": 41308}
{"snippet": "Series.str.upper()", "intent": "Convert strings in the Series/Index to uppercase .", "question_id": 41309}
{"snippet": "Series.str.upper()", "intent": "Convert strings in the Series/Index to uppercase .", "question_id": 41310}
{"snippet": "Series.str.upper()", "intent": "Convert strings in the Series/Index to uppercase .", "question_id": 41311}
{"snippet": "Series.str.wrap(width, **kwargs)", "intent": "Wrap strings in Series/Index at specified line `width` . With arguments `**kwargs`.", "question_id": 41312}
{"snippet": "Series.str.wrap(width, **kwargs)", "intent": "Wrap strings in Series/Index at specified line `width` . With arguments `**kwargs`.", "question_id": 41313}
{"snippet": "Series.str.wrap(width, **kwargs)", "intent": "Wrap strings in Series/Index at specified line `width` . With arguments `**kwargs`.", "question_id": 41314}
{"snippet": "Series.str.zfill(width)", "intent": "Pad strings in the Series/Index by prepending \u2018 0 \u2019 characters . Strings in the Series/Index are padded with \u2018 0 \u2019 characters on the left of the string to reach a total string length `width` .", "question_id": 41315}
{"snippet": "Series.str.zfill(width)", "intent": "Pad strings in the Series/Index by prepending \u2018 0 \u2019 characters . Strings in the Series/Index are padded with \u2018 0 \u2019 characters on the left of the string to reach a total string length `width` .", "question_id": 41316}
{"snippet": "Series.str.zfill(width)", "intent": "Pad strings in the Series/Index by prepending \u2018 0 \u2019 characters . Strings in the Series/Index are padded with \u2018 0 \u2019 characters on the left of the string to reach a total string length `width` .", "question_id": 41317}
{"snippet": "Series.sub(other)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) .", "question_id": 41318}
{"snippet": "Series.sub(other, level=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . With arguments `level`.", "question_id": 41319}
{"snippet": "Series.sub(other, fill_value=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . Equivalent to series - other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 41320}
{"snippet": "Series.sub(other, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . With arguments `axis`.", "question_id": 41321}
{"snippet": "Series.sub(other, level=None, fill_value=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . Equivalent to series - other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 41322}
{"snippet": "Series.sub(other, level=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . With arguments `level`, `axis`.", "question_id": 41323}
{"snippet": "Series.sub(other, fill_value=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . Equivalent to series - other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 41324}
{"snippet": "Series.sub(other, level=None, fill_value=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . Equivalent to series - other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 41325}
{"snippet": "Series.sub(other)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) .", "question_id": 41326}
{"snippet": "Series.sub(other, level=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . With arguments `level`.", "question_id": 41327}
{"snippet": "Series.sub(other, fill_value=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . Equivalent to series - other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 41328}
{"snippet": "Series.sub(other, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . With arguments `axis`.", "question_id": 41329}
{"snippet": "Series.sub(other, level=None, fill_value=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . Equivalent to series - other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 41330}
{"snippet": "Series.sub(other, level=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . With arguments `level`, `axis`.", "question_id": 41331}
{"snippet": "Series.sub(other, fill_value=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . Equivalent to series - other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 41332}
{"snippet": "Series.sub(other, level=None, fill_value=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . Equivalent to series - other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 41333}
{"snippet": "Series.sub(other)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) .", "question_id": 41334}
{"snippet": "Series.sub(other, level=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . With arguments `level`.", "question_id": 41335}
{"snippet": "Series.sub(other, fill_value=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . Equivalent to series - other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 41336}
{"snippet": "Series.sub(other, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . With arguments `axis`.", "question_id": 41337}
{"snippet": "Series.sub(other, level=None, fill_value=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . Equivalent to series - other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 41338}
{"snippet": "Series.sub(other, level=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . With arguments `level`, `axis`.", "question_id": 41339}
{"snippet": "Series.sub(other, fill_value=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . Equivalent to series - other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 41340}
{"snippet": "Series.sub(other, level=None, fill_value=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . Equivalent to series - other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 41341}
{"snippet": "Series.subtract(other)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) .", "question_id": 41342}
{"snippet": "Series.subtract(other, level=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . With arguments `level`.", "question_id": 41343}
{"snippet": "Series.subtract(other, fill_value=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . Equivalent to series - other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 41344}
{"snippet": "Series.subtract(other, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . With arguments `axis`.", "question_id": 41345}
{"snippet": "Series.subtract(other, level=None, fill_value=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . Equivalent to series - other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 41346}
{"snippet": "Series.subtract(other, level=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . With arguments `level`, `axis`.", "question_id": 41347}
{"snippet": "Series.subtract(other, fill_value=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . Equivalent to series - other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 41348}
{"snippet": "Series.subtract(other, level=None, fill_value=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . Equivalent to series - other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 41349}
{"snippet": "Series.subtract(other)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) .", "question_id": 41350}
{"snippet": "Series.subtract(other, level=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . With arguments `level`.", "question_id": 41351}
{"snippet": "Series.subtract(other, fill_value=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . Equivalent to series - other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 41352}
{"snippet": "Series.subtract(other, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . With arguments `axis`.", "question_id": 41353}
{"snippet": "Series.subtract(other, level=None, fill_value=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . Equivalent to series - other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 41354}
{"snippet": "Series.subtract(other, level=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . With arguments `level`, `axis`.", "question_id": 41355}
{"snippet": "Series.subtract(other, fill_value=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . Equivalent to series - other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 41356}
{"snippet": "Series.subtract(other, level=None, fill_value=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . Equivalent to series - other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 41357}
{"snippet": "Series.subtract(other)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) .", "question_id": 41358}
{"snippet": "Series.subtract(other, level=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . With arguments `level`.", "question_id": 41359}
{"snippet": "Series.subtract(other, fill_value=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . Equivalent to series - other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 41360}
{"snippet": "Series.subtract(other, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . With arguments `axis`.", "question_id": 41361}
{"snippet": "Series.subtract(other, level=None, fill_value=None)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . Equivalent to series - other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 41362}
{"snippet": "Series.subtract(other, level=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . With arguments `level`, `axis`.", "question_id": 41363}
{"snippet": "Series.subtract(other, fill_value=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . Equivalent to series - other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 41364}
{"snippet": "Series.subtract(other, level=None, fill_value=None, axis=0)", "intent": "Return Subtraction of series and `other` , element-wise ( binary operator sub ) . Equivalent to series - other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 41365}
{"snippet": "Series.sum(**kwargs)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 41366}
{"snippet": "Series.sum(**kwargs, axis=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 41367}
{"snippet": "Series.sum(**kwargs, skipna=None)", "intent": "Return the sum of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 41368}
{"snippet": "Series.sum(**kwargs, level=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 41369}
{"snippet": "Series.sum(**kwargs, numeric_only=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 41370}
{"snippet": "Series.sum(**kwargs, min_count=0)", "intent": "Return the sum of the values over the requested `axis` . This can be controlled with the `min_count` parameter . With arguments `**kwargs`.", "question_id": 41371}
{"snippet": "Series.sum(**kwargs, axis=None, skipna=None)", "intent": "Return the sum of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 41372}
{"snippet": "Series.sum(**kwargs, axis=None, level=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 41373}
{"snippet": "Series.sum(**kwargs, axis=None, numeric_only=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 41374}
{"snippet": "Series.sum(**kwargs, axis=None, min_count=0)", "intent": "Return the sum of the values over the requested `axis` . This can be controlled with the `min_count` parameter . With arguments `**kwargs`.", "question_id": 41375}
{"snippet": "Series.sum(**kwargs)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 41376}
{"snippet": "Series.sum(**kwargs, axis=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 41377}
{"snippet": "Series.sum(**kwargs, skipna=None)", "intent": "Return the sum of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 41378}
{"snippet": "Series.sum(**kwargs, level=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 41379}
{"snippet": "Series.sum(**kwargs, numeric_only=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 41380}
{"snippet": "Series.sum(**kwargs, min_count=0)", "intent": "Return the sum of the values over the requested `axis` . This can be controlled with the `min_count` parameter . With arguments `**kwargs`.", "question_id": 41381}
{"snippet": "Series.sum(**kwargs, axis=None, skipna=None)", "intent": "Return the sum of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 41382}
{"snippet": "Series.sum(**kwargs, axis=None, level=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 41383}
{"snippet": "Series.sum(**kwargs, axis=None, numeric_only=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 41384}
{"snippet": "Series.sum(**kwargs, axis=None, min_count=0)", "intent": "Return the sum of the values over the requested `axis` . This can be controlled with the `min_count` parameter . With arguments `**kwargs`.", "question_id": 41385}
{"snippet": "Series.sum(**kwargs)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 41386}
{"snippet": "Series.sum(**kwargs, axis=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`.", "question_id": 41387}
{"snippet": "Series.sum(**kwargs, skipna=None)", "intent": "Return the sum of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 41388}
{"snippet": "Series.sum(**kwargs, level=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 41389}
{"snippet": "Series.sum(**kwargs, numeric_only=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 41390}
{"snippet": "Series.sum(**kwargs, min_count=0)", "intent": "Return the sum of the values over the requested `axis` . This can be controlled with the `min_count` parameter . With arguments `**kwargs`.", "question_id": 41391}
{"snippet": "Series.sum(**kwargs, axis=None, skipna=None)", "intent": "Return the sum of the values over the requested `axis` . Thanks to the `skipna` parameter , min_count handles all-NA and empty series identically . With arguments `**kwargs`.", "question_id": 41392}
{"snippet": "Series.sum(**kwargs, axis=None, level=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 41393}
{"snippet": "Series.sum(**kwargs, axis=None, numeric_only=None)", "intent": "Return the sum of the values over the requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 41394}
{"snippet": "Series.sum(**kwargs, axis=None, min_count=0)", "intent": "Return the sum of the values over the requested `axis` . This can be controlled with the `min_count` parameter . With arguments `**kwargs`.", "question_id": 41395}
{"snippet": "Series.swapaxes(axis1, axis2)", "intent": "Interchange axes and swap values axes appropriately . With arguments `axis1`, `axis2`.", "question_id": 41396}
{"snippet": "Series.swapaxes(axis1, axis2, copy=True)", "intent": "Interchange axes and swap values axes appropriately . With arguments `axis1`, `axis2`, `copy`.", "question_id": 41397}
{"snippet": "Series.swapaxes(axis1, axis2)", "intent": "Interchange axes and swap values axes appropriately . With arguments `axis1`, `axis2`.", "question_id": 41398}
{"snippet": "Series.swapaxes(axis1, axis2, copy=True)", "intent": "Interchange axes and swap values axes appropriately . With arguments `axis1`, `axis2`, `copy`.", "question_id": 41399}
{"snippet": "Series.swapaxes(axis1, axis2)", "intent": "Interchange axes and swap values axes appropriately . With arguments `axis1`, `axis2`.", "question_id": 41400}
{"snippet": "Series.swapaxes(axis1, axis2, copy=True)", "intent": "Interchange axes and swap values axes appropriately . With arguments `axis1`, `axis2`, `copy`.", "question_id": 41401}
{"snippet": "Series.swaplevel()", "intent": "Swap levels `i` and `j` in a MultiIndex .", "question_id": 41402}
{"snippet": "Series.swaplevel(i=- 2)", "intent": "Swap levels `i` and `j` in a MultiIndex .", "question_id": 41403}
{"snippet": "Series.swaplevel(j=- 1)", "intent": "Swap levels `i` and `j` in a MultiIndex .", "question_id": 41404}
{"snippet": "Series.swaplevel(copy=True)", "intent": "Swap levels `i` and `j` in a MultiIndex . With arguments `copy`.", "question_id": 41405}
{"snippet": "Series.swaplevel(i=- 2, j=- 1)", "intent": "Swap levels `i` and `j` in a MultiIndex .", "question_id": 41406}
{"snippet": "Series.swaplevel(i=- 2, copy=True)", "intent": "Swap levels `i` and `j` in a MultiIndex . With arguments `copy`.", "question_id": 41407}
{"snippet": "Series.swaplevel(j=- 1, copy=True)", "intent": "Swap levels `i` and `j` in a MultiIndex . With arguments `copy`.", "question_id": 41408}
{"snippet": "Series.swaplevel(i=- 2, j=- 1, copy=True)", "intent": "Swap levels `i` and `j` in a MultiIndex . With arguments `copy`.", "question_id": 41409}
{"snippet": "Series.swaplevel()", "intent": "Swap levels `i` and `j` in a MultiIndex .", "question_id": 41410}
{"snippet": "Series.swaplevel(i=- 2)", "intent": "Swap levels `i` and `j` in a MultiIndex .", "question_id": 41411}
{"snippet": "Series.swaplevel(j=- 1)", "intent": "Swap levels `i` and `j` in a MultiIndex .", "question_id": 41412}
{"snippet": "Series.swaplevel(copy=True)", "intent": "Swap levels `i` and `j` in a MultiIndex . With arguments `copy`.", "question_id": 41413}
{"snippet": "Series.swaplevel(i=- 2, j=- 1)", "intent": "Swap levels `i` and `j` in a MultiIndex .", "question_id": 41414}
{"snippet": "Series.swaplevel(i=- 2, copy=True)", "intent": "Swap levels `i` and `j` in a MultiIndex . With arguments `copy`.", "question_id": 41415}
{"snippet": "Series.swaplevel(j=- 1, copy=True)", "intent": "Swap levels `i` and `j` in a MultiIndex . With arguments `copy`.", "question_id": 41416}
{"snippet": "Series.swaplevel(i=- 2, j=- 1, copy=True)", "intent": "Swap levels `i` and `j` in a MultiIndex . With arguments `copy`.", "question_id": 41417}
{"snippet": "Series.swaplevel()", "intent": "Swap levels `i` and `j` in a MultiIndex .", "question_id": 41418}
{"snippet": "Series.swaplevel(i=- 2)", "intent": "Swap levels `i` and `j` in a MultiIndex .", "question_id": 41419}
{"snippet": "Series.swaplevel(j=- 1)", "intent": "Swap levels `i` and `j` in a MultiIndex .", "question_id": 41420}
{"snippet": "Series.swaplevel(copy=True)", "intent": "Swap levels `i` and `j` in a MultiIndex . With arguments `copy`.", "question_id": 41421}
{"snippet": "Series.swaplevel(i=- 2, j=- 1)", "intent": "Swap levels `i` and `j` in a MultiIndex .", "question_id": 41422}
{"snippet": "Series.swaplevel(i=- 2, copy=True)", "intent": "Swap levels `i` and `j` in a MultiIndex . With arguments `copy`.", "question_id": 41423}
{"snippet": "Series.swaplevel(j=- 1, copy=True)", "intent": "Swap levels `i` and `j` in a MultiIndex . With arguments `copy`.", "question_id": 41424}
{"snippet": "Series.swaplevel(i=- 2, j=- 1, copy=True)", "intent": "Swap levels `i` and `j` in a MultiIndex . With arguments `copy`.", "question_id": 41425}
{"snippet": "Series.tail()", "intent": "Return the last `n` rows .", "question_id": 41426}
{"snippet": "Series.tail(n=5)", "intent": "Return the last `n` rows .", "question_id": 41427}
{"snippet": "Series.tail()", "intent": "Return the last `n` rows .", "question_id": 41428}
{"snippet": "Series.tail(n=5)", "intent": "Return the last `n` rows .", "question_id": 41429}
{"snippet": "Series.tail()", "intent": "Return the last `n` rows .", "question_id": 41430}
{"snippet": "Series.tail(n=5)", "intent": "Return the last `n` rows .", "question_id": 41431}
{"snippet": "Series.take(indices, **kwargs)", "intent": "Return the elements in the given positional `indices` along an `axis` . With arguments `**kwargs`.", "question_id": 41432}
{"snippet": "Series.take(indices, **kwargs, axis=0)", "intent": "Return the elements in the given positional `indices` along an `axis` . With arguments `**kwargs`.", "question_id": 41433}
{"snippet": "Series.take(indices, **kwargs, is_copy=None)", "intent": "Return the elements in the given positional `indices` along an `axis` . With arguments `**kwargs`, `is_copy`.", "question_id": 41434}
{"snippet": "Series.take(indices, **kwargs, axis=0, is_copy=None)", "intent": "Return the elements in the given positional `indices` along an `axis` . With arguments `**kwargs`, `is_copy`.", "question_id": 41435}
{"snippet": "Series.take(indices, **kwargs)", "intent": "Return the elements in the given positional `indices` along an `axis` . With arguments `**kwargs`.", "question_id": 41436}
{"snippet": "Series.take(indices, **kwargs, axis=0)", "intent": "Return the elements in the given positional `indices` along an `axis` . With arguments `**kwargs`.", "question_id": 41437}
{"snippet": "Series.take(indices, **kwargs, is_copy=None)", "intent": "Return the elements in the given positional `indices` along an `axis` . With arguments `**kwargs`, `is_copy`.", "question_id": 41438}
{"snippet": "Series.take(indices, **kwargs, axis=0, is_copy=None)", "intent": "Return the elements in the given positional `indices` along an `axis` . With arguments `**kwargs`, `is_copy`.", "question_id": 41439}
{"snippet": "Series.take(indices, **kwargs)", "intent": "Return the elements in the given positional `indices` along an `axis` . With arguments `**kwargs`.", "question_id": 41440}
{"snippet": "Series.take(indices, **kwargs, axis=0)", "intent": "Return the elements in the given positional `indices` along an `axis` . With arguments `**kwargs`.", "question_id": 41441}
{"snippet": "Series.take(indices, **kwargs, is_copy=None)", "intent": "Return the elements in the given positional `indices` along an `axis` . With arguments `**kwargs`, `is_copy`.", "question_id": 41442}
{"snippet": "Series.take(indices, **kwargs, axis=0, is_copy=None)", "intent": "Return the elements in the given positional `indices` along an `axis` . With arguments `**kwargs`, `is_copy`.", "question_id": 41443}
{"snippet": "Series.to_clipboard(**kwargs)", "intent": "Copy object to the system clipboard . With arguments `**kwargs`.", "question_id": 41444}
{"snippet": "Series.to_clipboard(**kwargs, excel=True)", "intent": "Copy object to the system clipboard . With arguments `**kwargs`, `excel`.", "question_id": 41445}
{"snippet": "Series.to_clipboard(**kwargs, sep=None)", "intent": "Copy object to the system clipboard . With arguments `**kwargs`, `sep`.", "question_id": 41446}
{"snippet": "Series.to_clipboard(**kwargs, excel=True, sep=None)", "intent": "Copy object to the system clipboard . With arguments `**kwargs`, `excel`, `sep`.", "question_id": 41447}
{"snippet": "Series.to_clipboard(**kwargs)", "intent": "Copy object to the system clipboard . With arguments `**kwargs`.", "question_id": 41448}
{"snippet": "Series.to_clipboard(**kwargs, excel=True)", "intent": "Copy object to the system clipboard . With arguments `**kwargs`, `excel`.", "question_id": 41449}
{"snippet": "Series.to_clipboard(**kwargs, sep=None)", "intent": "Copy object to the system clipboard . With arguments `**kwargs`, `sep`.", "question_id": 41450}
{"snippet": "Series.to_clipboard(**kwargs, excel=True, sep=None)", "intent": "Copy object to the system clipboard . With arguments `**kwargs`, `excel`, `sep`.", "question_id": 41451}
{"snippet": "Series.to_clipboard(**kwargs)", "intent": "Copy object to the system clipboard . With arguments `**kwargs`.", "question_id": 41452}
{"snippet": "Series.to_clipboard(**kwargs, excel=True)", "intent": "Copy object to the system clipboard . With arguments `**kwargs`, `excel`.", "question_id": 41453}
{"snippet": "Series.to_clipboard(**kwargs, sep=None)", "intent": "Copy object to the system clipboard . With arguments `**kwargs`, `sep`.", "question_id": 41454}
{"snippet": "Series.to_clipboard(**kwargs, excel=True, sep=None)", "intent": "Copy object to the system clipboard . With arguments `**kwargs`, `excel`, `sep`.", "question_id": 41455}
{"snippet": "Series.to_csv()", "intent": "Write object to a comma-separated values ( csv ) file .", "question_id": 41456}
{"snippet": "Series.to_csv(path_or_buf=None)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `path_or_buf`.", "question_id": 41457}
{"snippet": "Series.to_csv(sep=',')", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `sep`.", "question_id": 41458}
{"snippet": "Series.to_csv(na_rep='')", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `na_rep`.", "question_id": 41459}
{"snippet": "Series.to_csv(float_format=None)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `float_format`.", "question_id": 41460}
{"snippet": "Series.to_csv(columns=None)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `columns`.", "question_id": 41461}
{"snippet": "Series.to_csv(header=True)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `header`.", "question_id": 41462}
{"snippet": "Series.to_csv(index=True)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `index`.", "question_id": 41463}
{"snippet": "Series.to_csv(index_label=None)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `index_label`.", "question_id": 41464}
{"snippet": "Series.to_csv(mode='w')", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `mode`.", "question_id": 41465}
{"snippet": "Series.to_csv()", "intent": "Write object to a comma-separated values ( csv ) file .", "question_id": 41466}
{"snippet": "Series.to_csv(path_or_buf=None)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `path_or_buf`.", "question_id": 41467}
{"snippet": "Series.to_csv(sep=',')", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `sep`.", "question_id": 41468}
{"snippet": "Series.to_csv(na_rep='')", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `na_rep`.", "question_id": 41469}
{"snippet": "Series.to_csv(float_format=None)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `float_format`.", "question_id": 41470}
{"snippet": "Series.to_csv(columns=None)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `columns`.", "question_id": 41471}
{"snippet": "Series.to_csv(header=True)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `header`.", "question_id": 41472}
{"snippet": "Series.to_csv(index=True)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `index`.", "question_id": 41473}
{"snippet": "Series.to_csv(index_label=None)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `index_label`.", "question_id": 41474}
{"snippet": "Series.to_csv(mode='w')", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `mode`.", "question_id": 41475}
{"snippet": "Series.to_csv()", "intent": "Write object to a comma-separated values ( csv ) file .", "question_id": 41476}
{"snippet": "Series.to_csv(path_or_buf=None)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `path_or_buf`.", "question_id": 41477}
{"snippet": "Series.to_csv(sep=',')", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `sep`.", "question_id": 41478}
{"snippet": "Series.to_csv(na_rep='')", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `na_rep`.", "question_id": 41479}
{"snippet": "Series.to_csv(float_format=None)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `float_format`.", "question_id": 41480}
{"snippet": "Series.to_csv(columns=None)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `columns`.", "question_id": 41481}
{"snippet": "Series.to_csv(header=True)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `header`.", "question_id": 41482}
{"snippet": "Series.to_csv(index=True)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `index`.", "question_id": 41483}
{"snippet": "Series.to_csv(index_label=None)", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `index_label`.", "question_id": 41484}
{"snippet": "Series.to_csv(mode='w')", "intent": "Write object to a comma-separated values ( csv ) file . With arguments `mode`.", "question_id": 41485}
{"snippet": "Series.to_dict()", "intent": "Convert Series to { label - > value } dict or dict-like object .", "question_id": 41486}
{"snippet": "Series.to_dict(into=<class 'dict'>)", "intent": "Convert Series to { label - > value } dict or dict-like object . With arguments `into`.", "question_id": 41487}
{"snippet": "Series.to_dict()", "intent": "Convert Series to { label - > value } dict or dict-like object .", "question_id": 41488}
{"snippet": "Series.to_dict(into=<class 'dict'>)", "intent": "Convert Series to { label - > value } dict or dict-like object . With arguments `into`.", "question_id": 41489}
{"snippet": "Series.to_dict()", "intent": "Convert Series to { label - > value } dict or dict-like object .", "question_id": 41490}
{"snippet": "Series.to_dict(into=<class 'dict'>)", "intent": "Convert Series to { label - > value } dict or dict-like object . With arguments `into`.", "question_id": 41491}
{"snippet": "Series.to_excel(excel_writer)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`.", "question_id": 41492}
{"snippet": "Series.to_excel(excel_writer, sheet_name='Sheet1')", "intent": "Write object to an Excel sheet . Multiple sheets may be written to by specifying unique `sheet_name` . With arguments `excel_writer`.", "question_id": 41493}
{"snippet": "Series.to_excel(excel_writer, na_rep='')", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `na_rep`.", "question_id": 41494}
{"snippet": "Series.to_excel(excel_writer, float_format=None)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `float_format`.", "question_id": 41495}
{"snippet": "Series.to_excel(excel_writer, columns=None)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `columns`.", "question_id": 41496}
{"snippet": "Series.to_excel(excel_writer, header=True)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `header`.", "question_id": 41497}
{"snippet": "Series.to_excel(excel_writer, index=True)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `index`.", "question_id": 41498}
{"snippet": "Series.to_excel(excel_writer, index_label=None)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `index_label`.", "question_id": 41499}
{"snippet": "Series.to_excel(excel_writer, startrow=0)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `startrow`.", "question_id": 41500}
{"snippet": "Series.to_excel(excel_writer, startcol=0)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `startcol`.", "question_id": 41501}
{"snippet": "Series.to_excel(excel_writer)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`.", "question_id": 41502}
{"snippet": "Series.to_excel(excel_writer, sheet_name='Sheet1')", "intent": "Write object to an Excel sheet . Multiple sheets may be written to by specifying unique `sheet_name` . With arguments `excel_writer`.", "question_id": 41503}
{"snippet": "Series.to_excel(excel_writer, na_rep='')", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `na_rep`.", "question_id": 41504}
{"snippet": "Series.to_excel(excel_writer, float_format=None)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `float_format`.", "question_id": 41505}
{"snippet": "Series.to_excel(excel_writer, columns=None)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `columns`.", "question_id": 41506}
{"snippet": "Series.to_excel(excel_writer, header=True)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `header`.", "question_id": 41507}
{"snippet": "Series.to_excel(excel_writer, index=True)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `index`.", "question_id": 41508}
{"snippet": "Series.to_excel(excel_writer, index_label=None)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `index_label`.", "question_id": 41509}
{"snippet": "Series.to_excel(excel_writer, startrow=0)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `startrow`.", "question_id": 41510}
{"snippet": "Series.to_excel(excel_writer, startcol=0)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `startcol`.", "question_id": 41511}
{"snippet": "Series.to_excel(excel_writer)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`.", "question_id": 41512}
{"snippet": "Series.to_excel(excel_writer, sheet_name='Sheet1')", "intent": "Write object to an Excel sheet . Multiple sheets may be written to by specifying unique `sheet_name` . With arguments `excel_writer`.", "question_id": 41513}
{"snippet": "Series.to_excel(excel_writer, na_rep='')", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `na_rep`.", "question_id": 41514}
{"snippet": "Series.to_excel(excel_writer, float_format=None)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `float_format`.", "question_id": 41515}
{"snippet": "Series.to_excel(excel_writer, columns=None)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `columns`.", "question_id": 41516}
{"snippet": "Series.to_excel(excel_writer, header=True)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `header`.", "question_id": 41517}
{"snippet": "Series.to_excel(excel_writer, index=True)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `index`.", "question_id": 41518}
{"snippet": "Series.to_excel(excel_writer, index_label=None)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `index_label`.", "question_id": 41519}
{"snippet": "Series.to_excel(excel_writer, startrow=0)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `startrow`.", "question_id": 41520}
{"snippet": "Series.to_excel(excel_writer, startcol=0)", "intent": "Write object to an Excel sheet . With arguments `excel_writer`, `startcol`.", "question_id": 41521}
{"snippet": "Series.to_frame()", "intent": "Convert Series to DataFrame .", "question_id": 41522}
{"snippet": "Series.to_frame(name=None)", "intent": "Convert Series to DataFrame . With arguments `name`.", "question_id": 41523}
{"snippet": "Series.to_frame()", "intent": "Convert Series to DataFrame .", "question_id": 41524}
{"snippet": "Series.to_frame(name=None)", "intent": "Convert Series to DataFrame . With arguments `name`.", "question_id": 41525}
{"snippet": "Series.to_frame()", "intent": "Convert Series to DataFrame .", "question_id": 41526}
{"snippet": "Series.to_frame(name=None)", "intent": "Convert Series to DataFrame . With arguments `name`.", "question_id": 41527}
{"snippet": "Series.to_hdf(path_or_buf, key)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`.", "question_id": 41528}
{"snippet": "Series.to_hdf(path_or_buf, key, mode='a')", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`.", "question_id": 41529}
{"snippet": "Series.to_hdf(path_or_buf, key, complevel=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `complevel`.", "question_id": 41530}
{"snippet": "Series.to_hdf(path_or_buf, key, complib=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `complib`.", "question_id": 41531}
{"snippet": "Series.to_hdf(path_or_buf, key, append=False)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`.", "question_id": 41532}
{"snippet": "Series.to_hdf(path_or_buf, key, format=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `format`.", "question_id": 41533}
{"snippet": "Series.to_hdf(path_or_buf, key, index=True)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `index`.", "question_id": 41534}
{"snippet": "Series.to_hdf(path_or_buf, key, min_itemsize=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `min_itemsize`.", "question_id": 41535}
{"snippet": "Series.to_hdf(path_or_buf, key, nan_rep=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `nan_rep`.", "question_id": 41536}
{"snippet": "Series.to_hdf(path_or_buf, key, dropna=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `dropna`.", "question_id": 41537}
{"snippet": "Series.to_hdf(path_or_buf, key)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`.", "question_id": 41538}
{"snippet": "Series.to_hdf(path_or_buf, key, mode='a')", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`.", "question_id": 41539}
{"snippet": "Series.to_hdf(path_or_buf, key, complevel=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `complevel`.", "question_id": 41540}
{"snippet": "Series.to_hdf(path_or_buf, key, complib=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `complib`.", "question_id": 41541}
{"snippet": "Series.to_hdf(path_or_buf, key, append=False)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`.", "question_id": 41542}
{"snippet": "Series.to_hdf(path_or_buf, key, format=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `format`.", "question_id": 41543}
{"snippet": "Series.to_hdf(path_or_buf, key, index=True)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `index`.", "question_id": 41544}
{"snippet": "Series.to_hdf(path_or_buf, key, min_itemsize=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `min_itemsize`.", "question_id": 41545}
{"snippet": "Series.to_hdf(path_or_buf, key, nan_rep=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `nan_rep`.", "question_id": 41546}
{"snippet": "Series.to_hdf(path_or_buf, key, dropna=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `dropna`.", "question_id": 41547}
{"snippet": "Series.to_hdf(path_or_buf, key)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`.", "question_id": 41548}
{"snippet": "Series.to_hdf(path_or_buf, key, mode='a')", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`.", "question_id": 41549}
{"snippet": "Series.to_hdf(path_or_buf, key, complevel=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `complevel`.", "question_id": 41550}
{"snippet": "Series.to_hdf(path_or_buf, key, complib=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `complib`.", "question_id": 41551}
{"snippet": "Series.to_hdf(path_or_buf, key, append=False)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`.", "question_id": 41552}
{"snippet": "Series.to_hdf(path_or_buf, key, format=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `format`.", "question_id": 41553}
{"snippet": "Series.to_hdf(path_or_buf, key, index=True)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `index`.", "question_id": 41554}
{"snippet": "Series.to_hdf(path_or_buf, key, min_itemsize=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `min_itemsize`.", "question_id": 41555}
{"snippet": "Series.to_hdf(path_or_buf, key, nan_rep=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `nan_rep`.", "question_id": 41556}
{"snippet": "Series.to_hdf(path_or_buf, key, dropna=None)", "intent": "Write the contained data to an HDF5 file using HDFStore . In order to add another DataFrame or Series to an existing HDF file please use `append` `mode` and a different a `key` . With arguments `path_or_buf`, `dropna`.", "question_id": 41557}
{"snippet": "Series.to_json()", "intent": "Convert the object to a JSON string .", "question_id": 41558}
{"snippet": "Series.to_json(path_or_buf=None)", "intent": "Convert the object to a JSON string . With arguments `path_or_buf`.", "question_id": 41559}
{"snippet": "Series.to_json(orient=None)", "intent": "Convert the object to a JSON string . With arguments `orient`.", "question_id": 41560}
{"snippet": "Series.to_json(date_format=None)", "intent": "Convert the object to a JSON string . With arguments `date_format`.", "question_id": 41561}
{"snippet": "Series.to_json(double_precision=10)", "intent": "Convert the object to a JSON string . With arguments `double_precision`.", "question_id": 41562}
{"snippet": "Series.to_json(force_ascii=True)", "intent": "Convert the object to a JSON string . With arguments `force_ascii`.", "question_id": 41563}
{"snippet": "Series.to_json(date_unit='ms')", "intent": "Convert the object to a JSON string . With arguments `date_unit`.", "question_id": 41564}
{"snippet": "Series.to_json(default_handler=None)", "intent": "Convert the object to a JSON string . With arguments `default_handler`.", "question_id": 41565}
{"snippet": "Series.to_json(lines=False)", "intent": "Convert the object to a JSON string . With arguments `lines`.", "question_id": 41566}
{"snippet": "Series.to_json(compression='infer')", "intent": "Convert the object to a JSON string . With arguments `compression`.", "question_id": 41567}
{"snippet": "Series.to_json()", "intent": "Convert the object to a JSON string .", "question_id": 41568}
{"snippet": "Series.to_json(path_or_buf=None)", "intent": "Convert the object to a JSON string . With arguments `path_or_buf`.", "question_id": 41569}
{"snippet": "Series.to_json(orient=None)", "intent": "Convert the object to a JSON string . With arguments `orient`.", "question_id": 41570}
{"snippet": "Series.to_json(date_format=None)", "intent": "Convert the object to a JSON string . With arguments `date_format`.", "question_id": 41571}
{"snippet": "Series.to_json(double_precision=10)", "intent": "Convert the object to a JSON string . With arguments `double_precision`.", "question_id": 41572}
{"snippet": "Series.to_json(force_ascii=True)", "intent": "Convert the object to a JSON string . With arguments `force_ascii`.", "question_id": 41573}
{"snippet": "Series.to_json(date_unit='ms')", "intent": "Convert the object to a JSON string . With arguments `date_unit`.", "question_id": 41574}
{"snippet": "Series.to_json(default_handler=None)", "intent": "Convert the object to a JSON string . With arguments `default_handler`.", "question_id": 41575}
{"snippet": "Series.to_json(lines=False)", "intent": "Convert the object to a JSON string . With arguments `lines`.", "question_id": 41576}
{"snippet": "Series.to_json(compression='infer')", "intent": "Convert the object to a JSON string . With arguments `compression`.", "question_id": 41577}
{"snippet": "Series.to_json()", "intent": "Convert the object to a JSON string .", "question_id": 41578}
{"snippet": "Series.to_json(path_or_buf=None)", "intent": "Convert the object to a JSON string . With arguments `path_or_buf`.", "question_id": 41579}
{"snippet": "Series.to_json(orient=None)", "intent": "Convert the object to a JSON string . With arguments `orient`.", "question_id": 41580}
{"snippet": "Series.to_json(date_format=None)", "intent": "Convert the object to a JSON string . With arguments `date_format`.", "question_id": 41581}
{"snippet": "Series.to_json(double_precision=10)", "intent": "Convert the object to a JSON string . With arguments `double_precision`.", "question_id": 41582}
{"snippet": "Series.to_json(force_ascii=True)", "intent": "Convert the object to a JSON string . With arguments `force_ascii`.", "question_id": 41583}
{"snippet": "Series.to_json(date_unit='ms')", "intent": "Convert the object to a JSON string . With arguments `date_unit`.", "question_id": 41584}
{"snippet": "Series.to_json(default_handler=None)", "intent": "Convert the object to a JSON string . With arguments `default_handler`.", "question_id": 41585}
{"snippet": "Series.to_json(lines=False)", "intent": "Convert the object to a JSON string . With arguments `lines`.", "question_id": 41586}
{"snippet": "Series.to_json(compression='infer')", "intent": "Convert the object to a JSON string . With arguments `compression`.", "question_id": 41587}
{"snippet": "Series.to_latex()", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular .", "question_id": 41588}
{"snippet": "Series.to_latex(buf=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `buf`.", "question_id": 41589}
{"snippet": "Series.to_latex(columns=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `columns`.", "question_id": 41590}
{"snippet": "Series.to_latex(col_space=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `col_space`.", "question_id": 41591}
{"snippet": "Series.to_latex(header=True)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `header`.", "question_id": 41592}
{"snippet": "Series.to_latex(index=True)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `index`.", "question_id": 41593}
{"snippet": "Series.to_latex(na_rep='NaN')", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `na_rep`.", "question_id": 41594}
{"snippet": "Series.to_latex(formatters=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `formatters`.", "question_id": 41595}
{"snippet": "Series.to_latex(float_format=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `float_format`.", "question_id": 41596}
{"snippet": "Series.to_latex(sparsify=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `sparsify`.", "question_id": 41597}
{"snippet": "Series.to_latex()", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular .", "question_id": 41598}
{"snippet": "Series.to_latex(buf=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `buf`.", "question_id": 41599}
{"snippet": "Series.to_latex(columns=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `columns`.", "question_id": 41600}
{"snippet": "Series.to_latex(col_space=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `col_space`.", "question_id": 41601}
{"snippet": "Series.to_latex(header=True)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `header`.", "question_id": 41602}
{"snippet": "Series.to_latex(index=True)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `index`.", "question_id": 41603}
{"snippet": "Series.to_latex(na_rep='NaN')", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `na_rep`.", "question_id": 41604}
{"snippet": "Series.to_latex(formatters=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `formatters`.", "question_id": 41605}
{"snippet": "Series.to_latex(float_format=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `float_format`.", "question_id": 41606}
{"snippet": "Series.to_latex(sparsify=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `sparsify`.", "question_id": 41607}
{"snippet": "Series.to_latex()", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular .", "question_id": 41608}
{"snippet": "Series.to_latex(buf=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `buf`.", "question_id": 41609}
{"snippet": "Series.to_latex(columns=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `columns`.", "question_id": 41610}
{"snippet": "Series.to_latex(col_space=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `col_space`.", "question_id": 41611}
{"snippet": "Series.to_latex(header=True)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `header`.", "question_id": 41612}
{"snippet": "Series.to_latex(index=True)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `index`.", "question_id": 41613}
{"snippet": "Series.to_latex(na_rep='NaN')", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `na_rep`.", "question_id": 41614}
{"snippet": "Series.to_latex(formatters=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `formatters`.", "question_id": 41615}
{"snippet": "Series.to_latex(float_format=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `float_format`.", "question_id": 41616}
{"snippet": "Series.to_latex(sparsify=None)", "intent": "Render object to a LaTeX tabular , `longtable` , or nested table/tabular . With arguments `sparsify`.", "question_id": 41617}
{"snippet": "Series.to_list()", "intent": "Return a list of the values .", "question_id": 41618}
{"snippet": "Series.to_list()", "intent": "Return a list of the values .", "question_id": 41619}
{"snippet": "Series.to_list()", "intent": "Return a list of the values .", "question_id": 41620}
{"snippet": "Series.to_markdown(**kwargs)", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`.", "question_id": 41621}
{"snippet": "Series.to_markdown(**kwargs, buf=None)", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `buf`.", "question_id": 41622}
{"snippet": "Series.to_markdown(**kwargs, mode='wt')", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `mode`.", "question_id": 41623}
{"snippet": "Series.to_markdown(**kwargs, index=True)", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `index`.", "question_id": 41624}
{"snippet": "Series.to_markdown(**kwargs, storage_options=None)", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `storage_options`.", "question_id": 41625}
{"snippet": "Series.to_markdown(**kwargs, buf=None, mode='wt')", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `buf`, `mode`.", "question_id": 41626}
{"snippet": "Series.to_markdown(**kwargs, buf=None, index=True)", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `buf`, `index`.", "question_id": 41627}
{"snippet": "Series.to_markdown(**kwargs, buf=None, storage_options=None)", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `buf`, `storage_options`.", "question_id": 41628}
{"snippet": "Series.to_markdown(**kwargs, mode='wt', index=True)", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `mode`, `index`.", "question_id": 41629}
{"snippet": "Series.to_markdown(**kwargs, mode='wt', storage_options=None)", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `mode`, `storage_options`.", "question_id": 41630}
{"snippet": "Series.to_markdown(**kwargs)", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`.", "question_id": 41631}
{"snippet": "Series.to_markdown(**kwargs, buf=None)", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `buf`.", "question_id": 41632}
{"snippet": "Series.to_markdown(**kwargs, mode='wt')", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `mode`.", "question_id": 41633}
{"snippet": "Series.to_markdown(**kwargs, index=True)", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `index`.", "question_id": 41634}
{"snippet": "Series.to_markdown(**kwargs, storage_options=None)", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `storage_options`.", "question_id": 41635}
{"snippet": "Series.to_markdown(**kwargs, buf=None, mode='wt')", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `buf`, `mode`.", "question_id": 41636}
{"snippet": "Series.to_markdown(**kwargs, buf=None, index=True)", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `buf`, `index`.", "question_id": 41637}
{"snippet": "Series.to_markdown(**kwargs, buf=None, storage_options=None)", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `buf`, `storage_options`.", "question_id": 41638}
{"snippet": "Series.to_markdown(**kwargs, mode='wt', index=True)", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `mode`, `index`.", "question_id": 41639}
{"snippet": "Series.to_markdown(**kwargs, mode='wt', storage_options=None)", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `mode`, `storage_options`.", "question_id": 41640}
{"snippet": "Series.to_markdown(**kwargs)", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`.", "question_id": 41641}
{"snippet": "Series.to_markdown(**kwargs, buf=None)", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `buf`.", "question_id": 41642}
{"snippet": "Series.to_markdown(**kwargs, mode='wt')", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `mode`.", "question_id": 41643}
{"snippet": "Series.to_markdown(**kwargs, index=True)", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `index`.", "question_id": 41644}
{"snippet": "Series.to_markdown(**kwargs, storage_options=None)", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `storage_options`.", "question_id": 41645}
{"snippet": "Series.to_markdown(**kwargs, buf=None, mode='wt')", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `buf`, `mode`.", "question_id": 41646}
{"snippet": "Series.to_markdown(**kwargs, buf=None, index=True)", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `buf`, `index`.", "question_id": 41647}
{"snippet": "Series.to_markdown(**kwargs, buf=None, storage_options=None)", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `buf`, `storage_options`.", "question_id": 41648}
{"snippet": "Series.to_markdown(**kwargs, mode='wt', index=True)", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `mode`, `index`.", "question_id": 41649}
{"snippet": "Series.to_markdown(**kwargs, mode='wt', storage_options=None)", "intent": "Print Series in Markdown-friendly format . With arguments `**kwargs`, `mode`, `storage_options`.", "question_id": 41650}
{"snippet": "Series.to_numpy(**kwargs)", "intent": "A NumPy ndarray representing the values in this Series or Index . With arguments `**kwargs`.", "question_id": 41651}
{"snippet": "Series.to_numpy(**kwargs, dtype=None)", "intent": "A NumPy ndarray representing the values in this Series or Index . When self contains an ExtensionArray , the `dtype` may be different . With arguments `**kwargs`.", "question_id": 41652}
{"snippet": "Series.to_numpy(**kwargs, copy=False)", "intent": "A NumPy ndarray representing the values in this Series or Index . With arguments `**kwargs`, `copy`.", "question_id": 41653}
{"snippet": "Series.to_numpy(**kwargs, na_value=NoDefault.no_default)", "intent": "A NumPy ndarray representing the values in this Series or Index . With arguments `**kwargs`, `na_value`.", "question_id": 41654}
{"snippet": "Series.to_numpy(**kwargs, dtype=None, copy=False)", "intent": "A NumPy ndarray representing the values in this Series or Index . When self contains an ExtensionArray , the `dtype` may be different . With arguments `**kwargs`, `copy`.", "question_id": 41655}
{"snippet": "Series.to_numpy(**kwargs, dtype=None, na_value=NoDefault.no_default)", "intent": "A NumPy ndarray representing the values in this Series or Index . When self contains an ExtensionArray , the `dtype` may be different . With arguments `**kwargs`, `na_value`.", "question_id": 41656}
{"snippet": "Series.to_numpy(**kwargs, copy=False, na_value=NoDefault.no_default)", "intent": "A NumPy ndarray representing the values in this Series or Index . With arguments `**kwargs`, `copy`, `na_value`.", "question_id": 41657}
{"snippet": "Series.to_numpy(**kwargs, dtype=None, copy=False, na_value=NoDefault.no_default)", "intent": "A NumPy ndarray representing the values in this Series or Index . When self contains an ExtensionArray , the `dtype` may be different . With arguments `**kwargs`, `copy`, `na_value`.", "question_id": 41658}
{"snippet": "Series.to_numpy(**kwargs)", "intent": "A NumPy ndarray representing the values in this Series or Index . With arguments `**kwargs`.", "question_id": 41659}
{"snippet": "Series.to_numpy(**kwargs, dtype=None)", "intent": "A NumPy ndarray representing the values in this Series or Index . When self contains an ExtensionArray , the `dtype` may be different . With arguments `**kwargs`.", "question_id": 41660}
{"snippet": "Series.to_numpy(**kwargs, copy=False)", "intent": "A NumPy ndarray representing the values in this Series or Index . With arguments `**kwargs`, `copy`.", "question_id": 41661}
{"snippet": "Series.to_numpy(**kwargs, na_value=NoDefault.no_default)", "intent": "A NumPy ndarray representing the values in this Series or Index . With arguments `**kwargs`, `na_value`.", "question_id": 41662}
{"snippet": "Series.to_numpy(**kwargs, dtype=None, copy=False)", "intent": "A NumPy ndarray representing the values in this Series or Index . When self contains an ExtensionArray , the `dtype` may be different . With arguments `**kwargs`, `copy`.", "question_id": 41663}
{"snippet": "Series.to_numpy(**kwargs, dtype=None, na_value=NoDefault.no_default)", "intent": "A NumPy ndarray representing the values in this Series or Index . When self contains an ExtensionArray , the `dtype` may be different . With arguments `**kwargs`, `na_value`.", "question_id": 41664}
{"snippet": "Series.to_numpy(**kwargs, copy=False, na_value=NoDefault.no_default)", "intent": "A NumPy ndarray representing the values in this Series or Index . With arguments `**kwargs`, `copy`, `na_value`.", "question_id": 41665}
{"snippet": "Series.to_numpy(**kwargs, dtype=None, copy=False, na_value=NoDefault.no_default)", "intent": "A NumPy ndarray representing the values in this Series or Index . When self contains an ExtensionArray , the `dtype` may be different . With arguments `**kwargs`, `copy`, `na_value`.", "question_id": 41666}
{"snippet": "Series.to_numpy(**kwargs)", "intent": "A NumPy ndarray representing the values in this Series or Index . With arguments `**kwargs`.", "question_id": 41667}
{"snippet": "Series.to_numpy(**kwargs, dtype=None)", "intent": "A NumPy ndarray representing the values in this Series or Index . When self contains an ExtensionArray , the `dtype` may be different . With arguments `**kwargs`.", "question_id": 41668}
{"snippet": "Series.to_numpy(**kwargs, copy=False)", "intent": "A NumPy ndarray representing the values in this Series or Index . With arguments `**kwargs`, `copy`.", "question_id": 41669}
{"snippet": "Series.to_numpy(**kwargs, na_value=NoDefault.no_default)", "intent": "A NumPy ndarray representing the values in this Series or Index . With arguments `**kwargs`, `na_value`.", "question_id": 41670}
{"snippet": "Series.to_numpy(**kwargs, dtype=None, copy=False)", "intent": "A NumPy ndarray representing the values in this Series or Index . When self contains an ExtensionArray , the `dtype` may be different . With arguments `**kwargs`, `copy`.", "question_id": 41671}
{"snippet": "Series.to_numpy(**kwargs, dtype=None, na_value=NoDefault.no_default)", "intent": "A NumPy ndarray representing the values in this Series or Index . When self contains an ExtensionArray , the `dtype` may be different . With arguments `**kwargs`, `na_value`.", "question_id": 41672}
{"snippet": "Series.to_numpy(**kwargs, copy=False, na_value=NoDefault.no_default)", "intent": "A NumPy ndarray representing the values in this Series or Index . With arguments `**kwargs`, `copy`, `na_value`.", "question_id": 41673}
{"snippet": "Series.to_numpy(**kwargs, dtype=None, copy=False, na_value=NoDefault.no_default)", "intent": "A NumPy ndarray representing the values in this Series or Index . When self contains an ExtensionArray , the `dtype` may be different . With arguments `**kwargs`, `copy`, `na_value`.", "question_id": 41674}
{"snippet": "Series.to_period()", "intent": "Convert Series from DatetimeIndex to PeriodIndex .", "question_id": 41675}
{"snippet": "Series.to_period(freq=None)", "intent": "Convert Series from DatetimeIndex to PeriodIndex . With arguments `freq`.", "question_id": 41676}
{"snippet": "Series.to_period(copy=True)", "intent": "Convert Series from DatetimeIndex to PeriodIndex . With arguments `copy`.", "question_id": 41677}
{"snippet": "Series.to_period(freq=None, copy=True)", "intent": "Convert Series from DatetimeIndex to PeriodIndex . With arguments `freq`, `copy`.", "question_id": 41678}
{"snippet": "Series.to_period()", "intent": "Convert Series from DatetimeIndex to PeriodIndex .", "question_id": 41679}
{"snippet": "Series.to_period(freq=None)", "intent": "Convert Series from DatetimeIndex to PeriodIndex . With arguments `freq`.", "question_id": 41680}
{"snippet": "Series.to_period(copy=True)", "intent": "Convert Series from DatetimeIndex to PeriodIndex . With arguments `copy`.", "question_id": 41681}
{"snippet": "Series.to_period(freq=None, copy=True)", "intent": "Convert Series from DatetimeIndex to PeriodIndex . With arguments `freq`, `copy`.", "question_id": 41682}
{"snippet": "Series.to_period()", "intent": "Convert Series from DatetimeIndex to PeriodIndex .", "question_id": 41683}
{"snippet": "Series.to_period(freq=None)", "intent": "Convert Series from DatetimeIndex to PeriodIndex . With arguments `freq`.", "question_id": 41684}
{"snippet": "Series.to_period(copy=True)", "intent": "Convert Series from DatetimeIndex to PeriodIndex . With arguments `copy`.", "question_id": 41685}
{"snippet": "Series.to_period(freq=None, copy=True)", "intent": "Convert Series from DatetimeIndex to PeriodIndex . With arguments `freq`, `copy`.", "question_id": 41686}
{"snippet": "Series.to_pickle(path)", "intent": "Pickle ( serialize ) object to file . With arguments `path`.", "question_id": 41687}
{"snippet": "Series.to_pickle(path, compression='infer')", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `compression`.", "question_id": 41688}
{"snippet": "Series.to_pickle(path, protocol=5)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `protocol`.", "question_id": 41689}
{"snippet": "Series.to_pickle(path, storage_options=None)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `storage_options`.", "question_id": 41690}
{"snippet": "Series.to_pickle(path, compression='infer', protocol=5)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `compression`, `protocol`.", "question_id": 41691}
{"snippet": "Series.to_pickle(path, compression='infer', storage_options=None)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `compression`, `storage_options`.", "question_id": 41692}
{"snippet": "Series.to_pickle(path, protocol=5, storage_options=None)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `protocol`, `storage_options`.", "question_id": 41693}
{"snippet": "Series.to_pickle(path, compression='infer', protocol=5, storage_options=None)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `compression`, `protocol`, `storage_options`.", "question_id": 41694}
{"snippet": "Series.to_pickle(path)", "intent": "Pickle ( serialize ) object to file . With arguments `path`.", "question_id": 41695}
{"snippet": "Series.to_pickle(path, compression='infer')", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `compression`.", "question_id": 41696}
{"snippet": "Series.to_pickle(path, protocol=5)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `protocol`.", "question_id": 41697}
{"snippet": "Series.to_pickle(path, storage_options=None)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `storage_options`.", "question_id": 41698}
{"snippet": "Series.to_pickle(path, compression='infer', protocol=5)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `compression`, `protocol`.", "question_id": 41699}
{"snippet": "Series.to_pickle(path, compression='infer', storage_options=None)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `compression`, `storage_options`.", "question_id": 41700}
{"snippet": "Series.to_pickle(path, protocol=5, storage_options=None)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `protocol`, `storage_options`.", "question_id": 41701}
{"snippet": "Series.to_pickle(path, compression='infer', protocol=5, storage_options=None)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `compression`, `protocol`, `storage_options`.", "question_id": 41702}
{"snippet": "Series.to_pickle(path)", "intent": "Pickle ( serialize ) object to file . With arguments `path`.", "question_id": 41703}
{"snippet": "Series.to_pickle(path, compression='infer')", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `compression`.", "question_id": 41704}
{"snippet": "Series.to_pickle(path, protocol=5)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `protocol`.", "question_id": 41705}
{"snippet": "Series.to_pickle(path, storage_options=None)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `storage_options`.", "question_id": 41706}
{"snippet": "Series.to_pickle(path, compression='infer', protocol=5)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `compression`, `protocol`.", "question_id": 41707}
{"snippet": "Series.to_pickle(path, compression='infer', storage_options=None)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `compression`, `storage_options`.", "question_id": 41708}
{"snippet": "Series.to_pickle(path, protocol=5, storage_options=None)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `protocol`, `storage_options`.", "question_id": 41709}
{"snippet": "Series.to_pickle(path, compression='infer', protocol=5, storage_options=None)", "intent": "Pickle ( serialize ) object to file . With arguments `path`, `compression`, `protocol`, `storage_options`.", "question_id": 41710}
{"snippet": "Series.to_sql(name, con)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`.", "question_id": 41711}
{"snippet": "Series.to_sql(name, con, schema=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `schema`.", "question_id": 41712}
{"snippet": "Series.to_sql(name, con, if_exists='fail')", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `if_exists`.", "question_id": 41713}
{"snippet": "Series.to_sql(name, con, index=True)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `index`.", "question_id": 41714}
{"snippet": "Series.to_sql(name, con, index_label=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `index_label`.", "question_id": 41715}
{"snippet": "Series.to_sql(name, con, chunksize=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `chunksize`.", "question_id": 41716}
{"snippet": "Series.to_sql(name, con, dtype=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : Specify the `dtype` ( especially useful for integers with missing values ) . With arguments `name`.", "question_id": 41717}
{"snippet": "Series.to_sql(name, con, method=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `method`.", "question_id": 41718}
{"snippet": "Series.to_sql(name, con, schema=None, if_exists='fail')", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `schema`, `if_exists`.", "question_id": 41719}
{"snippet": "Series.to_sql(name, con, schema=None, index=True)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `schema`, `index`.", "question_id": 41720}
{"snippet": "Series.to_sql(name, con)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`.", "question_id": 41721}
{"snippet": "Series.to_sql(name, con, schema=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `schema`.", "question_id": 41722}
{"snippet": "Series.to_sql(name, con, if_exists='fail')", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `if_exists`.", "question_id": 41723}
{"snippet": "Series.to_sql(name, con, index=True)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `index`.", "question_id": 41724}
{"snippet": "Series.to_sql(name, con, index_label=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `index_label`.", "question_id": 41725}
{"snippet": "Series.to_sql(name, con, chunksize=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `chunksize`.", "question_id": 41726}
{"snippet": "Series.to_sql(name, con, dtype=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : Specify the `dtype` ( especially useful for integers with missing values ) . With arguments `name`.", "question_id": 41727}
{"snippet": "Series.to_sql(name, con, method=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `method`.", "question_id": 41728}
{"snippet": "Series.to_sql(name, con, schema=None, if_exists='fail')", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `schema`, `if_exists`.", "question_id": 41729}
{"snippet": "Series.to_sql(name, con, schema=None, index=True)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `schema`, `index`.", "question_id": 41730}
{"snippet": "Series.to_sql(name, con)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`.", "question_id": 41731}
{"snippet": "Series.to_sql(name, con, schema=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `schema`.", "question_id": 41732}
{"snippet": "Series.to_sql(name, con, if_exists='fail')", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `if_exists`.", "question_id": 41733}
{"snippet": "Series.to_sql(name, con, index=True)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `index`.", "question_id": 41734}
{"snippet": "Series.to_sql(name, con, index_label=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `index_label`.", "question_id": 41735}
{"snippet": "Series.to_sql(name, con, chunksize=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `chunksize`.", "question_id": 41736}
{"snippet": "Series.to_sql(name, con, dtype=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : Specify the `dtype` ( especially useful for integers with missing values ) . With arguments `name`.", "question_id": 41737}
{"snippet": "Series.to_sql(name, con, method=None)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `method`.", "question_id": 41738}
{"snippet": "Series.to_sql(name, con, schema=None, if_exists='fail')", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `schema`, `if_exists`.", "question_id": 41739}
{"snippet": "Series.to_sql(name, con, schema=None, index=True)", "intent": "Write records stored in a DataFrame to a SQL database . An sqlalchemy.engine.Connection can also be passed to `con` : With arguments `name`, `schema`, `index`.", "question_id": 41740}
{"snippet": "Series.to_string()", "intent": "Render a string representation of the Series .", "question_id": 41741}
{"snippet": "Series.to_string(buf=None)", "intent": "Render a string representation of the Series . With arguments `buf`.", "question_id": 41742}
{"snippet": "Series.to_string(na_rep='NaN')", "intent": "Render a string representation of the Series . With arguments `na_rep`.", "question_id": 41743}
{"snippet": "Series.to_string(float_format=None)", "intent": "Render a string representation of the Series . With arguments `float_format`.", "question_id": 41744}
{"snippet": "Series.to_string(header=True)", "intent": "Render a string representation of the Series . With arguments `header`.", "question_id": 41745}
{"snippet": "Series.to_string(index=True)", "intent": "Render a string representation of the Series . With arguments `index`.", "question_id": 41746}
{"snippet": "Series.to_string(length=False)", "intent": "Render a string representation of the Series . With arguments `length`.", "question_id": 41747}
{"snippet": "Series.to_string(dtype=False)", "intent": "Render a string representation of the Series . With arguments `dtype`.", "question_id": 41748}
{"snippet": "Series.to_string(name=False)", "intent": "Render a string representation of the Series . With arguments `name`.", "question_id": 41749}
{"snippet": "Series.to_string(max_rows=None)", "intent": "Render a string representation of the Series . With arguments `max_rows`.", "question_id": 41750}
{"snippet": "Series.to_string()", "intent": "Render a string representation of the Series .", "question_id": 41751}
{"snippet": "Series.to_string(buf=None)", "intent": "Render a string representation of the Series . With arguments `buf`.", "question_id": 41752}
{"snippet": "Series.to_string(na_rep='NaN')", "intent": "Render a string representation of the Series . With arguments `na_rep`.", "question_id": 41753}
{"snippet": "Series.to_string(float_format=None)", "intent": "Render a string representation of the Series . With arguments `float_format`.", "question_id": 41754}
{"snippet": "Series.to_string(header=True)", "intent": "Render a string representation of the Series . With arguments `header`.", "question_id": 41755}
{"snippet": "Series.to_string(index=True)", "intent": "Render a string representation of the Series . With arguments `index`.", "question_id": 41756}
{"snippet": "Series.to_string(length=False)", "intent": "Render a string representation of the Series . With arguments `length`.", "question_id": 41757}
{"snippet": "Series.to_string(dtype=False)", "intent": "Render a string representation of the Series . With arguments `dtype`.", "question_id": 41758}
{"snippet": "Series.to_string(name=False)", "intent": "Render a string representation of the Series . With arguments `name`.", "question_id": 41759}
{"snippet": "Series.to_string(max_rows=None)", "intent": "Render a string representation of the Series . With arguments `max_rows`.", "question_id": 41760}
{"snippet": "Series.to_string()", "intent": "Render a string representation of the Series .", "question_id": 41761}
{"snippet": "Series.to_string(buf=None)", "intent": "Render a string representation of the Series . With arguments `buf`.", "question_id": 41762}
{"snippet": "Series.to_string(na_rep='NaN')", "intent": "Render a string representation of the Series . With arguments `na_rep`.", "question_id": 41763}
{"snippet": "Series.to_string(float_format=None)", "intent": "Render a string representation of the Series . With arguments `float_format`.", "question_id": 41764}
{"snippet": "Series.to_string(header=True)", "intent": "Render a string representation of the Series . With arguments `header`.", "question_id": 41765}
{"snippet": "Series.to_string(index=True)", "intent": "Render a string representation of the Series . With arguments `index`.", "question_id": 41766}
{"snippet": "Series.to_string(length=False)", "intent": "Render a string representation of the Series . With arguments `length`.", "question_id": 41767}
{"snippet": "Series.to_string(dtype=False)", "intent": "Render a string representation of the Series . With arguments `dtype`.", "question_id": 41768}
{"snippet": "Series.to_string(name=False)", "intent": "Render a string representation of the Series . With arguments `name`.", "question_id": 41769}
{"snippet": "Series.to_string(max_rows=None)", "intent": "Render a string representation of the Series . With arguments `max_rows`.", "question_id": 41770}
{"snippet": "Series.to_timestamp()", "intent": "Cast to DatetimeIndex of Timestamps , at beginning of period .", "question_id": 41771}
{"snippet": "Series.to_timestamp(freq=None)", "intent": "Cast to DatetimeIndex of Timestamps , at beginning of period . With arguments `freq`.", "question_id": 41772}
{"snippet": "Series.to_timestamp(how='start')", "intent": "Cast to DatetimeIndex of Timestamps , at beginning of period . With arguments `how`.", "question_id": 41773}
{"snippet": "Series.to_timestamp(copy=True)", "intent": "Cast to DatetimeIndex of Timestamps , at beginning of period . With arguments `copy`.", "question_id": 41774}
{"snippet": "Series.to_timestamp(freq=None, how='start')", "intent": "Cast to DatetimeIndex of Timestamps , at beginning of period . With arguments `freq`, `how`.", "question_id": 41775}
{"snippet": "Series.to_timestamp(freq=None, copy=True)", "intent": "Cast to DatetimeIndex of Timestamps , at beginning of period . With arguments `freq`, `copy`.", "question_id": 41776}
{"snippet": "Series.to_timestamp(how='start', copy=True)", "intent": "Cast to DatetimeIndex of Timestamps , at beginning of period . With arguments `how`, `copy`.", "question_id": 41777}
{"snippet": "Series.to_timestamp(freq=None, how='start', copy=True)", "intent": "Cast to DatetimeIndex of Timestamps , at beginning of period . With arguments `freq`, `how`, `copy`.", "question_id": 41778}
{"snippet": "Series.to_timestamp()", "intent": "Cast to DatetimeIndex of Timestamps , at beginning of period .", "question_id": 41779}
{"snippet": "Series.to_timestamp(freq=None)", "intent": "Cast to DatetimeIndex of Timestamps , at beginning of period . With arguments `freq`.", "question_id": 41780}
{"snippet": "Series.to_timestamp(how='start')", "intent": "Cast to DatetimeIndex of Timestamps , at beginning of period . With arguments `how`.", "question_id": 41781}
{"snippet": "Series.to_timestamp(copy=True)", "intent": "Cast to DatetimeIndex of Timestamps , at beginning of period . With arguments `copy`.", "question_id": 41782}
{"snippet": "Series.to_timestamp(freq=None, how='start')", "intent": "Cast to DatetimeIndex of Timestamps , at beginning of period . With arguments `freq`, `how`.", "question_id": 41783}
{"snippet": "Series.to_timestamp(freq=None, copy=True)", "intent": "Cast to DatetimeIndex of Timestamps , at beginning of period . With arguments `freq`, `copy`.", "question_id": 41784}
{"snippet": "Series.to_timestamp(how='start', copy=True)", "intent": "Cast to DatetimeIndex of Timestamps , at beginning of period . With arguments `how`, `copy`.", "question_id": 41785}
{"snippet": "Series.to_timestamp(freq=None, how='start', copy=True)", "intent": "Cast to DatetimeIndex of Timestamps , at beginning of period . With arguments `freq`, `how`, `copy`.", "question_id": 41786}
{"snippet": "Series.to_timestamp()", "intent": "Cast to DatetimeIndex of Timestamps , at beginning of period .", "question_id": 41787}
{"snippet": "Series.to_timestamp(freq=None)", "intent": "Cast to DatetimeIndex of Timestamps , at beginning of period . With arguments `freq`.", "question_id": 41788}
{"snippet": "Series.to_timestamp(how='start')", "intent": "Cast to DatetimeIndex of Timestamps , at beginning of period . With arguments `how`.", "question_id": 41789}
{"snippet": "Series.to_timestamp(copy=True)", "intent": "Cast to DatetimeIndex of Timestamps , at beginning of period . With arguments `copy`.", "question_id": 41790}
{"snippet": "Series.to_timestamp(freq=None, how='start')", "intent": "Cast to DatetimeIndex of Timestamps , at beginning of period . With arguments `freq`, `how`.", "question_id": 41791}
{"snippet": "Series.to_timestamp(freq=None, copy=True)", "intent": "Cast to DatetimeIndex of Timestamps , at beginning of period . With arguments `freq`, `copy`.", "question_id": 41792}
{"snippet": "Series.to_timestamp(how='start', copy=True)", "intent": "Cast to DatetimeIndex of Timestamps , at beginning of period . With arguments `how`, `copy`.", "question_id": 41793}
{"snippet": "Series.to_timestamp(freq=None, how='start', copy=True)", "intent": "Cast to DatetimeIndex of Timestamps , at beginning of period . With arguments `freq`, `how`, `copy`.", "question_id": 41794}
{"snippet": "Series.to_xarray()", "intent": "Return an xarray object from the pandas object .", "question_id": 41795}
{"snippet": "Series.to_xarray()", "intent": "Return an xarray object from the pandas object .", "question_id": 41796}
{"snippet": "Series.to_xarray()", "intent": "Return an xarray object from the pandas object .", "question_id": 41797}
{"snippet": "Series.tolist()", "intent": "Return a list of the values .", "question_id": 41798}
{"snippet": "Series.tolist()", "intent": "Return a list of the values .", "question_id": 41799}
{"snippet": "Series.tolist()", "intent": "Return a list of the values .", "question_id": 41800}
{"snippet": "Series.transform(func, *args, **kwargs)", "intent": "Call `func` on self producing a Series with transformed values . With arguments `*args`, `**kwargs`.", "question_id": 41801}
{"snippet": "Series.transform(func, *args, **kwargs, axis=0)", "intent": "Call `func` on self producing a Series with transformed values . Produced Series will have same `axis` length as self . With arguments `*args`, `**kwargs`.", "question_id": 41802}
{"snippet": "Series.transform(func, *args, **kwargs)", "intent": "Call `func` on self producing a Series with transformed values . With arguments `*args`, `**kwargs`.", "question_id": 41803}
{"snippet": "Series.transform(func, *args, **kwargs, axis=0)", "intent": "Call `func` on self producing a Series with transformed values . Produced Series will have same `axis` length as self . With arguments `*args`, `**kwargs`.", "question_id": 41804}
{"snippet": "Series.transform(func, *args, **kwargs)", "intent": "Call `func` on self producing a Series with transformed values . With arguments `*args`, `**kwargs`.", "question_id": 41805}
{"snippet": "Series.transform(func, *args, **kwargs, axis=0)", "intent": "Call `func` on self producing a Series with transformed values . Produced Series will have same `axis` length as self . With arguments `*args`, `**kwargs`.", "question_id": 41806}
{"snippet": "Series.transpose(*args, **kwargs)", "intent": "Return the transpose , which is by definition self . With arguments `*args`, `**kwargs`.", "question_id": 41807}
{"snippet": "Series.transpose(*args, **kwargs)", "intent": "Return the transpose , which is by definition self . With arguments `*args`, `**kwargs`.", "question_id": 41808}
{"snippet": "Series.transpose(*args, **kwargs)", "intent": "Return the transpose , which is by definition self . With arguments `*args`, `**kwargs`.", "question_id": 41809}
{"snippet": "Series.truediv(other)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) .", "question_id": 41810}
{"snippet": "Series.truediv(other, level=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `level`.", "question_id": 41811}
{"snippet": "Series.truediv(other, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 41812}
{"snippet": "Series.truediv(other, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `axis`.", "question_id": 41813}
{"snippet": "Series.truediv(other, level=None, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 41814}
{"snippet": "Series.truediv(other, level=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `level`, `axis`.", "question_id": 41815}
{"snippet": "Series.truediv(other, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 41816}
{"snippet": "Series.truediv(other, level=None, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 41817}
{"snippet": "Series.truediv(other)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) .", "question_id": 41818}
{"snippet": "Series.truediv(other, level=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `level`.", "question_id": 41819}
{"snippet": "Series.truediv(other, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 41820}
{"snippet": "Series.truediv(other, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `axis`.", "question_id": 41821}
{"snippet": "Series.truediv(other, level=None, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 41822}
{"snippet": "Series.truediv(other, level=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `level`, `axis`.", "question_id": 41823}
{"snippet": "Series.truediv(other, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 41824}
{"snippet": "Series.truediv(other, level=None, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 41825}
{"snippet": "Series.truediv(other)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) .", "question_id": 41826}
{"snippet": "Series.truediv(other, level=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `level`.", "question_id": 41827}
{"snippet": "Series.truediv(other, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs .", "question_id": 41828}
{"snippet": "Series.truediv(other, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `axis`.", "question_id": 41829}
{"snippet": "Series.truediv(other, level=None, fill_value=None)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`.", "question_id": 41830}
{"snippet": "Series.truediv(other, level=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . With arguments `level`, `axis`.", "question_id": 41831}
{"snippet": "Series.truediv(other, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `axis`.", "question_id": 41832}
{"snippet": "Series.truediv(other, level=None, fill_value=None, axis=0)", "intent": "Return Floating division of series and `other` , element-wise ( binary operator truediv ) . Equivalent to series / other , but with support to substitute a `fill_value` for missing data in either one of the inputs . With arguments `level`, `axis`.", "question_id": 41833}
{"snippet": "Series.truncate()", "intent": "Truncate a Series or DataFrame `before` and `after` some index value .", "question_id": 41834}
{"snippet": "Series.truncate(before=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value .", "question_id": 41835}
{"snippet": "Series.truncate(after=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value .", "question_id": 41836}
{"snippet": "Series.truncate(axis=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `axis`.", "question_id": 41837}
{"snippet": "Series.truncate(copy=True)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `copy`.", "question_id": 41838}
{"snippet": "Series.truncate(before=None, after=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value .", "question_id": 41839}
{"snippet": "Series.truncate(before=None, axis=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `axis`.", "question_id": 41840}
{"snippet": "Series.truncate(before=None, copy=True)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `copy`.", "question_id": 41841}
{"snippet": "Series.truncate(after=None, axis=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `axis`.", "question_id": 41842}
{"snippet": "Series.truncate(after=None, copy=True)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `copy`.", "question_id": 41843}
{"snippet": "Series.truncate()", "intent": "Truncate a Series or DataFrame `before` and `after` some index value .", "question_id": 41844}
{"snippet": "Series.truncate(before=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value .", "question_id": 41845}
{"snippet": "Series.truncate(after=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value .", "question_id": 41846}
{"snippet": "Series.truncate(axis=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `axis`.", "question_id": 41847}
{"snippet": "Series.truncate(copy=True)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `copy`.", "question_id": 41848}
{"snippet": "Series.truncate(before=None, after=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value .", "question_id": 41849}
{"snippet": "Series.truncate(before=None, axis=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `axis`.", "question_id": 41850}
{"snippet": "Series.truncate(before=None, copy=True)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `copy`.", "question_id": 41851}
{"snippet": "Series.truncate(after=None, axis=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `axis`.", "question_id": 41852}
{"snippet": "Series.truncate(after=None, copy=True)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `copy`.", "question_id": 41853}
{"snippet": "Series.truncate()", "intent": "Truncate a Series or DataFrame `before` and `after` some index value .", "question_id": 41854}
{"snippet": "Series.truncate(before=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value .", "question_id": 41855}
{"snippet": "Series.truncate(after=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value .", "question_id": 41856}
{"snippet": "Series.truncate(axis=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `axis`.", "question_id": 41857}
{"snippet": "Series.truncate(copy=True)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `copy`.", "question_id": 41858}
{"snippet": "Series.truncate(before=None, after=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value .", "question_id": 41859}
{"snippet": "Series.truncate(before=None, axis=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `axis`.", "question_id": 41860}
{"snippet": "Series.truncate(before=None, copy=True)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `copy`.", "question_id": 41861}
{"snippet": "Series.truncate(after=None, axis=None)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `axis`.", "question_id": 41862}
{"snippet": "Series.truncate(after=None, copy=True)", "intent": "Truncate a Series or DataFrame `before` and `after` some index value . With arguments `copy`.", "question_id": 41863}
{"snippet": "Series.tshift()", "intent": "Shift the time index , using the index \u2019 s frequency if available .", "question_id": 41864}
{"snippet": "Series.tshift(periods=1)", "intent": "Shift the time index , using the index \u2019 s frequency if available . With arguments `periods`.", "question_id": 41865}
{"snippet": "Series.tshift(freq=None)", "intent": "Shift the time index , using the index \u2019 s frequency if available . If `freq` is not specified then tries to use the freq or inferred_freq attributes of the index .", "question_id": 41866}
{"snippet": "Series.tshift(axis=0)", "intent": "Shift the time index , using the index \u2019 s frequency if available . With arguments `axis`.", "question_id": 41867}
{"snippet": "Series.tshift(periods=1, freq=None)", "intent": "Shift the time index , using the index \u2019 s frequency if available . If `freq` is not specified then tries to use the freq or inferred_freq attributes of the index . With arguments `periods`.", "question_id": 41868}
{"snippet": "Series.tshift(periods=1, axis=0)", "intent": "Shift the time index , using the index \u2019 s frequency if available . With arguments `periods`, `axis`.", "question_id": 41869}
{"snippet": "Series.tshift(freq=None, axis=0)", "intent": "Shift the time index , using the index \u2019 s frequency if available . If `freq` is not specified then tries to use the freq or inferred_freq attributes of the index . With arguments `axis`.", "question_id": 41870}
{"snippet": "Series.tshift(periods=1, freq=None, axis=0)", "intent": "Shift the time index , using the index \u2019 s frequency if available . If `freq` is not specified then tries to use the freq or inferred_freq attributes of the index . With arguments `periods`, `axis`.", "question_id": 41871}
{"snippet": "Series.tshift()", "intent": "Shift the time index , using the index \u2019 s frequency if available .", "question_id": 41872}
{"snippet": "Series.tshift(periods=1)", "intent": "Shift the time index , using the index \u2019 s frequency if available . With arguments `periods`.", "question_id": 41873}
{"snippet": "Series.tshift(freq=None)", "intent": "Shift the time index , using the index \u2019 s frequency if available . If `freq` is not specified then tries to use the freq or inferred_freq attributes of the index .", "question_id": 41874}
{"snippet": "Series.tshift(axis=0)", "intent": "Shift the time index , using the index \u2019 s frequency if available . With arguments `axis`.", "question_id": 41875}
{"snippet": "Series.tshift(periods=1, freq=None)", "intent": "Shift the time index , using the index \u2019 s frequency if available . If `freq` is not specified then tries to use the freq or inferred_freq attributes of the index . With arguments `periods`.", "question_id": 41876}
{"snippet": "Series.tshift(periods=1, axis=0)", "intent": "Shift the time index , using the index \u2019 s frequency if available . With arguments `periods`, `axis`.", "question_id": 41877}
{"snippet": "Series.tshift(freq=None, axis=0)", "intent": "Shift the time index , using the index \u2019 s frequency if available . If `freq` is not specified then tries to use the freq or inferred_freq attributes of the index . With arguments `axis`.", "question_id": 41878}
{"snippet": "Series.tshift(periods=1, freq=None, axis=0)", "intent": "Shift the time index , using the index \u2019 s frequency if available . If `freq` is not specified then tries to use the freq or inferred_freq attributes of the index . With arguments `periods`, `axis`.", "question_id": 41879}
{"snippet": "Series.tshift()", "intent": "Shift the time index , using the index \u2019 s frequency if available .", "question_id": 41880}
{"snippet": "Series.tshift(periods=1)", "intent": "Shift the time index , using the index \u2019 s frequency if available . With arguments `periods`.", "question_id": 41881}
{"snippet": "Series.tshift(freq=None)", "intent": "Shift the time index , using the index \u2019 s frequency if available . If `freq` is not specified then tries to use the freq or inferred_freq attributes of the index .", "question_id": 41882}
{"snippet": "Series.tshift(axis=0)", "intent": "Shift the time index , using the index \u2019 s frequency if available . With arguments `axis`.", "question_id": 41883}
{"snippet": "Series.tshift(periods=1, freq=None)", "intent": "Shift the time index , using the index \u2019 s frequency if available . If `freq` is not specified then tries to use the freq or inferred_freq attributes of the index . With arguments `periods`.", "question_id": 41884}
{"snippet": "Series.tshift(periods=1, axis=0)", "intent": "Shift the time index , using the index \u2019 s frequency if available . With arguments `periods`, `axis`.", "question_id": 41885}
{"snippet": "Series.tshift(freq=None, axis=0)", "intent": "Shift the time index , using the index \u2019 s frequency if available . If `freq` is not specified then tries to use the freq or inferred_freq attributes of the index . With arguments `axis`.", "question_id": 41886}
{"snippet": "Series.tshift(periods=1, freq=None, axis=0)", "intent": "Shift the time index , using the index \u2019 s frequency if available . If `freq` is not specified then tries to use the freq or inferred_freq attributes of the index . With arguments `periods`, `axis`.", "question_id": 41887}
{"snippet": "Series.tz_convert(tz)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`.", "question_id": 41888}
{"snippet": "Series.tz_convert(tz, axis=0)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`.", "question_id": 41889}
{"snippet": "Series.tz_convert(tz, level=None)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `level`.", "question_id": 41890}
{"snippet": "Series.tz_convert(tz, copy=True)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `copy`.", "question_id": 41891}
{"snippet": "Series.tz_convert(tz, axis=0, level=None)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `level`.", "question_id": 41892}
{"snippet": "Series.tz_convert(tz, axis=0, copy=True)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `copy`.", "question_id": 41893}
{"snippet": "Series.tz_convert(tz, level=None, copy=True)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `level`, `copy`.", "question_id": 41894}
{"snippet": "Series.tz_convert(tz, axis=0, level=None, copy=True)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `level`, `copy`.", "question_id": 41895}
{"snippet": "Series.tz_convert(tz)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`.", "question_id": 41896}
{"snippet": "Series.tz_convert(tz, axis=0)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`.", "question_id": 41897}
{"snippet": "Series.tz_convert(tz, level=None)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `level`.", "question_id": 41898}
{"snippet": "Series.tz_convert(tz, copy=True)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `copy`.", "question_id": 41899}
{"snippet": "Series.tz_convert(tz, axis=0, level=None)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `level`.", "question_id": 41900}
{"snippet": "Series.tz_convert(tz, axis=0, copy=True)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `copy`.", "question_id": 41901}
{"snippet": "Series.tz_convert(tz, level=None, copy=True)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `level`, `copy`.", "question_id": 41902}
{"snippet": "Series.tz_convert(tz, axis=0, level=None, copy=True)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `level`, `copy`.", "question_id": 41903}
{"snippet": "Series.tz_convert(tz)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`.", "question_id": 41904}
{"snippet": "Series.tz_convert(tz, axis=0)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`.", "question_id": 41905}
{"snippet": "Series.tz_convert(tz, level=None)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `level`.", "question_id": 41906}
{"snippet": "Series.tz_convert(tz, copy=True)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `copy`.", "question_id": 41907}
{"snippet": "Series.tz_convert(tz, axis=0, level=None)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `level`.", "question_id": 41908}
{"snippet": "Series.tz_convert(tz, axis=0, copy=True)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `copy`.", "question_id": 41909}
{"snippet": "Series.tz_convert(tz, level=None, copy=True)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `level`, `copy`.", "question_id": 41910}
{"snippet": "Series.tz_convert(tz, axis=0, level=None, copy=True)", "intent": "Convert tz-aware `axis` to target time zone . With arguments `tz`, `level`, `copy`.", "question_id": 41911}
{"snippet": "Series.tz_localize(tz)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`.", "question_id": 41912}
{"snippet": "Series.tz_localize(tz, axis=0)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `axis`.", "question_id": 41913}
{"snippet": "Series.tz_localize(tz, level=None)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `level`.", "question_id": 41914}
{"snippet": "Series.tz_localize(tz, copy=True)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `copy`.", "question_id": 41915}
{"snippet": "Series.tz_localize(tz, ambiguous='raise')", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . In such cases , you can pass an ndarray to the `ambiguous` parameter to set the DST explicitly With arguments `tz`.", "question_id": 41916}
{"snippet": "Series.tz_localize(tz, nonexistent='raise')", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . If the DST transition causes `nonexistent` times , you can shift these dates forward or backward with a timedelta object or \u2018 shift_forward \u2019 or \u2018 shift_backward \u2019 . With arguments `tz`.", "question_id": 41917}
{"snippet": "Series.tz_localize(tz, axis=0, level=None)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `axis`, `level`.", "question_id": 41918}
{"snippet": "Series.tz_localize(tz, axis=0, copy=True)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `axis`, `copy`.", "question_id": 41919}
{"snippet": "Series.tz_localize(tz, axis=0, ambiguous='raise')", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . In such cases , you can pass an ndarray to the `ambiguous` parameter to set the DST explicitly With arguments `tz`, `axis`.", "question_id": 41920}
{"snippet": "Series.tz_localize(tz, axis=0, nonexistent='raise')", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . If the DST transition causes `nonexistent` times , you can shift these dates forward or backward with a timedelta object or \u2018 shift_forward \u2019 or \u2018 shift_backward \u2019 . With arguments `tz`, `axis`.", "question_id": 41921}
{"snippet": "Series.tz_localize(tz)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`.", "question_id": 41922}
{"snippet": "Series.tz_localize(tz, axis=0)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `axis`.", "question_id": 41923}
{"snippet": "Series.tz_localize(tz, level=None)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `level`.", "question_id": 41924}
{"snippet": "Series.tz_localize(tz, copy=True)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `copy`.", "question_id": 41925}
{"snippet": "Series.tz_localize(tz, ambiguous='raise')", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . In such cases , you can pass an ndarray to the `ambiguous` parameter to set the DST explicitly With arguments `tz`.", "question_id": 41926}
{"snippet": "Series.tz_localize(tz, nonexistent='raise')", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . If the DST transition causes `nonexistent` times , you can shift these dates forward or backward with a timedelta object or \u2018 shift_forward \u2019 or \u2018 shift_backward \u2019 . With arguments `tz`.", "question_id": 41927}
{"snippet": "Series.tz_localize(tz, axis=0, level=None)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `axis`, `level`.", "question_id": 41928}
{"snippet": "Series.tz_localize(tz, axis=0, copy=True)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `axis`, `copy`.", "question_id": 41929}
{"snippet": "Series.tz_localize(tz, axis=0, ambiguous='raise')", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . In such cases , you can pass an ndarray to the `ambiguous` parameter to set the DST explicitly With arguments `tz`, `axis`.", "question_id": 41930}
{"snippet": "Series.tz_localize(tz, axis=0, nonexistent='raise')", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . If the DST transition causes `nonexistent` times , you can shift these dates forward or backward with a timedelta object or \u2018 shift_forward \u2019 or \u2018 shift_backward \u2019 . With arguments `tz`, `axis`.", "question_id": 41931}
{"snippet": "Series.tz_localize(tz)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`.", "question_id": 41932}
{"snippet": "Series.tz_localize(tz, axis=0)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `axis`.", "question_id": 41933}
{"snippet": "Series.tz_localize(tz, level=None)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `level`.", "question_id": 41934}
{"snippet": "Series.tz_localize(tz, copy=True)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `copy`.", "question_id": 41935}
{"snippet": "Series.tz_localize(tz, ambiguous='raise')", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . In such cases , you can pass an ndarray to the `ambiguous` parameter to set the DST explicitly With arguments `tz`.", "question_id": 41936}
{"snippet": "Series.tz_localize(tz, nonexistent='raise')", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . If the DST transition causes `nonexistent` times , you can shift these dates forward or backward with a timedelta object or \u2018 shift_forward \u2019 or \u2018 shift_backward \u2019 . With arguments `tz`.", "question_id": 41937}
{"snippet": "Series.tz_localize(tz, axis=0, level=None)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `axis`, `level`.", "question_id": 41938}
{"snippet": "Series.tz_localize(tz, axis=0, copy=True)", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . With arguments `tz`, `axis`, `copy`.", "question_id": 41939}
{"snippet": "Series.tz_localize(tz, axis=0, ambiguous='raise')", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . In such cases , you can pass an ndarray to the `ambiguous` parameter to set the DST explicitly With arguments `tz`, `axis`.", "question_id": 41940}
{"snippet": "Series.tz_localize(tz, axis=0, nonexistent='raise')", "intent": "Localize tz-naive index of a Series or DataFrame to target time zone . If the DST transition causes `nonexistent` times , you can shift these dates forward or backward with a timedelta object or \u2018 shift_forward \u2019 or \u2018 shift_backward \u2019 . With arguments `tz`, `axis`.", "question_id": 41941}
{"snippet": "Series.unique()", "intent": "Return unique values of Series object .", "question_id": 41942}
{"snippet": "Series.unique()", "intent": "Return unique values of Series object .", "question_id": 41943}
{"snippet": "Series.unique()", "intent": "Return unique values of Series object .", "question_id": 41944}
{"snippet": "Series.unstack()", "intent": "Unstack , also known as pivot , Series with MultiIndex to produce DataFrame .", "question_id": 41945}
{"snippet": "Series.unstack(level=- 1)", "intent": "Unstack , also known as pivot , Series with MultiIndex to produce DataFrame . With arguments `level`.", "question_id": 41946}
{"snippet": "Series.unstack(fill_value=None)", "intent": "Unstack , also known as pivot , Series with MultiIndex to produce DataFrame . With arguments `fill_value`.", "question_id": 41947}
{"snippet": "Series.unstack(level=- 1, fill_value=None)", "intent": "Unstack , also known as pivot , Series with MultiIndex to produce DataFrame . With arguments `level`, `fill_value`.", "question_id": 41948}
{"snippet": "Series.unstack()", "intent": "Unstack , also known as pivot , Series with MultiIndex to produce DataFrame .", "question_id": 41949}
{"snippet": "Series.unstack(level=- 1)", "intent": "Unstack , also known as pivot , Series with MultiIndex to produce DataFrame . With arguments `level`.", "question_id": 41950}
{"snippet": "Series.unstack(fill_value=None)", "intent": "Unstack , also known as pivot , Series with MultiIndex to produce DataFrame . With arguments `fill_value`.", "question_id": 41951}
{"snippet": "Series.unstack(level=- 1, fill_value=None)", "intent": "Unstack , also known as pivot , Series with MultiIndex to produce DataFrame . With arguments `level`, `fill_value`.", "question_id": 41952}
{"snippet": "Series.unstack()", "intent": "Unstack , also known as pivot , Series with MultiIndex to produce DataFrame .", "question_id": 41953}
{"snippet": "Series.unstack(level=- 1)", "intent": "Unstack , also known as pivot , Series with MultiIndex to produce DataFrame . With arguments `level`.", "question_id": 41954}
{"snippet": "Series.unstack(fill_value=None)", "intent": "Unstack , also known as pivot , Series with MultiIndex to produce DataFrame . With arguments `fill_value`.", "question_id": 41955}
{"snippet": "Series.unstack(level=- 1, fill_value=None)", "intent": "Unstack , also known as pivot , Series with MultiIndex to produce DataFrame . With arguments `level`, `fill_value`.", "question_id": 41956}
{"snippet": "Series.update(other)", "intent": "Modify Series in place using values from passed Series . If `other` contains NaNs the corresponding values are not updated in the original Series .", "question_id": 41957}
{"snippet": "Series.update(other)", "intent": "Modify Series in place using values from passed Series . If `other` contains NaNs the corresponding values are not updated in the original Series .", "question_id": 41958}
{"snippet": "Series.update(other)", "intent": "Modify Series in place using values from passed Series . If `other` contains NaNs the corresponding values are not updated in the original Series .", "question_id": 41959}
{"snippet": "Series.value_counts()", "intent": "Return a Series containing counts of unique values .", "question_id": 41960}
{"snippet": "Series.value_counts(normalize=False)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values .", "question_id": 41961}
{"snippet": "Series.value_counts(sort=True)", "intent": "Return a Series containing counts of unique values . With arguments `sort`.", "question_id": 41962}
{"snippet": "Series.value_counts(ascending=False)", "intent": "Return a Series containing counts of unique values . With arguments `ascending`.", "question_id": 41963}
{"snippet": "Series.value_counts(bins=None)", "intent": "Return a Series containing counts of unique values . `bins`", "question_id": 41964}
{"snippet": "Series.value_counts(dropna=True)", "intent": "Return a Series containing counts of unique values . `dropna`", "question_id": 41965}
{"snippet": "Series.value_counts(normalize=False, sort=True)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values . With arguments `sort`.", "question_id": 41966}
{"snippet": "Series.value_counts(normalize=False, ascending=False)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values . With arguments `ascending`.", "question_id": 41967}
{"snippet": "Series.value_counts(normalize=False, bins=None)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values . `bins`", "question_id": 41968}
{"snippet": "Series.value_counts(normalize=False, dropna=True)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values . `dropna`", "question_id": 41969}
{"snippet": "Series.value_counts()", "intent": "Return a Series containing counts of unique values .", "question_id": 41970}
{"snippet": "Series.value_counts(normalize=False)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values .", "question_id": 41971}
{"snippet": "Series.value_counts(sort=True)", "intent": "Return a Series containing counts of unique values . With arguments `sort`.", "question_id": 41972}
{"snippet": "Series.value_counts(ascending=False)", "intent": "Return a Series containing counts of unique values . With arguments `ascending`.", "question_id": 41973}
{"snippet": "Series.value_counts(bins=None)", "intent": "Return a Series containing counts of unique values . `bins`", "question_id": 41974}
{"snippet": "Series.value_counts(dropna=True)", "intent": "Return a Series containing counts of unique values . `dropna`", "question_id": 41975}
{"snippet": "Series.value_counts(normalize=False, sort=True)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values . With arguments `sort`.", "question_id": 41976}
{"snippet": "Series.value_counts(normalize=False, ascending=False)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values . With arguments `ascending`.", "question_id": 41977}
{"snippet": "Series.value_counts(normalize=False, bins=None)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values . `bins`", "question_id": 41978}
{"snippet": "Series.value_counts(normalize=False, dropna=True)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values . `dropna`", "question_id": 41979}
{"snippet": "Series.value_counts()", "intent": "Return a Series containing counts of unique values .", "question_id": 41980}
{"snippet": "Series.value_counts(normalize=False)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values .", "question_id": 41981}
{"snippet": "Series.value_counts(sort=True)", "intent": "Return a Series containing counts of unique values . With arguments `sort`.", "question_id": 41982}
{"snippet": "Series.value_counts(ascending=False)", "intent": "Return a Series containing counts of unique values . With arguments `ascending`.", "question_id": 41983}
{"snippet": "Series.value_counts(bins=None)", "intent": "Return a Series containing counts of unique values . `bins`", "question_id": 41984}
{"snippet": "Series.value_counts(dropna=True)", "intent": "Return a Series containing counts of unique values . `dropna`", "question_id": 41985}
{"snippet": "Series.value_counts(normalize=False, sort=True)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values . With arguments `sort`.", "question_id": 41986}
{"snippet": "Series.value_counts(normalize=False, ascending=False)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values . With arguments `ascending`.", "question_id": 41987}
{"snippet": "Series.value_counts(normalize=False, bins=None)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values . `bins`", "question_id": 41988}
{"snippet": "Series.value_counts(normalize=False, dropna=True)", "intent": "Return a Series containing counts of unique values . With `normalize` set to True , returns the relative frequency by dividing all values by the sum of values . `dropna`", "question_id": 41989}
{"snippet": "Series.var(**kwargs)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`.", "question_id": 41990}
{"snippet": "Series.var(**kwargs, axis=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`.", "question_id": 41991}
{"snippet": "Series.var(**kwargs, skipna=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 41992}
{"snippet": "Series.var(**kwargs, level=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 41993}
{"snippet": "Series.var(**kwargs, ddof=1)", "intent": "Return unbiased variance over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 41994}
{"snippet": "Series.var(**kwargs, numeric_only=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 41995}
{"snippet": "Series.var(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 41996}
{"snippet": "Series.var(**kwargs, axis=None, level=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 41997}
{"snippet": "Series.var(**kwargs, axis=None, ddof=1)", "intent": "Return unbiased variance over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 41998}
{"snippet": "Series.var(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 41999}
{"snippet": "Series.var(**kwargs)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`.", "question_id": 42000}
{"snippet": "Series.var(**kwargs, axis=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`.", "question_id": 42001}
{"snippet": "Series.var(**kwargs, skipna=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 42002}
{"snippet": "Series.var(**kwargs, level=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 42003}
{"snippet": "Series.var(**kwargs, ddof=1)", "intent": "Return unbiased variance over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 42004}
{"snippet": "Series.var(**kwargs, numeric_only=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 42005}
{"snippet": "Series.var(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 42006}
{"snippet": "Series.var(**kwargs, axis=None, level=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 42007}
{"snippet": "Series.var(**kwargs, axis=None, ddof=1)", "intent": "Return unbiased variance over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 42008}
{"snippet": "Series.var(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 42009}
{"snippet": "Series.var(**kwargs)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`.", "question_id": 42010}
{"snippet": "Series.var(**kwargs, axis=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`.", "question_id": 42011}
{"snippet": "Series.var(**kwargs, skipna=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 42012}
{"snippet": "Series.var(**kwargs, level=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 42013}
{"snippet": "Series.var(**kwargs, ddof=1)", "intent": "Return unbiased variance over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 42014}
{"snippet": "Series.var(**kwargs, numeric_only=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 42015}
{"snippet": "Series.var(**kwargs, axis=None, skipna=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `skipna`.", "question_id": 42016}
{"snippet": "Series.var(**kwargs, axis=None, level=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `level`.", "question_id": 42017}
{"snippet": "Series.var(**kwargs, axis=None, ddof=1)", "intent": "Return unbiased variance over requested `axis` . This can be changed using the `ddof` argument With arguments `**kwargs`.", "question_id": 42018}
{"snippet": "Series.var(**kwargs, axis=None, numeric_only=None)", "intent": "Return unbiased variance over requested `axis` . With arguments `**kwargs`, `numeric_only`.", "question_id": 42019}
{"snippet": "Series.view()", "intent": "Create a new view of the Series .", "question_id": 42020}
{"snippet": "Series.view(dtype=None)", "intent": "Create a new view of the Series . While numpy.ndarray.view ( ) will return a view with the same data type as the original array , Series.view ( ) ( without specified `dtype` ) will try using float64 and may fail if the original data type size in bytes is not the same .", "question_id": 42021}
{"snippet": "Series.view()", "intent": "Create a new view of the Series .", "question_id": 42022}
{"snippet": "Series.view(dtype=None)", "intent": "Create a new view of the Series . While numpy.ndarray.view ( ) will return a view with the same data type as the original array , Series.view ( ) ( without specified `dtype` ) will try using float64 and may fail if the original data type size in bytes is not the same .", "question_id": 42023}
{"snippet": "Series.view()", "intent": "Create a new view of the Series .", "question_id": 42024}
{"snippet": "Series.view(dtype=None)", "intent": "Create a new view of the Series . While numpy.ndarray.view ( ) will return a view with the same data type as the original array , Series.view ( ) ( without specified `dtype` ) will try using float64 and may fail if the original data type size in bytes is not the same .", "question_id": 42025}
{"snippet": "Series.where(cond)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used .", "question_id": 42026}
{"snippet": "Series.where(cond, other=nan)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used .", "question_id": 42027}
{"snippet": "Series.where(cond, inplace=False)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `inplace`.", "question_id": 42028}
{"snippet": "Series.where(cond, axis=None)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `axis`.", "question_id": 42029}
{"snippet": "Series.where(cond, level=None)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `level`.", "question_id": 42030}
{"snippet": "Series.where(cond, errors='raise')", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `errors`.", "question_id": 42031}
{"snippet": "Series.where(cond, try_cast=NoDefault.no_default)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `try_cast`.", "question_id": 42032}
{"snippet": "Series.where(cond, other=nan, inplace=False)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `inplace`.", "question_id": 42033}
{"snippet": "Series.where(cond, other=nan, axis=None)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `axis`.", "question_id": 42034}
{"snippet": "Series.where(cond, other=nan, level=None)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `level`.", "question_id": 42035}
{"snippet": "Series.where(cond)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used .", "question_id": 42036}
{"snippet": "Series.where(cond, other=nan)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used .", "question_id": 42037}
{"snippet": "Series.where(cond, inplace=False)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `inplace`.", "question_id": 42038}
{"snippet": "Series.where(cond, axis=None)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `axis`.", "question_id": 42039}
{"snippet": "Series.where(cond, level=None)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `level`.", "question_id": 42040}
{"snippet": "Series.where(cond, errors='raise')", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `errors`.", "question_id": 42041}
{"snippet": "Series.where(cond, try_cast=NoDefault.no_default)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `try_cast`.", "question_id": 42042}
{"snippet": "Series.where(cond, other=nan, inplace=False)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `inplace`.", "question_id": 42043}
{"snippet": "Series.where(cond, other=nan, axis=None)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `axis`.", "question_id": 42044}
{"snippet": "Series.where(cond, other=nan, level=None)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `level`.", "question_id": 42045}
{"snippet": "Series.where(cond)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used .", "question_id": 42046}
{"snippet": "Series.where(cond, other=nan)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used .", "question_id": 42047}
{"snippet": "Series.where(cond, inplace=False)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `inplace`.", "question_id": 42048}
{"snippet": "Series.where(cond, axis=None)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `axis`.", "question_id": 42049}
{"snippet": "Series.where(cond, level=None)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `level`.", "question_id": 42050}
{"snippet": "Series.where(cond, errors='raise')", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `errors`.", "question_id": 42051}
{"snippet": "Series.where(cond, try_cast=NoDefault.no_default)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `try_cast`.", "question_id": 42052}
{"snippet": "Series.where(cond, other=nan, inplace=False)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `inplace`.", "question_id": 42053}
{"snippet": "Series.where(cond, other=nan, axis=None)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `axis`.", "question_id": 42054}
{"snippet": "Series.where(cond, other=nan, level=None)", "intent": "Replace values where the condition is False . For each element in the calling DataFrame , if `cond` is True the element is used ; otherwise the corresponding element from the DataFrame `other` is used . With arguments `level`.", "question_id": 42055}
{"snippet": "Series.xs(key)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex .", "question_id": 42056}
{"snippet": "Series.xs(key, axis=0)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . Get values at specified column and `axis`", "question_id": 42057}
{"snippet": "Series.xs(key, level=None)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex .", "question_id": 42058}
{"snippet": "Series.xs(key, drop_level=True)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . With arguments `drop_level`.", "question_id": 42059}
{"snippet": "Series.xs(key, axis=0, level=None)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . Get values at specified column and `axis`", "question_id": 42060}
{"snippet": "Series.xs(key, axis=0, drop_level=True)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . Get values at specified column and `axis` With arguments `drop_level`.", "question_id": 42061}
{"snippet": "Series.xs(key, level=None, drop_level=True)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . With arguments `drop_level`.", "question_id": 42062}
{"snippet": "Series.xs(key, axis=0, level=None, drop_level=True)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . Get values at specified column and `axis` With arguments `drop_level`.", "question_id": 42063}
{"snippet": "Series.xs(key)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex .", "question_id": 42064}
{"snippet": "Series.xs(key, axis=0)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . Get values at specified column and `axis`", "question_id": 42065}
{"snippet": "Series.xs(key, level=None)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex .", "question_id": 42066}
{"snippet": "Series.xs(key, drop_level=True)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . With arguments `drop_level`.", "question_id": 42067}
{"snippet": "Series.xs(key, axis=0, level=None)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . Get values at specified column and `axis`", "question_id": 42068}
{"snippet": "Series.xs(key, axis=0, drop_level=True)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . Get values at specified column and `axis` With arguments `drop_level`.", "question_id": 42069}
{"snippet": "Series.xs(key, level=None, drop_level=True)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . With arguments `drop_level`.", "question_id": 42070}
{"snippet": "Series.xs(key, axis=0, level=None, drop_level=True)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . Get values at specified column and `axis` With arguments `drop_level`.", "question_id": 42071}
{"snippet": "Series.xs(key)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex .", "question_id": 42072}
{"snippet": "Series.xs(key, axis=0)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . Get values at specified column and `axis`", "question_id": 42073}
{"snippet": "Series.xs(key, level=None)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex .", "question_id": 42074}
{"snippet": "Series.xs(key, drop_level=True)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . With arguments `drop_level`.", "question_id": 42075}
{"snippet": "Series.xs(key, axis=0, level=None)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . Get values at specified column and `axis`", "question_id": 42076}
{"snippet": "Series.xs(key, axis=0, drop_level=True)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . Get values at specified column and `axis` With arguments `drop_level`.", "question_id": 42077}
{"snippet": "Series.xs(key, level=None, drop_level=True)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . With arguments `drop_level`.", "question_id": 42078}
{"snippet": "Series.xs(key, axis=0, level=None, drop_level=True)", "intent": "Return cross-section from the Series/DataFrame . This method takes a `key` argument to select data at a particular `level` of a MultiIndex . Get values at specified column and `axis` With arguments `drop_level`.", "question_id": 42079}
{"snippet": "pandas.SparseDtype()", "intent": "Dtype for data stored in SparseArray .", "question_id": 42080}
{"snippet": "pandas.SparseDtype(dtype=<class 'numpy.float64'>)", "intent": "Dtype for data stored in SparseArray . This `dtype` implements the pandas ExtensionDtype interface .", "question_id": 42081}
{"snippet": "pandas.SparseDtype(fill_value=None)", "intent": "Dtype for data stored in SparseArray . With arguments `fill_value`.", "question_id": 42082}
{"snippet": "pandas.SparseDtype(dtype=<class 'numpy.float64'>, fill_value=None)", "intent": "Dtype for data stored in SparseArray . This `dtype` implements the pandas ExtensionDtype interface . With arguments `fill_value`.", "question_id": 42083}
{"snippet": "pandas.SparseDtype()", "intent": "Dtype for data stored in SparseArray .", "question_id": 42084}
{"snippet": "pandas.SparseDtype(dtype=<class 'numpy.float64'>)", "intent": "Dtype for data stored in SparseArray . This `dtype` implements the pandas ExtensionDtype interface .", "question_id": 42085}
{"snippet": "pandas.SparseDtype(fill_value=None)", "intent": "Dtype for data stored in SparseArray . With arguments `fill_value`.", "question_id": 42086}
{"snippet": "pandas.SparseDtype(dtype=<class 'numpy.float64'>, fill_value=None)", "intent": "Dtype for data stored in SparseArray . This `dtype` implements the pandas ExtensionDtype interface . With arguments `fill_value`.", "question_id": 42087}
{"snippet": "pandas.SparseDtype()", "intent": "Dtype for data stored in SparseArray .", "question_id": 42088}
{"snippet": "pandas.SparseDtype(dtype=<class 'numpy.float64'>)", "intent": "Dtype for data stored in SparseArray . This `dtype` implements the pandas ExtensionDtype interface .", "question_id": 42089}
{"snippet": "pandas.SparseDtype(fill_value=None)", "intent": "Dtype for data stored in SparseArray . With arguments `fill_value`.", "question_id": 42090}
{"snippet": "pandas.SparseDtype(dtype=<class 'numpy.float64'>, fill_value=None)", "intent": "Dtype for data stored in SparseArray . This `dtype` implements the pandas ExtensionDtype interface . With arguments `fill_value`.", "question_id": 42091}
{"snippet": "pandas.StringDtype()", "intent": "Extension dtype for string data .", "question_id": 42092}
{"snippet": "pandas.StringDtype(storage=None)", "intent": "Extension dtype for string data . With arguments `storage`.", "question_id": 42093}
{"snippet": "pandas.StringDtype()", "intent": "Extension dtype for string data .", "question_id": 42094}
{"snippet": "pandas.StringDtype(storage=None)", "intent": "Extension dtype for string data . With arguments `storage`.", "question_id": 42095}
{"snippet": "pandas.StringDtype()", "intent": "Extension dtype for string data .", "question_id": 42096}
{"snippet": "pandas.StringDtype(storage=None)", "intent": "Extension dtype for string data . With arguments `storage`.", "question_id": 42097}
{"snippet": "Timedelta.asm8", "intent": "Return a numpy timedelta64 array scalar view.", "question_id": 42098}
{"snippet": "Timedelta.asm8", "intent": "Return a numpy timedelta64 array scalar view.", "question_id": 42099}
{"snippet": "Timedelta.asm8", "intent": "Return a numpy timedelta64 array scalar view.", "question_id": 42100}
{"snippet": "Timedelta.ceil(freq)", "intent": "Return a new Timedelta ceiled to this resolution . With arguments `freq`.", "question_id": 42101}
{"snippet": "Timedelta.ceil(freq)", "intent": "Return a new Timedelta ceiled to this resolution . With arguments `freq`.", "question_id": 42102}
{"snippet": "Timedelta.ceil(freq)", "intent": "Return a new Timedelta ceiled to this resolution . With arguments `freq`.", "question_id": 42103}
{"snippet": "Timedelta.components", "intent": "Return a components namedtuple-like.", "question_id": 42104}
{"snippet": "Timedelta.components", "intent": "Return a components namedtuple-like.", "question_id": 42105}
{"snippet": "Timedelta.components", "intent": "Return a components namedtuple-like.", "question_id": 42106}
{"snippet": "Timedelta.days", "intent": "Number of days.", "question_id": 42107}
{"snippet": "Timedelta.days", "intent": "Number of days.", "question_id": 42108}
{"snippet": "Timedelta.days", "intent": "Number of days.", "question_id": 42109}
{"snippet": "Timedelta.delta", "intent": "Return the timedelta in nanoseconds (ns), for internal compatibility.", "question_id": 42110}
{"snippet": "Timedelta.delta", "intent": "Return the timedelta in nanoseconds (ns), for internal compatibility.", "question_id": 42111}
{"snippet": "Timedelta.delta", "intent": "Return the timedelta in nanoseconds (ns), for internal compatibility.", "question_id": 42112}
{"snippet": "Timedelta.floor(freq)", "intent": "Return a new Timedelta floored to this resolution . With arguments `freq`.", "question_id": 42113}
{"snippet": "Timedelta.floor(freq)", "intent": "Return a new Timedelta floored to this resolution . With arguments `freq`.", "question_id": 42114}
{"snippet": "Timedelta.floor(freq)", "intent": "Return a new Timedelta floored to this resolution . With arguments `freq`.", "question_id": 42115}
{"snippet": "pandas.Timedelta(**kwargs)", "intent": "Represents a duration , the difference between two dates or times . With arguments `**kwargs`.", "question_id": 42116}
{"snippet": "pandas.Timedelta(**kwargs, value=<object object>)", "intent": "Represents a duration , the difference between two dates or times . With arguments `**kwargs`, `value`.", "question_id": 42117}
{"snippet": "pandas.Timedelta(**kwargs, unit=None)", "intent": "Represents a duration , the difference between two dates or times . With arguments `**kwargs`, `unit`.", "question_id": 42118}
{"snippet": "pandas.Timedelta(**kwargs, value=<object object>, unit=None)", "intent": "Represents a duration , the difference between two dates or times . With arguments `**kwargs`, `value`, `unit`.", "question_id": 42119}
{"snippet": "pandas.Timedelta(**kwargs)", "intent": "Represents a duration , the difference between two dates or times . With arguments `**kwargs`.", "question_id": 42120}
{"snippet": "pandas.Timedelta(**kwargs, value=<object object>)", "intent": "Represents a duration , the difference between two dates or times . With arguments `**kwargs`, `value`.", "question_id": 42121}
{"snippet": "pandas.Timedelta(**kwargs, unit=None)", "intent": "Represents a duration , the difference between two dates or times . With arguments `**kwargs`, `unit`.", "question_id": 42122}
{"snippet": "pandas.Timedelta(**kwargs, value=<object object>, unit=None)", "intent": "Represents a duration , the difference between two dates or times . With arguments `**kwargs`, `value`, `unit`.", "question_id": 42123}
{"snippet": "pandas.Timedelta(**kwargs)", "intent": "Represents a duration , the difference between two dates or times . With arguments `**kwargs`.", "question_id": 42124}
{"snippet": "pandas.Timedelta(**kwargs, value=<object object>)", "intent": "Represents a duration , the difference between two dates or times . With arguments `**kwargs`, `value`.", "question_id": 42125}
{"snippet": "pandas.Timedelta(**kwargs, unit=None)", "intent": "Represents a duration , the difference between two dates or times . With arguments `**kwargs`, `unit`.", "question_id": 42126}
{"snippet": "pandas.Timedelta(**kwargs, value=<object object>, unit=None)", "intent": "Represents a duration , the difference between two dates or times . With arguments `**kwargs`, `value`, `unit`.", "question_id": 42127}
{"snippet": "Timedelta.isoformat()", "intent": "Format Timedelta as ISO 8601 Duration like P [ n ] Y [ n ] M [ n ] DT [ n ] H [ n ] M [ n ] S , where the [ n ] s are replaced by the values .", "question_id": 42128}
{"snippet": "Timedelta.isoformat()", "intent": "Format Timedelta as ISO 8601 Duration like P [ n ] Y [ n ] M [ n ] DT [ n ] H [ n ] M [ n ] S , where the [ n ] s are replaced by the values .", "question_id": 42129}
{"snippet": "Timedelta.isoformat()", "intent": "Format Timedelta as ISO 8601 Duration like P [ n ] Y [ n ] M [ n ] DT [ n ] H [ n ] M [ n ] S , where the [ n ] s are replaced by the values .", "question_id": 42130}
{"snippet": "Timedelta.microseconds", "intent": "Number of microseconds (>= 0 and less than 1 second).", "question_id": 42131}
{"snippet": "Timedelta.microseconds", "intent": "Number of microseconds (>= 0 and less than 1 second).", "question_id": 42132}
{"snippet": "Timedelta.microseconds", "intent": "Number of microseconds (>= 0 and less than 1 second).", "question_id": 42133}
{"snippet": "Timedelta.nanoseconds", "intent": "Return the number of nanoseconds (n), where 0 <= n < 1 microsecond.", "question_id": 42134}
{"snippet": "Timedelta.nanoseconds", "intent": "Return the number of nanoseconds (n), where 0 <= n < 1 microsecond.", "question_id": 42135}
{"snippet": "Timedelta.nanoseconds", "intent": "Return the number of nanoseconds (n), where 0 <= n < 1 microsecond.", "question_id": 42136}
{"snippet": "Timedelta.resolution_string", "intent": "Return a string representing the lowest timedelta resolution.", "question_id": 42137}
{"snippet": "Timedelta.resolution_string", "intent": "Return a string representing the lowest timedelta resolution.", "question_id": 42138}
{"snippet": "Timedelta.resolution_string", "intent": "Return a string representing the lowest timedelta resolution.", "question_id": 42139}
{"snippet": "Timedelta.round(freq)", "intent": "Round the Timedelta to the specified resolution . With arguments `freq`.", "question_id": 42140}
{"snippet": "Timedelta.round(freq)", "intent": "Round the Timedelta to the specified resolution . With arguments `freq`.", "question_id": 42141}
{"snippet": "Timedelta.round(freq)", "intent": "Round the Timedelta to the specified resolution . With arguments `freq`.", "question_id": 42142}
{"snippet": "Timedelta.seconds", "intent": "Number of seconds (>= 0 and less than 1 day).", "question_id": 42143}
{"snippet": "Timedelta.seconds", "intent": "Number of seconds (>= 0 and less than 1 day).", "question_id": 42144}
{"snippet": "Timedelta.seconds", "intent": "Number of seconds (>= 0 and less than 1 day).", "question_id": 42145}
{"snippet": "Timedelta.to_numpy()", "intent": "Convert the Timedelta to a NumPy timedelta64 .", "question_id": 42146}
{"snippet": "Timedelta.to_numpy()", "intent": "Convert the Timedelta to a NumPy timedelta64 .", "question_id": 42147}
{"snippet": "Timedelta.to_numpy()", "intent": "Convert the Timedelta to a NumPy timedelta64 .", "question_id": 42148}
{"snippet": "Timedelta.to_pytimedelta()", "intent": "Convert a pandas Timedelta object into a python timedelta object .", "question_id": 42149}
{"snippet": "Timedelta.to_pytimedelta()", "intent": "Convert a pandas Timedelta object into a python timedelta object .", "question_id": 42150}
{"snippet": "Timedelta.to_pytimedelta()", "intent": "Convert a pandas Timedelta object into a python timedelta object .", "question_id": 42151}
{"snippet": "Timedelta.to_timedelta64()", "intent": "Return a numpy.timedelta64 object with \u2018 ns \u2019 precision .", "question_id": 42152}
{"snippet": "Timedelta.to_timedelta64()", "intent": "Return a numpy.timedelta64 object with \u2018 ns \u2019 precision .", "question_id": 42153}
{"snippet": "Timedelta.to_timedelta64()", "intent": "Return a numpy.timedelta64 object with \u2018 ns \u2019 precision .", "question_id": 42154}
{"snippet": "Timedelta.total_seconds()", "intent": "Total seconds in the duration .", "question_id": 42155}
{"snippet": "Timedelta.total_seconds()", "intent": "Total seconds in the duration .", "question_id": 42156}
{"snippet": "Timedelta.total_seconds()", "intent": "Total seconds in the duration .", "question_id": 42157}
{"snippet": "Timedelta.view()", "intent": "Array view compatibility .", "question_id": 42158}
{"snippet": "Timedelta.view()", "intent": "Array view compatibility .", "question_id": 42159}
{"snippet": "Timedelta.view()", "intent": "Array view compatibility .", "question_id": 42160}
{"snippet": "TimedeltaIndex.ceil(*args, **kwargs)", "intent": "Perform ceil operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 42161}
{"snippet": "TimedeltaIndex.ceil(*args, **kwargs)", "intent": "Perform ceil operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 42162}
{"snippet": "TimedeltaIndex.ceil(*args, **kwargs)", "intent": "Perform ceil operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 42163}
{"snippet": "TimedeltaIndex.floor(*args, **kwargs)", "intent": "Perform floor operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 42164}
{"snippet": "TimedeltaIndex.floor(*args, **kwargs)", "intent": "Perform floor operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 42165}
{"snippet": "TimedeltaIndex.floor(*args, **kwargs)", "intent": "Perform floor operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 42166}
{"snippet": "pandas.TimedeltaIndex()", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects .", "question_id": 42167}
{"snippet": "pandas.TimedeltaIndex(data=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects .", "question_id": 42168}
{"snippet": "pandas.TimedeltaIndex(unit=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `unit`.", "question_id": 42169}
{"snippet": "pandas.TimedeltaIndex(freq=NoDefault.no_default)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `freq`.", "question_id": 42170}
{"snippet": "pandas.TimedeltaIndex(closed=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `closed`.", "question_id": 42171}
{"snippet": "pandas.TimedeltaIndex(dtype=dtype('<m8ns'))", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `dtype`.", "question_id": 42172}
{"snippet": "pandas.TimedeltaIndex(copy=False)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `copy`.", "question_id": 42173}
{"snippet": "pandas.TimedeltaIndex(name=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `name`.", "question_id": 42174}
{"snippet": "pandas.TimedeltaIndex(data=None, unit=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `unit`.", "question_id": 42175}
{"snippet": "pandas.TimedeltaIndex(data=None, freq=NoDefault.no_default)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `freq`.", "question_id": 42176}
{"snippet": "pandas.TimedeltaIndex()", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects .", "question_id": 42177}
{"snippet": "pandas.TimedeltaIndex(data=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects .", "question_id": 42178}
{"snippet": "pandas.TimedeltaIndex(unit=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `unit`.", "question_id": 42179}
{"snippet": "pandas.TimedeltaIndex(freq=NoDefault.no_default)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `freq`.", "question_id": 42180}
{"snippet": "pandas.TimedeltaIndex(closed=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `closed`.", "question_id": 42181}
{"snippet": "pandas.TimedeltaIndex(dtype=dtype('<m8ns'))", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `dtype`.", "question_id": 42182}
{"snippet": "pandas.TimedeltaIndex(copy=False)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `copy`.", "question_id": 42183}
{"snippet": "pandas.TimedeltaIndex(name=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `name`.", "question_id": 42184}
{"snippet": "pandas.TimedeltaIndex(data=None, unit=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `unit`.", "question_id": 42185}
{"snippet": "pandas.TimedeltaIndex(data=None, freq=NoDefault.no_default)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `freq`.", "question_id": 42186}
{"snippet": "pandas.TimedeltaIndex()", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects .", "question_id": 42187}
{"snippet": "pandas.TimedeltaIndex(data=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects .", "question_id": 42188}
{"snippet": "pandas.TimedeltaIndex(unit=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `unit`.", "question_id": 42189}
{"snippet": "pandas.TimedeltaIndex(freq=NoDefault.no_default)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `freq`.", "question_id": 42190}
{"snippet": "pandas.TimedeltaIndex(closed=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `closed`.", "question_id": 42191}
{"snippet": "pandas.TimedeltaIndex(dtype=dtype('<m8ns'))", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `dtype`.", "question_id": 42192}
{"snippet": "pandas.TimedeltaIndex(copy=False)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `copy`.", "question_id": 42193}
{"snippet": "pandas.TimedeltaIndex(name=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `name`.", "question_id": 42194}
{"snippet": "pandas.TimedeltaIndex(data=None, unit=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `unit`.", "question_id": 42195}
{"snippet": "pandas.TimedeltaIndex(data=None, freq=NoDefault.no_default)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `freq`.", "question_id": 42196}
{"snippet": "pandas.TimedeltaIndex()", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects .", "question_id": 42197}
{"snippet": "pandas.TimedeltaIndex(data=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects .", "question_id": 42198}
{"snippet": "pandas.TimedeltaIndex(unit=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `unit`.", "question_id": 42199}
{"snippet": "pandas.TimedeltaIndex(freq=NoDefault.no_default)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `freq`.", "question_id": 42200}
{"snippet": "pandas.TimedeltaIndex(closed=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `closed`.", "question_id": 42201}
{"snippet": "pandas.TimedeltaIndex(dtype=dtype('<m8ns'))", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `dtype`.", "question_id": 42202}
{"snippet": "pandas.TimedeltaIndex(copy=False)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `copy`.", "question_id": 42203}
{"snippet": "pandas.TimedeltaIndex(name=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `name`.", "question_id": 42204}
{"snippet": "pandas.TimedeltaIndex(data=None, unit=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `unit`.", "question_id": 42205}
{"snippet": "pandas.TimedeltaIndex(data=None, freq=NoDefault.no_default)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `freq`.", "question_id": 42206}
{"snippet": "pandas.TimedeltaIndex()", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects .", "question_id": 42207}
{"snippet": "pandas.TimedeltaIndex(data=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects .", "question_id": 42208}
{"snippet": "pandas.TimedeltaIndex(unit=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `unit`.", "question_id": 42209}
{"snippet": "pandas.TimedeltaIndex(freq=NoDefault.no_default)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `freq`.", "question_id": 42210}
{"snippet": "pandas.TimedeltaIndex(closed=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `closed`.", "question_id": 42211}
{"snippet": "pandas.TimedeltaIndex(dtype=dtype('<m8ns'))", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `dtype`.", "question_id": 42212}
{"snippet": "pandas.TimedeltaIndex(copy=False)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `copy`.", "question_id": 42213}
{"snippet": "pandas.TimedeltaIndex(name=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `name`.", "question_id": 42214}
{"snippet": "pandas.TimedeltaIndex(data=None, unit=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `unit`.", "question_id": 42215}
{"snippet": "pandas.TimedeltaIndex(data=None, freq=NoDefault.no_default)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `freq`.", "question_id": 42216}
{"snippet": "pandas.TimedeltaIndex()", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects .", "question_id": 42217}
{"snippet": "pandas.TimedeltaIndex(data=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects .", "question_id": 42218}
{"snippet": "pandas.TimedeltaIndex(unit=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `unit`.", "question_id": 42219}
{"snippet": "pandas.TimedeltaIndex(freq=NoDefault.no_default)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `freq`.", "question_id": 42220}
{"snippet": "pandas.TimedeltaIndex(closed=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `closed`.", "question_id": 42221}
{"snippet": "pandas.TimedeltaIndex(dtype=dtype('<m8ns'))", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `dtype`.", "question_id": 42222}
{"snippet": "pandas.TimedeltaIndex(copy=False)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `copy`.", "question_id": 42223}
{"snippet": "pandas.TimedeltaIndex(name=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `name`.", "question_id": 42224}
{"snippet": "pandas.TimedeltaIndex(data=None, unit=None)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `unit`.", "question_id": 42225}
{"snippet": "pandas.TimedeltaIndex(data=None, freq=NoDefault.no_default)", "intent": "Immutable ndarray of timedelta64 `data` , represented internally as int64 , and which can be boxed to timedelta objects . With arguments `freq`.", "question_id": 42226}
{"snippet": "TimedeltaIndex.inferred_freq", "intent": "Tries to return a string representing a frequency guess, generated by infer_freq.", "question_id": 42227}
{"snippet": "TimedeltaIndex.inferred_freq", "intent": "Tries to return a string representing a frequency guess, generated by infer_freq.", "question_id": 42228}
{"snippet": "TimedeltaIndex.inferred_freq", "intent": "Tries to return a string representing a frequency guess, generated by infer_freq.", "question_id": 42229}
{"snippet": "TimedeltaIndex.mean(*args, **kwargs)", "intent": "Return the mean value of the Array . With arguments `*args`, `**kwargs`.", "question_id": 42230}
{"snippet": "TimedeltaIndex.mean(*args, **kwargs)", "intent": "Return the mean value of the Array . With arguments `*args`, `**kwargs`.", "question_id": 42231}
{"snippet": "TimedeltaIndex.mean(*args, **kwargs)", "intent": "Return the mean value of the Array . With arguments `*args`, `**kwargs`.", "question_id": 42232}
{"snippet": "TimedeltaIndex.round(*args, **kwargs)", "intent": "Perform round operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 42233}
{"snippet": "TimedeltaIndex.round(*args, **kwargs)", "intent": "Perform round operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 42234}
{"snippet": "TimedeltaIndex.round(*args, **kwargs)", "intent": "Perform round operation on the data to the specified freq . With arguments `*args`, `**kwargs`.", "question_id": 42235}
{"snippet": "TimedeltaIndex.to_frame()", "intent": "Create a DataFrame with a column containing the Index .", "question_id": 42236}
{"snippet": "TimedeltaIndex.to_frame(index=True)", "intent": "Create a DataFrame with a column containing the Index . With arguments `index`.", "question_id": 42237}
{"snippet": "TimedeltaIndex.to_frame(name=None)", "intent": "Create a DataFrame with a column containing the Index . To override the `name` of the resulting column , specify name :", "question_id": 42238}
{"snippet": "TimedeltaIndex.to_frame(index=True, name=None)", "intent": "Create a DataFrame with a column containing the Index . To override the `name` of the resulting column , specify name : With arguments `index`.", "question_id": 42239}
{"snippet": "TimedeltaIndex.to_frame()", "intent": "Create a DataFrame with a column containing the Index .", "question_id": 42240}
{"snippet": "TimedeltaIndex.to_frame(index=True)", "intent": "Create a DataFrame with a column containing the Index . With arguments `index`.", "question_id": 42241}
{"snippet": "TimedeltaIndex.to_frame(name=None)", "intent": "Create a DataFrame with a column containing the Index . To override the `name` of the resulting column , specify name :", "question_id": 42242}
{"snippet": "TimedeltaIndex.to_frame(index=True, name=None)", "intent": "Create a DataFrame with a column containing the Index . To override the `name` of the resulting column , specify name : With arguments `index`.", "question_id": 42243}
{"snippet": "TimedeltaIndex.to_frame()", "intent": "Create a DataFrame with a column containing the Index .", "question_id": 42244}
{"snippet": "TimedeltaIndex.to_frame(index=True)", "intent": "Create a DataFrame with a column containing the Index . With arguments `index`.", "question_id": 42245}
{"snippet": "TimedeltaIndex.to_frame(name=None)", "intent": "Create a DataFrame with a column containing the Index . To override the `name` of the resulting column , specify name :", "question_id": 42246}
{"snippet": "TimedeltaIndex.to_frame(index=True, name=None)", "intent": "Create a DataFrame with a column containing the Index . To override the `name` of the resulting column , specify name : With arguments `index`.", "question_id": 42247}
{"snippet": "TimedeltaIndex.to_pytimedelta(*args, **kwargs)", "intent": "Return Timedelta Array/Index as object ndarray of datetime.timedelta objects . With arguments `*args`, `**kwargs`.", "question_id": 42248}
{"snippet": "TimedeltaIndex.to_pytimedelta(*args, **kwargs)", "intent": "Return Timedelta Array/Index as object ndarray of datetime.timedelta objects . With arguments `*args`, `**kwargs`.", "question_id": 42249}
{"snippet": "TimedeltaIndex.to_pytimedelta(*args, **kwargs)", "intent": "Return Timedelta Array/Index as object ndarray of datetime.timedelta objects . With arguments `*args`, `**kwargs`.", "question_id": 42250}
{"snippet": "TimedeltaIndex.to_series()", "intent": "Create a Series with both `index` and values equal to the index keys .", "question_id": 42251}
{"snippet": "TimedeltaIndex.to_series(index=None)", "intent": "Create a Series with both `index` and values equal to the index keys .", "question_id": 42252}
{"snippet": "TimedeltaIndex.to_series(name=None)", "intent": "Create a Series with both `index` and values equal to the index keys . By default , the original Index and original `name` is reused .", "question_id": 42253}
{"snippet": "TimedeltaIndex.to_series(index=None, name=None)", "intent": "Create a Series with both `index` and values equal to the index keys . By default , the original Index and original `name` is reused .", "question_id": 42254}
{"snippet": "TimedeltaIndex.to_series()", "intent": "Create a Series with both `index` and values equal to the index keys .", "question_id": 42255}
{"snippet": "TimedeltaIndex.to_series(index=None)", "intent": "Create a Series with both `index` and values equal to the index keys .", "question_id": 42256}
{"snippet": "TimedeltaIndex.to_series(name=None)", "intent": "Create a Series with both `index` and values equal to the index keys . By default , the original Index and original `name` is reused .", "question_id": 42257}
{"snippet": "TimedeltaIndex.to_series(index=None, name=None)", "intent": "Create a Series with both `index` and values equal to the index keys . By default , the original Index and original `name` is reused .", "question_id": 42258}
{"snippet": "TimedeltaIndex.to_series()", "intent": "Create a Series with both `index` and values equal to the index keys .", "question_id": 42259}
{"snippet": "TimedeltaIndex.to_series(index=None)", "intent": "Create a Series with both `index` and values equal to the index keys .", "question_id": 42260}
{"snippet": "TimedeltaIndex.to_series(name=None)", "intent": "Create a Series with both `index` and values equal to the index keys . By default , the original Index and original `name` is reused .", "question_id": 42261}
{"snippet": "TimedeltaIndex.to_series(index=None, name=None)", "intent": "Create a Series with both `index` and values equal to the index keys . By default , the original Index and original `name` is reused .", "question_id": 42262}
{"snippet": "Timestamp.asm8", "intent": "Return numpy datetime64 format in nanoseconds.", "question_id": 42263}
{"snippet": "Timestamp.asm8", "intent": "Return numpy datetime64 format in nanoseconds.", "question_id": 42264}
{"snippet": "Timestamp.asm8", "intent": "Return numpy datetime64 format in nanoseconds.", "question_id": 42265}
{"snippet": "Timestamp.astimezone(tz)", "intent": "Convert tz-aware Timestamp to another time zone . With arguments `tz`.", "question_id": 42266}
{"snippet": "Timestamp.astimezone(tz)", "intent": "Convert tz-aware Timestamp to another time zone . With arguments `tz`.", "question_id": 42267}
{"snippet": "Timestamp.astimezone(tz)", "intent": "Convert tz-aware Timestamp to another time zone . With arguments `tz`.", "question_id": 42268}
{"snippet": "Timestamp.ceil(freq)", "intent": "Return a new Timestamp ceiled to this resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e .", "question_id": 42269}
{"snippet": "Timestamp.ceil(freq, ambiguous='raise')", "intent": "Return a new Timestamp ceiled to this resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `ambiguous`.", "question_id": 42270}
{"snippet": "Timestamp.ceil(freq, nonexistent='raise')", "intent": "Return a new Timestamp ceiled to this resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `nonexistent`.", "question_id": 42271}
{"snippet": "Timestamp.ceil(freq, ambiguous='raise', nonexistent='raise')", "intent": "Return a new Timestamp ceiled to this resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `ambiguous`, `nonexistent`.", "question_id": 42272}
{"snippet": "Timestamp.ceil(freq)", "intent": "Return a new Timestamp ceiled to this resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e .", "question_id": 42273}
{"snippet": "Timestamp.ceil(freq, ambiguous='raise')", "intent": "Return a new Timestamp ceiled to this resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `ambiguous`.", "question_id": 42274}
{"snippet": "Timestamp.ceil(freq, nonexistent='raise')", "intent": "Return a new Timestamp ceiled to this resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `nonexistent`.", "question_id": 42275}
{"snippet": "Timestamp.ceil(freq, ambiguous='raise', nonexistent='raise')", "intent": "Return a new Timestamp ceiled to this resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `ambiguous`, `nonexistent`.", "question_id": 42276}
{"snippet": "Timestamp.ceil(freq)", "intent": "Return a new Timestamp ceiled to this resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e .", "question_id": 42277}
{"snippet": "Timestamp.ceil(freq, ambiguous='raise')", "intent": "Return a new Timestamp ceiled to this resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `ambiguous`.", "question_id": 42278}
{"snippet": "Timestamp.ceil(freq, nonexistent='raise')", "intent": "Return a new Timestamp ceiled to this resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `nonexistent`.", "question_id": 42279}
{"snippet": "Timestamp.ceil(freq, ambiguous='raise', nonexistent='raise')", "intent": "Return a new Timestamp ceiled to this resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `ambiguous`, `nonexistent`.", "question_id": 42280}
{"snippet": "Timestamp.combine(date, time)", "intent": "Combine `date` , `time` into datetime with same date and time fields .", "question_id": 42281}
{"snippet": "Timestamp.combine(date, time)", "intent": "Combine `date` , `time` into datetime with same date and time fields .", "question_id": 42282}
{"snippet": "Timestamp.combine(date, time)", "intent": "Combine `date` , `time` into datetime with same date and time fields .", "question_id": 42283}
{"snippet": "Timestamp.ctime()", "intent": "Return ctime ( ) style string .", "question_id": 42284}
{"snippet": "Timestamp.ctime()", "intent": "Return ctime ( ) style string .", "question_id": 42285}
{"snippet": "Timestamp.ctime()", "intent": "Return ctime ( ) style string .", "question_id": 42286}
{"snippet": "Timestamp.date()", "intent": "Return date object with same year , month and day .", "question_id": 42287}
{"snippet": "Timestamp.date()", "intent": "Return date object with same year , month and day .", "question_id": 42288}
{"snippet": "Timestamp.date()", "intent": "Return date object with same year , month and day .", "question_id": 42289}
{"snippet": "Timestamp.day_name()", "intent": "Return the day name of the Timestamp with specified locale .", "question_id": 42290}
{"snippet": "Timestamp.day_name()", "intent": "Return the day name of the Timestamp with specified locale .", "question_id": 42291}
{"snippet": "Timestamp.day_name()", "intent": "Return the day name of the Timestamp with specified locale .", "question_id": 42292}
{"snippet": "Timestamp.day_of_week", "intent": "Return day of the week.", "question_id": 42293}
{"snippet": "Timestamp.day_of_week", "intent": "Return day of the week.", "question_id": 42294}
{"snippet": "Timestamp.day_of_week", "intent": "Return day of the week.", "question_id": 42295}
{"snippet": "Timestamp.day_of_year", "intent": "Return the day of the year.", "question_id": 42296}
{"snippet": "Timestamp.day_of_year", "intent": "Return the day of the year.", "question_id": 42297}
{"snippet": "Timestamp.day_of_year", "intent": "Return the day of the year.", "question_id": 42298}
{"snippet": "Timestamp.dayofweek", "intent": "Return day of the week.", "question_id": 42299}
{"snippet": "Timestamp.dayofweek", "intent": "Return day of the week.", "question_id": 42300}
{"snippet": "Timestamp.dayofweek", "intent": "Return day of the week.", "question_id": 42301}
{"snippet": "Timestamp.dayofyear", "intent": "Return the day of the year.", "question_id": 42302}
{"snippet": "Timestamp.dayofyear", "intent": "Return the day of the year.", "question_id": 42303}
{"snippet": "Timestamp.dayofyear", "intent": "Return the day of the year.", "question_id": 42304}
{"snippet": "Timestamp.days_in_month", "intent": "Return the number of days in the month.", "question_id": 42305}
{"snippet": "Timestamp.days_in_month", "intent": "Return the number of days in the month.", "question_id": 42306}
{"snippet": "Timestamp.days_in_month", "intent": "Return the number of days in the month.", "question_id": 42307}
{"snippet": "Timestamp.daysinmonth", "intent": "Return the number of days in the month.", "question_id": 42308}
{"snippet": "Timestamp.daysinmonth", "intent": "Return the number of days in the month.", "question_id": 42309}
{"snippet": "Timestamp.daysinmonth", "intent": "Return the number of days in the month.", "question_id": 42310}
{"snippet": "Timestamp.dst()", "intent": "Return self.tzinfo.dst ( self ) .", "question_id": 42311}
{"snippet": "Timestamp.dst()", "intent": "Return self.tzinfo.dst ( self ) .", "question_id": 42312}
{"snippet": "Timestamp.dst()", "intent": "Return self.tzinfo.dst ( self ) .", "question_id": 42313}
{"snippet": "Timestamp.floor(freq)", "intent": "Return a new Timestamp floored to this resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e .", "question_id": 42314}
{"snippet": "Timestamp.floor(freq, ambiguous='raise')", "intent": "Return a new Timestamp floored to this resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `ambiguous`.", "question_id": 42315}
{"snippet": "Timestamp.floor(freq, nonexistent='raise')", "intent": "Return a new Timestamp floored to this resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `nonexistent`.", "question_id": 42316}
{"snippet": "Timestamp.floor(freq, ambiguous='raise', nonexistent='raise')", "intent": "Return a new Timestamp floored to this resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `ambiguous`, `nonexistent`.", "question_id": 42317}
{"snippet": "Timestamp.floor(freq)", "intent": "Return a new Timestamp floored to this resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e .", "question_id": 42318}
{"snippet": "Timestamp.floor(freq, ambiguous='raise')", "intent": "Return a new Timestamp floored to this resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `ambiguous`.", "question_id": 42319}
{"snippet": "Timestamp.floor(freq, nonexistent='raise')", "intent": "Return a new Timestamp floored to this resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `nonexistent`.", "question_id": 42320}
{"snippet": "Timestamp.floor(freq, ambiguous='raise', nonexistent='raise')", "intent": "Return a new Timestamp floored to this resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `ambiguous`, `nonexistent`.", "question_id": 42321}
{"snippet": "Timestamp.floor(freq)", "intent": "Return a new Timestamp floored to this resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e .", "question_id": 42322}
{"snippet": "Timestamp.floor(freq, ambiguous='raise')", "intent": "Return a new Timestamp floored to this resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `ambiguous`.", "question_id": 42323}
{"snippet": "Timestamp.floor(freq, nonexistent='raise')", "intent": "Return a new Timestamp floored to this resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `nonexistent`.", "question_id": 42324}
{"snippet": "Timestamp.floor(freq, ambiguous='raise', nonexistent='raise')", "intent": "Return a new Timestamp floored to this resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `ambiguous`, `nonexistent`.", "question_id": 42325}
{"snippet": "Timestamp.fromisocalendar()", "intent": "int , int , int - > Construct a date from the ISO year , week number and weekday .", "question_id": 42326}
{"snippet": "Timestamp.fromisocalendar()", "intent": "int , int , int - > Construct a date from the ISO year , week number and weekday .", "question_id": 42327}
{"snippet": "Timestamp.fromisocalendar()", "intent": "int , int , int - > Construct a date from the ISO year , week number and weekday .", "question_id": 42328}
{"snippet": "Timestamp.fromisoformat()", "intent": "string - > datetime from datetime.isoformat ( ) output", "question_id": 42329}
{"snippet": "Timestamp.fromisoformat()", "intent": "string - > datetime from datetime.isoformat ( ) output", "question_id": 42330}
{"snippet": "Timestamp.fromisoformat()", "intent": "string - > datetime from datetime.isoformat ( ) output", "question_id": 42331}
{"snippet": "Timestamp.fromordinal(ordinal)", "intent": "Passed an `ordinal` , translate and convert to a ts .", "question_id": 42332}
{"snippet": "Timestamp.fromordinal(ordinal, freq=None)", "intent": "Passed an `ordinal` , translate and convert to a ts . With arguments `freq`.", "question_id": 42333}
{"snippet": "Timestamp.fromordinal(ordinal, tz=None)", "intent": "Passed an `ordinal` , translate and convert to a ts . Note : by definition there can not be any `tz` info on the ordinal itself .", "question_id": 42334}
{"snippet": "Timestamp.fromordinal(ordinal, freq=None, tz=None)", "intent": "Passed an `ordinal` , translate and convert to a ts . Note : by definition there can not be any `tz` info on the ordinal itself . With arguments `freq`.", "question_id": 42335}
{"snippet": "Timestamp.fromordinal(ordinal)", "intent": "Passed an `ordinal` , translate and convert to a ts .", "question_id": 42336}
{"snippet": "Timestamp.fromordinal(ordinal, freq=None)", "intent": "Passed an `ordinal` , translate and convert to a ts . With arguments `freq`.", "question_id": 42337}
{"snippet": "Timestamp.fromordinal(ordinal, tz=None)", "intent": "Passed an `ordinal` , translate and convert to a ts . Note : by definition there can not be any `tz` info on the ordinal itself .", "question_id": 42338}
{"snippet": "Timestamp.fromordinal(ordinal, freq=None, tz=None)", "intent": "Passed an `ordinal` , translate and convert to a ts . Note : by definition there can not be any `tz` info on the ordinal itself . With arguments `freq`.", "question_id": 42339}
{"snippet": "Timestamp.fromordinal(ordinal)", "intent": "Passed an `ordinal` , translate and convert to a ts .", "question_id": 42340}
{"snippet": "Timestamp.fromordinal(ordinal, freq=None)", "intent": "Passed an `ordinal` , translate and convert to a ts . With arguments `freq`.", "question_id": 42341}
{"snippet": "Timestamp.fromordinal(ordinal, tz=None)", "intent": "Passed an `ordinal` , translate and convert to a ts . Note : by definition there can not be any `tz` info on the ordinal itself .", "question_id": 42342}
{"snippet": "Timestamp.fromordinal(ordinal, freq=None, tz=None)", "intent": "Passed an `ordinal` , translate and convert to a ts . Note : by definition there can not be any `tz` info on the ordinal itself . With arguments `freq`.", "question_id": 42343}
{"snippet": "Timestamp.fromtimestamp(ts)", "intent": "Transform timestamp [ , tz ] to tz \u2019 s local time from POSIX timestamp . With arguments `ts`.", "question_id": 42344}
{"snippet": "Timestamp.fromtimestamp(ts)", "intent": "Transform timestamp [ , tz ] to tz \u2019 s local time from POSIX timestamp . With arguments `ts`.", "question_id": 42345}
{"snippet": "Timestamp.fromtimestamp(ts)", "intent": "Transform timestamp [ , tz ] to tz \u2019 s local time from POSIX timestamp . With arguments `ts`.", "question_id": 42346}
{"snippet": "pandas.Timestamp()", "intent": "Pandas replacement for python datetime.datetime object .", "question_id": 42347}
{"snippet": "pandas.Timestamp(ts_input=<object object>)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `ts_input`.", "question_id": 42348}
{"snippet": "pandas.Timestamp(freq=None)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `freq`.", "question_id": 42349}
{"snippet": "pandas.Timestamp(tz=None)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `tz`.", "question_id": 42350}
{"snippet": "pandas.Timestamp(unit=None)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `unit`.", "question_id": 42351}
{"snippet": "pandas.Timestamp(year=None)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `year`.", "question_id": 42352}
{"snippet": "pandas.Timestamp(month=None)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `month`.", "question_id": 42353}
{"snippet": "pandas.Timestamp(day=None)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `day`.", "question_id": 42354}
{"snippet": "pandas.Timestamp(hour=None)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `hour`.", "question_id": 42355}
{"snippet": "pandas.Timestamp(minute=None)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `minute`.", "question_id": 42356}
{"snippet": "pandas.Timestamp()", "intent": "Pandas replacement for python datetime.datetime object .", "question_id": 42357}
{"snippet": "pandas.Timestamp(ts_input=<object object>)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `ts_input`.", "question_id": 42358}
{"snippet": "pandas.Timestamp(freq=None)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `freq`.", "question_id": 42359}
{"snippet": "pandas.Timestamp(tz=None)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `tz`.", "question_id": 42360}
{"snippet": "pandas.Timestamp(unit=None)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `unit`.", "question_id": 42361}
{"snippet": "pandas.Timestamp(year=None)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `year`.", "question_id": 42362}
{"snippet": "pandas.Timestamp(month=None)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `month`.", "question_id": 42363}
{"snippet": "pandas.Timestamp(day=None)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `day`.", "question_id": 42364}
{"snippet": "pandas.Timestamp(hour=None)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `hour`.", "question_id": 42365}
{"snippet": "pandas.Timestamp(minute=None)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `minute`.", "question_id": 42366}
{"snippet": "pandas.Timestamp()", "intent": "Pandas replacement for python datetime.datetime object .", "question_id": 42367}
{"snippet": "pandas.Timestamp(ts_input=<object object>)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `ts_input`.", "question_id": 42368}
{"snippet": "pandas.Timestamp(freq=None)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `freq`.", "question_id": 42369}
{"snippet": "pandas.Timestamp(tz=None)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `tz`.", "question_id": 42370}
{"snippet": "pandas.Timestamp(unit=None)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `unit`.", "question_id": 42371}
{"snippet": "pandas.Timestamp(year=None)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `year`.", "question_id": 42372}
{"snippet": "pandas.Timestamp(month=None)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `month`.", "question_id": 42373}
{"snippet": "pandas.Timestamp(day=None)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `day`.", "question_id": 42374}
{"snippet": "pandas.Timestamp(hour=None)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `hour`.", "question_id": 42375}
{"snippet": "pandas.Timestamp(minute=None)", "intent": "Pandas replacement for python datetime.datetime object . With arguments `minute`.", "question_id": 42376}
{"snippet": "Timestamp.is_leap_year", "intent": "Return True if year is a leap year.", "question_id": 42377}
{"snippet": "Timestamp.is_leap_year", "intent": "Return True if year is a leap year.", "question_id": 42378}
{"snippet": "Timestamp.is_leap_year", "intent": "Return True if year is a leap year.", "question_id": 42379}
{"snippet": "Timestamp.is_month_end", "intent": "Return True if date is last day of month.", "question_id": 42380}
{"snippet": "Timestamp.is_month_end", "intent": "Return True if date is last day of month.", "question_id": 42381}
{"snippet": "Timestamp.is_month_end", "intent": "Return True if date is last day of month.", "question_id": 42382}
{"snippet": "Timestamp.is_month_start", "intent": "Return True if date is first day of month.", "question_id": 42383}
{"snippet": "Timestamp.is_month_start", "intent": "Return True if date is first day of month.", "question_id": 42384}
{"snippet": "Timestamp.is_month_start", "intent": "Return True if date is first day of month.", "question_id": 42385}
{"snippet": "Timestamp.is_quarter_end", "intent": "Return True if date is last day of the quarter.", "question_id": 42386}
{"snippet": "Timestamp.is_quarter_end", "intent": "Return True if date is last day of the quarter.", "question_id": 42387}
{"snippet": "Timestamp.is_quarter_end", "intent": "Return True if date is last day of the quarter.", "question_id": 42388}
{"snippet": "Timestamp.is_quarter_start", "intent": "Return True if date is first day of the quarter.", "question_id": 42389}
{"snippet": "Timestamp.is_quarter_start", "intent": "Return True if date is first day of the quarter.", "question_id": 42390}
{"snippet": "Timestamp.is_quarter_start", "intent": "Return True if date is first day of the quarter.", "question_id": 42391}
{"snippet": "Timestamp.is_year_end", "intent": "Return True if date is last day of the year.", "question_id": 42392}
{"snippet": "Timestamp.is_year_end", "intent": "Return True if date is last day of the year.", "question_id": 42393}
{"snippet": "Timestamp.is_year_end", "intent": "Return True if date is last day of the year.", "question_id": 42394}
{"snippet": "Timestamp.is_year_start", "intent": "Return True if date is first day of the year.", "question_id": 42395}
{"snippet": "Timestamp.is_year_start", "intent": "Return True if date is first day of the year.", "question_id": 42396}
{"snippet": "Timestamp.is_year_start", "intent": "Return True if date is first day of the year.", "question_id": 42397}
{"snippet": "Timestamp.isocalendar()", "intent": "Return a 3-tuple containing ISO year , week number , and weekday .", "question_id": 42398}
{"snippet": "Timestamp.isocalendar()", "intent": "Return a 3-tuple containing ISO year , week number , and weekday .", "question_id": 42399}
{"snippet": "Timestamp.isocalendar()", "intent": "Return a 3-tuple containing ISO year , week number , and weekday .", "question_id": 42400}
{"snippet": "Timestamp.isoformat()", "intent": "[ sep ] - > string in ISO 8601 format , YYYY-MM-DDT [ HH [ : MM [ : SS [ .mmm [ uuu ] ] ] ] ] [ +HH : MM ] .", "question_id": 42401}
{"snippet": "Timestamp.isoformat()", "intent": "[ sep ] - > string in ISO 8601 format , YYYY-MM-DDT [ HH [ : MM [ : SS [ .mmm [ uuu ] ] ] ] ] [ +HH : MM ] .", "question_id": 42402}
{"snippet": "Timestamp.isoformat()", "intent": "[ sep ] - > string in ISO 8601 format , YYYY-MM-DDT [ HH [ : MM [ : SS [ .mmm [ uuu ] ] ] ] ] [ +HH : MM ] .", "question_id": 42403}
{"snippet": "Timestamp.isoweekday()", "intent": "Return the day of the week represented by the date .", "question_id": 42404}
{"snippet": "Timestamp.isoweekday()", "intent": "Return the day of the week represented by the date .", "question_id": 42405}
{"snippet": "Timestamp.isoweekday()", "intent": "Return the day of the week represented by the date .", "question_id": 42406}
{"snippet": "Timestamp.month_name()", "intent": "Return the month name of the Timestamp with specified locale .", "question_id": 42407}
{"snippet": "Timestamp.month_name()", "intent": "Return the month name of the Timestamp with specified locale .", "question_id": 42408}
{"snippet": "Timestamp.month_name()", "intent": "Return the month name of the Timestamp with specified locale .", "question_id": 42409}
{"snippet": "Timestamp.normalize()", "intent": "Normalize Timestamp to midnight , preserving tz information .", "question_id": 42410}
{"snippet": "Timestamp.normalize()", "intent": "Normalize Timestamp to midnight , preserving tz information .", "question_id": 42411}
{"snippet": "Timestamp.normalize()", "intent": "Normalize Timestamp to midnight , preserving tz information .", "question_id": 42412}
{"snippet": "Timestamp.now()", "intent": "Return new Timestamp object representing current time local to `tz` .", "question_id": 42413}
{"snippet": "Timestamp.now(tz=None)", "intent": "Return new Timestamp object representing current time local to `tz` .", "question_id": 42414}
{"snippet": "Timestamp.now()", "intent": "Return new Timestamp object representing current time local to `tz` .", "question_id": 42415}
{"snippet": "Timestamp.now(tz=None)", "intent": "Return new Timestamp object representing current time local to `tz` .", "question_id": 42416}
{"snippet": "Timestamp.now()", "intent": "Return new Timestamp object representing current time local to `tz` .", "question_id": 42417}
{"snippet": "Timestamp.now(tz=None)", "intent": "Return new Timestamp object representing current time local to `tz` .", "question_id": 42418}
{"snippet": "Timestamp.quarter", "intent": "Return the quarter of the year.", "question_id": 42419}
{"snippet": "Timestamp.quarter", "intent": "Return the quarter of the year.", "question_id": 42420}
{"snippet": "Timestamp.quarter", "intent": "Return the quarter of the year.", "question_id": 42421}
{"snippet": "Timestamp.replace()", "intent": "Implements datetime.replace , handles nanoseconds .", "question_id": 42422}
{"snippet": "Timestamp.replace(year=None)", "intent": "Implements datetime.replace , handles nanoseconds . Replace `year` and the `hour` :", "question_id": 42423}
{"snippet": "Timestamp.replace(month=None)", "intent": "Implements datetime.replace , handles nanoseconds . With arguments `month`.", "question_id": 42424}
{"snippet": "Timestamp.replace(day=None)", "intent": "Implements datetime.replace , handles nanoseconds . With arguments `day`.", "question_id": 42425}
{"snippet": "Timestamp.replace(hour=None)", "intent": "Implements datetime.replace , handles nanoseconds . Replace `year` and the `hour` :", "question_id": 42426}
{"snippet": "Timestamp.replace(minute=None)", "intent": "Implements datetime.replace , handles nanoseconds . With arguments `minute`.", "question_id": 42427}
{"snippet": "Timestamp.replace(second=None)", "intent": "Implements datetime.replace , handles nanoseconds . With arguments `second`.", "question_id": 42428}
{"snippet": "Timestamp.replace(microsecond=None)", "intent": "Implements datetime.replace , handles nanoseconds . With arguments `microsecond`.", "question_id": 42429}
{"snippet": "Timestamp.replace(nanosecond=None)", "intent": "Implements datetime.replace , handles nanoseconds . With arguments `nanosecond`.", "question_id": 42430}
{"snippet": "Timestamp.replace(tzinfo=<class 'object'>)", "intent": "Implements datetime.replace , handles nanoseconds . With arguments `tzinfo`.", "question_id": 42431}
{"snippet": "Timestamp.replace()", "intent": "Implements datetime.replace , handles nanoseconds .", "question_id": 42432}
{"snippet": "Timestamp.replace(year=None)", "intent": "Implements datetime.replace , handles nanoseconds . Replace `year` and the `hour` :", "question_id": 42433}
{"snippet": "Timestamp.replace(month=None)", "intent": "Implements datetime.replace , handles nanoseconds . With arguments `month`.", "question_id": 42434}
{"snippet": "Timestamp.replace(day=None)", "intent": "Implements datetime.replace , handles nanoseconds . With arguments `day`.", "question_id": 42435}
{"snippet": "Timestamp.replace(hour=None)", "intent": "Implements datetime.replace , handles nanoseconds . Replace `year` and the `hour` :", "question_id": 42436}
{"snippet": "Timestamp.replace(minute=None)", "intent": "Implements datetime.replace , handles nanoseconds . With arguments `minute`.", "question_id": 42437}
{"snippet": "Timestamp.replace(second=None)", "intent": "Implements datetime.replace , handles nanoseconds . With arguments `second`.", "question_id": 42438}
{"snippet": "Timestamp.replace(microsecond=None)", "intent": "Implements datetime.replace , handles nanoseconds . With arguments `microsecond`.", "question_id": 42439}
{"snippet": "Timestamp.replace(nanosecond=None)", "intent": "Implements datetime.replace , handles nanoseconds . With arguments `nanosecond`.", "question_id": 42440}
{"snippet": "Timestamp.replace(tzinfo=<class 'object'>)", "intent": "Implements datetime.replace , handles nanoseconds . With arguments `tzinfo`.", "question_id": 42441}
{"snippet": "Timestamp.replace()", "intent": "Implements datetime.replace , handles nanoseconds .", "question_id": 42442}
{"snippet": "Timestamp.replace(year=None)", "intent": "Implements datetime.replace , handles nanoseconds . Replace `year` and the `hour` :", "question_id": 42443}
{"snippet": "Timestamp.replace(month=None)", "intent": "Implements datetime.replace , handles nanoseconds . With arguments `month`.", "question_id": 42444}
{"snippet": "Timestamp.replace(day=None)", "intent": "Implements datetime.replace , handles nanoseconds . With arguments `day`.", "question_id": 42445}
{"snippet": "Timestamp.replace(hour=None)", "intent": "Implements datetime.replace , handles nanoseconds . Replace `year` and the `hour` :", "question_id": 42446}
{"snippet": "Timestamp.replace(minute=None)", "intent": "Implements datetime.replace , handles nanoseconds . With arguments `minute`.", "question_id": 42447}
{"snippet": "Timestamp.replace(second=None)", "intent": "Implements datetime.replace , handles nanoseconds . With arguments `second`.", "question_id": 42448}
{"snippet": "Timestamp.replace(microsecond=None)", "intent": "Implements datetime.replace , handles nanoseconds . With arguments `microsecond`.", "question_id": 42449}
{"snippet": "Timestamp.replace(nanosecond=None)", "intent": "Implements datetime.replace , handles nanoseconds . With arguments `nanosecond`.", "question_id": 42450}
{"snippet": "Timestamp.replace(tzinfo=<class 'object'>)", "intent": "Implements datetime.replace , handles nanoseconds . With arguments `tzinfo`.", "question_id": 42451}
{"snippet": "Timestamp.round(freq)", "intent": "Round the Timestamp to the specified resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e .", "question_id": 42452}
{"snippet": "Timestamp.round(freq, ambiguous='raise')", "intent": "Round the Timestamp to the specified resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `ambiguous`.", "question_id": 42453}
{"snippet": "Timestamp.round(freq, nonexistent='raise')", "intent": "Round the Timestamp to the specified resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `nonexistent`.", "question_id": 42454}
{"snippet": "Timestamp.round(freq, ambiguous='raise', nonexistent='raise')", "intent": "Round the Timestamp to the specified resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `ambiguous`, `nonexistent`.", "question_id": 42455}
{"snippet": "Timestamp.round(freq)", "intent": "Round the Timestamp to the specified resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e .", "question_id": 42456}
{"snippet": "Timestamp.round(freq, ambiguous='raise')", "intent": "Round the Timestamp to the specified resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `ambiguous`.", "question_id": 42457}
{"snippet": "Timestamp.round(freq, nonexistent='raise')", "intent": "Round the Timestamp to the specified resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `nonexistent`.", "question_id": 42458}
{"snippet": "Timestamp.round(freq, ambiguous='raise', nonexistent='raise')", "intent": "Round the Timestamp to the specified resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `ambiguous`, `nonexistent`.", "question_id": 42459}
{"snippet": "Timestamp.round(freq)", "intent": "Round the Timestamp to the specified resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e .", "question_id": 42460}
{"snippet": "Timestamp.round(freq, ambiguous='raise')", "intent": "Round the Timestamp to the specified resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `ambiguous`.", "question_id": 42461}
{"snippet": "Timestamp.round(freq, nonexistent='raise')", "intent": "Round the Timestamp to the specified resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `nonexistent`.", "question_id": 42462}
{"snippet": "Timestamp.round(freq, ambiguous='raise', nonexistent='raise')", "intent": "Round the Timestamp to the specified resolution . `freq` can also be a multiple of a single unit , like \u2018 5T \u2019 ( i.e . With arguments `ambiguous`, `nonexistent`.", "question_id": 42463}
{"snippet": "Timestamp.strftime(format)", "intent": "Return a string representing the given POSIX timestamp controlled by an explicit `format` string .", "question_id": 42464}
{"snippet": "Timestamp.strftime(format)", "intent": "Return a string representing the given POSIX timestamp controlled by an explicit `format` string .", "question_id": 42465}
{"snippet": "Timestamp.strftime(format)", "intent": "Return a string representing the given POSIX timestamp controlled by an explicit `format` string .", "question_id": 42466}
{"snippet": "Timestamp.strptime(string, format)", "intent": "Function is not implemented . With arguments `string`, `format`.", "question_id": 42467}
{"snippet": "Timestamp.strptime(string, format)", "intent": "Function is not implemented . With arguments `string`, `format`.", "question_id": 42468}
{"snippet": "Timestamp.strptime(string, format)", "intent": "Function is not implemented . With arguments `string`, `format`.", "question_id": 42469}
{"snippet": "Timestamp.time()", "intent": "Return time object with same time but with tzinfo=None .", "question_id": 42470}
{"snippet": "Timestamp.time()", "intent": "Return time object with same time but with tzinfo=None .", "question_id": 42471}
{"snippet": "Timestamp.time()", "intent": "Return time object with same time but with tzinfo=None .", "question_id": 42472}
{"snippet": "Timestamp.timestamp()", "intent": "Return POSIX timestamp as float .", "question_id": 42473}
{"snippet": "Timestamp.timestamp()", "intent": "Return POSIX timestamp as float .", "question_id": 42474}
{"snippet": "Timestamp.timestamp()", "intent": "Return POSIX timestamp as float .", "question_id": 42475}
{"snippet": "Timestamp.timetuple()", "intent": "Return time tuple , compatible with time.localtime ( ) .", "question_id": 42476}
{"snippet": "Timestamp.timetuple()", "intent": "Return time tuple , compatible with time.localtime ( ) .", "question_id": 42477}
{"snippet": "Timestamp.timetuple()", "intent": "Return time tuple , compatible with time.localtime ( ) .", "question_id": 42478}
{"snippet": "Timestamp.timetz()", "intent": "Return time object with same time and tzinfo .", "question_id": 42479}
{"snippet": "Timestamp.timetz()", "intent": "Return time object with same time and tzinfo .", "question_id": 42480}
{"snippet": "Timestamp.timetz()", "intent": "Return time object with same time and tzinfo .", "question_id": 42481}
{"snippet": "Timestamp.to_datetime64()", "intent": "Return a numpy.datetime64 object with \u2018 ns \u2019 precision .", "question_id": 42482}
{"snippet": "Timestamp.to_datetime64()", "intent": "Return a numpy.datetime64 object with \u2018 ns \u2019 precision .", "question_id": 42483}
{"snippet": "Timestamp.to_datetime64()", "intent": "Return a numpy.datetime64 object with \u2018 ns \u2019 precision .", "question_id": 42484}
{"snippet": "Timestamp.to_julian_date()", "intent": "Convert TimeStamp to a Julian Date .", "question_id": 42485}
{"snippet": "Timestamp.to_julian_date()", "intent": "Convert TimeStamp to a Julian Date .", "question_id": 42486}
{"snippet": "Timestamp.to_julian_date()", "intent": "Convert TimeStamp to a Julian Date .", "question_id": 42487}
{"snippet": "Timestamp.to_numpy()", "intent": "Convert the Timestamp to a NumPy datetime64 .", "question_id": 42488}
{"snippet": "Timestamp.to_numpy()", "intent": "Convert the Timestamp to a NumPy datetime64 .", "question_id": 42489}
{"snippet": "Timestamp.to_numpy()", "intent": "Convert the Timestamp to a NumPy datetime64 .", "question_id": 42490}
{"snippet": "Timestamp.to_period()", "intent": "Return an period of which this timestamp is an observation .", "question_id": 42491}
{"snippet": "Timestamp.to_period()", "intent": "Return an period of which this timestamp is an observation .", "question_id": 42492}
{"snippet": "Timestamp.to_period()", "intent": "Return an period of which this timestamp is an observation .", "question_id": 42493}
{"snippet": "Timestamp.to_pydatetime()", "intent": "Convert a Timestamp object to a native Python datetime object .", "question_id": 42494}
{"snippet": "Timestamp.to_pydatetime()", "intent": "Convert a Timestamp object to a native Python datetime object .", "question_id": 42495}
{"snippet": "Timestamp.to_pydatetime()", "intent": "Convert a Timestamp object to a native Python datetime object .", "question_id": 42496}
{"snippet": "Timestamp.today(cls)", "intent": "Return the current time in the local timezone . With arguments `cls`.", "question_id": 42497}
{"snippet": "Timestamp.today(cls, tz=None)", "intent": "Return the current time in the local timezone . With arguments `cls`, `tz`.", "question_id": 42498}
{"snippet": "Timestamp.today(cls)", "intent": "Return the current time in the local timezone . With arguments `cls`.", "question_id": 42499}
{"snippet": "Timestamp.today(cls, tz=None)", "intent": "Return the current time in the local timezone . With arguments `cls`, `tz`.", "question_id": 42500}
{"snippet": "Timestamp.today(cls)", "intent": "Return the current time in the local timezone . With arguments `cls`.", "question_id": 42501}
{"snippet": "Timestamp.today(cls, tz=None)", "intent": "Return the current time in the local timezone . With arguments `cls`, `tz`.", "question_id": 42502}
{"snippet": "Timestamp.toordinal()", "intent": "Return proleptic Gregorian ordinal .", "question_id": 42503}
{"snippet": "Timestamp.toordinal()", "intent": "Return proleptic Gregorian ordinal .", "question_id": 42504}
{"snippet": "Timestamp.toordinal()", "intent": "Return proleptic Gregorian ordinal .", "question_id": 42505}
{"snippet": "Timestamp.tz_convert(tz)", "intent": "Convert tz-aware Timestamp to another time zone . With arguments `tz`.", "question_id": 42506}
{"snippet": "Timestamp.tz_convert(tz)", "intent": "Convert tz-aware Timestamp to another time zone . With arguments `tz`.", "question_id": 42507}
{"snippet": "Timestamp.tz_convert(tz)", "intent": "Convert tz-aware Timestamp to another time zone . With arguments `tz`.", "question_id": 42508}
{"snippet": "Timestamp.tz_localize(tz)", "intent": "Convert naive Timestamp to local time zone , or remove timezone from tz-aware Timestamp . With arguments `tz`.", "question_id": 42509}
{"snippet": "Timestamp.tz_localize(tz, ambiguous='raise')", "intent": "Convert naive Timestamp to local time zone , or remove timezone from tz-aware Timestamp . With arguments `tz`, `ambiguous`.", "question_id": 42510}
{"snippet": "Timestamp.tz_localize(tz, nonexistent='raise')", "intent": "Convert naive Timestamp to local time zone , or remove timezone from tz-aware Timestamp . With arguments `tz`, `nonexistent`.", "question_id": 42511}
{"snippet": "Timestamp.tz_localize(tz, ambiguous='raise', nonexistent='raise')", "intent": "Convert naive Timestamp to local time zone , or remove timezone from tz-aware Timestamp . With arguments `tz`, `ambiguous`, `nonexistent`.", "question_id": 42512}
{"snippet": "Timestamp.tz_localize(tz)", "intent": "Convert naive Timestamp to local time zone , or remove timezone from tz-aware Timestamp . With arguments `tz`.", "question_id": 42513}
{"snippet": "Timestamp.tz_localize(tz, ambiguous='raise')", "intent": "Convert naive Timestamp to local time zone , or remove timezone from tz-aware Timestamp . With arguments `tz`, `ambiguous`.", "question_id": 42514}
{"snippet": "Timestamp.tz_localize(tz, nonexistent='raise')", "intent": "Convert naive Timestamp to local time zone , or remove timezone from tz-aware Timestamp . With arguments `tz`, `nonexistent`.", "question_id": 42515}
{"snippet": "Timestamp.tz_localize(tz, ambiguous='raise', nonexistent='raise')", "intent": "Convert naive Timestamp to local time zone , or remove timezone from tz-aware Timestamp . With arguments `tz`, `ambiguous`, `nonexistent`.", "question_id": 42516}
{"snippet": "Timestamp.tz_localize(tz)", "intent": "Convert naive Timestamp to local time zone , or remove timezone from tz-aware Timestamp . With arguments `tz`.", "question_id": 42517}
{"snippet": "Timestamp.tz_localize(tz, ambiguous='raise')", "intent": "Convert naive Timestamp to local time zone , or remove timezone from tz-aware Timestamp . With arguments `tz`, `ambiguous`.", "question_id": 42518}
{"snippet": "Timestamp.tz_localize(tz, nonexistent='raise')", "intent": "Convert naive Timestamp to local time zone , or remove timezone from tz-aware Timestamp . With arguments `tz`, `nonexistent`.", "question_id": 42519}
{"snippet": "Timestamp.tz_localize(tz, ambiguous='raise', nonexistent='raise')", "intent": "Convert naive Timestamp to local time zone , or remove timezone from tz-aware Timestamp . With arguments `tz`, `ambiguous`, `nonexistent`.", "question_id": 42520}
{"snippet": "Timestamp.tzname()", "intent": "Return self.tzinfo.tzname ( self ) .", "question_id": 42521}
{"snippet": "Timestamp.tzname()", "intent": "Return self.tzinfo.tzname ( self ) .", "question_id": 42522}
{"snippet": "Timestamp.tzname()", "intent": "Return self.tzinfo.tzname ( self ) .", "question_id": 42523}
{"snippet": "Timestamp.utcfromtimestamp(ts)", "intent": "Construct a naive UTC datetime from a POSIX timestamp . With arguments `ts`.", "question_id": 42524}
{"snippet": "Timestamp.utcfromtimestamp(ts)", "intent": "Construct a naive UTC datetime from a POSIX timestamp . With arguments `ts`.", "question_id": 42525}
{"snippet": "Timestamp.utcfromtimestamp(ts)", "intent": "Construct a naive UTC datetime from a POSIX timestamp . With arguments `ts`.", "question_id": 42526}
{"snippet": "Timestamp.utcnow()", "intent": "Return a new Timestamp representing UTC day and time .", "question_id": 42527}
{"snippet": "Timestamp.utcnow()", "intent": "Return a new Timestamp representing UTC day and time .", "question_id": 42528}
{"snippet": "Timestamp.utcnow()", "intent": "Return a new Timestamp representing UTC day and time .", "question_id": 42529}
{"snippet": "Timestamp.utcoffset()", "intent": "Return self.tzinfo.utcoffset ( self ) .", "question_id": 42530}
{"snippet": "Timestamp.utcoffset()", "intent": "Return self.tzinfo.utcoffset ( self ) .", "question_id": 42531}
{"snippet": "Timestamp.utcoffset()", "intent": "Return self.tzinfo.utcoffset ( self ) .", "question_id": 42532}
{"snippet": "Timestamp.utctimetuple()", "intent": "Return UTC time tuple , compatible with time.localtime ( ) .", "question_id": 42533}
{"snippet": "Timestamp.utctimetuple()", "intent": "Return UTC time tuple , compatible with time.localtime ( ) .", "question_id": 42534}
{"snippet": "Timestamp.utctimetuple()", "intent": "Return UTC time tuple , compatible with time.localtime ( ) .", "question_id": 42535}
{"snippet": "Timestamp.week", "intent": "Return the week number of the year.", "question_id": 42536}
{"snippet": "Timestamp.week", "intent": "Return the week number of the year.", "question_id": 42537}
{"snippet": "Timestamp.week", "intent": "Return the week number of the year.", "question_id": 42538}
{"snippet": "Timestamp.weekday()", "intent": "Return the day of the week represented by the date .", "question_id": 42539}
{"snippet": "Timestamp.weekday()", "intent": "Return the day of the week represented by the date .", "question_id": 42540}
{"snippet": "Timestamp.weekday()", "intent": "Return the day of the week represented by the date .", "question_id": 42541}
{"snippet": "Timestamp.weekofyear", "intent": "Return the week number of the year.", "question_id": 42542}
{"snippet": "Timestamp.weekofyear", "intent": "Return the week number of the year.", "question_id": 42543}
{"snippet": "Timestamp.weekofyear", "intent": "Return the week number of the year.", "question_id": 42544}
{"snippet": "pandas.UInt16Dtype", "intent": "An ExtensionDtype for uint16 integer data.", "question_id": 42545}
{"snippet": "pandas.UInt16Dtype", "intent": "An ExtensionDtype for uint16 integer data.", "question_id": 42546}
{"snippet": "pandas.UInt16Dtype", "intent": "An ExtensionDtype for uint16 integer data.", "question_id": 42547}
{"snippet": "pandas.UInt32Dtype", "intent": "An ExtensionDtype for uint32 integer data.", "question_id": 42548}
{"snippet": "pandas.UInt32Dtype", "intent": "An ExtensionDtype for uint32 integer data.", "question_id": 42549}
{"snippet": "pandas.UInt32Dtype", "intent": "An ExtensionDtype for uint32 integer data.", "question_id": 42550}
{"snippet": "pandas.UInt64Dtype", "intent": "An ExtensionDtype for uint64 integer data.", "question_id": 42551}
{"snippet": "pandas.UInt64Dtype", "intent": "An ExtensionDtype for uint64 integer data.", "question_id": 42552}
{"snippet": "pandas.UInt64Dtype", "intent": "An ExtensionDtype for uint64 integer data.", "question_id": 42553}
{"snippet": "pandas.UInt64Index()", "intent": "Immutable sequence used for indexing and alignment .", "question_id": 42554}
{"snippet": "pandas.UInt64Index(data=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`.", "question_id": 42555}
{"snippet": "pandas.UInt64Index(dtype=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`.", "question_id": 42556}
{"snippet": "pandas.UInt64Index(copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `copy`.", "question_id": 42557}
{"snippet": "pandas.UInt64Index(name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `name`.", "question_id": 42558}
{"snippet": "pandas.UInt64Index(data=None, dtype=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `dtype`.", "question_id": 42559}
{"snippet": "pandas.UInt64Index(data=None, copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `copy`.", "question_id": 42560}
{"snippet": "pandas.UInt64Index(data=None, name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `name`.", "question_id": 42561}
{"snippet": "pandas.UInt64Index(dtype=None, copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`, `copy`.", "question_id": 42562}
{"snippet": "pandas.UInt64Index(dtype=None, name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`, `name`.", "question_id": 42563}
{"snippet": "pandas.UInt64Index()", "intent": "Immutable sequence used for indexing and alignment .", "question_id": 42564}
{"snippet": "pandas.UInt64Index(data=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`.", "question_id": 42565}
{"snippet": "pandas.UInt64Index(dtype=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`.", "question_id": 42566}
{"snippet": "pandas.UInt64Index(copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `copy`.", "question_id": 42567}
{"snippet": "pandas.UInt64Index(name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `name`.", "question_id": 42568}
{"snippet": "pandas.UInt64Index(data=None, dtype=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `dtype`.", "question_id": 42569}
{"snippet": "pandas.UInt64Index(data=None, copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `copy`.", "question_id": 42570}
{"snippet": "pandas.UInt64Index(data=None, name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `name`.", "question_id": 42571}
{"snippet": "pandas.UInt64Index(dtype=None, copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`, `copy`.", "question_id": 42572}
{"snippet": "pandas.UInt64Index(dtype=None, name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`, `name`.", "question_id": 42573}
{"snippet": "pandas.UInt64Index()", "intent": "Immutable sequence used for indexing and alignment .", "question_id": 42574}
{"snippet": "pandas.UInt64Index(data=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`.", "question_id": 42575}
{"snippet": "pandas.UInt64Index(dtype=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`.", "question_id": 42576}
{"snippet": "pandas.UInt64Index(copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `copy`.", "question_id": 42577}
{"snippet": "pandas.UInt64Index(name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `name`.", "question_id": 42578}
{"snippet": "pandas.UInt64Index(data=None, dtype=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `dtype`.", "question_id": 42579}
{"snippet": "pandas.UInt64Index(data=None, copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `copy`.", "question_id": 42580}
{"snippet": "pandas.UInt64Index(data=None, name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `data`, `name`.", "question_id": 42581}
{"snippet": "pandas.UInt64Index(dtype=None, copy=False)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`, `copy`.", "question_id": 42582}
{"snippet": "pandas.UInt64Index(dtype=None, name=None)", "intent": "Immutable sequence used for indexing and alignment . With arguments `dtype`, `name`.", "question_id": 42583}
{"snippet": "pandas.UInt8Dtype", "intent": "An ExtensionDtype for uint8 integer data.", "question_id": 42584}
{"snippet": "pandas.UInt8Dtype", "intent": "An ExtensionDtype for uint8 integer data.", "question_id": 42585}
{"snippet": "pandas.UInt8Dtype", "intent": "An ExtensionDtype for uint8 integer data.", "question_id": 42586}
{"snippet": "ExtensionArray._concat_same_type(to_concat)", "intent": "Concatenate multiple array of this dtype . With arguments `to_concat`.", "question_id": 42587}
{"snippet": "ExtensionArray._concat_same_type(to_concat)", "intent": "Concatenate multiple array of this dtype . With arguments `to_concat`.", "question_id": 42588}
{"snippet": "ExtensionArray._concat_same_type(to_concat)", "intent": "Concatenate multiple array of this dtype . With arguments `to_concat`.", "question_id": 42589}
{"snippet": "ExtensionArray._formatter()", "intent": "Formatting function for scalar values .", "question_id": 42590}
{"snippet": "ExtensionArray._formatter(boxed=False)", "intent": "Formatting function for scalar values . With arguments `boxed`.", "question_id": 42591}
{"snippet": "ExtensionArray._formatter()", "intent": "Formatting function for scalar values .", "question_id": 42592}
{"snippet": "ExtensionArray._formatter(boxed=False)", "intent": "Formatting function for scalar values . With arguments `boxed`.", "question_id": 42593}
{"snippet": "ExtensionArray._formatter()", "intent": "Formatting function for scalar values .", "question_id": 42594}
{"snippet": "ExtensionArray._formatter(boxed=False)", "intent": "Formatting function for scalar values . With arguments `boxed`.", "question_id": 42595}
{"snippet": "ExtensionArray._from_factorized(values, original)", "intent": "Reconstruct an ExtensionArray after factorization . With arguments `values`, `original`.", "question_id": 42596}
{"snippet": "ExtensionArray._from_factorized(values, original)", "intent": "Reconstruct an ExtensionArray after factorization . With arguments `values`, `original`.", "question_id": 42597}
{"snippet": "ExtensionArray._from_factorized(values, original)", "intent": "Reconstruct an ExtensionArray after factorization . With arguments `values`, `original`.", "question_id": 42598}
{"snippet": "ExtensionArray._from_sequence(scalars)", "intent": "Construct a new ExtensionArray from a sequence of `scalars` .", "question_id": 42599}
{"snippet": "ExtensionArray._from_sequence(scalars, dtype=None)", "intent": "Construct a new ExtensionArray from a sequence of `scalars` . With arguments `dtype`.", "question_id": 42600}
{"snippet": "ExtensionArray._from_sequence(scalars, copy=False)", "intent": "Construct a new ExtensionArray from a sequence of `scalars` . With arguments `copy`.", "question_id": 42601}
{"snippet": "ExtensionArray._from_sequence(scalars, dtype=None, copy=False)", "intent": "Construct a new ExtensionArray from a sequence of `scalars` . With arguments `dtype`, `copy`.", "question_id": 42602}
{"snippet": "ExtensionArray._from_sequence(scalars)", "intent": "Construct a new ExtensionArray from a sequence of `scalars` .", "question_id": 42603}
{"snippet": "ExtensionArray._from_sequence(scalars, dtype=None)", "intent": "Construct a new ExtensionArray from a sequence of `scalars` . With arguments `dtype`.", "question_id": 42604}
{"snippet": "ExtensionArray._from_sequence(scalars, copy=False)", "intent": "Construct a new ExtensionArray from a sequence of `scalars` . With arguments `copy`.", "question_id": 42605}
{"snippet": "ExtensionArray._from_sequence(scalars, dtype=None, copy=False)", "intent": "Construct a new ExtensionArray from a sequence of `scalars` . With arguments `dtype`, `copy`.", "question_id": 42606}
{"snippet": "ExtensionArray._from_sequence(scalars)", "intent": "Construct a new ExtensionArray from a sequence of `scalars` .", "question_id": 42607}
{"snippet": "ExtensionArray._from_sequence(scalars, dtype=None)", "intent": "Construct a new ExtensionArray from a sequence of `scalars` . With arguments `dtype`.", "question_id": 42608}
{"snippet": "ExtensionArray._from_sequence(scalars, copy=False)", "intent": "Construct a new ExtensionArray from a sequence of `scalars` . With arguments `copy`.", "question_id": 42609}
{"snippet": "ExtensionArray._from_sequence(scalars, dtype=None, copy=False)", "intent": "Construct a new ExtensionArray from a sequence of `scalars` . With arguments `dtype`, `copy`.", "question_id": 42610}
{"snippet": "ExtensionArray._from_sequence_of_strings(strings)", "intent": "Construct a new ExtensionArray from a sequence of `strings` .", "question_id": 42611}
{"snippet": "ExtensionArray._from_sequence_of_strings(strings, dtype=None)", "intent": "Construct a new ExtensionArray from a sequence of `strings` . With arguments `dtype`.", "question_id": 42612}
{"snippet": "ExtensionArray._from_sequence_of_strings(strings, copy=False)", "intent": "Construct a new ExtensionArray from a sequence of `strings` . With arguments `copy`.", "question_id": 42613}
{"snippet": "ExtensionArray._from_sequence_of_strings(strings, dtype=None, copy=False)", "intent": "Construct a new ExtensionArray from a sequence of `strings` . With arguments `dtype`, `copy`.", "question_id": 42614}
{"snippet": "ExtensionArray._from_sequence_of_strings(strings)", "intent": "Construct a new ExtensionArray from a sequence of `strings` .", "question_id": 42615}
{"snippet": "ExtensionArray._from_sequence_of_strings(strings, dtype=None)", "intent": "Construct a new ExtensionArray from a sequence of `strings` . With arguments `dtype`.", "question_id": 42616}
{"snippet": "ExtensionArray._from_sequence_of_strings(strings, copy=False)", "intent": "Construct a new ExtensionArray from a sequence of `strings` . With arguments `copy`.", "question_id": 42617}
{"snippet": "ExtensionArray._from_sequence_of_strings(strings, dtype=None, copy=False)", "intent": "Construct a new ExtensionArray from a sequence of `strings` . With arguments `dtype`, `copy`.", "question_id": 42618}
{"snippet": "ExtensionArray._from_sequence_of_strings(strings)", "intent": "Construct a new ExtensionArray from a sequence of `strings` .", "question_id": 42619}
{"snippet": "ExtensionArray._from_sequence_of_strings(strings, dtype=None)", "intent": "Construct a new ExtensionArray from a sequence of `strings` . With arguments `dtype`.", "question_id": 42620}
{"snippet": "ExtensionArray._from_sequence_of_strings(strings, copy=False)", "intent": "Construct a new ExtensionArray from a sequence of `strings` . With arguments `copy`.", "question_id": 42621}
{"snippet": "ExtensionArray._from_sequence_of_strings(strings, dtype=None, copy=False)", "intent": "Construct a new ExtensionArray from a sequence of `strings` . With arguments `dtype`, `copy`.", "question_id": 42622}
{"snippet": "ExtensionArray._reduce(name, **kwargs)", "intent": "Return a scalar result of performing the reduction operation . With arguments `name`, `**kwargs`.", "question_id": 42623}
{"snippet": "ExtensionArray._reduce(name, **kwargs, skipna=True)", "intent": "Return a scalar result of performing the reduction operation . With arguments `name`, `**kwargs`, `skipna`.", "question_id": 42624}
{"snippet": "ExtensionArray._reduce(name, **kwargs)", "intent": "Return a scalar result of performing the reduction operation . With arguments `name`, `**kwargs`.", "question_id": 42625}
{"snippet": "ExtensionArray._reduce(name, **kwargs, skipna=True)", "intent": "Return a scalar result of performing the reduction operation . With arguments `name`, `**kwargs`, `skipna`.", "question_id": 42626}
{"snippet": "ExtensionArray._reduce(name, **kwargs)", "intent": "Return a scalar result of performing the reduction operation . With arguments `name`, `**kwargs`.", "question_id": 42627}
{"snippet": "ExtensionArray._reduce(name, **kwargs, skipna=True)", "intent": "Return a scalar result of performing the reduction operation . With arguments `name`, `**kwargs`, `skipna`.", "question_id": 42628}
{"snippet": "ExtensionArray._values_for_argsort()", "intent": "Return values for sorting .", "question_id": 42629}
{"snippet": "ExtensionArray._values_for_argsort()", "intent": "Return values for sorting .", "question_id": 42630}
{"snippet": "ExtensionArray._values_for_argsort()", "intent": "Return values for sorting .", "question_id": 42631}
{"snippet": "ExtensionArray._values_for_factorize()", "intent": "Return an array and missing value suitable for factorization .", "question_id": 42632}
{"snippet": "ExtensionArray._values_for_factorize()", "intent": "Return an array and missing value suitable for factorization .", "question_id": 42633}
{"snippet": "ExtensionArray._values_for_factorize()", "intent": "Return an array and missing value suitable for factorization .", "question_id": 42634}
{"snippet": "ExtensionArray.argsort(*args, **kwargs)", "intent": "Return the indices that would sort this array . With arguments `*args`, `**kwargs`.", "question_id": 42635}
{"snippet": "ExtensionArray.argsort(*args, **kwargs, ascending=True)", "intent": "Return the indices that would sort this array . With arguments `*args`, `**kwargs`, `ascending`.", "question_id": 42636}
{"snippet": "ExtensionArray.argsort(*args, **kwargs, kind='quicksort')", "intent": "Return the indices that would sort this array . With arguments `*args`, `**kwargs`, `kind`.", "question_id": 42637}
{"snippet": "ExtensionArray.argsort(*args, **kwargs, na_position='last')", "intent": "Return the indices that would sort this array . With arguments `*args`, `**kwargs`, `na_position`.", "question_id": 42638}
{"snippet": "ExtensionArray.argsort(*args, **kwargs, ascending=True, kind='quicksort')", "intent": "Return the indices that would sort this array . With arguments `*args`, `**kwargs`, `ascending`, `kind`.", "question_id": 42639}
{"snippet": "ExtensionArray.argsort(*args, **kwargs, ascending=True, na_position='last')", "intent": "Return the indices that would sort this array . With arguments `*args`, `**kwargs`, `ascending`, `na_position`.", "question_id": 42640}
{"snippet": "ExtensionArray.argsort(*args, **kwargs, kind='quicksort', na_position='last')", "intent": "Return the indices that would sort this array . With arguments `*args`, `**kwargs`, `kind`, `na_position`.", "question_id": 42641}
{"snippet": "ExtensionArray.argsort(*args, **kwargs, ascending=True, kind='quicksort', na_position='last')", "intent": "Return the indices that would sort this array . With arguments `*args`, `**kwargs`, `ascending`, `kind`, `na_position`.", "question_id": 42642}
{"snippet": "ExtensionArray.argsort(*args, **kwargs)", "intent": "Return the indices that would sort this array . With arguments `*args`, `**kwargs`.", "question_id": 42643}
{"snippet": "ExtensionArray.argsort(*args, **kwargs, ascending=True)", "intent": "Return the indices that would sort this array . With arguments `*args`, `**kwargs`, `ascending`.", "question_id": 42644}
{"snippet": "ExtensionArray.argsort(*args, **kwargs, kind='quicksort')", "intent": "Return the indices that would sort this array . With arguments `*args`, `**kwargs`, `kind`.", "question_id": 42645}
{"snippet": "ExtensionArray.argsort(*args, **kwargs, na_position='last')", "intent": "Return the indices that would sort this array . With arguments `*args`, `**kwargs`, `na_position`.", "question_id": 42646}
{"snippet": "ExtensionArray.argsort(*args, **kwargs, ascending=True, kind='quicksort')", "intent": "Return the indices that would sort this array . With arguments `*args`, `**kwargs`, `ascending`, `kind`.", "question_id": 42647}
{"snippet": "ExtensionArray.argsort(*args, **kwargs, ascending=True, na_position='last')", "intent": "Return the indices that would sort this array . With arguments `*args`, `**kwargs`, `ascending`, `na_position`.", "question_id": 42648}
{"snippet": "ExtensionArray.argsort(*args, **kwargs, kind='quicksort', na_position='last')", "intent": "Return the indices that would sort this array . With arguments `*args`, `**kwargs`, `kind`, `na_position`.", "question_id": 42649}
{"snippet": "ExtensionArray.argsort(*args, **kwargs, ascending=True, kind='quicksort', na_position='last')", "intent": "Return the indices that would sort this array . With arguments `*args`, `**kwargs`, `ascending`, `kind`, `na_position`.", "question_id": 42650}
{"snippet": "ExtensionArray.argsort(*args, **kwargs)", "intent": "Return the indices that would sort this array . With arguments `*args`, `**kwargs`.", "question_id": 42651}
{"snippet": "ExtensionArray.argsort(*args, **kwargs, ascending=True)", "intent": "Return the indices that would sort this array . With arguments `*args`, `**kwargs`, `ascending`.", "question_id": 42652}
{"snippet": "ExtensionArray.argsort(*args, **kwargs, kind='quicksort')", "intent": "Return the indices that would sort this array . With arguments `*args`, `**kwargs`, `kind`.", "question_id": 42653}
{"snippet": "ExtensionArray.argsort(*args, **kwargs, na_position='last')", "intent": "Return the indices that would sort this array . With arguments `*args`, `**kwargs`, `na_position`.", "question_id": 42654}
{"snippet": "ExtensionArray.argsort(*args, **kwargs, ascending=True, kind='quicksort')", "intent": "Return the indices that would sort this array . With arguments `*args`, `**kwargs`, `ascending`, `kind`.", "question_id": 42655}
{"snippet": "ExtensionArray.argsort(*args, **kwargs, ascending=True, na_position='last')", "intent": "Return the indices that would sort this array . With arguments `*args`, `**kwargs`, `ascending`, `na_position`.", "question_id": 42656}
{"snippet": "ExtensionArray.argsort(*args, **kwargs, kind='quicksort', na_position='last')", "intent": "Return the indices that would sort this array . With arguments `*args`, `**kwargs`, `kind`, `na_position`.", "question_id": 42657}
{"snippet": "ExtensionArray.argsort(*args, **kwargs, ascending=True, kind='quicksort', na_position='last')", "intent": "Return the indices that would sort this array . With arguments `*args`, `**kwargs`, `ascending`, `kind`, `na_position`.", "question_id": 42658}
{"snippet": "ExtensionArray.astype(dtype)", "intent": "Cast to a NumPy array with \u2018 `dtype` \u2019 .", "question_id": 42659}
{"snippet": "ExtensionArray.astype(dtype, copy=True)", "intent": "Cast to a NumPy array with \u2018 `dtype` \u2019 . With arguments `copy`.", "question_id": 42660}
{"snippet": "ExtensionArray.astype(dtype)", "intent": "Cast to a NumPy array with \u2018 `dtype` \u2019 .", "question_id": 42661}
{"snippet": "ExtensionArray.astype(dtype, copy=True)", "intent": "Cast to a NumPy array with \u2018 `dtype` \u2019 . With arguments `copy`.", "question_id": 42662}
{"snippet": "ExtensionArray.astype(dtype)", "intent": "Cast to a NumPy array with \u2018 `dtype` \u2019 .", "question_id": 42663}
{"snippet": "ExtensionArray.astype(dtype, copy=True)", "intent": "Cast to a NumPy array with \u2018 `dtype` \u2019 . With arguments `copy`.", "question_id": 42664}
{"snippet": "ExtensionArray.copy()", "intent": "Return a copy of the array .", "question_id": 42665}
{"snippet": "ExtensionArray.copy()", "intent": "Return a copy of the array .", "question_id": 42666}
{"snippet": "ExtensionArray.copy()", "intent": "Return a copy of the array .", "question_id": 42667}
{"snippet": "ExtensionArray.dropna()", "intent": "Return ExtensionArray without NA values .", "question_id": 42668}
{"snippet": "ExtensionArray.dropna()", "intent": "Return ExtensionArray without NA values .", "question_id": 42669}
{"snippet": "ExtensionArray.dropna()", "intent": "Return ExtensionArray without NA values .", "question_id": 42670}
{"snippet": "ExtensionArray.equals(other)", "intent": "Return if another array is equivalent to this array . With arguments `other`.", "question_id": 42671}
{"snippet": "ExtensionArray.equals(other)", "intent": "Return if another array is equivalent to this array . With arguments `other`.", "question_id": 42672}
{"snippet": "ExtensionArray.equals(other)", "intent": "Return if another array is equivalent to this array . With arguments `other`.", "question_id": 42673}
{"snippet": "ExtensionArray.factorize()", "intent": "Encode the extension array as an enumerated type .", "question_id": 42674}
{"snippet": "ExtensionArray.factorize(na_sentinel=- 1)", "intent": "Encode the extension array as an enumerated type . With arguments `na_sentinel`.", "question_id": 42675}
{"snippet": "ExtensionArray.factorize()", "intent": "Encode the extension array as an enumerated type .", "question_id": 42676}
{"snippet": "ExtensionArray.factorize(na_sentinel=- 1)", "intent": "Encode the extension array as an enumerated type . With arguments `na_sentinel`.", "question_id": 42677}
{"snippet": "ExtensionArray.factorize()", "intent": "Encode the extension array as an enumerated type .", "question_id": 42678}
{"snippet": "ExtensionArray.factorize(na_sentinel=- 1)", "intent": "Encode the extension array as an enumerated type . With arguments `na_sentinel`.", "question_id": 42679}
{"snippet": "ExtensionArray.fillna()", "intent": "Fill NA/NaN values using the specified `method` .", "question_id": 42680}
{"snippet": "ExtensionArray.fillna(value=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`.", "question_id": 42681}
{"snippet": "ExtensionArray.fillna(method=None)", "intent": "Fill NA/NaN values using the specified `method` .", "question_id": 42682}
{"snippet": "ExtensionArray.fillna(limit=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `limit`.", "question_id": 42683}
{"snippet": "ExtensionArray.fillna(value=None, method=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`.", "question_id": 42684}
{"snippet": "ExtensionArray.fillna(value=None, limit=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`, `limit`.", "question_id": 42685}
{"snippet": "ExtensionArray.fillna(method=None, limit=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `limit`.", "question_id": 42686}
{"snippet": "ExtensionArray.fillna(value=None, method=None, limit=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`, `limit`.", "question_id": 42687}
{"snippet": "ExtensionArray.fillna()", "intent": "Fill NA/NaN values using the specified `method` .", "question_id": 42688}
{"snippet": "ExtensionArray.fillna(value=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`.", "question_id": 42689}
{"snippet": "ExtensionArray.fillna(method=None)", "intent": "Fill NA/NaN values using the specified `method` .", "question_id": 42690}
{"snippet": "ExtensionArray.fillna(limit=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `limit`.", "question_id": 42691}
{"snippet": "ExtensionArray.fillna(value=None, method=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`.", "question_id": 42692}
{"snippet": "ExtensionArray.fillna(value=None, limit=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`, `limit`.", "question_id": 42693}
{"snippet": "ExtensionArray.fillna(method=None, limit=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `limit`.", "question_id": 42694}
{"snippet": "ExtensionArray.fillna(value=None, method=None, limit=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`, `limit`.", "question_id": 42695}
{"snippet": "ExtensionArray.fillna()", "intent": "Fill NA/NaN values using the specified `method` .", "question_id": 42696}
{"snippet": "ExtensionArray.fillna(value=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`.", "question_id": 42697}
{"snippet": "ExtensionArray.fillna(method=None)", "intent": "Fill NA/NaN values using the specified `method` .", "question_id": 42698}
{"snippet": "ExtensionArray.fillna(limit=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `limit`.", "question_id": 42699}
{"snippet": "ExtensionArray.fillna(value=None, method=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`.", "question_id": 42700}
{"snippet": "ExtensionArray.fillna(value=None, limit=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`, `limit`.", "question_id": 42701}
{"snippet": "ExtensionArray.fillna(method=None, limit=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `limit`.", "question_id": 42702}
{"snippet": "ExtensionArray.fillna(value=None, method=None, limit=None)", "intent": "Fill NA/NaN values using the specified `method` . With arguments `value`, `limit`.", "question_id": 42703}
{"snippet": "pandas.api.extensions.ExtensionArray", "intent": "Abstract base class for custom 1-D array types.", "question_id": 42704}
{"snippet": "pandas.api.extensions.ExtensionArray", "intent": "Abstract base class for custom 1-D array types.", "question_id": 42705}
{"snippet": "pandas.api.extensions.ExtensionArray", "intent": "Abstract base class for custom 1-D array types.", "question_id": 42706}
{"snippet": "ExtensionArray.isin(values)", "intent": "Pointwise comparison for set containment in the given `values` .", "question_id": 42707}
{"snippet": "ExtensionArray.isin(values)", "intent": "Pointwise comparison for set containment in the given `values` .", "question_id": 42708}
{"snippet": "ExtensionArray.isin(values)", "intent": "Pointwise comparison for set containment in the given `values` .", "question_id": 42709}
{"snippet": "ExtensionArray.isna()", "intent": "A 1-D array indicating if each value is missing .", "question_id": 42710}
{"snippet": "ExtensionArray.isna()", "intent": "A 1-D array indicating if each value is missing .", "question_id": 42711}
{"snippet": "ExtensionArray.isna()", "intent": "A 1-D array indicating if each value is missing .", "question_id": 42712}
{"snippet": "ExtensionArray.ravel()", "intent": "Return a flattened view on this array .", "question_id": 42713}
{"snippet": "ExtensionArray.ravel(order='C')", "intent": "Return a flattened view on this array . With arguments `order`.", "question_id": 42714}
{"snippet": "ExtensionArray.ravel()", "intent": "Return a flattened view on this array .", "question_id": 42715}
{"snippet": "ExtensionArray.ravel(order='C')", "intent": "Return a flattened view on this array . With arguments `order`.", "question_id": 42716}
{"snippet": "ExtensionArray.ravel()", "intent": "Return a flattened view on this array .", "question_id": 42717}
{"snippet": "ExtensionArray.ravel(order='C')", "intent": "Return a flattened view on this array . With arguments `order`.", "question_id": 42718}
{"snippet": "ExtensionArray.repeat(repeats)", "intent": "Repeat elements of a ExtensionArray . With arguments `repeats`.", "question_id": 42719}
{"snippet": "ExtensionArray.repeat(repeats, axis=None)", "intent": "Repeat elements of a ExtensionArray . With arguments `repeats`, `axis`.", "question_id": 42720}
{"snippet": "ExtensionArray.repeat(repeats)", "intent": "Repeat elements of a ExtensionArray . With arguments `repeats`.", "question_id": 42721}
{"snippet": "ExtensionArray.repeat(repeats, axis=None)", "intent": "Repeat elements of a ExtensionArray . With arguments `repeats`, `axis`.", "question_id": 42722}
{"snippet": "ExtensionArray.repeat(repeats)", "intent": "Repeat elements of a ExtensionArray . With arguments `repeats`.", "question_id": 42723}
{"snippet": "ExtensionArray.repeat(repeats, axis=None)", "intent": "Repeat elements of a ExtensionArray . With arguments `repeats`, `axis`.", "question_id": 42724}
{"snippet": "ExtensionArray.searchsorted(value)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted array self ( a ) such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved .", "question_id": 42725}
{"snippet": "ExtensionArray.searchsorted(value, side='left')", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted array self ( a ) such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `side`.", "question_id": 42726}
{"snippet": "ExtensionArray.searchsorted(value, sorter=None)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted array self ( a ) such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `sorter`.", "question_id": 42727}
{"snippet": "ExtensionArray.searchsorted(value, side='left', sorter=None)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted array self ( a ) such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `side`, `sorter`.", "question_id": 42728}
{"snippet": "ExtensionArray.searchsorted(value)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted array self ( a ) such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved .", "question_id": 42729}
{"snippet": "ExtensionArray.searchsorted(value, side='left')", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted array self ( a ) such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `side`.", "question_id": 42730}
{"snippet": "ExtensionArray.searchsorted(value, sorter=None)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted array self ( a ) such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `sorter`.", "question_id": 42731}
{"snippet": "ExtensionArray.searchsorted(value, side='left', sorter=None)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted array self ( a ) such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `side`, `sorter`.", "question_id": 42732}
{"snippet": "ExtensionArray.searchsorted(value)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted array self ( a ) such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved .", "question_id": 42733}
{"snippet": "ExtensionArray.searchsorted(value, side='left')", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted array self ( a ) such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `side`.", "question_id": 42734}
{"snippet": "ExtensionArray.searchsorted(value, sorter=None)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted array self ( a ) such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `sorter`.", "question_id": 42735}
{"snippet": "ExtensionArray.searchsorted(value, side='left', sorter=None)", "intent": "Find indices where elements should be inserted to maintain order . Find the indices into a sorted array self ( a ) such that , if the corresponding elements in `value` were inserted before the indices , the order of self would be preserved . With arguments `side`, `sorter`.", "question_id": 42736}
{"snippet": "ExtensionArray.shift()", "intent": "Shift values by desired number .", "question_id": 42737}
{"snippet": "ExtensionArray.shift(periods=1)", "intent": "Shift values by desired number . If self is empty or `periods` is 0 , a copy of self is returned .", "question_id": 42738}
{"snippet": "ExtensionArray.shift(fill_value=None)", "intent": "Shift values by desired number . With arguments `fill_value`.", "question_id": 42739}
{"snippet": "ExtensionArray.shift(periods=1, fill_value=None)", "intent": "Shift values by desired number . If self is empty or `periods` is 0 , a copy of self is returned . With arguments `fill_value`.", "question_id": 42740}
{"snippet": "ExtensionArray.shift()", "intent": "Shift values by desired number .", "question_id": 42741}
{"snippet": "ExtensionArray.shift(periods=1)", "intent": "Shift values by desired number . If self is empty or `periods` is 0 , a copy of self is returned .", "question_id": 42742}
{"snippet": "ExtensionArray.shift(fill_value=None)", "intent": "Shift values by desired number . With arguments `fill_value`.", "question_id": 42743}
{"snippet": "ExtensionArray.shift(periods=1, fill_value=None)", "intent": "Shift values by desired number . If self is empty or `periods` is 0 , a copy of self is returned . With arguments `fill_value`.", "question_id": 42744}
{"snippet": "ExtensionArray.shift()", "intent": "Shift values by desired number .", "question_id": 42745}
{"snippet": "ExtensionArray.shift(periods=1)", "intent": "Shift values by desired number . If self is empty or `periods` is 0 , a copy of self is returned .", "question_id": 42746}
{"snippet": "ExtensionArray.shift(fill_value=None)", "intent": "Shift values by desired number . With arguments `fill_value`.", "question_id": 42747}
{"snippet": "ExtensionArray.shift(periods=1, fill_value=None)", "intent": "Shift values by desired number . If self is empty or `periods` is 0 , a copy of self is returned . With arguments `fill_value`.", "question_id": 42748}
{"snippet": "ExtensionArray.take(indices)", "intent": "Take elements from an array . ExtensionArray.take is called by Series.__getitem__ , .loc , iloc , when `indices` is a sequence of values .", "question_id": 42749}
{"snippet": "ExtensionArray.take(indices, allow_fill=False)", "intent": "Take elements from an array . ExtensionArray.take is called by Series.__getitem__ , .loc , iloc , when `indices` is a sequence of values . With arguments `allow_fill`.", "question_id": 42750}
{"snippet": "ExtensionArray.take(indices, fill_value=None)", "intent": "Take elements from an array . ExtensionArray.take is called by Series.__getitem__ , .loc , iloc , when `indices` is a sequence of values . Additionally , it \u2019 s called by Series.reindex ( ) , or any other method that causes realignment , with a `fill_value` .", "question_id": 42751}
{"snippet": "ExtensionArray.take(indices, allow_fill=False, fill_value=None)", "intent": "Take elements from an array . ExtensionArray.take is called by Series.__getitem__ , .loc , iloc , when `indices` is a sequence of values . Additionally , it \u2019 s called by Series.reindex ( ) , or any other method that causes realignment , with a `fill_value` . With arguments `allow_fill`.", "question_id": 42752}
{"snippet": "ExtensionArray.take(indices)", "intent": "Take elements from an array . ExtensionArray.take is called by Series.__getitem__ , .loc , iloc , when `indices` is a sequence of values .", "question_id": 42753}
{"snippet": "ExtensionArray.take(indices, allow_fill=False)", "intent": "Take elements from an array . ExtensionArray.take is called by Series.__getitem__ , .loc , iloc , when `indices` is a sequence of values . With arguments `allow_fill`.", "question_id": 42754}
{"snippet": "ExtensionArray.take(indices, fill_value=None)", "intent": "Take elements from an array . ExtensionArray.take is called by Series.__getitem__ , .loc , iloc , when `indices` is a sequence of values . Additionally , it \u2019 s called by Series.reindex ( ) , or any other method that causes realignment , with a `fill_value` .", "question_id": 42755}
{"snippet": "ExtensionArray.take(indices, allow_fill=False, fill_value=None)", "intent": "Take elements from an array . ExtensionArray.take is called by Series.__getitem__ , .loc , iloc , when `indices` is a sequence of values . Additionally , it \u2019 s called by Series.reindex ( ) , or any other method that causes realignment , with a `fill_value` . With arguments `allow_fill`.", "question_id": 42756}
{"snippet": "ExtensionArray.take(indices)", "intent": "Take elements from an array . ExtensionArray.take is called by Series.__getitem__ , .loc , iloc , when `indices` is a sequence of values .", "question_id": 42757}
{"snippet": "ExtensionArray.take(indices, allow_fill=False)", "intent": "Take elements from an array . ExtensionArray.take is called by Series.__getitem__ , .loc , iloc , when `indices` is a sequence of values . With arguments `allow_fill`.", "question_id": 42758}
{"snippet": "ExtensionArray.take(indices, fill_value=None)", "intent": "Take elements from an array . ExtensionArray.take is called by Series.__getitem__ , .loc , iloc , when `indices` is a sequence of values . Additionally , it \u2019 s called by Series.reindex ( ) , or any other method that causes realignment , with a `fill_value` .", "question_id": 42759}
{"snippet": "ExtensionArray.take(indices, allow_fill=False, fill_value=None)", "intent": "Take elements from an array . ExtensionArray.take is called by Series.__getitem__ , .loc , iloc , when `indices` is a sequence of values . Additionally , it \u2019 s called by Series.reindex ( ) , or any other method that causes realignment , with a `fill_value` . With arguments `allow_fill`.", "question_id": 42760}
{"snippet": "ExtensionArray.unique()", "intent": "Compute the ExtensionArray of unique values .", "question_id": 42761}
{"snippet": "ExtensionArray.unique()", "intent": "Compute the ExtensionArray of unique values .", "question_id": 42762}
{"snippet": "ExtensionArray.unique()", "intent": "Compute the ExtensionArray of unique values .", "question_id": 42763}
{"snippet": "ExtensionArray.view()", "intent": "Return a view on the array .", "question_id": 42764}
{"snippet": "ExtensionArray.view(dtype=None)", "intent": "Return a view on the array . With arguments `dtype`.", "question_id": 42765}
{"snippet": "ExtensionArray.view()", "intent": "Return a view on the array .", "question_id": 42766}
{"snippet": "ExtensionArray.view(dtype=None)", "intent": "Return a view on the array . With arguments `dtype`.", "question_id": 42767}
{"snippet": "ExtensionArray.view()", "intent": "Return a view on the array .", "question_id": 42768}
{"snippet": "ExtensionArray.view(dtype=None)", "intent": "Return a view on the array . With arguments `dtype`.", "question_id": 42769}
{"snippet": "ExtensionDtype.construct_array_type()", "intent": "Return the array type associated with this dtype .", "question_id": 42770}
{"snippet": "ExtensionDtype.construct_array_type()", "intent": "Return the array type associated with this dtype .", "question_id": 42771}
{"snippet": "ExtensionDtype.construct_array_type()", "intent": "Return the array type associated with this dtype .", "question_id": 42772}
{"snippet": "ExtensionDtype.construct_from_string(string)", "intent": "Construct this type from a `string` .", "question_id": 42773}
{"snippet": "ExtensionDtype.construct_from_string(string)", "intent": "Construct this type from a `string` .", "question_id": 42774}
{"snippet": "ExtensionDtype.construct_from_string(string)", "intent": "Construct this type from a `string` .", "question_id": 42775}
{"snippet": "pandas.api.extensions.ExtensionDtype", "intent": "A custom data type, to be paired with an ExtensionArray.", "question_id": 42776}
{"snippet": "pandas.api.extensions.ExtensionDtype", "intent": "A custom data type, to be paired with an ExtensionArray.", "question_id": 42777}
{"snippet": "pandas.api.extensions.ExtensionDtype", "intent": "A custom data type, to be paired with an ExtensionArray.", "question_id": 42778}
{"snippet": "ExtensionDtype.is_dtype(dtype)", "intent": "Check if we match \u2018 `dtype` \u2019 .", "question_id": 42779}
{"snippet": "ExtensionDtype.is_dtype(dtype)", "intent": "Check if we match \u2018 `dtype` \u2019 .", "question_id": 42780}
{"snippet": "ExtensionDtype.is_dtype(dtype)", "intent": "Check if we match \u2018 `dtype` \u2019 .", "question_id": 42781}
{"snippet": "pandas.api.extensions.register_dataframe_accessor(name)", "intent": "Register a custom accessor on DataFrame objects . With arguments `name`.", "question_id": 42782}
{"snippet": "pandas.api.extensions.register_dataframe_accessor(name)", "intent": "Register a custom accessor on DataFrame objects . With arguments `name`.", "question_id": 42783}
{"snippet": "pandas.api.extensions.register_dataframe_accessor(name)", "intent": "Register a custom accessor on DataFrame objects . With arguments `name`.", "question_id": 42784}
{"snippet": "pandas.api.extensions.register_extension_dtype(cls)", "intent": "Register an ExtensionType with pandas as class decorator . With arguments `cls`.", "question_id": 42785}
{"snippet": "pandas.api.extensions.register_extension_dtype(cls)", "intent": "Register an ExtensionType with pandas as class decorator . With arguments `cls`.", "question_id": 42786}
{"snippet": "pandas.api.extensions.register_extension_dtype(cls)", "intent": "Register an ExtensionType with pandas as class decorator . With arguments `cls`.", "question_id": 42787}
{"snippet": "pandas.api.extensions.register_index_accessor(name)", "intent": "Register a custom accessor on Index objects . With arguments `name`.", "question_id": 42788}
{"snippet": "pandas.api.extensions.register_index_accessor(name)", "intent": "Register a custom accessor on Index objects . With arguments `name`.", "question_id": 42789}
{"snippet": "pandas.api.extensions.register_index_accessor(name)", "intent": "Register a custom accessor on Index objects . With arguments `name`.", "question_id": 42790}
{"snippet": "pandas.api.extensions.register_series_accessor(name)", "intent": "Register a custom accessor on Series objects . With arguments `name`.", "question_id": 42791}
{"snippet": "pandas.api.extensions.register_series_accessor(name)", "intent": "Register a custom accessor on Series objects . With arguments `name`.", "question_id": 42792}
{"snippet": "pandas.api.extensions.register_series_accessor(name)", "intent": "Register a custom accessor on Series objects . With arguments `name`.", "question_id": 42793}
{"snippet": "BaseIndexer.get_window_bounds()", "intent": "Computes the bounds of a window .", "question_id": 42794}
{"snippet": "BaseIndexer.get_window_bounds(num_values=0)", "intent": "Computes the bounds of a window . With arguments `num_values`.", "question_id": 42795}
{"snippet": "BaseIndexer.get_window_bounds(min_periods=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`.", "question_id": 42796}
{"snippet": "BaseIndexer.get_window_bounds(center=None)", "intent": "Computes the bounds of a window . With arguments `center`.", "question_id": 42797}
{"snippet": "BaseIndexer.get_window_bounds(closed=None)", "intent": "Computes the bounds of a window . With arguments `closed`.", "question_id": 42798}
{"snippet": "BaseIndexer.get_window_bounds(num_values=0, min_periods=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `min_periods`.", "question_id": 42799}
{"snippet": "BaseIndexer.get_window_bounds(num_values=0, center=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `center`.", "question_id": 42800}
{"snippet": "BaseIndexer.get_window_bounds(num_values=0, closed=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `closed`.", "question_id": 42801}
{"snippet": "BaseIndexer.get_window_bounds(min_periods=None, center=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`, `center`.", "question_id": 42802}
{"snippet": "BaseIndexer.get_window_bounds(min_periods=None, closed=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`, `closed`.", "question_id": 42803}
{"snippet": "BaseIndexer.get_window_bounds()", "intent": "Computes the bounds of a window .", "question_id": 42804}
{"snippet": "BaseIndexer.get_window_bounds(num_values=0)", "intent": "Computes the bounds of a window . With arguments `num_values`.", "question_id": 42805}
{"snippet": "BaseIndexer.get_window_bounds(min_periods=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`.", "question_id": 42806}
{"snippet": "BaseIndexer.get_window_bounds(center=None)", "intent": "Computes the bounds of a window . With arguments `center`.", "question_id": 42807}
{"snippet": "BaseIndexer.get_window_bounds(closed=None)", "intent": "Computes the bounds of a window . With arguments `closed`.", "question_id": 42808}
{"snippet": "BaseIndexer.get_window_bounds(num_values=0, min_periods=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `min_periods`.", "question_id": 42809}
{"snippet": "BaseIndexer.get_window_bounds(num_values=0, center=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `center`.", "question_id": 42810}
{"snippet": "BaseIndexer.get_window_bounds(num_values=0, closed=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `closed`.", "question_id": 42811}
{"snippet": "BaseIndexer.get_window_bounds(min_periods=None, center=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`, `center`.", "question_id": 42812}
{"snippet": "BaseIndexer.get_window_bounds(min_periods=None, closed=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`, `closed`.", "question_id": 42813}
{"snippet": "BaseIndexer.get_window_bounds()", "intent": "Computes the bounds of a window .", "question_id": 42814}
{"snippet": "BaseIndexer.get_window_bounds(num_values=0)", "intent": "Computes the bounds of a window . With arguments `num_values`.", "question_id": 42815}
{"snippet": "BaseIndexer.get_window_bounds(min_periods=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`.", "question_id": 42816}
{"snippet": "BaseIndexer.get_window_bounds(center=None)", "intent": "Computes the bounds of a window . With arguments `center`.", "question_id": 42817}
{"snippet": "BaseIndexer.get_window_bounds(closed=None)", "intent": "Computes the bounds of a window . With arguments `closed`.", "question_id": 42818}
{"snippet": "BaseIndexer.get_window_bounds(num_values=0, min_periods=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `min_periods`.", "question_id": 42819}
{"snippet": "BaseIndexer.get_window_bounds(num_values=0, center=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `center`.", "question_id": 42820}
{"snippet": "BaseIndexer.get_window_bounds(num_values=0, closed=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `closed`.", "question_id": 42821}
{"snippet": "BaseIndexer.get_window_bounds(min_periods=None, center=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`, `center`.", "question_id": 42822}
{"snippet": "BaseIndexer.get_window_bounds(min_periods=None, closed=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`, `closed`.", "question_id": 42823}
{"snippet": "pandas.api.indexers.BaseIndexer(**kwargs)", "intent": "Base class for window bounds calculations . With arguments `**kwargs`.", "question_id": 42824}
{"snippet": "pandas.api.indexers.BaseIndexer(**kwargs, index_array=None)", "intent": "Base class for window bounds calculations . With arguments `**kwargs`, `index_array`.", "question_id": 42825}
{"snippet": "pandas.api.indexers.BaseIndexer(**kwargs, window_size=0)", "intent": "Base class for window bounds calculations . With arguments `**kwargs`, `window_size`.", "question_id": 42826}
{"snippet": "pandas.api.indexers.BaseIndexer(**kwargs, index_array=None, window_size=0)", "intent": "Base class for window bounds calculations . With arguments `**kwargs`, `index_array`, `window_size`.", "question_id": 42827}
{"snippet": "pandas.api.indexers.BaseIndexer(**kwargs)", "intent": "Base class for window bounds calculations . With arguments `**kwargs`.", "question_id": 42828}
{"snippet": "pandas.api.indexers.BaseIndexer(**kwargs, index_array=None)", "intent": "Base class for window bounds calculations . With arguments `**kwargs`, `index_array`.", "question_id": 42829}
{"snippet": "pandas.api.indexers.BaseIndexer(**kwargs, window_size=0)", "intent": "Base class for window bounds calculations . With arguments `**kwargs`, `window_size`.", "question_id": 42830}
{"snippet": "pandas.api.indexers.BaseIndexer(**kwargs, index_array=None, window_size=0)", "intent": "Base class for window bounds calculations . With arguments `**kwargs`, `index_array`, `window_size`.", "question_id": 42831}
{"snippet": "pandas.api.indexers.BaseIndexer(**kwargs)", "intent": "Base class for window bounds calculations . With arguments `**kwargs`.", "question_id": 42832}
{"snippet": "pandas.api.indexers.BaseIndexer(**kwargs, index_array=None)", "intent": "Base class for window bounds calculations . With arguments `**kwargs`, `index_array`.", "question_id": 42833}
{"snippet": "pandas.api.indexers.BaseIndexer(**kwargs, window_size=0)", "intent": "Base class for window bounds calculations . With arguments `**kwargs`, `window_size`.", "question_id": 42834}
{"snippet": "pandas.api.indexers.BaseIndexer(**kwargs, index_array=None, window_size=0)", "intent": "Base class for window bounds calculations . With arguments `**kwargs`, `index_array`, `window_size`.", "question_id": 42835}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds()", "intent": "Computes the bounds of a window .", "question_id": 42836}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(num_values=0)", "intent": "Computes the bounds of a window . With arguments `num_values`.", "question_id": 42837}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(min_periods=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`.", "question_id": 42838}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(center=None)", "intent": "Computes the bounds of a window . With arguments `center`.", "question_id": 42839}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(closed=None)", "intent": "Computes the bounds of a window . With arguments `closed`.", "question_id": 42840}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(num_values=0, min_periods=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `min_periods`.", "question_id": 42841}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(num_values=0, center=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `center`.", "question_id": 42842}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(num_values=0, closed=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `closed`.", "question_id": 42843}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(min_periods=None, center=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`, `center`.", "question_id": 42844}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(min_periods=None, closed=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`, `closed`.", "question_id": 42845}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds()", "intent": "Computes the bounds of a window .", "question_id": 42846}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(num_values=0)", "intent": "Computes the bounds of a window . With arguments `num_values`.", "question_id": 42847}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(min_periods=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`.", "question_id": 42848}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(center=None)", "intent": "Computes the bounds of a window . With arguments `center`.", "question_id": 42849}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(closed=None)", "intent": "Computes the bounds of a window . With arguments `closed`.", "question_id": 42850}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(num_values=0, min_periods=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `min_periods`.", "question_id": 42851}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(num_values=0, center=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `center`.", "question_id": 42852}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(num_values=0, closed=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `closed`.", "question_id": 42853}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(min_periods=None, center=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`, `center`.", "question_id": 42854}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(min_periods=None, closed=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`, `closed`.", "question_id": 42855}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds()", "intent": "Computes the bounds of a window .", "question_id": 42856}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(num_values=0)", "intent": "Computes the bounds of a window . With arguments `num_values`.", "question_id": 42857}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(min_periods=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`.", "question_id": 42858}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(center=None)", "intent": "Computes the bounds of a window . With arguments `center`.", "question_id": 42859}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(closed=None)", "intent": "Computes the bounds of a window . With arguments `closed`.", "question_id": 42860}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(num_values=0, min_periods=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `min_periods`.", "question_id": 42861}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(num_values=0, center=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `center`.", "question_id": 42862}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(num_values=0, closed=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `closed`.", "question_id": 42863}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(min_periods=None, center=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`, `center`.", "question_id": 42864}
{"snippet": "FixedForwardWindowIndexer.get_window_bounds(min_periods=None, closed=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`, `closed`.", "question_id": 42865}
{"snippet": "pandas.api.indexers.FixedForwardWindowIndexer(**kwargs)", "intent": "Creates window boundaries for fixed-length windows that include the current row . With arguments `**kwargs`.", "question_id": 42866}
{"snippet": "pandas.api.indexers.FixedForwardWindowIndexer(**kwargs, index_array=None)", "intent": "Creates window boundaries for fixed-length windows that include the current row . With arguments `**kwargs`, `index_array`.", "question_id": 42867}
{"snippet": "pandas.api.indexers.FixedForwardWindowIndexer(**kwargs, window_size=0)", "intent": "Creates window boundaries for fixed-length windows that include the current row . With arguments `**kwargs`, `window_size`.", "question_id": 42868}
{"snippet": "pandas.api.indexers.FixedForwardWindowIndexer(**kwargs, index_array=None, window_size=0)", "intent": "Creates window boundaries for fixed-length windows that include the current row . With arguments `**kwargs`, `index_array`, `window_size`.", "question_id": 42869}
{"snippet": "pandas.api.indexers.FixedForwardWindowIndexer(**kwargs)", "intent": "Creates window boundaries for fixed-length windows that include the current row . With arguments `**kwargs`.", "question_id": 42870}
{"snippet": "pandas.api.indexers.FixedForwardWindowIndexer(**kwargs, index_array=None)", "intent": "Creates window boundaries for fixed-length windows that include the current row . With arguments `**kwargs`, `index_array`.", "question_id": 42871}
{"snippet": "pandas.api.indexers.FixedForwardWindowIndexer(**kwargs, window_size=0)", "intent": "Creates window boundaries for fixed-length windows that include the current row . With arguments `**kwargs`, `window_size`.", "question_id": 42872}
{"snippet": "pandas.api.indexers.FixedForwardWindowIndexer(**kwargs, index_array=None, window_size=0)", "intent": "Creates window boundaries for fixed-length windows that include the current row . With arguments `**kwargs`, `index_array`, `window_size`.", "question_id": 42873}
{"snippet": "pandas.api.indexers.FixedForwardWindowIndexer(**kwargs)", "intent": "Creates window boundaries for fixed-length windows that include the current row . With arguments `**kwargs`.", "question_id": 42874}
{"snippet": "pandas.api.indexers.FixedForwardWindowIndexer(**kwargs, index_array=None)", "intent": "Creates window boundaries for fixed-length windows that include the current row . With arguments `**kwargs`, `index_array`.", "question_id": 42875}
{"snippet": "pandas.api.indexers.FixedForwardWindowIndexer(**kwargs, window_size=0)", "intent": "Creates window boundaries for fixed-length windows that include the current row . With arguments `**kwargs`, `window_size`.", "question_id": 42876}
{"snippet": "pandas.api.indexers.FixedForwardWindowIndexer(**kwargs, index_array=None, window_size=0)", "intent": "Creates window boundaries for fixed-length windows that include the current row . With arguments `**kwargs`, `index_array`, `window_size`.", "question_id": 42877}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds()", "intent": "Computes the bounds of a window .", "question_id": 42878}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(num_values=0)", "intent": "Computes the bounds of a window . With arguments `num_values`.", "question_id": 42879}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(min_periods=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`.", "question_id": 42880}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(center=None)", "intent": "Computes the bounds of a window . With arguments `center`.", "question_id": 42881}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(closed=None)", "intent": "Computes the bounds of a window . With arguments `closed`.", "question_id": 42882}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(num_values=0, min_periods=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `min_periods`.", "question_id": 42883}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(num_values=0, center=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `center`.", "question_id": 42884}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(num_values=0, closed=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `closed`.", "question_id": 42885}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(min_periods=None, center=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`, `center`.", "question_id": 42886}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(min_periods=None, closed=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`, `closed`.", "question_id": 42887}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds()", "intent": "Computes the bounds of a window .", "question_id": 42888}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(num_values=0)", "intent": "Computes the bounds of a window . With arguments `num_values`.", "question_id": 42889}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(min_periods=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`.", "question_id": 42890}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(center=None)", "intent": "Computes the bounds of a window . With arguments `center`.", "question_id": 42891}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(closed=None)", "intent": "Computes the bounds of a window . With arguments `closed`.", "question_id": 42892}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(num_values=0, min_periods=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `min_periods`.", "question_id": 42893}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(num_values=0, center=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `center`.", "question_id": 42894}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(num_values=0, closed=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `closed`.", "question_id": 42895}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(min_periods=None, center=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`, `center`.", "question_id": 42896}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(min_periods=None, closed=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`, `closed`.", "question_id": 42897}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds()", "intent": "Computes the bounds of a window .", "question_id": 42898}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(num_values=0)", "intent": "Computes the bounds of a window . With arguments `num_values`.", "question_id": 42899}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(min_periods=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`.", "question_id": 42900}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(center=None)", "intent": "Computes the bounds of a window . With arguments `center`.", "question_id": 42901}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(closed=None)", "intent": "Computes the bounds of a window . With arguments `closed`.", "question_id": 42902}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(num_values=0, min_periods=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `min_periods`.", "question_id": 42903}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(num_values=0, center=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `center`.", "question_id": 42904}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(num_values=0, closed=None)", "intent": "Computes the bounds of a window . With arguments `num_values`, `closed`.", "question_id": 42905}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(min_periods=None, center=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`, `center`.", "question_id": 42906}
{"snippet": "VariableOffsetWindowIndexer.get_window_bounds(min_periods=None, closed=None)", "intent": "Computes the bounds of a window . With arguments `min_periods`, `closed`.", "question_id": 42907}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`.", "question_id": 42908}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, index_array=None)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`, `index_array`.", "question_id": 42909}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, window_size=0)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`, `window_size`.", "question_id": 42910}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, index=None)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`, `index`.", "question_id": 42911}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, offset=None)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`.", "question_id": 42912}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, index_array=None, window_size=0)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`, `index_array`, `window_size`.", "question_id": 42913}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, index_array=None, index=None)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`, `index_array`, `index`.", "question_id": 42914}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, index_array=None, offset=None)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`, `index_array`.", "question_id": 42915}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, window_size=0, index=None)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`, `window_size`, `index`.", "question_id": 42916}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, window_size=0, offset=None)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`, `window_size`.", "question_id": 42917}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`.", "question_id": 42918}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, index_array=None)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`, `index_array`.", "question_id": 42919}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, window_size=0)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`, `window_size`.", "question_id": 42920}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, index=None)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`, `index`.", "question_id": 42921}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, offset=None)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`.", "question_id": 42922}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, index_array=None, window_size=0)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`, `index_array`, `window_size`.", "question_id": 42923}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, index_array=None, index=None)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`, `index_array`, `index`.", "question_id": 42924}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, index_array=None, offset=None)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`, `index_array`.", "question_id": 42925}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, window_size=0, index=None)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`, `window_size`, `index`.", "question_id": 42926}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, window_size=0, offset=None)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`, `window_size`.", "question_id": 42927}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`.", "question_id": 42928}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, index_array=None)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`, `index_array`.", "question_id": 42929}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, window_size=0)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`, `window_size`.", "question_id": 42930}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, index=None)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`, `index`.", "question_id": 42931}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, offset=None)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`.", "question_id": 42932}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, index_array=None, window_size=0)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`, `index_array`, `window_size`.", "question_id": 42933}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, index_array=None, index=None)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`, `index_array`, `index`.", "question_id": 42934}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, index_array=None, offset=None)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`, `index_array`.", "question_id": 42935}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, window_size=0, index=None)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`, `window_size`, `index`.", "question_id": 42936}
{"snippet": "pandas.api.indexers.VariableOffsetWindowIndexer(**kwargs, window_size=0, offset=None)", "intent": "Calculate window boundaries based on a non-fixed `offset` such as a BusinessDay With arguments `**kwargs`, `window_size`.", "question_id": 42937}
{"snippet": "pandas.api.indexers.check_array_indexer(array, indexer)", "intent": "Check if `indexer` is a valid `array` indexer for array .", "question_id": 42938}
{"snippet": "pandas.api.indexers.check_array_indexer(array, indexer)", "intent": "Check if `indexer` is a valid `array` indexer for array .", "question_id": 42939}
{"snippet": "pandas.api.indexers.check_array_indexer(array, indexer)", "intent": "Check if `indexer` is a valid `array` indexer for array .", "question_id": 42940}
{"snippet": "pandas.api.types.infer_dtype()", "intent": "Efficiently infer the type of a passed val , or list-like array of values .", "question_id": 42941}
{"snippet": "pandas.api.types.infer_dtype()", "intent": "Efficiently infer the type of a passed val , or list-like array of values .", "question_id": 42942}
{"snippet": "pandas.api.types.infer_dtype()", "intent": "Efficiently infer the type of a passed val , or list-like array of values .", "question_id": 42943}
{"snippet": "pandas.api.types.is_bool()", "intent": "Return True if given object is boolean .", "question_id": 42944}
{"snippet": "pandas.api.types.is_bool()", "intent": "Return True if given object is boolean .", "question_id": 42945}
{"snippet": "pandas.api.types.is_bool()", "intent": "Return True if given object is boolean .", "question_id": 42946}
{"snippet": "pandas.api.types.is_bool_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of a boolean dtype . With arguments `arr_or_dtype`.", "question_id": 42947}
{"snippet": "pandas.api.types.is_bool_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of a boolean dtype . With arguments `arr_or_dtype`.", "question_id": 42948}
{"snippet": "pandas.api.types.is_bool_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of a boolean dtype . With arguments `arr_or_dtype`.", "question_id": 42949}
{"snippet": "pandas.api.types.is_categorical(arr)", "intent": "Check whether an array-like is a Categorical instance . With arguments `arr`.", "question_id": 42950}
{"snippet": "pandas.api.types.is_categorical(arr)", "intent": "Check whether an array-like is a Categorical instance . With arguments `arr`.", "question_id": 42951}
{"snippet": "pandas.api.types.is_categorical(arr)", "intent": "Check whether an array-like is a Categorical instance . With arguments `arr`.", "question_id": 42952}
{"snippet": "pandas.api.types.is_categorical_dtype(arr_or_dtype)", "intent": "Check whether an array-like or dtype is of the Categorical dtype . With arguments `arr_or_dtype`.", "question_id": 42953}
{"snippet": "pandas.api.types.is_categorical_dtype(arr_or_dtype)", "intent": "Check whether an array-like or dtype is of the Categorical dtype . With arguments `arr_or_dtype`.", "question_id": 42954}
{"snippet": "pandas.api.types.is_categorical_dtype(arr_or_dtype)", "intent": "Check whether an array-like or dtype is of the Categorical dtype . With arguments `arr_or_dtype`.", "question_id": 42955}
{"snippet": "pandas.api.types.is_complex()", "intent": "Return True if given object is complex .", "question_id": 42956}
{"snippet": "pandas.api.types.is_complex()", "intent": "Return True if given object is complex .", "question_id": 42957}
{"snippet": "pandas.api.types.is_complex()", "intent": "Return True if given object is complex .", "question_id": 42958}
{"snippet": "pandas.api.types.is_complex_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of a complex dtype . With arguments `arr_or_dtype`.", "question_id": 42959}
{"snippet": "pandas.api.types.is_complex_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of a complex dtype . With arguments `arr_or_dtype`.", "question_id": 42960}
{"snippet": "pandas.api.types.is_complex_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of a complex dtype . With arguments `arr_or_dtype`.", "question_id": 42961}
{"snippet": "pandas.api.types.is_datetime64_any_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of the datetime64 dtype . With arguments `arr_or_dtype`.", "question_id": 42962}
{"snippet": "pandas.api.types.is_datetime64_any_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of the datetime64 dtype . With arguments `arr_or_dtype`.", "question_id": 42963}
{"snippet": "pandas.api.types.is_datetime64_any_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of the datetime64 dtype . With arguments `arr_or_dtype`.", "question_id": 42964}
{"snippet": "pandas.api.types.is_datetime64_dtype(arr_or_dtype)", "intent": "Check whether an array-like or dtype is of the datetime64 dtype . With arguments `arr_or_dtype`.", "question_id": 42965}
{"snippet": "pandas.api.types.is_datetime64_dtype(arr_or_dtype)", "intent": "Check whether an array-like or dtype is of the datetime64 dtype . With arguments `arr_or_dtype`.", "question_id": 42966}
{"snippet": "pandas.api.types.is_datetime64_dtype(arr_or_dtype)", "intent": "Check whether an array-like or dtype is of the datetime64 dtype . With arguments `arr_or_dtype`.", "question_id": 42967}
{"snippet": "pandas.api.types.is_datetime64_ns_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of the datetime64 [ ns ] dtype . With arguments `arr_or_dtype`.", "question_id": 42968}
{"snippet": "pandas.api.types.is_datetime64_ns_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of the datetime64 [ ns ] dtype . With arguments `arr_or_dtype`.", "question_id": 42969}
{"snippet": "pandas.api.types.is_datetime64_ns_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of the datetime64 [ ns ] dtype . With arguments `arr_or_dtype`.", "question_id": 42970}
{"snippet": "pandas.api.types.is_datetime64tz_dtype(arr_or_dtype)", "intent": "Check whether an array-like or dtype is of a DatetimeTZDtype dtype . With arguments `arr_or_dtype`.", "question_id": 42971}
{"snippet": "pandas.api.types.is_datetime64tz_dtype(arr_or_dtype)", "intent": "Check whether an array-like or dtype is of a DatetimeTZDtype dtype . With arguments `arr_or_dtype`.", "question_id": 42972}
{"snippet": "pandas.api.types.is_datetime64tz_dtype(arr_or_dtype)", "intent": "Check whether an array-like or dtype is of a DatetimeTZDtype dtype . With arguments `arr_or_dtype`.", "question_id": 42973}
{"snippet": "pandas.api.types.is_dict_like(obj)", "intent": "Check if the object is dict-like . With arguments `obj`.", "question_id": 42974}
{"snippet": "pandas.api.types.is_dict_like(obj)", "intent": "Check if the object is dict-like . With arguments `obj`.", "question_id": 42975}
{"snippet": "pandas.api.types.is_dict_like(obj)", "intent": "Check if the object is dict-like . With arguments `obj`.", "question_id": 42976}
{"snippet": "pandas.api.types.is_extension_array_dtype(arr_or_dtype)", "intent": "Check if an object is a pandas extension array type . With arguments `arr_or_dtype`.", "question_id": 42977}
{"snippet": "pandas.api.types.is_extension_array_dtype(arr_or_dtype)", "intent": "Check if an object is a pandas extension array type . With arguments `arr_or_dtype`.", "question_id": 42978}
{"snippet": "pandas.api.types.is_extension_array_dtype(arr_or_dtype)", "intent": "Check if an object is a pandas extension array type . With arguments `arr_or_dtype`.", "question_id": 42979}
{"snippet": "pandas.api.types.is_extension_type(arr)", "intent": "Check whether an array-like is of a pandas extension class instance . With arguments `arr`.", "question_id": 42980}
{"snippet": "pandas.api.types.is_extension_type(arr)", "intent": "Check whether an array-like is of a pandas extension class instance . With arguments `arr`.", "question_id": 42981}
{"snippet": "pandas.api.types.is_extension_type(arr)", "intent": "Check whether an array-like is of a pandas extension class instance . With arguments `arr`.", "question_id": 42982}
{"snippet": "pandas.api.types.is_file_like(obj)", "intent": "Check if the object is a file-like object . With arguments `obj`.", "question_id": 42983}
{"snippet": "pandas.api.types.is_file_like(obj)", "intent": "Check if the object is a file-like object . With arguments `obj`.", "question_id": 42984}
{"snippet": "pandas.api.types.is_file_like(obj)", "intent": "Check if the object is a file-like object . With arguments `obj`.", "question_id": 42985}
{"snippet": "pandas.api.types.is_float()", "intent": "Return True if given object is float .", "question_id": 42986}
{"snippet": "pandas.api.types.is_float()", "intent": "Return True if given object is float .", "question_id": 42987}
{"snippet": "pandas.api.types.is_float()", "intent": "Return True if given object is float .", "question_id": 42988}
{"snippet": "pandas.api.types.is_float_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of a float dtype . With arguments `arr_or_dtype`.", "question_id": 42989}
{"snippet": "pandas.api.types.is_float_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of a float dtype . With arguments `arr_or_dtype`.", "question_id": 42990}
{"snippet": "pandas.api.types.is_float_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of a float dtype . With arguments `arr_or_dtype`.", "question_id": 42991}
{"snippet": "pandas.api.types.is_hashable(obj)", "intent": "Return True if hash ( `obj` ) will succeed , False otherwise .", "question_id": 42992}
{"snippet": "pandas.api.types.is_hashable(obj)", "intent": "Return True if hash ( `obj` ) will succeed , False otherwise .", "question_id": 42993}
{"snippet": "pandas.api.types.is_hashable(obj)", "intent": "Return True if hash ( `obj` ) will succeed , False otherwise .", "question_id": 42994}
{"snippet": "pandas.api.types.is_int64_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of the int64 dtype . With arguments `arr_or_dtype`.", "question_id": 42995}
{"snippet": "pandas.api.types.is_int64_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of the int64 dtype . With arguments `arr_or_dtype`.", "question_id": 42996}
{"snippet": "pandas.api.types.is_int64_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of the int64 dtype . With arguments `arr_or_dtype`.", "question_id": 42997}
{"snippet": "pandas.api.types.is_integer()", "intent": "Return True if given object is integer .", "question_id": 42998}
{"snippet": "pandas.api.types.is_integer()", "intent": "Return True if given object is integer .", "question_id": 42999}
{"snippet": "pandas.api.types.is_integer()", "intent": "Return True if given object is integer .", "question_id": 43000}
{"snippet": "pandas.api.types.is_integer_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of an integer dtype . With arguments `arr_or_dtype`.", "question_id": 43001}
{"snippet": "pandas.api.types.is_integer_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of an integer dtype . With arguments `arr_or_dtype`.", "question_id": 43002}
{"snippet": "pandas.api.types.is_integer_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of an integer dtype . With arguments `arr_or_dtype`.", "question_id": 43003}
{"snippet": "pandas.api.types.is_interval_dtype(arr_or_dtype)", "intent": "Check whether an array-like or dtype is of the Interval dtype . With arguments `arr_or_dtype`.", "question_id": 43004}
{"snippet": "pandas.api.types.is_interval_dtype(arr_or_dtype)", "intent": "Check whether an array-like or dtype is of the Interval dtype . With arguments `arr_or_dtype`.", "question_id": 43005}
{"snippet": "pandas.api.types.is_interval_dtype(arr_or_dtype)", "intent": "Check whether an array-like or dtype is of the Interval dtype . With arguments `arr_or_dtype`.", "question_id": 43006}
{"snippet": "pandas.api.types.is_iterator()", "intent": "Check if the object is an iterator .", "question_id": 43007}
{"snippet": "pandas.api.types.is_iterator()", "intent": "Check if the object is an iterator .", "question_id": 43008}
{"snippet": "pandas.api.types.is_iterator()", "intent": "Check if the object is an iterator .", "question_id": 43009}
{"snippet": "pandas.api.types.is_list_like()", "intent": "Check if the object is list-like .", "question_id": 43010}
{"snippet": "pandas.api.types.is_list_like()", "intent": "Check if the object is list-like .", "question_id": 43011}
{"snippet": "pandas.api.types.is_list_like()", "intent": "Check if the object is list-like .", "question_id": 43012}
{"snippet": "pandas.api.types.is_named_tuple(obj)", "intent": "Check if the object is a named tuple . With arguments `obj`.", "question_id": 43013}
{"snippet": "pandas.api.types.is_named_tuple(obj)", "intent": "Check if the object is a named tuple . With arguments `obj`.", "question_id": 43014}
{"snippet": "pandas.api.types.is_named_tuple(obj)", "intent": "Check if the object is a named tuple . With arguments `obj`.", "question_id": 43015}
{"snippet": "pandas.api.types.is_number(obj)", "intent": "Check if the object is a number . With arguments `obj`.", "question_id": 43016}
{"snippet": "pandas.api.types.is_number(obj)", "intent": "Check if the object is a number . With arguments `obj`.", "question_id": 43017}
{"snippet": "pandas.api.types.is_number(obj)", "intent": "Check if the object is a number . With arguments `obj`.", "question_id": 43018}
{"snippet": "pandas.api.types.is_numeric_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of a numeric dtype . With arguments `arr_or_dtype`.", "question_id": 43019}
{"snippet": "pandas.api.types.is_numeric_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of a numeric dtype . With arguments `arr_or_dtype`.", "question_id": 43020}
{"snippet": "pandas.api.types.is_numeric_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of a numeric dtype . With arguments `arr_or_dtype`.", "question_id": 43021}
{"snippet": "pandas.api.types.is_object_dtype(arr_or_dtype)", "intent": "Check whether an array-like or dtype is of the object dtype . With arguments `arr_or_dtype`.", "question_id": 43022}
{"snippet": "pandas.api.types.is_object_dtype(arr_or_dtype)", "intent": "Check whether an array-like or dtype is of the object dtype . With arguments `arr_or_dtype`.", "question_id": 43023}
{"snippet": "pandas.api.types.is_object_dtype(arr_or_dtype)", "intent": "Check whether an array-like or dtype is of the object dtype . With arguments `arr_or_dtype`.", "question_id": 43024}
{"snippet": "pandas.api.types.is_period_dtype(arr_or_dtype)", "intent": "Check whether an array-like or dtype is of the Period dtype . With arguments `arr_or_dtype`.", "question_id": 43025}
{"snippet": "pandas.api.types.is_period_dtype(arr_or_dtype)", "intent": "Check whether an array-like or dtype is of the Period dtype . With arguments `arr_or_dtype`.", "question_id": 43026}
{"snippet": "pandas.api.types.is_period_dtype(arr_or_dtype)", "intent": "Check whether an array-like or dtype is of the Period dtype . With arguments `arr_or_dtype`.", "question_id": 43027}
{"snippet": "pandas.api.types.is_re(obj)", "intent": "Check if the object is a regex pattern instance . With arguments `obj`.", "question_id": 43028}
{"snippet": "pandas.api.types.is_re(obj)", "intent": "Check if the object is a regex pattern instance . With arguments `obj`.", "question_id": 43029}
{"snippet": "pandas.api.types.is_re(obj)", "intent": "Check if the object is a regex pattern instance . With arguments `obj`.", "question_id": 43030}
{"snippet": "pandas.api.types.is_re_compilable(obj)", "intent": "Check if the object can be compiled into a regex pattern instance . With arguments `obj`.", "question_id": 43031}
{"snippet": "pandas.api.types.is_re_compilable(obj)", "intent": "Check if the object can be compiled into a regex pattern instance . With arguments `obj`.", "question_id": 43032}
{"snippet": "pandas.api.types.is_re_compilable(obj)", "intent": "Check if the object can be compiled into a regex pattern instance . With arguments `obj`.", "question_id": 43033}
{"snippet": "pandas.api.types.is_scalar()", "intent": "Return True if given object is scalar .", "question_id": 43034}
{"snippet": "pandas.api.types.is_scalar()", "intent": "Return True if given object is scalar .", "question_id": 43035}
{"snippet": "pandas.api.types.is_scalar()", "intent": "Return True if given object is scalar .", "question_id": 43036}
{"snippet": "pandas.api.types.is_signed_integer_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of a signed integer dtype . With arguments `arr_or_dtype`.", "question_id": 43037}
{"snippet": "pandas.api.types.is_signed_integer_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of a signed integer dtype . With arguments `arr_or_dtype`.", "question_id": 43038}
{"snippet": "pandas.api.types.is_signed_integer_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of a signed integer dtype . With arguments `arr_or_dtype`.", "question_id": 43039}
{"snippet": "pandas.api.types.is_sparse(arr)", "intent": "Check whether an array-like is a 1-D pandas sparse array . With arguments `arr`.", "question_id": 43040}
{"snippet": "pandas.api.types.is_sparse(arr)", "intent": "Check whether an array-like is a 1-D pandas sparse array . With arguments `arr`.", "question_id": 43041}
{"snippet": "pandas.api.types.is_sparse(arr)", "intent": "Check whether an array-like is a 1-D pandas sparse array . With arguments `arr`.", "question_id": 43042}
{"snippet": "pandas.api.types.is_string_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of the string dtype . With arguments `arr_or_dtype`.", "question_id": 43043}
{"snippet": "pandas.api.types.is_string_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of the string dtype . With arguments `arr_or_dtype`.", "question_id": 43044}
{"snippet": "pandas.api.types.is_string_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of the string dtype . With arguments `arr_or_dtype`.", "question_id": 43045}
{"snippet": "pandas.api.types.is_timedelta64_dtype(arr_or_dtype)", "intent": "Check whether an array-like or dtype is of the timedelta64 dtype . With arguments `arr_or_dtype`.", "question_id": 43046}
{"snippet": "pandas.api.types.is_timedelta64_dtype(arr_or_dtype)", "intent": "Check whether an array-like or dtype is of the timedelta64 dtype . With arguments `arr_or_dtype`.", "question_id": 43047}
{"snippet": "pandas.api.types.is_timedelta64_dtype(arr_or_dtype)", "intent": "Check whether an array-like or dtype is of the timedelta64 dtype . With arguments `arr_or_dtype`.", "question_id": 43048}
{"snippet": "pandas.api.types.is_timedelta64_ns_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of the timedelta64 [ ns ] dtype . With arguments `arr_or_dtype`.", "question_id": 43049}
{"snippet": "pandas.api.types.is_timedelta64_ns_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of the timedelta64 [ ns ] dtype . With arguments `arr_or_dtype`.", "question_id": 43050}
{"snippet": "pandas.api.types.is_timedelta64_ns_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of the timedelta64 [ ns ] dtype . With arguments `arr_or_dtype`.", "question_id": 43051}
{"snippet": "pandas.api.types.is_unsigned_integer_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of an unsigned integer dtype . With arguments `arr_or_dtype`.", "question_id": 43052}
{"snippet": "pandas.api.types.is_unsigned_integer_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of an unsigned integer dtype . With arguments `arr_or_dtype`.", "question_id": 43053}
{"snippet": "pandas.api.types.is_unsigned_integer_dtype(arr_or_dtype)", "intent": "Check whether the provided array or dtype is of an unsigned integer dtype . With arguments `arr_or_dtype`.", "question_id": 43054}
{"snippet": "pandas.api.types.pandas_dtype(dtype)", "intent": "Convert input into a pandas only `dtype` object or a numpy dtype object .", "question_id": 43055}
{"snippet": "pandas.api.types.pandas_dtype(dtype)", "intent": "Convert input into a pandas only `dtype` object or a numpy dtype object .", "question_id": 43056}
{"snippet": "pandas.api.types.pandas_dtype(dtype)", "intent": "Convert input into a pandas only `dtype` object or a numpy dtype object .", "question_id": 43057}
{"snippet": "pandas.api.types.union_categoricals(to_union)", "intent": "Combine list-like of Categorical-like , unioning categories . With arguments `to_union`.", "question_id": 43058}
{"snippet": "pandas.api.types.union_categoricals(to_union, sort_categories=False)", "intent": "Combine list-like of Categorical-like , unioning categories . With arguments `to_union`, `sort_categories`.", "question_id": 43059}
{"snippet": "pandas.api.types.union_categoricals(to_union, ignore_order=False)", "intent": "Combine list-like of Categorical-like , unioning categories . With arguments `to_union`, `ignore_order`.", "question_id": 43060}
{"snippet": "pandas.api.types.union_categoricals(to_union, sort_categories=False, ignore_order=False)", "intent": "Combine list-like of Categorical-like , unioning categories . With arguments `to_union`, `sort_categories`, `ignore_order`.", "question_id": 43061}
{"snippet": "pandas.api.types.union_categoricals(to_union)", "intent": "Combine list-like of Categorical-like , unioning categories . With arguments `to_union`.", "question_id": 43062}
{"snippet": "pandas.api.types.union_categoricals(to_union, sort_categories=False)", "intent": "Combine list-like of Categorical-like , unioning categories . With arguments `to_union`, `sort_categories`.", "question_id": 43063}
{"snippet": "pandas.api.types.union_categoricals(to_union, ignore_order=False)", "intent": "Combine list-like of Categorical-like , unioning categories . With arguments `to_union`, `ignore_order`.", "question_id": 43064}
{"snippet": "pandas.api.types.union_categoricals(to_union, sort_categories=False, ignore_order=False)", "intent": "Combine list-like of Categorical-like , unioning categories . With arguments `to_union`, `sort_categories`, `ignore_order`.", "question_id": 43065}
{"snippet": "pandas.api.types.union_categoricals(to_union)", "intent": "Combine list-like of Categorical-like , unioning categories . With arguments `to_union`.", "question_id": 43066}
{"snippet": "pandas.api.types.union_categoricals(to_union, sort_categories=False)", "intent": "Combine list-like of Categorical-like , unioning categories . With arguments `to_union`, `sort_categories`.", "question_id": 43067}
{"snippet": "pandas.api.types.union_categoricals(to_union, ignore_order=False)", "intent": "Combine list-like of Categorical-like , unioning categories . With arguments `to_union`, `ignore_order`.", "question_id": 43068}
{"snippet": "pandas.api.types.union_categoricals(to_union, sort_categories=False, ignore_order=False)", "intent": "Combine list-like of Categorical-like , unioning categories . With arguments `to_union`, `sort_categories`, `ignore_order`.", "question_id": 43069}
{"snippet": "pandas.array(data)", "intent": "Create an array . Omitting the `dtype` argument means pandas will attempt to infer the best array type from the values in the `data` .", "question_id": 43070}
{"snippet": "pandas.array(data, dtype=None)", "intent": "Create an array . Omitting the `dtype` argument means pandas will attempt to infer the best array type from the values in the `data` .", "question_id": 43071}
{"snippet": "pandas.array(data, copy=True)", "intent": "Create an array . Omitting the `dtype` argument means pandas will attempt to infer the best array type from the values in the `data` . With arguments `copy`.", "question_id": 43072}
{"snippet": "pandas.array(data, dtype=None, copy=True)", "intent": "Create an array . Omitting the `dtype` argument means pandas will attempt to infer the best array type from the values in the `data` . With arguments `copy`.", "question_id": 43073}
{"snippet": "pandas.array(data)", "intent": "Create an array . Omitting the `dtype` argument means pandas will attempt to infer the best array type from the values in the `data` .", "question_id": 43074}
{"snippet": "pandas.array(data, dtype=None)", "intent": "Create an array . Omitting the `dtype` argument means pandas will attempt to infer the best array type from the values in the `data` .", "question_id": 43075}
{"snippet": "pandas.array(data, copy=True)", "intent": "Create an array . Omitting the `dtype` argument means pandas will attempt to infer the best array type from the values in the `data` . With arguments `copy`.", "question_id": 43076}
{"snippet": "pandas.array(data, dtype=None, copy=True)", "intent": "Create an array . Omitting the `dtype` argument means pandas will attempt to infer the best array type from the values in the `data` . With arguments `copy`.", "question_id": 43077}
{"snippet": "pandas.array(data)", "intent": "Create an array . Omitting the `dtype` argument means pandas will attempt to infer the best array type from the values in the `data` .", "question_id": 43078}
{"snippet": "pandas.array(data, dtype=None)", "intent": "Create an array . Omitting the `dtype` argument means pandas will attempt to infer the best array type from the values in the `data` .", "question_id": 43079}
{"snippet": "pandas.array(data, copy=True)", "intent": "Create an array . Omitting the `dtype` argument means pandas will attempt to infer the best array type from the values in the `data` . With arguments `copy`.", "question_id": 43080}
{"snippet": "pandas.array(data, dtype=None, copy=True)", "intent": "Create an array . Omitting the `dtype` argument means pandas will attempt to infer the best array type from the values in the `data` . With arguments `copy`.", "question_id": 43081}
{"snippet": "pandas.arrays.ArrowStringArray(values)", "intent": "Extension array for string data in a pyarrow.ChunkedArray . With arguments `values`.", "question_id": 43082}
{"snippet": "pandas.arrays.ArrowStringArray(values)", "intent": "Extension array for string data in a pyarrow.ChunkedArray . With arguments `values`.", "question_id": 43083}
{"snippet": "pandas.arrays.ArrowStringArray(values)", "intent": "Extension array for string data in a pyarrow.ChunkedArray . With arguments `values`.", "question_id": 43084}
{"snippet": "pandas.arrays.BooleanArray(values, mask)", "intent": "Array of boolean ( True/False ) data with missing `values` . This is a pandas Extension array for boolean data , under the hood represented by 2 numpy arrays : a boolean array with the data and a boolean array with the `mask` ( True indicating missing ) .", "question_id": 43085}
{"snippet": "pandas.arrays.BooleanArray(values, mask, copy=False)", "intent": "Array of boolean ( True/False ) data with missing `values` . This is a pandas Extension array for boolean data , under the hood represented by 2 numpy arrays : a boolean array with the data and a boolean array with the `mask` ( True indicating missing ) . With arguments `copy`.", "question_id": 43086}
{"snippet": "pandas.arrays.BooleanArray(values, mask)", "intent": "Array of boolean ( True/False ) data with missing `values` . This is a pandas Extension array for boolean data , under the hood represented by 2 numpy arrays : a boolean array with the data and a boolean array with the `mask` ( True indicating missing ) .", "question_id": 43087}
{"snippet": "pandas.arrays.BooleanArray(values, mask, copy=False)", "intent": "Array of boolean ( True/False ) data with missing `values` . This is a pandas Extension array for boolean data , under the hood represented by 2 numpy arrays : a boolean array with the data and a boolean array with the `mask` ( True indicating missing ) . With arguments `copy`.", "question_id": 43088}
{"snippet": "pandas.arrays.BooleanArray(values, mask)", "intent": "Array of boolean ( True/False ) data with missing `values` . This is a pandas Extension array for boolean data , under the hood represented by 2 numpy arrays : a boolean array with the data and a boolean array with the `mask` ( True indicating missing ) .", "question_id": 43089}
{"snippet": "pandas.arrays.BooleanArray(values, mask, copy=False)", "intent": "Array of boolean ( True/False ) data with missing `values` . This is a pandas Extension array for boolean data , under the hood represented by 2 numpy arrays : a boolean array with the data and a boolean array with the `mask` ( True indicating missing ) . With arguments `copy`.", "question_id": 43090}
{"snippet": "pandas.arrays.DatetimeArray(values)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `values`.", "question_id": 43091}
{"snippet": "pandas.arrays.DatetimeArray(values, dtype=dtype('<M8ns'))", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `values`, `dtype`.", "question_id": 43092}
{"snippet": "pandas.arrays.DatetimeArray(values, freq=None)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `values`, `freq`.", "question_id": 43093}
{"snippet": "pandas.arrays.DatetimeArray(values, copy=False)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `values`, `copy`.", "question_id": 43094}
{"snippet": "pandas.arrays.DatetimeArray(values, dtype=dtype('<M8ns'), freq=None)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `values`, `dtype`, `freq`.", "question_id": 43095}
{"snippet": "pandas.arrays.DatetimeArray(values, dtype=dtype('<M8ns'), copy=False)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `values`, `dtype`, `copy`.", "question_id": 43096}
{"snippet": "pandas.arrays.DatetimeArray(values, freq=None, copy=False)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `values`, `freq`, `copy`.", "question_id": 43097}
{"snippet": "pandas.arrays.DatetimeArray(values, dtype=dtype('<M8ns'), freq=None, copy=False)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `values`, `dtype`, `freq`, `copy`.", "question_id": 43098}
{"snippet": "pandas.arrays.DatetimeArray()", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data .", "question_id": 43099}
{"snippet": "pandas.arrays.DatetimeArray(dtype=dtype('<M8ns'))", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `dtype`.", "question_id": 43100}
{"snippet": "pandas.arrays.DatetimeArray(freq=None)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `freq`.", "question_id": 43101}
{"snippet": "pandas.arrays.DatetimeArray(copy=False)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `copy`.", "question_id": 43102}
{"snippet": "pandas.arrays.DatetimeArray(dtype=dtype('<M8ns'), freq=None)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `dtype`, `freq`.", "question_id": 43103}
{"snippet": "pandas.arrays.DatetimeArray(dtype=dtype('<M8ns'), copy=False)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `dtype`, `copy`.", "question_id": 43104}
{"snippet": "pandas.arrays.DatetimeArray(freq=None, copy=False)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `freq`, `copy`.", "question_id": 43105}
{"snippet": "pandas.arrays.DatetimeArray(dtype=dtype('<M8ns'), freq=None, copy=False)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `dtype`, `freq`, `copy`.", "question_id": 43106}
{"snippet": "pandas.arrays.DatetimeArray(values)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `values`.", "question_id": 43107}
{"snippet": "pandas.arrays.DatetimeArray(values, dtype=dtype('<M8ns'))", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `values`, `dtype`.", "question_id": 43108}
{"snippet": "pandas.arrays.DatetimeArray(values, freq=None)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `values`, `freq`.", "question_id": 43109}
{"snippet": "pandas.arrays.DatetimeArray(values, copy=False)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `values`, `copy`.", "question_id": 43110}
{"snippet": "pandas.arrays.DatetimeArray(values, dtype=dtype('<M8ns'), freq=None)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `values`, `dtype`, `freq`.", "question_id": 43111}
{"snippet": "pandas.arrays.DatetimeArray(values, dtype=dtype('<M8ns'), copy=False)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `values`, `dtype`, `copy`.", "question_id": 43112}
{"snippet": "pandas.arrays.DatetimeArray(values, freq=None, copy=False)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `values`, `freq`, `copy`.", "question_id": 43113}
{"snippet": "pandas.arrays.DatetimeArray(values, dtype=dtype('<M8ns'), freq=None, copy=False)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `values`, `dtype`, `freq`, `copy`.", "question_id": 43114}
{"snippet": "pandas.arrays.DatetimeArray()", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data .", "question_id": 43115}
{"snippet": "pandas.arrays.DatetimeArray(dtype=dtype('<M8ns'))", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `dtype`.", "question_id": 43116}
{"snippet": "pandas.arrays.DatetimeArray(freq=None)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `freq`.", "question_id": 43117}
{"snippet": "pandas.arrays.DatetimeArray(copy=False)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `copy`.", "question_id": 43118}
{"snippet": "pandas.arrays.DatetimeArray(dtype=dtype('<M8ns'), freq=None)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `dtype`, `freq`.", "question_id": 43119}
{"snippet": "pandas.arrays.DatetimeArray(dtype=dtype('<M8ns'), copy=False)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `dtype`, `copy`.", "question_id": 43120}
{"snippet": "pandas.arrays.DatetimeArray(freq=None, copy=False)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `freq`, `copy`.", "question_id": 43121}
{"snippet": "pandas.arrays.DatetimeArray(dtype=dtype('<M8ns'), freq=None, copy=False)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `dtype`, `freq`, `copy`.", "question_id": 43122}
{"snippet": "pandas.arrays.DatetimeArray(values)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `values`.", "question_id": 43123}
{"snippet": "pandas.arrays.DatetimeArray(values, dtype=dtype('<M8ns'))", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `values`, `dtype`.", "question_id": 43124}
{"snippet": "pandas.arrays.DatetimeArray(values, freq=None)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `values`, `freq`.", "question_id": 43125}
{"snippet": "pandas.arrays.DatetimeArray(values, copy=False)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `values`, `copy`.", "question_id": 43126}
{"snippet": "pandas.arrays.DatetimeArray(values, dtype=dtype('<M8ns'), freq=None)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `values`, `dtype`, `freq`.", "question_id": 43127}
{"snippet": "pandas.arrays.DatetimeArray(values, dtype=dtype('<M8ns'), copy=False)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `values`, `dtype`, `copy`.", "question_id": 43128}
{"snippet": "pandas.arrays.DatetimeArray(values, freq=None, copy=False)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `values`, `freq`, `copy`.", "question_id": 43129}
{"snippet": "pandas.arrays.DatetimeArray(values, dtype=dtype('<M8ns'), freq=None, copy=False)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `values`, `dtype`, `freq`, `copy`.", "question_id": 43130}
{"snippet": "pandas.arrays.DatetimeArray()", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data .", "question_id": 43131}
{"snippet": "pandas.arrays.DatetimeArray(dtype=dtype('<M8ns'))", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `dtype`.", "question_id": 43132}
{"snippet": "pandas.arrays.DatetimeArray(freq=None)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `freq`.", "question_id": 43133}
{"snippet": "pandas.arrays.DatetimeArray(copy=False)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `copy`.", "question_id": 43134}
{"snippet": "pandas.arrays.DatetimeArray(dtype=dtype('<M8ns'), freq=None)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `dtype`, `freq`.", "question_id": 43135}
{"snippet": "pandas.arrays.DatetimeArray(dtype=dtype('<M8ns'), copy=False)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `dtype`, `copy`.", "question_id": 43136}
{"snippet": "pandas.arrays.DatetimeArray(freq=None, copy=False)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `freq`, `copy`.", "question_id": 43137}
{"snippet": "pandas.arrays.DatetimeArray(dtype=dtype('<M8ns'), freq=None, copy=False)", "intent": "Pandas ExtensionArray for tz-naive or tz-aware datetime data . With arguments `dtype`, `freq`, `copy`.", "question_id": 43138}
{"snippet": "pandas.arrays.IntegerArray(values, mask)", "intent": "Array of integer ( optional missing ) `values` . With arguments `mask`.", "question_id": 43139}
{"snippet": "pandas.arrays.IntegerArray(values, mask, copy=False)", "intent": "Array of integer ( optional missing ) `values` . With arguments `mask`, `copy`.", "question_id": 43140}
{"snippet": "pandas.arrays.IntegerArray(values, mask)", "intent": "Array of integer ( optional missing ) `values` . With arguments `mask`.", "question_id": 43141}
{"snippet": "pandas.arrays.IntegerArray(values, mask, copy=False)", "intent": "Array of integer ( optional missing ) `values` . With arguments `mask`, `copy`.", "question_id": 43142}
{"snippet": "pandas.arrays.IntegerArray(values, mask)", "intent": "Array of integer ( optional missing ) `values` . With arguments `mask`.", "question_id": 43143}
{"snippet": "pandas.arrays.IntegerArray(values, mask, copy=False)", "intent": "Array of integer ( optional missing ) `values` . With arguments `mask`, `copy`.", "question_id": 43144}
{"snippet": "IntervalArray.contains(other)", "intent": "Check elementwise if the Intervals contain the value . With arguments `other`.", "question_id": 43145}
{"snippet": "IntervalArray.contains(other)", "intent": "Check elementwise if the Intervals contain the value . With arguments `other`.", "question_id": 43146}
{"snippet": "IntervalArray.contains(other)", "intent": "Check elementwise if the Intervals contain the value . With arguments `other`.", "question_id": 43147}
{"snippet": "IntervalArray.from_arrays(left, right)", "intent": "Construct from two arrays defining the `left` and `right` bounds .", "question_id": 43148}
{"snippet": "IntervalArray.from_arrays(left, right, closed='right')", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `closed`.", "question_id": 43149}
{"snippet": "IntervalArray.from_arrays(left, right, copy=False)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `copy`.", "question_id": 43150}
{"snippet": "IntervalArray.from_arrays(left, right, dtype=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `dtype`.", "question_id": 43151}
{"snippet": "IntervalArray.from_arrays(left, right, closed='right', copy=False)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `closed`, `copy`.", "question_id": 43152}
{"snippet": "IntervalArray.from_arrays(left, right, closed='right', dtype=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `closed`, `dtype`.", "question_id": 43153}
{"snippet": "IntervalArray.from_arrays(left, right, copy=False, dtype=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `copy`, `dtype`.", "question_id": 43154}
{"snippet": "IntervalArray.from_arrays(left, right, closed='right', copy=False, dtype=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `closed`, `copy`, `dtype`.", "question_id": 43155}
{"snippet": "IntervalArray.from_arrays(left, right)", "intent": "Construct from two arrays defining the `left` and `right` bounds .", "question_id": 43156}
{"snippet": "IntervalArray.from_arrays(left, right, closed='right')", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `closed`.", "question_id": 43157}
{"snippet": "IntervalArray.from_arrays(left, right, copy=False)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `copy`.", "question_id": 43158}
{"snippet": "IntervalArray.from_arrays(left, right, dtype=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `dtype`.", "question_id": 43159}
{"snippet": "IntervalArray.from_arrays(left, right, closed='right', copy=False)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `closed`, `copy`.", "question_id": 43160}
{"snippet": "IntervalArray.from_arrays(left, right, closed='right', dtype=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `closed`, `dtype`.", "question_id": 43161}
{"snippet": "IntervalArray.from_arrays(left, right, copy=False, dtype=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `copy`, `dtype`.", "question_id": 43162}
{"snippet": "IntervalArray.from_arrays(left, right, closed='right', copy=False, dtype=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `closed`, `copy`, `dtype`.", "question_id": 43163}
{"snippet": "IntervalArray.from_arrays(left, right)", "intent": "Construct from two arrays defining the `left` and `right` bounds .", "question_id": 43164}
{"snippet": "IntervalArray.from_arrays(left, right, closed='right')", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `closed`.", "question_id": 43165}
{"snippet": "IntervalArray.from_arrays(left, right, copy=False)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `copy`.", "question_id": 43166}
{"snippet": "IntervalArray.from_arrays(left, right, dtype=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `dtype`.", "question_id": 43167}
{"snippet": "IntervalArray.from_arrays(left, right, closed='right', copy=False)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `closed`, `copy`.", "question_id": 43168}
{"snippet": "IntervalArray.from_arrays(left, right, closed='right', dtype=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `closed`, `dtype`.", "question_id": 43169}
{"snippet": "IntervalArray.from_arrays(left, right, copy=False, dtype=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `copy`, `dtype`.", "question_id": 43170}
{"snippet": "IntervalArray.from_arrays(left, right, closed='right', copy=False, dtype=None)", "intent": "Construct from two arrays defining the `left` and `right` bounds . With arguments `closed`, `copy`, `dtype`.", "question_id": 43171}
{"snippet": "IntervalArray.from_breaks(breaks)", "intent": "Construct an IntervalArray from an array of splits . With arguments `breaks`.", "question_id": 43172}
{"snippet": "IntervalArray.from_breaks(breaks, closed='right')", "intent": "Construct an IntervalArray from an array of splits . With arguments `breaks`, `closed`.", "question_id": 43173}
{"snippet": "IntervalArray.from_breaks(breaks, copy=False)", "intent": "Construct an IntervalArray from an array of splits . With arguments `breaks`, `copy`.", "question_id": 43174}
{"snippet": "IntervalArray.from_breaks(breaks, dtype=None)", "intent": "Construct an IntervalArray from an array of splits . With arguments `breaks`, `dtype`.", "question_id": 43175}
{"snippet": "IntervalArray.from_breaks(breaks, closed='right', copy=False)", "intent": "Construct an IntervalArray from an array of splits . With arguments `breaks`, `closed`, `copy`.", "question_id": 43176}
{"snippet": "IntervalArray.from_breaks(breaks, closed='right', dtype=None)", "intent": "Construct an IntervalArray from an array of splits . With arguments `breaks`, `closed`, `dtype`.", "question_id": 43177}
{"snippet": "IntervalArray.from_breaks(breaks, copy=False, dtype=None)", "intent": "Construct an IntervalArray from an array of splits . With arguments `breaks`, `copy`, `dtype`.", "question_id": 43178}
{"snippet": "IntervalArray.from_breaks(breaks, closed='right', copy=False, dtype=None)", "intent": "Construct an IntervalArray from an array of splits . With arguments `breaks`, `closed`, `copy`, `dtype`.", "question_id": 43179}
{"snippet": "IntervalArray.from_breaks(breaks)", "intent": "Construct an IntervalArray from an array of splits . With arguments `breaks`.", "question_id": 43180}
{"snippet": "IntervalArray.from_breaks(breaks, closed='right')", "intent": "Construct an IntervalArray from an array of splits . With arguments `breaks`, `closed`.", "question_id": 43181}
{"snippet": "IntervalArray.from_breaks(breaks, copy=False)", "intent": "Construct an IntervalArray from an array of splits . With arguments `breaks`, `copy`.", "question_id": 43182}
{"snippet": "IntervalArray.from_breaks(breaks, dtype=None)", "intent": "Construct an IntervalArray from an array of splits . With arguments `breaks`, `dtype`.", "question_id": 43183}
{"snippet": "IntervalArray.from_breaks(breaks, closed='right', copy=False)", "intent": "Construct an IntervalArray from an array of splits . With arguments `breaks`, `closed`, `copy`.", "question_id": 43184}
{"snippet": "IntervalArray.from_breaks(breaks, closed='right', dtype=None)", "intent": "Construct an IntervalArray from an array of splits . With arguments `breaks`, `closed`, `dtype`.", "question_id": 43185}
{"snippet": "IntervalArray.from_breaks(breaks, copy=False, dtype=None)", "intent": "Construct an IntervalArray from an array of splits . With arguments `breaks`, `copy`, `dtype`.", "question_id": 43186}
{"snippet": "IntervalArray.from_breaks(breaks, closed='right', copy=False, dtype=None)", "intent": "Construct an IntervalArray from an array of splits . With arguments `breaks`, `closed`, `copy`, `dtype`.", "question_id": 43187}
{"snippet": "IntervalArray.from_breaks(breaks)", "intent": "Construct an IntervalArray from an array of splits . With arguments `breaks`.", "question_id": 43188}
{"snippet": "IntervalArray.from_breaks(breaks, closed='right')", "intent": "Construct an IntervalArray from an array of splits . With arguments `breaks`, `closed`.", "question_id": 43189}
{"snippet": "IntervalArray.from_breaks(breaks, copy=False)", "intent": "Construct an IntervalArray from an array of splits . With arguments `breaks`, `copy`.", "question_id": 43190}
{"snippet": "IntervalArray.from_breaks(breaks, dtype=None)", "intent": "Construct an IntervalArray from an array of splits . With arguments `breaks`, `dtype`.", "question_id": 43191}
{"snippet": "IntervalArray.from_breaks(breaks, closed='right', copy=False)", "intent": "Construct an IntervalArray from an array of splits . With arguments `breaks`, `closed`, `copy`.", "question_id": 43192}
{"snippet": "IntervalArray.from_breaks(breaks, closed='right', dtype=None)", "intent": "Construct an IntervalArray from an array of splits . With arguments `breaks`, `closed`, `dtype`.", "question_id": 43193}
{"snippet": "IntervalArray.from_breaks(breaks, copy=False, dtype=None)", "intent": "Construct an IntervalArray from an array of splits . With arguments `breaks`, `copy`, `dtype`.", "question_id": 43194}
{"snippet": "IntervalArray.from_breaks(breaks, closed='right', copy=False, dtype=None)", "intent": "Construct an IntervalArray from an array of splits . With arguments `breaks`, `closed`, `copy`, `dtype`.", "question_id": 43195}
{"snippet": "IntervalArray.from_tuples(data)", "intent": "Construct an IntervalArray from an array-like of tuples . With arguments `data`.", "question_id": 43196}
{"snippet": "IntervalArray.from_tuples(data, closed='right')", "intent": "Construct an IntervalArray from an array-like of tuples . With arguments `data`, `closed`.", "question_id": 43197}
{"snippet": "IntervalArray.from_tuples(data, copy=False)", "intent": "Construct an IntervalArray from an array-like of tuples . With arguments `data`, `copy`.", "question_id": 43198}
{"snippet": "IntervalArray.from_tuples(data, dtype=None)", "intent": "Construct an IntervalArray from an array-like of tuples . With arguments `data`, `dtype`.", "question_id": 43199}
{"snippet": "IntervalArray.from_tuples(data, closed='right', copy=False)", "intent": "Construct an IntervalArray from an array-like of tuples . With arguments `data`, `closed`, `copy`.", "question_id": 43200}
{"snippet": "IntervalArray.from_tuples(data, closed='right', dtype=None)", "intent": "Construct an IntervalArray from an array-like of tuples . With arguments `data`, `closed`, `dtype`.", "question_id": 43201}
{"snippet": "IntervalArray.from_tuples(data, copy=False, dtype=None)", "intent": "Construct an IntervalArray from an array-like of tuples . With arguments `data`, `copy`, `dtype`.", "question_id": 43202}
{"snippet": "IntervalArray.from_tuples(data, closed='right', copy=False, dtype=None)", "intent": "Construct an IntervalArray from an array-like of tuples . With arguments `data`, `closed`, `copy`, `dtype`.", "question_id": 43203}
{"snippet": "IntervalArray.from_tuples(data)", "intent": "Construct an IntervalArray from an array-like of tuples . With arguments `data`.", "question_id": 43204}
{"snippet": "IntervalArray.from_tuples(data, closed='right')", "intent": "Construct an IntervalArray from an array-like of tuples . With arguments `data`, `closed`.", "question_id": 43205}
{"snippet": "IntervalArray.from_tuples(data, copy=False)", "intent": "Construct an IntervalArray from an array-like of tuples . With arguments `data`, `copy`.", "question_id": 43206}
{"snippet": "IntervalArray.from_tuples(data, dtype=None)", "intent": "Construct an IntervalArray from an array-like of tuples . With arguments `data`, `dtype`.", "question_id": 43207}
{"snippet": "IntervalArray.from_tuples(data, closed='right', copy=False)", "intent": "Construct an IntervalArray from an array-like of tuples . With arguments `data`, `closed`, `copy`.", "question_id": 43208}
{"snippet": "IntervalArray.from_tuples(data, closed='right', dtype=None)", "intent": "Construct an IntervalArray from an array-like of tuples . With arguments `data`, `closed`, `dtype`.", "question_id": 43209}
{"snippet": "IntervalArray.from_tuples(data, copy=False, dtype=None)", "intent": "Construct an IntervalArray from an array-like of tuples . With arguments `data`, `copy`, `dtype`.", "question_id": 43210}
{"snippet": "IntervalArray.from_tuples(data, closed='right', copy=False, dtype=None)", "intent": "Construct an IntervalArray from an array-like of tuples . With arguments `data`, `closed`, `copy`, `dtype`.", "question_id": 43211}
{"snippet": "IntervalArray.from_tuples(data)", "intent": "Construct an IntervalArray from an array-like of tuples . With arguments `data`.", "question_id": 43212}
{"snippet": "IntervalArray.from_tuples(data, closed='right')", "intent": "Construct an IntervalArray from an array-like of tuples . With arguments `data`, `closed`.", "question_id": 43213}
{"snippet": "IntervalArray.from_tuples(data, copy=False)", "intent": "Construct an IntervalArray from an array-like of tuples . With arguments `data`, `copy`.", "question_id": 43214}
{"snippet": "IntervalArray.from_tuples(data, dtype=None)", "intent": "Construct an IntervalArray from an array-like of tuples . With arguments `data`, `dtype`.", "question_id": 43215}
{"snippet": "IntervalArray.from_tuples(data, closed='right', copy=False)", "intent": "Construct an IntervalArray from an array-like of tuples . With arguments `data`, `closed`, `copy`.", "question_id": 43216}
{"snippet": "IntervalArray.from_tuples(data, closed='right', dtype=None)", "intent": "Construct an IntervalArray from an array-like of tuples . With arguments `data`, `closed`, `dtype`.", "question_id": 43217}
{"snippet": "IntervalArray.from_tuples(data, copy=False, dtype=None)", "intent": "Construct an IntervalArray from an array-like of tuples . With arguments `data`, `copy`, `dtype`.", "question_id": 43218}
{"snippet": "IntervalArray.from_tuples(data, closed='right', copy=False, dtype=None)", "intent": "Construct an IntervalArray from an array-like of tuples . With arguments `data`, `closed`, `copy`, `dtype`.", "question_id": 43219}
{"snippet": "pandas.arrays.IntervalArray(data)", "intent": "Pandas array for interval `data` that are `closed` on the same side .", "question_id": 43220}
{"snippet": "pandas.arrays.IntervalArray(data, closed=None)", "intent": "Pandas array for interval `data` that are `closed` on the same side .", "question_id": 43221}
{"snippet": "pandas.arrays.IntervalArray(data, dtype=None)", "intent": "Pandas array for interval `data` that are `closed` on the same side . With arguments `dtype`.", "question_id": 43222}
{"snippet": "pandas.arrays.IntervalArray(data, copy=False)", "intent": "Pandas array for interval `data` that are `closed` on the same side . With arguments `copy`.", "question_id": 43223}
{"snippet": "pandas.arrays.IntervalArray(data, verify_integrity=True)", "intent": "Pandas array for interval `data` that are `closed` on the same side . With arguments `verify_integrity`.", "question_id": 43224}
{"snippet": "pandas.arrays.IntervalArray(data, closed=None, dtype=None)", "intent": "Pandas array for interval `data` that are `closed` on the same side . With arguments `dtype`.", "question_id": 43225}
{"snippet": "pandas.arrays.IntervalArray(data, closed=None, copy=False)", "intent": "Pandas array for interval `data` that are `closed` on the same side . With arguments `copy`.", "question_id": 43226}
{"snippet": "pandas.arrays.IntervalArray(data, closed=None, verify_integrity=True)", "intent": "Pandas array for interval `data` that are `closed` on the same side . With arguments `verify_integrity`.", "question_id": 43227}
{"snippet": "pandas.arrays.IntervalArray(data, dtype=None, copy=False)", "intent": "Pandas array for interval `data` that are `closed` on the same side . With arguments `dtype`, `copy`.", "question_id": 43228}
{"snippet": "pandas.arrays.IntervalArray(data, dtype=None, verify_integrity=True)", "intent": "Pandas array for interval `data` that are `closed` on the same side . With arguments `dtype`, `verify_integrity`.", "question_id": 43229}
{"snippet": "pandas.arrays.IntervalArray(data)", "intent": "Pandas array for interval `data` that are `closed` on the same side .", "question_id": 43230}
{"snippet": "pandas.arrays.IntervalArray(data, closed=None)", "intent": "Pandas array for interval `data` that are `closed` on the same side .", "question_id": 43231}
{"snippet": "pandas.arrays.IntervalArray(data, dtype=None)", "intent": "Pandas array for interval `data` that are `closed` on the same side . With arguments `dtype`.", "question_id": 43232}
{"snippet": "pandas.arrays.IntervalArray(data, copy=False)", "intent": "Pandas array for interval `data` that are `closed` on the same side . With arguments `copy`.", "question_id": 43233}
{"snippet": "pandas.arrays.IntervalArray(data, verify_integrity=True)", "intent": "Pandas array for interval `data` that are `closed` on the same side . With arguments `verify_integrity`.", "question_id": 43234}
{"snippet": "pandas.arrays.IntervalArray(data, closed=None, dtype=None)", "intent": "Pandas array for interval `data` that are `closed` on the same side . With arguments `dtype`.", "question_id": 43235}
{"snippet": "pandas.arrays.IntervalArray(data, closed=None, copy=False)", "intent": "Pandas array for interval `data` that are `closed` on the same side . With arguments `copy`.", "question_id": 43236}
{"snippet": "pandas.arrays.IntervalArray(data, closed=None, verify_integrity=True)", "intent": "Pandas array for interval `data` that are `closed` on the same side . With arguments `verify_integrity`.", "question_id": 43237}
{"snippet": "pandas.arrays.IntervalArray(data, dtype=None, copy=False)", "intent": "Pandas array for interval `data` that are `closed` on the same side . With arguments `dtype`, `copy`.", "question_id": 43238}
{"snippet": "pandas.arrays.IntervalArray(data, dtype=None, verify_integrity=True)", "intent": "Pandas array for interval `data` that are `closed` on the same side . With arguments `dtype`, `verify_integrity`.", "question_id": 43239}
{"snippet": "pandas.arrays.IntervalArray(data)", "intent": "Pandas array for interval `data` that are `closed` on the same side .", "question_id": 43240}
{"snippet": "pandas.arrays.IntervalArray(data, closed=None)", "intent": "Pandas array for interval `data` that are `closed` on the same side .", "question_id": 43241}
{"snippet": "pandas.arrays.IntervalArray(data, dtype=None)", "intent": "Pandas array for interval `data` that are `closed` on the same side . With arguments `dtype`.", "question_id": 43242}
{"snippet": "pandas.arrays.IntervalArray(data, copy=False)", "intent": "Pandas array for interval `data` that are `closed` on the same side . With arguments `copy`.", "question_id": 43243}
{"snippet": "pandas.arrays.IntervalArray(data, verify_integrity=True)", "intent": "Pandas array for interval `data` that are `closed` on the same side . With arguments `verify_integrity`.", "question_id": 43244}
{"snippet": "pandas.arrays.IntervalArray(data, closed=None, dtype=None)", "intent": "Pandas array for interval `data` that are `closed` on the same side . With arguments `dtype`.", "question_id": 43245}
{"snippet": "pandas.arrays.IntervalArray(data, closed=None, copy=False)", "intent": "Pandas array for interval `data` that are `closed` on the same side . With arguments `copy`.", "question_id": 43246}
{"snippet": "pandas.arrays.IntervalArray(data, closed=None, verify_integrity=True)", "intent": "Pandas array for interval `data` that are `closed` on the same side . With arguments `verify_integrity`.", "question_id": 43247}
{"snippet": "pandas.arrays.IntervalArray(data, dtype=None, copy=False)", "intent": "Pandas array for interval `data` that are `closed` on the same side . With arguments `dtype`, `copy`.", "question_id": 43248}
{"snippet": "pandas.arrays.IntervalArray(data, dtype=None, verify_integrity=True)", "intent": "Pandas array for interval `data` that are `closed` on the same side . With arguments `dtype`, `verify_integrity`.", "question_id": 43249}
{"snippet": "IntervalArray.is_empty", "intent": "Indicates if an interval is empty, meaning it contains no points.", "question_id": 43250}
{"snippet": "IntervalArray.is_empty", "intent": "Indicates if an interval is empty, meaning it contains no points.", "question_id": 43251}
{"snippet": "IntervalArray.is_empty", "intent": "Indicates if an interval is empty, meaning it contains no points.", "question_id": 43252}
{"snippet": "IntervalArray.overlaps(other)", "intent": "Check elementwise if an Interval overlaps the values in the IntervalArray . With arguments `other`.", "question_id": 43253}
{"snippet": "IntervalArray.overlaps(other)", "intent": "Check elementwise if an Interval overlaps the values in the IntervalArray . With arguments `other`.", "question_id": 43254}
{"snippet": "IntervalArray.overlaps(other)", "intent": "Check elementwise if an Interval overlaps the values in the IntervalArray . With arguments `other`.", "question_id": 43255}
{"snippet": "IntervalArray.set_closed(closed)", "intent": "Return an IntervalArray identical to the current one , but `closed` on the specified side .", "question_id": 43256}
{"snippet": "IntervalArray.set_closed(closed)", "intent": "Return an IntervalArray identical to the current one , but `closed` on the specified side .", "question_id": 43257}
{"snippet": "IntervalArray.set_closed(closed)", "intent": "Return an IntervalArray identical to the current one , but `closed` on the specified side .", "question_id": 43258}
{"snippet": "IntervalArray.to_tuples()", "intent": "Return an ndarray of tuples of the form ( left , right ) .", "question_id": 43259}
{"snippet": "IntervalArray.to_tuples(na_tuple=True)", "intent": "Return an ndarray of tuples of the form ( left , right ) . With arguments `na_tuple`.", "question_id": 43260}
{"snippet": "IntervalArray.to_tuples()", "intent": "Return an ndarray of tuples of the form ( left , right ) .", "question_id": 43261}
{"snippet": "IntervalArray.to_tuples(na_tuple=True)", "intent": "Return an ndarray of tuples of the form ( left , right ) . With arguments `na_tuple`.", "question_id": 43262}
{"snippet": "IntervalArray.to_tuples()", "intent": "Return an ndarray of tuples of the form ( left , right ) .", "question_id": 43263}
{"snippet": "IntervalArray.to_tuples(na_tuple=True)", "intent": "Return an ndarray of tuples of the form ( left , right ) . With arguments `na_tuple`.", "question_id": 43264}
{"snippet": "pandas.arrays.PandasArray(values)", "intent": "A pandas ExtensionArray for NumPy data . With arguments `values`.", "question_id": 43265}
{"snippet": "pandas.arrays.PandasArray(values, copy=False)", "intent": "A pandas ExtensionArray for NumPy data . With arguments `values`, `copy`.", "question_id": 43266}
{"snippet": "pandas.arrays.PandasArray(values)", "intent": "A pandas ExtensionArray for NumPy data . With arguments `values`.", "question_id": 43267}
{"snippet": "pandas.arrays.PandasArray(values, copy=False)", "intent": "A pandas ExtensionArray for NumPy data . With arguments `values`, `copy`.", "question_id": 43268}
{"snippet": "pandas.arrays.PandasArray(values)", "intent": "A pandas ExtensionArray for NumPy data . With arguments `values`.", "question_id": 43269}
{"snippet": "pandas.arrays.PandasArray(values, copy=False)", "intent": "A pandas ExtensionArray for NumPy data . With arguments `values`, `copy`.", "question_id": 43270}
{"snippet": "pandas.arrays.PeriodArray(values)", "intent": "Pandas ExtensionArray for storing Period data . The `values` are physically stored as a 1-D ndarray of integers .", "question_id": 43271}
{"snippet": "pandas.arrays.PeriodArray(values, dtype=None)", "intent": "Pandas ExtensionArray for storing Period data . The `values` are physically stored as a 1-D ndarray of integers . With arguments `dtype`.", "question_id": 43272}
{"snippet": "pandas.arrays.PeriodArray(values, freq=None)", "intent": "Pandas ExtensionArray for storing Period data . The `values` are physically stored as a 1-D ndarray of integers . The `freq` indicates the span covered by each element of the array .", "question_id": 43273}
{"snippet": "pandas.arrays.PeriodArray(values, copy=False)", "intent": "Pandas ExtensionArray for storing Period data . The `values` are physically stored as a 1-D ndarray of integers . With arguments `copy`.", "question_id": 43274}
{"snippet": "pandas.arrays.PeriodArray(values, dtype=None, freq=None)", "intent": "Pandas ExtensionArray for storing Period data . The `values` are physically stored as a 1-D ndarray of integers . The `freq` indicates the span covered by each element of the array . With arguments `dtype`.", "question_id": 43275}
{"snippet": "pandas.arrays.PeriodArray(values, dtype=None, copy=False)", "intent": "Pandas ExtensionArray for storing Period data . The `values` are physically stored as a 1-D ndarray of integers . With arguments `dtype`, `copy`.", "question_id": 43276}
{"snippet": "pandas.arrays.PeriodArray(values, freq=None, copy=False)", "intent": "Pandas ExtensionArray for storing Period data . The `values` are physically stored as a 1-D ndarray of integers . The `freq` indicates the span covered by each element of the array . With arguments `copy`.", "question_id": 43277}
{"snippet": "pandas.arrays.PeriodArray(values, dtype=None, freq=None, copy=False)", "intent": "Pandas ExtensionArray for storing Period data . The `values` are physically stored as a 1-D ndarray of integers . The `freq` indicates the span covered by each element of the array . With arguments `dtype`, `copy`.", "question_id": 43278}
{"snippet": "pandas.arrays.PeriodArray(values)", "intent": "Pandas ExtensionArray for storing Period data . The `values` are physically stored as a 1-D ndarray of integers .", "question_id": 43279}
{"snippet": "pandas.arrays.PeriodArray(values, dtype=None)", "intent": "Pandas ExtensionArray for storing Period data . The `values` are physically stored as a 1-D ndarray of integers . With arguments `dtype`.", "question_id": 43280}
{"snippet": "pandas.arrays.PeriodArray(values, freq=None)", "intent": "Pandas ExtensionArray for storing Period data . The `values` are physically stored as a 1-D ndarray of integers . The `freq` indicates the span covered by each element of the array .", "question_id": 43281}
{"snippet": "pandas.arrays.PeriodArray(values, copy=False)", "intent": "Pandas ExtensionArray for storing Period data . The `values` are physically stored as a 1-D ndarray of integers . With arguments `copy`.", "question_id": 43282}
{"snippet": "pandas.arrays.PeriodArray(values, dtype=None, freq=None)", "intent": "Pandas ExtensionArray for storing Period data . The `values` are physically stored as a 1-D ndarray of integers . The `freq` indicates the span covered by each element of the array . With arguments `dtype`.", "question_id": 43283}
{"snippet": "pandas.arrays.PeriodArray(values, dtype=None, copy=False)", "intent": "Pandas ExtensionArray for storing Period data . The `values` are physically stored as a 1-D ndarray of integers . With arguments `dtype`, `copy`.", "question_id": 43284}
{"snippet": "pandas.arrays.PeriodArray(values, freq=None, copy=False)", "intent": "Pandas ExtensionArray for storing Period data . The `values` are physically stored as a 1-D ndarray of integers . The `freq` indicates the span covered by each element of the array . With arguments `copy`.", "question_id": 43285}
{"snippet": "pandas.arrays.PeriodArray(values, dtype=None, freq=None, copy=False)", "intent": "Pandas ExtensionArray for storing Period data . The `values` are physically stored as a 1-D ndarray of integers . The `freq` indicates the span covered by each element of the array . With arguments `dtype`, `copy`.", "question_id": 43286}
{"snippet": "pandas.arrays.PeriodArray(values)", "intent": "Pandas ExtensionArray for storing Period data . The `values` are physically stored as a 1-D ndarray of integers .", "question_id": 43287}
{"snippet": "pandas.arrays.PeriodArray(values, dtype=None)", "intent": "Pandas ExtensionArray for storing Period data . The `values` are physically stored as a 1-D ndarray of integers . With arguments `dtype`.", "question_id": 43288}
{"snippet": "pandas.arrays.PeriodArray(values, freq=None)", "intent": "Pandas ExtensionArray for storing Period data . The `values` are physically stored as a 1-D ndarray of integers . The `freq` indicates the span covered by each element of the array .", "question_id": 43289}
{"snippet": "pandas.arrays.PeriodArray(values, copy=False)", "intent": "Pandas ExtensionArray for storing Period data . The `values` are physically stored as a 1-D ndarray of integers . With arguments `copy`.", "question_id": 43290}
{"snippet": "pandas.arrays.PeriodArray(values, dtype=None, freq=None)", "intent": "Pandas ExtensionArray for storing Period data . The `values` are physically stored as a 1-D ndarray of integers . The `freq` indicates the span covered by each element of the array . With arguments `dtype`.", "question_id": 43291}
{"snippet": "pandas.arrays.PeriodArray(values, dtype=None, copy=False)", "intent": "Pandas ExtensionArray for storing Period data . The `values` are physically stored as a 1-D ndarray of integers . With arguments `dtype`, `copy`.", "question_id": 43292}
{"snippet": "pandas.arrays.PeriodArray(values, freq=None, copy=False)", "intent": "Pandas ExtensionArray for storing Period data . The `values` are physically stored as a 1-D ndarray of integers . The `freq` indicates the span covered by each element of the array . With arguments `copy`.", "question_id": 43293}
{"snippet": "pandas.arrays.PeriodArray(values, dtype=None, freq=None, copy=False)", "intent": "Pandas ExtensionArray for storing Period data . The `values` are physically stored as a 1-D ndarray of integers . The `freq` indicates the span covered by each element of the array . With arguments `dtype`, `copy`.", "question_id": 43294}
{"snippet": "pandas.arrays.SparseArray(data)", "intent": "An ExtensionArray for storing sparse `data` .", "question_id": 43295}
{"snippet": "pandas.arrays.SparseArray(data, sparse_index=None)", "intent": "An ExtensionArray for storing sparse `data` . With arguments `sparse_index`.", "question_id": 43296}
{"snippet": "pandas.arrays.SparseArray(data, index=None)", "intent": "An ExtensionArray for storing sparse `data` . With arguments `index`.", "question_id": 43297}
{"snippet": "pandas.arrays.SparseArray(data, fill_value=None)", "intent": "An ExtensionArray for storing sparse `data` . With arguments `fill_value`.", "question_id": 43298}
{"snippet": "pandas.arrays.SparseArray(data, kind='integer')", "intent": "An ExtensionArray for storing sparse `data` . With arguments `kind`.", "question_id": 43299}
{"snippet": "pandas.arrays.SparseArray(data, dtype=None)", "intent": "An ExtensionArray for storing sparse `data` . With arguments `dtype`.", "question_id": 43300}
{"snippet": "pandas.arrays.SparseArray(data, copy=False)", "intent": "An ExtensionArray for storing sparse `data` . With arguments `copy`.", "question_id": 43301}
{"snippet": "pandas.arrays.SparseArray(data, sparse_index=None, index=None)", "intent": "An ExtensionArray for storing sparse `data` . With arguments `sparse_index`, `index`.", "question_id": 43302}
{"snippet": "pandas.arrays.SparseArray(data, sparse_index=None, fill_value=None)", "intent": "An ExtensionArray for storing sparse `data` . With arguments `sparse_index`, `fill_value`.", "question_id": 43303}
{"snippet": "pandas.arrays.SparseArray(data, sparse_index=None, kind='integer')", "intent": "An ExtensionArray for storing sparse `data` . With arguments `sparse_index`, `kind`.", "question_id": 43304}
{"snippet": "pandas.arrays.SparseArray(data)", "intent": "An ExtensionArray for storing sparse `data` .", "question_id": 43305}
{"snippet": "pandas.arrays.SparseArray(data, sparse_index=None)", "intent": "An ExtensionArray for storing sparse `data` . With arguments `sparse_index`.", "question_id": 43306}
{"snippet": "pandas.arrays.SparseArray(data, index=None)", "intent": "An ExtensionArray for storing sparse `data` . With arguments `index`.", "question_id": 43307}
{"snippet": "pandas.arrays.SparseArray(data, fill_value=None)", "intent": "An ExtensionArray for storing sparse `data` . With arguments `fill_value`.", "question_id": 43308}
{"snippet": "pandas.arrays.SparseArray(data, kind='integer')", "intent": "An ExtensionArray for storing sparse `data` . With arguments `kind`.", "question_id": 43309}
{"snippet": "pandas.arrays.SparseArray(data, dtype=None)", "intent": "An ExtensionArray for storing sparse `data` . With arguments `dtype`.", "question_id": 43310}
{"snippet": "pandas.arrays.SparseArray(data, copy=False)", "intent": "An ExtensionArray for storing sparse `data` . With arguments `copy`.", "question_id": 43311}
{"snippet": "pandas.arrays.SparseArray(data, sparse_index=None, index=None)", "intent": "An ExtensionArray for storing sparse `data` . With arguments `sparse_index`, `index`.", "question_id": 43312}
{"snippet": "pandas.arrays.SparseArray(data, sparse_index=None, fill_value=None)", "intent": "An ExtensionArray for storing sparse `data` . With arguments `sparse_index`, `fill_value`.", "question_id": 43313}
{"snippet": "pandas.arrays.SparseArray(data, sparse_index=None, kind='integer')", "intent": "An ExtensionArray for storing sparse `data` . With arguments `sparse_index`, `kind`.", "question_id": 43314}
{"snippet": "pandas.arrays.SparseArray(data)", "intent": "An ExtensionArray for storing sparse `data` .", "question_id": 43315}
{"snippet": "pandas.arrays.SparseArray(data, sparse_index=None)", "intent": "An ExtensionArray for storing sparse `data` . With arguments `sparse_index`.", "question_id": 43316}
{"snippet": "pandas.arrays.SparseArray(data, index=None)", "intent": "An ExtensionArray for storing sparse `data` . With arguments `index`.", "question_id": 43317}
{"snippet": "pandas.arrays.SparseArray(data, fill_value=None)", "intent": "An ExtensionArray for storing sparse `data` . With arguments `fill_value`.", "question_id": 43318}
{"snippet": "pandas.arrays.SparseArray(data, kind='integer')", "intent": "An ExtensionArray for storing sparse `data` . With arguments `kind`.", "question_id": 43319}
{"snippet": "pandas.arrays.SparseArray(data, dtype=None)", "intent": "An ExtensionArray for storing sparse `data` . With arguments `dtype`.", "question_id": 43320}
{"snippet": "pandas.arrays.SparseArray(data, copy=False)", "intent": "An ExtensionArray for storing sparse `data` . With arguments `copy`.", "question_id": 43321}
{"snippet": "pandas.arrays.SparseArray(data, sparse_index=None, index=None)", "intent": "An ExtensionArray for storing sparse `data` . With arguments `sparse_index`, `index`.", "question_id": 43322}
{"snippet": "pandas.arrays.SparseArray(data, sparse_index=None, fill_value=None)", "intent": "An ExtensionArray for storing sparse `data` . With arguments `sparse_index`, `fill_value`.", "question_id": 43323}
{"snippet": "pandas.arrays.SparseArray(data, sparse_index=None, kind='integer')", "intent": "An ExtensionArray for storing sparse `data` . With arguments `sparse_index`, `kind`.", "question_id": 43324}
{"snippet": "pandas.arrays.StringArray(values)", "intent": "Extension array for string data . Unlike arrays instantiated with dtype= '' object '' , StringArray will convert the `values` to strings .", "question_id": 43325}
{"snippet": "pandas.arrays.StringArray(values, copy=False)", "intent": "Extension array for string data . Unlike arrays instantiated with dtype= '' object '' , StringArray will convert the `values` to strings . With arguments `copy`.", "question_id": 43326}
{"snippet": "pandas.arrays.StringArray(values)", "intent": "Extension array for string data . Unlike arrays instantiated with dtype= '' object '' , StringArray will convert the `values` to strings .", "question_id": 43327}
{"snippet": "pandas.arrays.StringArray(values, copy=False)", "intent": "Extension array for string data . Unlike arrays instantiated with dtype= '' object '' , StringArray will convert the `values` to strings . With arguments `copy`.", "question_id": 43328}
{"snippet": "pandas.arrays.StringArray(values)", "intent": "Extension array for string data . Unlike arrays instantiated with dtype= '' object '' , StringArray will convert the `values` to strings .", "question_id": 43329}
{"snippet": "pandas.arrays.StringArray(values, copy=False)", "intent": "Extension array for string data . Unlike arrays instantiated with dtype= '' object '' , StringArray will convert the `values` to strings . With arguments `copy`.", "question_id": 43330}
{"snippet": "pandas.arrays.TimedeltaArray(values)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `values`.", "question_id": 43331}
{"snippet": "pandas.arrays.TimedeltaArray(values, dtype=dtype('<m8ns'))", "intent": "Pandas ExtensionArray for timedelta data . With arguments `values`, `dtype`.", "question_id": 43332}
{"snippet": "pandas.arrays.TimedeltaArray(values, freq=NoDefault.no_default)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `values`, `freq`.", "question_id": 43333}
{"snippet": "pandas.arrays.TimedeltaArray(values, copy=False)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `values`, `copy`.", "question_id": 43334}
{"snippet": "pandas.arrays.TimedeltaArray(values, dtype=dtype('<m8ns'), freq=NoDefault.no_default)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `values`, `dtype`, `freq`.", "question_id": 43335}
{"snippet": "pandas.arrays.TimedeltaArray(values, dtype=dtype('<m8ns'), copy=False)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `values`, `dtype`, `copy`.", "question_id": 43336}
{"snippet": "pandas.arrays.TimedeltaArray(values, freq=NoDefault.no_default, copy=False)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `values`, `freq`, `copy`.", "question_id": 43337}
{"snippet": "pandas.arrays.TimedeltaArray(values, dtype=dtype('<m8ns'), freq=NoDefault.no_default, copy=False)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `values`, `dtype`, `freq`, `copy`.", "question_id": 43338}
{"snippet": "pandas.arrays.TimedeltaArray()", "intent": "Pandas ExtensionArray for timedelta data .", "question_id": 43339}
{"snippet": "pandas.arrays.TimedeltaArray(dtype=dtype('<m8ns'))", "intent": "Pandas ExtensionArray for timedelta data . With arguments `dtype`.", "question_id": 43340}
{"snippet": "pandas.arrays.TimedeltaArray(freq=NoDefault.no_default)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `freq`.", "question_id": 43341}
{"snippet": "pandas.arrays.TimedeltaArray(copy=False)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `copy`.", "question_id": 43342}
{"snippet": "pandas.arrays.TimedeltaArray(dtype=dtype('<m8ns'), freq=NoDefault.no_default)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `dtype`, `freq`.", "question_id": 43343}
{"snippet": "pandas.arrays.TimedeltaArray(dtype=dtype('<m8ns'), copy=False)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `dtype`, `copy`.", "question_id": 43344}
{"snippet": "pandas.arrays.TimedeltaArray(freq=NoDefault.no_default, copy=False)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `freq`, `copy`.", "question_id": 43345}
{"snippet": "pandas.arrays.TimedeltaArray(dtype=dtype('<m8ns'), freq=NoDefault.no_default, copy=False)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `dtype`, `freq`, `copy`.", "question_id": 43346}
{"snippet": "pandas.arrays.TimedeltaArray(values)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `values`.", "question_id": 43347}
{"snippet": "pandas.arrays.TimedeltaArray(values, dtype=dtype('<m8ns'))", "intent": "Pandas ExtensionArray for timedelta data . With arguments `values`, `dtype`.", "question_id": 43348}
{"snippet": "pandas.arrays.TimedeltaArray(values, freq=NoDefault.no_default)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `values`, `freq`.", "question_id": 43349}
{"snippet": "pandas.arrays.TimedeltaArray(values, copy=False)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `values`, `copy`.", "question_id": 43350}
{"snippet": "pandas.arrays.TimedeltaArray(values, dtype=dtype('<m8ns'), freq=NoDefault.no_default)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `values`, `dtype`, `freq`.", "question_id": 43351}
{"snippet": "pandas.arrays.TimedeltaArray(values, dtype=dtype('<m8ns'), copy=False)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `values`, `dtype`, `copy`.", "question_id": 43352}
{"snippet": "pandas.arrays.TimedeltaArray(values, freq=NoDefault.no_default, copy=False)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `values`, `freq`, `copy`.", "question_id": 43353}
{"snippet": "pandas.arrays.TimedeltaArray(values, dtype=dtype('<m8ns'), freq=NoDefault.no_default, copy=False)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `values`, `dtype`, `freq`, `copy`.", "question_id": 43354}
{"snippet": "pandas.arrays.TimedeltaArray()", "intent": "Pandas ExtensionArray for timedelta data .", "question_id": 43355}
{"snippet": "pandas.arrays.TimedeltaArray(dtype=dtype('<m8ns'))", "intent": "Pandas ExtensionArray for timedelta data . With arguments `dtype`.", "question_id": 43356}
{"snippet": "pandas.arrays.TimedeltaArray(freq=NoDefault.no_default)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `freq`.", "question_id": 43357}
{"snippet": "pandas.arrays.TimedeltaArray(copy=False)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `copy`.", "question_id": 43358}
{"snippet": "pandas.arrays.TimedeltaArray(dtype=dtype('<m8ns'), freq=NoDefault.no_default)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `dtype`, `freq`.", "question_id": 43359}
{"snippet": "pandas.arrays.TimedeltaArray(dtype=dtype('<m8ns'), copy=False)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `dtype`, `copy`.", "question_id": 43360}
{"snippet": "pandas.arrays.TimedeltaArray(freq=NoDefault.no_default, copy=False)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `freq`, `copy`.", "question_id": 43361}
{"snippet": "pandas.arrays.TimedeltaArray(dtype=dtype('<m8ns'), freq=NoDefault.no_default, copy=False)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `dtype`, `freq`, `copy`.", "question_id": 43362}
{"snippet": "pandas.arrays.TimedeltaArray(values)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `values`.", "question_id": 43363}
{"snippet": "pandas.arrays.TimedeltaArray(values, dtype=dtype('<m8ns'))", "intent": "Pandas ExtensionArray for timedelta data . With arguments `values`, `dtype`.", "question_id": 43364}
{"snippet": "pandas.arrays.TimedeltaArray(values, freq=NoDefault.no_default)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `values`, `freq`.", "question_id": 43365}
{"snippet": "pandas.arrays.TimedeltaArray(values, copy=False)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `values`, `copy`.", "question_id": 43366}
{"snippet": "pandas.arrays.TimedeltaArray(values, dtype=dtype('<m8ns'), freq=NoDefault.no_default)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `values`, `dtype`, `freq`.", "question_id": 43367}
{"snippet": "pandas.arrays.TimedeltaArray(values, dtype=dtype('<m8ns'), copy=False)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `values`, `dtype`, `copy`.", "question_id": 43368}
{"snippet": "pandas.arrays.TimedeltaArray(values, freq=NoDefault.no_default, copy=False)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `values`, `freq`, `copy`.", "question_id": 43369}
{"snippet": "pandas.arrays.TimedeltaArray(values, dtype=dtype('<m8ns'), freq=NoDefault.no_default, copy=False)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `values`, `dtype`, `freq`, `copy`.", "question_id": 43370}
{"snippet": "pandas.arrays.TimedeltaArray()", "intent": "Pandas ExtensionArray for timedelta data .", "question_id": 43371}
{"snippet": "pandas.arrays.TimedeltaArray(dtype=dtype('<m8ns'))", "intent": "Pandas ExtensionArray for timedelta data . With arguments `dtype`.", "question_id": 43372}
{"snippet": "pandas.arrays.TimedeltaArray(freq=NoDefault.no_default)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `freq`.", "question_id": 43373}
{"snippet": "pandas.arrays.TimedeltaArray(copy=False)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `copy`.", "question_id": 43374}
{"snippet": "pandas.arrays.TimedeltaArray(dtype=dtype('<m8ns'), freq=NoDefault.no_default)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `dtype`, `freq`.", "question_id": 43375}
{"snippet": "pandas.arrays.TimedeltaArray(dtype=dtype('<m8ns'), copy=False)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `dtype`, `copy`.", "question_id": 43376}
{"snippet": "pandas.arrays.TimedeltaArray(freq=NoDefault.no_default, copy=False)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `freq`, `copy`.", "question_id": 43377}
{"snippet": "pandas.arrays.TimedeltaArray(dtype=dtype('<m8ns'), freq=NoDefault.no_default, copy=False)", "intent": "Pandas ExtensionArray for timedelta data . With arguments `dtype`, `freq`, `copy`.", "question_id": 43378}
{"snippet": "pandas.bdate_range(**kwargs)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . With arguments `**kwargs`.", "question_id": 43379}
{"snippet": "pandas.bdate_range(**kwargs, start=None)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . Of the four parameters : `start` , `end` , `periods` , and `freq` , exactly three must be specified . With arguments `**kwargs`.", "question_id": 43380}
{"snippet": "pandas.bdate_range(**kwargs, end=None)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . Of the four parameters : `start` , `end` , `periods` , and `freq` , exactly three must be specified . With arguments `**kwargs`.", "question_id": 43381}
{"snippet": "pandas.bdate_range(**kwargs, periods=None)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . Of the four parameters : `start` , `end` , `periods` , and `freq` , exactly three must be specified . With arguments `**kwargs`.", "question_id": 43382}
{"snippet": "pandas.bdate_range(**kwargs, freq='B')", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . Of the four parameters : `start` , `end` , `periods` , and `freq` , exactly three must be specified . With arguments `**kwargs`.", "question_id": 43383}
{"snippet": "pandas.bdate_range(**kwargs, tz=None)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . With arguments `**kwargs`, `tz`.", "question_id": 43384}
{"snippet": "pandas.bdate_range(**kwargs, normalize=True)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . With arguments `**kwargs`, `normalize`.", "question_id": 43385}
{"snippet": "pandas.bdate_range(**kwargs, name=None)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . With arguments `**kwargs`, `name`.", "question_id": 43386}
{"snippet": "pandas.bdate_range(**kwargs, weekmask=None)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . With arguments `**kwargs`, `weekmask`.", "question_id": 43387}
{"snippet": "pandas.bdate_range(**kwargs, holidays=None)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . With arguments `**kwargs`, `holidays`.", "question_id": 43388}
{"snippet": "pandas.bdate_range(**kwargs)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . With arguments `**kwargs`.", "question_id": 43389}
{"snippet": "pandas.bdate_range(**kwargs, start=None)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . Of the four parameters : `start` , `end` , `periods` , and `freq` , exactly three must be specified . With arguments `**kwargs`.", "question_id": 43390}
{"snippet": "pandas.bdate_range(**kwargs, end=None)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . Of the four parameters : `start` , `end` , `periods` , and `freq` , exactly three must be specified . With arguments `**kwargs`.", "question_id": 43391}
{"snippet": "pandas.bdate_range(**kwargs, periods=None)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . Of the four parameters : `start` , `end` , `periods` , and `freq` , exactly three must be specified . With arguments `**kwargs`.", "question_id": 43392}
{"snippet": "pandas.bdate_range(**kwargs, freq='B')", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . Of the four parameters : `start` , `end` , `periods` , and `freq` , exactly three must be specified . With arguments `**kwargs`.", "question_id": 43393}
{"snippet": "pandas.bdate_range(**kwargs, tz=None)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . With arguments `**kwargs`, `tz`.", "question_id": 43394}
{"snippet": "pandas.bdate_range(**kwargs, normalize=True)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . With arguments `**kwargs`, `normalize`.", "question_id": 43395}
{"snippet": "pandas.bdate_range(**kwargs, name=None)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . With arguments `**kwargs`, `name`.", "question_id": 43396}
{"snippet": "pandas.bdate_range(**kwargs, weekmask=None)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . With arguments `**kwargs`, `weekmask`.", "question_id": 43397}
{"snippet": "pandas.bdate_range(**kwargs, holidays=None)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . With arguments `**kwargs`, `holidays`.", "question_id": 43398}
{"snippet": "pandas.bdate_range(**kwargs)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . With arguments `**kwargs`.", "question_id": 43399}
{"snippet": "pandas.bdate_range(**kwargs, start=None)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . Of the four parameters : `start` , `end` , `periods` , and `freq` , exactly three must be specified . With arguments `**kwargs`.", "question_id": 43400}
{"snippet": "pandas.bdate_range(**kwargs, end=None)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . Of the four parameters : `start` , `end` , `periods` , and `freq` , exactly three must be specified . With arguments `**kwargs`.", "question_id": 43401}
{"snippet": "pandas.bdate_range(**kwargs, periods=None)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . Of the four parameters : `start` , `end` , `periods` , and `freq` , exactly three must be specified . With arguments `**kwargs`.", "question_id": 43402}
{"snippet": "pandas.bdate_range(**kwargs, freq='B')", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . Of the four parameters : `start` , `end` , `periods` , and `freq` , exactly three must be specified . With arguments `**kwargs`.", "question_id": 43403}
{"snippet": "pandas.bdate_range(**kwargs, tz=None)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . With arguments `**kwargs`, `tz`.", "question_id": 43404}
{"snippet": "pandas.bdate_range(**kwargs, normalize=True)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . With arguments `**kwargs`, `normalize`.", "question_id": 43405}
{"snippet": "pandas.bdate_range(**kwargs, name=None)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . With arguments `**kwargs`, `name`.", "question_id": 43406}
{"snippet": "pandas.bdate_range(**kwargs, weekmask=None)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . With arguments `**kwargs`, `weekmask`.", "question_id": 43407}
{"snippet": "pandas.bdate_range(**kwargs, holidays=None)", "intent": "Return a fixed frequency DatetimeIndex , with business day as the default frequency . With arguments `**kwargs`, `holidays`.", "question_id": 43408}
{"snippet": "pandas.concat(objs)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . With arguments `objs`.", "question_id": 43409}
{"snippet": "pandas.concat(objs, axis=0)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . With arguments `objs`.", "question_id": 43410}
{"snippet": "pandas.concat(objs, join='outer')", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . Combine DataFrame objects with overlapping columns and return only those that are shared by passing inner to the `join` keyword argument . With arguments `objs`.", "question_id": 43411}
{"snippet": "pandas.concat(objs, ignore_index=False)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . Clear the existing index and reset it in the result by setting the `ignore_index` option to True . With arguments `objs`.", "question_id": 43412}
{"snippet": "pandas.concat(objs, keys=None)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . The `keys` , `levels` , and `names` arguments are all optional . With arguments `objs`.", "question_id": 43413}
{"snippet": "pandas.concat(objs, levels=None)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . The `keys` , `levels` , and `names` arguments are all optional . With arguments `objs`.", "question_id": 43414}
{"snippet": "pandas.concat(objs, names=None)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . The `keys` , `levels` , and `names` arguments are all optional . With arguments `objs`.", "question_id": 43415}
{"snippet": "pandas.concat(objs, verify_integrity=False)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . Prevent the result from including duplicate index values with the `verify_integrity` option . With arguments `objs`.", "question_id": 43416}
{"snippet": "pandas.concat(objs, sort=False)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . With arguments `objs`, `sort`.", "question_id": 43417}
{"snippet": "pandas.concat(objs, copy=True)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . With arguments `objs`, `copy`.", "question_id": 43418}
{"snippet": "pandas.concat(objs)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . With arguments `objs`.", "question_id": 43419}
{"snippet": "pandas.concat(objs, axis=0)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . With arguments `objs`.", "question_id": 43420}
{"snippet": "pandas.concat(objs, join='outer')", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . Combine DataFrame objects with overlapping columns and return only those that are shared by passing inner to the `join` keyword argument . With arguments `objs`.", "question_id": 43421}
{"snippet": "pandas.concat(objs, ignore_index=False)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . Clear the existing index and reset it in the result by setting the `ignore_index` option to True . With arguments `objs`.", "question_id": 43422}
{"snippet": "pandas.concat(objs, keys=None)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . The `keys` , `levels` , and `names` arguments are all optional . With arguments `objs`.", "question_id": 43423}
{"snippet": "pandas.concat(objs, levels=None)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . The `keys` , `levels` , and `names` arguments are all optional . With arguments `objs`.", "question_id": 43424}
{"snippet": "pandas.concat(objs, names=None)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . The `keys` , `levels` , and `names` arguments are all optional . With arguments `objs`.", "question_id": 43425}
{"snippet": "pandas.concat(objs, verify_integrity=False)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . Prevent the result from including duplicate index values with the `verify_integrity` option . With arguments `objs`.", "question_id": 43426}
{"snippet": "pandas.concat(objs, sort=False)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . With arguments `objs`, `sort`.", "question_id": 43427}
{"snippet": "pandas.concat(objs, copy=True)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . With arguments `objs`, `copy`.", "question_id": 43428}
{"snippet": "pandas.concat(objs)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . With arguments `objs`.", "question_id": 43429}
{"snippet": "pandas.concat(objs, axis=0)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . With arguments `objs`.", "question_id": 43430}
{"snippet": "pandas.concat(objs, join='outer')", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . Combine DataFrame objects with overlapping columns and return only those that are shared by passing inner to the `join` keyword argument . With arguments `objs`.", "question_id": 43431}
{"snippet": "pandas.concat(objs, ignore_index=False)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . Clear the existing index and reset it in the result by setting the `ignore_index` option to True . With arguments `objs`.", "question_id": 43432}
{"snippet": "pandas.concat(objs, keys=None)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . The `keys` , `levels` , and `names` arguments are all optional . With arguments `objs`.", "question_id": 43433}
{"snippet": "pandas.concat(objs, levels=None)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . The `keys` , `levels` , and `names` arguments are all optional . With arguments `objs`.", "question_id": 43434}
{"snippet": "pandas.concat(objs, names=None)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . The `keys` , `levels` , and `names` arguments are all optional . With arguments `objs`.", "question_id": 43435}
{"snippet": "pandas.concat(objs, verify_integrity=False)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . Prevent the result from including duplicate index values with the `verify_integrity` option . With arguments `objs`.", "question_id": 43436}
{"snippet": "pandas.concat(objs, sort=False)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . With arguments `objs`, `sort`.", "question_id": 43437}
{"snippet": "pandas.concat(objs, copy=True)", "intent": "Concatenate pandas objects along a particular `axis` with optional set logic along the other axes . With arguments `objs`, `copy`.", "question_id": 43438}
{"snippet": "DataFrameGroupBy.aggregate(*args, **kwargs)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`.", "question_id": 43439}
{"snippet": "DataFrameGroupBy.aggregate(*args, **kwargs, func=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `func`.", "question_id": 43440}
{"snippet": "DataFrameGroupBy.aggregate(*args, **kwargs, engine=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `engine`.", "question_id": 43441}
{"snippet": "DataFrameGroupBy.aggregate(*args, **kwargs, engine_kwargs=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 43442}
{"snippet": "DataFrameGroupBy.aggregate(*args, **kwargs, func=None, engine=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `func`, `engine`.", "question_id": 43443}
{"snippet": "DataFrameGroupBy.aggregate(*args, **kwargs, func=None, engine_kwargs=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `func`, `engine_kwargs`.", "question_id": 43444}
{"snippet": "DataFrameGroupBy.aggregate(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `engine`, `engine_kwargs`.", "question_id": 43445}
{"snippet": "DataFrameGroupBy.aggregate(*args, **kwargs, func=None, engine=None, engine_kwargs=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `func`, `engine`, `engine_kwargs`.", "question_id": 43446}
{"snippet": "DataFrameGroupBy.aggregate(*args, **kwargs)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`.", "question_id": 43447}
{"snippet": "DataFrameGroupBy.aggregate(*args, **kwargs, func=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `func`.", "question_id": 43448}
{"snippet": "DataFrameGroupBy.aggregate(*args, **kwargs, engine=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `engine`.", "question_id": 43449}
{"snippet": "DataFrameGroupBy.aggregate(*args, **kwargs, engine_kwargs=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 43450}
{"snippet": "DataFrameGroupBy.aggregate(*args, **kwargs, func=None, engine=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `func`, `engine`.", "question_id": 43451}
{"snippet": "DataFrameGroupBy.aggregate(*args, **kwargs, func=None, engine_kwargs=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `func`, `engine_kwargs`.", "question_id": 43452}
{"snippet": "DataFrameGroupBy.aggregate(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `engine`, `engine_kwargs`.", "question_id": 43453}
{"snippet": "DataFrameGroupBy.aggregate(*args, **kwargs, func=None, engine=None, engine_kwargs=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `func`, `engine`, `engine_kwargs`.", "question_id": 43454}
{"snippet": "DataFrameGroupBy.aggregate(*args, **kwargs)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`.", "question_id": 43455}
{"snippet": "DataFrameGroupBy.aggregate(*args, **kwargs, func=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `func`.", "question_id": 43456}
{"snippet": "DataFrameGroupBy.aggregate(*args, **kwargs, engine=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `engine`.", "question_id": 43457}
{"snippet": "DataFrameGroupBy.aggregate(*args, **kwargs, engine_kwargs=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 43458}
{"snippet": "DataFrameGroupBy.aggregate(*args, **kwargs, func=None, engine=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `func`, `engine`.", "question_id": 43459}
{"snippet": "DataFrameGroupBy.aggregate(*args, **kwargs, func=None, engine_kwargs=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `func`, `engine_kwargs`.", "question_id": 43460}
{"snippet": "DataFrameGroupBy.aggregate(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `engine`, `engine_kwargs`.", "question_id": 43461}
{"snippet": "DataFrameGroupBy.aggregate(*args, **kwargs, func=None, engine=None, engine_kwargs=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `func`, `engine`, `engine_kwargs`.", "question_id": 43462}
{"snippet": "DataFrameGroupBy.all()", "intent": "Return True if all values in the group are truthful , else False .", "question_id": 43463}
{"snippet": "DataFrameGroupBy.all(skipna=True)", "intent": "Return True if all values in the group are truthful , else False . With arguments `skipna`.", "question_id": 43464}
{"snippet": "DataFrameGroupBy.all()", "intent": "Return True if all values in the group are truthful , else False .", "question_id": 43465}
{"snippet": "DataFrameGroupBy.all(skipna=True)", "intent": "Return True if all values in the group are truthful , else False . With arguments `skipna`.", "question_id": 43466}
{"snippet": "DataFrameGroupBy.all()", "intent": "Return True if all values in the group are truthful , else False .", "question_id": 43467}
{"snippet": "DataFrameGroupBy.all(skipna=True)", "intent": "Return True if all values in the group are truthful , else False . With arguments `skipna`.", "question_id": 43468}
{"snippet": "DataFrameGroupBy.any()", "intent": "Return True if any value in the group is truthful , else False .", "question_id": 43469}
{"snippet": "DataFrameGroupBy.any(skipna=True)", "intent": "Return True if any value in the group is truthful , else False . With arguments `skipna`.", "question_id": 43470}
{"snippet": "DataFrameGroupBy.any()", "intent": "Return True if any value in the group is truthful , else False .", "question_id": 43471}
{"snippet": "DataFrameGroupBy.any(skipna=True)", "intent": "Return True if any value in the group is truthful , else False . With arguments `skipna`.", "question_id": 43472}
{"snippet": "DataFrameGroupBy.any()", "intent": "Return True if any value in the group is truthful , else False .", "question_id": 43473}
{"snippet": "DataFrameGroupBy.any(skipna=True)", "intent": "Return True if any value in the group is truthful , else False . With arguments `skipna`.", "question_id": 43474}
{"snippet": "DataFrameGroupBy.backfill()", "intent": "Backward fill the values .", "question_id": 43475}
{"snippet": "DataFrameGroupBy.backfill(limit=None)", "intent": "Backward fill the values . With arguments `limit`.", "question_id": 43476}
{"snippet": "DataFrameGroupBy.backfill()", "intent": "Backward fill the values .", "question_id": 43477}
{"snippet": "DataFrameGroupBy.backfill(limit=None)", "intent": "Backward fill the values . With arguments `limit`.", "question_id": 43478}
{"snippet": "DataFrameGroupBy.backfill()", "intent": "Backward fill the values .", "question_id": 43479}
{"snippet": "DataFrameGroupBy.backfill(limit=None)", "intent": "Backward fill the values . With arguments `limit`.", "question_id": 43480}
{"snippet": "DataFrameGroupBy.bfill()", "intent": "Backward fill the values .", "question_id": 43481}
{"snippet": "DataFrameGroupBy.bfill(limit=None)", "intent": "Backward fill the values . With arguments `limit`.", "question_id": 43482}
{"snippet": "DataFrameGroupBy.bfill()", "intent": "Backward fill the values .", "question_id": 43483}
{"snippet": "DataFrameGroupBy.bfill(limit=None)", "intent": "Backward fill the values . With arguments `limit`.", "question_id": 43484}
{"snippet": "DataFrameGroupBy.bfill()", "intent": "Backward fill the values .", "question_id": 43485}
{"snippet": "DataFrameGroupBy.bfill(limit=None)", "intent": "Backward fill the values . With arguments `limit`.", "question_id": 43486}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`.", "question_id": 43487}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, subplots=True)", "intent": "Make box plots from DataFrameGroupBy data . You can create boxplots for grouped data and show them as separate `subplots` : With arguments `**kwargs`.", "question_id": 43488}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, column=None)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`, `column`.", "question_id": 43489}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, fontsize=None)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`, `fontsize`.", "question_id": 43490}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, rot=0)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`, `rot`.", "question_id": 43491}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, grid=True)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`, `grid`.", "question_id": 43492}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, ax=None)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`, `ax`.", "question_id": 43493}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, figsize=None)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`, `figsize`.", "question_id": 43494}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, layout=None)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`, `layout`.", "question_id": 43495}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, sharex=False)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`, `sharex`.", "question_id": 43496}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`.", "question_id": 43497}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, subplots=True)", "intent": "Make box plots from DataFrameGroupBy data . You can create boxplots for grouped data and show them as separate `subplots` : With arguments `**kwargs`.", "question_id": 43498}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, column=None)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`, `column`.", "question_id": 43499}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, fontsize=None)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`, `fontsize`.", "question_id": 43500}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, rot=0)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`, `rot`.", "question_id": 43501}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, grid=True)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`, `grid`.", "question_id": 43502}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, ax=None)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`, `ax`.", "question_id": 43503}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, figsize=None)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`, `figsize`.", "question_id": 43504}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, layout=None)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`, `layout`.", "question_id": 43505}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, sharex=False)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`, `sharex`.", "question_id": 43506}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`.", "question_id": 43507}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, subplots=True)", "intent": "Make box plots from DataFrameGroupBy data . You can create boxplots for grouped data and show them as separate `subplots` : With arguments `**kwargs`.", "question_id": 43508}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, column=None)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`, `column`.", "question_id": 43509}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, fontsize=None)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`, `fontsize`.", "question_id": 43510}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, rot=0)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`, `rot`.", "question_id": 43511}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, grid=True)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`, `grid`.", "question_id": 43512}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, ax=None)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`, `ax`.", "question_id": 43513}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, figsize=None)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`, `figsize`.", "question_id": 43514}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, layout=None)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`, `layout`.", "question_id": 43515}
{"snippet": "DataFrameGroupBy.boxplot(**kwargs, sharex=False)", "intent": "Make box plots from DataFrameGroupBy data . With arguments `**kwargs`, `sharex`.", "question_id": 43516}
{"snippet": "DataFrameGroupBy.count()", "intent": "Compute count of group , excluding missing values .", "question_id": 43517}
{"snippet": "DataFrameGroupBy.count()", "intent": "Compute count of group , excluding missing values .", "question_id": 43518}
{"snippet": "DataFrameGroupBy.count()", "intent": "Compute count of group , excluding missing values .", "question_id": 43519}
{"snippet": "DataFrameGroupBy.cumcount()", "intent": "Number each item in each group from 0 to the length of that group - 1 .", "question_id": 43520}
{"snippet": "DataFrameGroupBy.cumcount(ascending=True)", "intent": "Number each item in each group from 0 to the length of that group - 1 . With arguments `ascending`.", "question_id": 43521}
{"snippet": "DataFrameGroupBy.cumcount()", "intent": "Number each item in each group from 0 to the length of that group - 1 .", "question_id": 43522}
{"snippet": "DataFrameGroupBy.cumcount(ascending=True)", "intent": "Number each item in each group from 0 to the length of that group - 1 . With arguments `ascending`.", "question_id": 43523}
{"snippet": "DataFrameGroupBy.cumcount()", "intent": "Number each item in each group from 0 to the length of that group - 1 .", "question_id": 43524}
{"snippet": "DataFrameGroupBy.cumcount(ascending=True)", "intent": "Number each item in each group from 0 to the length of that group - 1 . With arguments `ascending`.", "question_id": 43525}
{"snippet": "DataFrameGroupBy.cummax(**kwargs)", "intent": "Cumulative max for each group . With arguments `**kwargs`.", "question_id": 43526}
{"snippet": "DataFrameGroupBy.cummax(**kwargs, axis=0)", "intent": "Cumulative max for each group . With arguments `**kwargs`, `axis`.", "question_id": 43527}
{"snippet": "DataFrameGroupBy.cummax(**kwargs)", "intent": "Cumulative max for each group . With arguments `**kwargs`.", "question_id": 43528}
{"snippet": "DataFrameGroupBy.cummax(**kwargs, axis=0)", "intent": "Cumulative max for each group . With arguments `**kwargs`, `axis`.", "question_id": 43529}
{"snippet": "DataFrameGroupBy.cummax(**kwargs)", "intent": "Cumulative max for each group . With arguments `**kwargs`.", "question_id": 43530}
{"snippet": "DataFrameGroupBy.cummax(**kwargs, axis=0)", "intent": "Cumulative max for each group . With arguments `**kwargs`, `axis`.", "question_id": 43531}
{"snippet": "DataFrameGroupBy.cummin(**kwargs)", "intent": "Cumulative min for each group . With arguments `**kwargs`.", "question_id": 43532}
{"snippet": "DataFrameGroupBy.cummin(**kwargs, axis=0)", "intent": "Cumulative min for each group . With arguments `**kwargs`, `axis`.", "question_id": 43533}
{"snippet": "DataFrameGroupBy.cummin(**kwargs)", "intent": "Cumulative min for each group . With arguments `**kwargs`.", "question_id": 43534}
{"snippet": "DataFrameGroupBy.cummin(**kwargs, axis=0)", "intent": "Cumulative min for each group . With arguments `**kwargs`, `axis`.", "question_id": 43535}
{"snippet": "DataFrameGroupBy.cummin(**kwargs)", "intent": "Cumulative min for each group . With arguments `**kwargs`.", "question_id": 43536}
{"snippet": "DataFrameGroupBy.cummin(**kwargs, axis=0)", "intent": "Cumulative min for each group . With arguments `**kwargs`, `axis`.", "question_id": 43537}
{"snippet": "DataFrameGroupBy.cumprod(*args, **kwargs)", "intent": "Cumulative product for each group . With arguments `*args`, `**kwargs`.", "question_id": 43538}
{"snippet": "DataFrameGroupBy.cumprod(*args, **kwargs, axis=0)", "intent": "Cumulative product for each group . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 43539}
{"snippet": "DataFrameGroupBy.cumprod(*args, **kwargs)", "intent": "Cumulative product for each group . With arguments `*args`, `**kwargs`.", "question_id": 43540}
{"snippet": "DataFrameGroupBy.cumprod(*args, **kwargs, axis=0)", "intent": "Cumulative product for each group . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 43541}
{"snippet": "DataFrameGroupBy.cumprod(*args, **kwargs)", "intent": "Cumulative product for each group . With arguments `*args`, `**kwargs`.", "question_id": 43542}
{"snippet": "DataFrameGroupBy.cumprod(*args, **kwargs, axis=0)", "intent": "Cumulative product for each group . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 43543}
{"snippet": "DataFrameGroupBy.cumsum(*args, **kwargs)", "intent": "Cumulative sum for each group . With arguments `*args`, `**kwargs`.", "question_id": 43544}
{"snippet": "DataFrameGroupBy.cumsum(*args, **kwargs, axis=0)", "intent": "Cumulative sum for each group . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 43545}
{"snippet": "DataFrameGroupBy.cumsum(*args, **kwargs)", "intent": "Cumulative sum for each group . With arguments `*args`, `**kwargs`.", "question_id": 43546}
{"snippet": "DataFrameGroupBy.cumsum(*args, **kwargs, axis=0)", "intent": "Cumulative sum for each group . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 43547}
{"snippet": "DataFrameGroupBy.cumsum(*args, **kwargs)", "intent": "Cumulative sum for each group . With arguments `*args`, `**kwargs`.", "question_id": 43548}
{"snippet": "DataFrameGroupBy.cumsum(*args, **kwargs, axis=0)", "intent": "Cumulative sum for each group . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 43549}
{"snippet": "DataFrameGroupBy.describe(**kwargs)", "intent": "Generate descriptive statistics . With arguments `**kwargs`.", "question_id": 43550}
{"snippet": "DataFrameGroupBy.describe(**kwargs)", "intent": "Generate descriptive statistics . With arguments `**kwargs`.", "question_id": 43551}
{"snippet": "DataFrameGroupBy.describe(**kwargs)", "intent": "Generate descriptive statistics . With arguments `**kwargs`.", "question_id": 43552}
{"snippet": "DataFrameGroupBy.ffill()", "intent": "Forward fill the values .", "question_id": 43553}
{"snippet": "DataFrameGroupBy.ffill(limit=None)", "intent": "Forward fill the values . With arguments `limit`.", "question_id": 43554}
{"snippet": "DataFrameGroupBy.ffill()", "intent": "Forward fill the values .", "question_id": 43555}
{"snippet": "DataFrameGroupBy.ffill(limit=None)", "intent": "Forward fill the values . With arguments `limit`.", "question_id": 43556}
{"snippet": "DataFrameGroupBy.ffill()", "intent": "Forward fill the values .", "question_id": 43557}
{"snippet": "DataFrameGroupBy.ffill(limit=None)", "intent": "Forward fill the values . With arguments `limit`.", "question_id": 43558}
{"snippet": "DataFrameGroupBy.filter(func, *args, **kwargs)", "intent": "Return a copy of a DataFrame excluding filtered elements . Elements from groups are filtered if they do not satisfy the boolean criterion specified by `func` . With arguments `*args`, `**kwargs`.", "question_id": 43559}
{"snippet": "DataFrameGroupBy.filter(func, *args, **kwargs, dropna=True)", "intent": "Return a copy of a DataFrame excluding filtered elements . Elements from groups are filtered if they do not satisfy the boolean criterion specified by `func` . With arguments `*args`, `**kwargs`, `dropna`.", "question_id": 43560}
{"snippet": "DataFrameGroupBy.filter(func, *args, **kwargs)", "intent": "Return a copy of a DataFrame excluding filtered elements . Elements from groups are filtered if they do not satisfy the boolean criterion specified by `func` . With arguments `*args`, `**kwargs`.", "question_id": 43561}
{"snippet": "DataFrameGroupBy.filter(func, *args, **kwargs, dropna=True)", "intent": "Return a copy of a DataFrame excluding filtered elements . Elements from groups are filtered if they do not satisfy the boolean criterion specified by `func` . With arguments `*args`, `**kwargs`, `dropna`.", "question_id": 43562}
{"snippet": "DataFrameGroupBy.filter(func, *args, **kwargs)", "intent": "Return a copy of a DataFrame excluding filtered elements . Elements from groups are filtered if they do not satisfy the boolean criterion specified by `func` . With arguments `*args`, `**kwargs`.", "question_id": 43563}
{"snippet": "DataFrameGroupBy.filter(func, *args, **kwargs, dropna=True)", "intent": "Return a copy of a DataFrame excluding filtered elements . Elements from groups are filtered if they do not satisfy the boolean criterion specified by `func` . With arguments `*args`, `**kwargs`, `dropna`.", "question_id": 43564}
{"snippet": "DataFrameGroupBy.idxmax()", "intent": "Return index of first occurrence of maximum over requested `axis` .", "question_id": 43565}
{"snippet": "DataFrameGroupBy.idxmax(axis=0)", "intent": "Return index of first occurrence of maximum over requested `axis` .", "question_id": 43566}
{"snippet": "DataFrameGroupBy.idxmax(skipna=True)", "intent": "Return index of first occurrence of maximum over requested `axis` . With arguments `skipna`.", "question_id": 43567}
{"snippet": "DataFrameGroupBy.idxmax(axis=0, skipna=True)", "intent": "Return index of first occurrence of maximum over requested `axis` . With arguments `skipna`.", "question_id": 43568}
{"snippet": "DataFrameGroupBy.idxmax()", "intent": "Return index of first occurrence of maximum over requested `axis` .", "question_id": 43569}
{"snippet": "DataFrameGroupBy.idxmax(axis=0)", "intent": "Return index of first occurrence of maximum over requested `axis` .", "question_id": 43570}
{"snippet": "DataFrameGroupBy.idxmax(skipna=True)", "intent": "Return index of first occurrence of maximum over requested `axis` . With arguments `skipna`.", "question_id": 43571}
{"snippet": "DataFrameGroupBy.idxmax(axis=0, skipna=True)", "intent": "Return index of first occurrence of maximum over requested `axis` . With arguments `skipna`.", "question_id": 43572}
{"snippet": "DataFrameGroupBy.idxmax()", "intent": "Return index of first occurrence of maximum over requested `axis` .", "question_id": 43573}
{"snippet": "DataFrameGroupBy.idxmax(axis=0)", "intent": "Return index of first occurrence of maximum over requested `axis` .", "question_id": 43574}
{"snippet": "DataFrameGroupBy.idxmax(skipna=True)", "intent": "Return index of first occurrence of maximum over requested `axis` . With arguments `skipna`.", "question_id": 43575}
{"snippet": "DataFrameGroupBy.idxmax(axis=0, skipna=True)", "intent": "Return index of first occurrence of maximum over requested `axis` . With arguments `skipna`.", "question_id": 43576}
{"snippet": "DataFrameGroupBy.idxmin()", "intent": "Return index of first occurrence of minimum over requested `axis` .", "question_id": 43577}
{"snippet": "DataFrameGroupBy.idxmin(axis=0)", "intent": "Return index of first occurrence of minimum over requested `axis` .", "question_id": 43578}
{"snippet": "DataFrameGroupBy.idxmin(skipna=True)", "intent": "Return index of first occurrence of minimum over requested `axis` . With arguments `skipna`.", "question_id": 43579}
{"snippet": "DataFrameGroupBy.idxmin(axis=0, skipna=True)", "intent": "Return index of first occurrence of minimum over requested `axis` . With arguments `skipna`.", "question_id": 43580}
{"snippet": "DataFrameGroupBy.idxmin()", "intent": "Return index of first occurrence of minimum over requested `axis` .", "question_id": 43581}
{"snippet": "DataFrameGroupBy.idxmin(axis=0)", "intent": "Return index of first occurrence of minimum over requested `axis` .", "question_id": 43582}
{"snippet": "DataFrameGroupBy.idxmin(skipna=True)", "intent": "Return index of first occurrence of minimum over requested `axis` . With arguments `skipna`.", "question_id": 43583}
{"snippet": "DataFrameGroupBy.idxmin(axis=0, skipna=True)", "intent": "Return index of first occurrence of minimum over requested `axis` . With arguments `skipna`.", "question_id": 43584}
{"snippet": "DataFrameGroupBy.idxmin()", "intent": "Return index of first occurrence of minimum over requested `axis` .", "question_id": 43585}
{"snippet": "DataFrameGroupBy.idxmin(axis=0)", "intent": "Return index of first occurrence of minimum over requested `axis` .", "question_id": 43586}
{"snippet": "DataFrameGroupBy.idxmin(skipna=True)", "intent": "Return index of first occurrence of minimum over requested `axis` . With arguments `skipna`.", "question_id": 43587}
{"snippet": "DataFrameGroupBy.idxmin(axis=0, skipna=True)", "intent": "Return index of first occurrence of minimum over requested `axis` . With arguments `skipna`.", "question_id": 43588}
{"snippet": "DataFrameGroupBy.nunique()", "intent": "Return DataFrame with counts of unique elements in each position .", "question_id": 43589}
{"snippet": "DataFrameGroupBy.nunique(dropna=True)", "intent": "Return DataFrame with counts of unique elements in each position . With arguments `dropna`.", "question_id": 43590}
{"snippet": "DataFrameGroupBy.nunique()", "intent": "Return DataFrame with counts of unique elements in each position .", "question_id": 43591}
{"snippet": "DataFrameGroupBy.nunique(dropna=True)", "intent": "Return DataFrame with counts of unique elements in each position . With arguments `dropna`.", "question_id": 43592}
{"snippet": "DataFrameGroupBy.nunique()", "intent": "Return DataFrame with counts of unique elements in each position .", "question_id": 43593}
{"snippet": "DataFrameGroupBy.nunique(dropna=True)", "intent": "Return DataFrame with counts of unique elements in each position . With arguments `dropna`.", "question_id": 43594}
{"snippet": "DataFrameGroupBy.pad()", "intent": "Forward fill the values .", "question_id": 43595}
{"snippet": "DataFrameGroupBy.pad(limit=None)", "intent": "Forward fill the values . With arguments `limit`.", "question_id": 43596}
{"snippet": "DataFrameGroupBy.pad()", "intent": "Forward fill the values .", "question_id": 43597}
{"snippet": "DataFrameGroupBy.pad(limit=None)", "intent": "Forward fill the values . With arguments `limit`.", "question_id": 43598}
{"snippet": "DataFrameGroupBy.pad()", "intent": "Forward fill the values .", "question_id": 43599}
{"snippet": "DataFrameGroupBy.pad(limit=None)", "intent": "Forward fill the values . With arguments `limit`.", "question_id": 43600}
{"snippet": "DataFrameGroupBy.pct_change()", "intent": "Calculate pct_change of each value to previous entry in group .", "question_id": 43601}
{"snippet": "DataFrameGroupBy.pct_change(periods=1)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`.", "question_id": 43602}
{"snippet": "DataFrameGroupBy.pct_change(fill_method='pad')", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `fill_method`.", "question_id": 43603}
{"snippet": "DataFrameGroupBy.pct_change(limit=None)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `limit`.", "question_id": 43604}
{"snippet": "DataFrameGroupBy.pct_change(freq=None)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `freq`.", "question_id": 43605}
{"snippet": "DataFrameGroupBy.pct_change(axis=0)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `axis`.", "question_id": 43606}
{"snippet": "DataFrameGroupBy.pct_change(periods=1, fill_method='pad')", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`, `fill_method`.", "question_id": 43607}
{"snippet": "DataFrameGroupBy.pct_change(periods=1, limit=None)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`, `limit`.", "question_id": 43608}
{"snippet": "DataFrameGroupBy.pct_change(periods=1, freq=None)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`, `freq`.", "question_id": 43609}
{"snippet": "DataFrameGroupBy.pct_change(periods=1, axis=0)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`, `axis`.", "question_id": 43610}
{"snippet": "DataFrameGroupBy.pct_change()", "intent": "Calculate pct_change of each value to previous entry in group .", "question_id": 43611}
{"snippet": "DataFrameGroupBy.pct_change(periods=1)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`.", "question_id": 43612}
{"snippet": "DataFrameGroupBy.pct_change(fill_method='pad')", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `fill_method`.", "question_id": 43613}
{"snippet": "DataFrameGroupBy.pct_change(limit=None)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `limit`.", "question_id": 43614}
{"snippet": "DataFrameGroupBy.pct_change(freq=None)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `freq`.", "question_id": 43615}
{"snippet": "DataFrameGroupBy.pct_change(axis=0)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `axis`.", "question_id": 43616}
{"snippet": "DataFrameGroupBy.pct_change(periods=1, fill_method='pad')", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`, `fill_method`.", "question_id": 43617}
{"snippet": "DataFrameGroupBy.pct_change(periods=1, limit=None)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`, `limit`.", "question_id": 43618}
{"snippet": "DataFrameGroupBy.pct_change(periods=1, freq=None)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`, `freq`.", "question_id": 43619}
{"snippet": "DataFrameGroupBy.pct_change(periods=1, axis=0)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`, `axis`.", "question_id": 43620}
{"snippet": "DataFrameGroupBy.pct_change()", "intent": "Calculate pct_change of each value to previous entry in group .", "question_id": 43621}
{"snippet": "DataFrameGroupBy.pct_change(periods=1)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`.", "question_id": 43622}
{"snippet": "DataFrameGroupBy.pct_change(fill_method='pad')", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `fill_method`.", "question_id": 43623}
{"snippet": "DataFrameGroupBy.pct_change(limit=None)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `limit`.", "question_id": 43624}
{"snippet": "DataFrameGroupBy.pct_change(freq=None)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `freq`.", "question_id": 43625}
{"snippet": "DataFrameGroupBy.pct_change(axis=0)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `axis`.", "question_id": 43626}
{"snippet": "DataFrameGroupBy.pct_change(periods=1, fill_method='pad')", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`, `fill_method`.", "question_id": 43627}
{"snippet": "DataFrameGroupBy.pct_change(periods=1, limit=None)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`, `limit`.", "question_id": 43628}
{"snippet": "DataFrameGroupBy.pct_change(periods=1, freq=None)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`, `freq`.", "question_id": 43629}
{"snippet": "DataFrameGroupBy.pct_change(periods=1, axis=0)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`, `axis`.", "question_id": 43630}
{"snippet": "DataFrameGroupBy.quantile()", "intent": "Return group values at the given quantile , a la numpy.percentile .", "question_id": 43631}
{"snippet": "DataFrameGroupBy.quantile(q=0.5)", "intent": "Return group values at the given quantile , a la numpy.percentile . With arguments `q`.", "question_id": 43632}
{"snippet": "DataFrameGroupBy.quantile(interpolation='linear')", "intent": "Return group values at the given quantile , a la numpy.percentile . With arguments `interpolation`.", "question_id": 43633}
{"snippet": "DataFrameGroupBy.quantile(q=0.5, interpolation='linear')", "intent": "Return group values at the given quantile , a la numpy.percentile . With arguments `q`, `interpolation`.", "question_id": 43634}
{"snippet": "DataFrameGroupBy.quantile()", "intent": "Return group values at the given quantile , a la numpy.percentile .", "question_id": 43635}
{"snippet": "DataFrameGroupBy.quantile(q=0.5)", "intent": "Return group values at the given quantile , a la numpy.percentile . With arguments `q`.", "question_id": 43636}
{"snippet": "DataFrameGroupBy.quantile(interpolation='linear')", "intent": "Return group values at the given quantile , a la numpy.percentile . With arguments `interpolation`.", "question_id": 43637}
{"snippet": "DataFrameGroupBy.quantile(q=0.5, interpolation='linear')", "intent": "Return group values at the given quantile , a la numpy.percentile . With arguments `q`, `interpolation`.", "question_id": 43638}
{"snippet": "DataFrameGroupBy.quantile()", "intent": "Return group values at the given quantile , a la numpy.percentile .", "question_id": 43639}
{"snippet": "DataFrameGroupBy.quantile(q=0.5)", "intent": "Return group values at the given quantile , a la numpy.percentile . With arguments `q`.", "question_id": 43640}
{"snippet": "DataFrameGroupBy.quantile(interpolation='linear')", "intent": "Return group values at the given quantile , a la numpy.percentile . With arguments `interpolation`.", "question_id": 43641}
{"snippet": "DataFrameGroupBy.quantile(q=0.5, interpolation='linear')", "intent": "Return group values at the given quantile , a la numpy.percentile . With arguments `q`, `interpolation`.", "question_id": 43642}
{"snippet": "DataFrameGroupBy.rank()", "intent": "Provide the rank of values within each group .", "question_id": 43643}
{"snippet": "DataFrameGroupBy.rank(method='average')", "intent": "Provide the rank of values within each group . With arguments `method`.", "question_id": 43644}
{"snippet": "DataFrameGroupBy.rank(ascending=True)", "intent": "Provide the rank of values within each group . With arguments `ascending`.", "question_id": 43645}
{"snippet": "DataFrameGroupBy.rank(na_option='keep')", "intent": "Provide the rank of values within each group . With arguments `na_option`.", "question_id": 43646}
{"snippet": "DataFrameGroupBy.rank(pct=False)", "intent": "Provide the rank of values within each group . With arguments `pct`.", "question_id": 43647}
{"snippet": "DataFrameGroupBy.rank(axis=0)", "intent": "Provide the rank of values within each group . With arguments `axis`.", "question_id": 43648}
{"snippet": "DataFrameGroupBy.rank(method='average', ascending=True)", "intent": "Provide the rank of values within each group . With arguments `method`, `ascending`.", "question_id": 43649}
{"snippet": "DataFrameGroupBy.rank(method='average', na_option='keep')", "intent": "Provide the rank of values within each group . With arguments `method`, `na_option`.", "question_id": 43650}
{"snippet": "DataFrameGroupBy.rank(method='average', pct=False)", "intent": "Provide the rank of values within each group . With arguments `method`, `pct`.", "question_id": 43651}
{"snippet": "DataFrameGroupBy.rank(method='average', axis=0)", "intent": "Provide the rank of values within each group . With arguments `method`, `axis`.", "question_id": 43652}
{"snippet": "DataFrameGroupBy.rank()", "intent": "Provide the rank of values within each group .", "question_id": 43653}
{"snippet": "DataFrameGroupBy.rank(method='average')", "intent": "Provide the rank of values within each group . With arguments `method`.", "question_id": 43654}
{"snippet": "DataFrameGroupBy.rank(ascending=True)", "intent": "Provide the rank of values within each group . With arguments `ascending`.", "question_id": 43655}
{"snippet": "DataFrameGroupBy.rank(na_option='keep')", "intent": "Provide the rank of values within each group . With arguments `na_option`.", "question_id": 43656}
{"snippet": "DataFrameGroupBy.rank(pct=False)", "intent": "Provide the rank of values within each group . With arguments `pct`.", "question_id": 43657}
{"snippet": "DataFrameGroupBy.rank(axis=0)", "intent": "Provide the rank of values within each group . With arguments `axis`.", "question_id": 43658}
{"snippet": "DataFrameGroupBy.rank(method='average', ascending=True)", "intent": "Provide the rank of values within each group . With arguments `method`, `ascending`.", "question_id": 43659}
{"snippet": "DataFrameGroupBy.rank(method='average', na_option='keep')", "intent": "Provide the rank of values within each group . With arguments `method`, `na_option`.", "question_id": 43660}
{"snippet": "DataFrameGroupBy.rank(method='average', pct=False)", "intent": "Provide the rank of values within each group . With arguments `method`, `pct`.", "question_id": 43661}
{"snippet": "DataFrameGroupBy.rank(method='average', axis=0)", "intent": "Provide the rank of values within each group . With arguments `method`, `axis`.", "question_id": 43662}
{"snippet": "DataFrameGroupBy.rank()", "intent": "Provide the rank of values within each group .", "question_id": 43663}
{"snippet": "DataFrameGroupBy.rank(method='average')", "intent": "Provide the rank of values within each group . With arguments `method`.", "question_id": 43664}
{"snippet": "DataFrameGroupBy.rank(ascending=True)", "intent": "Provide the rank of values within each group . With arguments `ascending`.", "question_id": 43665}
{"snippet": "DataFrameGroupBy.rank(na_option='keep')", "intent": "Provide the rank of values within each group . With arguments `na_option`.", "question_id": 43666}
{"snippet": "DataFrameGroupBy.rank(pct=False)", "intent": "Provide the rank of values within each group . With arguments `pct`.", "question_id": 43667}
{"snippet": "DataFrameGroupBy.rank(axis=0)", "intent": "Provide the rank of values within each group . With arguments `axis`.", "question_id": 43668}
{"snippet": "DataFrameGroupBy.rank(method='average', ascending=True)", "intent": "Provide the rank of values within each group . With arguments `method`, `ascending`.", "question_id": 43669}
{"snippet": "DataFrameGroupBy.rank(method='average', na_option='keep')", "intent": "Provide the rank of values within each group . With arguments `method`, `na_option`.", "question_id": 43670}
{"snippet": "DataFrameGroupBy.rank(method='average', pct=False)", "intent": "Provide the rank of values within each group . With arguments `method`, `pct`.", "question_id": 43671}
{"snippet": "DataFrameGroupBy.rank(method='average', axis=0)", "intent": "Provide the rank of values within each group . With arguments `method`, `axis`.", "question_id": 43672}
{"snippet": "DataFrameGroupBy.resample(rule, *args, **kwargs)", "intent": "Provide resampling when using a TimeGrouper . With arguments `rule`, `*args`, `**kwargs`.", "question_id": 43673}
{"snippet": "DataFrameGroupBy.resample(rule, *args, **kwargs)", "intent": "Provide resampling when using a TimeGrouper . With arguments `rule`, `*args`, `**kwargs`.", "question_id": 43674}
{"snippet": "DataFrameGroupBy.resample(rule, *args, **kwargs)", "intent": "Provide resampling when using a TimeGrouper . With arguments `rule`, `*args`, `**kwargs`.", "question_id": 43675}
{"snippet": "DataFrameGroupBy.sample()", "intent": "Return a random sample of items from each group .", "question_id": 43676}
{"snippet": "DataFrameGroupBy.sample(n=None)", "intent": "Return a random sample of items from each group . With arguments `n`.", "question_id": 43677}
{"snippet": "DataFrameGroupBy.sample(frac=None)", "intent": "Return a random sample of items from each group . Set `frac` to sample fixed proportions rather than counts :", "question_id": 43678}
{"snippet": "DataFrameGroupBy.sample(replace=False)", "intent": "Return a random sample of items from each group . With arguments `replace`.", "question_id": 43679}
{"snippet": "DataFrameGroupBy.sample(weights=None)", "intent": "Return a random sample of items from each group . Control sample probabilities within groups by setting `weights` :", "question_id": 43680}
{"snippet": "DataFrameGroupBy.sample(random_state=None)", "intent": "Return a random sample of items from each group . You can use `random_state` for reproducibility .", "question_id": 43681}
{"snippet": "DataFrameGroupBy.sample(n=None, frac=None)", "intent": "Return a random sample of items from each group . Set `frac` to sample fixed proportions rather than counts : With arguments `n`.", "question_id": 43682}
{"snippet": "DataFrameGroupBy.sample(n=None, replace=False)", "intent": "Return a random sample of items from each group . With arguments `n`, `replace`.", "question_id": 43683}
{"snippet": "DataFrameGroupBy.sample(n=None, weights=None)", "intent": "Return a random sample of items from each group . Control sample probabilities within groups by setting `weights` : With arguments `n`.", "question_id": 43684}
{"snippet": "DataFrameGroupBy.sample(n=None, random_state=None)", "intent": "Return a random sample of items from each group . You can use `random_state` for reproducibility . With arguments `n`.", "question_id": 43685}
{"snippet": "DataFrameGroupBy.sample()", "intent": "Return a random sample of items from each group .", "question_id": 43686}
{"snippet": "DataFrameGroupBy.sample(n=None)", "intent": "Return a random sample of items from each group . With arguments `n`.", "question_id": 43687}
{"snippet": "DataFrameGroupBy.sample(frac=None)", "intent": "Return a random sample of items from each group . Set `frac` to sample fixed proportions rather than counts :", "question_id": 43688}
{"snippet": "DataFrameGroupBy.sample(replace=False)", "intent": "Return a random sample of items from each group . With arguments `replace`.", "question_id": 43689}
{"snippet": "DataFrameGroupBy.sample(weights=None)", "intent": "Return a random sample of items from each group . Control sample probabilities within groups by setting `weights` :", "question_id": 43690}
{"snippet": "DataFrameGroupBy.sample(random_state=None)", "intent": "Return a random sample of items from each group . You can use `random_state` for reproducibility .", "question_id": 43691}
{"snippet": "DataFrameGroupBy.sample(n=None, frac=None)", "intent": "Return a random sample of items from each group . Set `frac` to sample fixed proportions rather than counts : With arguments `n`.", "question_id": 43692}
{"snippet": "DataFrameGroupBy.sample(n=None, replace=False)", "intent": "Return a random sample of items from each group . With arguments `n`, `replace`.", "question_id": 43693}
{"snippet": "DataFrameGroupBy.sample(n=None, weights=None)", "intent": "Return a random sample of items from each group . Control sample probabilities within groups by setting `weights` : With arguments `n`.", "question_id": 43694}
{"snippet": "DataFrameGroupBy.sample(n=None, random_state=None)", "intent": "Return a random sample of items from each group . You can use `random_state` for reproducibility . With arguments `n`.", "question_id": 43695}
{"snippet": "DataFrameGroupBy.sample()", "intent": "Return a random sample of items from each group .", "question_id": 43696}
{"snippet": "DataFrameGroupBy.sample(n=None)", "intent": "Return a random sample of items from each group . With arguments `n`.", "question_id": 43697}
{"snippet": "DataFrameGroupBy.sample(frac=None)", "intent": "Return a random sample of items from each group . Set `frac` to sample fixed proportions rather than counts :", "question_id": 43698}
{"snippet": "DataFrameGroupBy.sample(replace=False)", "intent": "Return a random sample of items from each group . With arguments `replace`.", "question_id": 43699}
{"snippet": "DataFrameGroupBy.sample(weights=None)", "intent": "Return a random sample of items from each group . Control sample probabilities within groups by setting `weights` :", "question_id": 43700}
{"snippet": "DataFrameGroupBy.sample(random_state=None)", "intent": "Return a random sample of items from each group . You can use `random_state` for reproducibility .", "question_id": 43701}
{"snippet": "DataFrameGroupBy.sample(n=None, frac=None)", "intent": "Return a random sample of items from each group . Set `frac` to sample fixed proportions rather than counts : With arguments `n`.", "question_id": 43702}
{"snippet": "DataFrameGroupBy.sample(n=None, replace=False)", "intent": "Return a random sample of items from each group . With arguments `n`, `replace`.", "question_id": 43703}
{"snippet": "DataFrameGroupBy.sample(n=None, weights=None)", "intent": "Return a random sample of items from each group . Control sample probabilities within groups by setting `weights` : With arguments `n`.", "question_id": 43704}
{"snippet": "DataFrameGroupBy.sample(n=None, random_state=None)", "intent": "Return a random sample of items from each group . You can use `random_state` for reproducibility . With arguments `n`.", "question_id": 43705}
{"snippet": "DataFrameGroupBy.shift()", "intent": "Shift each group by `periods` observations .", "question_id": 43706}
{"snippet": "DataFrameGroupBy.shift(periods=1)", "intent": "Shift each group by `periods` observations .", "question_id": 43707}
{"snippet": "DataFrameGroupBy.shift(freq=None)", "intent": "Shift each group by `periods` observations . If `freq` is passed , the index will be increased using the periods and the freq .", "question_id": 43708}
{"snippet": "DataFrameGroupBy.shift(axis=0)", "intent": "Shift each group by `periods` observations . With arguments `axis`.", "question_id": 43709}
{"snippet": "DataFrameGroupBy.shift(fill_value=None)", "intent": "Shift each group by `periods` observations . With arguments `fill_value`.", "question_id": 43710}
{"snippet": "DataFrameGroupBy.shift(periods=1, freq=None)", "intent": "Shift each group by `periods` observations . If `freq` is passed , the index will be increased using the periods and the freq .", "question_id": 43711}
{"snippet": "DataFrameGroupBy.shift(periods=1, axis=0)", "intent": "Shift each group by `periods` observations . With arguments `axis`.", "question_id": 43712}
{"snippet": "DataFrameGroupBy.shift(periods=1, fill_value=None)", "intent": "Shift each group by `periods` observations . With arguments `fill_value`.", "question_id": 43713}
{"snippet": "DataFrameGroupBy.shift(freq=None, axis=0)", "intent": "Shift each group by `periods` observations . If `freq` is passed , the index will be increased using the periods and the freq . With arguments `axis`.", "question_id": 43714}
{"snippet": "DataFrameGroupBy.shift(freq=None, fill_value=None)", "intent": "Shift each group by `periods` observations . If `freq` is passed , the index will be increased using the periods and the freq . With arguments `fill_value`.", "question_id": 43715}
{"snippet": "DataFrameGroupBy.shift()", "intent": "Shift each group by `periods` observations .", "question_id": 43716}
{"snippet": "DataFrameGroupBy.shift(periods=1)", "intent": "Shift each group by `periods` observations .", "question_id": 43717}
{"snippet": "DataFrameGroupBy.shift(freq=None)", "intent": "Shift each group by `periods` observations . If `freq` is passed , the index will be increased using the periods and the freq .", "question_id": 43718}
{"snippet": "DataFrameGroupBy.shift(axis=0)", "intent": "Shift each group by `periods` observations . With arguments `axis`.", "question_id": 43719}
{"snippet": "DataFrameGroupBy.shift(fill_value=None)", "intent": "Shift each group by `periods` observations . With arguments `fill_value`.", "question_id": 43720}
{"snippet": "DataFrameGroupBy.shift(periods=1, freq=None)", "intent": "Shift each group by `periods` observations . If `freq` is passed , the index will be increased using the periods and the freq .", "question_id": 43721}
{"snippet": "DataFrameGroupBy.shift(periods=1, axis=0)", "intent": "Shift each group by `periods` observations . With arguments `axis`.", "question_id": 43722}
{"snippet": "DataFrameGroupBy.shift(periods=1, fill_value=None)", "intent": "Shift each group by `periods` observations . With arguments `fill_value`.", "question_id": 43723}
{"snippet": "DataFrameGroupBy.shift(freq=None, axis=0)", "intent": "Shift each group by `periods` observations . If `freq` is passed , the index will be increased using the periods and the freq . With arguments `axis`.", "question_id": 43724}
{"snippet": "DataFrameGroupBy.shift(freq=None, fill_value=None)", "intent": "Shift each group by `periods` observations . If `freq` is passed , the index will be increased using the periods and the freq . With arguments `fill_value`.", "question_id": 43725}
{"snippet": "DataFrameGroupBy.shift()", "intent": "Shift each group by `periods` observations .", "question_id": 43726}
{"snippet": "DataFrameGroupBy.shift(periods=1)", "intent": "Shift each group by `periods` observations .", "question_id": 43727}
{"snippet": "DataFrameGroupBy.shift(freq=None)", "intent": "Shift each group by `periods` observations . If `freq` is passed , the index will be increased using the periods and the freq .", "question_id": 43728}
{"snippet": "DataFrameGroupBy.shift(axis=0)", "intent": "Shift each group by `periods` observations . With arguments `axis`.", "question_id": 43729}
{"snippet": "DataFrameGroupBy.shift(fill_value=None)", "intent": "Shift each group by `periods` observations . With arguments `fill_value`.", "question_id": 43730}
{"snippet": "DataFrameGroupBy.shift(periods=1, freq=None)", "intent": "Shift each group by `periods` observations . If `freq` is passed , the index will be increased using the periods and the freq .", "question_id": 43731}
{"snippet": "DataFrameGroupBy.shift(periods=1, axis=0)", "intent": "Shift each group by `periods` observations . With arguments `axis`.", "question_id": 43732}
{"snippet": "DataFrameGroupBy.shift(periods=1, fill_value=None)", "intent": "Shift each group by `periods` observations . With arguments `fill_value`.", "question_id": 43733}
{"snippet": "DataFrameGroupBy.shift(freq=None, axis=0)", "intent": "Shift each group by `periods` observations . If `freq` is passed , the index will be increased using the periods and the freq . With arguments `axis`.", "question_id": 43734}
{"snippet": "DataFrameGroupBy.shift(freq=None, fill_value=None)", "intent": "Shift each group by `periods` observations . If `freq` is passed , the index will be increased using the periods and the freq . With arguments `fill_value`.", "question_id": 43735}
{"snippet": "DataFrameGroupBy.size()", "intent": "Compute group sizes .", "question_id": 43736}
{"snippet": "DataFrameGroupBy.size()", "intent": "Compute group sizes .", "question_id": 43737}
{"snippet": "DataFrameGroupBy.size()", "intent": "Compute group sizes .", "question_id": 43738}
{"snippet": "DataFrameGroupBy.transform(func, *args, **kwargs)", "intent": "Call function producing a like-indexed DataFrame on each group and return a DataFrame having the same indexes as the original object filled with the transformed values With arguments `func`, `*args`, `**kwargs`.", "question_id": 43739}
{"snippet": "DataFrameGroupBy.transform(func, *args, **kwargs, engine=None)", "intent": "Call function producing a like-indexed DataFrame on each group and return a DataFrame having the same indexes as the original object filled with the transformed values With arguments `func`, `*args`, `**kwargs`, `engine`.", "question_id": 43740}
{"snippet": "DataFrameGroupBy.transform(func, *args, **kwargs, engine_kwargs=None)", "intent": "Call function producing a like-indexed DataFrame on each group and return a DataFrame having the same indexes as the original object filled with the transformed values With arguments `func`, `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 43741}
{"snippet": "DataFrameGroupBy.transform(func, *args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Call function producing a like-indexed DataFrame on each group and return a DataFrame having the same indexes as the original object filled with the transformed values With arguments `func`, `*args`, `**kwargs`, `engine`, `engine_kwargs`.", "question_id": 43742}
{"snippet": "DataFrameGroupBy.transform(func, *args, **kwargs)", "intent": "Call function producing a like-indexed DataFrame on each group and return a DataFrame having the same indexes as the original object filled with the transformed values With arguments `func`, `*args`, `**kwargs`.", "question_id": 43743}
{"snippet": "DataFrameGroupBy.transform(func, *args, **kwargs, engine=None)", "intent": "Call function producing a like-indexed DataFrame on each group and return a DataFrame having the same indexes as the original object filled with the transformed values With arguments `func`, `*args`, `**kwargs`, `engine`.", "question_id": 43744}
{"snippet": "DataFrameGroupBy.transform(func, *args, **kwargs, engine_kwargs=None)", "intent": "Call function producing a like-indexed DataFrame on each group and return a DataFrame having the same indexes as the original object filled with the transformed values With arguments `func`, `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 43745}
{"snippet": "DataFrameGroupBy.transform(func, *args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Call function producing a like-indexed DataFrame on each group and return a DataFrame having the same indexes as the original object filled with the transformed values With arguments `func`, `*args`, `**kwargs`, `engine`, `engine_kwargs`.", "question_id": 43746}
{"snippet": "DataFrameGroupBy.transform(func, *args, **kwargs)", "intent": "Call function producing a like-indexed DataFrame on each group and return a DataFrame having the same indexes as the original object filled with the transformed values With arguments `func`, `*args`, `**kwargs`.", "question_id": 43747}
{"snippet": "DataFrameGroupBy.transform(func, *args, **kwargs, engine=None)", "intent": "Call function producing a like-indexed DataFrame on each group and return a DataFrame having the same indexes as the original object filled with the transformed values With arguments `func`, `*args`, `**kwargs`, `engine`.", "question_id": 43748}
{"snippet": "DataFrameGroupBy.transform(func, *args, **kwargs, engine_kwargs=None)", "intent": "Call function producing a like-indexed DataFrame on each group and return a DataFrame having the same indexes as the original object filled with the transformed values With arguments `func`, `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 43749}
{"snippet": "DataFrameGroupBy.transform(func, *args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Call function producing a like-indexed DataFrame on each group and return a DataFrame having the same indexes as the original object filled with the transformed values With arguments `func`, `*args`, `**kwargs`, `engine`, `engine_kwargs`.", "question_id": 43750}
{"snippet": "GroupBy.__iter__()", "intent": "Groupby iterator .", "question_id": 43751}
{"snippet": "GroupBy.__iter__()", "intent": "Groupby iterator .", "question_id": 43752}
{"snippet": "GroupBy.__iter__()", "intent": "Groupby iterator .", "question_id": 43753}
{"snippet": "GroupBy.all()", "intent": "Return True if all values in the group are truthful , else False .", "question_id": 43754}
{"snippet": "GroupBy.all(skipna=True)", "intent": "Return True if all values in the group are truthful , else False . With arguments `skipna`.", "question_id": 43755}
{"snippet": "GroupBy.all()", "intent": "Return True if all values in the group are truthful , else False .", "question_id": 43756}
{"snippet": "GroupBy.all(skipna=True)", "intent": "Return True if all values in the group are truthful , else False . With arguments `skipna`.", "question_id": 43757}
{"snippet": "GroupBy.all()", "intent": "Return True if all values in the group are truthful , else False .", "question_id": 43758}
{"snippet": "GroupBy.all(skipna=True)", "intent": "Return True if all values in the group are truthful , else False . With arguments `skipna`.", "question_id": 43759}
{"snippet": "GroupBy.any()", "intent": "Return True if any value in the group is truthful , else False .", "question_id": 43760}
{"snippet": "GroupBy.any(skipna=True)", "intent": "Return True if any value in the group is truthful , else False . With arguments `skipna`.", "question_id": 43761}
{"snippet": "GroupBy.any()", "intent": "Return True if any value in the group is truthful , else False .", "question_id": 43762}
{"snippet": "GroupBy.any(skipna=True)", "intent": "Return True if any value in the group is truthful , else False . With arguments `skipna`.", "question_id": 43763}
{"snippet": "GroupBy.any()", "intent": "Return True if any value in the group is truthful , else False .", "question_id": 43764}
{"snippet": "GroupBy.any(skipna=True)", "intent": "Return True if any value in the group is truthful , else False . With arguments `skipna`.", "question_id": 43765}
{"snippet": "GroupBy.apply(func, *args, **kwargs)", "intent": "Apply function `func` group-wise and combine the results together . With arguments `*args`, `**kwargs`.", "question_id": 43766}
{"snippet": "GroupBy.apply(func, *args, **kwargs)", "intent": "Apply function `func` group-wise and combine the results together . With arguments `*args`, `**kwargs`.", "question_id": 43767}
{"snippet": "GroupBy.apply(func, *args, **kwargs)", "intent": "Apply function `func` group-wise and combine the results together . With arguments `*args`, `**kwargs`.", "question_id": 43768}
{"snippet": "GroupBy.backfill()", "intent": "Backward fill the values .", "question_id": 43769}
{"snippet": "GroupBy.backfill(limit=None)", "intent": "Backward fill the values . With arguments `limit`.", "question_id": 43770}
{"snippet": "GroupBy.backfill()", "intent": "Backward fill the values .", "question_id": 43771}
{"snippet": "GroupBy.backfill(limit=None)", "intent": "Backward fill the values . With arguments `limit`.", "question_id": 43772}
{"snippet": "GroupBy.backfill()", "intent": "Backward fill the values .", "question_id": 43773}
{"snippet": "GroupBy.backfill(limit=None)", "intent": "Backward fill the values . With arguments `limit`.", "question_id": 43774}
{"snippet": "GroupBy.bfill()", "intent": "Backward fill the values .", "question_id": 43775}
{"snippet": "GroupBy.bfill(limit=None)", "intent": "Backward fill the values . With arguments `limit`.", "question_id": 43776}
{"snippet": "GroupBy.bfill()", "intent": "Backward fill the values .", "question_id": 43777}
{"snippet": "GroupBy.bfill(limit=None)", "intent": "Backward fill the values . With arguments `limit`.", "question_id": 43778}
{"snippet": "GroupBy.bfill()", "intent": "Backward fill the values .", "question_id": 43779}
{"snippet": "GroupBy.bfill(limit=None)", "intent": "Backward fill the values . With arguments `limit`.", "question_id": 43780}
{"snippet": "GroupBy.count()", "intent": "Compute count of group , excluding missing values .", "question_id": 43781}
{"snippet": "GroupBy.count()", "intent": "Compute count of group , excluding missing values .", "question_id": 43782}
{"snippet": "GroupBy.count()", "intent": "Compute count of group , excluding missing values .", "question_id": 43783}
{"snippet": "GroupBy.cumcount()", "intent": "Number each item in each group from 0 to the length of that group - 1 .", "question_id": 43784}
{"snippet": "GroupBy.cumcount(ascending=True)", "intent": "Number each item in each group from 0 to the length of that group - 1 . With arguments `ascending`.", "question_id": 43785}
{"snippet": "GroupBy.cumcount()", "intent": "Number each item in each group from 0 to the length of that group - 1 .", "question_id": 43786}
{"snippet": "GroupBy.cumcount(ascending=True)", "intent": "Number each item in each group from 0 to the length of that group - 1 . With arguments `ascending`.", "question_id": 43787}
{"snippet": "GroupBy.cumcount()", "intent": "Number each item in each group from 0 to the length of that group - 1 .", "question_id": 43788}
{"snippet": "GroupBy.cumcount(ascending=True)", "intent": "Number each item in each group from 0 to the length of that group - 1 . With arguments `ascending`.", "question_id": 43789}
{"snippet": "GroupBy.cummax(**kwargs)", "intent": "Cumulative max for each group . With arguments `**kwargs`.", "question_id": 43790}
{"snippet": "GroupBy.cummax(**kwargs, axis=0)", "intent": "Cumulative max for each group . With arguments `**kwargs`, `axis`.", "question_id": 43791}
{"snippet": "GroupBy.cummax(**kwargs)", "intent": "Cumulative max for each group . With arguments `**kwargs`.", "question_id": 43792}
{"snippet": "GroupBy.cummax(**kwargs, axis=0)", "intent": "Cumulative max for each group . With arguments `**kwargs`, `axis`.", "question_id": 43793}
{"snippet": "GroupBy.cummax(**kwargs)", "intent": "Cumulative max for each group . With arguments `**kwargs`.", "question_id": 43794}
{"snippet": "GroupBy.cummax(**kwargs, axis=0)", "intent": "Cumulative max for each group . With arguments `**kwargs`, `axis`.", "question_id": 43795}
{"snippet": "GroupBy.cummin(**kwargs)", "intent": "Cumulative min for each group . With arguments `**kwargs`.", "question_id": 43796}
{"snippet": "GroupBy.cummin(**kwargs, axis=0)", "intent": "Cumulative min for each group . With arguments `**kwargs`, `axis`.", "question_id": 43797}
{"snippet": "GroupBy.cummin(**kwargs)", "intent": "Cumulative min for each group . With arguments `**kwargs`.", "question_id": 43798}
{"snippet": "GroupBy.cummin(**kwargs, axis=0)", "intent": "Cumulative min for each group . With arguments `**kwargs`, `axis`.", "question_id": 43799}
{"snippet": "GroupBy.cummin(**kwargs)", "intent": "Cumulative min for each group . With arguments `**kwargs`.", "question_id": 43800}
{"snippet": "GroupBy.cummin(**kwargs, axis=0)", "intent": "Cumulative min for each group . With arguments `**kwargs`, `axis`.", "question_id": 43801}
{"snippet": "GroupBy.cumprod(*args, **kwargs)", "intent": "Cumulative product for each group . With arguments `*args`, `**kwargs`.", "question_id": 43802}
{"snippet": "GroupBy.cumprod(*args, **kwargs, axis=0)", "intent": "Cumulative product for each group . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 43803}
{"snippet": "GroupBy.cumprod(*args, **kwargs)", "intent": "Cumulative product for each group . With arguments `*args`, `**kwargs`.", "question_id": 43804}
{"snippet": "GroupBy.cumprod(*args, **kwargs, axis=0)", "intent": "Cumulative product for each group . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 43805}
{"snippet": "GroupBy.cumprod(*args, **kwargs)", "intent": "Cumulative product for each group . With arguments `*args`, `**kwargs`.", "question_id": 43806}
{"snippet": "GroupBy.cumprod(*args, **kwargs, axis=0)", "intent": "Cumulative product for each group . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 43807}
{"snippet": "GroupBy.cumsum(*args, **kwargs)", "intent": "Cumulative sum for each group . With arguments `*args`, `**kwargs`.", "question_id": 43808}
{"snippet": "GroupBy.cumsum(*args, **kwargs, axis=0)", "intent": "Cumulative sum for each group . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 43809}
{"snippet": "GroupBy.cumsum(*args, **kwargs)", "intent": "Cumulative sum for each group . With arguments `*args`, `**kwargs`.", "question_id": 43810}
{"snippet": "GroupBy.cumsum(*args, **kwargs, axis=0)", "intent": "Cumulative sum for each group . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 43811}
{"snippet": "GroupBy.cumsum(*args, **kwargs)", "intent": "Cumulative sum for each group . With arguments `*args`, `**kwargs`.", "question_id": 43812}
{"snippet": "GroupBy.cumsum(*args, **kwargs, axis=0)", "intent": "Cumulative sum for each group . With arguments `*args`, `**kwargs`, `axis`.", "question_id": 43813}
{"snippet": "GroupBy.ffill()", "intent": "Forward fill the values .", "question_id": 43814}
{"snippet": "GroupBy.ffill(limit=None)", "intent": "Forward fill the values . With arguments `limit`.", "question_id": 43815}
{"snippet": "GroupBy.ffill()", "intent": "Forward fill the values .", "question_id": 43816}
{"snippet": "GroupBy.ffill(limit=None)", "intent": "Forward fill the values . With arguments `limit`.", "question_id": 43817}
{"snippet": "GroupBy.ffill()", "intent": "Forward fill the values .", "question_id": 43818}
{"snippet": "GroupBy.ffill(limit=None)", "intent": "Forward fill the values . With arguments `limit`.", "question_id": 43819}
{"snippet": "GroupBy.first()", "intent": "Compute first of group values .", "question_id": 43820}
{"snippet": "GroupBy.first(numeric_only=False)", "intent": "Compute first of group values . With arguments `numeric_only`.", "question_id": 43821}
{"snippet": "GroupBy.first(min_count=- 1)", "intent": "Compute first of group values . With arguments `min_count`.", "question_id": 43822}
{"snippet": "GroupBy.first(numeric_only=False, min_count=- 1)", "intent": "Compute first of group values . With arguments `numeric_only`, `min_count`.", "question_id": 43823}
{"snippet": "GroupBy.first()", "intent": "Compute first of group values .", "question_id": 43824}
{"snippet": "GroupBy.first(numeric_only=False)", "intent": "Compute first of group values . With arguments `numeric_only`.", "question_id": 43825}
{"snippet": "GroupBy.first(min_count=- 1)", "intent": "Compute first of group values . With arguments `min_count`.", "question_id": 43826}
{"snippet": "GroupBy.first(numeric_only=False, min_count=- 1)", "intent": "Compute first of group values . With arguments `numeric_only`, `min_count`.", "question_id": 43827}
{"snippet": "GroupBy.first()", "intent": "Compute first of group values .", "question_id": 43828}
{"snippet": "GroupBy.first(numeric_only=False)", "intent": "Compute first of group values . With arguments `numeric_only`.", "question_id": 43829}
{"snippet": "GroupBy.first(min_count=- 1)", "intent": "Compute first of group values . With arguments `min_count`.", "question_id": 43830}
{"snippet": "GroupBy.first(numeric_only=False, min_count=- 1)", "intent": "Compute first of group values . With arguments `numeric_only`, `min_count`.", "question_id": 43831}
{"snippet": "GroupBy.get_group(name)", "intent": "Construct DataFrame from group with provided `name` .", "question_id": 43832}
{"snippet": "GroupBy.get_group(name, obj=None)", "intent": "Construct DataFrame from group with provided `name` . With arguments `obj`.", "question_id": 43833}
{"snippet": "GroupBy.get_group(name)", "intent": "Construct DataFrame from group with provided `name` .", "question_id": 43834}
{"snippet": "GroupBy.get_group(name, obj=None)", "intent": "Construct DataFrame from group with provided `name` . With arguments `obj`.", "question_id": 43835}
{"snippet": "GroupBy.get_group(name)", "intent": "Construct DataFrame from group with provided `name` .", "question_id": 43836}
{"snippet": "GroupBy.get_group(name, obj=None)", "intent": "Construct DataFrame from group with provided `name` . With arguments `obj`.", "question_id": 43837}
{"snippet": "GroupBy.head()", "intent": "Return first `n` rows of each group .", "question_id": 43838}
{"snippet": "GroupBy.head(n=5)", "intent": "Return first `n` rows of each group .", "question_id": 43839}
{"snippet": "GroupBy.head()", "intent": "Return first `n` rows of each group .", "question_id": 43840}
{"snippet": "GroupBy.head(n=5)", "intent": "Return first `n` rows of each group .", "question_id": 43841}
{"snippet": "GroupBy.head()", "intent": "Return first `n` rows of each group .", "question_id": 43842}
{"snippet": "GroupBy.head(n=5)", "intent": "Return first `n` rows of each group .", "question_id": 43843}
{"snippet": "GroupBy.last()", "intent": "Compute last of group values .", "question_id": 43844}
{"snippet": "GroupBy.last(numeric_only=False)", "intent": "Compute last of group values . With arguments `numeric_only`.", "question_id": 43845}
{"snippet": "GroupBy.last(min_count=- 1)", "intent": "Compute last of group values . With arguments `min_count`.", "question_id": 43846}
{"snippet": "GroupBy.last(numeric_only=False, min_count=- 1)", "intent": "Compute last of group values . With arguments `numeric_only`, `min_count`.", "question_id": 43847}
{"snippet": "GroupBy.last()", "intent": "Compute last of group values .", "question_id": 43848}
{"snippet": "GroupBy.last(numeric_only=False)", "intent": "Compute last of group values . With arguments `numeric_only`.", "question_id": 43849}
{"snippet": "GroupBy.last(min_count=- 1)", "intent": "Compute last of group values . With arguments `min_count`.", "question_id": 43850}
{"snippet": "GroupBy.last(numeric_only=False, min_count=- 1)", "intent": "Compute last of group values . With arguments `numeric_only`, `min_count`.", "question_id": 43851}
{"snippet": "GroupBy.last()", "intent": "Compute last of group values .", "question_id": 43852}
{"snippet": "GroupBy.last(numeric_only=False)", "intent": "Compute last of group values . With arguments `numeric_only`.", "question_id": 43853}
{"snippet": "GroupBy.last(min_count=- 1)", "intent": "Compute last of group values . With arguments `min_count`.", "question_id": 43854}
{"snippet": "GroupBy.last(numeric_only=False, min_count=- 1)", "intent": "Compute last of group values . With arguments `numeric_only`, `min_count`.", "question_id": 43855}
{"snippet": "GroupBy.max()", "intent": "Compute max of group values .", "question_id": 43856}
{"snippet": "GroupBy.max(numeric_only=False)", "intent": "Compute max of group values . With arguments `numeric_only`.", "question_id": 43857}
{"snippet": "GroupBy.max(min_count=- 1)", "intent": "Compute max of group values . With arguments `min_count`.", "question_id": 43858}
{"snippet": "GroupBy.max(numeric_only=False, min_count=- 1)", "intent": "Compute max of group values . With arguments `numeric_only`, `min_count`.", "question_id": 43859}
{"snippet": "GroupBy.max()", "intent": "Compute max of group values .", "question_id": 43860}
{"snippet": "GroupBy.max(numeric_only=False)", "intent": "Compute max of group values . With arguments `numeric_only`.", "question_id": 43861}
{"snippet": "GroupBy.max(min_count=- 1)", "intent": "Compute max of group values . With arguments `min_count`.", "question_id": 43862}
{"snippet": "GroupBy.max(numeric_only=False, min_count=- 1)", "intent": "Compute max of group values . With arguments `numeric_only`, `min_count`.", "question_id": 43863}
{"snippet": "GroupBy.max()", "intent": "Compute max of group values .", "question_id": 43864}
{"snippet": "GroupBy.max(numeric_only=False)", "intent": "Compute max of group values . With arguments `numeric_only`.", "question_id": 43865}
{"snippet": "GroupBy.max(min_count=- 1)", "intent": "Compute max of group values . With arguments `min_count`.", "question_id": 43866}
{"snippet": "GroupBy.max(numeric_only=False, min_count=- 1)", "intent": "Compute max of group values . With arguments `numeric_only`, `min_count`.", "question_id": 43867}
{"snippet": "GroupBy.mean()", "intent": "Compute mean of groups , excluding missing values .", "question_id": 43868}
{"snippet": "GroupBy.mean(numeric_only=NoDefault.no_default)", "intent": "Compute mean of groups , excluding missing values . With arguments `numeric_only`.", "question_id": 43869}
{"snippet": "GroupBy.mean()", "intent": "Compute mean of groups , excluding missing values .", "question_id": 43870}
{"snippet": "GroupBy.mean(numeric_only=NoDefault.no_default)", "intent": "Compute mean of groups , excluding missing values . With arguments `numeric_only`.", "question_id": 43871}
{"snippet": "GroupBy.mean()", "intent": "Compute mean of groups , excluding missing values .", "question_id": 43872}
{"snippet": "GroupBy.mean(numeric_only=NoDefault.no_default)", "intent": "Compute mean of groups , excluding missing values . With arguments `numeric_only`.", "question_id": 43873}
{"snippet": "GroupBy.median()", "intent": "Compute median of groups , excluding missing values .", "question_id": 43874}
{"snippet": "GroupBy.median(numeric_only=NoDefault.no_default)", "intent": "Compute median of groups , excluding missing values . With arguments `numeric_only`.", "question_id": 43875}
{"snippet": "GroupBy.median()", "intent": "Compute median of groups , excluding missing values .", "question_id": 43876}
{"snippet": "GroupBy.median(numeric_only=NoDefault.no_default)", "intent": "Compute median of groups , excluding missing values . With arguments `numeric_only`.", "question_id": 43877}
{"snippet": "GroupBy.median()", "intent": "Compute median of groups , excluding missing values .", "question_id": 43878}
{"snippet": "GroupBy.median(numeric_only=NoDefault.no_default)", "intent": "Compute median of groups , excluding missing values . With arguments `numeric_only`.", "question_id": 43879}
{"snippet": "GroupBy.min()", "intent": "Compute min of group values .", "question_id": 43880}
{"snippet": "GroupBy.min(numeric_only=False)", "intent": "Compute min of group values . With arguments `numeric_only`.", "question_id": 43881}
{"snippet": "GroupBy.min(min_count=- 1)", "intent": "Compute min of group values . With arguments `min_count`.", "question_id": 43882}
{"snippet": "GroupBy.min(numeric_only=False, min_count=- 1)", "intent": "Compute min of group values . With arguments `numeric_only`, `min_count`.", "question_id": 43883}
{"snippet": "GroupBy.min()", "intent": "Compute min of group values .", "question_id": 43884}
{"snippet": "GroupBy.min(numeric_only=False)", "intent": "Compute min of group values . With arguments `numeric_only`.", "question_id": 43885}
{"snippet": "GroupBy.min(min_count=- 1)", "intent": "Compute min of group values . With arguments `min_count`.", "question_id": 43886}
{"snippet": "GroupBy.min(numeric_only=False, min_count=- 1)", "intent": "Compute min of group values . With arguments `numeric_only`, `min_count`.", "question_id": 43887}
{"snippet": "GroupBy.min()", "intent": "Compute min of group values .", "question_id": 43888}
{"snippet": "GroupBy.min(numeric_only=False)", "intent": "Compute min of group values . With arguments `numeric_only`.", "question_id": 43889}
{"snippet": "GroupBy.min(min_count=- 1)", "intent": "Compute min of group values . With arguments `min_count`.", "question_id": 43890}
{"snippet": "GroupBy.min(numeric_only=False, min_count=- 1)", "intent": "Compute min of group values . With arguments `numeric_only`, `min_count`.", "question_id": 43891}
{"snippet": "GroupBy.ngroup()", "intent": "Number each group from 0 to the number of groups - 1 .", "question_id": 43892}
{"snippet": "GroupBy.ngroup(ascending=True)", "intent": "Number each group from 0 to the number of groups - 1 . With arguments `ascending`.", "question_id": 43893}
{"snippet": "GroupBy.ngroup()", "intent": "Number each group from 0 to the number of groups - 1 .", "question_id": 43894}
{"snippet": "GroupBy.ngroup(ascending=True)", "intent": "Number each group from 0 to the number of groups - 1 . With arguments `ascending`.", "question_id": 43895}
{"snippet": "GroupBy.ngroup()", "intent": "Number each group from 0 to the number of groups - 1 .", "question_id": 43896}
{"snippet": "GroupBy.ngroup(ascending=True)", "intent": "Number each group from 0 to the number of groups - 1 . With arguments `ascending`.", "question_id": 43897}
{"snippet": "GroupBy.nth(n)", "intent": "Take the nth row from each group if `n` is an int , or a subset of rows if n is a list of ints .", "question_id": 43898}
{"snippet": "GroupBy.nth(n, dropna=None)", "intent": "Take the nth row from each group if `n` is an int , or a subset of rows if n is a list of ints . If `dropna` , will take the nth non-null row , dropna is either \u2018 all \u2019 or \u2018 any \u2019 ; this is equivalent to calling dropna ( how=dropna ) before the groupby .", "question_id": 43899}
{"snippet": "GroupBy.nth(n)", "intent": "Take the nth row from each group if `n` is an int , or a subset of rows if n is a list of ints .", "question_id": 43900}
{"snippet": "GroupBy.nth(n, dropna=None)", "intent": "Take the nth row from each group if `n` is an int , or a subset of rows if n is a list of ints . If `dropna` , will take the nth non-null row , dropna is either \u2018 all \u2019 or \u2018 any \u2019 ; this is equivalent to calling dropna ( how=dropna ) before the groupby .", "question_id": 43901}
{"snippet": "GroupBy.nth(n)", "intent": "Take the nth row from each group if `n` is an int , or a subset of rows if n is a list of ints .", "question_id": 43902}
{"snippet": "GroupBy.nth(n, dropna=None)", "intent": "Take the nth row from each group if `n` is an int , or a subset of rows if n is a list of ints . If `dropna` , will take the nth non-null row , dropna is either \u2018 all \u2019 or \u2018 any \u2019 ; this is equivalent to calling dropna ( how=dropna ) before the groupby .", "question_id": 43903}
{"snippet": "GroupBy.ohlc()", "intent": "Compute open , high , low and close values of a group , excluding missing values .", "question_id": 43904}
{"snippet": "GroupBy.ohlc()", "intent": "Compute open , high , low and close values of a group , excluding missing values .", "question_id": 43905}
{"snippet": "GroupBy.ohlc()", "intent": "Compute open , high , low and close values of a group , excluding missing values .", "question_id": 43906}
{"snippet": "GroupBy.pad()", "intent": "Forward fill the values .", "question_id": 43907}
{"snippet": "GroupBy.pad(limit=None)", "intent": "Forward fill the values . With arguments `limit`.", "question_id": 43908}
{"snippet": "GroupBy.pad()", "intent": "Forward fill the values .", "question_id": 43909}
{"snippet": "GroupBy.pad(limit=None)", "intent": "Forward fill the values . With arguments `limit`.", "question_id": 43910}
{"snippet": "GroupBy.pad()", "intent": "Forward fill the values .", "question_id": 43911}
{"snippet": "GroupBy.pad(limit=None)", "intent": "Forward fill the values . With arguments `limit`.", "question_id": 43912}
{"snippet": "GroupBy.pct_change()", "intent": "Calculate pct_change of each value to previous entry in group .", "question_id": 43913}
{"snippet": "GroupBy.pct_change(periods=1)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`.", "question_id": 43914}
{"snippet": "GroupBy.pct_change(fill_method='pad')", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `fill_method`.", "question_id": 43915}
{"snippet": "GroupBy.pct_change(limit=None)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `limit`.", "question_id": 43916}
{"snippet": "GroupBy.pct_change(freq=None)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `freq`.", "question_id": 43917}
{"snippet": "GroupBy.pct_change(axis=0)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `axis`.", "question_id": 43918}
{"snippet": "GroupBy.pct_change(periods=1, fill_method='pad')", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`, `fill_method`.", "question_id": 43919}
{"snippet": "GroupBy.pct_change(periods=1, limit=None)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`, `limit`.", "question_id": 43920}
{"snippet": "GroupBy.pct_change(periods=1, freq=None)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`, `freq`.", "question_id": 43921}
{"snippet": "GroupBy.pct_change(periods=1, axis=0)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`, `axis`.", "question_id": 43922}
{"snippet": "GroupBy.pct_change()", "intent": "Calculate pct_change of each value to previous entry in group .", "question_id": 43923}
{"snippet": "GroupBy.pct_change(periods=1)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`.", "question_id": 43924}
{"snippet": "GroupBy.pct_change(fill_method='pad')", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `fill_method`.", "question_id": 43925}
{"snippet": "GroupBy.pct_change(limit=None)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `limit`.", "question_id": 43926}
{"snippet": "GroupBy.pct_change(freq=None)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `freq`.", "question_id": 43927}
{"snippet": "GroupBy.pct_change(axis=0)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `axis`.", "question_id": 43928}
{"snippet": "GroupBy.pct_change(periods=1, fill_method='pad')", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`, `fill_method`.", "question_id": 43929}
{"snippet": "GroupBy.pct_change(periods=1, limit=None)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`, `limit`.", "question_id": 43930}
{"snippet": "GroupBy.pct_change(periods=1, freq=None)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`, `freq`.", "question_id": 43931}
{"snippet": "GroupBy.pct_change(periods=1, axis=0)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`, `axis`.", "question_id": 43932}
{"snippet": "GroupBy.pct_change()", "intent": "Calculate pct_change of each value to previous entry in group .", "question_id": 43933}
{"snippet": "GroupBy.pct_change(periods=1)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`.", "question_id": 43934}
{"snippet": "GroupBy.pct_change(fill_method='pad')", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `fill_method`.", "question_id": 43935}
{"snippet": "GroupBy.pct_change(limit=None)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `limit`.", "question_id": 43936}
{"snippet": "GroupBy.pct_change(freq=None)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `freq`.", "question_id": 43937}
{"snippet": "GroupBy.pct_change(axis=0)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `axis`.", "question_id": 43938}
{"snippet": "GroupBy.pct_change(periods=1, fill_method='pad')", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`, `fill_method`.", "question_id": 43939}
{"snippet": "GroupBy.pct_change(periods=1, limit=None)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`, `limit`.", "question_id": 43940}
{"snippet": "GroupBy.pct_change(periods=1, freq=None)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`, `freq`.", "question_id": 43941}
{"snippet": "GroupBy.pct_change(periods=1, axis=0)", "intent": "Calculate pct_change of each value to previous entry in group . With arguments `periods`, `axis`.", "question_id": 43942}
{"snippet": "GroupBy.pipe(func, *args, **kwargs)", "intent": "Apply a function `func` with arguments to this GroupBy object and return the function \u2019 s result . With arguments `*args`, `**kwargs`.", "question_id": 43943}
{"snippet": "GroupBy.pipe(func, *args, **kwargs)", "intent": "Apply a function `func` with arguments to this GroupBy object and return the function \u2019 s result . With arguments `*args`, `**kwargs`.", "question_id": 43944}
{"snippet": "GroupBy.pipe(func, *args, **kwargs)", "intent": "Apply a function `func` with arguments to this GroupBy object and return the function \u2019 s result . With arguments `*args`, `**kwargs`.", "question_id": 43945}
{"snippet": "GroupBy.prod()", "intent": "Compute prod of group values .", "question_id": 43946}
{"snippet": "GroupBy.prod(numeric_only=NoDefault.no_default)", "intent": "Compute prod of group values . With arguments `numeric_only`.", "question_id": 43947}
{"snippet": "GroupBy.prod(min_count=0)", "intent": "Compute prod of group values . With arguments `min_count`.", "question_id": 43948}
{"snippet": "GroupBy.prod(numeric_only=NoDefault.no_default, min_count=0)", "intent": "Compute prod of group values . With arguments `numeric_only`, `min_count`.", "question_id": 43949}
{"snippet": "GroupBy.prod()", "intent": "Compute prod of group values .", "question_id": 43950}
{"snippet": "GroupBy.prod(numeric_only=NoDefault.no_default)", "intent": "Compute prod of group values . With arguments `numeric_only`.", "question_id": 43951}
{"snippet": "GroupBy.prod(min_count=0)", "intent": "Compute prod of group values . With arguments `min_count`.", "question_id": 43952}
{"snippet": "GroupBy.prod(numeric_only=NoDefault.no_default, min_count=0)", "intent": "Compute prod of group values . With arguments `numeric_only`, `min_count`.", "question_id": 43953}
{"snippet": "GroupBy.prod()", "intent": "Compute prod of group values .", "question_id": 43954}
{"snippet": "GroupBy.prod(numeric_only=NoDefault.no_default)", "intent": "Compute prod of group values . With arguments `numeric_only`.", "question_id": 43955}
{"snippet": "GroupBy.prod(min_count=0)", "intent": "Compute prod of group values . With arguments `min_count`.", "question_id": 43956}
{"snippet": "GroupBy.prod(numeric_only=NoDefault.no_default, min_count=0)", "intent": "Compute prod of group values . With arguments `numeric_only`, `min_count`.", "question_id": 43957}
{"snippet": "GroupBy.rank()", "intent": "Provide the rank of values within each group .", "question_id": 43958}
{"snippet": "GroupBy.rank(method='average')", "intent": "Provide the rank of values within each group . With arguments `method`.", "question_id": 43959}
{"snippet": "GroupBy.rank(ascending=True)", "intent": "Provide the rank of values within each group . With arguments `ascending`.", "question_id": 43960}
{"snippet": "GroupBy.rank(na_option='keep')", "intent": "Provide the rank of values within each group . With arguments `na_option`.", "question_id": 43961}
{"snippet": "GroupBy.rank(pct=False)", "intent": "Provide the rank of values within each group . With arguments `pct`.", "question_id": 43962}
{"snippet": "GroupBy.rank(axis=0)", "intent": "Provide the rank of values within each group . With arguments `axis`.", "question_id": 43963}
{"snippet": "GroupBy.rank(method='average', ascending=True)", "intent": "Provide the rank of values within each group . With arguments `method`, `ascending`.", "question_id": 43964}
{"snippet": "GroupBy.rank(method='average', na_option='keep')", "intent": "Provide the rank of values within each group . With arguments `method`, `na_option`.", "question_id": 43965}
{"snippet": "GroupBy.rank(method='average', pct=False)", "intent": "Provide the rank of values within each group . With arguments `method`, `pct`.", "question_id": 43966}
{"snippet": "GroupBy.rank(method='average', axis=0)", "intent": "Provide the rank of values within each group . With arguments `method`, `axis`.", "question_id": 43967}
{"snippet": "GroupBy.rank()", "intent": "Provide the rank of values within each group .", "question_id": 43968}
{"snippet": "GroupBy.rank(method='average')", "intent": "Provide the rank of values within each group . With arguments `method`.", "question_id": 43969}
{"snippet": "GroupBy.rank(ascending=True)", "intent": "Provide the rank of values within each group . With arguments `ascending`.", "question_id": 43970}
{"snippet": "GroupBy.rank(na_option='keep')", "intent": "Provide the rank of values within each group . With arguments `na_option`.", "question_id": 43971}
{"snippet": "GroupBy.rank(pct=False)", "intent": "Provide the rank of values within each group . With arguments `pct`.", "question_id": 43972}
{"snippet": "GroupBy.rank(axis=0)", "intent": "Provide the rank of values within each group . With arguments `axis`.", "question_id": 43973}
{"snippet": "GroupBy.rank(method='average', ascending=True)", "intent": "Provide the rank of values within each group . With arguments `method`, `ascending`.", "question_id": 43974}
{"snippet": "GroupBy.rank(method='average', na_option='keep')", "intent": "Provide the rank of values within each group . With arguments `method`, `na_option`.", "question_id": 43975}
{"snippet": "GroupBy.rank(method='average', pct=False)", "intent": "Provide the rank of values within each group . With arguments `method`, `pct`.", "question_id": 43976}
{"snippet": "GroupBy.rank(method='average', axis=0)", "intent": "Provide the rank of values within each group . With arguments `method`, `axis`.", "question_id": 43977}
{"snippet": "GroupBy.rank()", "intent": "Provide the rank of values within each group .", "question_id": 43978}
{"snippet": "GroupBy.rank(method='average')", "intent": "Provide the rank of values within each group . With arguments `method`.", "question_id": 43979}
{"snippet": "GroupBy.rank(ascending=True)", "intent": "Provide the rank of values within each group . With arguments `ascending`.", "question_id": 43980}
{"snippet": "GroupBy.rank(na_option='keep')", "intent": "Provide the rank of values within each group . With arguments `na_option`.", "question_id": 43981}
{"snippet": "GroupBy.rank(pct=False)", "intent": "Provide the rank of values within each group . With arguments `pct`.", "question_id": 43982}
{"snippet": "GroupBy.rank(axis=0)", "intent": "Provide the rank of values within each group . With arguments `axis`.", "question_id": 43983}
{"snippet": "GroupBy.rank(method='average', ascending=True)", "intent": "Provide the rank of values within each group . With arguments `method`, `ascending`.", "question_id": 43984}
{"snippet": "GroupBy.rank(method='average', na_option='keep')", "intent": "Provide the rank of values within each group . With arguments `method`, `na_option`.", "question_id": 43985}
{"snippet": "GroupBy.rank(method='average', pct=False)", "intent": "Provide the rank of values within each group . With arguments `method`, `pct`.", "question_id": 43986}
{"snippet": "GroupBy.rank(method='average', axis=0)", "intent": "Provide the rank of values within each group . With arguments `method`, `axis`.", "question_id": 43987}
{"snippet": "GroupBy.sem()", "intent": "Compute standard error of the mean of groups , excluding missing values .", "question_id": 43988}
{"snippet": "GroupBy.sem(ddof=1)", "intent": "Compute standard error of the mean of groups , excluding missing values . With arguments `ddof`.", "question_id": 43989}
{"snippet": "GroupBy.sem()", "intent": "Compute standard error of the mean of groups , excluding missing values .", "question_id": 43990}
{"snippet": "GroupBy.sem(ddof=1)", "intent": "Compute standard error of the mean of groups , excluding missing values . With arguments `ddof`.", "question_id": 43991}
{"snippet": "GroupBy.sem()", "intent": "Compute standard error of the mean of groups , excluding missing values .", "question_id": 43992}
{"snippet": "GroupBy.sem(ddof=1)", "intent": "Compute standard error of the mean of groups , excluding missing values . With arguments `ddof`.", "question_id": 43993}
{"snippet": "GroupBy.size()", "intent": "Compute group sizes .", "question_id": 43994}
{"snippet": "GroupBy.size()", "intent": "Compute group sizes .", "question_id": 43995}
{"snippet": "GroupBy.size()", "intent": "Compute group sizes .", "question_id": 43996}
{"snippet": "GroupBy.std()", "intent": "Compute standard deviation of groups , excluding missing values .", "question_id": 43997}
{"snippet": "GroupBy.std(ddof=1)", "intent": "Compute standard deviation of groups , excluding missing values . With arguments `ddof`.", "question_id": 43998}
{"snippet": "GroupBy.std()", "intent": "Compute standard deviation of groups , excluding missing values .", "question_id": 43999}
{"snippet": "GroupBy.std(ddof=1)", "intent": "Compute standard deviation of groups , excluding missing values . With arguments `ddof`.", "question_id": 44000}
{"snippet": "GroupBy.std()", "intent": "Compute standard deviation of groups , excluding missing values .", "question_id": 44001}
{"snippet": "GroupBy.std(ddof=1)", "intent": "Compute standard deviation of groups , excluding missing values . With arguments `ddof`.", "question_id": 44002}
{"snippet": "GroupBy.sum()", "intent": "Compute sum of group values .", "question_id": 44003}
{"snippet": "GroupBy.sum(numeric_only=NoDefault.no_default)", "intent": "Compute sum of group values . With arguments `numeric_only`.", "question_id": 44004}
{"snippet": "GroupBy.sum(min_count=0)", "intent": "Compute sum of group values . With arguments `min_count`.", "question_id": 44005}
{"snippet": "GroupBy.sum(numeric_only=NoDefault.no_default, min_count=0)", "intent": "Compute sum of group values . With arguments `numeric_only`, `min_count`.", "question_id": 44006}
{"snippet": "GroupBy.sum()", "intent": "Compute sum of group values .", "question_id": 44007}
{"snippet": "GroupBy.sum(numeric_only=NoDefault.no_default)", "intent": "Compute sum of group values . With arguments `numeric_only`.", "question_id": 44008}
{"snippet": "GroupBy.sum(min_count=0)", "intent": "Compute sum of group values . With arguments `min_count`.", "question_id": 44009}
{"snippet": "GroupBy.sum(numeric_only=NoDefault.no_default, min_count=0)", "intent": "Compute sum of group values . With arguments `numeric_only`, `min_count`.", "question_id": 44010}
{"snippet": "GroupBy.sum()", "intent": "Compute sum of group values .", "question_id": 44011}
{"snippet": "GroupBy.sum(numeric_only=NoDefault.no_default)", "intent": "Compute sum of group values . With arguments `numeric_only`.", "question_id": 44012}
{"snippet": "GroupBy.sum(min_count=0)", "intent": "Compute sum of group values . With arguments `min_count`.", "question_id": 44013}
{"snippet": "GroupBy.sum(numeric_only=NoDefault.no_default, min_count=0)", "intent": "Compute sum of group values . With arguments `numeric_only`, `min_count`.", "question_id": 44014}
{"snippet": "GroupBy.tail()", "intent": "Return last `n` rows of each group .", "question_id": 44015}
{"snippet": "GroupBy.tail(n=5)", "intent": "Return last `n` rows of each group .", "question_id": 44016}
{"snippet": "GroupBy.tail()", "intent": "Return last `n` rows of each group .", "question_id": 44017}
{"snippet": "GroupBy.tail(n=5)", "intent": "Return last `n` rows of each group .", "question_id": 44018}
{"snippet": "GroupBy.tail()", "intent": "Return last `n` rows of each group .", "question_id": 44019}
{"snippet": "GroupBy.tail(n=5)", "intent": "Return last `n` rows of each group .", "question_id": 44020}
{"snippet": "GroupBy.var()", "intent": "Compute variance of groups , excluding missing values .", "question_id": 44021}
{"snippet": "GroupBy.var(ddof=1)", "intent": "Compute variance of groups , excluding missing values . With arguments `ddof`.", "question_id": 44022}
{"snippet": "GroupBy.var()", "intent": "Compute variance of groups , excluding missing values .", "question_id": 44023}
{"snippet": "GroupBy.var(ddof=1)", "intent": "Compute variance of groups , excluding missing values . With arguments `ddof`.", "question_id": 44024}
{"snippet": "GroupBy.var()", "intent": "Compute variance of groups , excluding missing values .", "question_id": 44025}
{"snippet": "GroupBy.var(ddof=1)", "intent": "Compute variance of groups , excluding missing values . With arguments `ddof`.", "question_id": 44026}
{"snippet": "SeriesGroupBy.aggregate(*args, **kwargs)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`.", "question_id": 44027}
{"snippet": "SeriesGroupBy.aggregate(*args, **kwargs, func=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `func`.", "question_id": 44028}
{"snippet": "SeriesGroupBy.aggregate(*args, **kwargs, engine=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `engine`.", "question_id": 44029}
{"snippet": "SeriesGroupBy.aggregate(*args, **kwargs, engine_kwargs=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44030}
{"snippet": "SeriesGroupBy.aggregate(*args, **kwargs, func=None, engine=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `func`, `engine`.", "question_id": 44031}
{"snippet": "SeriesGroupBy.aggregate(*args, **kwargs, func=None, engine_kwargs=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `func`, `engine_kwargs`.", "question_id": 44032}
{"snippet": "SeriesGroupBy.aggregate(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `engine`, `engine_kwargs`.", "question_id": 44033}
{"snippet": "SeriesGroupBy.aggregate(*args, **kwargs, func=None, engine=None, engine_kwargs=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `func`, `engine`, `engine_kwargs`.", "question_id": 44034}
{"snippet": "SeriesGroupBy.aggregate(*args, **kwargs)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`.", "question_id": 44035}
{"snippet": "SeriesGroupBy.aggregate(*args, **kwargs, func=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `func`.", "question_id": 44036}
{"snippet": "SeriesGroupBy.aggregate(*args, **kwargs, engine=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `engine`.", "question_id": 44037}
{"snippet": "SeriesGroupBy.aggregate(*args, **kwargs, engine_kwargs=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44038}
{"snippet": "SeriesGroupBy.aggregate(*args, **kwargs, func=None, engine=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `func`, `engine`.", "question_id": 44039}
{"snippet": "SeriesGroupBy.aggregate(*args, **kwargs, func=None, engine_kwargs=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `func`, `engine_kwargs`.", "question_id": 44040}
{"snippet": "SeriesGroupBy.aggregate(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `engine`, `engine_kwargs`.", "question_id": 44041}
{"snippet": "SeriesGroupBy.aggregate(*args, **kwargs, func=None, engine=None, engine_kwargs=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `func`, `engine`, `engine_kwargs`.", "question_id": 44042}
{"snippet": "SeriesGroupBy.aggregate(*args, **kwargs)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`.", "question_id": 44043}
{"snippet": "SeriesGroupBy.aggregate(*args, **kwargs, func=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `func`.", "question_id": 44044}
{"snippet": "SeriesGroupBy.aggregate(*args, **kwargs, engine=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `engine`.", "question_id": 44045}
{"snippet": "SeriesGroupBy.aggregate(*args, **kwargs, engine_kwargs=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44046}
{"snippet": "SeriesGroupBy.aggregate(*args, **kwargs, func=None, engine=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `func`, `engine`.", "question_id": 44047}
{"snippet": "SeriesGroupBy.aggregate(*args, **kwargs, func=None, engine_kwargs=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `func`, `engine_kwargs`.", "question_id": 44048}
{"snippet": "SeriesGroupBy.aggregate(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `engine`, `engine_kwargs`.", "question_id": 44049}
{"snippet": "SeriesGroupBy.aggregate(*args, **kwargs, func=None, engine=None, engine_kwargs=None)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `*args`, `**kwargs`, `func`, `engine`, `engine_kwargs`.", "question_id": 44050}
{"snippet": "SeriesGroupBy.nunique()", "intent": "Return number of unique elements in the group .", "question_id": 44051}
{"snippet": "SeriesGroupBy.nunique(dropna=True)", "intent": "Return number of unique elements in the group . With arguments `dropna`.", "question_id": 44052}
{"snippet": "SeriesGroupBy.nunique()", "intent": "Return number of unique elements in the group .", "question_id": 44053}
{"snippet": "SeriesGroupBy.nunique(dropna=True)", "intent": "Return number of unique elements in the group . With arguments `dropna`.", "question_id": 44054}
{"snippet": "SeriesGroupBy.nunique()", "intent": "Return number of unique elements in the group .", "question_id": 44055}
{"snippet": "SeriesGroupBy.nunique(dropna=True)", "intent": "Return number of unique elements in the group . With arguments `dropna`.", "question_id": 44056}
{"snippet": "SeriesGroupBy.transform(func, *args, **kwargs)", "intent": "Call function producing a like-indexed Series on each group and return a Series having the same indexes as the original object filled with the transformed values With arguments `func`, `*args`, `**kwargs`.", "question_id": 44057}
{"snippet": "SeriesGroupBy.transform(func, *args, **kwargs, engine=None)", "intent": "Call function producing a like-indexed Series on each group and return a Series having the same indexes as the original object filled with the transformed values With arguments `func`, `*args`, `**kwargs`, `engine`.", "question_id": 44058}
{"snippet": "SeriesGroupBy.transform(func, *args, **kwargs, engine_kwargs=None)", "intent": "Call function producing a like-indexed Series on each group and return a Series having the same indexes as the original object filled with the transformed values With arguments `func`, `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44059}
{"snippet": "SeriesGroupBy.transform(func, *args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Call function producing a like-indexed Series on each group and return a Series having the same indexes as the original object filled with the transformed values With arguments `func`, `*args`, `**kwargs`, `engine`, `engine_kwargs`.", "question_id": 44060}
{"snippet": "SeriesGroupBy.transform(func, *args, **kwargs)", "intent": "Call function producing a like-indexed Series on each group and return a Series having the same indexes as the original object filled with the transformed values With arguments `func`, `*args`, `**kwargs`.", "question_id": 44061}
{"snippet": "SeriesGroupBy.transform(func, *args, **kwargs, engine=None)", "intent": "Call function producing a like-indexed Series on each group and return a Series having the same indexes as the original object filled with the transformed values With arguments `func`, `*args`, `**kwargs`, `engine`.", "question_id": 44062}
{"snippet": "SeriesGroupBy.transform(func, *args, **kwargs, engine_kwargs=None)", "intent": "Call function producing a like-indexed Series on each group and return a Series having the same indexes as the original object filled with the transformed values With arguments `func`, `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44063}
{"snippet": "SeriesGroupBy.transform(func, *args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Call function producing a like-indexed Series on each group and return a Series having the same indexes as the original object filled with the transformed values With arguments `func`, `*args`, `**kwargs`, `engine`, `engine_kwargs`.", "question_id": 44064}
{"snippet": "SeriesGroupBy.transform(func, *args, **kwargs)", "intent": "Call function producing a like-indexed Series on each group and return a Series having the same indexes as the original object filled with the transformed values With arguments `func`, `*args`, `**kwargs`.", "question_id": 44065}
{"snippet": "SeriesGroupBy.transform(func, *args, **kwargs, engine=None)", "intent": "Call function producing a like-indexed Series on each group and return a Series having the same indexes as the original object filled with the transformed values With arguments `func`, `*args`, `**kwargs`, `engine`.", "question_id": 44066}
{"snippet": "SeriesGroupBy.transform(func, *args, **kwargs, engine_kwargs=None)", "intent": "Call function producing a like-indexed Series on each group and return a Series having the same indexes as the original object filled with the transformed values With arguments `func`, `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44067}
{"snippet": "SeriesGroupBy.transform(func, *args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Call function producing a like-indexed Series on each group and return a Series having the same indexes as the original object filled with the transformed values With arguments `func`, `*args`, `**kwargs`, `engine`, `engine_kwargs`.", "question_id": 44068}
{"snippet": "Resampler.__iter__()", "intent": "Groupby iterator .", "question_id": 44069}
{"snippet": "Resampler.__iter__()", "intent": "Groupby iterator .", "question_id": 44070}
{"snippet": "Resampler.__iter__()", "intent": "Groupby iterator .", "question_id": 44071}
{"snippet": "Resampler.aggregate(func, *args, **kwargs)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `func`, `*args`, `**kwargs`.", "question_id": 44072}
{"snippet": "Resampler.aggregate(func, *args, **kwargs)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `func`, `*args`, `**kwargs`.", "question_id": 44073}
{"snippet": "Resampler.aggregate(func, *args, **kwargs)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `func`, `*args`, `**kwargs`.", "question_id": 44074}
{"snippet": "Resampler.apply(func, *args, **kwargs)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `func`, `*args`, `**kwargs`.", "question_id": 44075}
{"snippet": "Resampler.apply(func, *args, **kwargs)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `func`, `*args`, `**kwargs`.", "question_id": 44076}
{"snippet": "Resampler.apply(func, *args, **kwargs)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `func`, `*args`, `**kwargs`.", "question_id": 44077}
{"snippet": "Resampler.asfreq()", "intent": "Return the values at the new freq , essentially a reindex .", "question_id": 44078}
{"snippet": "Resampler.asfreq(fill_value=None)", "intent": "Return the values at the new freq , essentially a reindex . With arguments `fill_value`.", "question_id": 44079}
{"snippet": "Resampler.asfreq()", "intent": "Return the values at the new freq , essentially a reindex .", "question_id": 44080}
{"snippet": "Resampler.asfreq(fill_value=None)", "intent": "Return the values at the new freq , essentially a reindex . With arguments `fill_value`.", "question_id": 44081}
{"snippet": "Resampler.asfreq()", "intent": "Return the values at the new freq , essentially a reindex .", "question_id": 44082}
{"snippet": "Resampler.asfreq(fill_value=None)", "intent": "Return the values at the new freq , essentially a reindex . With arguments `fill_value`.", "question_id": 44083}
{"snippet": "Resampler.backfill()", "intent": "Backward fill the new missing values in the resampled data .", "question_id": 44084}
{"snippet": "Resampler.backfill(limit=None)", "intent": "Backward fill the new missing values in the resampled data . With arguments `limit`.", "question_id": 44085}
{"snippet": "Resampler.backfill()", "intent": "Backward fill the new missing values in the resampled data .", "question_id": 44086}
{"snippet": "Resampler.backfill(limit=None)", "intent": "Backward fill the new missing values in the resampled data . With arguments `limit`.", "question_id": 44087}
{"snippet": "Resampler.backfill()", "intent": "Backward fill the new missing values in the resampled data .", "question_id": 44088}
{"snippet": "Resampler.backfill(limit=None)", "intent": "Backward fill the new missing values in the resampled data . With arguments `limit`.", "question_id": 44089}
{"snippet": "Resampler.bfill()", "intent": "Backward fill the new missing values in the resampled data .", "question_id": 44090}
{"snippet": "Resampler.bfill(limit=None)", "intent": "Backward fill the new missing values in the resampled data . With arguments `limit`.", "question_id": 44091}
{"snippet": "Resampler.bfill()", "intent": "Backward fill the new missing values in the resampled data .", "question_id": 44092}
{"snippet": "Resampler.bfill(limit=None)", "intent": "Backward fill the new missing values in the resampled data . With arguments `limit`.", "question_id": 44093}
{"snippet": "Resampler.bfill()", "intent": "Backward fill the new missing values in the resampled data .", "question_id": 44094}
{"snippet": "Resampler.bfill(limit=None)", "intent": "Backward fill the new missing values in the resampled data . With arguments `limit`.", "question_id": 44095}
{"snippet": "Resampler.count()", "intent": "Compute count of group , excluding missing values .", "question_id": 44096}
{"snippet": "Resampler.count()", "intent": "Compute count of group , excluding missing values .", "question_id": 44097}
{"snippet": "Resampler.count()", "intent": "Compute count of group , excluding missing values .", "question_id": 44098}
{"snippet": "Resampler.ffill()", "intent": "Forward fill the values .", "question_id": 44099}
{"snippet": "Resampler.ffill(limit=None)", "intent": "Forward fill the values . With arguments `limit`.", "question_id": 44100}
{"snippet": "Resampler.ffill()", "intent": "Forward fill the values .", "question_id": 44101}
{"snippet": "Resampler.ffill(limit=None)", "intent": "Forward fill the values . With arguments `limit`.", "question_id": 44102}
{"snippet": "Resampler.ffill()", "intent": "Forward fill the values .", "question_id": 44103}
{"snippet": "Resampler.ffill(limit=None)", "intent": "Forward fill the values . With arguments `limit`.", "question_id": 44104}
{"snippet": "Resampler.fillna(method)", "intent": "Fill missing values introduced by upsampling . With arguments `method`.", "question_id": 44105}
{"snippet": "Resampler.fillna(method, limit=None)", "intent": "Fill missing values introduced by upsampling . With arguments `method`, `limit`.", "question_id": 44106}
{"snippet": "Resampler.fillna(method)", "intent": "Fill missing values introduced by upsampling . With arguments `method`.", "question_id": 44107}
{"snippet": "Resampler.fillna(method, limit=None)", "intent": "Fill missing values introduced by upsampling . With arguments `method`, `limit`.", "question_id": 44108}
{"snippet": "Resampler.fillna(method)", "intent": "Fill missing values introduced by upsampling . With arguments `method`.", "question_id": 44109}
{"snippet": "Resampler.fillna(method, limit=None)", "intent": "Fill missing values introduced by upsampling . With arguments `method`, `limit`.", "question_id": 44110}
{"snippet": "Resampler.first(*args, **kwargs)", "intent": "Compute first of group values . With arguments `*args`, `**kwargs`.", "question_id": 44111}
{"snippet": "Resampler.first(*args, **kwargs, _method='first')", "intent": "Compute first of group values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44112}
{"snippet": "Resampler.first(*args, **kwargs, min_count=0)", "intent": "Compute first of group values . With arguments `*args`, `**kwargs`, `min_count`.", "question_id": 44113}
{"snippet": "Resampler.first(*args, **kwargs, _method='first', min_count=0)", "intent": "Compute first of group values . With arguments `*args`, `**kwargs`, `_method`, `min_count`.", "question_id": 44114}
{"snippet": "Resampler.first(*args, **kwargs)", "intent": "Compute first of group values . With arguments `*args`, `**kwargs`.", "question_id": 44115}
{"snippet": "Resampler.first(*args, **kwargs, _method='first')", "intent": "Compute first of group values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44116}
{"snippet": "Resampler.first(*args, **kwargs, min_count=0)", "intent": "Compute first of group values . With arguments `*args`, `**kwargs`, `min_count`.", "question_id": 44117}
{"snippet": "Resampler.first(*args, **kwargs, _method='first', min_count=0)", "intent": "Compute first of group values . With arguments `*args`, `**kwargs`, `_method`, `min_count`.", "question_id": 44118}
{"snippet": "Resampler.first(*args, **kwargs)", "intent": "Compute first of group values . With arguments `*args`, `**kwargs`.", "question_id": 44119}
{"snippet": "Resampler.first(*args, **kwargs, _method='first')", "intent": "Compute first of group values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44120}
{"snippet": "Resampler.first(*args, **kwargs, min_count=0)", "intent": "Compute first of group values . With arguments `*args`, `**kwargs`, `min_count`.", "question_id": 44121}
{"snippet": "Resampler.first(*args, **kwargs, _method='first', min_count=0)", "intent": "Compute first of group values . With arguments `*args`, `**kwargs`, `_method`, `min_count`.", "question_id": 44122}
{"snippet": "Resampler.get_group(name)", "intent": "Construct DataFrame from group with provided `name` .", "question_id": 44123}
{"snippet": "Resampler.get_group(name, obj=None)", "intent": "Construct DataFrame from group with provided `name` . With arguments `obj`.", "question_id": 44124}
{"snippet": "Resampler.get_group(name)", "intent": "Construct DataFrame from group with provided `name` .", "question_id": 44125}
{"snippet": "Resampler.get_group(name, obj=None)", "intent": "Construct DataFrame from group with provided `name` . With arguments `obj`.", "question_id": 44126}
{"snippet": "Resampler.get_group(name)", "intent": "Construct DataFrame from group with provided `name` .", "question_id": 44127}
{"snippet": "Resampler.get_group(name, obj=None)", "intent": "Construct DataFrame from group with provided `name` . With arguments `obj`.", "question_id": 44128}
{"snippet": "Resampler.interpolate(**kwargs)", "intent": "Interpolate values according to different methods . With arguments `**kwargs`.", "question_id": 44129}
{"snippet": "Resampler.interpolate(**kwargs, method='linear')", "intent": "Interpolate values according to different methods . Fill NaN values using an interpolation `method` . With arguments `**kwargs`.", "question_id": 44130}
{"snippet": "Resampler.interpolate(**kwargs, axis=0)", "intent": "Interpolate values according to different methods . With arguments `**kwargs`, `axis`.", "question_id": 44131}
{"snippet": "Resampler.interpolate(**kwargs, limit=None)", "intent": "Interpolate values according to different methods . With arguments `**kwargs`, `limit`.", "question_id": 44132}
{"snippet": "Resampler.interpolate(**kwargs, inplace=False)", "intent": "Interpolate values according to different methods . With arguments `**kwargs`, `inplace`.", "question_id": 44133}
{"snippet": "Resampler.interpolate(**kwargs, limit_direction='forward')", "intent": "Interpolate values according to different methods . With arguments `**kwargs`, `limit_direction`.", "question_id": 44134}
{"snippet": "Resampler.interpolate(**kwargs, limit_area=None)", "intent": "Interpolate values according to different methods . With arguments `**kwargs`, `limit_area`.", "question_id": 44135}
{"snippet": "Resampler.interpolate(**kwargs, downcast=None)", "intent": "Interpolate values according to different methods . With arguments `**kwargs`, `downcast`.", "question_id": 44136}
{"snippet": "Resampler.interpolate(**kwargs, method='linear', axis=0)", "intent": "Interpolate values according to different methods . Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `axis`.", "question_id": 44137}
{"snippet": "Resampler.interpolate(**kwargs, method='linear', limit=None)", "intent": "Interpolate values according to different methods . Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit`.", "question_id": 44138}
{"snippet": "Resampler.interpolate(**kwargs)", "intent": "Interpolate values according to different methods . With arguments `**kwargs`.", "question_id": 44139}
{"snippet": "Resampler.interpolate(**kwargs, method='linear')", "intent": "Interpolate values according to different methods . Fill NaN values using an interpolation `method` . With arguments `**kwargs`.", "question_id": 44140}
{"snippet": "Resampler.interpolate(**kwargs, axis=0)", "intent": "Interpolate values according to different methods . With arguments `**kwargs`, `axis`.", "question_id": 44141}
{"snippet": "Resampler.interpolate(**kwargs, limit=None)", "intent": "Interpolate values according to different methods . With arguments `**kwargs`, `limit`.", "question_id": 44142}
{"snippet": "Resampler.interpolate(**kwargs, inplace=False)", "intent": "Interpolate values according to different methods . With arguments `**kwargs`, `inplace`.", "question_id": 44143}
{"snippet": "Resampler.interpolate(**kwargs, limit_direction='forward')", "intent": "Interpolate values according to different methods . With arguments `**kwargs`, `limit_direction`.", "question_id": 44144}
{"snippet": "Resampler.interpolate(**kwargs, limit_area=None)", "intent": "Interpolate values according to different methods . With arguments `**kwargs`, `limit_area`.", "question_id": 44145}
{"snippet": "Resampler.interpolate(**kwargs, downcast=None)", "intent": "Interpolate values according to different methods . With arguments `**kwargs`, `downcast`.", "question_id": 44146}
{"snippet": "Resampler.interpolate(**kwargs, method='linear', axis=0)", "intent": "Interpolate values according to different methods . Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `axis`.", "question_id": 44147}
{"snippet": "Resampler.interpolate(**kwargs, method='linear', limit=None)", "intent": "Interpolate values according to different methods . Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit`.", "question_id": 44148}
{"snippet": "Resampler.interpolate(**kwargs)", "intent": "Interpolate values according to different methods . With arguments `**kwargs`.", "question_id": 44149}
{"snippet": "Resampler.interpolate(**kwargs, method='linear')", "intent": "Interpolate values according to different methods . Fill NaN values using an interpolation `method` . With arguments `**kwargs`.", "question_id": 44150}
{"snippet": "Resampler.interpolate(**kwargs, axis=0)", "intent": "Interpolate values according to different methods . With arguments `**kwargs`, `axis`.", "question_id": 44151}
{"snippet": "Resampler.interpolate(**kwargs, limit=None)", "intent": "Interpolate values according to different methods . With arguments `**kwargs`, `limit`.", "question_id": 44152}
{"snippet": "Resampler.interpolate(**kwargs, inplace=False)", "intent": "Interpolate values according to different methods . With arguments `**kwargs`, `inplace`.", "question_id": 44153}
{"snippet": "Resampler.interpolate(**kwargs, limit_direction='forward')", "intent": "Interpolate values according to different methods . With arguments `**kwargs`, `limit_direction`.", "question_id": 44154}
{"snippet": "Resampler.interpolate(**kwargs, limit_area=None)", "intent": "Interpolate values according to different methods . With arguments `**kwargs`, `limit_area`.", "question_id": 44155}
{"snippet": "Resampler.interpolate(**kwargs, downcast=None)", "intent": "Interpolate values according to different methods . With arguments `**kwargs`, `downcast`.", "question_id": 44156}
{"snippet": "Resampler.interpolate(**kwargs, method='linear', axis=0)", "intent": "Interpolate values according to different methods . Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `axis`.", "question_id": 44157}
{"snippet": "Resampler.interpolate(**kwargs, method='linear', limit=None)", "intent": "Interpolate values according to different methods . Fill NaN values using an interpolation `method` . With arguments `**kwargs`, `limit`.", "question_id": 44158}
{"snippet": "Resampler.last(*args, **kwargs)", "intent": "Compute last of group values . With arguments `*args`, `**kwargs`.", "question_id": 44159}
{"snippet": "Resampler.last(*args, **kwargs, _method='last')", "intent": "Compute last of group values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44160}
{"snippet": "Resampler.last(*args, **kwargs, min_count=0)", "intent": "Compute last of group values . With arguments `*args`, `**kwargs`, `min_count`.", "question_id": 44161}
{"snippet": "Resampler.last(*args, **kwargs, _method='last', min_count=0)", "intent": "Compute last of group values . With arguments `*args`, `**kwargs`, `_method`, `min_count`.", "question_id": 44162}
{"snippet": "Resampler.last(*args, **kwargs)", "intent": "Compute last of group values . With arguments `*args`, `**kwargs`.", "question_id": 44163}
{"snippet": "Resampler.last(*args, **kwargs, _method='last')", "intent": "Compute last of group values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44164}
{"snippet": "Resampler.last(*args, **kwargs, min_count=0)", "intent": "Compute last of group values . With arguments `*args`, `**kwargs`, `min_count`.", "question_id": 44165}
{"snippet": "Resampler.last(*args, **kwargs, _method='last', min_count=0)", "intent": "Compute last of group values . With arguments `*args`, `**kwargs`, `_method`, `min_count`.", "question_id": 44166}
{"snippet": "Resampler.last(*args, **kwargs)", "intent": "Compute last of group values . With arguments `*args`, `**kwargs`.", "question_id": 44167}
{"snippet": "Resampler.last(*args, **kwargs, _method='last')", "intent": "Compute last of group values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44168}
{"snippet": "Resampler.last(*args, **kwargs, min_count=0)", "intent": "Compute last of group values . With arguments `*args`, `**kwargs`, `min_count`.", "question_id": 44169}
{"snippet": "Resampler.last(*args, **kwargs, _method='last', min_count=0)", "intent": "Compute last of group values . With arguments `*args`, `**kwargs`, `_method`, `min_count`.", "question_id": 44170}
{"snippet": "Resampler.max(*args, **kwargs)", "intent": "Compute max of group values . With arguments `*args`, `**kwargs`.", "question_id": 44171}
{"snippet": "Resampler.max(*args, **kwargs, _method='max')", "intent": "Compute max of group values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44172}
{"snippet": "Resampler.max(*args, **kwargs, min_count=0)", "intent": "Compute max of group values . With arguments `*args`, `**kwargs`, `min_count`.", "question_id": 44173}
{"snippet": "Resampler.max(*args, **kwargs, _method='max', min_count=0)", "intent": "Compute max of group values . With arguments `*args`, `**kwargs`, `_method`, `min_count`.", "question_id": 44174}
{"snippet": "Resampler.max(*args, **kwargs)", "intent": "Compute max of group values . With arguments `*args`, `**kwargs`.", "question_id": 44175}
{"snippet": "Resampler.max(*args, **kwargs, _method='max')", "intent": "Compute max of group values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44176}
{"snippet": "Resampler.max(*args, **kwargs, min_count=0)", "intent": "Compute max of group values . With arguments `*args`, `**kwargs`, `min_count`.", "question_id": 44177}
{"snippet": "Resampler.max(*args, **kwargs, _method='max', min_count=0)", "intent": "Compute max of group values . With arguments `*args`, `**kwargs`, `_method`, `min_count`.", "question_id": 44178}
{"snippet": "Resampler.max(*args, **kwargs)", "intent": "Compute max of group values . With arguments `*args`, `**kwargs`.", "question_id": 44179}
{"snippet": "Resampler.max(*args, **kwargs, _method='max')", "intent": "Compute max of group values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44180}
{"snippet": "Resampler.max(*args, **kwargs, min_count=0)", "intent": "Compute max of group values . With arguments `*args`, `**kwargs`, `min_count`.", "question_id": 44181}
{"snippet": "Resampler.max(*args, **kwargs, _method='max', min_count=0)", "intent": "Compute max of group values . With arguments `*args`, `**kwargs`, `_method`, `min_count`.", "question_id": 44182}
{"snippet": "Resampler.mean(*args, **kwargs)", "intent": "Compute mean of groups , excluding missing values . With arguments `*args`, `**kwargs`.", "question_id": 44183}
{"snippet": "Resampler.mean(*args, **kwargs, _method='mean')", "intent": "Compute mean of groups , excluding missing values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44184}
{"snippet": "Resampler.mean(*args, **kwargs)", "intent": "Compute mean of groups , excluding missing values . With arguments `*args`, `**kwargs`.", "question_id": 44185}
{"snippet": "Resampler.mean(*args, **kwargs, _method='mean')", "intent": "Compute mean of groups , excluding missing values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44186}
{"snippet": "Resampler.mean(*args, **kwargs)", "intent": "Compute mean of groups , excluding missing values . With arguments `*args`, `**kwargs`.", "question_id": 44187}
{"snippet": "Resampler.mean(*args, **kwargs, _method='mean')", "intent": "Compute mean of groups , excluding missing values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44188}
{"snippet": "Resampler.median(*args, **kwargs)", "intent": "Compute median of groups , excluding missing values . With arguments `*args`, `**kwargs`.", "question_id": 44189}
{"snippet": "Resampler.median(*args, **kwargs, _method='median')", "intent": "Compute median of groups , excluding missing values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44190}
{"snippet": "Resampler.median(*args, **kwargs)", "intent": "Compute median of groups , excluding missing values . With arguments `*args`, `**kwargs`.", "question_id": 44191}
{"snippet": "Resampler.median(*args, **kwargs, _method='median')", "intent": "Compute median of groups , excluding missing values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44192}
{"snippet": "Resampler.median(*args, **kwargs)", "intent": "Compute median of groups , excluding missing values . With arguments `*args`, `**kwargs`.", "question_id": 44193}
{"snippet": "Resampler.median(*args, **kwargs, _method='median')", "intent": "Compute median of groups , excluding missing values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44194}
{"snippet": "Resampler.min(*args, **kwargs)", "intent": "Compute min of group values . With arguments `*args`, `**kwargs`.", "question_id": 44195}
{"snippet": "Resampler.min(*args, **kwargs, _method='min')", "intent": "Compute min of group values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44196}
{"snippet": "Resampler.min(*args, **kwargs, min_count=0)", "intent": "Compute min of group values . With arguments `*args`, `**kwargs`, `min_count`.", "question_id": 44197}
{"snippet": "Resampler.min(*args, **kwargs, _method='min', min_count=0)", "intent": "Compute min of group values . With arguments `*args`, `**kwargs`, `_method`, `min_count`.", "question_id": 44198}
{"snippet": "Resampler.min(*args, **kwargs)", "intent": "Compute min of group values . With arguments `*args`, `**kwargs`.", "question_id": 44199}
{"snippet": "Resampler.min(*args, **kwargs, _method='min')", "intent": "Compute min of group values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44200}
{"snippet": "Resampler.min(*args, **kwargs, min_count=0)", "intent": "Compute min of group values . With arguments `*args`, `**kwargs`, `min_count`.", "question_id": 44201}
{"snippet": "Resampler.min(*args, **kwargs, _method='min', min_count=0)", "intent": "Compute min of group values . With arguments `*args`, `**kwargs`, `_method`, `min_count`.", "question_id": 44202}
{"snippet": "Resampler.min(*args, **kwargs)", "intent": "Compute min of group values . With arguments `*args`, `**kwargs`.", "question_id": 44203}
{"snippet": "Resampler.min(*args, **kwargs, _method='min')", "intent": "Compute min of group values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44204}
{"snippet": "Resampler.min(*args, **kwargs, min_count=0)", "intent": "Compute min of group values . With arguments `*args`, `**kwargs`, `min_count`.", "question_id": 44205}
{"snippet": "Resampler.min(*args, **kwargs, _method='min', min_count=0)", "intent": "Compute min of group values . With arguments `*args`, `**kwargs`, `_method`, `min_count`.", "question_id": 44206}
{"snippet": "Resampler.nearest()", "intent": "Resample by using the nearest value .", "question_id": 44207}
{"snippet": "Resampler.nearest(limit=None)", "intent": "Resample by using the nearest value . If `limit` is given , fill only this many values in each direction for each of the original values .", "question_id": 44208}
{"snippet": "Resampler.nearest()", "intent": "Resample by using the nearest value .", "question_id": 44209}
{"snippet": "Resampler.nearest(limit=None)", "intent": "Resample by using the nearest value . If `limit` is given , fill only this many values in each direction for each of the original values .", "question_id": 44210}
{"snippet": "Resampler.nearest()", "intent": "Resample by using the nearest value .", "question_id": 44211}
{"snippet": "Resampler.nearest(limit=None)", "intent": "Resample by using the nearest value . If `limit` is given , fill only this many values in each direction for each of the original values .", "question_id": 44212}
{"snippet": "Resampler.nunique()", "intent": "Return number of unique elements in the group .", "question_id": 44213}
{"snippet": "Resampler.nunique(_method='nunique')", "intent": "Return number of unique elements in the group . With arguments `_method`.", "question_id": 44214}
{"snippet": "Resampler.nunique()", "intent": "Return number of unique elements in the group .", "question_id": 44215}
{"snippet": "Resampler.nunique(_method='nunique')", "intent": "Return number of unique elements in the group . With arguments `_method`.", "question_id": 44216}
{"snippet": "Resampler.nunique()", "intent": "Return number of unique elements in the group .", "question_id": 44217}
{"snippet": "Resampler.nunique(_method='nunique')", "intent": "Return number of unique elements in the group . With arguments `_method`.", "question_id": 44218}
{"snippet": "Resampler.ohlc(*args, **kwargs)", "intent": "Compute open , high , low and close values of a group , excluding missing values . With arguments `*args`, `**kwargs`.", "question_id": 44219}
{"snippet": "Resampler.ohlc(*args, **kwargs, _method='ohlc')", "intent": "Compute open , high , low and close values of a group , excluding missing values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44220}
{"snippet": "Resampler.ohlc(*args, **kwargs)", "intent": "Compute open , high , low and close values of a group , excluding missing values . With arguments `*args`, `**kwargs`.", "question_id": 44221}
{"snippet": "Resampler.ohlc(*args, **kwargs, _method='ohlc')", "intent": "Compute open , high , low and close values of a group , excluding missing values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44222}
{"snippet": "Resampler.ohlc(*args, **kwargs)", "intent": "Compute open , high , low and close values of a group , excluding missing values . With arguments `*args`, `**kwargs`.", "question_id": 44223}
{"snippet": "Resampler.ohlc(*args, **kwargs, _method='ohlc')", "intent": "Compute open , high , low and close values of a group , excluding missing values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44224}
{"snippet": "Resampler.pad()", "intent": "Forward fill the values .", "question_id": 44225}
{"snippet": "Resampler.pad(limit=None)", "intent": "Forward fill the values . With arguments `limit`.", "question_id": 44226}
{"snippet": "Resampler.pad()", "intent": "Forward fill the values .", "question_id": 44227}
{"snippet": "Resampler.pad(limit=None)", "intent": "Forward fill the values . With arguments `limit`.", "question_id": 44228}
{"snippet": "Resampler.pad()", "intent": "Forward fill the values .", "question_id": 44229}
{"snippet": "Resampler.pad(limit=None)", "intent": "Forward fill the values . With arguments `limit`.", "question_id": 44230}
{"snippet": "Resampler.pipe(func, *args, **kwargs)", "intent": "Apply a function `func` with arguments to this Resampler object and return the function \u2019 s result . With arguments `*args`, `**kwargs`.", "question_id": 44231}
{"snippet": "Resampler.pipe(func, *args, **kwargs)", "intent": "Apply a function `func` with arguments to this Resampler object and return the function \u2019 s result . With arguments `*args`, `**kwargs`.", "question_id": 44232}
{"snippet": "Resampler.pipe(func, *args, **kwargs)", "intent": "Apply a function `func` with arguments to this Resampler object and return the function \u2019 s result . With arguments `*args`, `**kwargs`.", "question_id": 44233}
{"snippet": "Resampler.prod(*args, **kwargs)", "intent": "Compute prod of group values . With arguments `*args`, `**kwargs`.", "question_id": 44234}
{"snippet": "Resampler.prod(*args, **kwargs, _method='prod')", "intent": "Compute prod of group values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44235}
{"snippet": "Resampler.prod(*args, **kwargs, min_count=0)", "intent": "Compute prod of group values . With arguments `*args`, `**kwargs`, `min_count`.", "question_id": 44236}
{"snippet": "Resampler.prod(*args, **kwargs, _method='prod', min_count=0)", "intent": "Compute prod of group values . With arguments `*args`, `**kwargs`, `_method`, `min_count`.", "question_id": 44237}
{"snippet": "Resampler.prod(*args, **kwargs)", "intent": "Compute prod of group values . With arguments `*args`, `**kwargs`.", "question_id": 44238}
{"snippet": "Resampler.prod(*args, **kwargs, _method='prod')", "intent": "Compute prod of group values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44239}
{"snippet": "Resampler.prod(*args, **kwargs, min_count=0)", "intent": "Compute prod of group values . With arguments `*args`, `**kwargs`, `min_count`.", "question_id": 44240}
{"snippet": "Resampler.prod(*args, **kwargs, _method='prod', min_count=0)", "intent": "Compute prod of group values . With arguments `*args`, `**kwargs`, `_method`, `min_count`.", "question_id": 44241}
{"snippet": "Resampler.prod(*args, **kwargs)", "intent": "Compute prod of group values . With arguments `*args`, `**kwargs`.", "question_id": 44242}
{"snippet": "Resampler.prod(*args, **kwargs, _method='prod')", "intent": "Compute prod of group values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44243}
{"snippet": "Resampler.prod(*args, **kwargs, min_count=0)", "intent": "Compute prod of group values . With arguments `*args`, `**kwargs`, `min_count`.", "question_id": 44244}
{"snippet": "Resampler.prod(*args, **kwargs, _method='prod', min_count=0)", "intent": "Compute prod of group values . With arguments `*args`, `**kwargs`, `_method`, `min_count`.", "question_id": 44245}
{"snippet": "Resampler.quantile(**kwargs)", "intent": "Return value at the given quantile . With arguments `**kwargs`.", "question_id": 44246}
{"snippet": "Resampler.quantile(**kwargs, q=0.5)", "intent": "Return value at the given quantile . With arguments `**kwargs`, `q`.", "question_id": 44247}
{"snippet": "Resampler.quantile(**kwargs)", "intent": "Return value at the given quantile . With arguments `**kwargs`.", "question_id": 44248}
{"snippet": "Resampler.quantile(**kwargs, q=0.5)", "intent": "Return value at the given quantile . With arguments `**kwargs`, `q`.", "question_id": 44249}
{"snippet": "Resampler.quantile(**kwargs)", "intent": "Return value at the given quantile . With arguments `**kwargs`.", "question_id": 44250}
{"snippet": "Resampler.quantile(**kwargs, q=0.5)", "intent": "Return value at the given quantile . With arguments `**kwargs`, `q`.", "question_id": 44251}
{"snippet": "Resampler.sem(*args, **kwargs)", "intent": "Compute standard error of the mean of groups , excluding missing values . With arguments `*args`, `**kwargs`.", "question_id": 44252}
{"snippet": "Resampler.sem(*args, **kwargs, _method='sem')", "intent": "Compute standard error of the mean of groups , excluding missing values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44253}
{"snippet": "Resampler.sem(*args, **kwargs)", "intent": "Compute standard error of the mean of groups , excluding missing values . With arguments `*args`, `**kwargs`.", "question_id": 44254}
{"snippet": "Resampler.sem(*args, **kwargs, _method='sem')", "intent": "Compute standard error of the mean of groups , excluding missing values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44255}
{"snippet": "Resampler.sem(*args, **kwargs)", "intent": "Compute standard error of the mean of groups , excluding missing values . With arguments `*args`, `**kwargs`.", "question_id": 44256}
{"snippet": "Resampler.sem(*args, **kwargs, _method='sem')", "intent": "Compute standard error of the mean of groups , excluding missing values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44257}
{"snippet": "Resampler.size()", "intent": "Compute group sizes .", "question_id": 44258}
{"snippet": "Resampler.size()", "intent": "Compute group sizes .", "question_id": 44259}
{"snippet": "Resampler.size()", "intent": "Compute group sizes .", "question_id": 44260}
{"snippet": "Resampler.std(*args, **kwargs)", "intent": "Compute standard deviation of groups , excluding missing values . With arguments `*args`, `**kwargs`.", "question_id": 44261}
{"snippet": "Resampler.std(*args, **kwargs, ddof=1)", "intent": "Compute standard deviation of groups , excluding missing values . With arguments `*args`, `**kwargs`, `ddof`.", "question_id": 44262}
{"snippet": "Resampler.std(*args, **kwargs)", "intent": "Compute standard deviation of groups , excluding missing values . With arguments `*args`, `**kwargs`.", "question_id": 44263}
{"snippet": "Resampler.std(*args, **kwargs, ddof=1)", "intent": "Compute standard deviation of groups , excluding missing values . With arguments `*args`, `**kwargs`, `ddof`.", "question_id": 44264}
{"snippet": "Resampler.std(*args, **kwargs)", "intent": "Compute standard deviation of groups , excluding missing values . With arguments `*args`, `**kwargs`.", "question_id": 44265}
{"snippet": "Resampler.std(*args, **kwargs, ddof=1)", "intent": "Compute standard deviation of groups , excluding missing values . With arguments `*args`, `**kwargs`, `ddof`.", "question_id": 44266}
{"snippet": "Resampler.sum(*args, **kwargs)", "intent": "Compute sum of group values . With arguments `*args`, `**kwargs`.", "question_id": 44267}
{"snippet": "Resampler.sum(*args, **kwargs, _method='sum')", "intent": "Compute sum of group values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44268}
{"snippet": "Resampler.sum(*args, **kwargs, min_count=0)", "intent": "Compute sum of group values . With arguments `*args`, `**kwargs`, `min_count`.", "question_id": 44269}
{"snippet": "Resampler.sum(*args, **kwargs, _method='sum', min_count=0)", "intent": "Compute sum of group values . With arguments `*args`, `**kwargs`, `_method`, `min_count`.", "question_id": 44270}
{"snippet": "Resampler.sum(*args, **kwargs)", "intent": "Compute sum of group values . With arguments `*args`, `**kwargs`.", "question_id": 44271}
{"snippet": "Resampler.sum(*args, **kwargs, _method='sum')", "intent": "Compute sum of group values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44272}
{"snippet": "Resampler.sum(*args, **kwargs, min_count=0)", "intent": "Compute sum of group values . With arguments `*args`, `**kwargs`, `min_count`.", "question_id": 44273}
{"snippet": "Resampler.sum(*args, **kwargs, _method='sum', min_count=0)", "intent": "Compute sum of group values . With arguments `*args`, `**kwargs`, `_method`, `min_count`.", "question_id": 44274}
{"snippet": "Resampler.sum(*args, **kwargs)", "intent": "Compute sum of group values . With arguments `*args`, `**kwargs`.", "question_id": 44275}
{"snippet": "Resampler.sum(*args, **kwargs, _method='sum')", "intent": "Compute sum of group values . With arguments `*args`, `**kwargs`, `_method`.", "question_id": 44276}
{"snippet": "Resampler.sum(*args, **kwargs, min_count=0)", "intent": "Compute sum of group values . With arguments `*args`, `**kwargs`, `min_count`.", "question_id": 44277}
{"snippet": "Resampler.sum(*args, **kwargs, _method='sum', min_count=0)", "intent": "Compute sum of group values . With arguments `*args`, `**kwargs`, `_method`, `min_count`.", "question_id": 44278}
{"snippet": "Resampler.transform(arg, *args, **kwargs)", "intent": "Call function producing a like-indexed Series on each group and return a Series with the transformed values . With arguments `arg`, `*args`, `**kwargs`.", "question_id": 44279}
{"snippet": "Resampler.transform(arg, *args, **kwargs)", "intent": "Call function producing a like-indexed Series on each group and return a Series with the transformed values . With arguments `arg`, `*args`, `**kwargs`.", "question_id": 44280}
{"snippet": "Resampler.transform(arg, *args, **kwargs)", "intent": "Call function producing a like-indexed Series on each group and return a Series with the transformed values . With arguments `arg`, `*args`, `**kwargs`.", "question_id": 44281}
{"snippet": "Resampler.var(*args, **kwargs)", "intent": "Compute variance of groups , excluding missing values . With arguments `*args`, `**kwargs`.", "question_id": 44282}
{"snippet": "Resampler.var(*args, **kwargs, ddof=1)", "intent": "Compute variance of groups , excluding missing values . With arguments `*args`, `**kwargs`, `ddof`.", "question_id": 44283}
{"snippet": "Resampler.var(*args, **kwargs)", "intent": "Compute variance of groups , excluding missing values . With arguments `*args`, `**kwargs`.", "question_id": 44284}
{"snippet": "Resampler.var(*args, **kwargs, ddof=1)", "intent": "Compute variance of groups , excluding missing values . With arguments `*args`, `**kwargs`, `ddof`.", "question_id": 44285}
{"snippet": "Resampler.var(*args, **kwargs)", "intent": "Compute variance of groups , excluding missing values . With arguments `*args`, `**kwargs`.", "question_id": 44286}
{"snippet": "Resampler.var(*args, **kwargs, ddof=1)", "intent": "Compute variance of groups , excluding missing values . With arguments `*args`, `**kwargs`, `ddof`.", "question_id": 44287}
{"snippet": "ExponentialMovingWindow.corr(**kwargs)", "intent": "Calculate the ewm ( exponential weighted moment ) sample correlation . With arguments `**kwargs`.", "question_id": 44288}
{"snippet": "ExponentialMovingWindow.corr(**kwargs, other=None)", "intent": "Calculate the ewm ( exponential weighted moment ) sample correlation . With arguments `**kwargs`, `other`.", "question_id": 44289}
{"snippet": "ExponentialMovingWindow.corr(**kwargs, pairwise=None)", "intent": "Calculate the ewm ( exponential weighted moment ) sample correlation . With arguments `**kwargs`, `pairwise`.", "question_id": 44290}
{"snippet": "ExponentialMovingWindow.corr(**kwargs, other=None, pairwise=None)", "intent": "Calculate the ewm ( exponential weighted moment ) sample correlation . With arguments `**kwargs`, `other`, `pairwise`.", "question_id": 44291}
{"snippet": "ExponentialMovingWindow.corr(**kwargs)", "intent": "Calculate the ewm ( exponential weighted moment ) sample correlation . With arguments `**kwargs`.", "question_id": 44292}
{"snippet": "ExponentialMovingWindow.corr(**kwargs, other=None)", "intent": "Calculate the ewm ( exponential weighted moment ) sample correlation . With arguments `**kwargs`, `other`.", "question_id": 44293}
{"snippet": "ExponentialMovingWindow.corr(**kwargs, pairwise=None)", "intent": "Calculate the ewm ( exponential weighted moment ) sample correlation . With arguments `**kwargs`, `pairwise`.", "question_id": 44294}
{"snippet": "ExponentialMovingWindow.corr(**kwargs, other=None, pairwise=None)", "intent": "Calculate the ewm ( exponential weighted moment ) sample correlation . With arguments `**kwargs`, `other`, `pairwise`.", "question_id": 44295}
{"snippet": "ExponentialMovingWindow.corr(**kwargs)", "intent": "Calculate the ewm ( exponential weighted moment ) sample correlation . With arguments `**kwargs`.", "question_id": 44296}
{"snippet": "ExponentialMovingWindow.corr(**kwargs, other=None)", "intent": "Calculate the ewm ( exponential weighted moment ) sample correlation . With arguments `**kwargs`, `other`.", "question_id": 44297}
{"snippet": "ExponentialMovingWindow.corr(**kwargs, pairwise=None)", "intent": "Calculate the ewm ( exponential weighted moment ) sample correlation . With arguments `**kwargs`, `pairwise`.", "question_id": 44298}
{"snippet": "ExponentialMovingWindow.corr(**kwargs, other=None, pairwise=None)", "intent": "Calculate the ewm ( exponential weighted moment ) sample correlation . With arguments `**kwargs`, `other`, `pairwise`.", "question_id": 44299}
{"snippet": "ExponentialMovingWindow.cov(**kwargs)", "intent": "Calculate the ewm ( exponential weighted moment ) sample covariance . With arguments `**kwargs`.", "question_id": 44300}
{"snippet": "ExponentialMovingWindow.cov(**kwargs, other=None)", "intent": "Calculate the ewm ( exponential weighted moment ) sample covariance . With arguments `**kwargs`, `other`.", "question_id": 44301}
{"snippet": "ExponentialMovingWindow.cov(**kwargs, pairwise=None)", "intent": "Calculate the ewm ( exponential weighted moment ) sample covariance . With arguments `**kwargs`, `pairwise`.", "question_id": 44302}
{"snippet": "ExponentialMovingWindow.cov(**kwargs, bias=False)", "intent": "Calculate the ewm ( exponential weighted moment ) sample covariance . With arguments `**kwargs`, `bias`.", "question_id": 44303}
{"snippet": "ExponentialMovingWindow.cov(**kwargs, other=None, pairwise=None)", "intent": "Calculate the ewm ( exponential weighted moment ) sample covariance . With arguments `**kwargs`, `other`, `pairwise`.", "question_id": 44304}
{"snippet": "ExponentialMovingWindow.cov(**kwargs, other=None, bias=False)", "intent": "Calculate the ewm ( exponential weighted moment ) sample covariance . With arguments `**kwargs`, `other`, `bias`.", "question_id": 44305}
{"snippet": "ExponentialMovingWindow.cov(**kwargs, pairwise=None, bias=False)", "intent": "Calculate the ewm ( exponential weighted moment ) sample covariance . With arguments `**kwargs`, `pairwise`, `bias`.", "question_id": 44306}
{"snippet": "ExponentialMovingWindow.cov(**kwargs, other=None, pairwise=None, bias=False)", "intent": "Calculate the ewm ( exponential weighted moment ) sample covariance . With arguments `**kwargs`, `other`, `pairwise`, `bias`.", "question_id": 44307}
{"snippet": "ExponentialMovingWindow.cov(**kwargs)", "intent": "Calculate the ewm ( exponential weighted moment ) sample covariance . With arguments `**kwargs`.", "question_id": 44308}
{"snippet": "ExponentialMovingWindow.cov(**kwargs, other=None)", "intent": "Calculate the ewm ( exponential weighted moment ) sample covariance . With arguments `**kwargs`, `other`.", "question_id": 44309}
{"snippet": "ExponentialMovingWindow.cov(**kwargs, pairwise=None)", "intent": "Calculate the ewm ( exponential weighted moment ) sample covariance . With arguments `**kwargs`, `pairwise`.", "question_id": 44310}
{"snippet": "ExponentialMovingWindow.cov(**kwargs, bias=False)", "intent": "Calculate the ewm ( exponential weighted moment ) sample covariance . With arguments `**kwargs`, `bias`.", "question_id": 44311}
{"snippet": "ExponentialMovingWindow.cov(**kwargs, other=None, pairwise=None)", "intent": "Calculate the ewm ( exponential weighted moment ) sample covariance . With arguments `**kwargs`, `other`, `pairwise`.", "question_id": 44312}
{"snippet": "ExponentialMovingWindow.cov(**kwargs, other=None, bias=False)", "intent": "Calculate the ewm ( exponential weighted moment ) sample covariance . With arguments `**kwargs`, `other`, `bias`.", "question_id": 44313}
{"snippet": "ExponentialMovingWindow.cov(**kwargs, pairwise=None, bias=False)", "intent": "Calculate the ewm ( exponential weighted moment ) sample covariance . With arguments `**kwargs`, `pairwise`, `bias`.", "question_id": 44314}
{"snippet": "ExponentialMovingWindow.cov(**kwargs, other=None, pairwise=None, bias=False)", "intent": "Calculate the ewm ( exponential weighted moment ) sample covariance . With arguments `**kwargs`, `other`, `pairwise`, `bias`.", "question_id": 44315}
{"snippet": "ExponentialMovingWindow.cov(**kwargs)", "intent": "Calculate the ewm ( exponential weighted moment ) sample covariance . With arguments `**kwargs`.", "question_id": 44316}
{"snippet": "ExponentialMovingWindow.cov(**kwargs, other=None)", "intent": "Calculate the ewm ( exponential weighted moment ) sample covariance . With arguments `**kwargs`, `other`.", "question_id": 44317}
{"snippet": "ExponentialMovingWindow.cov(**kwargs, pairwise=None)", "intent": "Calculate the ewm ( exponential weighted moment ) sample covariance . With arguments `**kwargs`, `pairwise`.", "question_id": 44318}
{"snippet": "ExponentialMovingWindow.cov(**kwargs, bias=False)", "intent": "Calculate the ewm ( exponential weighted moment ) sample covariance . With arguments `**kwargs`, `bias`.", "question_id": 44319}
{"snippet": "ExponentialMovingWindow.cov(**kwargs, other=None, pairwise=None)", "intent": "Calculate the ewm ( exponential weighted moment ) sample covariance . With arguments `**kwargs`, `other`, `pairwise`.", "question_id": 44320}
{"snippet": "ExponentialMovingWindow.cov(**kwargs, other=None, bias=False)", "intent": "Calculate the ewm ( exponential weighted moment ) sample covariance . With arguments `**kwargs`, `other`, `bias`.", "question_id": 44321}
{"snippet": "ExponentialMovingWindow.cov(**kwargs, pairwise=None, bias=False)", "intent": "Calculate the ewm ( exponential weighted moment ) sample covariance . With arguments `**kwargs`, `pairwise`, `bias`.", "question_id": 44322}
{"snippet": "ExponentialMovingWindow.cov(**kwargs, other=None, pairwise=None, bias=False)", "intent": "Calculate the ewm ( exponential weighted moment ) sample covariance . With arguments `**kwargs`, `other`, `pairwise`, `bias`.", "question_id": 44323}
{"snippet": "ExponentialMovingWindow.mean(*args, **kwargs)", "intent": "Calculate the ewm ( exponential weighted moment ) mean . With arguments `*args`, `**kwargs`.", "question_id": 44324}
{"snippet": "ExponentialMovingWindow.mean(*args, **kwargs, engine=None)", "intent": "Calculate the ewm ( exponential weighted moment ) mean . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44325}
{"snippet": "ExponentialMovingWindow.mean(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the ewm ( exponential weighted moment ) mean . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44326}
{"snippet": "ExponentialMovingWindow.mean(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the ewm ( exponential weighted moment ) mean . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44327}
{"snippet": "ExponentialMovingWindow.mean(*args, **kwargs)", "intent": "Calculate the ewm ( exponential weighted moment ) mean . With arguments `*args`, `**kwargs`.", "question_id": 44328}
{"snippet": "ExponentialMovingWindow.mean(*args, **kwargs, engine=None)", "intent": "Calculate the ewm ( exponential weighted moment ) mean . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44329}
{"snippet": "ExponentialMovingWindow.mean(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the ewm ( exponential weighted moment ) mean . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44330}
{"snippet": "ExponentialMovingWindow.mean(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the ewm ( exponential weighted moment ) mean . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44331}
{"snippet": "ExponentialMovingWindow.mean(*args, **kwargs)", "intent": "Calculate the ewm ( exponential weighted moment ) mean . With arguments `*args`, `**kwargs`.", "question_id": 44332}
{"snippet": "ExponentialMovingWindow.mean(*args, **kwargs, engine=None)", "intent": "Calculate the ewm ( exponential weighted moment ) mean . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44333}
{"snippet": "ExponentialMovingWindow.mean(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the ewm ( exponential weighted moment ) mean . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44334}
{"snippet": "ExponentialMovingWindow.mean(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the ewm ( exponential weighted moment ) mean . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44335}
{"snippet": "ExponentialMovingWindow.std(*args, **kwargs)", "intent": "Calculate the ewm ( exponential weighted moment ) standard deviation . With arguments `*args`, `**kwargs`.", "question_id": 44336}
{"snippet": "ExponentialMovingWindow.std(*args, **kwargs, bias=False)", "intent": "Calculate the ewm ( exponential weighted moment ) standard deviation . With arguments `*args`, `**kwargs`, `bias`.", "question_id": 44337}
{"snippet": "ExponentialMovingWindow.std(*args, **kwargs)", "intent": "Calculate the ewm ( exponential weighted moment ) standard deviation . With arguments `*args`, `**kwargs`.", "question_id": 44338}
{"snippet": "ExponentialMovingWindow.std(*args, **kwargs, bias=False)", "intent": "Calculate the ewm ( exponential weighted moment ) standard deviation . With arguments `*args`, `**kwargs`, `bias`.", "question_id": 44339}
{"snippet": "ExponentialMovingWindow.std(*args, **kwargs)", "intent": "Calculate the ewm ( exponential weighted moment ) standard deviation . With arguments `*args`, `**kwargs`.", "question_id": 44340}
{"snippet": "ExponentialMovingWindow.std(*args, **kwargs, bias=False)", "intent": "Calculate the ewm ( exponential weighted moment ) standard deviation . With arguments `*args`, `**kwargs`, `bias`.", "question_id": 44341}
{"snippet": "ExponentialMovingWindow.var(*args, **kwargs)", "intent": "Calculate the ewm ( exponential weighted moment ) variance . With arguments `*args`, `**kwargs`.", "question_id": 44342}
{"snippet": "ExponentialMovingWindow.var(*args, **kwargs, bias=False)", "intent": "Calculate the ewm ( exponential weighted moment ) variance . With arguments `*args`, `**kwargs`, `bias`.", "question_id": 44343}
{"snippet": "ExponentialMovingWindow.var(*args, **kwargs)", "intent": "Calculate the ewm ( exponential weighted moment ) variance . With arguments `*args`, `**kwargs`.", "question_id": 44344}
{"snippet": "ExponentialMovingWindow.var(*args, **kwargs, bias=False)", "intent": "Calculate the ewm ( exponential weighted moment ) variance . With arguments `*args`, `**kwargs`, `bias`.", "question_id": 44345}
{"snippet": "ExponentialMovingWindow.var(*args, **kwargs)", "intent": "Calculate the ewm ( exponential weighted moment ) variance . With arguments `*args`, `**kwargs`.", "question_id": 44346}
{"snippet": "ExponentialMovingWindow.var(*args, **kwargs, bias=False)", "intent": "Calculate the ewm ( exponential weighted moment ) variance . With arguments `*args`, `**kwargs`, `bias`.", "question_id": 44347}
{"snippet": "Expanding.aggregate(func, *args, **kwargs)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `func`, `*args`, `**kwargs`.", "question_id": 44348}
{"snippet": "Expanding.aggregate(func, *args, **kwargs)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `func`, `*args`, `**kwargs`.", "question_id": 44349}
{"snippet": "Expanding.aggregate(func, *args, **kwargs)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `func`, `*args`, `**kwargs`.", "question_id": 44350}
{"snippet": "Expanding.apply(func)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`.", "question_id": 44351}
{"snippet": "Expanding.apply(func, raw=False)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `raw`.", "question_id": 44352}
{"snippet": "Expanding.apply(func, engine=None)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `engine`.", "question_id": 44353}
{"snippet": "Expanding.apply(func, engine_kwargs=None)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `engine_kwargs`.", "question_id": 44354}
{"snippet": "Expanding.apply(func, args=None)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `args`.", "question_id": 44355}
{"snippet": "Expanding.apply(func, kwargs=None)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `kwargs`.", "question_id": 44356}
{"snippet": "Expanding.apply(func, raw=False, engine=None)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `raw`, `engine`.", "question_id": 44357}
{"snippet": "Expanding.apply(func, raw=False, engine_kwargs=None)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `raw`, `engine_kwargs`.", "question_id": 44358}
{"snippet": "Expanding.apply(func, raw=False, args=None)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `raw`, `args`.", "question_id": 44359}
{"snippet": "Expanding.apply(func, raw=False, kwargs=None)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `raw`, `kwargs`.", "question_id": 44360}
{"snippet": "Expanding.apply(func)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`.", "question_id": 44361}
{"snippet": "Expanding.apply(func, raw=False)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `raw`.", "question_id": 44362}
{"snippet": "Expanding.apply(func, engine=None)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `engine`.", "question_id": 44363}
{"snippet": "Expanding.apply(func, engine_kwargs=None)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `engine_kwargs`.", "question_id": 44364}
{"snippet": "Expanding.apply(func, args=None)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `args`.", "question_id": 44365}
{"snippet": "Expanding.apply(func, kwargs=None)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `kwargs`.", "question_id": 44366}
{"snippet": "Expanding.apply(func, raw=False, engine=None)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `raw`, `engine`.", "question_id": 44367}
{"snippet": "Expanding.apply(func, raw=False, engine_kwargs=None)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `raw`, `engine_kwargs`.", "question_id": 44368}
{"snippet": "Expanding.apply(func, raw=False, args=None)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `raw`, `args`.", "question_id": 44369}
{"snippet": "Expanding.apply(func, raw=False, kwargs=None)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `raw`, `kwargs`.", "question_id": 44370}
{"snippet": "Expanding.apply(func)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`.", "question_id": 44371}
{"snippet": "Expanding.apply(func, raw=False)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `raw`.", "question_id": 44372}
{"snippet": "Expanding.apply(func, engine=None)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `engine`.", "question_id": 44373}
{"snippet": "Expanding.apply(func, engine_kwargs=None)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `engine_kwargs`.", "question_id": 44374}
{"snippet": "Expanding.apply(func, args=None)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `args`.", "question_id": 44375}
{"snippet": "Expanding.apply(func, kwargs=None)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `kwargs`.", "question_id": 44376}
{"snippet": "Expanding.apply(func, raw=False, engine=None)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `raw`, `engine`.", "question_id": 44377}
{"snippet": "Expanding.apply(func, raw=False, engine_kwargs=None)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `raw`, `engine_kwargs`.", "question_id": 44378}
{"snippet": "Expanding.apply(func, raw=False, args=None)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `raw`, `args`.", "question_id": 44379}
{"snippet": "Expanding.apply(func, raw=False, kwargs=None)", "intent": "Calculate the expanding custom aggregation function . With arguments `func`, `raw`, `kwargs`.", "question_id": 44380}
{"snippet": "Expanding.corr(**kwargs)", "intent": "Calculate the expanding correlation . With arguments `**kwargs`.", "question_id": 44381}
{"snippet": "Expanding.corr(**kwargs, other=None)", "intent": "Calculate the expanding correlation . When `other` is not specified , the output will be self correlation ( e.g . With arguments `**kwargs`.", "question_id": 44382}
{"snippet": "Expanding.corr(**kwargs, pairwise=None)", "intent": "Calculate the expanding correlation . all 1 \u2019 s ) , except for DataFrame inputs with `pairwise` set to True . With arguments `**kwargs`.", "question_id": 44383}
{"snippet": "Expanding.corr(**kwargs, ddof=1)", "intent": "Calculate the expanding correlation . With arguments `**kwargs`, `ddof`.", "question_id": 44384}
{"snippet": "Expanding.corr(**kwargs, other=None, pairwise=None)", "intent": "Calculate the expanding correlation . When `other` is not specified , the output will be self correlation ( e.g . all 1 \u2019 s ) , except for DataFrame inputs with `pairwise` set to True . With arguments `**kwargs`.", "question_id": 44385}
{"snippet": "Expanding.corr(**kwargs, other=None, ddof=1)", "intent": "Calculate the expanding correlation . When `other` is not specified , the output will be self correlation ( e.g . With arguments `**kwargs`, `ddof`.", "question_id": 44386}
{"snippet": "Expanding.corr(**kwargs, pairwise=None, ddof=1)", "intent": "Calculate the expanding correlation . all 1 \u2019 s ) , except for DataFrame inputs with `pairwise` set to True . With arguments `**kwargs`, `ddof`.", "question_id": 44387}
{"snippet": "Expanding.corr(**kwargs, other=None, pairwise=None, ddof=1)", "intent": "Calculate the expanding correlation . When `other` is not specified , the output will be self correlation ( e.g . all 1 \u2019 s ) , except for DataFrame inputs with `pairwise` set to True . With arguments `**kwargs`, `ddof`.", "question_id": 44388}
{"snippet": "Expanding.corr(**kwargs)", "intent": "Calculate the expanding correlation . With arguments `**kwargs`.", "question_id": 44389}
{"snippet": "Expanding.corr(**kwargs, other=None)", "intent": "Calculate the expanding correlation . When `other` is not specified , the output will be self correlation ( e.g . With arguments `**kwargs`.", "question_id": 44390}
{"snippet": "Expanding.corr(**kwargs, pairwise=None)", "intent": "Calculate the expanding correlation . all 1 \u2019 s ) , except for DataFrame inputs with `pairwise` set to True . With arguments `**kwargs`.", "question_id": 44391}
{"snippet": "Expanding.corr(**kwargs, ddof=1)", "intent": "Calculate the expanding correlation . With arguments `**kwargs`, `ddof`.", "question_id": 44392}
{"snippet": "Expanding.corr(**kwargs, other=None, pairwise=None)", "intent": "Calculate the expanding correlation . When `other` is not specified , the output will be self correlation ( e.g . all 1 \u2019 s ) , except for DataFrame inputs with `pairwise` set to True . With arguments `**kwargs`.", "question_id": 44393}
{"snippet": "Expanding.corr(**kwargs, other=None, ddof=1)", "intent": "Calculate the expanding correlation . When `other` is not specified , the output will be self correlation ( e.g . With arguments `**kwargs`, `ddof`.", "question_id": 44394}
{"snippet": "Expanding.corr(**kwargs, pairwise=None, ddof=1)", "intent": "Calculate the expanding correlation . all 1 \u2019 s ) , except for DataFrame inputs with `pairwise` set to True . With arguments `**kwargs`, `ddof`.", "question_id": 44395}
{"snippet": "Expanding.corr(**kwargs, other=None, pairwise=None, ddof=1)", "intent": "Calculate the expanding correlation . When `other` is not specified , the output will be self correlation ( e.g . all 1 \u2019 s ) , except for DataFrame inputs with `pairwise` set to True . With arguments `**kwargs`, `ddof`.", "question_id": 44396}
{"snippet": "Expanding.corr(**kwargs)", "intent": "Calculate the expanding correlation . With arguments `**kwargs`.", "question_id": 44397}
{"snippet": "Expanding.corr(**kwargs, other=None)", "intent": "Calculate the expanding correlation . When `other` is not specified , the output will be self correlation ( e.g . With arguments `**kwargs`.", "question_id": 44398}
{"snippet": "Expanding.corr(**kwargs, pairwise=None)", "intent": "Calculate the expanding correlation . all 1 \u2019 s ) , except for DataFrame inputs with `pairwise` set to True . With arguments `**kwargs`.", "question_id": 44399}
{"snippet": "Expanding.corr(**kwargs, ddof=1)", "intent": "Calculate the expanding correlation . With arguments `**kwargs`, `ddof`.", "question_id": 44400}
{"snippet": "Expanding.corr(**kwargs, other=None, pairwise=None)", "intent": "Calculate the expanding correlation . When `other` is not specified , the output will be self correlation ( e.g . all 1 \u2019 s ) , except for DataFrame inputs with `pairwise` set to True . With arguments `**kwargs`.", "question_id": 44401}
{"snippet": "Expanding.corr(**kwargs, other=None, ddof=1)", "intent": "Calculate the expanding correlation . When `other` is not specified , the output will be self correlation ( e.g . With arguments `**kwargs`, `ddof`.", "question_id": 44402}
{"snippet": "Expanding.corr(**kwargs, pairwise=None, ddof=1)", "intent": "Calculate the expanding correlation . all 1 \u2019 s ) , except for DataFrame inputs with `pairwise` set to True . With arguments `**kwargs`, `ddof`.", "question_id": 44403}
{"snippet": "Expanding.corr(**kwargs, other=None, pairwise=None, ddof=1)", "intent": "Calculate the expanding correlation . When `other` is not specified , the output will be self correlation ( e.g . all 1 \u2019 s ) , except for DataFrame inputs with `pairwise` set to True . With arguments `**kwargs`, `ddof`.", "question_id": 44404}
{"snippet": "Expanding.count()", "intent": "Calculate the expanding count of non NaN observations .", "question_id": 44405}
{"snippet": "Expanding.count()", "intent": "Calculate the expanding count of non NaN observations .", "question_id": 44406}
{"snippet": "Expanding.count()", "intent": "Calculate the expanding count of non NaN observations .", "question_id": 44407}
{"snippet": "Expanding.cov(**kwargs)", "intent": "Calculate the expanding sample covariance . With arguments `**kwargs`.", "question_id": 44408}
{"snippet": "Expanding.cov(**kwargs, other=None)", "intent": "Calculate the expanding sample covariance . With arguments `**kwargs`, `other`.", "question_id": 44409}
{"snippet": "Expanding.cov(**kwargs, pairwise=None)", "intent": "Calculate the expanding sample covariance . With arguments `**kwargs`, `pairwise`.", "question_id": 44410}
{"snippet": "Expanding.cov(**kwargs, ddof=1)", "intent": "Calculate the expanding sample covariance . With arguments `**kwargs`, `ddof`.", "question_id": 44411}
{"snippet": "Expanding.cov(**kwargs, other=None, pairwise=None)", "intent": "Calculate the expanding sample covariance . With arguments `**kwargs`, `other`, `pairwise`.", "question_id": 44412}
{"snippet": "Expanding.cov(**kwargs, other=None, ddof=1)", "intent": "Calculate the expanding sample covariance . With arguments `**kwargs`, `other`, `ddof`.", "question_id": 44413}
{"snippet": "Expanding.cov(**kwargs, pairwise=None, ddof=1)", "intent": "Calculate the expanding sample covariance . With arguments `**kwargs`, `pairwise`, `ddof`.", "question_id": 44414}
{"snippet": "Expanding.cov(**kwargs, other=None, pairwise=None, ddof=1)", "intent": "Calculate the expanding sample covariance . With arguments `**kwargs`, `other`, `pairwise`, `ddof`.", "question_id": 44415}
{"snippet": "Expanding.cov(**kwargs)", "intent": "Calculate the expanding sample covariance . With arguments `**kwargs`.", "question_id": 44416}
{"snippet": "Expanding.cov(**kwargs, other=None)", "intent": "Calculate the expanding sample covariance . With arguments `**kwargs`, `other`.", "question_id": 44417}
{"snippet": "Expanding.cov(**kwargs, pairwise=None)", "intent": "Calculate the expanding sample covariance . With arguments `**kwargs`, `pairwise`.", "question_id": 44418}
{"snippet": "Expanding.cov(**kwargs, ddof=1)", "intent": "Calculate the expanding sample covariance . With arguments `**kwargs`, `ddof`.", "question_id": 44419}
{"snippet": "Expanding.cov(**kwargs, other=None, pairwise=None)", "intent": "Calculate the expanding sample covariance . With arguments `**kwargs`, `other`, `pairwise`.", "question_id": 44420}
{"snippet": "Expanding.cov(**kwargs, other=None, ddof=1)", "intent": "Calculate the expanding sample covariance . With arguments `**kwargs`, `other`, `ddof`.", "question_id": 44421}
{"snippet": "Expanding.cov(**kwargs, pairwise=None, ddof=1)", "intent": "Calculate the expanding sample covariance . With arguments `**kwargs`, `pairwise`, `ddof`.", "question_id": 44422}
{"snippet": "Expanding.cov(**kwargs, other=None, pairwise=None, ddof=1)", "intent": "Calculate the expanding sample covariance . With arguments `**kwargs`, `other`, `pairwise`, `ddof`.", "question_id": 44423}
{"snippet": "Expanding.cov(**kwargs)", "intent": "Calculate the expanding sample covariance . With arguments `**kwargs`.", "question_id": 44424}
{"snippet": "Expanding.cov(**kwargs, other=None)", "intent": "Calculate the expanding sample covariance . With arguments `**kwargs`, `other`.", "question_id": 44425}
{"snippet": "Expanding.cov(**kwargs, pairwise=None)", "intent": "Calculate the expanding sample covariance . With arguments `**kwargs`, `pairwise`.", "question_id": 44426}
{"snippet": "Expanding.cov(**kwargs, ddof=1)", "intent": "Calculate the expanding sample covariance . With arguments `**kwargs`, `ddof`.", "question_id": 44427}
{"snippet": "Expanding.cov(**kwargs, other=None, pairwise=None)", "intent": "Calculate the expanding sample covariance . With arguments `**kwargs`, `other`, `pairwise`.", "question_id": 44428}
{"snippet": "Expanding.cov(**kwargs, other=None, ddof=1)", "intent": "Calculate the expanding sample covariance . With arguments `**kwargs`, `other`, `ddof`.", "question_id": 44429}
{"snippet": "Expanding.cov(**kwargs, pairwise=None, ddof=1)", "intent": "Calculate the expanding sample covariance . With arguments `**kwargs`, `pairwise`, `ddof`.", "question_id": 44430}
{"snippet": "Expanding.cov(**kwargs, other=None, pairwise=None, ddof=1)", "intent": "Calculate the expanding sample covariance . With arguments `**kwargs`, `other`, `pairwise`, `ddof`.", "question_id": 44431}
{"snippet": "Expanding.kurt(**kwargs)", "intent": "Calculate the expanding Fisher \u2019 s definition of kurtosis without bias . With arguments `**kwargs`.", "question_id": 44432}
{"snippet": "Expanding.kurt(**kwargs)", "intent": "Calculate the expanding Fisher \u2019 s definition of kurtosis without bias . With arguments `**kwargs`.", "question_id": 44433}
{"snippet": "Expanding.kurt(**kwargs)", "intent": "Calculate the expanding Fisher \u2019 s definition of kurtosis without bias . With arguments `**kwargs`.", "question_id": 44434}
{"snippet": "Expanding.max(*args, **kwargs)", "intent": "Calculate the expanding maximum . With arguments `*args`, `**kwargs`.", "question_id": 44435}
{"snippet": "Expanding.max(*args, **kwargs, engine=None)", "intent": "Calculate the expanding maximum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44436}
{"snippet": "Expanding.max(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the expanding maximum . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44437}
{"snippet": "Expanding.max(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the expanding maximum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44438}
{"snippet": "Expanding.max(*args, **kwargs)", "intent": "Calculate the expanding maximum . With arguments `*args`, `**kwargs`.", "question_id": 44439}
{"snippet": "Expanding.max(*args, **kwargs, engine=None)", "intent": "Calculate the expanding maximum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44440}
{"snippet": "Expanding.max(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the expanding maximum . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44441}
{"snippet": "Expanding.max(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the expanding maximum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44442}
{"snippet": "Expanding.max(*args, **kwargs)", "intent": "Calculate the expanding maximum . With arguments `*args`, `**kwargs`.", "question_id": 44443}
{"snippet": "Expanding.max(*args, **kwargs, engine=None)", "intent": "Calculate the expanding maximum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44444}
{"snippet": "Expanding.max(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the expanding maximum . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44445}
{"snippet": "Expanding.max(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the expanding maximum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44446}
{"snippet": "Expanding.mean(*args, **kwargs)", "intent": "Calculate the expanding mean . With arguments `*args`, `**kwargs`.", "question_id": 44447}
{"snippet": "Expanding.mean(*args, **kwargs, engine=None)", "intent": "Calculate the expanding mean . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44448}
{"snippet": "Expanding.mean(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the expanding mean . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44449}
{"snippet": "Expanding.mean(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the expanding mean . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44450}
{"snippet": "Expanding.mean(*args, **kwargs)", "intent": "Calculate the expanding mean . With arguments `*args`, `**kwargs`.", "question_id": 44451}
{"snippet": "Expanding.mean(*args, **kwargs, engine=None)", "intent": "Calculate the expanding mean . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44452}
{"snippet": "Expanding.mean(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the expanding mean . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44453}
{"snippet": "Expanding.mean(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the expanding mean . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44454}
{"snippet": "Expanding.mean(*args, **kwargs)", "intent": "Calculate the expanding mean . With arguments `*args`, `**kwargs`.", "question_id": 44455}
{"snippet": "Expanding.mean(*args, **kwargs, engine=None)", "intent": "Calculate the expanding mean . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44456}
{"snippet": "Expanding.mean(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the expanding mean . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44457}
{"snippet": "Expanding.mean(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the expanding mean . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44458}
{"snippet": "Expanding.median(**kwargs)", "intent": "Calculate the expanding median . With arguments `**kwargs`.", "question_id": 44459}
{"snippet": "Expanding.median(**kwargs, engine=None)", "intent": "Calculate the expanding median . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `**kwargs`.", "question_id": 44460}
{"snippet": "Expanding.median(**kwargs, engine_kwargs=None)", "intent": "Calculate the expanding median . With arguments `**kwargs`, `engine_kwargs`.", "question_id": 44461}
{"snippet": "Expanding.median(**kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the expanding median . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `**kwargs`, `engine_kwargs`.", "question_id": 44462}
{"snippet": "Expanding.median(**kwargs)", "intent": "Calculate the expanding median . With arguments `**kwargs`.", "question_id": 44463}
{"snippet": "Expanding.median(**kwargs, engine=None)", "intent": "Calculate the expanding median . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `**kwargs`.", "question_id": 44464}
{"snippet": "Expanding.median(**kwargs, engine_kwargs=None)", "intent": "Calculate the expanding median . With arguments `**kwargs`, `engine_kwargs`.", "question_id": 44465}
{"snippet": "Expanding.median(**kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the expanding median . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `**kwargs`, `engine_kwargs`.", "question_id": 44466}
{"snippet": "Expanding.median(**kwargs)", "intent": "Calculate the expanding median . With arguments `**kwargs`.", "question_id": 44467}
{"snippet": "Expanding.median(**kwargs, engine=None)", "intent": "Calculate the expanding median . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `**kwargs`.", "question_id": 44468}
{"snippet": "Expanding.median(**kwargs, engine_kwargs=None)", "intent": "Calculate the expanding median . With arguments `**kwargs`, `engine_kwargs`.", "question_id": 44469}
{"snippet": "Expanding.median(**kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the expanding median . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `**kwargs`, `engine_kwargs`.", "question_id": 44470}
{"snippet": "Expanding.min(*args, **kwargs)", "intent": "Calculate the expanding minimum . With arguments `*args`, `**kwargs`.", "question_id": 44471}
{"snippet": "Expanding.min(*args, **kwargs, engine=None)", "intent": "Calculate the expanding minimum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44472}
{"snippet": "Expanding.min(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the expanding minimum . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44473}
{"snippet": "Expanding.min(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the expanding minimum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44474}
{"snippet": "Expanding.min(*args, **kwargs)", "intent": "Calculate the expanding minimum . With arguments `*args`, `**kwargs`.", "question_id": 44475}
{"snippet": "Expanding.min(*args, **kwargs, engine=None)", "intent": "Calculate the expanding minimum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44476}
{"snippet": "Expanding.min(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the expanding minimum . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44477}
{"snippet": "Expanding.min(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the expanding minimum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44478}
{"snippet": "Expanding.min(*args, **kwargs)", "intent": "Calculate the expanding minimum . With arguments `*args`, `**kwargs`.", "question_id": 44479}
{"snippet": "Expanding.min(*args, **kwargs, engine=None)", "intent": "Calculate the expanding minimum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44480}
{"snippet": "Expanding.min(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the expanding minimum . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44481}
{"snippet": "Expanding.min(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the expanding minimum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44482}
{"snippet": "Expanding.quantile(quantile, **kwargs)", "intent": "Calculate the expanding `quantile` . With arguments `**kwargs`.", "question_id": 44483}
{"snippet": "Expanding.quantile(quantile, **kwargs, interpolation='linear')", "intent": "Calculate the expanding `quantile` . With arguments `**kwargs`, `interpolation`.", "question_id": 44484}
{"snippet": "Expanding.quantile(quantile, **kwargs)", "intent": "Calculate the expanding `quantile` . With arguments `**kwargs`.", "question_id": 44485}
{"snippet": "Expanding.quantile(quantile, **kwargs, interpolation='linear')", "intent": "Calculate the expanding `quantile` . With arguments `**kwargs`, `interpolation`.", "question_id": 44486}
{"snippet": "Expanding.quantile(quantile, **kwargs)", "intent": "Calculate the expanding `quantile` . With arguments `**kwargs`.", "question_id": 44487}
{"snippet": "Expanding.quantile(quantile, **kwargs, interpolation='linear')", "intent": "Calculate the expanding `quantile` . With arguments `**kwargs`, `interpolation`.", "question_id": 44488}
{"snippet": "Expanding.sem(*args, **kwargs)", "intent": "Calculate the expanding standard error of mean . With arguments `*args`, `**kwargs`.", "question_id": 44489}
{"snippet": "Expanding.sem(*args, **kwargs, ddof=1)", "intent": "Calculate the expanding standard error of mean . With arguments `*args`, `**kwargs`, `ddof`.", "question_id": 44490}
{"snippet": "Expanding.sem(*args, **kwargs)", "intent": "Calculate the expanding standard error of mean . With arguments `*args`, `**kwargs`.", "question_id": 44491}
{"snippet": "Expanding.sem(*args, **kwargs, ddof=1)", "intent": "Calculate the expanding standard error of mean . With arguments `*args`, `**kwargs`, `ddof`.", "question_id": 44492}
{"snippet": "Expanding.sem(*args, **kwargs)", "intent": "Calculate the expanding standard error of mean . With arguments `*args`, `**kwargs`.", "question_id": 44493}
{"snippet": "Expanding.sem(*args, **kwargs, ddof=1)", "intent": "Calculate the expanding standard error of mean . With arguments `*args`, `**kwargs`, `ddof`.", "question_id": 44494}
{"snippet": "Expanding.skew(**kwargs)", "intent": "Calculate the expanding unbiased skewness . With arguments `**kwargs`.", "question_id": 44495}
{"snippet": "Expanding.skew(**kwargs)", "intent": "Calculate the expanding unbiased skewness . With arguments `**kwargs`.", "question_id": 44496}
{"snippet": "Expanding.skew(**kwargs)", "intent": "Calculate the expanding unbiased skewness . With arguments `**kwargs`.", "question_id": 44497}
{"snippet": "Expanding.std(*args, **kwargs)", "intent": "Calculate the expanding standard deviation . With arguments `*args`, `**kwargs`.", "question_id": 44498}
{"snippet": "Expanding.std(*args, **kwargs, ddof=1)", "intent": "Calculate the expanding standard deviation . The default `ddof` of 1 used in Series.std ( ) is different than the default ddof of 0 in numpy.std ( ) . With arguments `*args`, `**kwargs`.", "question_id": 44499}
{"snippet": "Expanding.std(*args, **kwargs)", "intent": "Calculate the expanding standard deviation . With arguments `*args`, `**kwargs`.", "question_id": 44500}
{"snippet": "Expanding.std(*args, **kwargs, ddof=1)", "intent": "Calculate the expanding standard deviation . The default `ddof` of 1 used in Series.std ( ) is different than the default ddof of 0 in numpy.std ( ) . With arguments `*args`, `**kwargs`.", "question_id": 44501}
{"snippet": "Expanding.std(*args, **kwargs)", "intent": "Calculate the expanding standard deviation . With arguments `*args`, `**kwargs`.", "question_id": 44502}
{"snippet": "Expanding.std(*args, **kwargs, ddof=1)", "intent": "Calculate the expanding standard deviation . The default `ddof` of 1 used in Series.std ( ) is different than the default ddof of 0 in numpy.std ( ) . With arguments `*args`, `**kwargs`.", "question_id": 44503}
{"snippet": "Expanding.sum(*args, **kwargs)", "intent": "Calculate the expanding sum . With arguments `*args`, `**kwargs`.", "question_id": 44504}
{"snippet": "Expanding.sum(*args, **kwargs, engine=None)", "intent": "Calculate the expanding sum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44505}
{"snippet": "Expanding.sum(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the expanding sum . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44506}
{"snippet": "Expanding.sum(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the expanding sum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44507}
{"snippet": "Expanding.sum(*args, **kwargs)", "intent": "Calculate the expanding sum . With arguments `*args`, `**kwargs`.", "question_id": 44508}
{"snippet": "Expanding.sum(*args, **kwargs, engine=None)", "intent": "Calculate the expanding sum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44509}
{"snippet": "Expanding.sum(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the expanding sum . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44510}
{"snippet": "Expanding.sum(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the expanding sum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44511}
{"snippet": "Expanding.sum(*args, **kwargs)", "intent": "Calculate the expanding sum . With arguments `*args`, `**kwargs`.", "question_id": 44512}
{"snippet": "Expanding.sum(*args, **kwargs, engine=None)", "intent": "Calculate the expanding sum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44513}
{"snippet": "Expanding.sum(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the expanding sum . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44514}
{"snippet": "Expanding.sum(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the expanding sum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44515}
{"snippet": "Expanding.var(*args, **kwargs)", "intent": "Calculate the expanding variance . With arguments `*args`, `**kwargs`.", "question_id": 44516}
{"snippet": "Expanding.var(*args, **kwargs, ddof=1)", "intent": "Calculate the expanding variance . The default `ddof` of 1 used in Series.var ( ) is different than the default ddof of 0 in numpy.var ( ) . With arguments `*args`, `**kwargs`.", "question_id": 44517}
{"snippet": "Expanding.var(*args, **kwargs)", "intent": "Calculate the expanding variance . With arguments `*args`, `**kwargs`.", "question_id": 44518}
{"snippet": "Expanding.var(*args, **kwargs, ddof=1)", "intent": "Calculate the expanding variance . The default `ddof` of 1 used in Series.var ( ) is different than the default ddof of 0 in numpy.var ( ) . With arguments `*args`, `**kwargs`.", "question_id": 44519}
{"snippet": "Expanding.var(*args, **kwargs)", "intent": "Calculate the expanding variance . With arguments `*args`, `**kwargs`.", "question_id": 44520}
{"snippet": "Expanding.var(*args, **kwargs, ddof=1)", "intent": "Calculate the expanding variance . The default `ddof` of 1 used in Series.var ( ) is different than the default ddof of 0 in numpy.var ( ) . With arguments `*args`, `**kwargs`.", "question_id": 44521}
{"snippet": "Rolling.aggregate(func, *args, **kwargs)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `func`, `*args`, `**kwargs`.", "question_id": 44522}
{"snippet": "Rolling.aggregate(func, *args, **kwargs)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `func`, `*args`, `**kwargs`.", "question_id": 44523}
{"snippet": "Rolling.aggregate(func, *args, **kwargs)", "intent": "Aggregate using one or more operations over the specified axis . With arguments `func`, `*args`, `**kwargs`.", "question_id": 44524}
{"snippet": "Rolling.apply(func)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`.", "question_id": 44525}
{"snippet": "Rolling.apply(func, raw=False)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `raw`.", "question_id": 44526}
{"snippet": "Rolling.apply(func, engine=None)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `engine`.", "question_id": 44527}
{"snippet": "Rolling.apply(func, engine_kwargs=None)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `engine_kwargs`.", "question_id": 44528}
{"snippet": "Rolling.apply(func, args=None)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `args`.", "question_id": 44529}
{"snippet": "Rolling.apply(func, kwargs=None)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `kwargs`.", "question_id": 44530}
{"snippet": "Rolling.apply(func, raw=False, engine=None)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `raw`, `engine`.", "question_id": 44531}
{"snippet": "Rolling.apply(func, raw=False, engine_kwargs=None)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `raw`, `engine_kwargs`.", "question_id": 44532}
{"snippet": "Rolling.apply(func, raw=False, args=None)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `raw`, `args`.", "question_id": 44533}
{"snippet": "Rolling.apply(func, raw=False, kwargs=None)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `raw`, `kwargs`.", "question_id": 44534}
{"snippet": "Rolling.apply(func)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`.", "question_id": 44535}
{"snippet": "Rolling.apply(func, raw=False)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `raw`.", "question_id": 44536}
{"snippet": "Rolling.apply(func, engine=None)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `engine`.", "question_id": 44537}
{"snippet": "Rolling.apply(func, engine_kwargs=None)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `engine_kwargs`.", "question_id": 44538}
{"snippet": "Rolling.apply(func, args=None)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `args`.", "question_id": 44539}
{"snippet": "Rolling.apply(func, kwargs=None)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `kwargs`.", "question_id": 44540}
{"snippet": "Rolling.apply(func, raw=False, engine=None)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `raw`, `engine`.", "question_id": 44541}
{"snippet": "Rolling.apply(func, raw=False, engine_kwargs=None)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `raw`, `engine_kwargs`.", "question_id": 44542}
{"snippet": "Rolling.apply(func, raw=False, args=None)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `raw`, `args`.", "question_id": 44543}
{"snippet": "Rolling.apply(func, raw=False, kwargs=None)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `raw`, `kwargs`.", "question_id": 44544}
{"snippet": "Rolling.apply(func)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`.", "question_id": 44545}
{"snippet": "Rolling.apply(func, raw=False)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `raw`.", "question_id": 44546}
{"snippet": "Rolling.apply(func, engine=None)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `engine`.", "question_id": 44547}
{"snippet": "Rolling.apply(func, engine_kwargs=None)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `engine_kwargs`.", "question_id": 44548}
{"snippet": "Rolling.apply(func, args=None)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `args`.", "question_id": 44549}
{"snippet": "Rolling.apply(func, kwargs=None)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `kwargs`.", "question_id": 44550}
{"snippet": "Rolling.apply(func, raw=False, engine=None)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `raw`, `engine`.", "question_id": 44551}
{"snippet": "Rolling.apply(func, raw=False, engine_kwargs=None)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `raw`, `engine_kwargs`.", "question_id": 44552}
{"snippet": "Rolling.apply(func, raw=False, args=None)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `raw`, `args`.", "question_id": 44553}
{"snippet": "Rolling.apply(func, raw=False, kwargs=None)", "intent": "Calculate the rolling custom aggregation function . With arguments `func`, `raw`, `kwargs`.", "question_id": 44554}
{"snippet": "Rolling.corr(**kwargs)", "intent": "Calculate the rolling correlation . With arguments `**kwargs`.", "question_id": 44555}
{"snippet": "Rolling.corr(**kwargs, other=None)", "intent": "Calculate the rolling correlation . When `other` is not specified , the output will be self correlation ( e.g . With arguments `**kwargs`.", "question_id": 44556}
{"snippet": "Rolling.corr(**kwargs, pairwise=None)", "intent": "Calculate the rolling correlation . all 1 \u2019 s ) , except for DataFrame inputs with `pairwise` set to True . With arguments `**kwargs`.", "question_id": 44557}
{"snippet": "Rolling.corr(**kwargs, ddof=1)", "intent": "Calculate the rolling correlation . With arguments `**kwargs`, `ddof`.", "question_id": 44558}
{"snippet": "Rolling.corr(**kwargs, other=None, pairwise=None)", "intent": "Calculate the rolling correlation . When `other` is not specified , the output will be self correlation ( e.g . all 1 \u2019 s ) , except for DataFrame inputs with `pairwise` set to True . With arguments `**kwargs`.", "question_id": 44559}
{"snippet": "Rolling.corr(**kwargs, other=None, ddof=1)", "intent": "Calculate the rolling correlation . When `other` is not specified , the output will be self correlation ( e.g . With arguments `**kwargs`, `ddof`.", "question_id": 44560}
{"snippet": "Rolling.corr(**kwargs, pairwise=None, ddof=1)", "intent": "Calculate the rolling correlation . all 1 \u2019 s ) , except for DataFrame inputs with `pairwise` set to True . With arguments `**kwargs`, `ddof`.", "question_id": 44561}
{"snippet": "Rolling.corr(**kwargs, other=None, pairwise=None, ddof=1)", "intent": "Calculate the rolling correlation . When `other` is not specified , the output will be self correlation ( e.g . all 1 \u2019 s ) , except for DataFrame inputs with `pairwise` set to True . With arguments `**kwargs`, `ddof`.", "question_id": 44562}
{"snippet": "Rolling.corr(**kwargs)", "intent": "Calculate the rolling correlation . With arguments `**kwargs`.", "question_id": 44563}
{"snippet": "Rolling.corr(**kwargs, other=None)", "intent": "Calculate the rolling correlation . When `other` is not specified , the output will be self correlation ( e.g . With arguments `**kwargs`.", "question_id": 44564}
{"snippet": "Rolling.corr(**kwargs, pairwise=None)", "intent": "Calculate the rolling correlation . all 1 \u2019 s ) , except for DataFrame inputs with `pairwise` set to True . With arguments `**kwargs`.", "question_id": 44565}
{"snippet": "Rolling.corr(**kwargs, ddof=1)", "intent": "Calculate the rolling correlation . With arguments `**kwargs`, `ddof`.", "question_id": 44566}
{"snippet": "Rolling.corr(**kwargs, other=None, pairwise=None)", "intent": "Calculate the rolling correlation . When `other` is not specified , the output will be self correlation ( e.g . all 1 \u2019 s ) , except for DataFrame inputs with `pairwise` set to True . With arguments `**kwargs`.", "question_id": 44567}
{"snippet": "Rolling.corr(**kwargs, other=None, ddof=1)", "intent": "Calculate the rolling correlation . When `other` is not specified , the output will be self correlation ( e.g . With arguments `**kwargs`, `ddof`.", "question_id": 44568}
{"snippet": "Rolling.corr(**kwargs, pairwise=None, ddof=1)", "intent": "Calculate the rolling correlation . all 1 \u2019 s ) , except for DataFrame inputs with `pairwise` set to True . With arguments `**kwargs`, `ddof`.", "question_id": 44569}
{"snippet": "Rolling.corr(**kwargs, other=None, pairwise=None, ddof=1)", "intent": "Calculate the rolling correlation . When `other` is not specified , the output will be self correlation ( e.g . all 1 \u2019 s ) , except for DataFrame inputs with `pairwise` set to True . With arguments `**kwargs`, `ddof`.", "question_id": 44570}
{"snippet": "Rolling.corr(**kwargs)", "intent": "Calculate the rolling correlation . With arguments `**kwargs`.", "question_id": 44571}
{"snippet": "Rolling.corr(**kwargs, other=None)", "intent": "Calculate the rolling correlation . When `other` is not specified , the output will be self correlation ( e.g . With arguments `**kwargs`.", "question_id": 44572}
{"snippet": "Rolling.corr(**kwargs, pairwise=None)", "intent": "Calculate the rolling correlation . all 1 \u2019 s ) , except for DataFrame inputs with `pairwise` set to True . With arguments `**kwargs`.", "question_id": 44573}
{"snippet": "Rolling.corr(**kwargs, ddof=1)", "intent": "Calculate the rolling correlation . With arguments `**kwargs`, `ddof`.", "question_id": 44574}
{"snippet": "Rolling.corr(**kwargs, other=None, pairwise=None)", "intent": "Calculate the rolling correlation . When `other` is not specified , the output will be self correlation ( e.g . all 1 \u2019 s ) , except for DataFrame inputs with `pairwise` set to True . With arguments `**kwargs`.", "question_id": 44575}
{"snippet": "Rolling.corr(**kwargs, other=None, ddof=1)", "intent": "Calculate the rolling correlation . When `other` is not specified , the output will be self correlation ( e.g . With arguments `**kwargs`, `ddof`.", "question_id": 44576}
{"snippet": "Rolling.corr(**kwargs, pairwise=None, ddof=1)", "intent": "Calculate the rolling correlation . all 1 \u2019 s ) , except for DataFrame inputs with `pairwise` set to True . With arguments `**kwargs`, `ddof`.", "question_id": 44577}
{"snippet": "Rolling.corr(**kwargs, other=None, pairwise=None, ddof=1)", "intent": "Calculate the rolling correlation . When `other` is not specified , the output will be self correlation ( e.g . all 1 \u2019 s ) , except for DataFrame inputs with `pairwise` set to True . With arguments `**kwargs`, `ddof`.", "question_id": 44578}
{"snippet": "Rolling.count()", "intent": "Calculate the rolling count of non NaN observations .", "question_id": 44579}
{"snippet": "Rolling.count()", "intent": "Calculate the rolling count of non NaN observations .", "question_id": 44580}
{"snippet": "Rolling.count()", "intent": "Calculate the rolling count of non NaN observations .", "question_id": 44581}
{"snippet": "Rolling.cov(**kwargs)", "intent": "Calculate the rolling sample covariance . With arguments `**kwargs`.", "question_id": 44582}
{"snippet": "Rolling.cov(**kwargs, other=None)", "intent": "Calculate the rolling sample covariance . With arguments `**kwargs`, `other`.", "question_id": 44583}
{"snippet": "Rolling.cov(**kwargs, pairwise=None)", "intent": "Calculate the rolling sample covariance . With arguments `**kwargs`, `pairwise`.", "question_id": 44584}
{"snippet": "Rolling.cov(**kwargs, ddof=1)", "intent": "Calculate the rolling sample covariance . With arguments `**kwargs`, `ddof`.", "question_id": 44585}
{"snippet": "Rolling.cov(**kwargs, other=None, pairwise=None)", "intent": "Calculate the rolling sample covariance . With arguments `**kwargs`, `other`, `pairwise`.", "question_id": 44586}
{"snippet": "Rolling.cov(**kwargs, other=None, ddof=1)", "intent": "Calculate the rolling sample covariance . With arguments `**kwargs`, `other`, `ddof`.", "question_id": 44587}
{"snippet": "Rolling.cov(**kwargs, pairwise=None, ddof=1)", "intent": "Calculate the rolling sample covariance . With arguments `**kwargs`, `pairwise`, `ddof`.", "question_id": 44588}
{"snippet": "Rolling.cov(**kwargs, other=None, pairwise=None, ddof=1)", "intent": "Calculate the rolling sample covariance . With arguments `**kwargs`, `other`, `pairwise`, `ddof`.", "question_id": 44589}
{"snippet": "Rolling.cov(**kwargs)", "intent": "Calculate the rolling sample covariance . With arguments `**kwargs`.", "question_id": 44590}
{"snippet": "Rolling.cov(**kwargs, other=None)", "intent": "Calculate the rolling sample covariance . With arguments `**kwargs`, `other`.", "question_id": 44591}
{"snippet": "Rolling.cov(**kwargs, pairwise=None)", "intent": "Calculate the rolling sample covariance . With arguments `**kwargs`, `pairwise`.", "question_id": 44592}
{"snippet": "Rolling.cov(**kwargs, ddof=1)", "intent": "Calculate the rolling sample covariance . With arguments `**kwargs`, `ddof`.", "question_id": 44593}
{"snippet": "Rolling.cov(**kwargs, other=None, pairwise=None)", "intent": "Calculate the rolling sample covariance . With arguments `**kwargs`, `other`, `pairwise`.", "question_id": 44594}
{"snippet": "Rolling.cov(**kwargs, other=None, ddof=1)", "intent": "Calculate the rolling sample covariance . With arguments `**kwargs`, `other`, `ddof`.", "question_id": 44595}
{"snippet": "Rolling.cov(**kwargs, pairwise=None, ddof=1)", "intent": "Calculate the rolling sample covariance . With arguments `**kwargs`, `pairwise`, `ddof`.", "question_id": 44596}
{"snippet": "Rolling.cov(**kwargs, other=None, pairwise=None, ddof=1)", "intent": "Calculate the rolling sample covariance . With arguments `**kwargs`, `other`, `pairwise`, `ddof`.", "question_id": 44597}
{"snippet": "Rolling.cov(**kwargs)", "intent": "Calculate the rolling sample covariance . With arguments `**kwargs`.", "question_id": 44598}
{"snippet": "Rolling.cov(**kwargs, other=None)", "intent": "Calculate the rolling sample covariance . With arguments `**kwargs`, `other`.", "question_id": 44599}
{"snippet": "Rolling.cov(**kwargs, pairwise=None)", "intent": "Calculate the rolling sample covariance . With arguments `**kwargs`, `pairwise`.", "question_id": 44600}
{"snippet": "Rolling.cov(**kwargs, ddof=1)", "intent": "Calculate the rolling sample covariance . With arguments `**kwargs`, `ddof`.", "question_id": 44601}
{"snippet": "Rolling.cov(**kwargs, other=None, pairwise=None)", "intent": "Calculate the rolling sample covariance . With arguments `**kwargs`, `other`, `pairwise`.", "question_id": 44602}
{"snippet": "Rolling.cov(**kwargs, other=None, ddof=1)", "intent": "Calculate the rolling sample covariance . With arguments `**kwargs`, `other`, `ddof`.", "question_id": 44603}
{"snippet": "Rolling.cov(**kwargs, pairwise=None, ddof=1)", "intent": "Calculate the rolling sample covariance . With arguments `**kwargs`, `pairwise`, `ddof`.", "question_id": 44604}
{"snippet": "Rolling.cov(**kwargs, other=None, pairwise=None, ddof=1)", "intent": "Calculate the rolling sample covariance . With arguments `**kwargs`, `other`, `pairwise`, `ddof`.", "question_id": 44605}
{"snippet": "Rolling.kurt(**kwargs)", "intent": "Calculate the rolling Fisher \u2019 s definition of kurtosis without bias . With arguments `**kwargs`.", "question_id": 44606}
{"snippet": "Rolling.kurt(**kwargs)", "intent": "Calculate the rolling Fisher \u2019 s definition of kurtosis without bias . With arguments `**kwargs`.", "question_id": 44607}
{"snippet": "Rolling.kurt(**kwargs)", "intent": "Calculate the rolling Fisher \u2019 s definition of kurtosis without bias . With arguments `**kwargs`.", "question_id": 44608}
{"snippet": "Rolling.max(*args, **kwargs)", "intent": "Calculate the rolling maximum . With arguments `*args`, `**kwargs`.", "question_id": 44609}
{"snippet": "Rolling.max(*args, **kwargs, engine=None)", "intent": "Calculate the rolling maximum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44610}
{"snippet": "Rolling.max(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the rolling maximum . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44611}
{"snippet": "Rolling.max(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the rolling maximum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44612}
{"snippet": "Rolling.max(*args, **kwargs)", "intent": "Calculate the rolling maximum . With arguments `*args`, `**kwargs`.", "question_id": 44613}
{"snippet": "Rolling.max(*args, **kwargs, engine=None)", "intent": "Calculate the rolling maximum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44614}
{"snippet": "Rolling.max(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the rolling maximum . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44615}
{"snippet": "Rolling.max(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the rolling maximum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44616}
{"snippet": "Rolling.max(*args, **kwargs)", "intent": "Calculate the rolling maximum . With arguments `*args`, `**kwargs`.", "question_id": 44617}
{"snippet": "Rolling.max(*args, **kwargs, engine=None)", "intent": "Calculate the rolling maximum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44618}
{"snippet": "Rolling.max(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the rolling maximum . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44619}
{"snippet": "Rolling.max(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the rolling maximum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44620}
{"snippet": "Rolling.mean(*args, **kwargs)", "intent": "Calculate the rolling mean . With arguments `*args`, `**kwargs`.", "question_id": 44621}
{"snippet": "Rolling.mean(*args, **kwargs, engine=None)", "intent": "Calculate the rolling mean . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44622}
{"snippet": "Rolling.mean(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the rolling mean . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44623}
{"snippet": "Rolling.mean(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the rolling mean . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44624}
{"snippet": "Rolling.mean(*args, **kwargs)", "intent": "Calculate the rolling mean . With arguments `*args`, `**kwargs`.", "question_id": 44625}
{"snippet": "Rolling.mean(*args, **kwargs, engine=None)", "intent": "Calculate the rolling mean . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44626}
{"snippet": "Rolling.mean(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the rolling mean . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44627}
{"snippet": "Rolling.mean(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the rolling mean . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44628}
{"snippet": "Rolling.mean(*args, **kwargs)", "intent": "Calculate the rolling mean . With arguments `*args`, `**kwargs`.", "question_id": 44629}
{"snippet": "Rolling.mean(*args, **kwargs, engine=None)", "intent": "Calculate the rolling mean . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44630}
{"snippet": "Rolling.mean(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the rolling mean . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44631}
{"snippet": "Rolling.mean(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the rolling mean . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44632}
{"snippet": "Rolling.median(**kwargs)", "intent": "Calculate the rolling median . With arguments `**kwargs`.", "question_id": 44633}
{"snippet": "Rolling.median(**kwargs, engine=None)", "intent": "Calculate the rolling median . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `**kwargs`.", "question_id": 44634}
{"snippet": "Rolling.median(**kwargs, engine_kwargs=None)", "intent": "Calculate the rolling median . With arguments `**kwargs`, `engine_kwargs`.", "question_id": 44635}
{"snippet": "Rolling.median(**kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the rolling median . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `**kwargs`, `engine_kwargs`.", "question_id": 44636}
{"snippet": "Rolling.median(**kwargs)", "intent": "Calculate the rolling median . With arguments `**kwargs`.", "question_id": 44637}
{"snippet": "Rolling.median(**kwargs, engine=None)", "intent": "Calculate the rolling median . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `**kwargs`.", "question_id": 44638}
{"snippet": "Rolling.median(**kwargs, engine_kwargs=None)", "intent": "Calculate the rolling median . With arguments `**kwargs`, `engine_kwargs`.", "question_id": 44639}
{"snippet": "Rolling.median(**kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the rolling median . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `**kwargs`, `engine_kwargs`.", "question_id": 44640}
{"snippet": "Rolling.median(**kwargs)", "intent": "Calculate the rolling median . With arguments `**kwargs`.", "question_id": 44641}
{"snippet": "Rolling.median(**kwargs, engine=None)", "intent": "Calculate the rolling median . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `**kwargs`.", "question_id": 44642}
{"snippet": "Rolling.median(**kwargs, engine_kwargs=None)", "intent": "Calculate the rolling median . With arguments `**kwargs`, `engine_kwargs`.", "question_id": 44643}
{"snippet": "Rolling.median(**kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the rolling median . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `**kwargs`, `engine_kwargs`.", "question_id": 44644}
{"snippet": "Rolling.min(*args, **kwargs)", "intent": "Calculate the rolling minimum . With arguments `*args`, `**kwargs`.", "question_id": 44645}
{"snippet": "Rolling.min(*args, **kwargs, engine=None)", "intent": "Calculate the rolling minimum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44646}
{"snippet": "Rolling.min(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the rolling minimum . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44647}
{"snippet": "Rolling.min(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the rolling minimum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44648}
{"snippet": "Rolling.min(*args, **kwargs)", "intent": "Calculate the rolling minimum . With arguments `*args`, `**kwargs`.", "question_id": 44649}
{"snippet": "Rolling.min(*args, **kwargs, engine=None)", "intent": "Calculate the rolling minimum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44650}
{"snippet": "Rolling.min(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the rolling minimum . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44651}
{"snippet": "Rolling.min(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the rolling minimum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44652}
{"snippet": "Rolling.min(*args, **kwargs)", "intent": "Calculate the rolling minimum . With arguments `*args`, `**kwargs`.", "question_id": 44653}
{"snippet": "Rolling.min(*args, **kwargs, engine=None)", "intent": "Calculate the rolling minimum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44654}
{"snippet": "Rolling.min(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the rolling minimum . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44655}
{"snippet": "Rolling.min(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the rolling minimum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44656}
{"snippet": "Rolling.quantile(quantile, **kwargs)", "intent": "Calculate the rolling `quantile` . With arguments `**kwargs`.", "question_id": 44657}
{"snippet": "Rolling.quantile(quantile, **kwargs, interpolation='linear')", "intent": "Calculate the rolling `quantile` . With arguments `**kwargs`, `interpolation`.", "question_id": 44658}
{"snippet": "Rolling.quantile(quantile, **kwargs)", "intent": "Calculate the rolling `quantile` . With arguments `**kwargs`.", "question_id": 44659}
{"snippet": "Rolling.quantile(quantile, **kwargs, interpolation='linear')", "intent": "Calculate the rolling `quantile` . With arguments `**kwargs`, `interpolation`.", "question_id": 44660}
{"snippet": "Rolling.quantile(quantile, **kwargs)", "intent": "Calculate the rolling `quantile` . With arguments `**kwargs`.", "question_id": 44661}
{"snippet": "Rolling.quantile(quantile, **kwargs, interpolation='linear')", "intent": "Calculate the rolling `quantile` . With arguments `**kwargs`, `interpolation`.", "question_id": 44662}
{"snippet": "Rolling.sem(*args, **kwargs)", "intent": "Calculate the rolling standard error of mean . With arguments `*args`, `**kwargs`.", "question_id": 44663}
{"snippet": "Rolling.sem(*args, **kwargs, ddof=1)", "intent": "Calculate the rolling standard error of mean . With arguments `*args`, `**kwargs`, `ddof`.", "question_id": 44664}
{"snippet": "Rolling.sem(*args, **kwargs)", "intent": "Calculate the rolling standard error of mean . With arguments `*args`, `**kwargs`.", "question_id": 44665}
{"snippet": "Rolling.sem(*args, **kwargs, ddof=1)", "intent": "Calculate the rolling standard error of mean . With arguments `*args`, `**kwargs`, `ddof`.", "question_id": 44666}
{"snippet": "Rolling.sem(*args, **kwargs)", "intent": "Calculate the rolling standard error of mean . With arguments `*args`, `**kwargs`.", "question_id": 44667}
{"snippet": "Rolling.sem(*args, **kwargs, ddof=1)", "intent": "Calculate the rolling standard error of mean . With arguments `*args`, `**kwargs`, `ddof`.", "question_id": 44668}
{"snippet": "Rolling.skew(**kwargs)", "intent": "Calculate the rolling unbiased skewness . With arguments `**kwargs`.", "question_id": 44669}
{"snippet": "Rolling.skew(**kwargs)", "intent": "Calculate the rolling unbiased skewness . With arguments `**kwargs`.", "question_id": 44670}
{"snippet": "Rolling.skew(**kwargs)", "intent": "Calculate the rolling unbiased skewness . With arguments `**kwargs`.", "question_id": 44671}
{"snippet": "Rolling.std(*args, **kwargs)", "intent": "Calculate the rolling standard deviation . With arguments `*args`, `**kwargs`.", "question_id": 44672}
{"snippet": "Rolling.std(*args, **kwargs, ddof=1)", "intent": "Calculate the rolling standard deviation . The default `ddof` of 1 used in Series.std ( ) is different than the default ddof of 0 in numpy.std ( ) . With arguments `*args`, `**kwargs`.", "question_id": 44673}
{"snippet": "Rolling.std(*args, **kwargs)", "intent": "Calculate the rolling standard deviation . With arguments `*args`, `**kwargs`.", "question_id": 44674}
{"snippet": "Rolling.std(*args, **kwargs, ddof=1)", "intent": "Calculate the rolling standard deviation . The default `ddof` of 1 used in Series.std ( ) is different than the default ddof of 0 in numpy.std ( ) . With arguments `*args`, `**kwargs`.", "question_id": 44675}
{"snippet": "Rolling.std(*args, **kwargs)", "intent": "Calculate the rolling standard deviation . With arguments `*args`, `**kwargs`.", "question_id": 44676}
{"snippet": "Rolling.std(*args, **kwargs, ddof=1)", "intent": "Calculate the rolling standard deviation . The default `ddof` of 1 used in Series.std ( ) is different than the default ddof of 0 in numpy.std ( ) . With arguments `*args`, `**kwargs`.", "question_id": 44677}
{"snippet": "Rolling.sum(*args, **kwargs)", "intent": "Calculate the rolling sum . With arguments `*args`, `**kwargs`.", "question_id": 44678}
{"snippet": "Rolling.sum(*args, **kwargs, engine=None)", "intent": "Calculate the rolling sum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44679}
{"snippet": "Rolling.sum(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the rolling sum . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44680}
{"snippet": "Rolling.sum(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the rolling sum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44681}
{"snippet": "Rolling.sum(*args, **kwargs)", "intent": "Calculate the rolling sum . With arguments `*args`, `**kwargs`.", "question_id": 44682}
{"snippet": "Rolling.sum(*args, **kwargs, engine=None)", "intent": "Calculate the rolling sum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44683}
{"snippet": "Rolling.sum(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the rolling sum . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44684}
{"snippet": "Rolling.sum(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the rolling sum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44685}
{"snippet": "Rolling.sum(*args, **kwargs)", "intent": "Calculate the rolling sum . With arguments `*args`, `**kwargs`.", "question_id": 44686}
{"snippet": "Rolling.sum(*args, **kwargs, engine=None)", "intent": "Calculate the rolling sum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`.", "question_id": 44687}
{"snippet": "Rolling.sum(*args, **kwargs, engine_kwargs=None)", "intent": "Calculate the rolling sum . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44688}
{"snippet": "Rolling.sum(*args, **kwargs, engine=None, engine_kwargs=None)", "intent": "Calculate the rolling sum . See Numba `engine` and Numba ( JIT compilation ) for extended documentation and performance considerations for the Numba engine . With arguments `*args`, `**kwargs`, `engine_kwargs`.", "question_id": 44689}
{"snippet": "Rolling.var(*args, **kwargs)", "intent": "Calculate the rolling variance . With arguments `*args`, `**kwargs`.", "question_id": 44690}
{"snippet": "Rolling.var(*args, **kwargs, ddof=1)", "intent": "Calculate the rolling variance . The default `ddof` of 1 used in Series.var ( ) is different than the default ddof of 0 in numpy.var ( ) . With arguments `*args`, `**kwargs`.", "question_id": 44691}
{"snippet": "Rolling.var(*args, **kwargs)", "intent": "Calculate the rolling variance . With arguments `*args`, `**kwargs`.", "question_id": 44692}
{"snippet": "Rolling.var(*args, **kwargs, ddof=1)", "intent": "Calculate the rolling variance . The default `ddof` of 1 used in Series.var ( ) is different than the default ddof of 0 in numpy.var ( ) . With arguments `*args`, `**kwargs`.", "question_id": 44693}
{"snippet": "Rolling.var(*args, **kwargs)", "intent": "Calculate the rolling variance . With arguments `*args`, `**kwargs`.", "question_id": 44694}
{"snippet": "Rolling.var(*args, **kwargs, ddof=1)", "intent": "Calculate the rolling variance . The default `ddof` of 1 used in Series.var ( ) is different than the default ddof of 0 in numpy.var ( ) . With arguments `*args`, `**kwargs`.", "question_id": 44695}
{"snippet": "Window.mean(*args, **kwargs)", "intent": "Calculate the rolling weighted window mean . With arguments `*args`, `**kwargs`.", "question_id": 44696}
{"snippet": "Window.mean(*args, **kwargs)", "intent": "Calculate the rolling weighted window mean . With arguments `*args`, `**kwargs`.", "question_id": 44697}
{"snippet": "Window.mean(*args, **kwargs)", "intent": "Calculate the rolling weighted window mean . With arguments `*args`, `**kwargs`.", "question_id": 44698}
{"snippet": "Window.std(*args, **kwargs)", "intent": "Calculate the rolling weighted window standard deviation . With arguments `*args`, `**kwargs`.", "question_id": 44699}
{"snippet": "Window.std(*args, **kwargs, ddof=1)", "intent": "Calculate the rolling weighted window standard deviation . With arguments `*args`, `**kwargs`, `ddof`.", "question_id": 44700}
{"snippet": "Window.std(*args, **kwargs)", "intent": "Calculate the rolling weighted window standard deviation . With arguments `*args`, `**kwargs`.", "question_id": 44701}
{"snippet": "Window.std(*args, **kwargs, ddof=1)", "intent": "Calculate the rolling weighted window standard deviation . With arguments `*args`, `**kwargs`, `ddof`.", "question_id": 44702}
{"snippet": "Window.std(*args, **kwargs)", "intent": "Calculate the rolling weighted window standard deviation . With arguments `*args`, `**kwargs`.", "question_id": 44703}
{"snippet": "Window.std(*args, **kwargs, ddof=1)", "intent": "Calculate the rolling weighted window standard deviation . With arguments `*args`, `**kwargs`, `ddof`.", "question_id": 44704}
{"snippet": "Window.sum(*args, **kwargs)", "intent": "Calculate the rolling weighted window sum . With arguments `*args`, `**kwargs`.", "question_id": 44705}
{"snippet": "Window.sum(*args, **kwargs)", "intent": "Calculate the rolling weighted window sum . With arguments `*args`, `**kwargs`.", "question_id": 44706}
{"snippet": "Window.sum(*args, **kwargs)", "intent": "Calculate the rolling weighted window sum . With arguments `*args`, `**kwargs`.", "question_id": 44707}
{"snippet": "Window.var(*args, **kwargs)", "intent": "Calculate the rolling weighted window variance . With arguments `*args`, `**kwargs`.", "question_id": 44708}
{"snippet": "Window.var(*args, **kwargs, ddof=1)", "intent": "Calculate the rolling weighted window variance . With arguments `*args`, `**kwargs`, `ddof`.", "question_id": 44709}
{"snippet": "Window.var(*args, **kwargs)", "intent": "Calculate the rolling weighted window variance . With arguments `*args`, `**kwargs`.", "question_id": 44710}
{"snippet": "Window.var(*args, **kwargs, ddof=1)", "intent": "Calculate the rolling weighted window variance . With arguments `*args`, `**kwargs`, `ddof`.", "question_id": 44711}
{"snippet": "Window.var(*args, **kwargs)", "intent": "Calculate the rolling weighted window variance . With arguments `*args`, `**kwargs`.", "question_id": 44712}
{"snippet": "Window.var(*args, **kwargs, ddof=1)", "intent": "Calculate the rolling weighted window variance . With arguments `*args`, `**kwargs`, `ddof`.", "question_id": 44713}
{"snippet": "pandas.crosstab(index, columns)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . With arguments `index`, `columns`.", "question_id": 44714}
{"snippet": "pandas.crosstab(index, columns, values=None)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . By default computes a frequency table of the factors unless an array of `values` and an aggregation function are passed . With arguments `index`, `columns`.", "question_id": 44715}
{"snippet": "pandas.crosstab(index, columns, rownames=None)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . With arguments `index`, `columns`, `rownames`.", "question_id": 44716}
{"snippet": "pandas.crosstab(index, columns, colnames=None)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . With arguments `index`, `columns`, `colnames`.", "question_id": 44717}
{"snippet": "pandas.crosstab(index, columns, aggfunc=None)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . With arguments `index`, `columns`, `aggfunc`.", "question_id": 44718}
{"snippet": "pandas.crosstab(index, columns, margins=False)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . With arguments `index`, `columns`, `margins`.", "question_id": 44719}
{"snippet": "pandas.crosstab(index, columns, margins_name='All')", "intent": "Compute a simple cross tabulation of two ( or more ) factors . With arguments `index`, `columns`, `margins_name`.", "question_id": 44720}
{"snippet": "pandas.crosstab(index, columns, dropna=True)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . Here \u2018 c \u2019 and \u2018 f \u2019 are not represented in the data and will not be shown in the output because `dropna` is True by default . With arguments `index`, `columns`.", "question_id": 44721}
{"snippet": "pandas.crosstab(index, columns, normalize=False)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . With arguments `index`, `columns`, `normalize`.", "question_id": 44722}
{"snippet": "pandas.crosstab(index, columns, values=None, rownames=None)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . By default computes a frequency table of the factors unless an array of `values` and an aggregation function are passed . With arguments `index`, `columns`, `rownames`.", "question_id": 44723}
{"snippet": "pandas.crosstab(index, columns)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . With arguments `index`, `columns`.", "question_id": 44724}
{"snippet": "pandas.crosstab(index, columns, values=None)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . By default computes a frequency table of the factors unless an array of `values` and an aggregation function are passed . With arguments `index`, `columns`.", "question_id": 44725}
{"snippet": "pandas.crosstab(index, columns, rownames=None)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . With arguments `index`, `columns`, `rownames`.", "question_id": 44726}
{"snippet": "pandas.crosstab(index, columns, colnames=None)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . With arguments `index`, `columns`, `colnames`.", "question_id": 44727}
{"snippet": "pandas.crosstab(index, columns, aggfunc=None)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . With arguments `index`, `columns`, `aggfunc`.", "question_id": 44728}
{"snippet": "pandas.crosstab(index, columns, margins=False)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . With arguments `index`, `columns`, `margins`.", "question_id": 44729}
{"snippet": "pandas.crosstab(index, columns, margins_name='All')", "intent": "Compute a simple cross tabulation of two ( or more ) factors . With arguments `index`, `columns`, `margins_name`.", "question_id": 44730}
{"snippet": "pandas.crosstab(index, columns, dropna=True)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . Here \u2018 c \u2019 and \u2018 f \u2019 are not represented in the data and will not be shown in the output because `dropna` is True by default . With arguments `index`, `columns`.", "question_id": 44731}
{"snippet": "pandas.crosstab(index, columns, normalize=False)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . With arguments `index`, `columns`, `normalize`.", "question_id": 44732}
{"snippet": "pandas.crosstab(index, columns, values=None, rownames=None)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . By default computes a frequency table of the factors unless an array of `values` and an aggregation function are passed . With arguments `index`, `columns`, `rownames`.", "question_id": 44733}
{"snippet": "pandas.crosstab(index, columns)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . With arguments `index`, `columns`.", "question_id": 44734}
{"snippet": "pandas.crosstab(index, columns, values=None)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . By default computes a frequency table of the factors unless an array of `values` and an aggregation function are passed . With arguments `index`, `columns`.", "question_id": 44735}
{"snippet": "pandas.crosstab(index, columns, rownames=None)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . With arguments `index`, `columns`, `rownames`.", "question_id": 44736}
{"snippet": "pandas.crosstab(index, columns, colnames=None)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . With arguments `index`, `columns`, `colnames`.", "question_id": 44737}
{"snippet": "pandas.crosstab(index, columns, aggfunc=None)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . With arguments `index`, `columns`, `aggfunc`.", "question_id": 44738}
{"snippet": "pandas.crosstab(index, columns, margins=False)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . With arguments `index`, `columns`, `margins`.", "question_id": 44739}
{"snippet": "pandas.crosstab(index, columns, margins_name='All')", "intent": "Compute a simple cross tabulation of two ( or more ) factors . With arguments `index`, `columns`, `margins_name`.", "question_id": 44740}
{"snippet": "pandas.crosstab(index, columns, dropna=True)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . Here \u2018 c \u2019 and \u2018 f \u2019 are not represented in the data and will not be shown in the output because `dropna` is True by default . With arguments `index`, `columns`.", "question_id": 44741}
{"snippet": "pandas.crosstab(index, columns, normalize=False)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . With arguments `index`, `columns`, `normalize`.", "question_id": 44742}
{"snippet": "pandas.crosstab(index, columns, values=None, rownames=None)", "intent": "Compute a simple cross tabulation of two ( or more ) factors . By default computes a frequency table of the factors unless an array of `values` and an aggregation function are passed . With arguments `index`, `columns`, `rownames`.", "question_id": 44743}
{"snippet": "pandas.cut(x, bins)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . With arguments `x`.", "question_id": 44744}
{"snippet": "pandas.cut(x, bins, right=True)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . 0 is to the left of the first bin ( which is closed on the `right` ) , and 1.5 falls between two bins . With arguments `x`.", "question_id": 44745}
{"snippet": "pandas.cut(x, bins, labels=None)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . Discovers the same bins , but assign them specific `labels` . With arguments `x`.", "question_id": 44746}
{"snippet": "pandas.cut(x, bins, retbins=False)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . With arguments `x`, `retbins`.", "question_id": 44747}
{"snippet": "pandas.cut(x, bins, precision=3)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . With arguments `x`, `precision`.", "question_id": 44748}
{"snippet": "pandas.cut(x, bins, include_lowest=False)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . With arguments `x`, `include_lowest`.", "question_id": 44749}
{"snippet": "pandas.cut(x, bins, duplicates='raise')", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . With arguments `x`, `duplicates`.", "question_id": 44750}
{"snippet": "pandas.cut(x, bins, ordered=True)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . Notice that the returned Categorical \u2019 s categories are labels and is `ordered` . With arguments `x`.", "question_id": 44751}
{"snippet": "pandas.cut(x, bins, right=True, labels=None)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . 0 is to the left of the first bin ( which is closed on the `right` ) , and 1.5 falls between two bins . Discovers the same bins , but assign them specific `labels` . With arguments `x`.", "question_id": 44752}
{"snippet": "pandas.cut(x, bins, right=True, retbins=False)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . 0 is to the left of the first bin ( which is closed on the `right` ) , and 1.5 falls between two bins . With arguments `x`, `retbins`.", "question_id": 44753}
{"snippet": "pandas.cut(x, bins)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . With arguments `x`.", "question_id": 44754}
{"snippet": "pandas.cut(x, bins, right=True)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . 0 is to the left of the first bin ( which is closed on the `right` ) , and 1.5 falls between two bins . With arguments `x`.", "question_id": 44755}
{"snippet": "pandas.cut(x, bins, labels=None)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . Discovers the same bins , but assign them specific `labels` . With arguments `x`.", "question_id": 44756}
{"snippet": "pandas.cut(x, bins, retbins=False)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . With arguments `x`, `retbins`.", "question_id": 44757}
{"snippet": "pandas.cut(x, bins, precision=3)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . With arguments `x`, `precision`.", "question_id": 44758}
{"snippet": "pandas.cut(x, bins, include_lowest=False)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . With arguments `x`, `include_lowest`.", "question_id": 44759}
{"snippet": "pandas.cut(x, bins, duplicates='raise')", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . With arguments `x`, `duplicates`.", "question_id": 44760}
{"snippet": "pandas.cut(x, bins, ordered=True)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . Notice that the returned Categorical \u2019 s categories are labels and is `ordered` . With arguments `x`.", "question_id": 44761}
{"snippet": "pandas.cut(x, bins, right=True, labels=None)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . 0 is to the left of the first bin ( which is closed on the `right` ) , and 1.5 falls between two bins . Discovers the same bins , but assign them specific `labels` . With arguments `x`.", "question_id": 44762}
{"snippet": "pandas.cut(x, bins, right=True, retbins=False)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . 0 is to the left of the first bin ( which is closed on the `right` ) , and 1.5 falls between two bins . With arguments `x`, `retbins`.", "question_id": 44763}
{"snippet": "pandas.cut(x, bins)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . With arguments `x`.", "question_id": 44764}
{"snippet": "pandas.cut(x, bins, right=True)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . 0 is to the left of the first bin ( which is closed on the `right` ) , and 1.5 falls between two bins . With arguments `x`.", "question_id": 44765}
{"snippet": "pandas.cut(x, bins, labels=None)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . Discovers the same bins , but assign them specific `labels` . With arguments `x`.", "question_id": 44766}
{"snippet": "pandas.cut(x, bins, retbins=False)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . With arguments `x`, `retbins`.", "question_id": 44767}
{"snippet": "pandas.cut(x, bins, precision=3)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . With arguments `x`, `precision`.", "question_id": 44768}
{"snippet": "pandas.cut(x, bins, include_lowest=False)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . With arguments `x`, `include_lowest`.", "question_id": 44769}
{"snippet": "pandas.cut(x, bins, duplicates='raise')", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . With arguments `x`, `duplicates`.", "question_id": 44770}
{"snippet": "pandas.cut(x, bins, ordered=True)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . Notice that the returned Categorical \u2019 s categories are labels and is `ordered` . With arguments `x`.", "question_id": 44771}
{"snippet": "pandas.cut(x, bins, right=True, labels=None)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . 0 is to the left of the first bin ( which is closed on the `right` ) , and 1.5 falls between two bins . Discovers the same bins , but assign them specific `labels` . With arguments `x`.", "question_id": 44772}
{"snippet": "pandas.cut(x, bins, right=True, retbins=False)", "intent": "Bin values into discrete intervals . Use cut when you need to segment and sort data values into `bins` . 0 is to the left of the first bin ( which is closed on the `right` ) , and 1.5 falls between two bins . With arguments `x`, `retbins`.", "question_id": 44773}
{"snippet": "pandas.date_range(**kwargs)", "intent": "Return a fixed frequency DatetimeIndex . With arguments `**kwargs`.", "question_id": 44774}
{"snippet": "pandas.date_range(**kwargs, start=None)", "intent": "Return a fixed frequency DatetimeIndex . Returns the range of equally spaced time points ( where the difference between any two adjacent points is specified by the given frequency ) such that they all satisfy `start` < [ = ] x < [ = ] `end` , where the first one and the last one are , resp. , the first and last time points in that range that fall on the boundary of `freq` ( if given as a frequency string ) or that are valid for freq ( if given as a pandas.tseries.offsets.DateOffset ) . With arguments `**kwargs`.", "question_id": 44775}
{"snippet": "pandas.date_range(**kwargs, end=None)", "intent": "Return a fixed frequency DatetimeIndex . Returns the range of equally spaced time points ( where the difference between any two adjacent points is specified by the given frequency ) such that they all satisfy `start` < [ = ] x < [ = ] `end` , where the first one and the last one are , resp. , the first and last time points in that range that fall on the boundary of `freq` ( if given as a frequency string ) or that are valid for freq ( if given as a pandas.tseries.offsets.DateOffset ) . With arguments `**kwargs`.", "question_id": 44776}
{"snippet": "pandas.date_range(**kwargs, periods=None)", "intent": "Return a fixed frequency DatetimeIndex . ( If exactly one of start , end , or freq is not specified , this missing parameter can be computed given `periods` , the number of timesteps in the range . With arguments `**kwargs`.", "question_id": 44777}
{"snippet": "pandas.date_range(**kwargs, freq=None)", "intent": "Return a fixed frequency DatetimeIndex . Returns the range of equally spaced time points ( where the difference between any two adjacent points is specified by the given frequency ) such that they all satisfy `start` < [ = ] x < [ = ] `end` , where the first one and the last one are , resp. , the first and last time points in that range that fall on the boundary of `freq` ( if given as a frequency string ) or that are valid for freq ( if given as a pandas.tseries.offsets.DateOffset ) . With arguments `**kwargs`.", "question_id": 44778}
{"snippet": "pandas.date_range(**kwargs, tz=None)", "intent": "Return a fixed frequency DatetimeIndex . Specify `tz` to set the timezone . With arguments `**kwargs`.", "question_id": 44779}
{"snippet": "pandas.date_range(**kwargs, normalize=False)", "intent": "Return a fixed frequency DatetimeIndex . With arguments `**kwargs`, `normalize`.", "question_id": 44780}
{"snippet": "pandas.date_range(**kwargs, name=None)", "intent": "Return a fixed frequency DatetimeIndex . With arguments `**kwargs`, `name`.", "question_id": 44781}
{"snippet": "pandas.date_range(**kwargs, closed=None)", "intent": "Return a fixed frequency DatetimeIndex . If freq is omitted , the resulting DatetimeIndex will have periods linearly spaced elements between start and end ( `closed` on both sides ) . With arguments `**kwargs`.", "question_id": 44782}
{"snippet": "pandas.date_range(**kwargs, start=None, end=None)", "intent": "Return a fixed frequency DatetimeIndex . Returns the range of equally spaced time points ( where the difference between any two adjacent points is specified by the given frequency ) such that they all satisfy `start` < [ = ] x < [ = ] `end` , where the first one and the last one are , resp. , the first and last time points in that range that fall on the boundary of `freq` ( if given as a frequency string ) or that are valid for freq ( if given as a pandas.tseries.offsets.DateOffset ) . With arguments `**kwargs`.", "question_id": 44783}
{"snippet": "pandas.date_range(**kwargs)", "intent": "Return a fixed frequency DatetimeIndex . With arguments `**kwargs`.", "question_id": 44784}
{"snippet": "pandas.date_range(**kwargs, start=None)", "intent": "Return a fixed frequency DatetimeIndex . Returns the range of equally spaced time points ( where the difference between any two adjacent points is specified by the given frequency ) such that they all satisfy `start` < [ = ] x < [ = ] `end` , where the first one and the last one are , resp. , the first and last time points in that range that fall on the boundary of `freq` ( if given as a frequency string ) or that are valid for freq ( if given as a pandas.tseries.offsets.DateOffset ) . With arguments `**kwargs`.", "question_id": 44785}
{"snippet": "pandas.date_range(**kwargs, end=None)", "intent": "Return a fixed frequency DatetimeIndex . Returns the range of equally spaced time points ( where the difference between any two adjacent points is specified by the given frequency ) such that they all satisfy `start` < [ = ] x < [ = ] `end` , where the first one and the last one are , resp. , the first and last time points in that range that fall on the boundary of `freq` ( if given as a frequency string ) or that are valid for freq ( if given as a pandas.tseries.offsets.DateOffset ) . With arguments `**kwargs`.", "question_id": 44786}
{"snippet": "pandas.date_range(**kwargs, periods=None)", "intent": "Return a fixed frequency DatetimeIndex . ( If exactly one of start , end , or freq is not specified , this missing parameter can be computed given `periods` , the number of timesteps in the range . With arguments `**kwargs`.", "question_id": 44787}
{"snippet": "pandas.date_range(**kwargs, freq=None)", "intent": "Return a fixed frequency DatetimeIndex . Returns the range of equally spaced time points ( where the difference between any two adjacent points is specified by the given frequency ) such that they all satisfy `start` < [ = ] x < [ = ] `end` , where the first one and the last one are , resp. , the first and last time points in that range that fall on the boundary of `freq` ( if given as a frequency string ) or that are valid for freq ( if given as a pandas.tseries.offsets.DateOffset ) . With arguments `**kwargs`.", "question_id": 44788}
{"snippet": "pandas.date_range(**kwargs, tz=None)", "intent": "Return a fixed frequency DatetimeIndex . Specify `tz` to set the timezone . With arguments `**kwargs`.", "question_id": 44789}
{"snippet": "pandas.date_range(**kwargs, normalize=False)", "intent": "Return a fixed frequency DatetimeIndex . With arguments `**kwargs`, `normalize`.", "question_id": 44790}
{"snippet": "pandas.date_range(**kwargs, name=None)", "intent": "Return a fixed frequency DatetimeIndex . With arguments `**kwargs`, `name`.", "question_id": 44791}
{"snippet": "pandas.date_range(**kwargs, closed=None)", "intent": "Return a fixed frequency DatetimeIndex . If freq is omitted , the resulting DatetimeIndex will have periods linearly spaced elements between start and end ( `closed` on both sides ) . With arguments `**kwargs`.", "question_id": 44792}
{"snippet": "pandas.date_range(**kwargs, start=None, end=None)", "intent": "Return a fixed frequency DatetimeIndex . Returns the range of equally spaced time points ( where the difference between any two adjacent points is specified by the given frequency ) such that they all satisfy `start` < [ = ] x < [ = ] `end` , where the first one and the last one are , resp. , the first and last time points in that range that fall on the boundary of `freq` ( if given as a frequency string ) or that are valid for freq ( if given as a pandas.tseries.offsets.DateOffset ) . With arguments `**kwargs`.", "question_id": 44793}
{"snippet": "pandas.date_range(**kwargs)", "intent": "Return a fixed frequency DatetimeIndex . With arguments `**kwargs`.", "question_id": 44794}
{"snippet": "pandas.date_range(**kwargs, start=None)", "intent": "Return a fixed frequency DatetimeIndex . Returns the range of equally spaced time points ( where the difference between any two adjacent points is specified by the given frequency ) such that they all satisfy `start` < [ = ] x < [ = ] `end` , where the first one and the last one are , resp. , the first and last time points in that range that fall on the boundary of `freq` ( if given as a frequency string ) or that are valid for freq ( if given as a pandas.tseries.offsets.DateOffset ) . With arguments `**kwargs`.", "question_id": 44795}
{"snippet": "pandas.date_range(**kwargs, end=None)", "intent": "Return a fixed frequency DatetimeIndex . Returns the range of equally spaced time points ( where the difference between any two adjacent points is specified by the given frequency ) such that they all satisfy `start` < [ = ] x < [ = ] `end` , where the first one and the last one are , resp. , the first and last time points in that range that fall on the boundary of `freq` ( if given as a frequency string ) or that are valid for freq ( if given as a pandas.tseries.offsets.DateOffset ) . With arguments `**kwargs`.", "question_id": 44796}
{"snippet": "pandas.date_range(**kwargs, periods=None)", "intent": "Return a fixed frequency DatetimeIndex . ( If exactly one of start , end , or freq is not specified , this missing parameter can be computed given `periods` , the number of timesteps in the range . With arguments `**kwargs`.", "question_id": 44797}
{"snippet": "pandas.date_range(**kwargs, freq=None)", "intent": "Return a fixed frequency DatetimeIndex . Returns the range of equally spaced time points ( where the difference between any two adjacent points is specified by the given frequency ) such that they all satisfy `start` < [ = ] x < [ = ] `end` , where the first one and the last one are , resp. , the first and last time points in that range that fall on the boundary of `freq` ( if given as a frequency string ) or that are valid for freq ( if given as a pandas.tseries.offsets.DateOffset ) . With arguments `**kwargs`.", "question_id": 44798}
{"snippet": "pandas.date_range(**kwargs, tz=None)", "intent": "Return a fixed frequency DatetimeIndex . Specify `tz` to set the timezone . With arguments `**kwargs`.", "question_id": 44799}
{"snippet": "pandas.date_range(**kwargs, normalize=False)", "intent": "Return a fixed frequency DatetimeIndex . With arguments `**kwargs`, `normalize`.", "question_id": 44800}
{"snippet": "pandas.date_range(**kwargs, name=None)", "intent": "Return a fixed frequency DatetimeIndex . With arguments `**kwargs`, `name`.", "question_id": 44801}
{"snippet": "pandas.date_range(**kwargs, closed=None)", "intent": "Return a fixed frequency DatetimeIndex . If freq is omitted , the resulting DatetimeIndex will have periods linearly spaced elements between start and end ( `closed` on both sides ) . With arguments `**kwargs`.", "question_id": 44802}
{"snippet": "pandas.date_range(**kwargs, start=None, end=None)", "intent": "Return a fixed frequency DatetimeIndex . Returns the range of equally spaced time points ( where the difference between any two adjacent points is specified by the given frequency ) such that they all satisfy `start` < [ = ] x < [ = ] `end` , where the first one and the last one are , resp. , the first and last time points in that range that fall on the boundary of `freq` ( if given as a frequency string ) or that are valid for freq ( if given as a pandas.tseries.offsets.DateOffset ) . With arguments `**kwargs`.", "question_id": 44803}
{"snippet": "pandas.describe_option(pat)", "intent": "Prints the description for one or more registered options . With arguments `pat`.", "question_id": 44804}
{"snippet": "pandas.describe_option(pat, _print_desc=False)", "intent": "Prints the description for one or more registered options . With arguments `pat`, `_print_desc`.", "question_id": 44805}
{"snippet": "pandas.describe_option(pat)", "intent": "Prints the description for one or more registered options . With arguments `pat`.", "question_id": 44806}
{"snippet": "pandas.describe_option(pat, _print_desc=False)", "intent": "Prints the description for one or more registered options . With arguments `pat`, `_print_desc`.", "question_id": 44807}
{"snippet": "pandas.describe_option(pat)", "intent": "Prints the description for one or more registered options . With arguments `pat`.", "question_id": 44808}
{"snippet": "pandas.describe_option(pat, _print_desc=False)", "intent": "Prints the description for one or more registered options . With arguments `pat`, `_print_desc`.", "question_id": 44809}
{"snippet": "pandas.errors.AccessorRegistrationWarning", "intent": "Warning for attribute conflicts in accessor registration.", "question_id": 44810}
{"snippet": "pandas.errors.AccessorRegistrationWarning", "intent": "Warning for attribute conflicts in accessor registration.", "question_id": 44811}
{"snippet": "pandas.errors.AccessorRegistrationWarning", "intent": "Warning for attribute conflicts in accessor registration.", "question_id": 44812}
{"snippet": "pandas.errors.DtypeWarning", "intent": "Warning raised when reading different dtypes in a column from a file.", "question_id": 44813}
{"snippet": "pandas.errors.DtypeWarning", "intent": "Warning raised when reading different dtypes in a column from a file.", "question_id": 44814}
{"snippet": "pandas.errors.DtypeWarning", "intent": "Warning raised when reading different dtypes in a column from a file.", "question_id": 44815}
{"snippet": "pandas.errors.DuplicateLabelError", "intent": "Error raised when an operation would introduce duplicate labels.", "question_id": 44816}
{"snippet": "pandas.errors.DuplicateLabelError", "intent": "Error raised when an operation would introduce duplicate labels.", "question_id": 44817}
{"snippet": "pandas.errors.DuplicateLabelError", "intent": "Error raised when an operation would introduce duplicate labels.", "question_id": 44818}
{"snippet": "pandas.errors.EmptyDataError", "intent": "Exception that is thrown in pd.read_csv (by both the C and Python engines) when empty data or header is encountered.", "question_id": 44819}
{"snippet": "pandas.errors.EmptyDataError", "intent": "Exception that is thrown in pd.read_csv (by both the C and Python engines) when empty data or header is encountered.", "question_id": 44820}
{"snippet": "pandas.errors.EmptyDataError", "intent": "Exception that is thrown in pd.read_csv (by both the C and Python engines) when empty data or header is encountered.", "question_id": 44821}
{"snippet": "pandas.errors.InvalidIndexError", "intent": "Exception raised when attempting to use an invalid index key.", "question_id": 44822}
{"snippet": "pandas.errors.InvalidIndexError", "intent": "Exception raised when attempting to use an invalid index key.", "question_id": 44823}
{"snippet": "pandas.errors.InvalidIndexError", "intent": "Exception raised when attempting to use an invalid index key.", "question_id": 44824}
{"snippet": "pandas.errors.MergeError", "intent": "Error raised when problems arise during merging due to problems with input data.", "question_id": 44825}
{"snippet": "pandas.errors.MergeError", "intent": "Error raised when problems arise during merging due to problems with input data.", "question_id": 44826}
{"snippet": "pandas.errors.MergeError", "intent": "Error raised when problems arise during merging due to problems with input data.", "question_id": 44827}
{"snippet": "pandas.errors.NullFrequencyError", "intent": "Error raised when a null freq attribute is used in an operation that needs a non-null frequency, particularly DatetimeIndex.shift, TimedeltaIndex.shift, PeriodIndex.shift.", "question_id": 44828}
{"snippet": "pandas.errors.NullFrequencyError", "intent": "Error raised when a null freq attribute is used in an operation that needs a non-null frequency, particularly DatetimeIndex.shift, TimedeltaIndex.shift, PeriodIndex.shift.", "question_id": 44829}
{"snippet": "pandas.errors.NullFrequencyError", "intent": "Error raised when a null freq attribute is used in an operation that needs a non-null frequency, particularly DatetimeIndex.shift, TimedeltaIndex.shift, PeriodIndex.shift.", "question_id": 44830}
{"snippet": "pandas.errors.NumbaUtilError", "intent": "Error raised for unsupported Numba engine routines.", "question_id": 44831}
{"snippet": "pandas.errors.NumbaUtilError", "intent": "Error raised for unsupported Numba engine routines.", "question_id": 44832}
{"snippet": "pandas.errors.NumbaUtilError", "intent": "Error raised for unsupported Numba engine routines.", "question_id": 44833}
{"snippet": "pandas.errors.OutOfBoundsTimedelta", "intent": "Raised when encountering a timedelta value that cannot be represented as a timedelta64[ns].", "question_id": 44834}
{"snippet": "pandas.errors.OutOfBoundsTimedelta", "intent": "Raised when encountering a timedelta value that cannot be represented as a timedelta64[ns].", "question_id": 44835}
{"snippet": "pandas.errors.OutOfBoundsTimedelta", "intent": "Raised when encountering a timedelta value that cannot be represented as a timedelta64[ns].", "question_id": 44836}
{"snippet": "pandas.errors.ParserError", "intent": "Exception that is raised by an error encountered in parsing file contents.", "question_id": 44837}
{"snippet": "pandas.errors.ParserError", "intent": "Exception that is raised by an error encountered in parsing file contents.", "question_id": 44838}
{"snippet": "pandas.errors.ParserError", "intent": "Exception that is raised by an error encountered in parsing file contents.", "question_id": 44839}
{"snippet": "pandas.errors.ParserWarning", "intent": "Warning raised when reading a file that doesn\u2019t use the default \u2018c\u2019 parser.", "question_id": 44840}
{"snippet": "pandas.errors.ParserWarning", "intent": "Warning raised when reading a file that doesn\u2019t use the default \u2018c\u2019 parser.", "question_id": 44841}
{"snippet": "pandas.errors.ParserWarning", "intent": "Warning raised when reading a file that doesn\u2019t use the default \u2018c\u2019 parser.", "question_id": 44842}
{"snippet": "pandas.errors.PerformanceWarning", "intent": "Warning raised when there is a possible performance impact.", "question_id": 44843}
{"snippet": "pandas.errors.PerformanceWarning", "intent": "Warning raised when there is a possible performance impact.", "question_id": 44844}
{"snippet": "pandas.errors.PerformanceWarning", "intent": "Warning raised when there is a possible performance impact.", "question_id": 44845}
{"snippet": "pandas.errors.UnsortedIndexError", "intent": "Error raised when attempting to get a slice of a MultiIndex, and the index has not been lexsorted.", "question_id": 44846}
{"snippet": "pandas.errors.UnsortedIndexError", "intent": "Error raised when attempting to get a slice of a MultiIndex, and the index has not been lexsorted.", "question_id": 44847}
{"snippet": "pandas.errors.UnsortedIndexError", "intent": "Error raised when attempting to get a slice of a MultiIndex, and the index has not been lexsorted.", "question_id": 44848}
{"snippet": "pandas.errors.UnsupportedFunctionCall", "intent": "Exception raised when attempting to call a numpy function on a pandas object, but that function is not supported by the object e.g.", "question_id": 44849}
{"snippet": "pandas.errors.UnsupportedFunctionCall", "intent": "Exception raised when attempting to call a numpy function on a pandas object, but that function is not supported by the object e.g.", "question_id": 44850}
{"snippet": "pandas.errors.UnsupportedFunctionCall", "intent": "Exception raised when attempting to call a numpy function on a pandas object, but that function is not supported by the object e.g.", "question_id": 44851}
{"snippet": "pandas.eval(expr)", "intent": "Evaluate a Python expression as a string using various backends . With arguments `expr`.", "question_id": 44852}
{"snippet": "pandas.eval(expr, parser='pandas')", "intent": "Evaluate a Python expression as a string using various backends . Additionally , the 'pandas ' `parser` allows the use of and , or , and not with the same semantics as the corresponding bitwise operators . With arguments `expr`.", "question_id": 44853}
{"snippet": "pandas.eval(expr, engine=None)", "intent": "Evaluate a Python expression as a string using various backends . The following arithmetic operations are supported : + , - , * , / , * * , % , // ( python `engine` only ) along with the following boolean operations : | ( or ) , & ( and ) , and ~ ( not ) . With arguments `expr`.", "question_id": 44854}
{"snippet": "pandas.eval(expr, truediv=NoDefault.no_default)", "intent": "Evaluate a Python expression as a string using various backends . With arguments `expr`, `truediv`.", "question_id": 44855}
{"snippet": "pandas.eval(expr, local_dict=None)", "intent": "Evaluate a Python expression as a string using various backends . With arguments `expr`, `local_dict`.", "question_id": 44856}
{"snippet": "pandas.eval(expr, global_dict=None)", "intent": "Evaluate a Python expression as a string using various backends . With arguments `expr`, `global_dict`.", "question_id": 44857}
{"snippet": "pandas.eval(expr, resolvers=())", "intent": "Evaluate a Python expression as a string using various backends . With arguments `expr`, `resolvers`.", "question_id": 44858}
{"snippet": "pandas.eval(expr, level=0)", "intent": "Evaluate a Python expression as a string using various backends . With arguments `expr`, `level`.", "question_id": 44859}
{"snippet": "pandas.eval(expr, target=None)", "intent": "Evaluate a Python expression as a string using various backends . With arguments `expr`, `target`.", "question_id": 44860}
{"snippet": "pandas.eval(expr, inplace=False)", "intent": "Evaluate a Python expression as a string using various backends . With arguments `expr`, `inplace`.", "question_id": 44861}
{"snippet": "pandas.eval(expr)", "intent": "Evaluate a Python expression as a string using various backends . With arguments `expr`.", "question_id": 44862}
{"snippet": "pandas.eval(expr, parser='pandas')", "intent": "Evaluate a Python expression as a string using various backends . Additionally , the 'pandas ' `parser` allows the use of and , or , and not with the same semantics as the corresponding bitwise operators . With arguments `expr`.", "question_id": 44863}
{"snippet": "pandas.eval(expr, engine=None)", "intent": "Evaluate a Python expression as a string using various backends . The following arithmetic operations are supported : + , - , * , / , * * , % , // ( python `engine` only ) along with the following boolean operations : | ( or ) , & ( and ) , and ~ ( not ) . With arguments `expr`.", "question_id": 44864}
{"snippet": "pandas.eval(expr, truediv=NoDefault.no_default)", "intent": "Evaluate a Python expression as a string using various backends . With arguments `expr`, `truediv`.", "question_id": 44865}
{"snippet": "pandas.eval(expr, local_dict=None)", "intent": "Evaluate a Python expression as a string using various backends . With arguments `expr`, `local_dict`.", "question_id": 44866}
{"snippet": "pandas.eval(expr, global_dict=None)", "intent": "Evaluate a Python expression as a string using various backends . With arguments `expr`, `global_dict`.", "question_id": 44867}
{"snippet": "pandas.eval(expr, resolvers=())", "intent": "Evaluate a Python expression as a string using various backends . With arguments `expr`, `resolvers`.", "question_id": 44868}
{"snippet": "pandas.eval(expr, level=0)", "intent": "Evaluate a Python expression as a string using various backends . With arguments `expr`, `level`.", "question_id": 44869}
{"snippet": "pandas.eval(expr, target=None)", "intent": "Evaluate a Python expression as a string using various backends . With arguments `expr`, `target`.", "question_id": 44870}
{"snippet": "pandas.eval(expr, inplace=False)", "intent": "Evaluate a Python expression as a string using various backends . With arguments `expr`, `inplace`.", "question_id": 44871}
{"snippet": "pandas.eval(expr)", "intent": "Evaluate a Python expression as a string using various backends . With arguments `expr`.", "question_id": 44872}
{"snippet": "pandas.eval(expr, parser='pandas')", "intent": "Evaluate a Python expression as a string using various backends . Additionally , the 'pandas ' `parser` allows the use of and , or , and not with the same semantics as the corresponding bitwise operators . With arguments `expr`.", "question_id": 44873}
{"snippet": "pandas.eval(expr, engine=None)", "intent": "Evaluate a Python expression as a string using various backends . The following arithmetic operations are supported : + , - , * , / , * * , % , // ( python `engine` only ) along with the following boolean operations : | ( or ) , & ( and ) , and ~ ( not ) . With arguments `expr`.", "question_id": 44874}
{"snippet": "pandas.eval(expr, truediv=NoDefault.no_default)", "intent": "Evaluate a Python expression as a string using various backends . With arguments `expr`, `truediv`.", "question_id": 44875}
{"snippet": "pandas.eval(expr, local_dict=None)", "intent": "Evaluate a Python expression as a string using various backends . With arguments `expr`, `local_dict`.", "question_id": 44876}
{"snippet": "pandas.eval(expr, global_dict=None)", "intent": "Evaluate a Python expression as a string using various backends . With arguments `expr`, `global_dict`.", "question_id": 44877}
{"snippet": "pandas.eval(expr, resolvers=())", "intent": "Evaluate a Python expression as a string using various backends . With arguments `expr`, `resolvers`.", "question_id": 44878}
{"snippet": "pandas.eval(expr, level=0)", "intent": "Evaluate a Python expression as a string using various backends . With arguments `expr`, `level`.", "question_id": 44879}
{"snippet": "pandas.eval(expr, target=None)", "intent": "Evaluate a Python expression as a string using various backends . With arguments `expr`, `target`.", "question_id": 44880}
{"snippet": "pandas.eval(expr, inplace=False)", "intent": "Evaluate a Python expression as a string using various backends . With arguments `expr`, `inplace`.", "question_id": 44881}
{"snippet": "pandas.factorize(values)", "intent": "Encode the object as an enumerated type or categorical variable . This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct `values` .", "question_id": 44882}
{"snippet": "pandas.factorize(values, sort=False)", "intent": "Encode the object as an enumerated type or categorical variable . This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct `values` . With arguments `sort`.", "question_id": 44883}
{"snippet": "pandas.factorize(values, na_sentinel=- 1)", "intent": "Encode the object as an enumerated type or categorical variable . This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct `values` . Missing values are indicated in codes with `na_sentinel` ( -1 by default ) .", "question_id": 44884}
{"snippet": "pandas.factorize(values, size_hint=None)", "intent": "Encode the object as an enumerated type or categorical variable . This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct `values` . With arguments `size_hint`.", "question_id": 44885}
{"snippet": "pandas.factorize(values, sort=False, na_sentinel=- 1)", "intent": "Encode the object as an enumerated type or categorical variable . This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct `values` . Missing values are indicated in codes with `na_sentinel` ( -1 by default ) . With arguments `sort`.", "question_id": 44886}
{"snippet": "pandas.factorize(values, sort=False, size_hint=None)", "intent": "Encode the object as an enumerated type or categorical variable . This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct `values` . With arguments `sort`, `size_hint`.", "question_id": 44887}
{"snippet": "pandas.factorize(values, na_sentinel=- 1, size_hint=None)", "intent": "Encode the object as an enumerated type or categorical variable . This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct `values` . Missing values are indicated in codes with `na_sentinel` ( -1 by default ) . With arguments `size_hint`.", "question_id": 44888}
{"snippet": "pandas.factorize(values, sort=False, na_sentinel=- 1, size_hint=None)", "intent": "Encode the object as an enumerated type or categorical variable . This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct `values` . Missing values are indicated in codes with `na_sentinel` ( -1 by default ) . With arguments `sort`, `size_hint`.", "question_id": 44889}
{"snippet": "pandas.factorize(values)", "intent": "Encode the object as an enumerated type or categorical variable . This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct `values` .", "question_id": 44890}
{"snippet": "pandas.factorize(values, sort=False)", "intent": "Encode the object as an enumerated type or categorical variable . This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct `values` . With arguments `sort`.", "question_id": 44891}
{"snippet": "pandas.factorize(values, na_sentinel=- 1)", "intent": "Encode the object as an enumerated type or categorical variable . This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct `values` . Missing values are indicated in codes with `na_sentinel` ( -1 by default ) .", "question_id": 44892}
{"snippet": "pandas.factorize(values, size_hint=None)", "intent": "Encode the object as an enumerated type or categorical variable . This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct `values` . With arguments `size_hint`.", "question_id": 44893}
{"snippet": "pandas.factorize(values, sort=False, na_sentinel=- 1)", "intent": "Encode the object as an enumerated type or categorical variable . This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct `values` . Missing values are indicated in codes with `na_sentinel` ( -1 by default ) . With arguments `sort`.", "question_id": 44894}
{"snippet": "pandas.factorize(values, sort=False, size_hint=None)", "intent": "Encode the object as an enumerated type or categorical variable . This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct `values` . With arguments `sort`, `size_hint`.", "question_id": 44895}
{"snippet": "pandas.factorize(values, na_sentinel=- 1, size_hint=None)", "intent": "Encode the object as an enumerated type or categorical variable . This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct `values` . Missing values are indicated in codes with `na_sentinel` ( -1 by default ) . With arguments `size_hint`.", "question_id": 44896}
{"snippet": "pandas.factorize(values, sort=False, na_sentinel=- 1, size_hint=None)", "intent": "Encode the object as an enumerated type or categorical variable . This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct `values` . Missing values are indicated in codes with `na_sentinel` ( -1 by default ) . With arguments `sort`, `size_hint`.", "question_id": 44897}
{"snippet": "pandas.factorize(values)", "intent": "Encode the object as an enumerated type or categorical variable . This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct `values` .", "question_id": 44898}
{"snippet": "pandas.factorize(values, sort=False)", "intent": "Encode the object as an enumerated type or categorical variable . This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct `values` . With arguments `sort`.", "question_id": 44899}
{"snippet": "pandas.factorize(values, na_sentinel=- 1)", "intent": "Encode the object as an enumerated type or categorical variable . This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct `values` . Missing values are indicated in codes with `na_sentinel` ( -1 by default ) .", "question_id": 44900}
{"snippet": "pandas.factorize(values, size_hint=None)", "intent": "Encode the object as an enumerated type or categorical variable . This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct `values` . With arguments `size_hint`.", "question_id": 44901}
{"snippet": "pandas.factorize(values, sort=False, na_sentinel=- 1)", "intent": "Encode the object as an enumerated type or categorical variable . This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct `values` . Missing values are indicated in codes with `na_sentinel` ( -1 by default ) . With arguments `sort`.", "question_id": 44902}
{"snippet": "pandas.factorize(values, sort=False, size_hint=None)", "intent": "Encode the object as an enumerated type or categorical variable . This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct `values` . With arguments `sort`, `size_hint`.", "question_id": 44903}
{"snippet": "pandas.factorize(values, na_sentinel=- 1, size_hint=None)", "intent": "Encode the object as an enumerated type or categorical variable . This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct `values` . Missing values are indicated in codes with `na_sentinel` ( -1 by default ) . With arguments `size_hint`.", "question_id": 44904}
{"snippet": "pandas.factorize(values, sort=False, na_sentinel=- 1, size_hint=None)", "intent": "Encode the object as an enumerated type or categorical variable . This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct `values` . Missing values are indicated in codes with `na_sentinel` ( -1 by default ) . With arguments `sort`, `size_hint`.", "question_id": 44905}
{"snippet": "pandas.get_dummies(data)", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`.", "question_id": 44906}
{"snippet": "pandas.get_dummies(data, prefix=None)", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `prefix`.", "question_id": 44907}
{"snippet": "pandas.get_dummies(data, prefix_sep='_')", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `prefix_sep`.", "question_id": 44908}
{"snippet": "pandas.get_dummies(data, dummy_na=False)", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `dummy_na`.", "question_id": 44909}
{"snippet": "pandas.get_dummies(data, columns=None)", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `columns`.", "question_id": 44910}
{"snippet": "pandas.get_dummies(data, sparse=False)", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `sparse`.", "question_id": 44911}
{"snippet": "pandas.get_dummies(data, drop_first=False)", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `drop_first`.", "question_id": 44912}
{"snippet": "pandas.get_dummies(data, dtype=None)", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `dtype`.", "question_id": 44913}
{"snippet": "pandas.get_dummies(data, prefix=None, prefix_sep='_')", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `prefix`, `prefix_sep`.", "question_id": 44914}
{"snippet": "pandas.get_dummies(data, prefix=None, dummy_na=False)", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `prefix`, `dummy_na`.", "question_id": 44915}
{"snippet": "pandas.get_dummies(data)", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`.", "question_id": 44916}
{"snippet": "pandas.get_dummies(data, prefix=None)", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `prefix`.", "question_id": 44917}
{"snippet": "pandas.get_dummies(data, prefix_sep='_')", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `prefix_sep`.", "question_id": 44918}
{"snippet": "pandas.get_dummies(data, dummy_na=False)", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `dummy_na`.", "question_id": 44919}
{"snippet": "pandas.get_dummies(data, columns=None)", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `columns`.", "question_id": 44920}
{"snippet": "pandas.get_dummies(data, sparse=False)", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `sparse`.", "question_id": 44921}
{"snippet": "pandas.get_dummies(data, drop_first=False)", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `drop_first`.", "question_id": 44922}
{"snippet": "pandas.get_dummies(data, dtype=None)", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `dtype`.", "question_id": 44923}
{"snippet": "pandas.get_dummies(data, prefix=None, prefix_sep='_')", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `prefix`, `prefix_sep`.", "question_id": 44924}
{"snippet": "pandas.get_dummies(data, prefix=None, dummy_na=False)", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `prefix`, `dummy_na`.", "question_id": 44925}
{"snippet": "pandas.get_dummies(data)", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`.", "question_id": 44926}
{"snippet": "pandas.get_dummies(data, prefix=None)", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `prefix`.", "question_id": 44927}
{"snippet": "pandas.get_dummies(data, prefix_sep='_')", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `prefix_sep`.", "question_id": 44928}
{"snippet": "pandas.get_dummies(data, dummy_na=False)", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `dummy_na`.", "question_id": 44929}
{"snippet": "pandas.get_dummies(data, columns=None)", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `columns`.", "question_id": 44930}
{"snippet": "pandas.get_dummies(data, sparse=False)", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `sparse`.", "question_id": 44931}
{"snippet": "pandas.get_dummies(data, drop_first=False)", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `drop_first`.", "question_id": 44932}
{"snippet": "pandas.get_dummies(data, dtype=None)", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `dtype`.", "question_id": 44933}
{"snippet": "pandas.get_dummies(data, prefix=None, prefix_sep='_')", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `prefix`, `prefix_sep`.", "question_id": 44934}
{"snippet": "pandas.get_dummies(data, prefix=None, dummy_na=False)", "intent": "Convert categorical variable into dummy/indicator variables . With arguments `data`, `prefix`, `dummy_na`.", "question_id": 44935}
{"snippet": "pandas.get_option(pat)", "intent": "Retrieves the value of the specified option . With arguments `pat`.", "question_id": 44936}
{"snippet": "pandas.get_option(pat)", "intent": "Retrieves the value of the specified option . With arguments `pat`.", "question_id": 44937}
{"snippet": "pandas.get_option(pat)", "intent": "Retrieves the value of the specified option . With arguments `pat`.", "question_id": 44938}
{"snippet": "pandas.infer_freq(index)", "intent": "Infer the most likely frequency given the input `index` .", "question_id": 44939}
{"snippet": "pandas.infer_freq(index, warn=True)", "intent": "Infer the most likely frequency given the input `index` . With arguments `warn`.", "question_id": 44940}
{"snippet": "pandas.infer_freq(index)", "intent": "Infer the most likely frequency given the input `index` .", "question_id": 44941}
{"snippet": "pandas.infer_freq(index, warn=True)", "intent": "Infer the most likely frequency given the input `index` . With arguments `warn`.", "question_id": 44942}
{"snippet": "pandas.infer_freq(index)", "intent": "Infer the most likely frequency given the input `index` .", "question_id": 44943}
{"snippet": "pandas.infer_freq(index, warn=True)", "intent": "Infer the most likely frequency given the input `index` . With arguments `warn`.", "question_id": 44944}
{"snippet": "pandas.interval_range()", "intent": "Return a fixed frequency IntervalIndex .", "question_id": 44945}
{"snippet": "pandas.interval_range(start=None)", "intent": "Return a fixed frequency IntervalIndex . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 44946}
{"snippet": "pandas.interval_range(end=None)", "intent": "Return a fixed frequency IntervalIndex . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 44947}
{"snippet": "pandas.interval_range(periods=None)", "intent": "Return a fixed frequency IntervalIndex . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 44948}
{"snippet": "pandas.interval_range(freq=None)", "intent": "Return a fixed frequency IntervalIndex . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 44949}
{"snippet": "pandas.interval_range(name=None)", "intent": "Return a fixed frequency IntervalIndex . With arguments `name`.", "question_id": 44950}
{"snippet": "pandas.interval_range(closed='right')", "intent": "Return a fixed frequency IntervalIndex . The `closed` parameter specifies which endpoints of the individual intervals within the IntervalIndex are closed .", "question_id": 44951}
{"snippet": "pandas.interval_range(start=None, end=None)", "intent": "Return a fixed frequency IntervalIndex . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 44952}
{"snippet": "pandas.interval_range(start=None, periods=None)", "intent": "Return a fixed frequency IntervalIndex . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 44953}
{"snippet": "pandas.interval_range(start=None, freq=None)", "intent": "Return a fixed frequency IntervalIndex . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 44954}
{"snippet": "pandas.interval_range()", "intent": "Return a fixed frequency IntervalIndex .", "question_id": 44955}
{"snippet": "pandas.interval_range(start=None)", "intent": "Return a fixed frequency IntervalIndex . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 44956}
{"snippet": "pandas.interval_range(end=None)", "intent": "Return a fixed frequency IntervalIndex . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 44957}
{"snippet": "pandas.interval_range(periods=None)", "intent": "Return a fixed frequency IntervalIndex . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 44958}
{"snippet": "pandas.interval_range(freq=None)", "intent": "Return a fixed frequency IntervalIndex . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 44959}
{"snippet": "pandas.interval_range(name=None)", "intent": "Return a fixed frequency IntervalIndex . With arguments `name`.", "question_id": 44960}
{"snippet": "pandas.interval_range(closed='right')", "intent": "Return a fixed frequency IntervalIndex . The `closed` parameter specifies which endpoints of the individual intervals within the IntervalIndex are closed .", "question_id": 44961}
{"snippet": "pandas.interval_range(start=None, end=None)", "intent": "Return a fixed frequency IntervalIndex . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 44962}
{"snippet": "pandas.interval_range(start=None, periods=None)", "intent": "Return a fixed frequency IntervalIndex . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 44963}
{"snippet": "pandas.interval_range(start=None, freq=None)", "intent": "Return a fixed frequency IntervalIndex . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 44964}
{"snippet": "pandas.interval_range()", "intent": "Return a fixed frequency IntervalIndex .", "question_id": 44965}
{"snippet": "pandas.interval_range(start=None)", "intent": "Return a fixed frequency IntervalIndex . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 44966}
{"snippet": "pandas.interval_range(end=None)", "intent": "Return a fixed frequency IntervalIndex . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 44967}
{"snippet": "pandas.interval_range(periods=None)", "intent": "Return a fixed frequency IntervalIndex . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 44968}
{"snippet": "pandas.interval_range(freq=None)", "intent": "Return a fixed frequency IntervalIndex . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 44969}
{"snippet": "pandas.interval_range(name=None)", "intent": "Return a fixed frequency IntervalIndex . With arguments `name`.", "question_id": 44970}
{"snippet": "pandas.interval_range(closed='right')", "intent": "Return a fixed frequency IntervalIndex . The `closed` parameter specifies which endpoints of the individual intervals within the IntervalIndex are closed .", "question_id": 44971}
{"snippet": "pandas.interval_range(start=None, end=None)", "intent": "Return a fixed frequency IntervalIndex . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 44972}
{"snippet": "pandas.interval_range(start=None, periods=None)", "intent": "Return a fixed frequency IntervalIndex . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 44973}
{"snippet": "pandas.interval_range(start=None, freq=None)", "intent": "Return a fixed frequency IntervalIndex . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 44974}
{"snippet": "Styler.apply(func, **kwargs)", "intent": "Apply a CSS-styling function column-wise , row-wise , or table-wise . The elements of the output of `func` should be CSS styles as strings , in the format \u2018 attribute : value ; attribute2 : value2 ; \u2026 \u2019 or , if nothing is to be applied to that element , an empty string or None . With arguments `**kwargs`.", "question_id": 44975}
{"snippet": "Styler.apply(func, **kwargs, axis=0)", "intent": "Apply a CSS-styling function column-wise , row-wise , or table-wise . The elements of the output of `func` should be CSS styles as strings , in the format \u2018 attribute : value ; attribute2 : value2 ; \u2026 \u2019 or , if nothing is to be applied to that element , an empty string or None . With arguments `**kwargs`, `axis`.", "question_id": 44976}
{"snippet": "Styler.apply(func, **kwargs, subset=None)", "intent": "Apply a CSS-styling function column-wise , row-wise , or table-wise . The elements of the output of `func` should be CSS styles as strings , in the format \u2018 attribute : value ; attribute2 : value2 ; \u2026 \u2019 or , if nothing is to be applied to that element , an empty string or None . Using `subset` to restrict application to a single column or multiple columns With arguments `**kwargs`.", "question_id": 44977}
{"snippet": "Styler.apply(func, **kwargs, axis=0, subset=None)", "intent": "Apply a CSS-styling function column-wise , row-wise , or table-wise . The elements of the output of `func` should be CSS styles as strings , in the format \u2018 attribute : value ; attribute2 : value2 ; \u2026 \u2019 or , if nothing is to be applied to that element , an empty string or None . Using `subset` to restrict application to a single column or multiple columns With arguments `**kwargs`, `axis`.", "question_id": 44978}
{"snippet": "Styler.apply(func, **kwargs)", "intent": "Apply a CSS-styling function column-wise , row-wise , or table-wise . The elements of the output of `func` should be CSS styles as strings , in the format \u2018 attribute : value ; attribute2 : value2 ; \u2026 \u2019 or , if nothing is to be applied to that element , an empty string or None . With arguments `**kwargs`.", "question_id": 44979}
{"snippet": "Styler.apply(func, **kwargs, axis=0)", "intent": "Apply a CSS-styling function column-wise , row-wise , or table-wise . The elements of the output of `func` should be CSS styles as strings , in the format \u2018 attribute : value ; attribute2 : value2 ; \u2026 \u2019 or , if nothing is to be applied to that element , an empty string or None . With arguments `**kwargs`, `axis`.", "question_id": 44980}
{"snippet": "Styler.apply(func, **kwargs, subset=None)", "intent": "Apply a CSS-styling function column-wise , row-wise , or table-wise . The elements of the output of `func` should be CSS styles as strings , in the format \u2018 attribute : value ; attribute2 : value2 ; \u2026 \u2019 or , if nothing is to be applied to that element , an empty string or None . Using `subset` to restrict application to a single column or multiple columns With arguments `**kwargs`.", "question_id": 44981}
{"snippet": "Styler.apply(func, **kwargs, axis=0, subset=None)", "intent": "Apply a CSS-styling function column-wise , row-wise , or table-wise . The elements of the output of `func` should be CSS styles as strings , in the format \u2018 attribute : value ; attribute2 : value2 ; \u2026 \u2019 or , if nothing is to be applied to that element , an empty string or None . Using `subset` to restrict application to a single column or multiple columns With arguments `**kwargs`, `axis`.", "question_id": 44982}
{"snippet": "Styler.apply(func, **kwargs)", "intent": "Apply a CSS-styling function column-wise , row-wise , or table-wise . The elements of the output of `func` should be CSS styles as strings , in the format \u2018 attribute : value ; attribute2 : value2 ; \u2026 \u2019 or , if nothing is to be applied to that element , an empty string or None . With arguments `**kwargs`.", "question_id": 44983}
{"snippet": "Styler.apply(func, **kwargs, axis=0)", "intent": "Apply a CSS-styling function column-wise , row-wise , or table-wise . The elements of the output of `func` should be CSS styles as strings , in the format \u2018 attribute : value ; attribute2 : value2 ; \u2026 \u2019 or , if nothing is to be applied to that element , an empty string or None . With arguments `**kwargs`, `axis`.", "question_id": 44984}
{"snippet": "Styler.apply(func, **kwargs, subset=None)", "intent": "Apply a CSS-styling function column-wise , row-wise , or table-wise . The elements of the output of `func` should be CSS styles as strings , in the format \u2018 attribute : value ; attribute2 : value2 ; \u2026 \u2019 or , if nothing is to be applied to that element , an empty string or None . Using `subset` to restrict application to a single column or multiple columns With arguments `**kwargs`.", "question_id": 44985}
{"snippet": "Styler.apply(func, **kwargs, axis=0, subset=None)", "intent": "Apply a CSS-styling function column-wise , row-wise , or table-wise . The elements of the output of `func` should be CSS styles as strings , in the format \u2018 attribute : value ; attribute2 : value2 ; \u2026 \u2019 or , if nothing is to be applied to that element , an empty string or None . Using `subset` to restrict application to a single column or multiple columns With arguments `**kwargs`, `axis`.", "question_id": 44986}
{"snippet": "Styler.applymap(func, **kwargs)", "intent": "Apply a CSS-styling function elementwise . The elements of the output of `func` should be CSS styles as strings , in the format \u2018 attribute : value ; attribute2 : value2 ; \u2026 \u2019 or , if nothing is to be applied to that element , an empty string or None . With arguments `**kwargs`.", "question_id": 44987}
{"snippet": "Styler.applymap(func, **kwargs, subset=None)", "intent": "Apply a CSS-styling function elementwise . The elements of the output of `func` should be CSS styles as strings , in the format \u2018 attribute : value ; attribute2 : value2 ; \u2026 \u2019 or , if nothing is to be applied to that element , an empty string or None . Using `subset` to restrict application to a single column or multiple columns With arguments `**kwargs`.", "question_id": 44988}
{"snippet": "Styler.applymap(func, **kwargs)", "intent": "Apply a CSS-styling function elementwise . The elements of the output of `func` should be CSS styles as strings , in the format \u2018 attribute : value ; attribute2 : value2 ; \u2026 \u2019 or , if nothing is to be applied to that element , an empty string or None . With arguments `**kwargs`.", "question_id": 44989}
{"snippet": "Styler.applymap(func, **kwargs, subset=None)", "intent": "Apply a CSS-styling function elementwise . The elements of the output of `func` should be CSS styles as strings , in the format \u2018 attribute : value ; attribute2 : value2 ; \u2026 \u2019 or , if nothing is to be applied to that element , an empty string or None . Using `subset` to restrict application to a single column or multiple columns With arguments `**kwargs`.", "question_id": 44990}
{"snippet": "Styler.applymap(func, **kwargs)", "intent": "Apply a CSS-styling function elementwise . The elements of the output of `func` should be CSS styles as strings , in the format \u2018 attribute : value ; attribute2 : value2 ; \u2026 \u2019 or , if nothing is to be applied to that element , an empty string or None . With arguments `**kwargs`.", "question_id": 44991}
{"snippet": "Styler.applymap(func, **kwargs, subset=None)", "intent": "Apply a CSS-styling function elementwise . The elements of the output of `func` should be CSS styles as strings , in the format \u2018 attribute : value ; attribute2 : value2 ; \u2026 \u2019 or , if nothing is to be applied to that element , an empty string or None . Using `subset` to restrict application to a single column or multiple columns With arguments `**kwargs`.", "question_id": 44992}
{"snippet": "Styler.background_gradient()", "intent": "Color the background in a gradient style .", "question_id": 44993}
{"snippet": "Styler.background_gradient(cmap='PuBu')", "intent": "Color the background in a gradient style . Setting a gmap and applying to all columns with another `cmap`", "question_id": 44994}
{"snippet": "Styler.background_gradient(low=0)", "intent": "Color the background in a gradient style . When using `low` and `high` the range of the gradient , given by the data if `gmap` is not given or by gmap , is extended at the low end effectively by map.min - low * map.range and at the high end by map.max + high * map.range before the colors are normalized and determined .", "question_id": 44995}
{"snippet": "Styler.background_gradient(high=0)", "intent": "Color the background in a gradient style . When using `low` and `high` the range of the gradient , given by the data if `gmap` is not given or by gmap , is extended at the low end effectively by map.min - low * map.range and at the high end by map.max + high * map.range before the colors are normalized and determined .", "question_id": 44996}
{"snippet": "Styler.background_gradient(axis=0)", "intent": "Color the background in a gradient style . With arguments `axis`.", "question_id": 44997}
{"snippet": "Styler.background_gradient(subset=None)", "intent": "Color the background in a gradient style . axis=None ) , we need to explicitly state `subset` to match the gmap shape", "question_id": 44998}
{"snippet": "Styler.background_gradient(text_color_threshold=0.408)", "intent": "Color the background in a gradient style . With arguments `text_color_threshold`.", "question_id": 44999}
{"snippet": "Styler.background_gradient(vmin=None)", "intent": "Color the background in a gradient style . If combining with `vmin` and `vmax` the map.min , map.max and map.range are replaced by values according to the values derived from vmin and vmax .", "question_id": 45000}
{"snippet": "Styler.background_gradient(vmax=None)", "intent": "Color the background in a gradient style . If combining with `vmin` and `vmax` the map.min , map.max and map.range are replaced by values according to the values derived from vmin and vmax .", "question_id": 45001}
{"snippet": "Styler.background_gradient(gmap=None)", "intent": "Color the background in a gradient style . When using `low` and `high` the range of the gradient , given by the data if `gmap` is not given or by gmap , is extended at the low end effectively by map.min - low * map.range and at the high end by map.max + high * map.range before the colors are normalized and determined .", "question_id": 45002}
{"snippet": "Styler.background_gradient()", "intent": "Color the background in a gradient style .", "question_id": 45003}
{"snippet": "Styler.background_gradient(cmap='PuBu')", "intent": "Color the background in a gradient style . Setting a gmap and applying to all columns with another `cmap`", "question_id": 45004}
{"snippet": "Styler.background_gradient(low=0)", "intent": "Color the background in a gradient style . When using `low` and `high` the range of the gradient , given by the data if `gmap` is not given or by gmap , is extended at the low end effectively by map.min - low * map.range and at the high end by map.max + high * map.range before the colors are normalized and determined .", "question_id": 45005}
{"snippet": "Styler.background_gradient(high=0)", "intent": "Color the background in a gradient style . When using `low` and `high` the range of the gradient , given by the data if `gmap` is not given or by gmap , is extended at the low end effectively by map.min - low * map.range and at the high end by map.max + high * map.range before the colors are normalized and determined .", "question_id": 45006}
{"snippet": "Styler.background_gradient(axis=0)", "intent": "Color the background in a gradient style . With arguments `axis`.", "question_id": 45007}
{"snippet": "Styler.background_gradient(subset=None)", "intent": "Color the background in a gradient style . axis=None ) , we need to explicitly state `subset` to match the gmap shape", "question_id": 45008}
{"snippet": "Styler.background_gradient(text_color_threshold=0.408)", "intent": "Color the background in a gradient style . With arguments `text_color_threshold`.", "question_id": 45009}
{"snippet": "Styler.background_gradient(vmin=None)", "intent": "Color the background in a gradient style . If combining with `vmin` and `vmax` the map.min , map.max and map.range are replaced by values according to the values derived from vmin and vmax .", "question_id": 45010}
{"snippet": "Styler.background_gradient(vmax=None)", "intent": "Color the background in a gradient style . If combining with `vmin` and `vmax` the map.min , map.max and map.range are replaced by values according to the values derived from vmin and vmax .", "question_id": 45011}
{"snippet": "Styler.background_gradient(gmap=None)", "intent": "Color the background in a gradient style . When using `low` and `high` the range of the gradient , given by the data if `gmap` is not given or by gmap , is extended at the low end effectively by map.min - low * map.range and at the high end by map.max + high * map.range before the colors are normalized and determined .", "question_id": 45012}
{"snippet": "Styler.background_gradient()", "intent": "Color the background in a gradient style .", "question_id": 45013}
{"snippet": "Styler.background_gradient(cmap='PuBu')", "intent": "Color the background in a gradient style . Setting a gmap and applying to all columns with another `cmap`", "question_id": 45014}
{"snippet": "Styler.background_gradient(low=0)", "intent": "Color the background in a gradient style . When using `low` and `high` the range of the gradient , given by the data if `gmap` is not given or by gmap , is extended at the low end effectively by map.min - low * map.range and at the high end by map.max + high * map.range before the colors are normalized and determined .", "question_id": 45015}
{"snippet": "Styler.background_gradient(high=0)", "intent": "Color the background in a gradient style . When using `low` and `high` the range of the gradient , given by the data if `gmap` is not given or by gmap , is extended at the low end effectively by map.min - low * map.range and at the high end by map.max + high * map.range before the colors are normalized and determined .", "question_id": 45016}
{"snippet": "Styler.background_gradient(axis=0)", "intent": "Color the background in a gradient style . With arguments `axis`.", "question_id": 45017}
{"snippet": "Styler.background_gradient(subset=None)", "intent": "Color the background in a gradient style . axis=None ) , we need to explicitly state `subset` to match the gmap shape", "question_id": 45018}
{"snippet": "Styler.background_gradient(text_color_threshold=0.408)", "intent": "Color the background in a gradient style . With arguments `text_color_threshold`.", "question_id": 45019}
{"snippet": "Styler.background_gradient(vmin=None)", "intent": "Color the background in a gradient style . If combining with `vmin` and `vmax` the map.min , map.max and map.range are replaced by values according to the values derived from vmin and vmax .", "question_id": 45020}
{"snippet": "Styler.background_gradient(vmax=None)", "intent": "Color the background in a gradient style . If combining with `vmin` and `vmax` the map.min , map.max and map.range are replaced by values according to the values derived from vmin and vmax .", "question_id": 45021}
{"snippet": "Styler.background_gradient(gmap=None)", "intent": "Color the background in a gradient style . When using `low` and `high` the range of the gradient , given by the data if `gmap` is not given or by gmap , is extended at the low end effectively by map.min - low * map.range and at the high end by map.max + high * map.range before the colors are normalized and determined .", "question_id": 45022}
{"snippet": "Styler.bar()", "intent": "Draw bar chart in the cell backgrounds .", "question_id": 45023}
{"snippet": "Styler.bar(subset=None)", "intent": "Draw bar chart in the cell backgrounds . With arguments `subset`.", "question_id": 45024}
{"snippet": "Styler.bar(axis=0)", "intent": "Draw bar chart in the cell backgrounds . With arguments `axis`.", "question_id": 45025}
{"snippet": "Styler.bar(color='#d65f5f')", "intent": "Draw bar chart in the cell backgrounds . With arguments `color`.", "question_id": 45026}
{"snippet": "Styler.bar(width=100)", "intent": "Draw bar chart in the cell backgrounds . With arguments `width`.", "question_id": 45027}
{"snippet": "Styler.bar(align='left')", "intent": "Draw bar chart in the cell backgrounds . With arguments `align`.", "question_id": 45028}
{"snippet": "Styler.bar(vmin=None)", "intent": "Draw bar chart in the cell backgrounds . With arguments `vmin`.", "question_id": 45029}
{"snippet": "Styler.bar(vmax=None)", "intent": "Draw bar chart in the cell backgrounds . With arguments `vmax`.", "question_id": 45030}
{"snippet": "Styler.bar(subset=None, axis=0)", "intent": "Draw bar chart in the cell backgrounds . With arguments `subset`, `axis`.", "question_id": 45031}
{"snippet": "Styler.bar(subset=None, color='#d65f5f')", "intent": "Draw bar chart in the cell backgrounds . With arguments `subset`, `color`.", "question_id": 45032}
{"snippet": "Styler.bar()", "intent": "Draw bar chart in the cell backgrounds .", "question_id": 45033}
{"snippet": "Styler.bar(subset=None)", "intent": "Draw bar chart in the cell backgrounds . With arguments `subset`.", "question_id": 45034}
{"snippet": "Styler.bar(axis=0)", "intent": "Draw bar chart in the cell backgrounds . With arguments `axis`.", "question_id": 45035}
{"snippet": "Styler.bar(color='#d65f5f')", "intent": "Draw bar chart in the cell backgrounds . With arguments `color`.", "question_id": 45036}
{"snippet": "Styler.bar(width=100)", "intent": "Draw bar chart in the cell backgrounds . With arguments `width`.", "question_id": 45037}
{"snippet": "Styler.bar(align='left')", "intent": "Draw bar chart in the cell backgrounds . With arguments `align`.", "question_id": 45038}
{"snippet": "Styler.bar(vmin=None)", "intent": "Draw bar chart in the cell backgrounds . With arguments `vmin`.", "question_id": 45039}
{"snippet": "Styler.bar(vmax=None)", "intent": "Draw bar chart in the cell backgrounds . With arguments `vmax`.", "question_id": 45040}
{"snippet": "Styler.bar(subset=None, axis=0)", "intent": "Draw bar chart in the cell backgrounds . With arguments `subset`, `axis`.", "question_id": 45041}
{"snippet": "Styler.bar(subset=None, color='#d65f5f')", "intent": "Draw bar chart in the cell backgrounds . With arguments `subset`, `color`.", "question_id": 45042}
{"snippet": "Styler.bar()", "intent": "Draw bar chart in the cell backgrounds .", "question_id": 45043}
{"snippet": "Styler.bar(subset=None)", "intent": "Draw bar chart in the cell backgrounds . With arguments `subset`.", "question_id": 45044}
{"snippet": "Styler.bar(axis=0)", "intent": "Draw bar chart in the cell backgrounds . With arguments `axis`.", "question_id": 45045}
{"snippet": "Styler.bar(color='#d65f5f')", "intent": "Draw bar chart in the cell backgrounds . With arguments `color`.", "question_id": 45046}
{"snippet": "Styler.bar(width=100)", "intent": "Draw bar chart in the cell backgrounds . With arguments `width`.", "question_id": 45047}
{"snippet": "Styler.bar(align='left')", "intent": "Draw bar chart in the cell backgrounds . With arguments `align`.", "question_id": 45048}
{"snippet": "Styler.bar(vmin=None)", "intent": "Draw bar chart in the cell backgrounds . With arguments `vmin`.", "question_id": 45049}
{"snippet": "Styler.bar(vmax=None)", "intent": "Draw bar chart in the cell backgrounds . With arguments `vmax`.", "question_id": 45050}
{"snippet": "Styler.bar(subset=None, axis=0)", "intent": "Draw bar chart in the cell backgrounds . With arguments `subset`, `axis`.", "question_id": 45051}
{"snippet": "Styler.bar(subset=None, color='#d65f5f')", "intent": "Draw bar chart in the cell backgrounds . With arguments `subset`, `color`.", "question_id": 45052}
{"snippet": "Styler.clear()", "intent": "Reset the Styler , removing any previously applied styles .", "question_id": 45053}
{"snippet": "Styler.clear()", "intent": "Reset the Styler , removing any previously applied styles .", "question_id": 45054}
{"snippet": "Styler.clear()", "intent": "Reset the Styler , removing any previously applied styles .", "question_id": 45055}
{"snippet": "Styler.export()", "intent": "Export the styles applied to the current Styler .", "question_id": 45056}
{"snippet": "Styler.export()", "intent": "Export the styles applied to the current Styler .", "question_id": 45057}
{"snippet": "Styler.export()", "intent": "Export the styles applied to the current Styler .", "question_id": 45058}
{"snippet": "Styler.format()", "intent": "Format the text display value of cells .", "question_id": 45059}
{"snippet": "Styler.format(formatter=None)", "intent": "Format the text display value of cells . This method assigns a formatting function , `formatter` , to each cell in the DataFrame .", "question_id": 45060}
{"snippet": "Styler.format(subset=None)", "intent": "Format the text display value of cells . The `subset` argument defines which region to apply the formatting function to .", "question_id": 45061}
{"snippet": "Styler.format(na_rep=None)", "intent": "Format the text display value of cells . The default formatter does not adjust the representation of missing values unless the `na_rep` argument is used .", "question_id": 45062}
{"snippet": "Styler.format(precision=None)", "intent": "Format the text display value of cells . The default formatter currently expresses floats and complex numbers with the pandas display `precision` unless using the precision argument here .", "question_id": 45063}
{"snippet": "Styler.format(decimal='.')", "intent": "Format the text display value of cells . With arguments `decimal`.", "question_id": 45064}
{"snippet": "Styler.format(thousands=None)", "intent": "Format the text display value of cells . With arguments `thousands`.", "question_id": 45065}
{"snippet": "Styler.format(escape=None)", "intent": "Format the text display value of cells . Using a formatter with HTML `escape` and na_rep .", "question_id": 45066}
{"snippet": "Styler.format(formatter=None, subset=None)", "intent": "Format the text display value of cells . This method assigns a formatting function , `formatter` , to each cell in the DataFrame . The `subset` argument defines which region to apply the formatting function to .", "question_id": 45067}
{"snippet": "Styler.format(formatter=None, na_rep=None)", "intent": "Format the text display value of cells . This method assigns a formatting function , `formatter` , to each cell in the DataFrame . The default formatter does not adjust the representation of missing values unless the `na_rep` argument is used .", "question_id": 45068}
{"snippet": "Styler.format()", "intent": "Format the text display value of cells .", "question_id": 45069}
{"snippet": "Styler.format(formatter=None)", "intent": "Format the text display value of cells . This method assigns a formatting function , `formatter` , to each cell in the DataFrame .", "question_id": 45070}
{"snippet": "Styler.format(subset=None)", "intent": "Format the text display value of cells . The `subset` argument defines which region to apply the formatting function to .", "question_id": 45071}
{"snippet": "Styler.format(na_rep=None)", "intent": "Format the text display value of cells . The default formatter does not adjust the representation of missing values unless the `na_rep` argument is used .", "question_id": 45072}
{"snippet": "Styler.format(precision=None)", "intent": "Format the text display value of cells . The default formatter currently expresses floats and complex numbers with the pandas display `precision` unless using the precision argument here .", "question_id": 45073}
{"snippet": "Styler.format(decimal='.')", "intent": "Format the text display value of cells . With arguments `decimal`.", "question_id": 45074}
{"snippet": "Styler.format(thousands=None)", "intent": "Format the text display value of cells . With arguments `thousands`.", "question_id": 45075}
{"snippet": "Styler.format(escape=None)", "intent": "Format the text display value of cells . Using a formatter with HTML `escape` and na_rep .", "question_id": 45076}
{"snippet": "Styler.format(formatter=None, subset=None)", "intent": "Format the text display value of cells . This method assigns a formatting function , `formatter` , to each cell in the DataFrame . The `subset` argument defines which region to apply the formatting function to .", "question_id": 45077}
{"snippet": "Styler.format(formatter=None, na_rep=None)", "intent": "Format the text display value of cells . This method assigns a formatting function , `formatter` , to each cell in the DataFrame . The default formatter does not adjust the representation of missing values unless the `na_rep` argument is used .", "question_id": 45078}
{"snippet": "Styler.format()", "intent": "Format the text display value of cells .", "question_id": 45079}
{"snippet": "Styler.format(formatter=None)", "intent": "Format the text display value of cells . This method assigns a formatting function , `formatter` , to each cell in the DataFrame .", "question_id": 45080}
{"snippet": "Styler.format(subset=None)", "intent": "Format the text display value of cells . The `subset` argument defines which region to apply the formatting function to .", "question_id": 45081}
{"snippet": "Styler.format(na_rep=None)", "intent": "Format the text display value of cells . The default formatter does not adjust the representation of missing values unless the `na_rep` argument is used .", "question_id": 45082}
{"snippet": "Styler.format(precision=None)", "intent": "Format the text display value of cells . The default formatter currently expresses floats and complex numbers with the pandas display `precision` unless using the precision argument here .", "question_id": 45083}
{"snippet": "Styler.format(decimal='.')", "intent": "Format the text display value of cells . With arguments `decimal`.", "question_id": 45084}
{"snippet": "Styler.format(thousands=None)", "intent": "Format the text display value of cells . With arguments `thousands`.", "question_id": 45085}
{"snippet": "Styler.format(escape=None)", "intent": "Format the text display value of cells . Using a formatter with HTML `escape` and na_rep .", "question_id": 45086}
{"snippet": "Styler.format(formatter=None, subset=None)", "intent": "Format the text display value of cells . This method assigns a formatting function , `formatter` , to each cell in the DataFrame . The `subset` argument defines which region to apply the formatting function to .", "question_id": 45087}
{"snippet": "Styler.format(formatter=None, na_rep=None)", "intent": "Format the text display value of cells . This method assigns a formatting function , `formatter` , to each cell in the DataFrame . The default formatter does not adjust the representation of missing values unless the `na_rep` argument is used .", "question_id": 45088}
{"snippet": "Styler.from_custom_template(searchpath)", "intent": "Factory function for creating a subclass of Styler . With arguments `searchpath`.", "question_id": 45089}
{"snippet": "Styler.from_custom_template(searchpath, html_table=None)", "intent": "Factory function for creating a subclass of Styler . With arguments `searchpath`, `html_table`.", "question_id": 45090}
{"snippet": "Styler.from_custom_template(searchpath, html_style=None)", "intent": "Factory function for creating a subclass of Styler . With arguments `searchpath`, `html_style`.", "question_id": 45091}
{"snippet": "Styler.from_custom_template(searchpath, html_table=None, html_style=None)", "intent": "Factory function for creating a subclass of Styler . With arguments `searchpath`, `html_table`, `html_style`.", "question_id": 45092}
{"snippet": "Styler.from_custom_template(searchpath)", "intent": "Factory function for creating a subclass of Styler . With arguments `searchpath`.", "question_id": 45093}
{"snippet": "Styler.from_custom_template(searchpath, html_table=None)", "intent": "Factory function for creating a subclass of Styler . With arguments `searchpath`, `html_table`.", "question_id": 45094}
{"snippet": "Styler.from_custom_template(searchpath, html_style=None)", "intent": "Factory function for creating a subclass of Styler . With arguments `searchpath`, `html_style`.", "question_id": 45095}
{"snippet": "Styler.from_custom_template(searchpath, html_table=None, html_style=None)", "intent": "Factory function for creating a subclass of Styler . With arguments `searchpath`, `html_table`, `html_style`.", "question_id": 45096}
{"snippet": "Styler.from_custom_template(searchpath)", "intent": "Factory function for creating a subclass of Styler . With arguments `searchpath`.", "question_id": 45097}
{"snippet": "Styler.from_custom_template(searchpath, html_table=None)", "intent": "Factory function for creating a subclass of Styler . With arguments `searchpath`, `html_table`.", "question_id": 45098}
{"snippet": "Styler.from_custom_template(searchpath, html_style=None)", "intent": "Factory function for creating a subclass of Styler . With arguments `searchpath`, `html_style`.", "question_id": 45099}
{"snippet": "Styler.from_custom_template(searchpath, html_table=None, html_style=None)", "intent": "Factory function for creating a subclass of Styler . With arguments `searchpath`, `html_table`, `html_style`.", "question_id": 45100}
{"snippet": "Styler.hide_columns()", "intent": "Hide the column headers or specific keys in the columns from rendering .", "question_id": 45101}
{"snippet": "Styler.hide_columns(subset=None)", "intent": "Hide the column headers or specific keys in the columns from rendering . With arguments `subset`.", "question_id": 45102}
{"snippet": "Styler.hide_columns()", "intent": "Hide the column headers or specific keys in the columns from rendering .", "question_id": 45103}
{"snippet": "Styler.hide_columns(subset=None)", "intent": "Hide the column headers or specific keys in the columns from rendering . With arguments `subset`.", "question_id": 45104}
{"snippet": "Styler.hide_columns()", "intent": "Hide the column headers or specific keys in the columns from rendering .", "question_id": 45105}
{"snippet": "Styler.hide_columns(subset=None)", "intent": "Hide the column headers or specific keys in the columns from rendering . With arguments `subset`.", "question_id": 45106}
{"snippet": "Styler.hide_index()", "intent": "Hide the entire index , or specific keys in the index from rendering .", "question_id": 45107}
{"snippet": "Styler.hide_index(subset=None)", "intent": "Hide the entire index , or specific keys in the index from rendering . With arguments `subset`.", "question_id": 45108}
{"snippet": "Styler.hide_index()", "intent": "Hide the entire index , or specific keys in the index from rendering .", "question_id": 45109}
{"snippet": "Styler.hide_index(subset=None)", "intent": "Hide the entire index , or specific keys in the index from rendering . With arguments `subset`.", "question_id": 45110}
{"snippet": "Styler.hide_index()", "intent": "Hide the entire index , or specific keys in the index from rendering .", "question_id": 45111}
{"snippet": "Styler.hide_index(subset=None)", "intent": "Hide the entire index , or specific keys in the index from rendering . With arguments `subset`.", "question_id": 45112}
{"snippet": "Styler.highlight_between()", "intent": "Highlight a defined range with a style .", "question_id": 45113}
{"snippet": "Styler.highlight_between(subset=None)", "intent": "Highlight a defined range with a style . Use `subset` to control regions which have multiple dtypes .", "question_id": 45114}
{"snippet": "Styler.highlight_between(color='yellow')", "intent": "Highlight a defined range with a style . With arguments `color`.", "question_id": 45115}
{"snippet": "Styler.highlight_between(axis=0)", "intent": "Highlight a defined range with a style . `axis` is only needed if left or right are provided as a sequence or an array-like object for aligning the shapes .", "question_id": 45116}
{"snippet": "Styler.highlight_between(left=None)", "intent": "Highlight a defined range with a style . If `left` is None only the `right` bound is applied .", "question_id": 45117}
{"snippet": "Styler.highlight_between(right=None)", "intent": "Highlight a defined range with a style . If `left` is None only the `right` bound is applied .", "question_id": 45118}
{"snippet": "Styler.highlight_between(inclusive='both')", "intent": "Highlight a defined range with a style . With arguments `inclusive`.", "question_id": 45119}
{"snippet": "Styler.highlight_between(props=None)", "intent": "Highlight a defined range with a style . Using `props` instead of default background coloring", "question_id": 45120}
{"snippet": "Styler.highlight_between(subset=None, color='yellow')", "intent": "Highlight a defined range with a style . Use `subset` to control regions which have multiple dtypes . With arguments `color`.", "question_id": 45121}
{"snippet": "Styler.highlight_between(subset=None, axis=0)", "intent": "Highlight a defined range with a style . Use `subset` to control regions which have multiple dtypes . `axis` is only needed if left or right are provided as a sequence or an array-like object for aligning the shapes .", "question_id": 45122}
{"snippet": "Styler.highlight_between()", "intent": "Highlight a defined range with a style .", "question_id": 45123}
{"snippet": "Styler.highlight_between(subset=None)", "intent": "Highlight a defined range with a style . Use `subset` to control regions which have multiple dtypes .", "question_id": 45124}
{"snippet": "Styler.highlight_between(color='yellow')", "intent": "Highlight a defined range with a style . With arguments `color`.", "question_id": 45125}
{"snippet": "Styler.highlight_between(axis=0)", "intent": "Highlight a defined range with a style . `axis` is only needed if left or right are provided as a sequence or an array-like object for aligning the shapes .", "question_id": 45126}
{"snippet": "Styler.highlight_between(left=None)", "intent": "Highlight a defined range with a style . If `left` is None only the `right` bound is applied .", "question_id": 45127}
{"snippet": "Styler.highlight_between(right=None)", "intent": "Highlight a defined range with a style . If `left` is None only the `right` bound is applied .", "question_id": 45128}
{"snippet": "Styler.highlight_between(inclusive='both')", "intent": "Highlight a defined range with a style . With arguments `inclusive`.", "question_id": 45129}
{"snippet": "Styler.highlight_between(props=None)", "intent": "Highlight a defined range with a style . Using `props` instead of default background coloring", "question_id": 45130}
{"snippet": "Styler.highlight_between(subset=None, color='yellow')", "intent": "Highlight a defined range with a style . Use `subset` to control regions which have multiple dtypes . With arguments `color`.", "question_id": 45131}
{"snippet": "Styler.highlight_between(subset=None, axis=0)", "intent": "Highlight a defined range with a style . Use `subset` to control regions which have multiple dtypes . `axis` is only needed if left or right are provided as a sequence or an array-like object for aligning the shapes .", "question_id": 45132}
{"snippet": "Styler.highlight_between()", "intent": "Highlight a defined range with a style .", "question_id": 45133}
{"snippet": "Styler.highlight_between(subset=None)", "intent": "Highlight a defined range with a style . Use `subset` to control regions which have multiple dtypes .", "question_id": 45134}
{"snippet": "Styler.highlight_between(color='yellow')", "intent": "Highlight a defined range with a style . With arguments `color`.", "question_id": 45135}
{"snippet": "Styler.highlight_between(axis=0)", "intent": "Highlight a defined range with a style . `axis` is only needed if left or right are provided as a sequence or an array-like object for aligning the shapes .", "question_id": 45136}
{"snippet": "Styler.highlight_between(left=None)", "intent": "Highlight a defined range with a style . If `left` is None only the `right` bound is applied .", "question_id": 45137}
{"snippet": "Styler.highlight_between(right=None)", "intent": "Highlight a defined range with a style . If `left` is None only the `right` bound is applied .", "question_id": 45138}
{"snippet": "Styler.highlight_between(inclusive='both')", "intent": "Highlight a defined range with a style . With arguments `inclusive`.", "question_id": 45139}
{"snippet": "Styler.highlight_between(props=None)", "intent": "Highlight a defined range with a style . Using `props` instead of default background coloring", "question_id": 45140}
{"snippet": "Styler.highlight_between(subset=None, color='yellow')", "intent": "Highlight a defined range with a style . Use `subset` to control regions which have multiple dtypes . With arguments `color`.", "question_id": 45141}
{"snippet": "Styler.highlight_between(subset=None, axis=0)", "intent": "Highlight a defined range with a style . Use `subset` to control regions which have multiple dtypes . `axis` is only needed if left or right are provided as a sequence or an array-like object for aligning the shapes .", "question_id": 45142}
{"snippet": "Styler.highlight_max()", "intent": "Highlight the maximum with a style .", "question_id": 45143}
{"snippet": "Styler.highlight_max(subset=None)", "intent": "Highlight the maximum with a style . With arguments `subset`.", "question_id": 45144}
{"snippet": "Styler.highlight_max(color='yellow')", "intent": "Highlight the maximum with a style . With arguments `color`.", "question_id": 45145}
{"snippet": "Styler.highlight_max(axis=0)", "intent": "Highlight the maximum with a style . With arguments `axis`.", "question_id": 45146}
{"snippet": "Styler.highlight_max(props=None)", "intent": "Highlight the maximum with a style . With arguments `props`.", "question_id": 45147}
{"snippet": "Styler.highlight_max(subset=None, color='yellow')", "intent": "Highlight the maximum with a style . With arguments `subset`, `color`.", "question_id": 45148}
{"snippet": "Styler.highlight_max(subset=None, axis=0)", "intent": "Highlight the maximum with a style . With arguments `subset`, `axis`.", "question_id": 45149}
{"snippet": "Styler.highlight_max(subset=None, props=None)", "intent": "Highlight the maximum with a style . With arguments `subset`, `props`.", "question_id": 45150}
{"snippet": "Styler.highlight_max(color='yellow', axis=0)", "intent": "Highlight the maximum with a style . With arguments `color`, `axis`.", "question_id": 45151}
{"snippet": "Styler.highlight_max(color='yellow', props=None)", "intent": "Highlight the maximum with a style . With arguments `color`, `props`.", "question_id": 45152}
{"snippet": "Styler.highlight_max()", "intent": "Highlight the maximum with a style .", "question_id": 45153}
{"snippet": "Styler.highlight_max(subset=None)", "intent": "Highlight the maximum with a style . With arguments `subset`.", "question_id": 45154}
{"snippet": "Styler.highlight_max(color='yellow')", "intent": "Highlight the maximum with a style . With arguments `color`.", "question_id": 45155}
{"snippet": "Styler.highlight_max(axis=0)", "intent": "Highlight the maximum with a style . With arguments `axis`.", "question_id": 45156}
{"snippet": "Styler.highlight_max(props=None)", "intent": "Highlight the maximum with a style . With arguments `props`.", "question_id": 45157}
{"snippet": "Styler.highlight_max(subset=None, color='yellow')", "intent": "Highlight the maximum with a style . With arguments `subset`, `color`.", "question_id": 45158}
{"snippet": "Styler.highlight_max(subset=None, axis=0)", "intent": "Highlight the maximum with a style . With arguments `subset`, `axis`.", "question_id": 45159}
{"snippet": "Styler.highlight_max(subset=None, props=None)", "intent": "Highlight the maximum with a style . With arguments `subset`, `props`.", "question_id": 45160}
{"snippet": "Styler.highlight_max(color='yellow', axis=0)", "intent": "Highlight the maximum with a style . With arguments `color`, `axis`.", "question_id": 45161}
{"snippet": "Styler.highlight_max(color='yellow', props=None)", "intent": "Highlight the maximum with a style . With arguments `color`, `props`.", "question_id": 45162}
{"snippet": "Styler.highlight_max()", "intent": "Highlight the maximum with a style .", "question_id": 45163}
{"snippet": "Styler.highlight_max(subset=None)", "intent": "Highlight the maximum with a style . With arguments `subset`.", "question_id": 45164}
{"snippet": "Styler.highlight_max(color='yellow')", "intent": "Highlight the maximum with a style . With arguments `color`.", "question_id": 45165}
{"snippet": "Styler.highlight_max(axis=0)", "intent": "Highlight the maximum with a style . With arguments `axis`.", "question_id": 45166}
{"snippet": "Styler.highlight_max(props=None)", "intent": "Highlight the maximum with a style . With arguments `props`.", "question_id": 45167}
{"snippet": "Styler.highlight_max(subset=None, color='yellow')", "intent": "Highlight the maximum with a style . With arguments `subset`, `color`.", "question_id": 45168}
{"snippet": "Styler.highlight_max(subset=None, axis=0)", "intent": "Highlight the maximum with a style . With arguments `subset`, `axis`.", "question_id": 45169}
{"snippet": "Styler.highlight_max(subset=None, props=None)", "intent": "Highlight the maximum with a style . With arguments `subset`, `props`.", "question_id": 45170}
{"snippet": "Styler.highlight_max(color='yellow', axis=0)", "intent": "Highlight the maximum with a style . With arguments `color`, `axis`.", "question_id": 45171}
{"snippet": "Styler.highlight_max(color='yellow', props=None)", "intent": "Highlight the maximum with a style . With arguments `color`, `props`.", "question_id": 45172}
{"snippet": "Styler.highlight_min()", "intent": "Highlight the minimum with a style .", "question_id": 45173}
{"snippet": "Styler.highlight_min(subset=None)", "intent": "Highlight the minimum with a style . With arguments `subset`.", "question_id": 45174}
{"snippet": "Styler.highlight_min(color='yellow')", "intent": "Highlight the minimum with a style . With arguments `color`.", "question_id": 45175}
{"snippet": "Styler.highlight_min(axis=0)", "intent": "Highlight the minimum with a style . With arguments `axis`.", "question_id": 45176}
{"snippet": "Styler.highlight_min(props=None)", "intent": "Highlight the minimum with a style . With arguments `props`.", "question_id": 45177}
{"snippet": "Styler.highlight_min(subset=None, color='yellow')", "intent": "Highlight the minimum with a style . With arguments `subset`, `color`.", "question_id": 45178}
{"snippet": "Styler.highlight_min(subset=None, axis=0)", "intent": "Highlight the minimum with a style . With arguments `subset`, `axis`.", "question_id": 45179}
{"snippet": "Styler.highlight_min(subset=None, props=None)", "intent": "Highlight the minimum with a style . With arguments `subset`, `props`.", "question_id": 45180}
{"snippet": "Styler.highlight_min(color='yellow', axis=0)", "intent": "Highlight the minimum with a style . With arguments `color`, `axis`.", "question_id": 45181}
{"snippet": "Styler.highlight_min(color='yellow', props=None)", "intent": "Highlight the minimum with a style . With arguments `color`, `props`.", "question_id": 45182}
{"snippet": "Styler.highlight_min()", "intent": "Highlight the minimum with a style .", "question_id": 45183}
{"snippet": "Styler.highlight_min(subset=None)", "intent": "Highlight the minimum with a style . With arguments `subset`.", "question_id": 45184}
{"snippet": "Styler.highlight_min(color='yellow')", "intent": "Highlight the minimum with a style . With arguments `color`.", "question_id": 45185}
{"snippet": "Styler.highlight_min(axis=0)", "intent": "Highlight the minimum with a style . With arguments `axis`.", "question_id": 45186}
{"snippet": "Styler.highlight_min(props=None)", "intent": "Highlight the minimum with a style . With arguments `props`.", "question_id": 45187}
{"snippet": "Styler.highlight_min(subset=None, color='yellow')", "intent": "Highlight the minimum with a style . With arguments `subset`, `color`.", "question_id": 45188}
{"snippet": "Styler.highlight_min(subset=None, axis=0)", "intent": "Highlight the minimum with a style . With arguments `subset`, `axis`.", "question_id": 45189}
{"snippet": "Styler.highlight_min(subset=None, props=None)", "intent": "Highlight the minimum with a style . With arguments `subset`, `props`.", "question_id": 45190}
{"snippet": "Styler.highlight_min(color='yellow', axis=0)", "intent": "Highlight the minimum with a style . With arguments `color`, `axis`.", "question_id": 45191}
{"snippet": "Styler.highlight_min(color='yellow', props=None)", "intent": "Highlight the minimum with a style . With arguments `color`, `props`.", "question_id": 45192}
{"snippet": "Styler.highlight_min()", "intent": "Highlight the minimum with a style .", "question_id": 45193}
{"snippet": "Styler.highlight_min(subset=None)", "intent": "Highlight the minimum with a style . With arguments `subset`.", "question_id": 45194}
{"snippet": "Styler.highlight_min(color='yellow')", "intent": "Highlight the minimum with a style . With arguments `color`.", "question_id": 45195}
{"snippet": "Styler.highlight_min(axis=0)", "intent": "Highlight the minimum with a style . With arguments `axis`.", "question_id": 45196}
{"snippet": "Styler.highlight_min(props=None)", "intent": "Highlight the minimum with a style . With arguments `props`.", "question_id": 45197}
{"snippet": "Styler.highlight_min(subset=None, color='yellow')", "intent": "Highlight the minimum with a style . With arguments `subset`, `color`.", "question_id": 45198}
{"snippet": "Styler.highlight_min(subset=None, axis=0)", "intent": "Highlight the minimum with a style . With arguments `subset`, `axis`.", "question_id": 45199}
{"snippet": "Styler.highlight_min(subset=None, props=None)", "intent": "Highlight the minimum with a style . With arguments `subset`, `props`.", "question_id": 45200}
{"snippet": "Styler.highlight_min(color='yellow', axis=0)", "intent": "Highlight the minimum with a style . With arguments `color`, `axis`.", "question_id": 45201}
{"snippet": "Styler.highlight_min(color='yellow', props=None)", "intent": "Highlight the minimum with a style . With arguments `color`, `props`.", "question_id": 45202}
{"snippet": "Styler.highlight_null()", "intent": "Highlight missing values with a style .", "question_id": 45203}
{"snippet": "Styler.highlight_null(null_color='red')", "intent": "Highlight missing values with a style . With arguments `null_color`.", "question_id": 45204}
{"snippet": "Styler.highlight_null(subset=None)", "intent": "Highlight missing values with a style . With arguments `subset`.", "question_id": 45205}
{"snippet": "Styler.highlight_null(props=None)", "intent": "Highlight missing values with a style . With arguments `props`.", "question_id": 45206}
{"snippet": "Styler.highlight_null(null_color='red', subset=None)", "intent": "Highlight missing values with a style . With arguments `null_color`, `subset`.", "question_id": 45207}
{"snippet": "Styler.highlight_null(null_color='red', props=None)", "intent": "Highlight missing values with a style . With arguments `null_color`, `props`.", "question_id": 45208}
{"snippet": "Styler.highlight_null(subset=None, props=None)", "intent": "Highlight missing values with a style . With arguments `subset`, `props`.", "question_id": 45209}
{"snippet": "Styler.highlight_null(null_color='red', subset=None, props=None)", "intent": "Highlight missing values with a style . With arguments `null_color`, `subset`, `props`.", "question_id": 45210}
{"snippet": "Styler.highlight_null()", "intent": "Highlight missing values with a style .", "question_id": 45211}
{"snippet": "Styler.highlight_null(null_color='red')", "intent": "Highlight missing values with a style . With arguments `null_color`.", "question_id": 45212}
{"snippet": "Styler.highlight_null(subset=None)", "intent": "Highlight missing values with a style . With arguments `subset`.", "question_id": 45213}
{"snippet": "Styler.highlight_null(props=None)", "intent": "Highlight missing values with a style . With arguments `props`.", "question_id": 45214}
{"snippet": "Styler.highlight_null(null_color='red', subset=None)", "intent": "Highlight missing values with a style . With arguments `null_color`, `subset`.", "question_id": 45215}
{"snippet": "Styler.highlight_null(null_color='red', props=None)", "intent": "Highlight missing values with a style . With arguments `null_color`, `props`.", "question_id": 45216}
{"snippet": "Styler.highlight_null(subset=None, props=None)", "intent": "Highlight missing values with a style . With arguments `subset`, `props`.", "question_id": 45217}
{"snippet": "Styler.highlight_null(null_color='red', subset=None, props=None)", "intent": "Highlight missing values with a style . With arguments `null_color`, `subset`, `props`.", "question_id": 45218}
{"snippet": "Styler.highlight_null()", "intent": "Highlight missing values with a style .", "question_id": 45219}
{"snippet": "Styler.highlight_null(null_color='red')", "intent": "Highlight missing values with a style . With arguments `null_color`.", "question_id": 45220}
{"snippet": "Styler.highlight_null(subset=None)", "intent": "Highlight missing values with a style . With arguments `subset`.", "question_id": 45221}
{"snippet": "Styler.highlight_null(props=None)", "intent": "Highlight missing values with a style . With arguments `props`.", "question_id": 45222}
{"snippet": "Styler.highlight_null(null_color='red', subset=None)", "intent": "Highlight missing values with a style . With arguments `null_color`, `subset`.", "question_id": 45223}
{"snippet": "Styler.highlight_null(null_color='red', props=None)", "intent": "Highlight missing values with a style . With arguments `null_color`, `props`.", "question_id": 45224}
{"snippet": "Styler.highlight_null(subset=None, props=None)", "intent": "Highlight missing values with a style . With arguments `subset`, `props`.", "question_id": 45225}
{"snippet": "Styler.highlight_null(null_color='red', subset=None, props=None)", "intent": "Highlight missing values with a style . With arguments `null_color`, `subset`, `props`.", "question_id": 45226}
{"snippet": "Styler.highlight_quantile()", "intent": "Highlight values defined by a quantile with a style .", "question_id": 45227}
{"snippet": "Styler.highlight_quantile(subset=None)", "intent": "Highlight values defined by a quantile with a style . With arguments `subset`.", "question_id": 45228}
{"snippet": "Styler.highlight_quantile(color='yellow')", "intent": "Highlight values defined by a quantile with a style . With arguments `color`.", "question_id": 45229}
{"snippet": "Styler.highlight_quantile(axis=0)", "intent": "Highlight values defined by a quantile with a style . With arguments `axis`.", "question_id": 45230}
{"snippet": "Styler.highlight_quantile(q_left=0.0)", "intent": "Highlight values defined by a quantile with a style . With arguments `q_left`.", "question_id": 45231}
{"snippet": "Styler.highlight_quantile(q_right=1.0)", "intent": "Highlight values defined by a quantile with a style . With arguments `q_right`.", "question_id": 45232}
{"snippet": "Styler.highlight_quantile(interpolation='linear')", "intent": "Highlight values defined by a quantile with a style . With arguments `interpolation`.", "question_id": 45233}
{"snippet": "Styler.highlight_quantile(inclusive='both')", "intent": "Highlight values defined by a quantile with a style . With arguments `inclusive`.", "question_id": 45234}
{"snippet": "Styler.highlight_quantile(props=None)", "intent": "Highlight values defined by a quantile with a style . Use `props` instead of default background coloring", "question_id": 45235}
{"snippet": "Styler.highlight_quantile(subset=None, color='yellow')", "intent": "Highlight values defined by a quantile with a style . With arguments `subset`, `color`.", "question_id": 45236}
{"snippet": "Styler.highlight_quantile()", "intent": "Highlight values defined by a quantile with a style .", "question_id": 45237}
{"snippet": "Styler.highlight_quantile(subset=None)", "intent": "Highlight values defined by a quantile with a style . With arguments `subset`.", "question_id": 45238}
{"snippet": "Styler.highlight_quantile(color='yellow')", "intent": "Highlight values defined by a quantile with a style . With arguments `color`.", "question_id": 45239}
{"snippet": "Styler.highlight_quantile(axis=0)", "intent": "Highlight values defined by a quantile with a style . With arguments `axis`.", "question_id": 45240}
{"snippet": "Styler.highlight_quantile(q_left=0.0)", "intent": "Highlight values defined by a quantile with a style . With arguments `q_left`.", "question_id": 45241}
{"snippet": "Styler.highlight_quantile(q_right=1.0)", "intent": "Highlight values defined by a quantile with a style . With arguments `q_right`.", "question_id": 45242}
{"snippet": "Styler.highlight_quantile(interpolation='linear')", "intent": "Highlight values defined by a quantile with a style . With arguments `interpolation`.", "question_id": 45243}
{"snippet": "Styler.highlight_quantile(inclusive='both')", "intent": "Highlight values defined by a quantile with a style . With arguments `inclusive`.", "question_id": 45244}
{"snippet": "Styler.highlight_quantile(props=None)", "intent": "Highlight values defined by a quantile with a style . Use `props` instead of default background coloring", "question_id": 45245}
{"snippet": "Styler.highlight_quantile(subset=None, color='yellow')", "intent": "Highlight values defined by a quantile with a style . With arguments `subset`, `color`.", "question_id": 45246}
{"snippet": "Styler.highlight_quantile()", "intent": "Highlight values defined by a quantile with a style .", "question_id": 45247}
{"snippet": "Styler.highlight_quantile(subset=None)", "intent": "Highlight values defined by a quantile with a style . With arguments `subset`.", "question_id": 45248}
{"snippet": "Styler.highlight_quantile(color='yellow')", "intent": "Highlight values defined by a quantile with a style . With arguments `color`.", "question_id": 45249}
{"snippet": "Styler.highlight_quantile(axis=0)", "intent": "Highlight values defined by a quantile with a style . With arguments `axis`.", "question_id": 45250}
{"snippet": "Styler.highlight_quantile(q_left=0.0)", "intent": "Highlight values defined by a quantile with a style . With arguments `q_left`.", "question_id": 45251}
{"snippet": "Styler.highlight_quantile(q_right=1.0)", "intent": "Highlight values defined by a quantile with a style . With arguments `q_right`.", "question_id": 45252}
{"snippet": "Styler.highlight_quantile(interpolation='linear')", "intent": "Highlight values defined by a quantile with a style . With arguments `interpolation`.", "question_id": 45253}
{"snippet": "Styler.highlight_quantile(inclusive='both')", "intent": "Highlight values defined by a quantile with a style . With arguments `inclusive`.", "question_id": 45254}
{"snippet": "Styler.highlight_quantile(props=None)", "intent": "Highlight values defined by a quantile with a style . Use `props` instead of default background coloring", "question_id": 45255}
{"snippet": "Styler.highlight_quantile(subset=None, color='yellow')", "intent": "Highlight values defined by a quantile with a style . With arguments `subset`, `color`.", "question_id": 45256}
{"snippet": "pandas.io.formats.style.Styler(data)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS .", "question_id": 45257}
{"snippet": "pandas.io.formats.style.Styler(data, precision=None)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `precision`.", "question_id": 45258}
{"snippet": "pandas.io.formats.style.Styler(data, table_styles=None)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `table_styles`.", "question_id": 45259}
{"snippet": "pandas.io.formats.style.Styler(data, uuid=None)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `uuid`.", "question_id": 45260}
{"snippet": "pandas.io.formats.style.Styler(data, caption=None)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `caption`.", "question_id": 45261}
{"snippet": "pandas.io.formats.style.Styler(data, table_attributes=None)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `table_attributes`.", "question_id": 45262}
{"snippet": "pandas.io.formats.style.Styler(data, cell_ids=True)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `cell_ids`.", "question_id": 45263}
{"snippet": "pandas.io.formats.style.Styler(data, na_rep=None)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `na_rep`.", "question_id": 45264}
{"snippet": "pandas.io.formats.style.Styler(data, uuid_len=5)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `uuid_len`.", "question_id": 45265}
{"snippet": "pandas.io.formats.style.Styler(data, decimal='.')", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `decimal`.", "question_id": 45266}
{"snippet": "pandas.io.formats.style.Styler(data)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS .", "question_id": 45267}
{"snippet": "pandas.io.formats.style.Styler(data, precision=None)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `precision`.", "question_id": 45268}
{"snippet": "pandas.io.formats.style.Styler(data, table_styles=None)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `table_styles`.", "question_id": 45269}
{"snippet": "pandas.io.formats.style.Styler(data, uuid=None)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `uuid`.", "question_id": 45270}
{"snippet": "pandas.io.formats.style.Styler(data, caption=None)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `caption`.", "question_id": 45271}
{"snippet": "pandas.io.formats.style.Styler(data, table_attributes=None)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `table_attributes`.", "question_id": 45272}
{"snippet": "pandas.io.formats.style.Styler(data, cell_ids=True)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `cell_ids`.", "question_id": 45273}
{"snippet": "pandas.io.formats.style.Styler(data, na_rep=None)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `na_rep`.", "question_id": 45274}
{"snippet": "pandas.io.formats.style.Styler(data, uuid_len=5)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `uuid_len`.", "question_id": 45275}
{"snippet": "pandas.io.formats.style.Styler(data, decimal='.')", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `decimal`.", "question_id": 45276}
{"snippet": "pandas.io.formats.style.Styler(data)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS .", "question_id": 45277}
{"snippet": "pandas.io.formats.style.Styler(data, precision=None)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `precision`.", "question_id": 45278}
{"snippet": "pandas.io.formats.style.Styler(data, table_styles=None)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `table_styles`.", "question_id": 45279}
{"snippet": "pandas.io.formats.style.Styler(data, uuid=None)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `uuid`.", "question_id": 45280}
{"snippet": "pandas.io.formats.style.Styler(data, caption=None)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `caption`.", "question_id": 45281}
{"snippet": "pandas.io.formats.style.Styler(data, table_attributes=None)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `table_attributes`.", "question_id": 45282}
{"snippet": "pandas.io.formats.style.Styler(data, cell_ids=True)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `cell_ids`.", "question_id": 45283}
{"snippet": "pandas.io.formats.style.Styler(data, na_rep=None)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `na_rep`.", "question_id": 45284}
{"snippet": "pandas.io.formats.style.Styler(data, uuid_len=5)", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `uuid_len`.", "question_id": 45285}
{"snippet": "pandas.io.formats.style.Styler(data, decimal='.')", "intent": "Helps style a DataFrame or Series according to the `data` with HTML and CSS . With arguments `decimal`.", "question_id": 45286}
{"snippet": "Styler.pipe(func, *args, **kwargs)", "intent": "Apply `func` ( self , * args , * * kwargs ) , and return the result . With arguments `*args`, `**kwargs`.", "question_id": 45287}
{"snippet": "Styler.pipe(func, *args, **kwargs)", "intent": "Apply `func` ( self , * args , * * kwargs ) , and return the result . With arguments `*args`, `**kwargs`.", "question_id": 45288}
{"snippet": "Styler.pipe(func, *args, **kwargs)", "intent": "Apply `func` ( self , * args , * * kwargs ) , and return the result . With arguments `*args`, `**kwargs`.", "question_id": 45289}
{"snippet": "Styler.render(**kwargs)", "intent": "Render the Styler including all applied styles to HTML . With arguments `**kwargs`.", "question_id": 45290}
{"snippet": "Styler.render(**kwargs, sparse_index=None)", "intent": "Render the Styler including all applied styles to HTML . With arguments `**kwargs`, `sparse_index`.", "question_id": 45291}
{"snippet": "Styler.render(**kwargs, sparse_columns=None)", "intent": "Render the Styler including all applied styles to HTML . With arguments `**kwargs`, `sparse_columns`.", "question_id": 45292}
{"snippet": "Styler.render(**kwargs, sparse_index=None, sparse_columns=None)", "intent": "Render the Styler including all applied styles to HTML . With arguments `**kwargs`, `sparse_index`, `sparse_columns`.", "question_id": 45293}
{"snippet": "Styler.render(**kwargs)", "intent": "Render the Styler including all applied styles to HTML . With arguments `**kwargs`.", "question_id": 45294}
{"snippet": "Styler.render(**kwargs, sparse_index=None)", "intent": "Render the Styler including all applied styles to HTML . With arguments `**kwargs`, `sparse_index`.", "question_id": 45295}
{"snippet": "Styler.render(**kwargs, sparse_columns=None)", "intent": "Render the Styler including all applied styles to HTML . With arguments `**kwargs`, `sparse_columns`.", "question_id": 45296}
{"snippet": "Styler.render(**kwargs, sparse_index=None, sparse_columns=None)", "intent": "Render the Styler including all applied styles to HTML . With arguments `**kwargs`, `sparse_index`, `sparse_columns`.", "question_id": 45297}
{"snippet": "Styler.render(**kwargs)", "intent": "Render the Styler including all applied styles to HTML . With arguments `**kwargs`.", "question_id": 45298}
{"snippet": "Styler.render(**kwargs, sparse_index=None)", "intent": "Render the Styler including all applied styles to HTML . With arguments `**kwargs`, `sparse_index`.", "question_id": 45299}
{"snippet": "Styler.render(**kwargs, sparse_columns=None)", "intent": "Render the Styler including all applied styles to HTML . With arguments `**kwargs`, `sparse_columns`.", "question_id": 45300}
{"snippet": "Styler.render(**kwargs, sparse_index=None, sparse_columns=None)", "intent": "Render the Styler including all applied styles to HTML . With arguments `**kwargs`, `sparse_index`, `sparse_columns`.", "question_id": 45301}
{"snippet": "Styler.set_caption(caption)", "intent": "Set the text added to a < `caption` > HTML element .", "question_id": 45302}
{"snippet": "Styler.set_caption(caption)", "intent": "Set the text added to a < `caption` > HTML element .", "question_id": 45303}
{"snippet": "Styler.set_caption(caption)", "intent": "Set the text added to a < `caption` > HTML element .", "question_id": 45304}
{"snippet": "Styler.set_na_rep(na_rep)", "intent": "Set the missing data representation on a Styler . With arguments `na_rep`.", "question_id": 45305}
{"snippet": "Styler.set_na_rep(na_rep)", "intent": "Set the missing data representation on a Styler . With arguments `na_rep`.", "question_id": 45306}
{"snippet": "Styler.set_na_rep(na_rep)", "intent": "Set the missing data representation on a Styler . With arguments `na_rep`.", "question_id": 45307}
{"snippet": "Styler.set_precision(precision)", "intent": "Set the `precision` used to display values .", "question_id": 45308}
{"snippet": "Styler.set_precision(precision)", "intent": "Set the `precision` used to display values .", "question_id": 45309}
{"snippet": "Styler.set_precision(precision)", "intent": "Set the `precision` used to display values .", "question_id": 45310}
{"snippet": "Styler.set_properties(**kwargs)", "intent": "Set defined CSS-properties to each < td > HTML element within the given `subset` . With arguments `**kwargs`.", "question_id": 45311}
{"snippet": "Styler.set_properties(**kwargs, subset=None)", "intent": "Set defined CSS-properties to each < td > HTML element within the given `subset` . With arguments `**kwargs`.", "question_id": 45312}
{"snippet": "Styler.set_properties(**kwargs)", "intent": "Set defined CSS-properties to each < td > HTML element within the given `subset` . With arguments `**kwargs`.", "question_id": 45313}
{"snippet": "Styler.set_properties(**kwargs, subset=None)", "intent": "Set defined CSS-properties to each < td > HTML element within the given `subset` . With arguments `**kwargs`.", "question_id": 45314}
{"snippet": "Styler.set_properties(**kwargs)", "intent": "Set defined CSS-properties to each < td > HTML element within the given `subset` . With arguments `**kwargs`.", "question_id": 45315}
{"snippet": "Styler.set_properties(**kwargs, subset=None)", "intent": "Set defined CSS-properties to each < td > HTML element within the given `subset` . With arguments `**kwargs`.", "question_id": 45316}
{"snippet": "Styler.set_sticky()", "intent": "Add CSS to permanently display the index or column headers in a scrolling frame .", "question_id": 45317}
{"snippet": "Styler.set_sticky(axis=0)", "intent": "Add CSS to permanently display the index or column headers in a scrolling frame . With arguments `axis`.", "question_id": 45318}
{"snippet": "Styler.set_sticky(pixel_size=None)", "intent": "Add CSS to permanently display the index or column headers in a scrolling frame . With arguments `pixel_size`.", "question_id": 45319}
{"snippet": "Styler.set_sticky(levels=None)", "intent": "Add CSS to permanently display the index or column headers in a scrolling frame . With arguments `levels`.", "question_id": 45320}
{"snippet": "Styler.set_sticky(axis=0, pixel_size=None)", "intent": "Add CSS to permanently display the index or column headers in a scrolling frame . With arguments `axis`, `pixel_size`.", "question_id": 45321}
{"snippet": "Styler.set_sticky(axis=0, levels=None)", "intent": "Add CSS to permanently display the index or column headers in a scrolling frame . With arguments `axis`, `levels`.", "question_id": 45322}
{"snippet": "Styler.set_sticky(pixel_size=None, levels=None)", "intent": "Add CSS to permanently display the index or column headers in a scrolling frame . With arguments `pixel_size`, `levels`.", "question_id": 45323}
{"snippet": "Styler.set_sticky(axis=0, pixel_size=None, levels=None)", "intent": "Add CSS to permanently display the index or column headers in a scrolling frame . With arguments `axis`, `pixel_size`, `levels`.", "question_id": 45324}
{"snippet": "Styler.set_sticky()", "intent": "Add CSS to permanently display the index or column headers in a scrolling frame .", "question_id": 45325}
{"snippet": "Styler.set_sticky(axis=0)", "intent": "Add CSS to permanently display the index or column headers in a scrolling frame . With arguments `axis`.", "question_id": 45326}
{"snippet": "Styler.set_sticky(pixel_size=None)", "intent": "Add CSS to permanently display the index or column headers in a scrolling frame . With arguments `pixel_size`.", "question_id": 45327}
{"snippet": "Styler.set_sticky(levels=None)", "intent": "Add CSS to permanently display the index or column headers in a scrolling frame . With arguments `levels`.", "question_id": 45328}
{"snippet": "Styler.set_sticky(axis=0, pixel_size=None)", "intent": "Add CSS to permanently display the index or column headers in a scrolling frame . With arguments `axis`, `pixel_size`.", "question_id": 45329}
{"snippet": "Styler.set_sticky(axis=0, levels=None)", "intent": "Add CSS to permanently display the index or column headers in a scrolling frame . With arguments `axis`, `levels`.", "question_id": 45330}
{"snippet": "Styler.set_sticky(pixel_size=None, levels=None)", "intent": "Add CSS to permanently display the index or column headers in a scrolling frame . With arguments `pixel_size`, `levels`.", "question_id": 45331}
{"snippet": "Styler.set_sticky(axis=0, pixel_size=None, levels=None)", "intent": "Add CSS to permanently display the index or column headers in a scrolling frame . With arguments `axis`, `pixel_size`, `levels`.", "question_id": 45332}
{"snippet": "Styler.set_sticky()", "intent": "Add CSS to permanently display the index or column headers in a scrolling frame .", "question_id": 45333}
{"snippet": "Styler.set_sticky(axis=0)", "intent": "Add CSS to permanently display the index or column headers in a scrolling frame . With arguments `axis`.", "question_id": 45334}
{"snippet": "Styler.set_sticky(pixel_size=None)", "intent": "Add CSS to permanently display the index or column headers in a scrolling frame . With arguments `pixel_size`.", "question_id": 45335}
{"snippet": "Styler.set_sticky(levels=None)", "intent": "Add CSS to permanently display the index or column headers in a scrolling frame . With arguments `levels`.", "question_id": 45336}
{"snippet": "Styler.set_sticky(axis=0, pixel_size=None)", "intent": "Add CSS to permanently display the index or column headers in a scrolling frame . With arguments `axis`, `pixel_size`.", "question_id": 45337}
{"snippet": "Styler.set_sticky(axis=0, levels=None)", "intent": "Add CSS to permanently display the index or column headers in a scrolling frame . With arguments `axis`, `levels`.", "question_id": 45338}
{"snippet": "Styler.set_sticky(pixel_size=None, levels=None)", "intent": "Add CSS to permanently display the index or column headers in a scrolling frame . With arguments `pixel_size`, `levels`.", "question_id": 45339}
{"snippet": "Styler.set_sticky(axis=0, pixel_size=None, levels=None)", "intent": "Add CSS to permanently display the index or column headers in a scrolling frame . With arguments `axis`, `pixel_size`, `levels`.", "question_id": 45340}
{"snippet": "Styler.set_table_attributes(attributes)", "intent": "Set the table `attributes` added to the < table > HTML element .", "question_id": 45341}
{"snippet": "Styler.set_table_attributes(attributes)", "intent": "Set the table `attributes` added to the < table > HTML element .", "question_id": 45342}
{"snippet": "Styler.set_table_attributes(attributes)", "intent": "Set the table `attributes` added to the < table > HTML element .", "question_id": 45343}
{"snippet": "Styler.set_table_styles(table_styles)", "intent": "Set the table styles included within the < style > HTML element . With arguments `table_styles`.", "question_id": 45344}
{"snippet": "Styler.set_table_styles(table_styles, axis=0)", "intent": "Set the table styles included within the < style > HTML element . With arguments `table_styles`, `axis`.", "question_id": 45345}
{"snippet": "Styler.set_table_styles(table_styles, overwrite=True)", "intent": "Set the table styles included within the < style > HTML element . With arguments `table_styles`, `overwrite`.", "question_id": 45346}
{"snippet": "Styler.set_table_styles(table_styles, axis=0, overwrite=True)", "intent": "Set the table styles included within the < style > HTML element . With arguments `table_styles`, `axis`, `overwrite`.", "question_id": 45347}
{"snippet": "Styler.set_table_styles(table_styles)", "intent": "Set the table styles included within the < style > HTML element . With arguments `table_styles`.", "question_id": 45348}
{"snippet": "Styler.set_table_styles(table_styles, axis=0)", "intent": "Set the table styles included within the < style > HTML element . With arguments `table_styles`, `axis`.", "question_id": 45349}
{"snippet": "Styler.set_table_styles(table_styles, overwrite=True)", "intent": "Set the table styles included within the < style > HTML element . With arguments `table_styles`, `overwrite`.", "question_id": 45350}
{"snippet": "Styler.set_table_styles(table_styles, axis=0, overwrite=True)", "intent": "Set the table styles included within the < style > HTML element . With arguments `table_styles`, `axis`, `overwrite`.", "question_id": 45351}
{"snippet": "Styler.set_table_styles(table_styles)", "intent": "Set the table styles included within the < style > HTML element . With arguments `table_styles`.", "question_id": 45352}
{"snippet": "Styler.set_table_styles(table_styles, axis=0)", "intent": "Set the table styles included within the < style > HTML element . With arguments `table_styles`, `axis`.", "question_id": 45353}
{"snippet": "Styler.set_table_styles(table_styles, overwrite=True)", "intent": "Set the table styles included within the < style > HTML element . With arguments `table_styles`, `overwrite`.", "question_id": 45354}
{"snippet": "Styler.set_table_styles(table_styles, axis=0, overwrite=True)", "intent": "Set the table styles included within the < style > HTML element . With arguments `table_styles`, `axis`, `overwrite`.", "question_id": 45355}
{"snippet": "Styler.set_td_classes(classes)", "intent": "Set the DataFrame of strings added to the class attribute of < td > HTML elements . Using MultiIndex columns and a `classes` DataFrame as a subset of the underlying ,", "question_id": 45356}
{"snippet": "Styler.set_td_classes(classes)", "intent": "Set the DataFrame of strings added to the class attribute of < td > HTML elements . Using MultiIndex columns and a `classes` DataFrame as a subset of the underlying ,", "question_id": 45357}
{"snippet": "Styler.set_td_classes(classes)", "intent": "Set the DataFrame of strings added to the class attribute of < td > HTML elements . Using MultiIndex columns and a `classes` DataFrame as a subset of the underlying ,", "question_id": 45358}
{"snippet": "Styler.set_tooltips(ttips)", "intent": "Set the DataFrame of strings on Styler generating : hover tooltips . With arguments `ttips`.", "question_id": 45359}
{"snippet": "Styler.set_tooltips(ttips, props=None)", "intent": "Set the DataFrame of strings on Styler generating : hover tooltips . The property \u2018 visibility : hidden ; \u2019 is a key prerequisite to the hover functionality , and should always be included in any manual properties specification , using the `props` argument . With arguments `ttips`.", "question_id": 45360}
{"snippet": "Styler.set_tooltips(ttips, css_class=None)", "intent": "Set the DataFrame of strings on Styler generating : hover tooltips . With arguments `ttips`, `css_class`.", "question_id": 45361}
{"snippet": "Styler.set_tooltips(ttips, props=None, css_class=None)", "intent": "Set the DataFrame of strings on Styler generating : hover tooltips . The property \u2018 visibility : hidden ; \u2019 is a key prerequisite to the hover functionality , and should always be included in any manual properties specification , using the `props` argument . With arguments `ttips`, `css_class`.", "question_id": 45362}
{"snippet": "Styler.set_tooltips(ttips)", "intent": "Set the DataFrame of strings on Styler generating : hover tooltips . With arguments `ttips`.", "question_id": 45363}
{"snippet": "Styler.set_tooltips(ttips, props=None)", "intent": "Set the DataFrame of strings on Styler generating : hover tooltips . The property \u2018 visibility : hidden ; \u2019 is a key prerequisite to the hover functionality , and should always be included in any manual properties specification , using the `props` argument . With arguments `ttips`.", "question_id": 45364}
{"snippet": "Styler.set_tooltips(ttips, css_class=None)", "intent": "Set the DataFrame of strings on Styler generating : hover tooltips . With arguments `ttips`, `css_class`.", "question_id": 45365}
{"snippet": "Styler.set_tooltips(ttips, props=None, css_class=None)", "intent": "Set the DataFrame of strings on Styler generating : hover tooltips . The property \u2018 visibility : hidden ; \u2019 is a key prerequisite to the hover functionality , and should always be included in any manual properties specification , using the `props` argument . With arguments `ttips`, `css_class`.", "question_id": 45366}
{"snippet": "Styler.set_tooltips(ttips)", "intent": "Set the DataFrame of strings on Styler generating : hover tooltips . With arguments `ttips`.", "question_id": 45367}
{"snippet": "Styler.set_tooltips(ttips, props=None)", "intent": "Set the DataFrame of strings on Styler generating : hover tooltips . The property \u2018 visibility : hidden ; \u2019 is a key prerequisite to the hover functionality , and should always be included in any manual properties specification , using the `props` argument . With arguments `ttips`.", "question_id": 45368}
{"snippet": "Styler.set_tooltips(ttips, css_class=None)", "intent": "Set the DataFrame of strings on Styler generating : hover tooltips . With arguments `ttips`, `css_class`.", "question_id": 45369}
{"snippet": "Styler.set_tooltips(ttips, props=None, css_class=None)", "intent": "Set the DataFrame of strings on Styler generating : hover tooltips . The property \u2018 visibility : hidden ; \u2019 is a key prerequisite to the hover functionality , and should always be included in any manual properties specification , using the `props` argument . With arguments `ttips`, `css_class`.", "question_id": 45370}
{"snippet": "Styler.set_uuid(uuid)", "intent": "Set the `uuid` applied to id attributes of HTML elements .", "question_id": 45371}
{"snippet": "Styler.set_uuid(uuid)", "intent": "Set the `uuid` applied to id attributes of HTML elements .", "question_id": 45372}
{"snippet": "Styler.set_uuid(uuid)", "intent": "Set the `uuid` applied to id attributes of HTML elements .", "question_id": 45373}
{"snippet": "Styler.text_gradient()", "intent": "Color the text in a gradient style .", "question_id": 45374}
{"snippet": "Styler.text_gradient(cmap='PuBu')", "intent": "Color the text in a gradient style . Setting a gmap and applying to all columns with another `cmap`", "question_id": 45375}
{"snippet": "Styler.text_gradient(low=0)", "intent": "Color the text in a gradient style . When using `low` and `high` the range of the gradient , given by the data if `gmap` is not given or by gmap , is extended at the low end effectively by map.min - low * map.range and at the high end by map.max + high * map.range before the colors are normalized and determined .", "question_id": 45376}
{"snippet": "Styler.text_gradient(high=0)", "intent": "Color the text in a gradient style . When using `low` and `high` the range of the gradient , given by the data if `gmap` is not given or by gmap , is extended at the low end effectively by map.min - low * map.range and at the high end by map.max + high * map.range before the colors are normalized and determined .", "question_id": 45377}
{"snippet": "Styler.text_gradient(axis=0)", "intent": "Color the text in a gradient style . With arguments `axis`.", "question_id": 45378}
{"snippet": "Styler.text_gradient(subset=None)", "intent": "Color the text in a gradient style . axis=None ) , we need to explicitly state `subset` to match the gmap shape", "question_id": 45379}
{"snippet": "Styler.text_gradient(vmin=None)", "intent": "Color the text in a gradient style . If combining with `vmin` and `vmax` the map.min , map.max and map.range are replaced by values according to the values derived from vmin and vmax .", "question_id": 45380}
{"snippet": "Styler.text_gradient(vmax=None)", "intent": "Color the text in a gradient style . If combining with `vmin` and `vmax` the map.min , map.max and map.range are replaced by values according to the values derived from vmin and vmax .", "question_id": 45381}
{"snippet": "Styler.text_gradient(gmap=None)", "intent": "Color the text in a gradient style . When using `low` and `high` the range of the gradient , given by the data if `gmap` is not given or by gmap , is extended at the low end effectively by map.min - low * map.range and at the high end by map.max + high * map.range before the colors are normalized and determined .", "question_id": 45382}
{"snippet": "Styler.text_gradient(cmap='PuBu', low=0)", "intent": "Color the text in a gradient style . Setting a gmap and applying to all columns with another `cmap` When using `low` and `high` the range of the gradient , given by the data if `gmap` is not given or by gmap , is extended at the low end effectively by map.min - low * map.range and at the high end by map.max + high * map.range before the colors are normalized and determined .", "question_id": 45383}
{"snippet": "Styler.text_gradient()", "intent": "Color the text in a gradient style .", "question_id": 45384}
{"snippet": "Styler.text_gradient(cmap='PuBu')", "intent": "Color the text in a gradient style . Setting a gmap and applying to all columns with another `cmap`", "question_id": 45385}
{"snippet": "Styler.text_gradient(low=0)", "intent": "Color the text in a gradient style . When using `low` and `high` the range of the gradient , given by the data if `gmap` is not given or by gmap , is extended at the low end effectively by map.min - low * map.range and at the high end by map.max + high * map.range before the colors are normalized and determined .", "question_id": 45386}
{"snippet": "Styler.text_gradient(high=0)", "intent": "Color the text in a gradient style . When using `low` and `high` the range of the gradient , given by the data if `gmap` is not given or by gmap , is extended at the low end effectively by map.min - low * map.range and at the high end by map.max + high * map.range before the colors are normalized and determined .", "question_id": 45387}
{"snippet": "Styler.text_gradient(axis=0)", "intent": "Color the text in a gradient style . With arguments `axis`.", "question_id": 45388}
{"snippet": "Styler.text_gradient(subset=None)", "intent": "Color the text in a gradient style . axis=None ) , we need to explicitly state `subset` to match the gmap shape", "question_id": 45389}
{"snippet": "Styler.text_gradient(vmin=None)", "intent": "Color the text in a gradient style . If combining with `vmin` and `vmax` the map.min , map.max and map.range are replaced by values according to the values derived from vmin and vmax .", "question_id": 45390}
{"snippet": "Styler.text_gradient(vmax=None)", "intent": "Color the text in a gradient style . If combining with `vmin` and `vmax` the map.min , map.max and map.range are replaced by values according to the values derived from vmin and vmax .", "question_id": 45391}
{"snippet": "Styler.text_gradient(gmap=None)", "intent": "Color the text in a gradient style . When using `low` and `high` the range of the gradient , given by the data if `gmap` is not given or by gmap , is extended at the low end effectively by map.min - low * map.range and at the high end by map.max + high * map.range before the colors are normalized and determined .", "question_id": 45392}
{"snippet": "Styler.text_gradient(cmap='PuBu', low=0)", "intent": "Color the text in a gradient style . Setting a gmap and applying to all columns with another `cmap` When using `low` and `high` the range of the gradient , given by the data if `gmap` is not given or by gmap , is extended at the low end effectively by map.min - low * map.range and at the high end by map.max + high * map.range before the colors are normalized and determined .", "question_id": 45393}
{"snippet": "Styler.text_gradient()", "intent": "Color the text in a gradient style .", "question_id": 45394}
{"snippet": "Styler.text_gradient(cmap='PuBu')", "intent": "Color the text in a gradient style . Setting a gmap and applying to all columns with another `cmap`", "question_id": 45395}
{"snippet": "Styler.text_gradient(low=0)", "intent": "Color the text in a gradient style . When using `low` and `high` the range of the gradient , given by the data if `gmap` is not given or by gmap , is extended at the low end effectively by map.min - low * map.range and at the high end by map.max + high * map.range before the colors are normalized and determined .", "question_id": 45396}
{"snippet": "Styler.text_gradient(high=0)", "intent": "Color the text in a gradient style . When using `low` and `high` the range of the gradient , given by the data if `gmap` is not given or by gmap , is extended at the low end effectively by map.min - low * map.range and at the high end by map.max + high * map.range before the colors are normalized and determined .", "question_id": 45397}
{"snippet": "Styler.text_gradient(axis=0)", "intent": "Color the text in a gradient style . With arguments `axis`.", "question_id": 45398}
{"snippet": "Styler.text_gradient(subset=None)", "intent": "Color the text in a gradient style . axis=None ) , we need to explicitly state `subset` to match the gmap shape", "question_id": 45399}
{"snippet": "Styler.text_gradient(vmin=None)", "intent": "Color the text in a gradient style . If combining with `vmin` and `vmax` the map.min , map.max and map.range are replaced by values according to the values derived from vmin and vmax .", "question_id": 45400}
{"snippet": "Styler.text_gradient(vmax=None)", "intent": "Color the text in a gradient style . If combining with `vmin` and `vmax` the map.min , map.max and map.range are replaced by values according to the values derived from vmin and vmax .", "question_id": 45401}
{"snippet": "Styler.text_gradient(gmap=None)", "intent": "Color the text in a gradient style . When using `low` and `high` the range of the gradient , given by the data if `gmap` is not given or by gmap , is extended at the low end effectively by map.min - low * map.range and at the high end by map.max + high * map.range before the colors are normalized and determined .", "question_id": 45402}
{"snippet": "Styler.text_gradient(cmap='PuBu', low=0)", "intent": "Color the text in a gradient style . Setting a gmap and applying to all columns with another `cmap` When using `low` and `high` the range of the gradient , given by the data if `gmap` is not given or by gmap , is extended at the low end effectively by map.min - low * map.range and at the high end by map.max + high * map.range before the colors are normalized and determined .", "question_id": 45403}
{"snippet": "Styler.to_excel(excel_writer)", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`.", "question_id": 45404}
{"snippet": "Styler.to_excel(excel_writer, sheet_name='Sheet1')", "intent": "Write Styler to an Excel sheet . Multiple sheets may be written to by specifying unique `sheet_name` . With arguments `excel_writer`.", "question_id": 45405}
{"snippet": "Styler.to_excel(excel_writer, na_rep='')", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`, `na_rep`.", "question_id": 45406}
{"snippet": "Styler.to_excel(excel_writer, float_format=None)", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`, `float_format`.", "question_id": 45407}
{"snippet": "Styler.to_excel(excel_writer, columns=None)", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`, `columns`.", "question_id": 45408}
{"snippet": "Styler.to_excel(excel_writer, header=True)", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`, `header`.", "question_id": 45409}
{"snippet": "Styler.to_excel(excel_writer, index=True)", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`, `index`.", "question_id": 45410}
{"snippet": "Styler.to_excel(excel_writer, index_label=None)", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`, `index_label`.", "question_id": 45411}
{"snippet": "Styler.to_excel(excel_writer, startrow=0)", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`, `startrow`.", "question_id": 45412}
{"snippet": "Styler.to_excel(excel_writer, startcol=0)", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`, `startcol`.", "question_id": 45413}
{"snippet": "Styler.to_excel(excel_writer)", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`.", "question_id": 45414}
{"snippet": "Styler.to_excel(excel_writer, sheet_name='Sheet1')", "intent": "Write Styler to an Excel sheet . Multiple sheets may be written to by specifying unique `sheet_name` . With arguments `excel_writer`.", "question_id": 45415}
{"snippet": "Styler.to_excel(excel_writer, na_rep='')", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`, `na_rep`.", "question_id": 45416}
{"snippet": "Styler.to_excel(excel_writer, float_format=None)", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`, `float_format`.", "question_id": 45417}
{"snippet": "Styler.to_excel(excel_writer, columns=None)", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`, `columns`.", "question_id": 45418}
{"snippet": "Styler.to_excel(excel_writer, header=True)", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`, `header`.", "question_id": 45419}
{"snippet": "Styler.to_excel(excel_writer, index=True)", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`, `index`.", "question_id": 45420}
{"snippet": "Styler.to_excel(excel_writer, index_label=None)", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`, `index_label`.", "question_id": 45421}
{"snippet": "Styler.to_excel(excel_writer, startrow=0)", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`, `startrow`.", "question_id": 45422}
{"snippet": "Styler.to_excel(excel_writer, startcol=0)", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`, `startcol`.", "question_id": 45423}
{"snippet": "Styler.to_excel(excel_writer)", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`.", "question_id": 45424}
{"snippet": "Styler.to_excel(excel_writer, sheet_name='Sheet1')", "intent": "Write Styler to an Excel sheet . Multiple sheets may be written to by specifying unique `sheet_name` . With arguments `excel_writer`.", "question_id": 45425}
{"snippet": "Styler.to_excel(excel_writer, na_rep='')", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`, `na_rep`.", "question_id": 45426}
{"snippet": "Styler.to_excel(excel_writer, float_format=None)", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`, `float_format`.", "question_id": 45427}
{"snippet": "Styler.to_excel(excel_writer, columns=None)", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`, `columns`.", "question_id": 45428}
{"snippet": "Styler.to_excel(excel_writer, header=True)", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`, `header`.", "question_id": 45429}
{"snippet": "Styler.to_excel(excel_writer, index=True)", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`, `index`.", "question_id": 45430}
{"snippet": "Styler.to_excel(excel_writer, index_label=None)", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`, `index_label`.", "question_id": 45431}
{"snippet": "Styler.to_excel(excel_writer, startrow=0)", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`, `startrow`.", "question_id": 45432}
{"snippet": "Styler.to_excel(excel_writer, startcol=0)", "intent": "Write Styler to an Excel sheet . With arguments `excel_writer`, `startcol`.", "question_id": 45433}
{"snippet": "Styler.to_html()", "intent": "Write Styler to a file , buffer or string in HTML-CSS format .", "question_id": 45434}
{"snippet": "Styler.to_html(buf=None)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `buf`.", "question_id": 45435}
{"snippet": "Styler.to_html(table_uuid=None)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `table_uuid`.", "question_id": 45436}
{"snippet": "Styler.to_html(table_attributes=None)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `table_attributes`.", "question_id": 45437}
{"snippet": "Styler.to_html(encoding=None)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `encoding`.", "question_id": 45438}
{"snippet": "Styler.to_html(doctype_html=False)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `doctype_html`.", "question_id": 45439}
{"snippet": "Styler.to_html(exclude_styles=False)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `exclude_styles`.", "question_id": 45440}
{"snippet": "Styler.to_html(buf=None, table_uuid=None)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `buf`, `table_uuid`.", "question_id": 45441}
{"snippet": "Styler.to_html(buf=None, table_attributes=None)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `buf`, `table_attributes`.", "question_id": 45442}
{"snippet": "Styler.to_html(buf=None, encoding=None)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `buf`, `encoding`.", "question_id": 45443}
{"snippet": "Styler.to_html()", "intent": "Write Styler to a file , buffer or string in HTML-CSS format .", "question_id": 45444}
{"snippet": "Styler.to_html(buf=None)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `buf`.", "question_id": 45445}
{"snippet": "Styler.to_html(table_uuid=None)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `table_uuid`.", "question_id": 45446}
{"snippet": "Styler.to_html(table_attributes=None)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `table_attributes`.", "question_id": 45447}
{"snippet": "Styler.to_html(encoding=None)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `encoding`.", "question_id": 45448}
{"snippet": "Styler.to_html(doctype_html=False)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `doctype_html`.", "question_id": 45449}
{"snippet": "Styler.to_html(exclude_styles=False)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `exclude_styles`.", "question_id": 45450}
{"snippet": "Styler.to_html(buf=None, table_uuid=None)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `buf`, `table_uuid`.", "question_id": 45451}
{"snippet": "Styler.to_html(buf=None, table_attributes=None)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `buf`, `table_attributes`.", "question_id": 45452}
{"snippet": "Styler.to_html(buf=None, encoding=None)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `buf`, `encoding`.", "question_id": 45453}
{"snippet": "Styler.to_html()", "intent": "Write Styler to a file , buffer or string in HTML-CSS format .", "question_id": 45454}
{"snippet": "Styler.to_html(buf=None)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `buf`.", "question_id": 45455}
{"snippet": "Styler.to_html(table_uuid=None)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `table_uuid`.", "question_id": 45456}
{"snippet": "Styler.to_html(table_attributes=None)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `table_attributes`.", "question_id": 45457}
{"snippet": "Styler.to_html(encoding=None)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `encoding`.", "question_id": 45458}
{"snippet": "Styler.to_html(doctype_html=False)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `doctype_html`.", "question_id": 45459}
{"snippet": "Styler.to_html(exclude_styles=False)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `exclude_styles`.", "question_id": 45460}
{"snippet": "Styler.to_html(buf=None, table_uuid=None)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `buf`, `table_uuid`.", "question_id": 45461}
{"snippet": "Styler.to_html(buf=None, table_attributes=None)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `buf`, `table_attributes`.", "question_id": 45462}
{"snippet": "Styler.to_html(buf=None, encoding=None)", "intent": "Write Styler to a file , buffer or string in HTML-CSS format . With arguments `buf`, `encoding`.", "question_id": 45463}
{"snippet": "Styler.to_latex()", "intent": "Write Styler to a file , buffer or string in LaTeX format .", "question_id": 45464}
{"snippet": "Styler.to_latex(buf=None)", "intent": "Write Styler to a file , buffer or string in LaTeX format . With arguments `buf`.", "question_id": 45465}
{"snippet": "Styler.to_latex(column_format=None)", "intent": "Write Styler to a file , buffer or string in LaTeX format . Internally Styler uses its table_styles object to parse the `column_format` , `position` , `position_float` , and `label` input arguments .", "question_id": 45466}
{"snippet": "Styler.to_latex(position=None)", "intent": "Write Styler to a file , buffer or string in LaTeX format . Internally Styler uses its table_styles object to parse the `column_format` , `position` , `position_float` , and `label` input arguments .", "question_id": 45467}
{"snippet": "Styler.to_latex(position_float=None)", "intent": "Write Styler to a file , buffer or string in LaTeX format . Internally Styler uses its table_styles object to parse the `column_format` , `position` , `position_float` , and `label` input arguments .", "question_id": 45468}
{"snippet": "Styler.to_latex(hrules=False)", "intent": "Write Styler to a file , buffer or string in LaTeX format . Exception is made for the `hrules` argument which , in fact , controls all three commands : toprule , bottomrule and midrule simultaneously .", "question_id": 45469}
{"snippet": "Styler.to_latex(label=None)", "intent": "Write Styler to a file , buffer or string in LaTeX format . Internally Styler uses its table_styles object to parse the `column_format` , `position` , `position_float` , and `label` input arguments .", "question_id": 45470}
{"snippet": "Styler.to_latex(caption=None)", "intent": "Write Styler to a file , buffer or string in LaTeX format . With arguments `caption`.", "question_id": 45471}
{"snippet": "Styler.to_latex(sparse_index=None)", "intent": "Write Styler to a file , buffer or string in LaTeX format . With arguments `sparse_index`.", "question_id": 45472}
{"snippet": "Styler.to_latex(sparse_columns=None)", "intent": "Write Styler to a file , buffer or string in LaTeX format . With arguments `sparse_columns`.", "question_id": 45473}
{"snippet": "Styler.to_latex()", "intent": "Write Styler to a file , buffer or string in LaTeX format .", "question_id": 45474}
{"snippet": "Styler.to_latex(buf=None)", "intent": "Write Styler to a file , buffer or string in LaTeX format . With arguments `buf`.", "question_id": 45475}
{"snippet": "Styler.to_latex(column_format=None)", "intent": "Write Styler to a file , buffer or string in LaTeX format . Internally Styler uses its table_styles object to parse the `column_format` , `position` , `position_float` , and `label` input arguments .", "question_id": 45476}
{"snippet": "Styler.to_latex(position=None)", "intent": "Write Styler to a file , buffer or string in LaTeX format . Internally Styler uses its table_styles object to parse the `column_format` , `position` , `position_float` , and `label` input arguments .", "question_id": 45477}
{"snippet": "Styler.to_latex(position_float=None)", "intent": "Write Styler to a file , buffer or string in LaTeX format . Internally Styler uses its table_styles object to parse the `column_format` , `position` , `position_float` , and `label` input arguments .", "question_id": 45478}
{"snippet": "Styler.to_latex(hrules=False)", "intent": "Write Styler to a file , buffer or string in LaTeX format . Exception is made for the `hrules` argument which , in fact , controls all three commands : toprule , bottomrule and midrule simultaneously .", "question_id": 45479}
{"snippet": "Styler.to_latex(label=None)", "intent": "Write Styler to a file , buffer or string in LaTeX format . Internally Styler uses its table_styles object to parse the `column_format` , `position` , `position_float` , and `label` input arguments .", "question_id": 45480}
{"snippet": "Styler.to_latex(caption=None)", "intent": "Write Styler to a file , buffer or string in LaTeX format . With arguments `caption`.", "question_id": 45481}
{"snippet": "Styler.to_latex(sparse_index=None)", "intent": "Write Styler to a file , buffer or string in LaTeX format . With arguments `sparse_index`.", "question_id": 45482}
{"snippet": "Styler.to_latex(sparse_columns=None)", "intent": "Write Styler to a file , buffer or string in LaTeX format . With arguments `sparse_columns`.", "question_id": 45483}
{"snippet": "Styler.to_latex()", "intent": "Write Styler to a file , buffer or string in LaTeX format .", "question_id": 45484}
{"snippet": "Styler.to_latex(buf=None)", "intent": "Write Styler to a file , buffer or string in LaTeX format . With arguments `buf`.", "question_id": 45485}
{"snippet": "Styler.to_latex(column_format=None)", "intent": "Write Styler to a file , buffer or string in LaTeX format . Internally Styler uses its table_styles object to parse the `column_format` , `position` , `position_float` , and `label` input arguments .", "question_id": 45486}
{"snippet": "Styler.to_latex(position=None)", "intent": "Write Styler to a file , buffer or string in LaTeX format . Internally Styler uses its table_styles object to parse the `column_format` , `position` , `position_float` , and `label` input arguments .", "question_id": 45487}
{"snippet": "Styler.to_latex(position_float=None)", "intent": "Write Styler to a file , buffer or string in LaTeX format . Internally Styler uses its table_styles object to parse the `column_format` , `position` , `position_float` , and `label` input arguments .", "question_id": 45488}
{"snippet": "Styler.to_latex(hrules=False)", "intent": "Write Styler to a file , buffer or string in LaTeX format . Exception is made for the `hrules` argument which , in fact , controls all three commands : toprule , bottomrule and midrule simultaneously .", "question_id": 45489}
{"snippet": "Styler.to_latex(label=None)", "intent": "Write Styler to a file , buffer or string in LaTeX format . Internally Styler uses its table_styles object to parse the `column_format` , `position` , `position_float` , and `label` input arguments .", "question_id": 45490}
{"snippet": "Styler.to_latex(caption=None)", "intent": "Write Styler to a file , buffer or string in LaTeX format . With arguments `caption`.", "question_id": 45491}
{"snippet": "Styler.to_latex(sparse_index=None)", "intent": "Write Styler to a file , buffer or string in LaTeX format . With arguments `sparse_index`.", "question_id": 45492}
{"snippet": "Styler.to_latex(sparse_columns=None)", "intent": "Write Styler to a file , buffer or string in LaTeX format . With arguments `sparse_columns`.", "question_id": 45493}
{"snippet": "Styler.use(styles)", "intent": "Set the `styles` on the current Styler .", "question_id": 45494}
{"snippet": "Styler.use(styles)", "intent": "Set the `styles` on the current Styler .", "question_id": 45495}
{"snippet": "Styler.use(styles)", "intent": "Set the `styles` on the current Styler .", "question_id": 45496}
{"snippet": "Styler.where(cond, value, **kwargs)", "intent": "Apply CSS-styles based on a conditional function elementwise . Updates the HTML representation with a style which is selected in accordance with the return `value` of a function . With arguments `cond`, `**kwargs`.", "question_id": 45497}
{"snippet": "Styler.where(cond, value, **kwargs, other=None)", "intent": "Apply CSS-styles based on a conditional function elementwise . Updates the HTML representation with a style which is selected in accordance with the return `value` of a function . With arguments `cond`, `**kwargs`, `other`.", "question_id": 45498}
{"snippet": "Styler.where(cond, value, **kwargs, subset=None)", "intent": "Apply CSS-styles based on a conditional function elementwise . Updates the HTML representation with a style which is selected in accordance with the return `value` of a function . With arguments `cond`, `**kwargs`, `subset`.", "question_id": 45499}
{"snippet": "Styler.where(cond, value, **kwargs, other=None, subset=None)", "intent": "Apply CSS-styles based on a conditional function elementwise . Updates the HTML representation with a style which is selected in accordance with the return `value` of a function . With arguments `cond`, `**kwargs`, `other`, `subset`.", "question_id": 45500}
{"snippet": "Styler.where(cond, value, **kwargs)", "intent": "Apply CSS-styles based on a conditional function elementwise . Updates the HTML representation with a style which is selected in accordance with the return `value` of a function . With arguments `cond`, `**kwargs`.", "question_id": 45501}
{"snippet": "Styler.where(cond, value, **kwargs, other=None)", "intent": "Apply CSS-styles based on a conditional function elementwise . Updates the HTML representation with a style which is selected in accordance with the return `value` of a function . With arguments `cond`, `**kwargs`, `other`.", "question_id": 45502}
{"snippet": "Styler.where(cond, value, **kwargs, subset=None)", "intent": "Apply CSS-styles based on a conditional function elementwise . Updates the HTML representation with a style which is selected in accordance with the return `value` of a function . With arguments `cond`, `**kwargs`, `subset`.", "question_id": 45503}
{"snippet": "Styler.where(cond, value, **kwargs, other=None, subset=None)", "intent": "Apply CSS-styles based on a conditional function elementwise . Updates the HTML representation with a style which is selected in accordance with the return `value` of a function . With arguments `cond`, `**kwargs`, `other`, `subset`.", "question_id": 45504}
{"snippet": "Styler.where(cond, value, **kwargs)", "intent": "Apply CSS-styles based on a conditional function elementwise . Updates the HTML representation with a style which is selected in accordance with the return `value` of a function . With arguments `cond`, `**kwargs`.", "question_id": 45505}
{"snippet": "Styler.where(cond, value, **kwargs, other=None)", "intent": "Apply CSS-styles based on a conditional function elementwise . Updates the HTML representation with a style which is selected in accordance with the return `value` of a function . With arguments `cond`, `**kwargs`, `other`.", "question_id": 45506}
{"snippet": "Styler.where(cond, value, **kwargs, subset=None)", "intent": "Apply CSS-styles based on a conditional function elementwise . Updates the HTML representation with a style which is selected in accordance with the return `value` of a function . With arguments `cond`, `**kwargs`, `subset`.", "question_id": 45507}
{"snippet": "Styler.where(cond, value, **kwargs, other=None, subset=None)", "intent": "Apply CSS-styles based on a conditional function elementwise . Updates the HTML representation with a style which is selected in accordance with the return `value` of a function . With arguments `cond`, `**kwargs`, `other`, `subset`.", "question_id": 45508}
{"snippet": "pandas.io.json.build_table_schema(data)", "intent": "Create a Table schema from `data` .", "question_id": 45509}
{"snippet": "pandas.io.json.build_table_schema(data, index=True)", "intent": "Create a Table schema from `data` . With arguments `index`.", "question_id": 45510}
{"snippet": "pandas.io.json.build_table_schema(data, primary_key=None)", "intent": "Create a Table schema from `data` . With arguments `primary_key`.", "question_id": 45511}
{"snippet": "pandas.io.json.build_table_schema(data, version=True)", "intent": "Create a Table schema from `data` . With arguments `version`.", "question_id": 45512}
{"snippet": "pandas.io.json.build_table_schema(data, index=True, primary_key=None)", "intent": "Create a Table schema from `data` . With arguments `index`, `primary_key`.", "question_id": 45513}
{"snippet": "pandas.io.json.build_table_schema(data, index=True, version=True)", "intent": "Create a Table schema from `data` . With arguments `index`, `version`.", "question_id": 45514}
{"snippet": "pandas.io.json.build_table_schema(data, primary_key=None, version=True)", "intent": "Create a Table schema from `data` . With arguments `primary_key`, `version`.", "question_id": 45515}
{"snippet": "pandas.io.json.build_table_schema(data, index=True, primary_key=None, version=True)", "intent": "Create a Table schema from `data` . With arguments `index`, `primary_key`, `version`.", "question_id": 45516}
{"snippet": "pandas.io.json.build_table_schema(data)", "intent": "Create a Table schema from `data` .", "question_id": 45517}
{"snippet": "pandas.io.json.build_table_schema(data, index=True)", "intent": "Create a Table schema from `data` . With arguments `index`.", "question_id": 45518}
{"snippet": "pandas.io.json.build_table_schema(data, primary_key=None)", "intent": "Create a Table schema from `data` . With arguments `primary_key`.", "question_id": 45519}
{"snippet": "pandas.io.json.build_table_schema(data, version=True)", "intent": "Create a Table schema from `data` . With arguments `version`.", "question_id": 45520}
{"snippet": "pandas.io.json.build_table_schema(data, index=True, primary_key=None)", "intent": "Create a Table schema from `data` . With arguments `index`, `primary_key`.", "question_id": 45521}
{"snippet": "pandas.io.json.build_table_schema(data, index=True, version=True)", "intent": "Create a Table schema from `data` . With arguments `index`, `version`.", "question_id": 45522}
{"snippet": "pandas.io.json.build_table_schema(data, primary_key=None, version=True)", "intent": "Create a Table schema from `data` . With arguments `primary_key`, `version`.", "question_id": 45523}
{"snippet": "pandas.io.json.build_table_schema(data, index=True, primary_key=None, version=True)", "intent": "Create a Table schema from `data` . With arguments `index`, `primary_key`, `version`.", "question_id": 45524}
{"snippet": "pandas.io.json.build_table_schema(data)", "intent": "Create a Table schema from `data` .", "question_id": 45525}
{"snippet": "pandas.io.json.build_table_schema(data, index=True)", "intent": "Create a Table schema from `data` . With arguments `index`.", "question_id": 45526}
{"snippet": "pandas.io.json.build_table_schema(data, primary_key=None)", "intent": "Create a Table schema from `data` . With arguments `primary_key`.", "question_id": 45527}
{"snippet": "pandas.io.json.build_table_schema(data, version=True)", "intent": "Create a Table schema from `data` . With arguments `version`.", "question_id": 45528}
{"snippet": "pandas.io.json.build_table_schema(data, index=True, primary_key=None)", "intent": "Create a Table schema from `data` . With arguments `index`, `primary_key`.", "question_id": 45529}
{"snippet": "pandas.io.json.build_table_schema(data, index=True, version=True)", "intent": "Create a Table schema from `data` . With arguments `index`, `version`.", "question_id": 45530}
{"snippet": "pandas.io.json.build_table_schema(data, primary_key=None, version=True)", "intent": "Create a Table schema from `data` . With arguments `primary_key`, `version`.", "question_id": 45531}
{"snippet": "pandas.io.json.build_table_schema(data, index=True, primary_key=None, version=True)", "intent": "Create a Table schema from `data` . With arguments `index`, `primary_key`, `version`.", "question_id": 45532}
{"snippet": "pandas.io.json.read_json()", "intent": "Convert a JSON string to pandas object .", "question_id": 45533}
{"snippet": "pandas.io.json.read_json(path_or_buf=None)", "intent": "Convert a JSON string to pandas object . With arguments `path_or_buf`.", "question_id": 45534}
{"snippet": "pandas.io.json.read_json(orient=None)", "intent": "Convert a JSON string to pandas object . With arguments `orient`.", "question_id": 45535}
{"snippet": "pandas.io.json.read_json(typ='frame')", "intent": "Convert a JSON string to pandas object . With arguments `typ`.", "question_id": 45536}
{"snippet": "pandas.io.json.read_json(dtype=None)", "intent": "Convert a JSON string to pandas object . With arguments `dtype`.", "question_id": 45537}
{"snippet": "pandas.io.json.read_json(convert_axes=None)", "intent": "Convert a JSON string to pandas object . With arguments `convert_axes`.", "question_id": 45538}
{"snippet": "pandas.io.json.read_json(convert_dates=True)", "intent": "Convert a JSON string to pandas object . With arguments `convert_dates`.", "question_id": 45539}
{"snippet": "pandas.io.json.read_json(keep_default_dates=True)", "intent": "Convert a JSON string to pandas object . With arguments `keep_default_dates`.", "question_id": 45540}
{"snippet": "pandas.io.json.read_json(numpy=False)", "intent": "Convert a JSON string to pandas object . With arguments `numpy`.", "question_id": 45541}
{"snippet": "pandas.io.json.read_json(precise_float=False)", "intent": "Convert a JSON string to pandas object . With arguments `precise_float`.", "question_id": 45542}
{"snippet": "pandas.io.json.read_json()", "intent": "Convert a JSON string to pandas object .", "question_id": 45543}
{"snippet": "pandas.io.json.read_json(path_or_buf=None)", "intent": "Convert a JSON string to pandas object . With arguments `path_or_buf`.", "question_id": 45544}
{"snippet": "pandas.io.json.read_json(orient=None)", "intent": "Convert a JSON string to pandas object . With arguments `orient`.", "question_id": 45545}
{"snippet": "pandas.io.json.read_json(typ='frame')", "intent": "Convert a JSON string to pandas object . With arguments `typ`.", "question_id": 45546}
{"snippet": "pandas.io.json.read_json(dtype=None)", "intent": "Convert a JSON string to pandas object . With arguments `dtype`.", "question_id": 45547}
{"snippet": "pandas.io.json.read_json(convert_axes=None)", "intent": "Convert a JSON string to pandas object . With arguments `convert_axes`.", "question_id": 45548}
{"snippet": "pandas.io.json.read_json(convert_dates=True)", "intent": "Convert a JSON string to pandas object . With arguments `convert_dates`.", "question_id": 45549}
{"snippet": "pandas.io.json.read_json(keep_default_dates=True)", "intent": "Convert a JSON string to pandas object . With arguments `keep_default_dates`.", "question_id": 45550}
{"snippet": "pandas.io.json.read_json(numpy=False)", "intent": "Convert a JSON string to pandas object . With arguments `numpy`.", "question_id": 45551}
{"snippet": "pandas.io.json.read_json(precise_float=False)", "intent": "Convert a JSON string to pandas object . With arguments `precise_float`.", "question_id": 45552}
{"snippet": "pandas.io.json.read_json()", "intent": "Convert a JSON string to pandas object .", "question_id": 45553}
{"snippet": "pandas.io.json.read_json(path_or_buf=None)", "intent": "Convert a JSON string to pandas object . With arguments `path_or_buf`.", "question_id": 45554}
{"snippet": "pandas.io.json.read_json(orient=None)", "intent": "Convert a JSON string to pandas object . With arguments `orient`.", "question_id": 45555}
{"snippet": "pandas.io.json.read_json(typ='frame')", "intent": "Convert a JSON string to pandas object . With arguments `typ`.", "question_id": 45556}
{"snippet": "pandas.io.json.read_json(dtype=None)", "intent": "Convert a JSON string to pandas object . With arguments `dtype`.", "question_id": 45557}
{"snippet": "pandas.io.json.read_json(convert_axes=None)", "intent": "Convert a JSON string to pandas object . With arguments `convert_axes`.", "question_id": 45558}
{"snippet": "pandas.io.json.read_json(convert_dates=True)", "intent": "Convert a JSON string to pandas object . With arguments `convert_dates`.", "question_id": 45559}
{"snippet": "pandas.io.json.read_json(keep_default_dates=True)", "intent": "Convert a JSON string to pandas object . With arguments `keep_default_dates`.", "question_id": 45560}
{"snippet": "pandas.io.json.read_json(numpy=False)", "intent": "Convert a JSON string to pandas object . With arguments `numpy`.", "question_id": 45561}
{"snippet": "pandas.io.json.read_json(precise_float=False)", "intent": "Convert a JSON string to pandas object . With arguments `precise_float`.", "question_id": 45562}
{"snippet": "StataReader.value_labels()", "intent": "Return a dict , associating each variable name a dict , associating each value its corresponding label .", "question_id": 45563}
{"snippet": "StataReader.value_labels()", "intent": "Return a dict , associating each variable name a dict , associating each value its corresponding label .", "question_id": 45564}
{"snippet": "StataReader.value_labels()", "intent": "Return a dict , associating each variable name a dict , associating each value its corresponding label .", "question_id": 45565}
{"snippet": "StataReader.variable_labels()", "intent": "Return variable labels as a dict , associating each variable name with corresponding label .", "question_id": 45566}
{"snippet": "StataReader.variable_labels()", "intent": "Return variable labels as a dict , associating each variable name with corresponding label .", "question_id": 45567}
{"snippet": "StataReader.variable_labels()", "intent": "Return variable labels as a dict , associating each variable name with corresponding label .", "question_id": 45568}
{"snippet": "pandas.isna(obj)", "intent": "Detect missing values for an array-like object . With arguments `obj`.", "question_id": 45569}
{"snippet": "pandas.isna(obj)", "intent": "Detect missing values for an array-like object . With arguments `obj`.", "question_id": 45570}
{"snippet": "pandas.isna(obj)", "intent": "Detect missing values for an array-like object . With arguments `obj`.", "question_id": 45571}
{"snippet": "pandas.isnull(obj)", "intent": "Detect missing values for an array-like object . With arguments `obj`.", "question_id": 45572}
{"snippet": "pandas.isnull(obj)", "intent": "Detect missing values for an array-like object . With arguments `obj`.", "question_id": 45573}
{"snippet": "pandas.isnull(obj)", "intent": "Detect missing values for an array-like object . With arguments `obj`.", "question_id": 45574}
{"snippet": "pandas.melt(frame)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `frame`.", "question_id": 45575}
{"snippet": "pandas.melt(frame, id_vars=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 . With arguments `frame`.", "question_id": 45576}
{"snippet": "pandas.melt(frame, value_vars=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 . With arguments `frame`.", "question_id": 45577}
{"snippet": "pandas.melt(frame, var_name=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `frame`, `var_name`.", "question_id": 45578}
{"snippet": "pandas.melt(frame, value_name='value')", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `frame`, `value_name`.", "question_id": 45579}
{"snippet": "pandas.melt(frame, col_level=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `frame`, `col_level`.", "question_id": 45580}
{"snippet": "pandas.melt(frame, ignore_index=True)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `frame`, `ignore_index`.", "question_id": 45581}
{"snippet": "pandas.melt(frame, id_vars=None, value_vars=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 . With arguments `frame`.", "question_id": 45582}
{"snippet": "pandas.melt(frame, id_vars=None, var_name=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 . With arguments `frame`, `var_name`.", "question_id": 45583}
{"snippet": "pandas.melt(frame, id_vars=None, value_name='value')", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 . With arguments `frame`, `value_name`.", "question_id": 45584}
{"snippet": "pandas.melt(frame)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `frame`.", "question_id": 45585}
{"snippet": "pandas.melt(frame, id_vars=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 . With arguments `frame`.", "question_id": 45586}
{"snippet": "pandas.melt(frame, value_vars=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 . With arguments `frame`.", "question_id": 45587}
{"snippet": "pandas.melt(frame, var_name=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `frame`, `var_name`.", "question_id": 45588}
{"snippet": "pandas.melt(frame, value_name='value')", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `frame`, `value_name`.", "question_id": 45589}
{"snippet": "pandas.melt(frame, col_level=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `frame`, `col_level`.", "question_id": 45590}
{"snippet": "pandas.melt(frame, ignore_index=True)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `frame`, `ignore_index`.", "question_id": 45591}
{"snippet": "pandas.melt(frame, id_vars=None, value_vars=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 . With arguments `frame`.", "question_id": 45592}
{"snippet": "pandas.melt(frame, id_vars=None, var_name=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 . With arguments `frame`, `var_name`.", "question_id": 45593}
{"snippet": "pandas.melt(frame, id_vars=None, value_name='value')", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 . With arguments `frame`, `value_name`.", "question_id": 45594}
{"snippet": "pandas.melt(frame)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `frame`.", "question_id": 45595}
{"snippet": "pandas.melt(frame, id_vars=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 . With arguments `frame`.", "question_id": 45596}
{"snippet": "pandas.melt(frame, value_vars=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 . With arguments `frame`.", "question_id": 45597}
{"snippet": "pandas.melt(frame, var_name=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `frame`, `var_name`.", "question_id": 45598}
{"snippet": "pandas.melt(frame, value_name='value')", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `frame`, `value_name`.", "question_id": 45599}
{"snippet": "pandas.melt(frame, col_level=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `frame`, `col_level`.", "question_id": 45600}
{"snippet": "pandas.melt(frame, ignore_index=True)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . With arguments `frame`, `ignore_index`.", "question_id": 45601}
{"snippet": "pandas.melt(frame, id_vars=None, value_vars=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 . With arguments `frame`.", "question_id": 45602}
{"snippet": "pandas.melt(frame, id_vars=None, var_name=None)", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 . With arguments `frame`, `var_name`.", "question_id": 45603}
{"snippet": "pandas.melt(frame, id_vars=None, value_name='value')", "intent": "Unpivot a DataFrame from wide to long format , optionally leaving identifiers set . This function is useful to massage a DataFrame into a format where one or more columns are identifier variables ( `id_vars` ) , while all other columns , considered measured variables ( `value_vars` ) , are \u201c unpivoted \u201d to the row axis , leaving just two non-identifier columns , \u2018 variable \u2019 and \u2018 value \u2019 . With arguments `frame`, `value_name`.", "question_id": 45604}
{"snippet": "pandas.merge(left, right, '_y'))", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . With arguments `'_y')`.", "question_id": 45605}
{"snippet": "pandas.merge(left, right, '_y'), how='inner')", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `how`.", "question_id": 45606}
{"snippet": "pandas.merge(left, right, '_y'), on=None)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . The join is done `on` columns or indexes . With arguments `'_y')`.", "question_id": 45607}
{"snippet": "pandas.merge(left, right, '_y'), left_on=None)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . Support for specifying index levels as the on , `left_on` , and `right_on` parameters was added in version 0.23.0 Support for merging named Series objects was added in version 0.24.0 With arguments `'_y')`.", "question_id": 45608}
{"snippet": "pandas.merge(left, right, '_y'), right_on=None)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . Support for specifying index levels as the on , `left_on` , and `right_on` parameters was added in version 0.23.0 Support for merging named Series objects was added in version 0.24.0 With arguments `'_y')`.", "question_id": 45609}
{"snippet": "pandas.merge(left, right, '_y'), left_index=False)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `left_index`.", "question_id": 45610}
{"snippet": "pandas.merge(left, right, '_y'), right_index=False)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `right_index`.", "question_id": 45611}
{"snippet": "pandas.merge(left, right, '_y'), sort=False)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `sort`.", "question_id": 45612}
{"snippet": "pandas.merge(left, right, '_y'), suffixes=('_x')", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . The value columns have the default `suffixes` , _x and _y , appended . With arguments `'_y')`.", "question_id": 45613}
{"snippet": "pandas.merge(left, right, '_y'), copy=True)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `copy`.", "question_id": 45614}
{"snippet": "pandas.merge(left, right, '_y'))", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . With arguments `'_y')`.", "question_id": 45615}
{"snippet": "pandas.merge(left, right, '_y'), how='inner')", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `how`.", "question_id": 45616}
{"snippet": "pandas.merge(left, right, '_y'), on=None)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . The join is done `on` columns or indexes . With arguments `'_y')`.", "question_id": 45617}
{"snippet": "pandas.merge(left, right, '_y'), left_on=None)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . Support for specifying index levels as the on , `left_on` , and `right_on` parameters was added in version 0.23.0 Support for merging named Series objects was added in version 0.24.0 With arguments `'_y')`.", "question_id": 45618}
{"snippet": "pandas.merge(left, right, '_y'), right_on=None)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . Support for specifying index levels as the on , `left_on` , and `right_on` parameters was added in version 0.23.0 Support for merging named Series objects was added in version 0.24.0 With arguments `'_y')`.", "question_id": 45619}
{"snippet": "pandas.merge(left, right, '_y'), left_index=False)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `left_index`.", "question_id": 45620}
{"snippet": "pandas.merge(left, right, '_y'), right_index=False)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `right_index`.", "question_id": 45621}
{"snippet": "pandas.merge(left, right, '_y'), sort=False)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `sort`.", "question_id": 45622}
{"snippet": "pandas.merge(left, right, '_y'), suffixes=('_x')", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . The value columns have the default `suffixes` , _x and _y , appended . With arguments `'_y')`.", "question_id": 45623}
{"snippet": "pandas.merge(left, right, '_y'), copy=True)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `copy`.", "question_id": 45624}
{"snippet": "pandas.merge(left, right, '_y'))", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . With arguments `'_y')`.", "question_id": 45625}
{"snippet": "pandas.merge(left, right, '_y'), how='inner')", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `how`.", "question_id": 45626}
{"snippet": "pandas.merge(left, right, '_y'), on=None)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . The join is done `on` columns or indexes . With arguments `'_y')`.", "question_id": 45627}
{"snippet": "pandas.merge(left, right, '_y'), left_on=None)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . Support for specifying index levels as the on , `left_on` , and `right_on` parameters was added in version 0.23.0 Support for merging named Series objects was added in version 0.24.0 With arguments `'_y')`.", "question_id": 45628}
{"snippet": "pandas.merge(left, right, '_y'), right_on=None)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . Support for specifying index levels as the on , `left_on` , and `right_on` parameters was added in version 0.23.0 Support for merging named Series objects was added in version 0.24.0 With arguments `'_y')`.", "question_id": 45629}
{"snippet": "pandas.merge(left, right, '_y'), left_index=False)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `left_index`.", "question_id": 45630}
{"snippet": "pandas.merge(left, right, '_y'), right_index=False)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `right_index`.", "question_id": 45631}
{"snippet": "pandas.merge(left, right, '_y'), sort=False)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `sort`.", "question_id": 45632}
{"snippet": "pandas.merge(left, right, '_y'), suffixes=('_x')", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . The value columns have the default `suffixes` , _x and _y , appended . With arguments `'_y')`.", "question_id": 45633}
{"snippet": "pandas.merge(left, right, '_y'), copy=True)", "intent": "Merge DataFrame or named Series objects with a database-style join . Merge DataFrames df1 and df2 with specified `left` and `right` suffixes appended to any overlapping columns . With arguments `'_y')`, `copy`.", "question_id": 45634}
{"snippet": "pandas.merge_asof(left, right, '_y'))", "intent": "Perform an asof merge . For each row in the `left` DataFrame : With arguments `right`, `'_y')`.", "question_id": 45635}
{"snippet": "pandas.merge_asof(left, right, '_y'), on=None)", "intent": "Perform an asof merge . For each row in the `left` DataFrame : This is similar to a left-join except that we match `on` nearest key rather than equal keys . With arguments `right`, `'_y')`.", "question_id": 45636}
{"snippet": "pandas.merge_asof(left, right, '_y'), left_on=None)", "intent": "Perform an asof merge . For each row in the `left` DataFrame : With arguments `right`, `'_y')`, `left_on`.", "question_id": 45637}
{"snippet": "pandas.merge_asof(left, right, '_y'), right_on=None)", "intent": "Perform an asof merge . For each row in the `left` DataFrame : With arguments `right`, `'_y')`, `right_on`.", "question_id": 45638}
{"snippet": "pandas.merge_asof(left, right, '_y'), left_index=False)", "intent": "Perform an asof merge . For each row in the `left` DataFrame : With arguments `right`, `'_y')`, `left_index`.", "question_id": 45639}
{"snippet": "pandas.merge_asof(left, right, '_y'), right_index=False)", "intent": "Perform an asof merge . For each row in the `left` DataFrame : With arguments `right`, `'_y')`, `right_index`.", "question_id": 45640}
{"snippet": "pandas.merge_asof(left, right, '_y'), by=None)", "intent": "Perform an asof merge . For each row in the `left` DataFrame : Both DataFrames must be sorted `by` the key . With arguments `right`, `'_y')`.", "question_id": 45641}
{"snippet": "pandas.merge_asof(left, right, '_y'), left_by=None)", "intent": "Perform an asof merge . For each row in the `left` DataFrame : With arguments `right`, `'_y')`, `left_by`.", "question_id": 45642}
{"snippet": "pandas.merge_asof(left, right, '_y'), right_by=None)", "intent": "Perform an asof merge . For each row in the `left` DataFrame : With arguments `right`, `'_y')`, `right_by`.", "question_id": 45643}
{"snippet": "pandas.merge_asof(left, right, '_y'), suffixes=('_x')", "intent": "Perform an asof merge . For each row in the `left` DataFrame : With arguments `right`, `'_y')`, `suffixes`.", "question_id": 45644}
{"snippet": "pandas.merge_asof(left, right, '_y'))", "intent": "Perform an asof merge . For each row in the `left` DataFrame : With arguments `right`, `'_y')`.", "question_id": 45645}
{"snippet": "pandas.merge_asof(left, right, '_y'), on=None)", "intent": "Perform an asof merge . For each row in the `left` DataFrame : This is similar to a left-join except that we match `on` nearest key rather than equal keys . With arguments `right`, `'_y')`.", "question_id": 45646}
{"snippet": "pandas.merge_asof(left, right, '_y'), left_on=None)", "intent": "Perform an asof merge . For each row in the `left` DataFrame : With arguments `right`, `'_y')`, `left_on`.", "question_id": 45647}
{"snippet": "pandas.merge_asof(left, right, '_y'), right_on=None)", "intent": "Perform an asof merge . For each row in the `left` DataFrame : With arguments `right`, `'_y')`, `right_on`.", "question_id": 45648}
{"snippet": "pandas.merge_asof(left, right, '_y'), left_index=False)", "intent": "Perform an asof merge . For each row in the `left` DataFrame : With arguments `right`, `'_y')`, `left_index`.", "question_id": 45649}
{"snippet": "pandas.merge_asof(left, right, '_y'), right_index=False)", "intent": "Perform an asof merge . For each row in the `left` DataFrame : With arguments `right`, `'_y')`, `right_index`.", "question_id": 45650}
{"snippet": "pandas.merge_asof(left, right, '_y'), by=None)", "intent": "Perform an asof merge . For each row in the `left` DataFrame : Both DataFrames must be sorted `by` the key . With arguments `right`, `'_y')`.", "question_id": 45651}
{"snippet": "pandas.merge_asof(left, right, '_y'), left_by=None)", "intent": "Perform an asof merge . For each row in the `left` DataFrame : With arguments `right`, `'_y')`, `left_by`.", "question_id": 45652}
{"snippet": "pandas.merge_asof(left, right, '_y'), right_by=None)", "intent": "Perform an asof merge . For each row in the `left` DataFrame : With arguments `right`, `'_y')`, `right_by`.", "question_id": 45653}
{"snippet": "pandas.merge_asof(left, right, '_y'), suffixes=('_x')", "intent": "Perform an asof merge . For each row in the `left` DataFrame : With arguments `right`, `'_y')`, `suffixes`.", "question_id": 45654}
{"snippet": "pandas.merge_asof(left, right, '_y'))", "intent": "Perform an asof merge . For each row in the `left` DataFrame : With arguments `right`, `'_y')`.", "question_id": 45655}
{"snippet": "pandas.merge_asof(left, right, '_y'), on=None)", "intent": "Perform an asof merge . For each row in the `left` DataFrame : This is similar to a left-join except that we match `on` nearest key rather than equal keys . With arguments `right`, `'_y')`.", "question_id": 45656}
{"snippet": "pandas.merge_asof(left, right, '_y'), left_on=None)", "intent": "Perform an asof merge . For each row in the `left` DataFrame : With arguments `right`, `'_y')`, `left_on`.", "question_id": 45657}
{"snippet": "pandas.merge_asof(left, right, '_y'), right_on=None)", "intent": "Perform an asof merge . For each row in the `left` DataFrame : With arguments `right`, `'_y')`, `right_on`.", "question_id": 45658}
{"snippet": "pandas.merge_asof(left, right, '_y'), left_index=False)", "intent": "Perform an asof merge . For each row in the `left` DataFrame : With arguments `right`, `'_y')`, `left_index`.", "question_id": 45659}
{"snippet": "pandas.merge_asof(left, right, '_y'), right_index=False)", "intent": "Perform an asof merge . For each row in the `left` DataFrame : With arguments `right`, `'_y')`, `right_index`.", "question_id": 45660}
{"snippet": "pandas.merge_asof(left, right, '_y'), by=None)", "intent": "Perform an asof merge . For each row in the `left` DataFrame : Both DataFrames must be sorted `by` the key . With arguments `right`, `'_y')`.", "question_id": 45661}
{"snippet": "pandas.merge_asof(left, right, '_y'), left_by=None)", "intent": "Perform an asof merge . For each row in the `left` DataFrame : With arguments `right`, `'_y')`, `left_by`.", "question_id": 45662}
{"snippet": "pandas.merge_asof(left, right, '_y'), right_by=None)", "intent": "Perform an asof merge . For each row in the `left` DataFrame : With arguments `right`, `'_y')`, `right_by`.", "question_id": 45663}
{"snippet": "pandas.merge_asof(left, right, '_y'), suffixes=('_x')", "intent": "Perform an asof merge . For each row in the `left` DataFrame : With arguments `right`, `'_y')`, `suffixes`.", "question_id": 45664}
{"snippet": "pandas.merge_ordered(left, right, '_y'))", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`.", "question_id": 45665}
{"snippet": "pandas.merge_ordered(left, right, '_y'), on=None)", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `on`.", "question_id": 45666}
{"snippet": "pandas.merge_ordered(left, right, '_y'), left_on=None)", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `left_on`.", "question_id": 45667}
{"snippet": "pandas.merge_ordered(left, right, '_y'), right_on=None)", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `right_on`.", "question_id": 45668}
{"snippet": "pandas.merge_ordered(left, right, '_y'), left_by=None)", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `left_by`.", "question_id": 45669}
{"snippet": "pandas.merge_ordered(left, right, '_y'), right_by=None)", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `right_by`.", "question_id": 45670}
{"snippet": "pandas.merge_ordered(left, right, '_y'), fill_method=None)", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `fill_method`.", "question_id": 45671}
{"snippet": "pandas.merge_ordered(left, right, '_y'), suffixes=('_x')", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `suffixes`.", "question_id": 45672}
{"snippet": "pandas.merge_ordered(left, right, '_y'), how='outer')", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `how`.", "question_id": 45673}
{"snippet": "pandas.merge_ordered(left, right, '_y'), on=None, left_on=None)", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `on`, `left_on`.", "question_id": 45674}
{"snippet": "pandas.merge_ordered(left, right, '_y'))", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`.", "question_id": 45675}
{"snippet": "pandas.merge_ordered(left, right, '_y'), on=None)", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `on`.", "question_id": 45676}
{"snippet": "pandas.merge_ordered(left, right, '_y'), left_on=None)", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `left_on`.", "question_id": 45677}
{"snippet": "pandas.merge_ordered(left, right, '_y'), right_on=None)", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `right_on`.", "question_id": 45678}
{"snippet": "pandas.merge_ordered(left, right, '_y'), left_by=None)", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `left_by`.", "question_id": 45679}
{"snippet": "pandas.merge_ordered(left, right, '_y'), right_by=None)", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `right_by`.", "question_id": 45680}
{"snippet": "pandas.merge_ordered(left, right, '_y'), fill_method=None)", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `fill_method`.", "question_id": 45681}
{"snippet": "pandas.merge_ordered(left, right, '_y'), suffixes=('_x')", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `suffixes`.", "question_id": 45682}
{"snippet": "pandas.merge_ordered(left, right, '_y'), how='outer')", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `how`.", "question_id": 45683}
{"snippet": "pandas.merge_ordered(left, right, '_y'), on=None, left_on=None)", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `on`, `left_on`.", "question_id": 45684}
{"snippet": "pandas.merge_ordered(left, right, '_y'))", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`.", "question_id": 45685}
{"snippet": "pandas.merge_ordered(left, right, '_y'), on=None)", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `on`.", "question_id": 45686}
{"snippet": "pandas.merge_ordered(left, right, '_y'), left_on=None)", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `left_on`.", "question_id": 45687}
{"snippet": "pandas.merge_ordered(left, right, '_y'), right_on=None)", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `right_on`.", "question_id": 45688}
{"snippet": "pandas.merge_ordered(left, right, '_y'), left_by=None)", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `left_by`.", "question_id": 45689}
{"snippet": "pandas.merge_ordered(left, right, '_y'), right_by=None)", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `right_by`.", "question_id": 45690}
{"snippet": "pandas.merge_ordered(left, right, '_y'), fill_method=None)", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `fill_method`.", "question_id": 45691}
{"snippet": "pandas.merge_ordered(left, right, '_y'), suffixes=('_x')", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `suffixes`.", "question_id": 45692}
{"snippet": "pandas.merge_ordered(left, right, '_y'), how='outer')", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `how`.", "question_id": 45693}
{"snippet": "pandas.merge_ordered(left, right, '_y'), on=None, left_on=None)", "intent": "Perform merge with optional filling/interpolation . With arguments `left`, `right`, `'_y')`, `on`, `left_on`.", "question_id": 45694}
{"snippet": "pandas.notna(obj)", "intent": "Detect non-missing values for an array-like object . With arguments `obj`.", "question_id": 45695}
{"snippet": "pandas.notna(obj)", "intent": "Detect non-missing values for an array-like object . With arguments `obj`.", "question_id": 45696}
{"snippet": "pandas.notna(obj)", "intent": "Detect non-missing values for an array-like object . With arguments `obj`.", "question_id": 45697}
{"snippet": "pandas.notnull(obj)", "intent": "Detect non-missing values for an array-like object . With arguments `obj`.", "question_id": 45698}
{"snippet": "pandas.notnull(obj)", "intent": "Detect non-missing values for an array-like object . With arguments `obj`.", "question_id": 45699}
{"snippet": "pandas.notnull(obj)", "intent": "Detect non-missing values for an array-like object . With arguments `obj`.", "question_id": 45700}
{"snippet": "option_context.__call__(func)", "intent": "Call self as a function . With arguments `func`.", "question_id": 45701}
{"snippet": "option_context.__call__(func)", "intent": "Call self as a function . With arguments `func`.", "question_id": 45702}
{"snippet": "option_context.__call__(func)", "intent": "Call self as a function . With arguments `func`.", "question_id": 45703}
{"snippet": "pandas.option_context(*args)", "intent": "Context manager to temporarily set options in the with statement context . With arguments `*args`.", "question_id": 45704}
{"snippet": "pandas.option_context(*args)", "intent": "Context manager to temporarily set options in the with statement context . With arguments `*args`.", "question_id": 45705}
{"snippet": "pandas.option_context(*args)", "intent": "Context manager to temporarily set options in the with statement context . With arguments `*args`.", "question_id": 45706}
{"snippet": "pandas.period_range()", "intent": "Return a fixed frequency PeriodIndex .", "question_id": 45707}
{"snippet": "pandas.period_range(start=None)", "intent": "Return a fixed frequency PeriodIndex . Of the three parameters : `start` , `end` , and `periods` , exactly two must be specified .", "question_id": 45708}
{"snippet": "pandas.period_range(end=None)", "intent": "Return a fixed frequency PeriodIndex . Of the three parameters : `start` , `end` , and `periods` , exactly two must be specified .", "question_id": 45709}
{"snippet": "pandas.period_range(periods=None)", "intent": "Return a fixed frequency PeriodIndex . Of the three parameters : `start` , `end` , and `periods` , exactly two must be specified .", "question_id": 45710}
{"snippet": "pandas.period_range(freq=None)", "intent": "Return a fixed frequency PeriodIndex . With arguments `freq`.", "question_id": 45711}
{"snippet": "pandas.period_range(name=None)", "intent": "Return a fixed frequency PeriodIndex . With arguments `name`.", "question_id": 45712}
{"snippet": "pandas.period_range(start=None, end=None)", "intent": "Return a fixed frequency PeriodIndex . Of the three parameters : `start` , `end` , and `periods` , exactly two must be specified .", "question_id": 45713}
{"snippet": "pandas.period_range(start=None, periods=None)", "intent": "Return a fixed frequency PeriodIndex . Of the three parameters : `start` , `end` , and `periods` , exactly two must be specified .", "question_id": 45714}
{"snippet": "pandas.period_range(start=None, freq=None)", "intent": "Return a fixed frequency PeriodIndex . Of the three parameters : `start` , `end` , and `periods` , exactly two must be specified . With arguments `freq`.", "question_id": 45715}
{"snippet": "pandas.period_range(start=None, name=None)", "intent": "Return a fixed frequency PeriodIndex . Of the three parameters : `start` , `end` , and `periods` , exactly two must be specified . With arguments `name`.", "question_id": 45716}
{"snippet": "pandas.period_range()", "intent": "Return a fixed frequency PeriodIndex .", "question_id": 45717}
{"snippet": "pandas.period_range(start=None)", "intent": "Return a fixed frequency PeriodIndex . Of the three parameters : `start` , `end` , and `periods` , exactly two must be specified .", "question_id": 45718}
{"snippet": "pandas.period_range(end=None)", "intent": "Return a fixed frequency PeriodIndex . Of the three parameters : `start` , `end` , and `periods` , exactly two must be specified .", "question_id": 45719}
{"snippet": "pandas.period_range(periods=None)", "intent": "Return a fixed frequency PeriodIndex . Of the three parameters : `start` , `end` , and `periods` , exactly two must be specified .", "question_id": 45720}
{"snippet": "pandas.period_range(freq=None)", "intent": "Return a fixed frequency PeriodIndex . With arguments `freq`.", "question_id": 45721}
{"snippet": "pandas.period_range(name=None)", "intent": "Return a fixed frequency PeriodIndex . With arguments `name`.", "question_id": 45722}
{"snippet": "pandas.period_range(start=None, end=None)", "intent": "Return a fixed frequency PeriodIndex . Of the three parameters : `start` , `end` , and `periods` , exactly two must be specified .", "question_id": 45723}
{"snippet": "pandas.period_range(start=None, periods=None)", "intent": "Return a fixed frequency PeriodIndex . Of the three parameters : `start` , `end` , and `periods` , exactly two must be specified .", "question_id": 45724}
{"snippet": "pandas.period_range(start=None, freq=None)", "intent": "Return a fixed frequency PeriodIndex . Of the three parameters : `start` , `end` , and `periods` , exactly two must be specified . With arguments `freq`.", "question_id": 45725}
{"snippet": "pandas.period_range(start=None, name=None)", "intent": "Return a fixed frequency PeriodIndex . Of the three parameters : `start` , `end` , and `periods` , exactly two must be specified . With arguments `name`.", "question_id": 45726}
{"snippet": "pandas.period_range()", "intent": "Return a fixed frequency PeriodIndex .", "question_id": 45727}
{"snippet": "pandas.period_range(start=None)", "intent": "Return a fixed frequency PeriodIndex . Of the three parameters : `start` , `end` , and `periods` , exactly two must be specified .", "question_id": 45728}
{"snippet": "pandas.period_range(end=None)", "intent": "Return a fixed frequency PeriodIndex . Of the three parameters : `start` , `end` , and `periods` , exactly two must be specified .", "question_id": 45729}
{"snippet": "pandas.period_range(periods=None)", "intent": "Return a fixed frequency PeriodIndex . Of the three parameters : `start` , `end` , and `periods` , exactly two must be specified .", "question_id": 45730}
{"snippet": "pandas.period_range(freq=None)", "intent": "Return a fixed frequency PeriodIndex . With arguments `freq`.", "question_id": 45731}
{"snippet": "pandas.period_range(name=None)", "intent": "Return a fixed frequency PeriodIndex . With arguments `name`.", "question_id": 45732}
{"snippet": "pandas.period_range(start=None, end=None)", "intent": "Return a fixed frequency PeriodIndex . Of the three parameters : `start` , `end` , and `periods` , exactly two must be specified .", "question_id": 45733}
{"snippet": "pandas.period_range(start=None, periods=None)", "intent": "Return a fixed frequency PeriodIndex . Of the three parameters : `start` , `end` , and `periods` , exactly two must be specified .", "question_id": 45734}
{"snippet": "pandas.period_range(start=None, freq=None)", "intent": "Return a fixed frequency PeriodIndex . Of the three parameters : `start` , `end` , and `periods` , exactly two must be specified . With arguments `freq`.", "question_id": 45735}
{"snippet": "pandas.period_range(start=None, name=None)", "intent": "Return a fixed frequency PeriodIndex . Of the three parameters : `start` , `end` , and `periods` , exactly two must be specified . With arguments `name`.", "question_id": 45736}
{"snippet": "pandas.pivot(data)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Reshape `data` ( produce a \u201c pivot \u201d table ) based on column values .", "question_id": 45737}
{"snippet": "pandas.pivot(data, index=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Reshape `data` ( produce a \u201c pivot \u201d table ) based on column values .", "question_id": 45738}
{"snippet": "pandas.pivot(data, columns=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Reshape `data` ( produce a \u201c pivot \u201d table ) based on column values . Uses unique values from specified index / `columns` to form axes of the resulting DataFrame .", "question_id": 45739}
{"snippet": "pandas.pivot(data, values=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Reshape `data` ( produce a \u201c pivot \u201d table ) based on column values .", "question_id": 45740}
{"snippet": "pandas.pivot(data, index=None, columns=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Reshape `data` ( produce a \u201c pivot \u201d table ) based on column values . Uses unique values from specified index / `columns` to form axes of the resulting DataFrame .", "question_id": 45741}
{"snippet": "pandas.pivot(data, index=None, values=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Reshape `data` ( produce a \u201c pivot \u201d table ) based on column values .", "question_id": 45742}
{"snippet": "pandas.pivot(data, columns=None, values=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Reshape `data` ( produce a \u201c pivot \u201d table ) based on column values . Uses unique values from specified index / `columns` to form axes of the resulting DataFrame .", "question_id": 45743}
{"snippet": "pandas.pivot(data, index=None, columns=None, values=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Reshape `data` ( produce a \u201c pivot \u201d table ) based on column values . Uses unique values from specified index / `columns` to form axes of the resulting DataFrame .", "question_id": 45744}
{"snippet": "pandas.pivot(data)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Reshape `data` ( produce a \u201c pivot \u201d table ) based on column values .", "question_id": 45745}
{"snippet": "pandas.pivot(data, index=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Reshape `data` ( produce a \u201c pivot \u201d table ) based on column values .", "question_id": 45746}
{"snippet": "pandas.pivot(data, columns=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Reshape `data` ( produce a \u201c pivot \u201d table ) based on column values . Uses unique values from specified index / `columns` to form axes of the resulting DataFrame .", "question_id": 45747}
{"snippet": "pandas.pivot(data, values=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Reshape `data` ( produce a \u201c pivot \u201d table ) based on column values .", "question_id": 45748}
{"snippet": "pandas.pivot(data, index=None, columns=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Reshape `data` ( produce a \u201c pivot \u201d table ) based on column values . Uses unique values from specified index / `columns` to form axes of the resulting DataFrame .", "question_id": 45749}
{"snippet": "pandas.pivot(data, index=None, values=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Reshape `data` ( produce a \u201c pivot \u201d table ) based on column values .", "question_id": 45750}
{"snippet": "pandas.pivot(data, columns=None, values=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Reshape `data` ( produce a \u201c pivot \u201d table ) based on column values . Uses unique values from specified index / `columns` to form axes of the resulting DataFrame .", "question_id": 45751}
{"snippet": "pandas.pivot(data, index=None, columns=None, values=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Reshape `data` ( produce a \u201c pivot \u201d table ) based on column values . Uses unique values from specified index / `columns` to form axes of the resulting DataFrame .", "question_id": 45752}
{"snippet": "pandas.pivot(data)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Reshape `data` ( produce a \u201c pivot \u201d table ) based on column values .", "question_id": 45753}
{"snippet": "pandas.pivot(data, index=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Reshape `data` ( produce a \u201c pivot \u201d table ) based on column values .", "question_id": 45754}
{"snippet": "pandas.pivot(data, columns=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Reshape `data` ( produce a \u201c pivot \u201d table ) based on column values . Uses unique values from specified index / `columns` to form axes of the resulting DataFrame .", "question_id": 45755}
{"snippet": "pandas.pivot(data, values=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Reshape `data` ( produce a \u201c pivot \u201d table ) based on column values .", "question_id": 45756}
{"snippet": "pandas.pivot(data, index=None, columns=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Reshape `data` ( produce a \u201c pivot \u201d table ) based on column values . Uses unique values from specified index / `columns` to form axes of the resulting DataFrame .", "question_id": 45757}
{"snippet": "pandas.pivot(data, index=None, values=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Reshape `data` ( produce a \u201c pivot \u201d table ) based on column values .", "question_id": 45758}
{"snippet": "pandas.pivot(data, columns=None, values=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Reshape `data` ( produce a \u201c pivot \u201d table ) based on column values . Uses unique values from specified index / `columns` to form axes of the resulting DataFrame .", "question_id": 45759}
{"snippet": "pandas.pivot(data, index=None, columns=None, values=None)", "intent": "Return reshaped DataFrame organized by given `index` / column `values` . Reshape `data` ( produce a \u201c pivot \u201d table ) based on column values . Uses unique values from specified index / `columns` to form axes of the resulting DataFrame .", "question_id": 45760}
{"snippet": "pandas.pivot_table(data)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `data`.", "question_id": 45761}
{"snippet": "pandas.pivot_table(data, values=None)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . This first example aggregates `values` by taking the sum . With arguments `data`.", "question_id": 45762}
{"snippet": "pandas.pivot_table(data, index=None)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . The levels in the pivot table will be stored in MultiIndex objects ( hierarchical indexes ) on the `index` and `columns` of the result DataFrame . With arguments `data`.", "question_id": 45763}
{"snippet": "pandas.pivot_table(data, columns=None)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . The levels in the pivot table will be stored in MultiIndex objects ( hierarchical indexes ) on the `index` and `columns` of the result DataFrame . With arguments `data`.", "question_id": 45764}
{"snippet": "pandas.pivot_table(data, aggfunc='mean')", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `data`, `aggfunc`.", "question_id": 45765}
{"snippet": "pandas.pivot_table(data, fill_value=None)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . We can also fill missing values using the `fill_value` parameter . With arguments `data`.", "question_id": 45766}
{"snippet": "pandas.pivot_table(data, margins=False)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `data`, `margins`.", "question_id": 45767}
{"snippet": "pandas.pivot_table(data, dropna=True)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `data`, `dropna`.", "question_id": 45768}
{"snippet": "pandas.pivot_table(data, margins_name='All')", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `data`, `margins_name`.", "question_id": 45769}
{"snippet": "pandas.pivot_table(data, observed=False)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `data`, `observed`.", "question_id": 45770}
{"snippet": "pandas.pivot_table(data)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `data`.", "question_id": 45771}
{"snippet": "pandas.pivot_table(data, values=None)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . This first example aggregates `values` by taking the sum . With arguments `data`.", "question_id": 45772}
{"snippet": "pandas.pivot_table(data, index=None)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . The levels in the pivot table will be stored in MultiIndex objects ( hierarchical indexes ) on the `index` and `columns` of the result DataFrame . With arguments `data`.", "question_id": 45773}
{"snippet": "pandas.pivot_table(data, columns=None)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . The levels in the pivot table will be stored in MultiIndex objects ( hierarchical indexes ) on the `index` and `columns` of the result DataFrame . With arguments `data`.", "question_id": 45774}
{"snippet": "pandas.pivot_table(data, aggfunc='mean')", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `data`, `aggfunc`.", "question_id": 45775}
{"snippet": "pandas.pivot_table(data, fill_value=None)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . We can also fill missing values using the `fill_value` parameter . With arguments `data`.", "question_id": 45776}
{"snippet": "pandas.pivot_table(data, margins=False)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `data`, `margins`.", "question_id": 45777}
{"snippet": "pandas.pivot_table(data, dropna=True)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `data`, `dropna`.", "question_id": 45778}
{"snippet": "pandas.pivot_table(data, margins_name='All')", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `data`, `margins_name`.", "question_id": 45779}
{"snippet": "pandas.pivot_table(data, observed=False)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `data`, `observed`.", "question_id": 45780}
{"snippet": "pandas.pivot_table(data)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `data`.", "question_id": 45781}
{"snippet": "pandas.pivot_table(data, values=None)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . This first example aggregates `values` by taking the sum . With arguments `data`.", "question_id": 45782}
{"snippet": "pandas.pivot_table(data, index=None)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . The levels in the pivot table will be stored in MultiIndex objects ( hierarchical indexes ) on the `index` and `columns` of the result DataFrame . With arguments `data`.", "question_id": 45783}
{"snippet": "pandas.pivot_table(data, columns=None)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . The levels in the pivot table will be stored in MultiIndex objects ( hierarchical indexes ) on the `index` and `columns` of the result DataFrame . With arguments `data`.", "question_id": 45784}
{"snippet": "pandas.pivot_table(data, aggfunc='mean')", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `data`, `aggfunc`.", "question_id": 45785}
{"snippet": "pandas.pivot_table(data, fill_value=None)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . We can also fill missing values using the `fill_value` parameter . With arguments `data`.", "question_id": 45786}
{"snippet": "pandas.pivot_table(data, margins=False)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `data`, `margins`.", "question_id": 45787}
{"snippet": "pandas.pivot_table(data, dropna=True)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `data`, `dropna`.", "question_id": 45788}
{"snippet": "pandas.pivot_table(data, margins_name='All')", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `data`, `margins_name`.", "question_id": 45789}
{"snippet": "pandas.pivot_table(data, observed=False)", "intent": "Create a spreadsheet-style pivot table as a DataFrame . With arguments `data`, `observed`.", "question_id": 45790}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`.", "question_id": 45791}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, ax=None)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `ax`.", "question_id": 45792}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, samples=200)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `samples`.", "question_id": 45793}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, color=None)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `color`.", "question_id": 45794}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, colormap=None)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `colormap`.", "question_id": 45795}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, ax=None, samples=200)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `ax`, `samples`.", "question_id": 45796}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, ax=None, color=None)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `ax`, `color`.", "question_id": 45797}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, ax=None, colormap=None)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `ax`, `colormap`.", "question_id": 45798}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, samples=200, color=None)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `samples`, `color`.", "question_id": 45799}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, samples=200, colormap=None)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `samples`, `colormap`.", "question_id": 45800}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`.", "question_id": 45801}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, ax=None)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `ax`.", "question_id": 45802}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, samples=200)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `samples`.", "question_id": 45803}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, color=None)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `color`.", "question_id": 45804}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, colormap=None)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `colormap`.", "question_id": 45805}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, ax=None, samples=200)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `ax`, `samples`.", "question_id": 45806}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, ax=None, color=None)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `ax`, `color`.", "question_id": 45807}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, ax=None, colormap=None)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `ax`, `colormap`.", "question_id": 45808}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, samples=200, color=None)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `samples`, `color`.", "question_id": 45809}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, samples=200, colormap=None)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `samples`, `colormap`.", "question_id": 45810}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`.", "question_id": 45811}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, ax=None)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `ax`.", "question_id": 45812}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, samples=200)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `samples`.", "question_id": 45813}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, color=None)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `color`.", "question_id": 45814}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, colormap=None)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `colormap`.", "question_id": 45815}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, ax=None, samples=200)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `ax`, `samples`.", "question_id": 45816}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, ax=None, color=None)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `ax`, `color`.", "question_id": 45817}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, ax=None, colormap=None)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `ax`, `colormap`.", "question_id": 45818}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, samples=200, color=None)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `samples`, `color`.", "question_id": 45819}
{"snippet": "pandas.plotting.andrews_curves(frame, class_column, **kwargs, samples=200, colormap=None)", "intent": "Generate a matplotlib plot of Andrews curves , for visualising clusters of multivariate data . Each row of `frame` then corresponds to a single curve . With arguments `class_column`, `**kwargs`, `samples`, `colormap`.", "question_id": 45820}
{"snippet": "pandas.plotting.autocorrelation_plot(series, **kwargs)", "intent": "Autocorrelation plot for time `series` . With arguments `**kwargs`.", "question_id": 45821}
{"snippet": "pandas.plotting.autocorrelation_plot(series, **kwargs, ax=None)", "intent": "Autocorrelation plot for time `series` . With arguments `**kwargs`, `ax`.", "question_id": 45822}
{"snippet": "pandas.plotting.autocorrelation_plot(series, **kwargs)", "intent": "Autocorrelation plot for time `series` . With arguments `**kwargs`.", "question_id": 45823}
{"snippet": "pandas.plotting.autocorrelation_plot(series, **kwargs, ax=None)", "intent": "Autocorrelation plot for time `series` . With arguments `**kwargs`, `ax`.", "question_id": 45824}
{"snippet": "pandas.plotting.autocorrelation_plot(series, **kwargs)", "intent": "Autocorrelation plot for time `series` . With arguments `**kwargs`.", "question_id": 45825}
{"snippet": "pandas.plotting.autocorrelation_plot(series, **kwargs, ax=None)", "intent": "Autocorrelation plot for time `series` . With arguments `**kwargs`, `ax`.", "question_id": 45826}
{"snippet": "pandas.plotting.bootstrap_plot(series, **kwds)", "intent": "Bootstrap plot on mean , median and mid-range statistics . With arguments `series`, `**kwds`.", "question_id": 45827}
{"snippet": "pandas.plotting.bootstrap_plot(series, **kwds, fig=None)", "intent": "Bootstrap plot on mean , median and mid-range statistics . With arguments `series`, `**kwds`, `fig`.", "question_id": 45828}
{"snippet": "pandas.plotting.bootstrap_plot(series, **kwds, size=50)", "intent": "Bootstrap plot on mean , median and mid-range statistics . This function will generate bootstrapping plots for mean , median and mid-range statistics for the given number of `samples` of the given `size` . With arguments `series`, `**kwds`.", "question_id": 45829}
{"snippet": "pandas.plotting.bootstrap_plot(series, **kwds, samples=500)", "intent": "Bootstrap plot on mean , median and mid-range statistics . This function will generate bootstrapping plots for mean , median and mid-range statistics for the given number of `samples` of the given `size` . With arguments `series`, `**kwds`.", "question_id": 45830}
{"snippet": "pandas.plotting.bootstrap_plot(series, **kwds, fig=None, size=50)", "intent": "Bootstrap plot on mean , median and mid-range statistics . This function will generate bootstrapping plots for mean , median and mid-range statistics for the given number of `samples` of the given `size` . With arguments `series`, `**kwds`, `fig`.", "question_id": 45831}
{"snippet": "pandas.plotting.bootstrap_plot(series, **kwds, fig=None, samples=500)", "intent": "Bootstrap plot on mean , median and mid-range statistics . This function will generate bootstrapping plots for mean , median and mid-range statistics for the given number of `samples` of the given `size` . With arguments `series`, `**kwds`, `fig`.", "question_id": 45832}
{"snippet": "pandas.plotting.bootstrap_plot(series, **kwds, size=50, samples=500)", "intent": "Bootstrap plot on mean , median and mid-range statistics . This function will generate bootstrapping plots for mean , median and mid-range statistics for the given number of `samples` of the given `size` . With arguments `series`, `**kwds`.", "question_id": 45833}
{"snippet": "pandas.plotting.bootstrap_plot(series, **kwds, fig=None, size=50, samples=500)", "intent": "Bootstrap plot on mean , median and mid-range statistics . This function will generate bootstrapping plots for mean , median and mid-range statistics for the given number of `samples` of the given `size` . With arguments `series`, `**kwds`, `fig`.", "question_id": 45834}
{"snippet": "pandas.plotting.bootstrap_plot(series, **kwds)", "intent": "Bootstrap plot on mean , median and mid-range statistics . With arguments `series`, `**kwds`.", "question_id": 45835}
{"snippet": "pandas.plotting.bootstrap_plot(series, **kwds, fig=None)", "intent": "Bootstrap plot on mean , median and mid-range statistics . With arguments `series`, `**kwds`, `fig`.", "question_id": 45836}
{"snippet": "pandas.plotting.bootstrap_plot(series, **kwds, size=50)", "intent": "Bootstrap plot on mean , median and mid-range statistics . This function will generate bootstrapping plots for mean , median and mid-range statistics for the given number of `samples` of the given `size` . With arguments `series`, `**kwds`.", "question_id": 45837}
{"snippet": "pandas.plotting.bootstrap_plot(series, **kwds, samples=500)", "intent": "Bootstrap plot on mean , median and mid-range statistics . This function will generate bootstrapping plots for mean , median and mid-range statistics for the given number of `samples` of the given `size` . With arguments `series`, `**kwds`.", "question_id": 45838}
{"snippet": "pandas.plotting.bootstrap_plot(series, **kwds, fig=None, size=50)", "intent": "Bootstrap plot on mean , median and mid-range statistics . This function will generate bootstrapping plots for mean , median and mid-range statistics for the given number of `samples` of the given `size` . With arguments `series`, `**kwds`, `fig`.", "question_id": 45839}
{"snippet": "pandas.plotting.bootstrap_plot(series, **kwds, fig=None, samples=500)", "intent": "Bootstrap plot on mean , median and mid-range statistics . This function will generate bootstrapping plots for mean , median and mid-range statistics for the given number of `samples` of the given `size` . With arguments `series`, `**kwds`, `fig`.", "question_id": 45840}
{"snippet": "pandas.plotting.bootstrap_plot(series, **kwds, size=50, samples=500)", "intent": "Bootstrap plot on mean , median and mid-range statistics . This function will generate bootstrapping plots for mean , median and mid-range statistics for the given number of `samples` of the given `size` . With arguments `series`, `**kwds`.", "question_id": 45841}
{"snippet": "pandas.plotting.bootstrap_plot(series, **kwds, fig=None, size=50, samples=500)", "intent": "Bootstrap plot on mean , median and mid-range statistics . This function will generate bootstrapping plots for mean , median and mid-range statistics for the given number of `samples` of the given `size` . With arguments `series`, `**kwds`, `fig`.", "question_id": 45842}
{"snippet": "pandas.plotting.bootstrap_plot(series, **kwds)", "intent": "Bootstrap plot on mean , median and mid-range statistics . With arguments `series`, `**kwds`.", "question_id": 45843}
{"snippet": "pandas.plotting.bootstrap_plot(series, **kwds, fig=None)", "intent": "Bootstrap plot on mean , median and mid-range statistics . With arguments `series`, `**kwds`, `fig`.", "question_id": 45844}
{"snippet": "pandas.plotting.bootstrap_plot(series, **kwds, size=50)", "intent": "Bootstrap plot on mean , median and mid-range statistics . This function will generate bootstrapping plots for mean , median and mid-range statistics for the given number of `samples` of the given `size` . With arguments `series`, `**kwds`.", "question_id": 45845}
{"snippet": "pandas.plotting.bootstrap_plot(series, **kwds, samples=500)", "intent": "Bootstrap plot on mean , median and mid-range statistics . This function will generate bootstrapping plots for mean , median and mid-range statistics for the given number of `samples` of the given `size` . With arguments `series`, `**kwds`.", "question_id": 45846}
{"snippet": "pandas.plotting.bootstrap_plot(series, **kwds, fig=None, size=50)", "intent": "Bootstrap plot on mean , median and mid-range statistics . This function will generate bootstrapping plots for mean , median and mid-range statistics for the given number of `samples` of the given `size` . With arguments `series`, `**kwds`, `fig`.", "question_id": 45847}
{"snippet": "pandas.plotting.bootstrap_plot(series, **kwds, fig=None, samples=500)", "intent": "Bootstrap plot on mean , median and mid-range statistics . This function will generate bootstrapping plots for mean , median and mid-range statistics for the given number of `samples` of the given `size` . With arguments `series`, `**kwds`, `fig`.", "question_id": 45848}
{"snippet": "pandas.plotting.bootstrap_plot(series, **kwds, size=50, samples=500)", "intent": "Bootstrap plot on mean , median and mid-range statistics . This function will generate bootstrapping plots for mean , median and mid-range statistics for the given number of `samples` of the given `size` . With arguments `series`, `**kwds`.", "question_id": 45849}
{"snippet": "pandas.plotting.bootstrap_plot(series, **kwds, fig=None, size=50, samples=500)", "intent": "Bootstrap plot on mean , median and mid-range statistics . This function will generate bootstrapping plots for mean , median and mid-range statistics for the given number of `samples` of the given `size` . With arguments `series`, `**kwds`, `fig`.", "question_id": 45850}
{"snippet": "pandas.plotting.boxplot(data, **kwargs)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . With arguments `**kwargs`.", "question_id": 45851}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, column=None)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . Boxplots can be created for every `column` in the dataframe by df.boxplot ( ) or indicating the columns to be used : With arguments `**kwargs`.", "question_id": 45852}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, by=None)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . Make a box-and-whisker plot from DataFrame columns , optionally grouped `by` some other columns . With arguments `**kwargs`.", "question_id": 45853}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, ax=None)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . With arguments `**kwargs`, `ax`.", "question_id": 45854}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, fontsize=None)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . rot=45 ) or changing the `fontsize` ( i.e . With arguments `**kwargs`.", "question_id": 45855}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, rot=0)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . With arguments `**kwargs`, `rot`.", "question_id": 45856}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, grid=True)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . Additional formatting can be done to the boxplot , like suppressing the `grid` ( grid=False ) , rotating the labels in the x-axis ( i.e . With arguments `**kwargs`.", "question_id": 45857}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, figsize=None)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . With arguments `**kwargs`, `figsize`.", "question_id": 45858}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, layout=None)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . The `layout` of boxplot can be adjusted giving a tuple to layout : With arguments `**kwargs`.", "question_id": 45859}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, return_type=None)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . The return type depends on the `return_type` parameter : With arguments `**kwargs`.", "question_id": 45860}
{"snippet": "pandas.plotting.boxplot(data, **kwargs)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . With arguments `**kwargs`.", "question_id": 45861}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, column=None)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . Boxplots can be created for every `column` in the dataframe by df.boxplot ( ) or indicating the columns to be used : With arguments `**kwargs`.", "question_id": 45862}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, by=None)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . Make a box-and-whisker plot from DataFrame columns , optionally grouped `by` some other columns . With arguments `**kwargs`.", "question_id": 45863}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, ax=None)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . With arguments `**kwargs`, `ax`.", "question_id": 45864}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, fontsize=None)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . rot=45 ) or changing the `fontsize` ( i.e . With arguments `**kwargs`.", "question_id": 45865}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, rot=0)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . With arguments `**kwargs`, `rot`.", "question_id": 45866}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, grid=True)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . Additional formatting can be done to the boxplot , like suppressing the `grid` ( grid=False ) , rotating the labels in the x-axis ( i.e . With arguments `**kwargs`.", "question_id": 45867}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, figsize=None)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . With arguments `**kwargs`, `figsize`.", "question_id": 45868}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, layout=None)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . The `layout` of boxplot can be adjusted giving a tuple to layout : With arguments `**kwargs`.", "question_id": 45869}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, return_type=None)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . The return type depends on the `return_type` parameter : With arguments `**kwargs`.", "question_id": 45870}
{"snippet": "pandas.plotting.boxplot(data, **kwargs)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . With arguments `**kwargs`.", "question_id": 45871}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, column=None)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . Boxplots can be created for every `column` in the dataframe by df.boxplot ( ) or indicating the columns to be used : With arguments `**kwargs`.", "question_id": 45872}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, by=None)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . Make a box-and-whisker plot from DataFrame columns , optionally grouped `by` some other columns . With arguments `**kwargs`.", "question_id": 45873}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, ax=None)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . With arguments `**kwargs`, `ax`.", "question_id": 45874}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, fontsize=None)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . rot=45 ) or changing the `fontsize` ( i.e . With arguments `**kwargs`.", "question_id": 45875}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, rot=0)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . With arguments `**kwargs`, `rot`.", "question_id": 45876}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, grid=True)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . Additional formatting can be done to the boxplot , like suppressing the `grid` ( grid=False ) , rotating the labels in the x-axis ( i.e . With arguments `**kwargs`.", "question_id": 45877}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, figsize=None)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . With arguments `**kwargs`, `figsize`.", "question_id": 45878}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, layout=None)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . The `layout` of boxplot can be adjusted giving a tuple to layout : With arguments `**kwargs`.", "question_id": 45879}
{"snippet": "pandas.plotting.boxplot(data, **kwargs, return_type=None)", "intent": "Make a box plot from DataFrame columns . A box plot is a method for graphically depicting groups of numerical `data` through their quartiles . The return type depends on the `return_type` parameter : With arguments `**kwargs`.", "question_id": 45880}
{"snippet": "pandas.plotting.deregister_matplotlib_converters()", "intent": "Remove pandas formatters and converters .", "question_id": 45881}
{"snippet": "pandas.plotting.deregister_matplotlib_converters()", "intent": "Remove pandas formatters and converters .", "question_id": 45882}
{"snippet": "pandas.plotting.deregister_matplotlib_converters()", "intent": "Remove pandas formatters and converters .", "question_id": 45883}
{"snippet": "pandas.plotting.lag_plot(series, **kwds)", "intent": "Lag plot for time `series` . With arguments `**kwds`.", "question_id": 45884}
{"snippet": "pandas.plotting.lag_plot(series, **kwds, lag=1)", "intent": "Lag plot for time `series` . A `lag` plot with lag=1 returns With arguments `**kwds`.", "question_id": 45885}
{"snippet": "pandas.plotting.lag_plot(series, **kwds, ax=None)", "intent": "Lag plot for time `series` . With arguments `**kwds`, `ax`.", "question_id": 45886}
{"snippet": "pandas.plotting.lag_plot(series, **kwds, lag=1, ax=None)", "intent": "Lag plot for time `series` . A `lag` plot with lag=1 returns With arguments `**kwds`, `ax`.", "question_id": 45887}
{"snippet": "pandas.plotting.lag_plot(series, **kwds)", "intent": "Lag plot for time `series` . With arguments `**kwds`.", "question_id": 45888}
{"snippet": "pandas.plotting.lag_plot(series, **kwds, lag=1)", "intent": "Lag plot for time `series` . A `lag` plot with lag=1 returns With arguments `**kwds`.", "question_id": 45889}
{"snippet": "pandas.plotting.lag_plot(series, **kwds, ax=None)", "intent": "Lag plot for time `series` . With arguments `**kwds`, `ax`.", "question_id": 45890}
{"snippet": "pandas.plotting.lag_plot(series, **kwds, lag=1, ax=None)", "intent": "Lag plot for time `series` . A `lag` plot with lag=1 returns With arguments `**kwds`, `ax`.", "question_id": 45891}
{"snippet": "pandas.plotting.lag_plot(series, **kwds)", "intent": "Lag plot for time `series` . With arguments `**kwds`.", "question_id": 45892}
{"snippet": "pandas.plotting.lag_plot(series, **kwds, lag=1)", "intent": "Lag plot for time `series` . A `lag` plot with lag=1 returns With arguments `**kwds`.", "question_id": 45893}
{"snippet": "pandas.plotting.lag_plot(series, **kwds, ax=None)", "intent": "Lag plot for time `series` . With arguments `**kwds`, `ax`.", "question_id": 45894}
{"snippet": "pandas.plotting.lag_plot(series, **kwds, lag=1, ax=None)", "intent": "Lag plot for time `series` . A `lag` plot with lag=1 returns With arguments `**kwds`, `ax`.", "question_id": 45895}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`.", "question_id": 45896}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, cols=None)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `cols`.", "question_id": 45897}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, ax=None)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `ax`.", "question_id": 45898}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, color=None)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `color`.", "question_id": 45899}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, use_columns=False)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `use_columns`.", "question_id": 45900}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, xticks=None)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `xticks`.", "question_id": 45901}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, colormap=None)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `colormap`.", "question_id": 45902}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, axvlines=True)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `axvlines`.", "question_id": 45903}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, axvlines_kwds=None)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `axvlines_kwds`.", "question_id": 45904}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, sort_labels=False)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `sort_labels`.", "question_id": 45905}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`.", "question_id": 45906}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, cols=None)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `cols`.", "question_id": 45907}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, ax=None)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `ax`.", "question_id": 45908}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, color=None)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `color`.", "question_id": 45909}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, use_columns=False)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `use_columns`.", "question_id": 45910}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, xticks=None)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `xticks`.", "question_id": 45911}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, colormap=None)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `colormap`.", "question_id": 45912}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, axvlines=True)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `axvlines`.", "question_id": 45913}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, axvlines_kwds=None)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `axvlines_kwds`.", "question_id": 45914}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, sort_labels=False)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `sort_labels`.", "question_id": 45915}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`.", "question_id": 45916}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, cols=None)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `cols`.", "question_id": 45917}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, ax=None)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `ax`.", "question_id": 45918}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, color=None)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `color`.", "question_id": 45919}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, use_columns=False)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `use_columns`.", "question_id": 45920}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, xticks=None)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `xticks`.", "question_id": 45921}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, colormap=None)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `colormap`.", "question_id": 45922}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, axvlines=True)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `axvlines`.", "question_id": 45923}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, axvlines_kwds=None)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `axvlines_kwds`.", "question_id": 45924}
{"snippet": "pandas.plotting.parallel_coordinates(frame, class_column, **kwargs, sort_labels=False)", "intent": "Parallel coordinates plotting . With arguments `frame`, `class_column`, `**kwargs`, `sort_labels`.", "question_id": 45925}
{"snippet": "pandas.plotting.plot_params", "intent": "Stores pandas plotting options.", "question_id": 45926}
{"snippet": "pandas.plotting.plot_params", "intent": "Stores pandas plotting options.", "question_id": 45927}
{"snippet": "pandas.plotting.plot_params", "intent": "Stores pandas plotting options.", "question_id": 45928}
{"snippet": "pandas.plotting.radviz(frame, class_column, **kwds)", "intent": "Plot a multidimensional dataset in 2D . With arguments `frame`, `class_column`, `**kwds`.", "question_id": 45929}
{"snippet": "pandas.plotting.radviz(frame, class_column, **kwds, ax=None)", "intent": "Plot a multidimensional dataset in 2D . With arguments `frame`, `class_column`, `**kwds`, `ax`.", "question_id": 45930}
{"snippet": "pandas.plotting.radviz(frame, class_column, **kwds, color=None)", "intent": "Plot a multidimensional dataset in 2D . With arguments `frame`, `class_column`, `**kwds`, `color`.", "question_id": 45931}
{"snippet": "pandas.plotting.radviz(frame, class_column, **kwds, colormap=None)", "intent": "Plot a multidimensional dataset in 2D . With arguments `frame`, `class_column`, `**kwds`, `colormap`.", "question_id": 45932}
{"snippet": "pandas.plotting.radviz(frame, class_column, **kwds, ax=None, color=None)", "intent": "Plot a multidimensional dataset in 2D . With arguments `frame`, `class_column`, `**kwds`, `ax`, `color`.", "question_id": 45933}
{"snippet": "pandas.plotting.radviz(frame, class_column, **kwds, ax=None, colormap=None)", "intent": "Plot a multidimensional dataset in 2D . With arguments `frame`, `class_column`, `**kwds`, `ax`, `colormap`.", "question_id": 45934}
{"snippet": "pandas.plotting.radviz(frame, class_column, **kwds, color=None, colormap=None)", "intent": "Plot a multidimensional dataset in 2D . With arguments `frame`, `class_column`, `**kwds`, `color`, `colormap`.", "question_id": 45935}
{"snippet": "pandas.plotting.radviz(frame, class_column, **kwds, ax=None, color=None, colormap=None)", "intent": "Plot a multidimensional dataset in 2D . With arguments `frame`, `class_column`, `**kwds`, `ax`, `color`, `colormap`.", "question_id": 45936}
{"snippet": "pandas.plotting.radviz(frame, class_column, **kwds)", "intent": "Plot a multidimensional dataset in 2D . With arguments `frame`, `class_column`, `**kwds`.", "question_id": 45937}
{"snippet": "pandas.plotting.radviz(frame, class_column, **kwds, ax=None)", "intent": "Plot a multidimensional dataset in 2D . With arguments `frame`, `class_column`, `**kwds`, `ax`.", "question_id": 45938}
{"snippet": "pandas.plotting.radviz(frame, class_column, **kwds, color=None)", "intent": "Plot a multidimensional dataset in 2D . With arguments `frame`, `class_column`, `**kwds`, `color`.", "question_id": 45939}
{"snippet": "pandas.plotting.radviz(frame, class_column, **kwds, colormap=None)", "intent": "Plot a multidimensional dataset in 2D . With arguments `frame`, `class_column`, `**kwds`, `colormap`.", "question_id": 45940}
{"snippet": "pandas.plotting.radviz(frame, class_column, **kwds, ax=None, color=None)", "intent": "Plot a multidimensional dataset in 2D . With arguments `frame`, `class_column`, `**kwds`, `ax`, `color`.", "question_id": 45941}
{"snippet": "pandas.plotting.radviz(frame, class_column, **kwds, ax=None, colormap=None)", "intent": "Plot a multidimensional dataset in 2D . With arguments `frame`, `class_column`, `**kwds`, `ax`, `colormap`.", "question_id": 45942}
{"snippet": "pandas.plotting.radviz(frame, class_column, **kwds, color=None, colormap=None)", "intent": "Plot a multidimensional dataset in 2D . With arguments `frame`, `class_column`, `**kwds`, `color`, `colormap`.", "question_id": 45943}
{"snippet": "pandas.plotting.radviz(frame, class_column, **kwds, ax=None, color=None, colormap=None)", "intent": "Plot a multidimensional dataset in 2D . With arguments `frame`, `class_column`, `**kwds`, `ax`, `color`, `colormap`.", "question_id": 45944}
{"snippet": "pandas.plotting.radviz(frame, class_column, **kwds)", "intent": "Plot a multidimensional dataset in 2D . With arguments `frame`, `class_column`, `**kwds`.", "question_id": 45945}
{"snippet": "pandas.plotting.radviz(frame, class_column, **kwds, ax=None)", "intent": "Plot a multidimensional dataset in 2D . With arguments `frame`, `class_column`, `**kwds`, `ax`.", "question_id": 45946}
{"snippet": "pandas.plotting.radviz(frame, class_column, **kwds, color=None)", "intent": "Plot a multidimensional dataset in 2D . With arguments `frame`, `class_column`, `**kwds`, `color`.", "question_id": 45947}
{"snippet": "pandas.plotting.radviz(frame, class_column, **kwds, colormap=None)", "intent": "Plot a multidimensional dataset in 2D . With arguments `frame`, `class_column`, `**kwds`, `colormap`.", "question_id": 45948}
{"snippet": "pandas.plotting.radviz(frame, class_column, **kwds, ax=None, color=None)", "intent": "Plot a multidimensional dataset in 2D . With arguments `frame`, `class_column`, `**kwds`, `ax`, `color`.", "question_id": 45949}
{"snippet": "pandas.plotting.radviz(frame, class_column, **kwds, ax=None, colormap=None)", "intent": "Plot a multidimensional dataset in 2D . With arguments `frame`, `class_column`, `**kwds`, `ax`, `colormap`.", "question_id": 45950}
{"snippet": "pandas.plotting.radviz(frame, class_column, **kwds, color=None, colormap=None)", "intent": "Plot a multidimensional dataset in 2D . With arguments `frame`, `class_column`, `**kwds`, `color`, `colormap`.", "question_id": 45951}
{"snippet": "pandas.plotting.radviz(frame, class_column, **kwds, ax=None, color=None, colormap=None)", "intent": "Plot a multidimensional dataset in 2D . With arguments `frame`, `class_column`, `**kwds`, `ax`, `color`, `colormap`.", "question_id": 45952}
{"snippet": "pandas.plotting.register_matplotlib_converters()", "intent": "Register pandas formatters and converters with matplotlib .", "question_id": 45953}
{"snippet": "pandas.plotting.register_matplotlib_converters()", "intent": "Register pandas formatters and converters with matplotlib .", "question_id": 45954}
{"snippet": "pandas.plotting.register_matplotlib_converters()", "intent": "Register pandas formatters and converters with matplotlib .", "question_id": 45955}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs)", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`.", "question_id": 45956}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, alpha=0.5)", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `alpha`.", "question_id": 45957}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, figsize=None)", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `figsize`.", "question_id": 45958}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, ax=None)", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `ax`.", "question_id": 45959}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, grid=False)", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `grid`.", "question_id": 45960}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, diagonal='hist')", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `diagonal`.", "question_id": 45961}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, marker='.')", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `marker`.", "question_id": 45962}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, density_kwds=None)", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `density_kwds`.", "question_id": 45963}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, hist_kwds=None)", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `hist_kwds`.", "question_id": 45964}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, range_padding=0.05)", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `range_padding`.", "question_id": 45965}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs)", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`.", "question_id": 45966}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, alpha=0.5)", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `alpha`.", "question_id": 45967}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, figsize=None)", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `figsize`.", "question_id": 45968}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, ax=None)", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `ax`.", "question_id": 45969}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, grid=False)", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `grid`.", "question_id": 45970}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, diagonal='hist')", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `diagonal`.", "question_id": 45971}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, marker='.')", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `marker`.", "question_id": 45972}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, density_kwds=None)", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `density_kwds`.", "question_id": 45973}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, hist_kwds=None)", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `hist_kwds`.", "question_id": 45974}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, range_padding=0.05)", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `range_padding`.", "question_id": 45975}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs)", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`.", "question_id": 45976}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, alpha=0.5)", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `alpha`.", "question_id": 45977}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, figsize=None)", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `figsize`.", "question_id": 45978}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, ax=None)", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `ax`.", "question_id": 45979}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, grid=False)", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `grid`.", "question_id": 45980}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, diagonal='hist')", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `diagonal`.", "question_id": 45981}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, marker='.')", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `marker`.", "question_id": 45982}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, density_kwds=None)", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `density_kwds`.", "question_id": 45983}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, hist_kwds=None)", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `hist_kwds`.", "question_id": 45984}
{"snippet": "pandas.plotting.scatter_matrix(frame, **kwargs, range_padding=0.05)", "intent": "Draw a matrix of scatter plots . With arguments `frame`, `**kwargs`, `range_padding`.", "question_id": 45985}
{"snippet": "pandas.plotting.table(ax, data, **kwargs)", "intent": "Helper function to convert DataFrame and Series to matplotlib.table . With arguments `ax`, `data`, `**kwargs`.", "question_id": 45986}
{"snippet": "pandas.plotting.table(ax, data, **kwargs, rowLabels=None)", "intent": "Helper function to convert DataFrame and Series to matplotlib.table . With arguments `ax`, `data`, `**kwargs`, `rowLabels`.", "question_id": 45987}
{"snippet": "pandas.plotting.table(ax, data, **kwargs, colLabels=None)", "intent": "Helper function to convert DataFrame and Series to matplotlib.table . With arguments `ax`, `data`, `**kwargs`, `colLabels`.", "question_id": 45988}
{"snippet": "pandas.plotting.table(ax, data, **kwargs, rowLabels=None, colLabels=None)", "intent": "Helper function to convert DataFrame and Series to matplotlib.table . With arguments `ax`, `data`, `**kwargs`, `rowLabels`, `colLabels`.", "question_id": 45989}
{"snippet": "pandas.plotting.table(ax, data, **kwargs)", "intent": "Helper function to convert DataFrame and Series to matplotlib.table . With arguments `ax`, `data`, `**kwargs`.", "question_id": 45990}
{"snippet": "pandas.plotting.table(ax, data, **kwargs, rowLabels=None)", "intent": "Helper function to convert DataFrame and Series to matplotlib.table . With arguments `ax`, `data`, `**kwargs`, `rowLabels`.", "question_id": 45991}
{"snippet": "pandas.plotting.table(ax, data, **kwargs, colLabels=None)", "intent": "Helper function to convert DataFrame and Series to matplotlib.table . With arguments `ax`, `data`, `**kwargs`, `colLabels`.", "question_id": 45992}
{"snippet": "pandas.plotting.table(ax, data, **kwargs, rowLabels=None, colLabels=None)", "intent": "Helper function to convert DataFrame and Series to matplotlib.table . With arguments `ax`, `data`, `**kwargs`, `rowLabels`, `colLabels`.", "question_id": 45993}
{"snippet": "pandas.plotting.table(ax, data, **kwargs)", "intent": "Helper function to convert DataFrame and Series to matplotlib.table . With arguments `ax`, `data`, `**kwargs`.", "question_id": 45994}
{"snippet": "pandas.plotting.table(ax, data, **kwargs, rowLabels=None)", "intent": "Helper function to convert DataFrame and Series to matplotlib.table . With arguments `ax`, `data`, `**kwargs`, `rowLabels`.", "question_id": 45995}
{"snippet": "pandas.plotting.table(ax, data, **kwargs, colLabels=None)", "intent": "Helper function to convert DataFrame and Series to matplotlib.table . With arguments `ax`, `data`, `**kwargs`, `colLabels`.", "question_id": 45996}
{"snippet": "pandas.plotting.table(ax, data, **kwargs, rowLabels=None, colLabels=None)", "intent": "Helper function to convert DataFrame and Series to matplotlib.table . With arguments `ax`, `data`, `**kwargs`, `rowLabels`, `colLabels`.", "question_id": 45997}
{"snippet": "pandas.qcut(x, q)", "intent": "Quantile-based discretization function . With arguments `x`, `q`.", "question_id": 45998}
{"snippet": "pandas.qcut(x, q, labels=None)", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `labels`.", "question_id": 45999}
{"snippet": "pandas.qcut(x, q, retbins=False)", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `retbins`.", "question_id": 46000}
{"snippet": "pandas.qcut(x, q, precision=3)", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `precision`.", "question_id": 46001}
{"snippet": "pandas.qcut(x, q, duplicates='raise')", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `duplicates`.", "question_id": 46002}
{"snippet": "pandas.qcut(x, q, labels=None, retbins=False)", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `labels`, `retbins`.", "question_id": 46003}
{"snippet": "pandas.qcut(x, q, labels=None, precision=3)", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `labels`, `precision`.", "question_id": 46004}
{"snippet": "pandas.qcut(x, q, labels=None, duplicates='raise')", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `labels`, `duplicates`.", "question_id": 46005}
{"snippet": "pandas.qcut(x, q, retbins=False, precision=3)", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `retbins`, `precision`.", "question_id": 46006}
{"snippet": "pandas.qcut(x, q, retbins=False, duplicates='raise')", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `retbins`, `duplicates`.", "question_id": 46007}
{"snippet": "pandas.qcut(x, q)", "intent": "Quantile-based discretization function . With arguments `x`, `q`.", "question_id": 46008}
{"snippet": "pandas.qcut(x, q, labels=None)", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `labels`.", "question_id": 46009}
{"snippet": "pandas.qcut(x, q, retbins=False)", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `retbins`.", "question_id": 46010}
{"snippet": "pandas.qcut(x, q, precision=3)", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `precision`.", "question_id": 46011}
{"snippet": "pandas.qcut(x, q, duplicates='raise')", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `duplicates`.", "question_id": 46012}
{"snippet": "pandas.qcut(x, q, labels=None, retbins=False)", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `labels`, `retbins`.", "question_id": 46013}
{"snippet": "pandas.qcut(x, q, labels=None, precision=3)", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `labels`, `precision`.", "question_id": 46014}
{"snippet": "pandas.qcut(x, q, labels=None, duplicates='raise')", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `labels`, `duplicates`.", "question_id": 46015}
{"snippet": "pandas.qcut(x, q, retbins=False, precision=3)", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `retbins`, `precision`.", "question_id": 46016}
{"snippet": "pandas.qcut(x, q, retbins=False, duplicates='raise')", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `retbins`, `duplicates`.", "question_id": 46017}
{"snippet": "pandas.qcut(x, q)", "intent": "Quantile-based discretization function . With arguments `x`, `q`.", "question_id": 46018}
{"snippet": "pandas.qcut(x, q, labels=None)", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `labels`.", "question_id": 46019}
{"snippet": "pandas.qcut(x, q, retbins=False)", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `retbins`.", "question_id": 46020}
{"snippet": "pandas.qcut(x, q, precision=3)", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `precision`.", "question_id": 46021}
{"snippet": "pandas.qcut(x, q, duplicates='raise')", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `duplicates`.", "question_id": 46022}
{"snippet": "pandas.qcut(x, q, labels=None, retbins=False)", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `labels`, `retbins`.", "question_id": 46023}
{"snippet": "pandas.qcut(x, q, labels=None, precision=3)", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `labels`, `precision`.", "question_id": 46024}
{"snippet": "pandas.qcut(x, q, labels=None, duplicates='raise')", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `labels`, `duplicates`.", "question_id": 46025}
{"snippet": "pandas.qcut(x, q, retbins=False, precision=3)", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `retbins`, `precision`.", "question_id": 46026}
{"snippet": "pandas.qcut(x, q, retbins=False, duplicates='raise')", "intent": "Quantile-based discretization function . With arguments `x`, `q`, `retbins`, `duplicates`.", "question_id": 46027}
{"snippet": "pandas.read_clipboard(**kwargs)", "intent": "Read text from clipboard and pass to read_csv . With arguments `**kwargs`.", "question_id": 46028}
{"snippet": "pandas.read_clipboard(**kwargs, sep='\\\\s+')", "intent": "Read text from clipboard and pass to read_csv . With arguments `**kwargs`, `sep`.", "question_id": 46029}
{"snippet": "pandas.read_clipboard(**kwargs)", "intent": "Read text from clipboard and pass to read_csv . With arguments `**kwargs`.", "question_id": 46030}
{"snippet": "pandas.read_clipboard(**kwargs, sep='\\\\s+')", "intent": "Read text from clipboard and pass to read_csv . With arguments `**kwargs`, `sep`.", "question_id": 46031}
{"snippet": "pandas.read_clipboard(**kwargs)", "intent": "Read text from clipboard and pass to read_csv . With arguments `**kwargs`.", "question_id": 46032}
{"snippet": "pandas.read_clipboard(**kwargs, sep='\\\\s+')", "intent": "Read text from clipboard and pass to read_csv . With arguments `**kwargs`, `sep`.", "question_id": 46033}
{"snippet": "pandas.read_csv(filepath_or_buffer)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`.", "question_id": 46034}
{"snippet": "pandas.read_csv(filepath_or_buffer, sep=NoDefault.no_default)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `sep`.", "question_id": 46035}
{"snippet": "pandas.read_csv(filepath_or_buffer, delimiter=None)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `delimiter`.", "question_id": 46036}
{"snippet": "pandas.read_csv(filepath_or_buffer, header='infer')", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `header`.", "question_id": 46037}
{"snippet": "pandas.read_csv(filepath_or_buffer, names=NoDefault.no_default)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `names`.", "question_id": 46038}
{"snippet": "pandas.read_csv(filepath_or_buffer, index_col=None)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `index_col`.", "question_id": 46039}
{"snippet": "pandas.read_csv(filepath_or_buffer, usecols=None)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `usecols`.", "question_id": 46040}
{"snippet": "pandas.read_csv(filepath_or_buffer, squeeze=False)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `squeeze`.", "question_id": 46041}
{"snippet": "pandas.read_csv(filepath_or_buffer, prefix=NoDefault.no_default)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `prefix`.", "question_id": 46042}
{"snippet": "pandas.read_csv(filepath_or_buffer, mangle_dupe_cols=True)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `mangle_dupe_cols`.", "question_id": 46043}
{"snippet": "pandas.read_csv(filepath_or_buffer)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`.", "question_id": 46044}
{"snippet": "pandas.read_csv(filepath_or_buffer, sep=NoDefault.no_default)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `sep`.", "question_id": 46045}
{"snippet": "pandas.read_csv(filepath_or_buffer, delimiter=None)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `delimiter`.", "question_id": 46046}
{"snippet": "pandas.read_csv(filepath_or_buffer, header='infer')", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `header`.", "question_id": 46047}
{"snippet": "pandas.read_csv(filepath_or_buffer, names=NoDefault.no_default)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `names`.", "question_id": 46048}
{"snippet": "pandas.read_csv(filepath_or_buffer, index_col=None)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `index_col`.", "question_id": 46049}
{"snippet": "pandas.read_csv(filepath_or_buffer, usecols=None)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `usecols`.", "question_id": 46050}
{"snippet": "pandas.read_csv(filepath_or_buffer, squeeze=False)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `squeeze`.", "question_id": 46051}
{"snippet": "pandas.read_csv(filepath_or_buffer, prefix=NoDefault.no_default)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `prefix`.", "question_id": 46052}
{"snippet": "pandas.read_csv(filepath_or_buffer, mangle_dupe_cols=True)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `mangle_dupe_cols`.", "question_id": 46053}
{"snippet": "pandas.read_csv(filepath_or_buffer)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`.", "question_id": 46054}
{"snippet": "pandas.read_csv(filepath_or_buffer, sep=NoDefault.no_default)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `sep`.", "question_id": 46055}
{"snippet": "pandas.read_csv(filepath_or_buffer, delimiter=None)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `delimiter`.", "question_id": 46056}
{"snippet": "pandas.read_csv(filepath_or_buffer, header='infer')", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `header`.", "question_id": 46057}
{"snippet": "pandas.read_csv(filepath_or_buffer, names=NoDefault.no_default)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `names`.", "question_id": 46058}
{"snippet": "pandas.read_csv(filepath_or_buffer, index_col=None)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `index_col`.", "question_id": 46059}
{"snippet": "pandas.read_csv(filepath_or_buffer, usecols=None)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `usecols`.", "question_id": 46060}
{"snippet": "pandas.read_csv(filepath_or_buffer, squeeze=False)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `squeeze`.", "question_id": 46061}
{"snippet": "pandas.read_csv(filepath_or_buffer, prefix=NoDefault.no_default)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `prefix`.", "question_id": 46062}
{"snippet": "pandas.read_csv(filepath_or_buffer, mangle_dupe_cols=True)", "intent": "Read a comma-separated values ( csv ) file into DataFrame . With arguments `filepath_or_buffer`, `mangle_dupe_cols`.", "question_id": 46063}
{"snippet": "pandas.read_excel(io)", "intent": "Read an Excel file into a pandas DataFrame . With arguments `io`.", "question_id": 46064}
{"snippet": "pandas.read_excel(io, sheet_name=0)", "intent": "Read an Excel file into a pandas DataFrame . With arguments `io`, `sheet_name`.", "question_id": 46065}
{"snippet": "pandas.read_excel(io, header=0)", "intent": "Read an Excel file into a pandas DataFrame . Index and `header` can be specified via the `index_col` and header arguments With arguments `io`.", "question_id": 46066}
{"snippet": "pandas.read_excel(io, names=None)", "intent": "Read an Excel file into a pandas DataFrame . With arguments `io`, `names`.", "question_id": 46067}
{"snippet": "pandas.read_excel(io, index_col=None)", "intent": "Read an Excel file into a pandas DataFrame . Index and `header` can be specified via the `index_col` and header arguments With arguments `io`.", "question_id": 46068}
{"snippet": "pandas.read_excel(io, usecols=None)", "intent": "Read an Excel file into a pandas DataFrame . With arguments `io`, `usecols`.", "question_id": 46069}
{"snippet": "pandas.read_excel(io, squeeze=False)", "intent": "Read an Excel file into a pandas DataFrame . With arguments `io`, `squeeze`.", "question_id": 46070}
{"snippet": "pandas.read_excel(io, dtype=None)", "intent": "Read an Excel file into a pandas DataFrame . With arguments `io`, `dtype`.", "question_id": 46071}
{"snippet": "pandas.read_excel(io, engine=None)", "intent": "Read an Excel file into a pandas DataFrame . With arguments `io`, `engine`.", "question_id": 46072}
{"snippet": "pandas.read_excel(io, converters=None)", "intent": "Read an Excel file into a pandas DataFrame . With arguments `io`, `converters`.", "question_id": 46073}
{"snippet": "pandas.read_excel(io)", "intent": "Read an Excel file into a pandas DataFrame . With arguments `io`.", "question_id": 46074}
{"snippet": "pandas.read_excel(io, sheet_name=0)", "intent": "Read an Excel file into a pandas DataFrame . With arguments `io`, `sheet_name`.", "question_id": 46075}
{"snippet": "pandas.read_excel(io, header=0)", "intent": "Read an Excel file into a pandas DataFrame . Index and `header` can be specified via the `index_col` and header arguments With arguments `io`.", "question_id": 46076}
{"snippet": "pandas.read_excel(io, names=None)", "intent": "Read an Excel file into a pandas DataFrame . With arguments `io`, `names`.", "question_id": 46077}
{"snippet": "pandas.read_excel(io, index_col=None)", "intent": "Read an Excel file into a pandas DataFrame . Index and `header` can be specified via the `index_col` and header arguments With arguments `io`.", "question_id": 46078}
{"snippet": "pandas.read_excel(io, usecols=None)", "intent": "Read an Excel file into a pandas DataFrame . With arguments `io`, `usecols`.", "question_id": 46079}
{"snippet": "pandas.read_excel(io, squeeze=False)", "intent": "Read an Excel file into a pandas DataFrame . With arguments `io`, `squeeze`.", "question_id": 46080}
{"snippet": "pandas.read_excel(io, dtype=None)", "intent": "Read an Excel file into a pandas DataFrame . With arguments `io`, `dtype`.", "question_id": 46081}
{"snippet": "pandas.read_excel(io, engine=None)", "intent": "Read an Excel file into a pandas DataFrame . With arguments `io`, `engine`.", "question_id": 46082}
{"snippet": "pandas.read_excel(io, converters=None)", "intent": "Read an Excel file into a pandas DataFrame . With arguments `io`, `converters`.", "question_id": 46083}
{"snippet": "pandas.read_excel(io)", "intent": "Read an Excel file into a pandas DataFrame . With arguments `io`.", "question_id": 46084}
{"snippet": "pandas.read_excel(io, sheet_name=0)", "intent": "Read an Excel file into a pandas DataFrame . With arguments `io`, `sheet_name`.", "question_id": 46085}
{"snippet": "pandas.read_excel(io, header=0)", "intent": "Read an Excel file into a pandas DataFrame . Index and `header` can be specified via the `index_col` and header arguments With arguments `io`.", "question_id": 46086}
{"snippet": "pandas.read_excel(io, names=None)", "intent": "Read an Excel file into a pandas DataFrame . With arguments `io`, `names`.", "question_id": 46087}
{"snippet": "pandas.read_excel(io, index_col=None)", "intent": "Read an Excel file into a pandas DataFrame . Index and `header` can be specified via the `index_col` and header arguments With arguments `io`.", "question_id": 46088}
{"snippet": "pandas.read_excel(io, usecols=None)", "intent": "Read an Excel file into a pandas DataFrame . With arguments `io`, `usecols`.", "question_id": 46089}
{"snippet": "pandas.read_excel(io, squeeze=False)", "intent": "Read an Excel file into a pandas DataFrame . With arguments `io`, `squeeze`.", "question_id": 46090}
{"snippet": "pandas.read_excel(io, dtype=None)", "intent": "Read an Excel file into a pandas DataFrame . With arguments `io`, `dtype`.", "question_id": 46091}
{"snippet": "pandas.read_excel(io, engine=None)", "intent": "Read an Excel file into a pandas DataFrame . With arguments `io`, `engine`.", "question_id": 46092}
{"snippet": "pandas.read_excel(io, converters=None)", "intent": "Read an Excel file into a pandas DataFrame . With arguments `io`, `converters`.", "question_id": 46093}
{"snippet": "pandas.read_feather(path)", "intent": "Load a feather-format object from the file `path` .", "question_id": 46094}
{"snippet": "pandas.read_feather(path, columns=None)", "intent": "Load a feather-format object from the file `path` . With arguments `columns`.", "question_id": 46095}
{"snippet": "pandas.read_feather(path, use_threads=True)", "intent": "Load a feather-format object from the file `path` . With arguments `use_threads`.", "question_id": 46096}
{"snippet": "pandas.read_feather(path, storage_options=None)", "intent": "Load a feather-format object from the file `path` . With arguments `storage_options`.", "question_id": 46097}
{"snippet": "pandas.read_feather(path, columns=None, use_threads=True)", "intent": "Load a feather-format object from the file `path` . With arguments `columns`, `use_threads`.", "question_id": 46098}
{"snippet": "pandas.read_feather(path, columns=None, storage_options=None)", "intent": "Load a feather-format object from the file `path` . With arguments `columns`, `storage_options`.", "question_id": 46099}
{"snippet": "pandas.read_feather(path, use_threads=True, storage_options=None)", "intent": "Load a feather-format object from the file `path` . With arguments `use_threads`, `storage_options`.", "question_id": 46100}
{"snippet": "pandas.read_feather(path, columns=None, use_threads=True, storage_options=None)", "intent": "Load a feather-format object from the file `path` . With arguments `columns`, `use_threads`, `storage_options`.", "question_id": 46101}
{"snippet": "pandas.read_feather(path)", "intent": "Load a feather-format object from the file `path` .", "question_id": 46102}
{"snippet": "pandas.read_feather(path, columns=None)", "intent": "Load a feather-format object from the file `path` . With arguments `columns`.", "question_id": 46103}
{"snippet": "pandas.read_feather(path, use_threads=True)", "intent": "Load a feather-format object from the file `path` . With arguments `use_threads`.", "question_id": 46104}
{"snippet": "pandas.read_feather(path, storage_options=None)", "intent": "Load a feather-format object from the file `path` . With arguments `storage_options`.", "question_id": 46105}
{"snippet": "pandas.read_feather(path, columns=None, use_threads=True)", "intent": "Load a feather-format object from the file `path` . With arguments `columns`, `use_threads`.", "question_id": 46106}
{"snippet": "pandas.read_feather(path, columns=None, storage_options=None)", "intent": "Load a feather-format object from the file `path` . With arguments `columns`, `storage_options`.", "question_id": 46107}
{"snippet": "pandas.read_feather(path, use_threads=True, storage_options=None)", "intent": "Load a feather-format object from the file `path` . With arguments `use_threads`, `storage_options`.", "question_id": 46108}
{"snippet": "pandas.read_feather(path, columns=None, use_threads=True, storage_options=None)", "intent": "Load a feather-format object from the file `path` . With arguments `columns`, `use_threads`, `storage_options`.", "question_id": 46109}
{"snippet": "pandas.read_feather(path)", "intent": "Load a feather-format object from the file `path` .", "question_id": 46110}
{"snippet": "pandas.read_feather(path, columns=None)", "intent": "Load a feather-format object from the file `path` . With arguments `columns`.", "question_id": 46111}
{"snippet": "pandas.read_feather(path, use_threads=True)", "intent": "Load a feather-format object from the file `path` . With arguments `use_threads`.", "question_id": 46112}
{"snippet": "pandas.read_feather(path, storage_options=None)", "intent": "Load a feather-format object from the file `path` . With arguments `storage_options`.", "question_id": 46113}
{"snippet": "pandas.read_feather(path, columns=None, use_threads=True)", "intent": "Load a feather-format object from the file `path` . With arguments `columns`, `use_threads`.", "question_id": 46114}
{"snippet": "pandas.read_feather(path, columns=None, storage_options=None)", "intent": "Load a feather-format object from the file `path` . With arguments `columns`, `storage_options`.", "question_id": 46115}
{"snippet": "pandas.read_feather(path, use_threads=True, storage_options=None)", "intent": "Load a feather-format object from the file `path` . With arguments `use_threads`, `storage_options`.", "question_id": 46116}
{"snippet": "pandas.read_feather(path, columns=None, use_threads=True, storage_options=None)", "intent": "Load a feather-format object from the file `path` . With arguments `columns`, `use_threads`, `storage_options`.", "question_id": 46117}
{"snippet": "pandas.read_fwf(filepath_or_buffer, **kwds)", "intent": "Read a table of fixed-width formatted lines into DataFrame . With arguments `filepath_or_buffer`, `**kwds`.", "question_id": 46118}
{"snippet": "pandas.read_fwf(filepath_or_buffer, **kwds, colspecs='infer')", "intent": "Read a table of fixed-width formatted lines into DataFrame . With arguments `filepath_or_buffer`, `**kwds`, `colspecs`.", "question_id": 46119}
{"snippet": "pandas.read_fwf(filepath_or_buffer, **kwds, widths=None)", "intent": "Read a table of fixed-width formatted lines into DataFrame . With arguments `filepath_or_buffer`, `**kwds`, `widths`.", "question_id": 46120}
{"snippet": "pandas.read_fwf(filepath_or_buffer, **kwds, infer_nrows=100)", "intent": "Read a table of fixed-width formatted lines into DataFrame . With arguments `filepath_or_buffer`, `**kwds`, `infer_nrows`.", "question_id": 46121}
{"snippet": "pandas.read_fwf(filepath_or_buffer, **kwds, colspecs='infer', widths=None)", "intent": "Read a table of fixed-width formatted lines into DataFrame . With arguments `filepath_or_buffer`, `**kwds`, `colspecs`, `widths`.", "question_id": 46122}
{"snippet": "pandas.read_fwf(filepath_or_buffer, **kwds, colspecs='infer', infer_nrows=100)", "intent": "Read a table of fixed-width formatted lines into DataFrame . With arguments `filepath_or_buffer`, `**kwds`, `colspecs`, `infer_nrows`.", "question_id": 46123}
{"snippet": "pandas.read_fwf(filepath_or_buffer, **kwds, widths=None, infer_nrows=100)", "intent": "Read a table of fixed-width formatted lines into DataFrame . With arguments `filepath_or_buffer`, `**kwds`, `widths`, `infer_nrows`.", "question_id": 46124}
{"snippet": "pandas.read_fwf(filepath_or_buffer, **kwds, colspecs='infer', widths=None, infer_nrows=100)", "intent": "Read a table of fixed-width formatted lines into DataFrame . With arguments `filepath_or_buffer`, `**kwds`, `colspecs`, `widths`, `infer_nrows`.", "question_id": 46125}
{"snippet": "pandas.read_fwf(filepath_or_buffer, **kwds)", "intent": "Read a table of fixed-width formatted lines into DataFrame . With arguments `filepath_or_buffer`, `**kwds`.", "question_id": 46126}
{"snippet": "pandas.read_fwf(filepath_or_buffer, **kwds, colspecs='infer')", "intent": "Read a table of fixed-width formatted lines into DataFrame . With arguments `filepath_or_buffer`, `**kwds`, `colspecs`.", "question_id": 46127}
{"snippet": "pandas.read_fwf(filepath_or_buffer, **kwds, widths=None)", "intent": "Read a table of fixed-width formatted lines into DataFrame . With arguments `filepath_or_buffer`, `**kwds`, `widths`.", "question_id": 46128}
{"snippet": "pandas.read_fwf(filepath_or_buffer, **kwds, infer_nrows=100)", "intent": "Read a table of fixed-width formatted lines into DataFrame . With arguments `filepath_or_buffer`, `**kwds`, `infer_nrows`.", "question_id": 46129}
{"snippet": "pandas.read_fwf(filepath_or_buffer, **kwds, colspecs='infer', widths=None)", "intent": "Read a table of fixed-width formatted lines into DataFrame . With arguments `filepath_or_buffer`, `**kwds`, `colspecs`, `widths`.", "question_id": 46130}
{"snippet": "pandas.read_fwf(filepath_or_buffer, **kwds, colspecs='infer', infer_nrows=100)", "intent": "Read a table of fixed-width formatted lines into DataFrame . With arguments `filepath_or_buffer`, `**kwds`, `colspecs`, `infer_nrows`.", "question_id": 46131}
{"snippet": "pandas.read_fwf(filepath_or_buffer, **kwds, widths=None, infer_nrows=100)", "intent": "Read a table of fixed-width formatted lines into DataFrame . With arguments `filepath_or_buffer`, `**kwds`, `widths`, `infer_nrows`.", "question_id": 46132}
{"snippet": "pandas.read_fwf(filepath_or_buffer, **kwds, colspecs='infer', widths=None, infer_nrows=100)", "intent": "Read a table of fixed-width formatted lines into DataFrame . With arguments `filepath_or_buffer`, `**kwds`, `colspecs`, `widths`, `infer_nrows`.", "question_id": 46133}
{"snippet": "pandas.read_fwf(filepath_or_buffer, **kwds)", "intent": "Read a table of fixed-width formatted lines into DataFrame . With arguments `filepath_or_buffer`, `**kwds`.", "question_id": 46134}
{"snippet": "pandas.read_fwf(filepath_or_buffer, **kwds, colspecs='infer')", "intent": "Read a table of fixed-width formatted lines into DataFrame . With arguments `filepath_or_buffer`, `**kwds`, `colspecs`.", "question_id": 46135}
{"snippet": "pandas.read_fwf(filepath_or_buffer, **kwds, widths=None)", "intent": "Read a table of fixed-width formatted lines into DataFrame . With arguments `filepath_or_buffer`, `**kwds`, `widths`.", "question_id": 46136}
{"snippet": "pandas.read_fwf(filepath_or_buffer, **kwds, infer_nrows=100)", "intent": "Read a table of fixed-width formatted lines into DataFrame . With arguments `filepath_or_buffer`, `**kwds`, `infer_nrows`.", "question_id": 46137}
{"snippet": "pandas.read_fwf(filepath_or_buffer, **kwds, colspecs='infer', widths=None)", "intent": "Read a table of fixed-width formatted lines into DataFrame . With arguments `filepath_or_buffer`, `**kwds`, `colspecs`, `widths`.", "question_id": 46138}
{"snippet": "pandas.read_fwf(filepath_or_buffer, **kwds, colspecs='infer', infer_nrows=100)", "intent": "Read a table of fixed-width formatted lines into DataFrame . With arguments `filepath_or_buffer`, `**kwds`, `colspecs`, `infer_nrows`.", "question_id": 46139}
{"snippet": "pandas.read_fwf(filepath_or_buffer, **kwds, widths=None, infer_nrows=100)", "intent": "Read a table of fixed-width formatted lines into DataFrame . With arguments `filepath_or_buffer`, `**kwds`, `widths`, `infer_nrows`.", "question_id": 46140}
{"snippet": "pandas.read_fwf(filepath_or_buffer, **kwds, colspecs='infer', widths=None, infer_nrows=100)", "intent": "Read a table of fixed-width formatted lines into DataFrame . With arguments `filepath_or_buffer`, `**kwds`, `colspecs`, `widths`, `infer_nrows`.", "question_id": 46141}
{"snippet": "pandas.read_gbq(query)", "intent": "Load data from Google BigQuery . With arguments `query`.", "question_id": 46142}
{"snippet": "pandas.read_gbq(query, project_id=None)", "intent": "Load data from Google BigQuery . With arguments `query`, `project_id`.", "question_id": 46143}
{"snippet": "pandas.read_gbq(query, index_col=None)", "intent": "Load data from Google BigQuery . With arguments `query`, `index_col`.", "question_id": 46144}
{"snippet": "pandas.read_gbq(query, col_order=None)", "intent": "Load data from Google BigQuery . With arguments `query`, `col_order`.", "question_id": 46145}
{"snippet": "pandas.read_gbq(query, reauth=False)", "intent": "Load data from Google BigQuery . With arguments `query`, `reauth`.", "question_id": 46146}
{"snippet": "pandas.read_gbq(query, auth_local_webserver=False)", "intent": "Load data from Google BigQuery . With arguments `query`, `auth_local_webserver`.", "question_id": 46147}
{"snippet": "pandas.read_gbq(query, dialect=None)", "intent": "Load data from Google BigQuery . With arguments `query`, `dialect`.", "question_id": 46148}
{"snippet": "pandas.read_gbq(query, location=None)", "intent": "Load data from Google BigQuery . With arguments `query`, `location`.", "question_id": 46149}
{"snippet": "pandas.read_gbq(query, configuration=None)", "intent": "Load data from Google BigQuery . With arguments `query`, `configuration`.", "question_id": 46150}
{"snippet": "pandas.read_gbq(query, credentials=None)", "intent": "Load data from Google BigQuery . With arguments `query`, `credentials`.", "question_id": 46151}
{"snippet": "pandas.read_gbq(query)", "intent": "Load data from Google BigQuery . With arguments `query`.", "question_id": 46152}
{"snippet": "pandas.read_gbq(query, project_id=None)", "intent": "Load data from Google BigQuery . With arguments `query`, `project_id`.", "question_id": 46153}
{"snippet": "pandas.read_gbq(query, index_col=None)", "intent": "Load data from Google BigQuery . With arguments `query`, `index_col`.", "question_id": 46154}
{"snippet": "pandas.read_gbq(query, col_order=None)", "intent": "Load data from Google BigQuery . With arguments `query`, `col_order`.", "question_id": 46155}
{"snippet": "pandas.read_gbq(query, reauth=False)", "intent": "Load data from Google BigQuery . With arguments `query`, `reauth`.", "question_id": 46156}
{"snippet": "pandas.read_gbq(query, auth_local_webserver=False)", "intent": "Load data from Google BigQuery . With arguments `query`, `auth_local_webserver`.", "question_id": 46157}
{"snippet": "pandas.read_gbq(query, dialect=None)", "intent": "Load data from Google BigQuery . With arguments `query`, `dialect`.", "question_id": 46158}
{"snippet": "pandas.read_gbq(query, location=None)", "intent": "Load data from Google BigQuery . With arguments `query`, `location`.", "question_id": 46159}
{"snippet": "pandas.read_gbq(query, configuration=None)", "intent": "Load data from Google BigQuery . With arguments `query`, `configuration`.", "question_id": 46160}
{"snippet": "pandas.read_gbq(query, credentials=None)", "intent": "Load data from Google BigQuery . With arguments `query`, `credentials`.", "question_id": 46161}
{"snippet": "pandas.read_gbq(query)", "intent": "Load data from Google BigQuery . With arguments `query`.", "question_id": 46162}
{"snippet": "pandas.read_gbq(query, project_id=None)", "intent": "Load data from Google BigQuery . With arguments `query`, `project_id`.", "question_id": 46163}
{"snippet": "pandas.read_gbq(query, index_col=None)", "intent": "Load data from Google BigQuery . With arguments `query`, `index_col`.", "question_id": 46164}
{"snippet": "pandas.read_gbq(query, col_order=None)", "intent": "Load data from Google BigQuery . With arguments `query`, `col_order`.", "question_id": 46165}
{"snippet": "pandas.read_gbq(query, reauth=False)", "intent": "Load data from Google BigQuery . With arguments `query`, `reauth`.", "question_id": 46166}
{"snippet": "pandas.read_gbq(query, auth_local_webserver=False)", "intent": "Load data from Google BigQuery . With arguments `query`, `auth_local_webserver`.", "question_id": 46167}
{"snippet": "pandas.read_gbq(query, dialect=None)", "intent": "Load data from Google BigQuery . With arguments `query`, `dialect`.", "question_id": 46168}
{"snippet": "pandas.read_gbq(query, location=None)", "intent": "Load data from Google BigQuery . With arguments `query`, `location`.", "question_id": 46169}
{"snippet": "pandas.read_gbq(query, configuration=None)", "intent": "Load data from Google BigQuery . With arguments `query`, `configuration`.", "question_id": 46170}
{"snippet": "pandas.read_gbq(query, credentials=None)", "intent": "Load data from Google BigQuery . With arguments `query`, `credentials`.", "question_id": 46171}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs)", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`.", "question_id": 46172}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, key=None)", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`, `key`.", "question_id": 46173}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, mode='r')", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`, `mode`.", "question_id": 46174}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, errors='strict')", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`, `errors`.", "question_id": 46175}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, where=None)", "intent": "Read from the store , close it if we opened it . Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `path_or_buf`, `**kwargs`.", "question_id": 46176}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, start=None)", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`, `start`.", "question_id": 46177}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, stop=None)", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`, `stop`.", "question_id": 46178}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, columns=None)", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`, `columns`.", "question_id": 46179}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, iterator=False)", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`, `iterator`.", "question_id": 46180}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, chunksize=None)", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`, `chunksize`.", "question_id": 46181}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs)", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`.", "question_id": 46182}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, key=None)", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`, `key`.", "question_id": 46183}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, mode='r')", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`, `mode`.", "question_id": 46184}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, errors='strict')", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`, `errors`.", "question_id": 46185}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, where=None)", "intent": "Read from the store , close it if we opened it . Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `path_or_buf`, `**kwargs`.", "question_id": 46186}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, start=None)", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`, `start`.", "question_id": 46187}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, stop=None)", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`, `stop`.", "question_id": 46188}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, columns=None)", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`, `columns`.", "question_id": 46189}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, iterator=False)", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`, `iterator`.", "question_id": 46190}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, chunksize=None)", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`, `chunksize`.", "question_id": 46191}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs)", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`.", "question_id": 46192}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, key=None)", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`, `key`.", "question_id": 46193}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, mode='r')", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`, `mode`.", "question_id": 46194}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, errors='strict')", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`, `errors`.", "question_id": 46195}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, where=None)", "intent": "Read from the store , close it if we opened it . Retrieve pandas object stored in file , optionally based on `where` criteria . With arguments `path_or_buf`, `**kwargs`.", "question_id": 46196}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, start=None)", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`, `start`.", "question_id": 46197}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, stop=None)", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`, `stop`.", "question_id": 46198}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, columns=None)", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`, `columns`.", "question_id": 46199}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, iterator=False)", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`, `iterator`.", "question_id": 46200}
{"snippet": "pandas.read_hdf(path_or_buf, **kwargs, chunksize=None)", "intent": "Read from the store , close it if we opened it . With arguments `path_or_buf`, `**kwargs`, `chunksize`.", "question_id": 46201}
{"snippet": "pandas.read_html(io)", "intent": "Read HTML tables into a list of DataFrame objects . With arguments `io`.", "question_id": 46202}
{"snippet": "pandas.read_html(io, match='.+')", "intent": "Read HTML tables into a list of DataFrame objects . With arguments `io`, `match`.", "question_id": 46203}
{"snippet": "pandas.read_html(io, flavor=None)", "intent": "Read HTML tables into a list of DataFrame objects . With arguments `io`, `flavor`.", "question_id": 46204}
{"snippet": "pandas.read_html(io, header=None)", "intent": "Read HTML tables into a list of DataFrame objects . If the function has a < thead > argument , it is used to construct the `header` , otherwise the function attempts to find the header within the body ( by putting rows with only < th > elements into the header ) . With arguments `io`.", "question_id": 46205}
{"snippet": "pandas.read_html(io, index_col=None)", "intent": "Read HTML tables into a list of DataFrame objects . With arguments `io`, `index_col`.", "question_id": 46206}
{"snippet": "pandas.read_html(io, skiprows=None)", "intent": "Read HTML tables into a list of DataFrame objects . Similar to read_csv ( ) the header argument is applied after `skiprows` is applied . With arguments `io`.", "question_id": 46207}
{"snippet": "pandas.read_html(io, attrs=None)", "intent": "Read HTML tables into a list of DataFrame objects . With arguments `io`, `attrs`.", "question_id": 46208}
{"snippet": "pandas.read_html(io, parse_dates=False)", "intent": "Read HTML tables into a list of DataFrame objects . With arguments `io`, `parse_dates`.", "question_id": 46209}
{"snippet": "pandas.read_html(io, thousands=',')", "intent": "Read HTML tables into a list of DataFrame objects . With arguments `io`, `thousands`.", "question_id": 46210}
{"snippet": "pandas.read_html(io, encoding=None)", "intent": "Read HTML tables into a list of DataFrame objects . With arguments `io`, `encoding`.", "question_id": 46211}
{"snippet": "pandas.read_html(io)", "intent": "Read HTML tables into a list of DataFrame objects . With arguments `io`.", "question_id": 46212}
{"snippet": "pandas.read_html(io, match='.+')", "intent": "Read HTML tables into a list of DataFrame objects . With arguments `io`, `match`.", "question_id": 46213}
{"snippet": "pandas.read_html(io, flavor=None)", "intent": "Read HTML tables into a list of DataFrame objects . With arguments `io`, `flavor`.", "question_id": 46214}
{"snippet": "pandas.read_html(io, header=None)", "intent": "Read HTML tables into a list of DataFrame objects . If the function has a < thead > argument , it is used to construct the `header` , otherwise the function attempts to find the header within the body ( by putting rows with only < th > elements into the header ) . With arguments `io`.", "question_id": 46215}
{"snippet": "pandas.read_html(io, index_col=None)", "intent": "Read HTML tables into a list of DataFrame objects . With arguments `io`, `index_col`.", "question_id": 46216}
{"snippet": "pandas.read_html(io, skiprows=None)", "intent": "Read HTML tables into a list of DataFrame objects . Similar to read_csv ( ) the header argument is applied after `skiprows` is applied . With arguments `io`.", "question_id": 46217}
{"snippet": "pandas.read_html(io, attrs=None)", "intent": "Read HTML tables into a list of DataFrame objects . With arguments `io`, `attrs`.", "question_id": 46218}
{"snippet": "pandas.read_html(io, parse_dates=False)", "intent": "Read HTML tables into a list of DataFrame objects . With arguments `io`, `parse_dates`.", "question_id": 46219}
{"snippet": "pandas.read_html(io, thousands=',')", "intent": "Read HTML tables into a list of DataFrame objects . With arguments `io`, `thousands`.", "question_id": 46220}
{"snippet": "pandas.read_html(io, encoding=None)", "intent": "Read HTML tables into a list of DataFrame objects . With arguments `io`, `encoding`.", "question_id": 46221}
{"snippet": "pandas.read_html(io)", "intent": "Read HTML tables into a list of DataFrame objects . With arguments `io`.", "question_id": 46222}
{"snippet": "pandas.read_html(io, match='.+')", "intent": "Read HTML tables into a list of DataFrame objects . With arguments `io`, `match`.", "question_id": 46223}
{"snippet": "pandas.read_html(io, flavor=None)", "intent": "Read HTML tables into a list of DataFrame objects . With arguments `io`, `flavor`.", "question_id": 46224}
{"snippet": "pandas.read_html(io, header=None)", "intent": "Read HTML tables into a list of DataFrame objects . If the function has a < thead > argument , it is used to construct the `header` , otherwise the function attempts to find the header within the body ( by putting rows with only < th > elements into the header ) . With arguments `io`.", "question_id": 46225}
{"snippet": "pandas.read_html(io, index_col=None)", "intent": "Read HTML tables into a list of DataFrame objects . With arguments `io`, `index_col`.", "question_id": 46226}
{"snippet": "pandas.read_html(io, skiprows=None)", "intent": "Read HTML tables into a list of DataFrame objects . Similar to read_csv ( ) the header argument is applied after `skiprows` is applied . With arguments `io`.", "question_id": 46227}
{"snippet": "pandas.read_html(io, attrs=None)", "intent": "Read HTML tables into a list of DataFrame objects . With arguments `io`, `attrs`.", "question_id": 46228}
{"snippet": "pandas.read_html(io, parse_dates=False)", "intent": "Read HTML tables into a list of DataFrame objects . With arguments `io`, `parse_dates`.", "question_id": 46229}
{"snippet": "pandas.read_html(io, thousands=',')", "intent": "Read HTML tables into a list of DataFrame objects . With arguments `io`, `thousands`.", "question_id": 46230}
{"snippet": "pandas.read_html(io, encoding=None)", "intent": "Read HTML tables into a list of DataFrame objects . With arguments `io`, `encoding`.", "question_id": 46231}
{"snippet": "pandas.read_orc(path, **kwargs)", "intent": "Load an ORC object from the file `path` , returning a DataFrame . With arguments `**kwargs`.", "question_id": 46232}
{"snippet": "pandas.read_orc(path, **kwargs, columns=None)", "intent": "Load an ORC object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `columns`.", "question_id": 46233}
{"snippet": "pandas.read_orc(path, **kwargs)", "intent": "Load an ORC object from the file `path` , returning a DataFrame . With arguments `**kwargs`.", "question_id": 46234}
{"snippet": "pandas.read_orc(path, **kwargs, columns=None)", "intent": "Load an ORC object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `columns`.", "question_id": 46235}
{"snippet": "pandas.read_orc(path, **kwargs)", "intent": "Load an ORC object from the file `path` , returning a DataFrame . With arguments `**kwargs`.", "question_id": 46236}
{"snippet": "pandas.read_orc(path, **kwargs, columns=None)", "intent": "Load an ORC object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `columns`.", "question_id": 46237}
{"snippet": "pandas.read_parquet(path, **kwargs)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`.", "question_id": 46238}
{"snippet": "pandas.read_parquet(path, **kwargs, engine='auto')", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `engine`.", "question_id": 46239}
{"snippet": "pandas.read_parquet(path, **kwargs, columns=None)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `columns`.", "question_id": 46240}
{"snippet": "pandas.read_parquet(path, **kwargs, storage_options=None)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `storage_options`.", "question_id": 46241}
{"snippet": "pandas.read_parquet(path, **kwargs, use_nullable_dtypes=False)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `use_nullable_dtypes`.", "question_id": 46242}
{"snippet": "pandas.read_parquet(path, **kwargs, engine='auto', columns=None)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `engine`, `columns`.", "question_id": 46243}
{"snippet": "pandas.read_parquet(path, **kwargs, engine='auto', storage_options=None)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `engine`, `storage_options`.", "question_id": 46244}
{"snippet": "pandas.read_parquet(path, **kwargs, engine='auto', use_nullable_dtypes=False)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `engine`, `use_nullable_dtypes`.", "question_id": 46245}
{"snippet": "pandas.read_parquet(path, **kwargs, columns=None, storage_options=None)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `columns`, `storage_options`.", "question_id": 46246}
{"snippet": "pandas.read_parquet(path, **kwargs, columns=None, use_nullable_dtypes=False)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `columns`, `use_nullable_dtypes`.", "question_id": 46247}
{"snippet": "pandas.read_parquet(path, **kwargs)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`.", "question_id": 46248}
{"snippet": "pandas.read_parquet(path, **kwargs, engine='auto')", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `engine`.", "question_id": 46249}
{"snippet": "pandas.read_parquet(path, **kwargs, columns=None)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `columns`.", "question_id": 46250}
{"snippet": "pandas.read_parquet(path, **kwargs, storage_options=None)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `storage_options`.", "question_id": 46251}
{"snippet": "pandas.read_parquet(path, **kwargs, use_nullable_dtypes=False)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `use_nullable_dtypes`.", "question_id": 46252}
{"snippet": "pandas.read_parquet(path, **kwargs, engine='auto', columns=None)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `engine`, `columns`.", "question_id": 46253}
{"snippet": "pandas.read_parquet(path, **kwargs, engine='auto', storage_options=None)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `engine`, `storage_options`.", "question_id": 46254}
{"snippet": "pandas.read_parquet(path, **kwargs, engine='auto', use_nullable_dtypes=False)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `engine`, `use_nullable_dtypes`.", "question_id": 46255}
{"snippet": "pandas.read_parquet(path, **kwargs, columns=None, storage_options=None)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `columns`, `storage_options`.", "question_id": 46256}
{"snippet": "pandas.read_parquet(path, **kwargs, columns=None, use_nullable_dtypes=False)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `columns`, `use_nullable_dtypes`.", "question_id": 46257}
{"snippet": "pandas.read_parquet(path, **kwargs)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`.", "question_id": 46258}
{"snippet": "pandas.read_parquet(path, **kwargs, engine='auto')", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `engine`.", "question_id": 46259}
{"snippet": "pandas.read_parquet(path, **kwargs, columns=None)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `columns`.", "question_id": 46260}
{"snippet": "pandas.read_parquet(path, **kwargs, storage_options=None)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `storage_options`.", "question_id": 46261}
{"snippet": "pandas.read_parquet(path, **kwargs, use_nullable_dtypes=False)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `use_nullable_dtypes`.", "question_id": 46262}
{"snippet": "pandas.read_parquet(path, **kwargs, engine='auto', columns=None)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `engine`, `columns`.", "question_id": 46263}
{"snippet": "pandas.read_parquet(path, **kwargs, engine='auto', storage_options=None)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `engine`, `storage_options`.", "question_id": 46264}
{"snippet": "pandas.read_parquet(path, **kwargs, engine='auto', use_nullable_dtypes=False)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `engine`, `use_nullable_dtypes`.", "question_id": 46265}
{"snippet": "pandas.read_parquet(path, **kwargs, columns=None, storage_options=None)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `columns`, `storage_options`.", "question_id": 46266}
{"snippet": "pandas.read_parquet(path, **kwargs, columns=None, use_nullable_dtypes=False)", "intent": "Load a parquet object from the file `path` , returning a DataFrame . With arguments `**kwargs`, `columns`, `use_nullable_dtypes`.", "question_id": 46267}
{"snippet": "pandas.read_pickle(filepath_or_buffer)", "intent": "Load pickled pandas object ( or any object ) from file . With arguments `filepath_or_buffer`.", "question_id": 46268}
{"snippet": "pandas.read_pickle(filepath_or_buffer, compression='infer')", "intent": "Load pickled pandas object ( or any object ) from file . With arguments `filepath_or_buffer`, `compression`.", "question_id": 46269}
{"snippet": "pandas.read_pickle(filepath_or_buffer, storage_options=None)", "intent": "Load pickled pandas object ( or any object ) from file . With arguments `filepath_or_buffer`, `storage_options`.", "question_id": 46270}
{"snippet": "pandas.read_pickle(filepath_or_buffer, compression='infer', storage_options=None)", "intent": "Load pickled pandas object ( or any object ) from file . With arguments `filepath_or_buffer`, `compression`, `storage_options`.", "question_id": 46271}
{"snippet": "pandas.read_pickle(filepath_or_buffer)", "intent": "Load pickled pandas object ( or any object ) from file . With arguments `filepath_or_buffer`.", "question_id": 46272}
{"snippet": "pandas.read_pickle(filepath_or_buffer, compression='infer')", "intent": "Load pickled pandas object ( or any object ) from file . With arguments `filepath_or_buffer`, `compression`.", "question_id": 46273}
{"snippet": "pandas.read_pickle(filepath_or_buffer, storage_options=None)", "intent": "Load pickled pandas object ( or any object ) from file . With arguments `filepath_or_buffer`, `storage_options`.", "question_id": 46274}
{"snippet": "pandas.read_pickle(filepath_or_buffer, compression='infer', storage_options=None)", "intent": "Load pickled pandas object ( or any object ) from file . With arguments `filepath_or_buffer`, `compression`, `storage_options`.", "question_id": 46275}
{"snippet": "pandas.read_pickle(filepath_or_buffer)", "intent": "Load pickled pandas object ( or any object ) from file . With arguments `filepath_or_buffer`.", "question_id": 46276}
{"snippet": "pandas.read_pickle(filepath_or_buffer, compression='infer')", "intent": "Load pickled pandas object ( or any object ) from file . With arguments `filepath_or_buffer`, `compression`.", "question_id": 46277}
{"snippet": "pandas.read_pickle(filepath_or_buffer, storage_options=None)", "intent": "Load pickled pandas object ( or any object ) from file . With arguments `filepath_or_buffer`, `storage_options`.", "question_id": 46278}
{"snippet": "pandas.read_pickle(filepath_or_buffer, compression='infer', storage_options=None)", "intent": "Load pickled pandas object ( or any object ) from file . With arguments `filepath_or_buffer`, `compression`, `storage_options`.", "question_id": 46279}
{"snippet": "pandas.read_sas(filepath_or_buffer)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`.", "question_id": 46280}
{"snippet": "pandas.read_sas(filepath_or_buffer, format=None)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`.", "question_id": 46281}
{"snippet": "pandas.read_sas(filepath_or_buffer, index=None)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`, `index`.", "question_id": 46282}
{"snippet": "pandas.read_sas(filepath_or_buffer, encoding=None)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`, `encoding`.", "question_id": 46283}
{"snippet": "pandas.read_sas(filepath_or_buffer, chunksize=None)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`, `chunksize`.", "question_id": 46284}
{"snippet": "pandas.read_sas(filepath_or_buffer, iterator=False)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`, `iterator`.", "question_id": 46285}
{"snippet": "pandas.read_sas(filepath_or_buffer, format=None, index=None)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`, `index`.", "question_id": 46286}
{"snippet": "pandas.read_sas(filepath_or_buffer, format=None, encoding=None)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`, `encoding`.", "question_id": 46287}
{"snippet": "pandas.read_sas(filepath_or_buffer, format=None, chunksize=None)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`, `chunksize`.", "question_id": 46288}
{"snippet": "pandas.read_sas(filepath_or_buffer, format=None, iterator=False)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`, `iterator`.", "question_id": 46289}
{"snippet": "pandas.read_sas(filepath_or_buffer)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`.", "question_id": 46290}
{"snippet": "pandas.read_sas(filepath_or_buffer, format=None)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`.", "question_id": 46291}
{"snippet": "pandas.read_sas(filepath_or_buffer, index=None)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`, `index`.", "question_id": 46292}
{"snippet": "pandas.read_sas(filepath_or_buffer, encoding=None)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`, `encoding`.", "question_id": 46293}
{"snippet": "pandas.read_sas(filepath_or_buffer, chunksize=None)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`, `chunksize`.", "question_id": 46294}
{"snippet": "pandas.read_sas(filepath_or_buffer, iterator=False)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`, `iterator`.", "question_id": 46295}
{"snippet": "pandas.read_sas(filepath_or_buffer, format=None, index=None)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`, `index`.", "question_id": 46296}
{"snippet": "pandas.read_sas(filepath_or_buffer, format=None, encoding=None)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`, `encoding`.", "question_id": 46297}
{"snippet": "pandas.read_sas(filepath_or_buffer, format=None, chunksize=None)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`, `chunksize`.", "question_id": 46298}
{"snippet": "pandas.read_sas(filepath_or_buffer, format=None, iterator=False)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`, `iterator`.", "question_id": 46299}
{"snippet": "pandas.read_sas(filepath_or_buffer)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`.", "question_id": 46300}
{"snippet": "pandas.read_sas(filepath_or_buffer, format=None)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`.", "question_id": 46301}
{"snippet": "pandas.read_sas(filepath_or_buffer, index=None)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`, `index`.", "question_id": 46302}
{"snippet": "pandas.read_sas(filepath_or_buffer, encoding=None)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`, `encoding`.", "question_id": 46303}
{"snippet": "pandas.read_sas(filepath_or_buffer, chunksize=None)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`, `chunksize`.", "question_id": 46304}
{"snippet": "pandas.read_sas(filepath_or_buffer, iterator=False)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`, `iterator`.", "question_id": 46305}
{"snippet": "pandas.read_sas(filepath_or_buffer, format=None, index=None)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`, `index`.", "question_id": 46306}
{"snippet": "pandas.read_sas(filepath_or_buffer, format=None, encoding=None)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`, `encoding`.", "question_id": 46307}
{"snippet": "pandas.read_sas(filepath_or_buffer, format=None, chunksize=None)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`, `chunksize`.", "question_id": 46308}
{"snippet": "pandas.read_sas(filepath_or_buffer, format=None, iterator=False)", "intent": "Read SAS files stored as either XPORT or SAS7BDAT `format` files . With arguments `filepath_or_buffer`, `iterator`.", "question_id": 46309}
{"snippet": "pandas.read_spss(path)", "intent": "Load an SPSS file from the file `path` , returning a DataFrame .", "question_id": 46310}
{"snippet": "pandas.read_spss(path, usecols=None)", "intent": "Load an SPSS file from the file `path` , returning a DataFrame . With arguments `usecols`.", "question_id": 46311}
{"snippet": "pandas.read_spss(path, convert_categoricals=True)", "intent": "Load an SPSS file from the file `path` , returning a DataFrame . With arguments `convert_categoricals`.", "question_id": 46312}
{"snippet": "pandas.read_spss(path, usecols=None, convert_categoricals=True)", "intent": "Load an SPSS file from the file `path` , returning a DataFrame . With arguments `usecols`, `convert_categoricals`.", "question_id": 46313}
{"snippet": "pandas.read_spss(path)", "intent": "Load an SPSS file from the file `path` , returning a DataFrame .", "question_id": 46314}
{"snippet": "pandas.read_spss(path, usecols=None)", "intent": "Load an SPSS file from the file `path` , returning a DataFrame . With arguments `usecols`.", "question_id": 46315}
{"snippet": "pandas.read_spss(path, convert_categoricals=True)", "intent": "Load an SPSS file from the file `path` , returning a DataFrame . With arguments `convert_categoricals`.", "question_id": 46316}
{"snippet": "pandas.read_spss(path, usecols=None, convert_categoricals=True)", "intent": "Load an SPSS file from the file `path` , returning a DataFrame . With arguments `usecols`, `convert_categoricals`.", "question_id": 46317}
{"snippet": "pandas.read_spss(path)", "intent": "Load an SPSS file from the file `path` , returning a DataFrame .", "question_id": 46318}
{"snippet": "pandas.read_spss(path, usecols=None)", "intent": "Load an SPSS file from the file `path` , returning a DataFrame . With arguments `usecols`.", "question_id": 46319}
{"snippet": "pandas.read_spss(path, convert_categoricals=True)", "intent": "Load an SPSS file from the file `path` , returning a DataFrame . With arguments `convert_categoricals`.", "question_id": 46320}
{"snippet": "pandas.read_spss(path, usecols=None, convert_categoricals=True)", "intent": "Load an SPSS file from the file `path` , returning a DataFrame . With arguments `usecols`, `convert_categoricals`.", "question_id": 46321}
{"snippet": "pandas.read_sql(sql, con)", "intent": "Read SQL query or database table into a DataFrame . With arguments `sql`, `con`.", "question_id": 46322}
{"snippet": "pandas.read_sql(sql, con, index_col=None)", "intent": "Read SQL query or database table into a DataFrame . With arguments `sql`, `con`, `index_col`.", "question_id": 46323}
{"snippet": "pandas.read_sql(sql, con, coerce_float=True)", "intent": "Read SQL query or database table into a DataFrame . With arguments `sql`, `con`, `coerce_float`.", "question_id": 46324}
{"snippet": "pandas.read_sql(sql, con, params=None)", "intent": "Read SQL query or database table into a DataFrame . With arguments `sql`, `con`, `params`.", "question_id": 46325}
{"snippet": "pandas.read_sql(sql, con, parse_dates=None)", "intent": "Read SQL query or database table into a DataFrame . Apply date parsing to `columns` through the `parse_dates` argument With arguments `sql`, `con`.", "question_id": 46326}
{"snippet": "pandas.read_sql(sql, con, columns=None)", "intent": "Read SQL query or database table into a DataFrame . Apply date parsing to `columns` through the `parse_dates` argument With arguments `sql`, `con`.", "question_id": 46327}
{"snippet": "pandas.read_sql(sql, con, chunksize=None)", "intent": "Read SQL query or database table into a DataFrame . With arguments `sql`, `con`, `chunksize`.", "question_id": 46328}
{"snippet": "pandas.read_sql(sql, con, index_col=None, coerce_float=True)", "intent": "Read SQL query or database table into a DataFrame . With arguments `sql`, `con`, `index_col`, `coerce_float`.", "question_id": 46329}
{"snippet": "pandas.read_sql(sql, con, index_col=None, params=None)", "intent": "Read SQL query or database table into a DataFrame . With arguments `sql`, `con`, `index_col`, `params`.", "question_id": 46330}
{"snippet": "pandas.read_sql(sql, con, index_col=None, parse_dates=None)", "intent": "Read SQL query or database table into a DataFrame . Apply date parsing to `columns` through the `parse_dates` argument With arguments `sql`, `con`, `index_col`.", "question_id": 46331}
{"snippet": "pandas.read_sql(sql, con)", "intent": "Read SQL query or database table into a DataFrame . With arguments `sql`, `con`.", "question_id": 46332}
{"snippet": "pandas.read_sql(sql, con, index_col=None)", "intent": "Read SQL query or database table into a DataFrame . With arguments `sql`, `con`, `index_col`.", "question_id": 46333}
{"snippet": "pandas.read_sql(sql, con, coerce_float=True)", "intent": "Read SQL query or database table into a DataFrame . With arguments `sql`, `con`, `coerce_float`.", "question_id": 46334}
{"snippet": "pandas.read_sql(sql, con, params=None)", "intent": "Read SQL query or database table into a DataFrame . With arguments `sql`, `con`, `params`.", "question_id": 46335}
{"snippet": "pandas.read_sql(sql, con, parse_dates=None)", "intent": "Read SQL query or database table into a DataFrame . Apply date parsing to `columns` through the `parse_dates` argument With arguments `sql`, `con`.", "question_id": 46336}
{"snippet": "pandas.read_sql(sql, con, columns=None)", "intent": "Read SQL query or database table into a DataFrame . Apply date parsing to `columns` through the `parse_dates` argument With arguments `sql`, `con`.", "question_id": 46337}
{"snippet": "pandas.read_sql(sql, con, chunksize=None)", "intent": "Read SQL query or database table into a DataFrame . With arguments `sql`, `con`, `chunksize`.", "question_id": 46338}
{"snippet": "pandas.read_sql(sql, con, index_col=None, coerce_float=True)", "intent": "Read SQL query or database table into a DataFrame . With arguments `sql`, `con`, `index_col`, `coerce_float`.", "question_id": 46339}
{"snippet": "pandas.read_sql(sql, con, index_col=None, params=None)", "intent": "Read SQL query or database table into a DataFrame . With arguments `sql`, `con`, `index_col`, `params`.", "question_id": 46340}
{"snippet": "pandas.read_sql(sql, con, index_col=None, parse_dates=None)", "intent": "Read SQL query or database table into a DataFrame . Apply date parsing to `columns` through the `parse_dates` argument With arguments `sql`, `con`, `index_col`.", "question_id": 46341}
{"snippet": "pandas.read_sql(sql, con)", "intent": "Read SQL query or database table into a DataFrame . With arguments `sql`, `con`.", "question_id": 46342}
{"snippet": "pandas.read_sql(sql, con, index_col=None)", "intent": "Read SQL query or database table into a DataFrame . With arguments `sql`, `con`, `index_col`.", "question_id": 46343}
{"snippet": "pandas.read_sql(sql, con, coerce_float=True)", "intent": "Read SQL query or database table into a DataFrame . With arguments `sql`, `con`, `coerce_float`.", "question_id": 46344}
{"snippet": "pandas.read_sql(sql, con, params=None)", "intent": "Read SQL query or database table into a DataFrame . With arguments `sql`, `con`, `params`.", "question_id": 46345}
{"snippet": "pandas.read_sql(sql, con, parse_dates=None)", "intent": "Read SQL query or database table into a DataFrame . Apply date parsing to `columns` through the `parse_dates` argument With arguments `sql`, `con`.", "question_id": 46346}
{"snippet": "pandas.read_sql(sql, con, columns=None)", "intent": "Read SQL query or database table into a DataFrame . Apply date parsing to `columns` through the `parse_dates` argument With arguments `sql`, `con`.", "question_id": 46347}
{"snippet": "pandas.read_sql(sql, con, chunksize=None)", "intent": "Read SQL query or database table into a DataFrame . With arguments `sql`, `con`, `chunksize`.", "question_id": 46348}
{"snippet": "pandas.read_sql(sql, con, index_col=None, coerce_float=True)", "intent": "Read SQL query or database table into a DataFrame . With arguments `sql`, `con`, `index_col`, `coerce_float`.", "question_id": 46349}
{"snippet": "pandas.read_sql(sql, con, index_col=None, params=None)", "intent": "Read SQL query or database table into a DataFrame . With arguments `sql`, `con`, `index_col`, `params`.", "question_id": 46350}
{"snippet": "pandas.read_sql(sql, con, index_col=None, parse_dates=None)", "intent": "Read SQL query or database table into a DataFrame . Apply date parsing to `columns` through the `parse_dates` argument With arguments `sql`, `con`, `index_col`.", "question_id": 46351}
{"snippet": "pandas.read_sql_query(sql, con)", "intent": "Read SQL query into a DataFrame . With arguments `sql`, `con`.", "question_id": 46352}
{"snippet": "pandas.read_sql_query(sql, con, index_col=None)", "intent": "Read SQL query into a DataFrame . Optionally provide an `index_col` parameter to use one of the columns as the index , otherwise default integer index will be used . With arguments `sql`, `con`.", "question_id": 46353}
{"snippet": "pandas.read_sql_query(sql, con, coerce_float=True)", "intent": "Read SQL query into a DataFrame . With arguments `sql`, `con`, `coerce_float`.", "question_id": 46354}
{"snippet": "pandas.read_sql_query(sql, con, params=None)", "intent": "Read SQL query into a DataFrame . With arguments `sql`, `con`, `params`.", "question_id": 46355}
{"snippet": "pandas.read_sql_query(sql, con, parse_dates=None)", "intent": "Read SQL query into a DataFrame . Any datetime values with time zone information parsed via the `parse_dates` parameter will be converted to UTC . With arguments `sql`, `con`.", "question_id": 46356}
{"snippet": "pandas.read_sql_query(sql, con, chunksize=None)", "intent": "Read SQL query into a DataFrame . With arguments `sql`, `con`, `chunksize`.", "question_id": 46357}
{"snippet": "pandas.read_sql_query(sql, con, dtype=None)", "intent": "Read SQL query into a DataFrame . With arguments `sql`, `con`, `dtype`.", "question_id": 46358}
{"snippet": "pandas.read_sql_query(sql, con, index_col=None, coerce_float=True)", "intent": "Read SQL query into a DataFrame . Optionally provide an `index_col` parameter to use one of the columns as the index , otherwise default integer index will be used . With arguments `sql`, `con`, `coerce_float`.", "question_id": 46359}
{"snippet": "pandas.read_sql_query(sql, con, index_col=None, params=None)", "intent": "Read SQL query into a DataFrame . Optionally provide an `index_col` parameter to use one of the columns as the index , otherwise default integer index will be used . With arguments `sql`, `con`, `params`.", "question_id": 46360}
{"snippet": "pandas.read_sql_query(sql, con, index_col=None, parse_dates=None)", "intent": "Read SQL query into a DataFrame . Optionally provide an `index_col` parameter to use one of the columns as the index , otherwise default integer index will be used . Any datetime values with time zone information parsed via the `parse_dates` parameter will be converted to UTC . With arguments `sql`, `con`.", "question_id": 46361}
{"snippet": "pandas.read_sql_query(sql, con)", "intent": "Read SQL query into a DataFrame . With arguments `sql`, `con`.", "question_id": 46362}
{"snippet": "pandas.read_sql_query(sql, con, index_col=None)", "intent": "Read SQL query into a DataFrame . Optionally provide an `index_col` parameter to use one of the columns as the index , otherwise default integer index will be used . With arguments `sql`, `con`.", "question_id": 46363}
{"snippet": "pandas.read_sql_query(sql, con, coerce_float=True)", "intent": "Read SQL query into a DataFrame . With arguments `sql`, `con`, `coerce_float`.", "question_id": 46364}
{"snippet": "pandas.read_sql_query(sql, con, params=None)", "intent": "Read SQL query into a DataFrame . With arguments `sql`, `con`, `params`.", "question_id": 46365}
{"snippet": "pandas.read_sql_query(sql, con, parse_dates=None)", "intent": "Read SQL query into a DataFrame . Any datetime values with time zone information parsed via the `parse_dates` parameter will be converted to UTC . With arguments `sql`, `con`.", "question_id": 46366}
{"snippet": "pandas.read_sql_query(sql, con, chunksize=None)", "intent": "Read SQL query into a DataFrame . With arguments `sql`, `con`, `chunksize`.", "question_id": 46367}
{"snippet": "pandas.read_sql_query(sql, con, dtype=None)", "intent": "Read SQL query into a DataFrame . With arguments `sql`, `con`, `dtype`.", "question_id": 46368}
{"snippet": "pandas.read_sql_query(sql, con, index_col=None, coerce_float=True)", "intent": "Read SQL query into a DataFrame . Optionally provide an `index_col` parameter to use one of the columns as the index , otherwise default integer index will be used . With arguments `sql`, `con`, `coerce_float`.", "question_id": 46369}
{"snippet": "pandas.read_sql_query(sql, con, index_col=None, params=None)", "intent": "Read SQL query into a DataFrame . Optionally provide an `index_col` parameter to use one of the columns as the index , otherwise default integer index will be used . With arguments `sql`, `con`, `params`.", "question_id": 46370}
{"snippet": "pandas.read_sql_query(sql, con, index_col=None, parse_dates=None)", "intent": "Read SQL query into a DataFrame . Optionally provide an `index_col` parameter to use one of the columns as the index , otherwise default integer index will be used . Any datetime values with time zone information parsed via the `parse_dates` parameter will be converted to UTC . With arguments `sql`, `con`.", "question_id": 46371}
{"snippet": "pandas.read_sql_query(sql, con)", "intent": "Read SQL query into a DataFrame . With arguments `sql`, `con`.", "question_id": 46372}
{"snippet": "pandas.read_sql_query(sql, con, index_col=None)", "intent": "Read SQL query into a DataFrame . Optionally provide an `index_col` parameter to use one of the columns as the index , otherwise default integer index will be used . With arguments `sql`, `con`.", "question_id": 46373}
{"snippet": "pandas.read_sql_query(sql, con, coerce_float=True)", "intent": "Read SQL query into a DataFrame . With arguments `sql`, `con`, `coerce_float`.", "question_id": 46374}
{"snippet": "pandas.read_sql_query(sql, con, params=None)", "intent": "Read SQL query into a DataFrame . With arguments `sql`, `con`, `params`.", "question_id": 46375}
{"snippet": "pandas.read_sql_query(sql, con, parse_dates=None)", "intent": "Read SQL query into a DataFrame . Any datetime values with time zone information parsed via the `parse_dates` parameter will be converted to UTC . With arguments `sql`, `con`.", "question_id": 46376}
{"snippet": "pandas.read_sql_query(sql, con, chunksize=None)", "intent": "Read SQL query into a DataFrame . With arguments `sql`, `con`, `chunksize`.", "question_id": 46377}
{"snippet": "pandas.read_sql_query(sql, con, dtype=None)", "intent": "Read SQL query into a DataFrame . With arguments `sql`, `con`, `dtype`.", "question_id": 46378}
{"snippet": "pandas.read_sql_query(sql, con, index_col=None, coerce_float=True)", "intent": "Read SQL query into a DataFrame . Optionally provide an `index_col` parameter to use one of the columns as the index , otherwise default integer index will be used . With arguments `sql`, `con`, `coerce_float`.", "question_id": 46379}
{"snippet": "pandas.read_sql_query(sql, con, index_col=None, params=None)", "intent": "Read SQL query into a DataFrame . Optionally provide an `index_col` parameter to use one of the columns as the index , otherwise default integer index will be used . With arguments `sql`, `con`, `params`.", "question_id": 46380}
{"snippet": "pandas.read_sql_query(sql, con, index_col=None, parse_dates=None)", "intent": "Read SQL query into a DataFrame . Optionally provide an `index_col` parameter to use one of the columns as the index , otherwise default integer index will be used . Any datetime values with time zone information parsed via the `parse_dates` parameter will be converted to UTC . With arguments `sql`, `con`.", "question_id": 46381}
{"snippet": "pandas.read_sql_table(table_name, con)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`.", "question_id": 46382}
{"snippet": "pandas.read_sql_table(table_name, con, schema=None)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `schema`.", "question_id": 46383}
{"snippet": "pandas.read_sql_table(table_name, con, index_col=None)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `index_col`.", "question_id": 46384}
{"snippet": "pandas.read_sql_table(table_name, con, coerce_float=True)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `coerce_float`.", "question_id": 46385}
{"snippet": "pandas.read_sql_table(table_name, con, parse_dates=None)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `parse_dates`.", "question_id": 46386}
{"snippet": "pandas.read_sql_table(table_name, con, columns=None)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `columns`.", "question_id": 46387}
{"snippet": "pandas.read_sql_table(table_name, con, chunksize=None)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `chunksize`.", "question_id": 46388}
{"snippet": "pandas.read_sql_table(table_name, con, schema=None, index_col=None)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `schema`, `index_col`.", "question_id": 46389}
{"snippet": "pandas.read_sql_table(table_name, con, schema=None, coerce_float=True)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `schema`, `coerce_float`.", "question_id": 46390}
{"snippet": "pandas.read_sql_table(table_name, con, schema=None, parse_dates=None)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `schema`, `parse_dates`.", "question_id": 46391}
{"snippet": "pandas.read_sql_table(table_name, con)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`.", "question_id": 46392}
{"snippet": "pandas.read_sql_table(table_name, con, schema=None)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `schema`.", "question_id": 46393}
{"snippet": "pandas.read_sql_table(table_name, con, index_col=None)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `index_col`.", "question_id": 46394}
{"snippet": "pandas.read_sql_table(table_name, con, coerce_float=True)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `coerce_float`.", "question_id": 46395}
{"snippet": "pandas.read_sql_table(table_name, con, parse_dates=None)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `parse_dates`.", "question_id": 46396}
{"snippet": "pandas.read_sql_table(table_name, con, columns=None)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `columns`.", "question_id": 46397}
{"snippet": "pandas.read_sql_table(table_name, con, chunksize=None)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `chunksize`.", "question_id": 46398}
{"snippet": "pandas.read_sql_table(table_name, con, schema=None, index_col=None)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `schema`, `index_col`.", "question_id": 46399}
{"snippet": "pandas.read_sql_table(table_name, con, schema=None, coerce_float=True)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `schema`, `coerce_float`.", "question_id": 46400}
{"snippet": "pandas.read_sql_table(table_name, con, schema=None, parse_dates=None)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `schema`, `parse_dates`.", "question_id": 46401}
{"snippet": "pandas.read_sql_table(table_name, con)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`.", "question_id": 46402}
{"snippet": "pandas.read_sql_table(table_name, con, schema=None)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `schema`.", "question_id": 46403}
{"snippet": "pandas.read_sql_table(table_name, con, index_col=None)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `index_col`.", "question_id": 46404}
{"snippet": "pandas.read_sql_table(table_name, con, coerce_float=True)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `coerce_float`.", "question_id": 46405}
{"snippet": "pandas.read_sql_table(table_name, con, parse_dates=None)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `parse_dates`.", "question_id": 46406}
{"snippet": "pandas.read_sql_table(table_name, con, columns=None)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `columns`.", "question_id": 46407}
{"snippet": "pandas.read_sql_table(table_name, con, chunksize=None)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `chunksize`.", "question_id": 46408}
{"snippet": "pandas.read_sql_table(table_name, con, schema=None, index_col=None)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `schema`, `index_col`.", "question_id": 46409}
{"snippet": "pandas.read_sql_table(table_name, con, schema=None, coerce_float=True)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `schema`, `coerce_float`.", "question_id": 46410}
{"snippet": "pandas.read_sql_table(table_name, con, schema=None, parse_dates=None)", "intent": "Read SQL database table into a DataFrame . With arguments `table_name`, `con`, `schema`, `parse_dates`.", "question_id": 46411}
{"snippet": "pandas.read_stata(filepath_or_buffer)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`.", "question_id": 46412}
{"snippet": "pandas.read_stata(filepath_or_buffer, convert_dates=True)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`, `convert_dates`.", "question_id": 46413}
{"snippet": "pandas.read_stata(filepath_or_buffer, convert_categoricals=True)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`, `convert_categoricals`.", "question_id": 46414}
{"snippet": "pandas.read_stata(filepath_or_buffer, index_col=None)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`, `index_col`.", "question_id": 46415}
{"snippet": "pandas.read_stata(filepath_or_buffer, convert_missing=False)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`, `convert_missing`.", "question_id": 46416}
{"snippet": "pandas.read_stata(filepath_or_buffer, preserve_dtypes=True)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`, `preserve_dtypes`.", "question_id": 46417}
{"snippet": "pandas.read_stata(filepath_or_buffer, columns=None)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`, `columns`.", "question_id": 46418}
{"snippet": "pandas.read_stata(filepath_or_buffer, order_categoricals=True)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`, `order_categoricals`.", "question_id": 46419}
{"snippet": "pandas.read_stata(filepath_or_buffer, chunksize=None)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`, `chunksize`.", "question_id": 46420}
{"snippet": "pandas.read_stata(filepath_or_buffer, iterator=False)", "intent": "Read Stata file into DataFrame . Categorical variables read through an `iterator` may not have the same categories and dtype . With arguments `filepath_or_buffer`.", "question_id": 46421}
{"snippet": "pandas.read_stata(filepath_or_buffer)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`.", "question_id": 46422}
{"snippet": "pandas.read_stata(filepath_or_buffer, convert_dates=True)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`, `convert_dates`.", "question_id": 46423}
{"snippet": "pandas.read_stata(filepath_or_buffer, convert_categoricals=True)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`, `convert_categoricals`.", "question_id": 46424}
{"snippet": "pandas.read_stata(filepath_or_buffer, index_col=None)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`, `index_col`.", "question_id": 46425}
{"snippet": "pandas.read_stata(filepath_or_buffer, convert_missing=False)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`, `convert_missing`.", "question_id": 46426}
{"snippet": "pandas.read_stata(filepath_or_buffer, preserve_dtypes=True)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`, `preserve_dtypes`.", "question_id": 46427}
{"snippet": "pandas.read_stata(filepath_or_buffer, columns=None)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`, `columns`.", "question_id": 46428}
{"snippet": "pandas.read_stata(filepath_or_buffer, order_categoricals=True)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`, `order_categoricals`.", "question_id": 46429}
{"snippet": "pandas.read_stata(filepath_or_buffer, chunksize=None)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`, `chunksize`.", "question_id": 46430}
{"snippet": "pandas.read_stata(filepath_or_buffer, iterator=False)", "intent": "Read Stata file into DataFrame . Categorical variables read through an `iterator` may not have the same categories and dtype . With arguments `filepath_or_buffer`.", "question_id": 46431}
{"snippet": "pandas.read_stata(filepath_or_buffer)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`.", "question_id": 46432}
{"snippet": "pandas.read_stata(filepath_or_buffer, convert_dates=True)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`, `convert_dates`.", "question_id": 46433}
{"snippet": "pandas.read_stata(filepath_or_buffer, convert_categoricals=True)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`, `convert_categoricals`.", "question_id": 46434}
{"snippet": "pandas.read_stata(filepath_or_buffer, index_col=None)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`, `index_col`.", "question_id": 46435}
{"snippet": "pandas.read_stata(filepath_or_buffer, convert_missing=False)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`, `convert_missing`.", "question_id": 46436}
{"snippet": "pandas.read_stata(filepath_or_buffer, preserve_dtypes=True)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`, `preserve_dtypes`.", "question_id": 46437}
{"snippet": "pandas.read_stata(filepath_or_buffer, columns=None)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`, `columns`.", "question_id": 46438}
{"snippet": "pandas.read_stata(filepath_or_buffer, order_categoricals=True)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`, `order_categoricals`.", "question_id": 46439}
{"snippet": "pandas.read_stata(filepath_or_buffer, chunksize=None)", "intent": "Read Stata file into DataFrame . With arguments `filepath_or_buffer`, `chunksize`.", "question_id": 46440}
{"snippet": "pandas.read_stata(filepath_or_buffer, iterator=False)", "intent": "Read Stata file into DataFrame . Categorical variables read through an `iterator` may not have the same categories and dtype . With arguments `filepath_or_buffer`.", "question_id": 46441}
{"snippet": "pandas.read_table(filepath_or_buffer)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`.", "question_id": 46442}
{"snippet": "pandas.read_table(filepath_or_buffer, sep=NoDefault.no_default)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `sep`.", "question_id": 46443}
{"snippet": "pandas.read_table(filepath_or_buffer, delimiter=None)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `delimiter`.", "question_id": 46444}
{"snippet": "pandas.read_table(filepath_or_buffer, header='infer')", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `header`.", "question_id": 46445}
{"snippet": "pandas.read_table(filepath_or_buffer, names=NoDefault.no_default)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `names`.", "question_id": 46446}
{"snippet": "pandas.read_table(filepath_or_buffer, index_col=None)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `index_col`.", "question_id": 46447}
{"snippet": "pandas.read_table(filepath_or_buffer, usecols=None)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `usecols`.", "question_id": 46448}
{"snippet": "pandas.read_table(filepath_or_buffer, squeeze=False)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `squeeze`.", "question_id": 46449}
{"snippet": "pandas.read_table(filepath_or_buffer, prefix=NoDefault.no_default)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `prefix`.", "question_id": 46450}
{"snippet": "pandas.read_table(filepath_or_buffer, mangle_dupe_cols=True)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `mangle_dupe_cols`.", "question_id": 46451}
{"snippet": "pandas.read_table(filepath_or_buffer)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`.", "question_id": 46452}
{"snippet": "pandas.read_table(filepath_or_buffer, sep=NoDefault.no_default)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `sep`.", "question_id": 46453}
{"snippet": "pandas.read_table(filepath_or_buffer, delimiter=None)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `delimiter`.", "question_id": 46454}
{"snippet": "pandas.read_table(filepath_or_buffer, header='infer')", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `header`.", "question_id": 46455}
{"snippet": "pandas.read_table(filepath_or_buffer, names=NoDefault.no_default)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `names`.", "question_id": 46456}
{"snippet": "pandas.read_table(filepath_or_buffer, index_col=None)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `index_col`.", "question_id": 46457}
{"snippet": "pandas.read_table(filepath_or_buffer, usecols=None)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `usecols`.", "question_id": 46458}
{"snippet": "pandas.read_table(filepath_or_buffer, squeeze=False)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `squeeze`.", "question_id": 46459}
{"snippet": "pandas.read_table(filepath_or_buffer, prefix=NoDefault.no_default)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `prefix`.", "question_id": 46460}
{"snippet": "pandas.read_table(filepath_or_buffer, mangle_dupe_cols=True)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `mangle_dupe_cols`.", "question_id": 46461}
{"snippet": "pandas.read_table(filepath_or_buffer)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`.", "question_id": 46462}
{"snippet": "pandas.read_table(filepath_or_buffer, sep=NoDefault.no_default)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `sep`.", "question_id": 46463}
{"snippet": "pandas.read_table(filepath_or_buffer, delimiter=None)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `delimiter`.", "question_id": 46464}
{"snippet": "pandas.read_table(filepath_or_buffer, header='infer')", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `header`.", "question_id": 46465}
{"snippet": "pandas.read_table(filepath_or_buffer, names=NoDefault.no_default)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `names`.", "question_id": 46466}
{"snippet": "pandas.read_table(filepath_or_buffer, index_col=None)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `index_col`.", "question_id": 46467}
{"snippet": "pandas.read_table(filepath_or_buffer, usecols=None)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `usecols`.", "question_id": 46468}
{"snippet": "pandas.read_table(filepath_or_buffer, squeeze=False)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `squeeze`.", "question_id": 46469}
{"snippet": "pandas.read_table(filepath_or_buffer, prefix=NoDefault.no_default)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `prefix`.", "question_id": 46470}
{"snippet": "pandas.read_table(filepath_or_buffer, mangle_dupe_cols=True)", "intent": "Read general delimited file into DataFrame . With arguments `filepath_or_buffer`, `mangle_dupe_cols`.", "question_id": 46471}
{"snippet": "pandas.read_xml(path_or_buffer)", "intent": "Read XML document into a DataFrame object . With arguments `path_or_buffer`.", "question_id": 46472}
{"snippet": "pandas.read_xml(path_or_buffer, xpath='./*')", "intent": "Read XML document into a DataFrame object . This function will always return a single DataFrame or raise exceptions due to issues with XML document , `xpath` , or other parameters . With arguments `path_or_buffer`.", "question_id": 46473}
{"snippet": "pandas.read_xml(path_or_buffer, namespaces=None)", "intent": "Read XML document into a DataFrame object . With arguments `path_or_buffer`, `namespaces`.", "question_id": 46474}
{"snippet": "pandas.read_xml(path_or_buffer, elems_only=False)", "intent": "Read XML document into a DataFrame object . With arguments `path_or_buffer`, `elems_only`.", "question_id": 46475}
{"snippet": "pandas.read_xml(path_or_buffer, attrs_only=False)", "intent": "Read XML document into a DataFrame object . With arguments `path_or_buffer`, `attrs_only`.", "question_id": 46476}
{"snippet": "pandas.read_xml(path_or_buffer, names=None)", "intent": "Read XML document into a DataFrame object . With arguments `path_or_buffer`, `names`.", "question_id": 46477}
{"snippet": "pandas.read_xml(path_or_buffer, encoding='utf-8')", "intent": "Read XML document into a DataFrame object . With arguments `path_or_buffer`, `encoding`.", "question_id": 46478}
{"snippet": "pandas.read_xml(path_or_buffer, parser='lxml')", "intent": "Read XML document into a DataFrame object . With arguments `path_or_buffer`, `parser`.", "question_id": 46479}
{"snippet": "pandas.read_xml(path_or_buffer, stylesheet=None)", "intent": "Read XML document into a DataFrame object . However , for more complex XML documents , `stylesheet` allows you to temporarily redesign original document with XSLT ( a special purpose language ) for a flatter version for migration to a DataFrame . With arguments `path_or_buffer`.", "question_id": 46480}
{"snippet": "pandas.read_xml(path_or_buffer, compression='infer')", "intent": "Read XML document into a DataFrame object . With arguments `path_or_buffer`, `compression`.", "question_id": 46481}
{"snippet": "pandas.read_xml(path_or_buffer)", "intent": "Read XML document into a DataFrame object . With arguments `path_or_buffer`.", "question_id": 46482}
{"snippet": "pandas.read_xml(path_or_buffer, xpath='./*')", "intent": "Read XML document into a DataFrame object . This function will always return a single DataFrame or raise exceptions due to issues with XML document , `xpath` , or other parameters . With arguments `path_or_buffer`.", "question_id": 46483}
{"snippet": "pandas.read_xml(path_or_buffer, namespaces=None)", "intent": "Read XML document into a DataFrame object . With arguments `path_or_buffer`, `namespaces`.", "question_id": 46484}
{"snippet": "pandas.read_xml(path_or_buffer, elems_only=False)", "intent": "Read XML document into a DataFrame object . With arguments `path_or_buffer`, `elems_only`.", "question_id": 46485}
{"snippet": "pandas.read_xml(path_or_buffer, attrs_only=False)", "intent": "Read XML document into a DataFrame object . With arguments `path_or_buffer`, `attrs_only`.", "question_id": 46486}
{"snippet": "pandas.read_xml(path_or_buffer, names=None)", "intent": "Read XML document into a DataFrame object . With arguments `path_or_buffer`, `names`.", "question_id": 46487}
{"snippet": "pandas.read_xml(path_or_buffer, encoding='utf-8')", "intent": "Read XML document into a DataFrame object . With arguments `path_or_buffer`, `encoding`.", "question_id": 46488}
{"snippet": "pandas.read_xml(path_or_buffer, parser='lxml')", "intent": "Read XML document into a DataFrame object . With arguments `path_or_buffer`, `parser`.", "question_id": 46489}
{"snippet": "pandas.read_xml(path_or_buffer, stylesheet=None)", "intent": "Read XML document into a DataFrame object . However , for more complex XML documents , `stylesheet` allows you to temporarily redesign original document with XSLT ( a special purpose language ) for a flatter version for migration to a DataFrame . With arguments `path_or_buffer`.", "question_id": 46490}
{"snippet": "pandas.read_xml(path_or_buffer, compression='infer')", "intent": "Read XML document into a DataFrame object . With arguments `path_or_buffer`, `compression`.", "question_id": 46491}
{"snippet": "pandas.read_xml(path_or_buffer)", "intent": "Read XML document into a DataFrame object . With arguments `path_or_buffer`.", "question_id": 46492}
{"snippet": "pandas.read_xml(path_or_buffer, xpath='./*')", "intent": "Read XML document into a DataFrame object . This function will always return a single DataFrame or raise exceptions due to issues with XML document , `xpath` , or other parameters . With arguments `path_or_buffer`.", "question_id": 46493}
{"snippet": "pandas.read_xml(path_or_buffer, namespaces=None)", "intent": "Read XML document into a DataFrame object . With arguments `path_or_buffer`, `namespaces`.", "question_id": 46494}
{"snippet": "pandas.read_xml(path_or_buffer, elems_only=False)", "intent": "Read XML document into a DataFrame object . With arguments `path_or_buffer`, `elems_only`.", "question_id": 46495}
{"snippet": "pandas.read_xml(path_or_buffer, attrs_only=False)", "intent": "Read XML document into a DataFrame object . With arguments `path_or_buffer`, `attrs_only`.", "question_id": 46496}
{"snippet": "pandas.read_xml(path_or_buffer, names=None)", "intent": "Read XML document into a DataFrame object . With arguments `path_or_buffer`, `names`.", "question_id": 46497}
{"snippet": "pandas.read_xml(path_or_buffer, encoding='utf-8')", "intent": "Read XML document into a DataFrame object . With arguments `path_or_buffer`, `encoding`.", "question_id": 46498}
{"snippet": "pandas.read_xml(path_or_buffer, parser='lxml')", "intent": "Read XML document into a DataFrame object . With arguments `path_or_buffer`, `parser`.", "question_id": 46499}
{"snippet": "pandas.read_xml(path_or_buffer, stylesheet=None)", "intent": "Read XML document into a DataFrame object . However , for more complex XML documents , `stylesheet` allows you to temporarily redesign original document with XSLT ( a special purpose language ) for a flatter version for migration to a DataFrame . With arguments `path_or_buffer`.", "question_id": 46500}
{"snippet": "pandas.read_xml(path_or_buffer, compression='infer')", "intent": "Read XML document into a DataFrame object . With arguments `path_or_buffer`, `compression`.", "question_id": 46501}
{"snippet": "pandas.reset_option(pat)", "intent": "Reset one or more options to their default value . With arguments `pat`.", "question_id": 46502}
{"snippet": "pandas.reset_option(pat)", "intent": "Reset one or more options to their default value . With arguments `pat`.", "question_id": 46503}
{"snippet": "pandas.reset_option(pat)", "intent": "Reset one or more options to their default value . With arguments `pat`.", "question_id": 46504}
{"snippet": "pandas.set_option(pat, value)", "intent": "Sets the `value` of the specified option . With arguments `pat`.", "question_id": 46505}
{"snippet": "pandas.set_option(pat, value)", "intent": "Sets the `value` of the specified option . With arguments `pat`.", "question_id": 46506}
{"snippet": "pandas.set_option(pat, value)", "intent": "Sets the `value` of the specified option . With arguments `pat`.", "question_id": 46507}
{"snippet": "pandas.show_versions()", "intent": "Provide useful information , important for bug reports .", "question_id": 46508}
{"snippet": "pandas.show_versions(as_json=False)", "intent": "Provide useful information , important for bug reports . With arguments `as_json`.", "question_id": 46509}
{"snippet": "pandas.show_versions()", "intent": "Provide useful information , important for bug reports .", "question_id": 46510}
{"snippet": "pandas.show_versions(as_json=False)", "intent": "Provide useful information , important for bug reports . With arguments `as_json`.", "question_id": 46511}
{"snippet": "pandas.show_versions()", "intent": "Provide useful information , important for bug reports .", "question_id": 46512}
{"snippet": "pandas.show_versions(as_json=False)", "intent": "Provide useful information , important for bug reports . With arguments `as_json`.", "question_id": 46513}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right)", "intent": "Check that `left` and `right` ExtensionArrays are equal .", "question_id": 46514}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, check_dtype=True)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `check_dtype`.", "question_id": 46515}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, index_values=None)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `index_values`.", "question_id": 46516}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, check_less_precise=NoDefault.no_default)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `check_less_precise`.", "question_id": 46517}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, check_exact=False)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `check_exact`.", "question_id": 46518}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, rtol=1e-05)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `rtol`.", "question_id": 46519}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, atol=1e-08)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `atol`.", "question_id": 46520}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, check_dtype=True, index_values=None)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `check_dtype`, `index_values`.", "question_id": 46521}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, check_dtype=True, check_less_precise=NoDefault.no_default)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `check_dtype`, `check_less_precise`.", "question_id": 46522}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, check_dtype=True, check_exact=False)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `check_dtype`, `check_exact`.", "question_id": 46523}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right)", "intent": "Check that `left` and `right` ExtensionArrays are equal .", "question_id": 46524}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, check_dtype=True)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `check_dtype`.", "question_id": 46525}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, index_values=None)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `index_values`.", "question_id": 46526}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, check_less_precise=NoDefault.no_default)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `check_less_precise`.", "question_id": 46527}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, check_exact=False)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `check_exact`.", "question_id": 46528}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, rtol=1e-05)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `rtol`.", "question_id": 46529}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, atol=1e-08)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `atol`.", "question_id": 46530}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, check_dtype=True, index_values=None)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `check_dtype`, `index_values`.", "question_id": 46531}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, check_dtype=True, check_less_precise=NoDefault.no_default)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `check_dtype`, `check_less_precise`.", "question_id": 46532}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, check_dtype=True, check_exact=False)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `check_dtype`, `check_exact`.", "question_id": 46533}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right)", "intent": "Check that `left` and `right` ExtensionArrays are equal .", "question_id": 46534}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, check_dtype=True)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `check_dtype`.", "question_id": 46535}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, index_values=None)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `index_values`.", "question_id": 46536}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, check_less_precise=NoDefault.no_default)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `check_less_precise`.", "question_id": 46537}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, check_exact=False)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `check_exact`.", "question_id": 46538}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, rtol=1e-05)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `rtol`.", "question_id": 46539}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, atol=1e-08)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `atol`.", "question_id": 46540}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, check_dtype=True, index_values=None)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `check_dtype`, `index_values`.", "question_id": 46541}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, check_dtype=True, check_less_precise=NoDefault.no_default)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `check_dtype`, `check_less_precise`.", "question_id": 46542}
{"snippet": "pandas.testing.assert_extension_array_equal(left, right, check_dtype=True, check_exact=False)", "intent": "Check that `left` and `right` ExtensionArrays are equal . With arguments `check_dtype`, `check_exact`.", "question_id": 46543}
{"snippet": "pandas.testing.assert_frame_equal(left, right)", "intent": "Check that `left` and `right` DataFrame are equal .", "question_id": 46544}
{"snippet": "pandas.testing.assert_frame_equal(left, right, check_dtype=True)", "intent": "Check that `left` and `right` DataFrame are equal . Ignore differing dtypes in columns with `check_dtype` .", "question_id": 46545}
{"snippet": "pandas.testing.assert_frame_equal(left, right, check_index_type='equiv')", "intent": "Check that `left` and `right` DataFrame are equal . With arguments `check_index_type`.", "question_id": 46546}
{"snippet": "pandas.testing.assert_frame_equal(left, right, check_column_type='equiv')", "intent": "Check that `left` and `right` DataFrame are equal . With arguments `check_column_type`.", "question_id": 46547}
{"snippet": "pandas.testing.assert_frame_equal(left, right, check_frame_type=True)", "intent": "Check that `left` and `right` DataFrame are equal . With arguments `check_frame_type`.", "question_id": 46548}
{"snippet": "pandas.testing.assert_frame_equal(left, right, check_less_precise=NoDefault.no_default)", "intent": "Check that `left` and `right` DataFrame are equal . With arguments `check_less_precise`.", "question_id": 46549}
{"snippet": "pandas.testing.assert_frame_equal(left, right, check_names=True)", "intent": "Check that `left` and `right` DataFrame are equal . With arguments `check_names`.", "question_id": 46550}
{"snippet": "pandas.testing.assert_frame_equal(left, right, by_blocks=False)", "intent": "Check that `left` and `right` DataFrame are equal . With arguments `by_blocks`.", "question_id": 46551}
{"snippet": "pandas.testing.assert_frame_equal(left, right, check_exact=False)", "intent": "Check that `left` and `right` DataFrame are equal . With arguments `check_exact`.", "question_id": 46552}
{"snippet": "pandas.testing.assert_frame_equal(left, right, check_datetimelike_compat=False)", "intent": "Check that `left` and `right` DataFrame are equal . With arguments `check_datetimelike_compat`.", "question_id": 46553}
{"snippet": "pandas.testing.assert_frame_equal(left, right)", "intent": "Check that `left` and `right` DataFrame are equal .", "question_id": 46554}
{"snippet": "pandas.testing.assert_frame_equal(left, right, check_dtype=True)", "intent": "Check that `left` and `right` DataFrame are equal . Ignore differing dtypes in columns with `check_dtype` .", "question_id": 46555}
{"snippet": "pandas.testing.assert_frame_equal(left, right, check_index_type='equiv')", "intent": "Check that `left` and `right` DataFrame are equal . With arguments `check_index_type`.", "question_id": 46556}
{"snippet": "pandas.testing.assert_frame_equal(left, right, check_column_type='equiv')", "intent": "Check that `left` and `right` DataFrame are equal . With arguments `check_column_type`.", "question_id": 46557}
{"snippet": "pandas.testing.assert_frame_equal(left, right, check_frame_type=True)", "intent": "Check that `left` and `right` DataFrame are equal . With arguments `check_frame_type`.", "question_id": 46558}
{"snippet": "pandas.testing.assert_frame_equal(left, right, check_less_precise=NoDefault.no_default)", "intent": "Check that `left` and `right` DataFrame are equal . With arguments `check_less_precise`.", "question_id": 46559}
{"snippet": "pandas.testing.assert_frame_equal(left, right, check_names=True)", "intent": "Check that `left` and `right` DataFrame are equal . With arguments `check_names`.", "question_id": 46560}
{"snippet": "pandas.testing.assert_frame_equal(left, right, by_blocks=False)", "intent": "Check that `left` and `right` DataFrame are equal . With arguments `by_blocks`.", "question_id": 46561}
{"snippet": "pandas.testing.assert_frame_equal(left, right, check_exact=False)", "intent": "Check that `left` and `right` DataFrame are equal . With arguments `check_exact`.", "question_id": 46562}
{"snippet": "pandas.testing.assert_frame_equal(left, right, check_datetimelike_compat=False)", "intent": "Check that `left` and `right` DataFrame are equal . With arguments `check_datetimelike_compat`.", "question_id": 46563}
{"snippet": "pandas.testing.assert_frame_equal(left, right)", "intent": "Check that `left` and `right` DataFrame are equal .", "question_id": 46564}
{"snippet": "pandas.testing.assert_frame_equal(left, right, check_dtype=True)", "intent": "Check that `left` and `right` DataFrame are equal . Ignore differing dtypes in columns with `check_dtype` .", "question_id": 46565}
{"snippet": "pandas.testing.assert_frame_equal(left, right, check_index_type='equiv')", "intent": "Check that `left` and `right` DataFrame are equal . With arguments `check_index_type`.", "question_id": 46566}
{"snippet": "pandas.testing.assert_frame_equal(left, right, check_column_type='equiv')", "intent": "Check that `left` and `right` DataFrame are equal . With arguments `check_column_type`.", "question_id": 46567}
{"snippet": "pandas.testing.assert_frame_equal(left, right, check_frame_type=True)", "intent": "Check that `left` and `right` DataFrame are equal . With arguments `check_frame_type`.", "question_id": 46568}
{"snippet": "pandas.testing.assert_frame_equal(left, right, check_less_precise=NoDefault.no_default)", "intent": "Check that `left` and `right` DataFrame are equal . With arguments `check_less_precise`.", "question_id": 46569}
{"snippet": "pandas.testing.assert_frame_equal(left, right, check_names=True)", "intent": "Check that `left` and `right` DataFrame are equal . With arguments `check_names`.", "question_id": 46570}
{"snippet": "pandas.testing.assert_frame_equal(left, right, by_blocks=False)", "intent": "Check that `left` and `right` DataFrame are equal . With arguments `by_blocks`.", "question_id": 46571}
{"snippet": "pandas.testing.assert_frame_equal(left, right, check_exact=False)", "intent": "Check that `left` and `right` DataFrame are equal . With arguments `check_exact`.", "question_id": 46572}
{"snippet": "pandas.testing.assert_frame_equal(left, right, check_datetimelike_compat=False)", "intent": "Check that `left` and `right` DataFrame are equal . With arguments `check_datetimelike_compat`.", "question_id": 46573}
{"snippet": "pandas.testing.assert_index_equal(left, right)", "intent": "Check that `left` and `right` Index are equal .", "question_id": 46574}
{"snippet": "pandas.testing.assert_index_equal(left, right, exact='equiv')", "intent": "Check that `left` and `right` Index are equal . With arguments `exact`.", "question_id": 46575}
{"snippet": "pandas.testing.assert_index_equal(left, right, check_names=True)", "intent": "Check that `left` and `right` Index are equal . With arguments `check_names`.", "question_id": 46576}
{"snippet": "pandas.testing.assert_index_equal(left, right, check_less_precise=NoDefault.no_default)", "intent": "Check that `left` and `right` Index are equal . With arguments `check_less_precise`.", "question_id": 46577}
{"snippet": "pandas.testing.assert_index_equal(left, right, check_exact=True)", "intent": "Check that `left` and `right` Index are equal . With arguments `check_exact`.", "question_id": 46578}
{"snippet": "pandas.testing.assert_index_equal(left, right, check_categorical=True)", "intent": "Check that `left` and `right` Index are equal . With arguments `check_categorical`.", "question_id": 46579}
{"snippet": "pandas.testing.assert_index_equal(left, right, check_order=True)", "intent": "Check that `left` and `right` Index are equal . With arguments `check_order`.", "question_id": 46580}
{"snippet": "pandas.testing.assert_index_equal(left, right, rtol=1e-05)", "intent": "Check that `left` and `right` Index are equal . With arguments `rtol`.", "question_id": 46581}
{"snippet": "pandas.testing.assert_index_equal(left, right, atol=1e-08)", "intent": "Check that `left` and `right` Index are equal . With arguments `atol`.", "question_id": 46582}
{"snippet": "pandas.testing.assert_index_equal(left, right, obj='Index')", "intent": "Check that `left` and `right` Index are equal . With arguments `obj`.", "question_id": 46583}
{"snippet": "pandas.testing.assert_index_equal(left, right)", "intent": "Check that `left` and `right` Index are equal .", "question_id": 46584}
{"snippet": "pandas.testing.assert_index_equal(left, right, exact='equiv')", "intent": "Check that `left` and `right` Index are equal . With arguments `exact`.", "question_id": 46585}
{"snippet": "pandas.testing.assert_index_equal(left, right, check_names=True)", "intent": "Check that `left` and `right` Index are equal . With arguments `check_names`.", "question_id": 46586}
{"snippet": "pandas.testing.assert_index_equal(left, right, check_less_precise=NoDefault.no_default)", "intent": "Check that `left` and `right` Index are equal . With arguments `check_less_precise`.", "question_id": 46587}
{"snippet": "pandas.testing.assert_index_equal(left, right, check_exact=True)", "intent": "Check that `left` and `right` Index are equal . With arguments `check_exact`.", "question_id": 46588}
{"snippet": "pandas.testing.assert_index_equal(left, right, check_categorical=True)", "intent": "Check that `left` and `right` Index are equal . With arguments `check_categorical`.", "question_id": 46589}
{"snippet": "pandas.testing.assert_index_equal(left, right, check_order=True)", "intent": "Check that `left` and `right` Index are equal . With arguments `check_order`.", "question_id": 46590}
{"snippet": "pandas.testing.assert_index_equal(left, right, rtol=1e-05)", "intent": "Check that `left` and `right` Index are equal . With arguments `rtol`.", "question_id": 46591}
{"snippet": "pandas.testing.assert_index_equal(left, right, atol=1e-08)", "intent": "Check that `left` and `right` Index are equal . With arguments `atol`.", "question_id": 46592}
{"snippet": "pandas.testing.assert_index_equal(left, right, obj='Index')", "intent": "Check that `left` and `right` Index are equal . With arguments `obj`.", "question_id": 46593}
{"snippet": "pandas.testing.assert_index_equal(left, right)", "intent": "Check that `left` and `right` Index are equal .", "question_id": 46594}
{"snippet": "pandas.testing.assert_index_equal(left, right, exact='equiv')", "intent": "Check that `left` and `right` Index are equal . With arguments `exact`.", "question_id": 46595}
{"snippet": "pandas.testing.assert_index_equal(left, right, check_names=True)", "intent": "Check that `left` and `right` Index are equal . With arguments `check_names`.", "question_id": 46596}
{"snippet": "pandas.testing.assert_index_equal(left, right, check_less_precise=NoDefault.no_default)", "intent": "Check that `left` and `right` Index are equal . With arguments `check_less_precise`.", "question_id": 46597}
{"snippet": "pandas.testing.assert_index_equal(left, right, check_exact=True)", "intent": "Check that `left` and `right` Index are equal . With arguments `check_exact`.", "question_id": 46598}
{"snippet": "pandas.testing.assert_index_equal(left, right, check_categorical=True)", "intent": "Check that `left` and `right` Index are equal . With arguments `check_categorical`.", "question_id": 46599}
{"snippet": "pandas.testing.assert_index_equal(left, right, check_order=True)", "intent": "Check that `left` and `right` Index are equal . With arguments `check_order`.", "question_id": 46600}
{"snippet": "pandas.testing.assert_index_equal(left, right, rtol=1e-05)", "intent": "Check that `left` and `right` Index are equal . With arguments `rtol`.", "question_id": 46601}
{"snippet": "pandas.testing.assert_index_equal(left, right, atol=1e-08)", "intent": "Check that `left` and `right` Index are equal . With arguments `atol`.", "question_id": 46602}
{"snippet": "pandas.testing.assert_index_equal(left, right, obj='Index')", "intent": "Check that `left` and `right` Index are equal . With arguments `obj`.", "question_id": 46603}
{"snippet": "pandas.testing.assert_series_equal(left, right)", "intent": "Check that `left` and `right` Series are equal .", "question_id": 46604}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_dtype=True)", "intent": "Check that `left` and `right` Series are equal . With arguments `check_dtype`.", "question_id": 46605}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_index_type='equiv')", "intent": "Check that `left` and `right` Series are equal . With arguments `check_index_type`.", "question_id": 46606}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_series_type=True)", "intent": "Check that `left` and `right` Series are equal . With arguments `check_series_type`.", "question_id": 46607}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_less_precise=NoDefault.no_default)", "intent": "Check that `left` and `right` Series are equal . With arguments `check_less_precise`.", "question_id": 46608}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_names=True)", "intent": "Check that `left` and `right` Series are equal . With arguments `check_names`.", "question_id": 46609}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_exact=False)", "intent": "Check that `left` and `right` Series are equal . With arguments `check_exact`.", "question_id": 46610}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_datetimelike_compat=False)", "intent": "Check that `left` and `right` Series are equal . With arguments `check_datetimelike_compat`.", "question_id": 46611}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_categorical=True)", "intent": "Check that `left` and `right` Series are equal . With arguments `check_categorical`.", "question_id": 46612}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_category_order=True)", "intent": "Check that `left` and `right` Series are equal . With arguments `check_category_order`.", "question_id": 46613}
{"snippet": "pandas.testing.assert_series_equal(left, right)", "intent": "Check that `left` and `right` Series are equal .", "question_id": 46614}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_dtype=True)", "intent": "Check that `left` and `right` Series are equal . With arguments `check_dtype`.", "question_id": 46615}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_index_type='equiv')", "intent": "Check that `left` and `right` Series are equal . With arguments `check_index_type`.", "question_id": 46616}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_series_type=True)", "intent": "Check that `left` and `right` Series are equal . With arguments `check_series_type`.", "question_id": 46617}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_less_precise=NoDefault.no_default)", "intent": "Check that `left` and `right` Series are equal . With arguments `check_less_precise`.", "question_id": 46618}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_names=True)", "intent": "Check that `left` and `right` Series are equal . With arguments `check_names`.", "question_id": 46619}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_exact=False)", "intent": "Check that `left` and `right` Series are equal . With arguments `check_exact`.", "question_id": 46620}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_datetimelike_compat=False)", "intent": "Check that `left` and `right` Series are equal . With arguments `check_datetimelike_compat`.", "question_id": 46621}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_categorical=True)", "intent": "Check that `left` and `right` Series are equal . With arguments `check_categorical`.", "question_id": 46622}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_category_order=True)", "intent": "Check that `left` and `right` Series are equal . With arguments `check_category_order`.", "question_id": 46623}
{"snippet": "pandas.testing.assert_series_equal(left, right)", "intent": "Check that `left` and `right` Series are equal .", "question_id": 46624}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_dtype=True)", "intent": "Check that `left` and `right` Series are equal . With arguments `check_dtype`.", "question_id": 46625}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_index_type='equiv')", "intent": "Check that `left` and `right` Series are equal . With arguments `check_index_type`.", "question_id": 46626}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_series_type=True)", "intent": "Check that `left` and `right` Series are equal . With arguments `check_series_type`.", "question_id": 46627}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_less_precise=NoDefault.no_default)", "intent": "Check that `left` and `right` Series are equal . With arguments `check_less_precise`.", "question_id": 46628}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_names=True)", "intent": "Check that `left` and `right` Series are equal . With arguments `check_names`.", "question_id": 46629}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_exact=False)", "intent": "Check that `left` and `right` Series are equal . With arguments `check_exact`.", "question_id": 46630}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_datetimelike_compat=False)", "intent": "Check that `left` and `right` Series are equal . With arguments `check_datetimelike_compat`.", "question_id": 46631}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_categorical=True)", "intent": "Check that `left` and `right` Series are equal . With arguments `check_categorical`.", "question_id": 46632}
{"snippet": "pandas.testing.assert_series_equal(left, right, check_category_order=True)", "intent": "Check that `left` and `right` Series are equal . With arguments `check_category_order`.", "question_id": 46633}
{"snippet": "pandas.timedelta_range()", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency .", "question_id": 46634}
{"snippet": "pandas.timedelta_range(start=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 46635}
{"snippet": "pandas.timedelta_range(end=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 46636}
{"snippet": "pandas.timedelta_range(periods=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 46637}
{"snippet": "pandas.timedelta_range(freq=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 46638}
{"snippet": "pandas.timedelta_range(name=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . With arguments `name`.", "question_id": 46639}
{"snippet": "pandas.timedelta_range(closed=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . If freq is omitted , the resulting TimedeltaIndex will have periods linearly spaced elements between start and end ( `closed` on both sides ) .", "question_id": 46640}
{"snippet": "pandas.timedelta_range(start=None, end=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 46641}
{"snippet": "pandas.timedelta_range(start=None, periods=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 46642}
{"snippet": "pandas.timedelta_range(start=None, freq=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 46643}
{"snippet": "pandas.timedelta_range()", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency .", "question_id": 46644}
{"snippet": "pandas.timedelta_range(start=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 46645}
{"snippet": "pandas.timedelta_range(end=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 46646}
{"snippet": "pandas.timedelta_range(periods=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 46647}
{"snippet": "pandas.timedelta_range(freq=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 46648}
{"snippet": "pandas.timedelta_range(name=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . With arguments `name`.", "question_id": 46649}
{"snippet": "pandas.timedelta_range(closed=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . If freq is omitted , the resulting TimedeltaIndex will have periods linearly spaced elements between start and end ( `closed` on both sides ) .", "question_id": 46650}
{"snippet": "pandas.timedelta_range(start=None, end=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 46651}
{"snippet": "pandas.timedelta_range(start=None, periods=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 46652}
{"snippet": "pandas.timedelta_range(start=None, freq=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 46653}
{"snippet": "pandas.timedelta_range()", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency .", "question_id": 46654}
{"snippet": "pandas.timedelta_range(start=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 46655}
{"snippet": "pandas.timedelta_range(end=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 46656}
{"snippet": "pandas.timedelta_range(periods=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 46657}
{"snippet": "pandas.timedelta_range(freq=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 46658}
{"snippet": "pandas.timedelta_range(name=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . With arguments `name`.", "question_id": 46659}
{"snippet": "pandas.timedelta_range(closed=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . If freq is omitted , the resulting TimedeltaIndex will have periods linearly spaced elements between start and end ( `closed` on both sides ) .", "question_id": 46660}
{"snippet": "pandas.timedelta_range(start=None, end=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 46661}
{"snippet": "pandas.timedelta_range(start=None, periods=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 46662}
{"snippet": "pandas.timedelta_range(start=None, freq=None)", "intent": "Return a fixed frequency TimedeltaIndex , with day as the default frequency . Of the four parameters `start` , `end` , `periods` , and `freq` , exactly three must be specified .", "question_id": 46663}
{"snippet": "pandas.to_datetime(arg)", "intent": "Convert argument to datetime . With arguments `arg`.", "question_id": 46664}
{"snippet": "pandas.to_datetime(arg, errors='raise')", "intent": "Convert argument to datetime . With arguments `arg`, `errors`.", "question_id": 46665}
{"snippet": "pandas.to_datetime(arg, dayfirst=False)", "intent": "Convert argument to datetime . With arguments `arg`, `dayfirst`.", "question_id": 46666}
{"snippet": "pandas.to_datetime(arg, yearfirst=False)", "intent": "Convert argument to datetime . With arguments `arg`, `yearfirst`.", "question_id": 46667}
{"snippet": "pandas.to_datetime(arg, utc=None)", "intent": "Convert argument to datetime . With arguments `arg`, `utc`.", "question_id": 46668}
{"snippet": "pandas.to_datetime(arg, format=None)", "intent": "Convert argument to datetime . Passing infer_datetime_format=True can often-times speedup a parsing if its not an ISO8601 `format` exactly , but in a regular format . With arguments `arg`.", "question_id": 46669}
{"snippet": "pandas.to_datetime(arg, exact=True)", "intent": "Convert argument to datetime . With arguments `arg`, `exact`.", "question_id": 46670}
{"snippet": "pandas.to_datetime(arg, unit=None)", "intent": "Convert argument to datetime . With arguments `arg`, `unit`.", "question_id": 46671}
{"snippet": "pandas.to_datetime(arg, infer_datetime_format=False)", "intent": "Convert argument to datetime . With arguments `arg`, `infer_datetime_format`.", "question_id": 46672}
{"snippet": "pandas.to_datetime(arg, origin='unix')", "intent": "Convert argument to datetime . Using a non-unix epoch `origin` With arguments `arg`.", "question_id": 46673}
{"snippet": "pandas.to_datetime(arg)", "intent": "Convert argument to datetime . With arguments `arg`.", "question_id": 46674}
{"snippet": "pandas.to_datetime(arg, errors='raise')", "intent": "Convert argument to datetime . With arguments `arg`, `errors`.", "question_id": 46675}
{"snippet": "pandas.to_datetime(arg, dayfirst=False)", "intent": "Convert argument to datetime . With arguments `arg`, `dayfirst`.", "question_id": 46676}
{"snippet": "pandas.to_datetime(arg, yearfirst=False)", "intent": "Convert argument to datetime . With arguments `arg`, `yearfirst`.", "question_id": 46677}
{"snippet": "pandas.to_datetime(arg, utc=None)", "intent": "Convert argument to datetime . With arguments `arg`, `utc`.", "question_id": 46678}
{"snippet": "pandas.to_datetime(arg, format=None)", "intent": "Convert argument to datetime . Passing infer_datetime_format=True can often-times speedup a parsing if its not an ISO8601 `format` exactly , but in a regular format . With arguments `arg`.", "question_id": 46679}
{"snippet": "pandas.to_datetime(arg, exact=True)", "intent": "Convert argument to datetime . With arguments `arg`, `exact`.", "question_id": 46680}
{"snippet": "pandas.to_datetime(arg, unit=None)", "intent": "Convert argument to datetime . With arguments `arg`, `unit`.", "question_id": 46681}
{"snippet": "pandas.to_datetime(arg, infer_datetime_format=False)", "intent": "Convert argument to datetime . With arguments `arg`, `infer_datetime_format`.", "question_id": 46682}
{"snippet": "pandas.to_datetime(arg, origin='unix')", "intent": "Convert argument to datetime . Using a non-unix epoch `origin` With arguments `arg`.", "question_id": 46683}
{"snippet": "pandas.to_datetime(arg)", "intent": "Convert argument to datetime . With arguments `arg`.", "question_id": 46684}
{"snippet": "pandas.to_datetime(arg, errors='raise')", "intent": "Convert argument to datetime . With arguments `arg`, `errors`.", "question_id": 46685}
{"snippet": "pandas.to_datetime(arg, dayfirst=False)", "intent": "Convert argument to datetime . With arguments `arg`, `dayfirst`.", "question_id": 46686}
{"snippet": "pandas.to_datetime(arg, yearfirst=False)", "intent": "Convert argument to datetime . With arguments `arg`, `yearfirst`.", "question_id": 46687}
{"snippet": "pandas.to_datetime(arg, utc=None)", "intent": "Convert argument to datetime . With arguments `arg`, `utc`.", "question_id": 46688}
{"snippet": "pandas.to_datetime(arg, format=None)", "intent": "Convert argument to datetime . Passing infer_datetime_format=True can often-times speedup a parsing if its not an ISO8601 `format` exactly , but in a regular format . With arguments `arg`.", "question_id": 46689}
{"snippet": "pandas.to_datetime(arg, exact=True)", "intent": "Convert argument to datetime . With arguments `arg`, `exact`.", "question_id": 46690}
{"snippet": "pandas.to_datetime(arg, unit=None)", "intent": "Convert argument to datetime . With arguments `arg`, `unit`.", "question_id": 46691}
{"snippet": "pandas.to_datetime(arg, infer_datetime_format=False)", "intent": "Convert argument to datetime . With arguments `arg`, `infer_datetime_format`.", "question_id": 46692}
{"snippet": "pandas.to_datetime(arg, origin='unix')", "intent": "Convert argument to datetime . Using a non-unix epoch `origin` With arguments `arg`.", "question_id": 46693}
{"snippet": "pandas.to_numeric(arg)", "intent": "Convert argument to a numeric type . With arguments `arg`.", "question_id": 46694}
{"snippet": "pandas.to_numeric(arg, errors='raise')", "intent": "Convert argument to a numeric type . With arguments `arg`, `errors`.", "question_id": 46695}
{"snippet": "pandas.to_numeric(arg, downcast=None)", "intent": "Convert argument to a numeric type . Use the `downcast` parameter to obtain other dtypes . With arguments `arg`.", "question_id": 46696}
{"snippet": "pandas.to_numeric(arg, errors='raise', downcast=None)", "intent": "Convert argument to a numeric type . Use the `downcast` parameter to obtain other dtypes . With arguments `arg`, `errors`.", "question_id": 46697}
{"snippet": "pandas.to_numeric(arg)", "intent": "Convert argument to a numeric type . With arguments `arg`.", "question_id": 46698}
{"snippet": "pandas.to_numeric(arg, errors='raise')", "intent": "Convert argument to a numeric type . With arguments `arg`, `errors`.", "question_id": 46699}
{"snippet": "pandas.to_numeric(arg, downcast=None)", "intent": "Convert argument to a numeric type . Use the `downcast` parameter to obtain other dtypes . With arguments `arg`.", "question_id": 46700}
{"snippet": "pandas.to_numeric(arg, errors='raise', downcast=None)", "intent": "Convert argument to a numeric type . Use the `downcast` parameter to obtain other dtypes . With arguments `arg`, `errors`.", "question_id": 46701}
{"snippet": "pandas.to_numeric(arg)", "intent": "Convert argument to a numeric type . With arguments `arg`.", "question_id": 46702}
{"snippet": "pandas.to_numeric(arg, errors='raise')", "intent": "Convert argument to a numeric type . With arguments `arg`, `errors`.", "question_id": 46703}
{"snippet": "pandas.to_numeric(arg, downcast=None)", "intent": "Convert argument to a numeric type . Use the `downcast` parameter to obtain other dtypes . With arguments `arg`.", "question_id": 46704}
{"snippet": "pandas.to_numeric(arg, errors='raise', downcast=None)", "intent": "Convert argument to a numeric type . Use the `downcast` parameter to obtain other dtypes . With arguments `arg`, `errors`.", "question_id": 46705}
{"snippet": "pandas.to_timedelta(arg)", "intent": "Convert argument to timedelta . With arguments `arg`.", "question_id": 46706}
{"snippet": "pandas.to_timedelta(arg, unit=None)", "intent": "Convert argument to timedelta . Converting numbers by specifying the `unit` keyword argument : With arguments `arg`.", "question_id": 46707}
{"snippet": "pandas.to_timedelta(arg, errors='raise')", "intent": "Convert argument to timedelta . With arguments `arg`, `errors`.", "question_id": 46708}
{"snippet": "pandas.to_timedelta(arg, unit=None, errors='raise')", "intent": "Convert argument to timedelta . Converting numbers by specifying the `unit` keyword argument : With arguments `arg`, `errors`.", "question_id": 46709}
{"snippet": "pandas.to_timedelta(arg)", "intent": "Convert argument to timedelta . With arguments `arg`.", "question_id": 46710}
{"snippet": "pandas.to_timedelta(arg, unit=None)", "intent": "Convert argument to timedelta . Converting numbers by specifying the `unit` keyword argument : With arguments `arg`.", "question_id": 46711}
{"snippet": "pandas.to_timedelta(arg, errors='raise')", "intent": "Convert argument to timedelta . With arguments `arg`, `errors`.", "question_id": 46712}
{"snippet": "pandas.to_timedelta(arg, unit=None, errors='raise')", "intent": "Convert argument to timedelta . Converting numbers by specifying the `unit` keyword argument : With arguments `arg`, `errors`.", "question_id": 46713}
{"snippet": "pandas.to_timedelta(arg)", "intent": "Convert argument to timedelta . With arguments `arg`.", "question_id": 46714}
{"snippet": "pandas.to_timedelta(arg, unit=None)", "intent": "Convert argument to timedelta . Converting numbers by specifying the `unit` keyword argument : With arguments `arg`.", "question_id": 46715}
{"snippet": "pandas.to_timedelta(arg, errors='raise')", "intent": "Convert argument to timedelta . With arguments `arg`, `errors`.", "question_id": 46716}
{"snippet": "pandas.to_timedelta(arg, unit=None, errors='raise')", "intent": "Convert argument to timedelta . Converting numbers by specifying the `unit` keyword argument : With arguments `arg`, `errors`.", "question_id": 46717}
{"snippet": "pandas.tseries.frequencies.to_offset()", "intent": "Return DateOffset object from string or tuple representation or datetime.timedelta object .", "question_id": 46718}
{"snippet": "pandas.tseries.frequencies.to_offset()", "intent": "Return DateOffset object from string or tuple representation or datetime.timedelta object .", "question_id": 46719}
{"snippet": "pandas.tseries.frequencies.to_offset()", "intent": "Return DateOffset object from string or tuple representation or datetime.timedelta object .", "question_id": 46720}
{"snippet": "pandas.tseries.offsets.BDay", "intent": "alias of pandas._libs.tslibs.offsets.BusinessDay", "question_id": 46721}
{"snippet": "pandas.tseries.offsets.BDay", "intent": "alias of pandas._libs.tslibs.offsets.BusinessDay", "question_id": 46722}
{"snippet": "pandas.tseries.offsets.BDay", "intent": "alias of pandas._libs.tslibs.offsets.BusinessDay", "question_id": 46723}
{"snippet": "pandas.tseries.offsets.BMonthBegin", "intent": "alias of pandas._libs.tslibs.offsets.BusinessMonthBegin", "question_id": 46724}
{"snippet": "pandas.tseries.offsets.BMonthBegin", "intent": "alias of pandas._libs.tslibs.offsets.BusinessMonthBegin", "question_id": 46725}
{"snippet": "pandas.tseries.offsets.BMonthBegin", "intent": "alias of pandas._libs.tslibs.offsets.BusinessMonthBegin", "question_id": 46726}
{"snippet": "pandas.tseries.offsets.BMonthEnd", "intent": "alias of pandas._libs.tslibs.offsets.BusinessMonthEnd", "question_id": 46727}
{"snippet": "pandas.tseries.offsets.BMonthEnd", "intent": "alias of pandas._libs.tslibs.offsets.BusinessMonthEnd", "question_id": 46728}
{"snippet": "pandas.tseries.offsets.BMonthEnd", "intent": "alias of pandas._libs.tslibs.offsets.BusinessMonthEnd", "question_id": 46729}
{"snippet": "BQuarterBegin.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46730}
{"snippet": "BQuarterBegin.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46731}
{"snippet": "BQuarterBegin.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46732}
{"snippet": "BQuarterBegin.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46733}
{"snippet": "BQuarterBegin.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46734}
{"snippet": "BQuarterBegin.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46735}
{"snippet": "pandas.tseries.offsets.BQuarterBegin", "intent": "DateOffset increments between the first business day of each Quarter.", "question_id": 46736}
{"snippet": "pandas.tseries.offsets.BQuarterBegin", "intent": "DateOffset increments between the first business day of each Quarter.", "question_id": 46737}
{"snippet": "pandas.tseries.offsets.BQuarterBegin", "intent": "DateOffset increments between the first business day of each Quarter.", "question_id": 46738}
{"snippet": "BQuarterBegin.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46739}
{"snippet": "BQuarterBegin.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46740}
{"snippet": "BQuarterBegin.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46741}
{"snippet": "BQuarterBegin.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46742}
{"snippet": "BQuarterBegin.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46743}
{"snippet": "BQuarterBegin.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46744}
{"snippet": "BQuarterEnd.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46745}
{"snippet": "BQuarterEnd.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46746}
{"snippet": "BQuarterEnd.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46747}
{"snippet": "BQuarterEnd.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46748}
{"snippet": "BQuarterEnd.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46749}
{"snippet": "BQuarterEnd.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46750}
{"snippet": "pandas.tseries.offsets.BQuarterEnd", "intent": "DateOffset increments between the last business day of each Quarter.", "question_id": 46751}
{"snippet": "pandas.tseries.offsets.BQuarterEnd", "intent": "DateOffset increments between the last business day of each Quarter.", "question_id": 46752}
{"snippet": "pandas.tseries.offsets.BQuarterEnd", "intent": "DateOffset increments between the last business day of each Quarter.", "question_id": 46753}
{"snippet": "BQuarterEnd.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46754}
{"snippet": "BQuarterEnd.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46755}
{"snippet": "BQuarterEnd.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46756}
{"snippet": "BQuarterEnd.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46757}
{"snippet": "BQuarterEnd.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46758}
{"snippet": "BQuarterEnd.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46759}
{"snippet": "BYearBegin.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46760}
{"snippet": "BYearBegin.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46761}
{"snippet": "BYearBegin.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46762}
{"snippet": "BYearBegin.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46763}
{"snippet": "BYearBegin.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46764}
{"snippet": "BYearBegin.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46765}
{"snippet": "pandas.tseries.offsets.BYearBegin", "intent": "DateOffset increments between the first business day of the year.", "question_id": 46766}
{"snippet": "pandas.tseries.offsets.BYearBegin", "intent": "DateOffset increments between the first business day of the year.", "question_id": 46767}
{"snippet": "pandas.tseries.offsets.BYearBegin", "intent": "DateOffset increments between the first business day of the year.", "question_id": 46768}
{"snippet": "BYearBegin.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46769}
{"snippet": "BYearBegin.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46770}
{"snippet": "BYearBegin.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46771}
{"snippet": "BYearBegin.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46772}
{"snippet": "BYearBegin.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46773}
{"snippet": "BYearBegin.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46774}
{"snippet": "BYearEnd.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46775}
{"snippet": "BYearEnd.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46776}
{"snippet": "BYearEnd.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46777}
{"snippet": "BYearEnd.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46778}
{"snippet": "BYearEnd.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46779}
{"snippet": "BYearEnd.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46780}
{"snippet": "pandas.tseries.offsets.BYearEnd", "intent": "DateOffset increments between the last business day of the year.", "question_id": 46781}
{"snippet": "pandas.tseries.offsets.BYearEnd", "intent": "DateOffset increments between the last business day of the year.", "question_id": 46782}
{"snippet": "pandas.tseries.offsets.BYearEnd", "intent": "DateOffset increments between the last business day of the year.", "question_id": 46783}
{"snippet": "BYearEnd.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46784}
{"snippet": "BYearEnd.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46785}
{"snippet": "BYearEnd.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46786}
{"snippet": "BYearEnd.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46787}
{"snippet": "BYearEnd.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46788}
{"snippet": "BYearEnd.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46789}
{"snippet": "BusinessDay.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46790}
{"snippet": "BusinessDay.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46791}
{"snippet": "BusinessDay.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46792}
{"snippet": "BusinessDay.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46793}
{"snippet": "BusinessDay.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46794}
{"snippet": "BusinessDay.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46795}
{"snippet": "pandas.tseries.offsets.BusinessDay", "intent": "DateOffset subclass representing possibly n business days.", "question_id": 46796}
{"snippet": "pandas.tseries.offsets.BusinessDay", "intent": "DateOffset subclass representing possibly n business days.", "question_id": 46797}
{"snippet": "pandas.tseries.offsets.BusinessDay", "intent": "DateOffset subclass representing possibly n business days.", "question_id": 46798}
{"snippet": "BusinessDay.offset", "intent": "Alias for self._offset.", "question_id": 46799}
{"snippet": "BusinessDay.offset", "intent": "Alias for self._offset.", "question_id": 46800}
{"snippet": "BusinessDay.offset", "intent": "Alias for self._offset.", "question_id": 46801}
{"snippet": "BusinessDay.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46802}
{"snippet": "BusinessDay.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46803}
{"snippet": "BusinessDay.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46804}
{"snippet": "BusinessDay.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46805}
{"snippet": "BusinessDay.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46806}
{"snippet": "BusinessDay.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46807}
{"snippet": "BusinessHour.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46808}
{"snippet": "BusinessHour.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46809}
{"snippet": "BusinessHour.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46810}
{"snippet": "BusinessHour.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46811}
{"snippet": "BusinessHour.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46812}
{"snippet": "BusinessHour.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46813}
{"snippet": "pandas.tseries.offsets.BusinessHour", "intent": "DateOffset subclass representing possibly n business hours.", "question_id": 46814}
{"snippet": "pandas.tseries.offsets.BusinessHour", "intent": "DateOffset subclass representing possibly n business hours.", "question_id": 46815}
{"snippet": "pandas.tseries.offsets.BusinessHour", "intent": "DateOffset subclass representing possibly n business hours.", "question_id": 46816}
{"snippet": "BusinessHour.next_bday", "intent": "Used for moving to next business day.", "question_id": 46817}
{"snippet": "BusinessHour.next_bday", "intent": "Used for moving to next business day.", "question_id": 46818}
{"snippet": "BusinessHour.next_bday", "intent": "Used for moving to next business day.", "question_id": 46819}
{"snippet": "BusinessHour.offset", "intent": "Alias for self._offset.", "question_id": 46820}
{"snippet": "BusinessHour.offset", "intent": "Alias for self._offset.", "question_id": 46821}
{"snippet": "BusinessHour.offset", "intent": "Alias for self._offset.", "question_id": 46822}
{"snippet": "BusinessHour.rollback(other)", "intent": "Roll provided date backward to next offset only if not on offset . With arguments `other`.", "question_id": 46823}
{"snippet": "BusinessHour.rollback(other)", "intent": "Roll provided date backward to next offset only if not on offset . With arguments `other`.", "question_id": 46824}
{"snippet": "BusinessHour.rollback(other)", "intent": "Roll provided date backward to next offset only if not on offset . With arguments `other`.", "question_id": 46825}
{"snippet": "BusinessHour.rollforward(other)", "intent": "Roll provided date forward to next offset only if not on offset . With arguments `other`.", "question_id": 46826}
{"snippet": "BusinessHour.rollforward(other)", "intent": "Roll provided date forward to next offset only if not on offset . With arguments `other`.", "question_id": 46827}
{"snippet": "BusinessHour.rollforward(other)", "intent": "Roll provided date forward to next offset only if not on offset . With arguments `other`.", "question_id": 46828}
{"snippet": "BusinessMonthBegin.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46829}
{"snippet": "BusinessMonthBegin.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46830}
{"snippet": "BusinessMonthBegin.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46831}
{"snippet": "BusinessMonthBegin.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46832}
{"snippet": "BusinessMonthBegin.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46833}
{"snippet": "BusinessMonthBegin.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46834}
{"snippet": "pandas.tseries.offsets.BusinessMonthBegin", "intent": "DateOffset of one month at the first business day.", "question_id": 46835}
{"snippet": "pandas.tseries.offsets.BusinessMonthBegin", "intent": "DateOffset of one month at the first business day.", "question_id": 46836}
{"snippet": "pandas.tseries.offsets.BusinessMonthBegin", "intent": "DateOffset of one month at the first business day.", "question_id": 46837}
{"snippet": "BusinessMonthBegin.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46838}
{"snippet": "BusinessMonthBegin.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46839}
{"snippet": "BusinessMonthBegin.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46840}
{"snippet": "BusinessMonthBegin.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46841}
{"snippet": "BusinessMonthBegin.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46842}
{"snippet": "BusinessMonthBegin.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46843}
{"snippet": "BusinessMonthEnd.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46844}
{"snippet": "BusinessMonthEnd.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46845}
{"snippet": "BusinessMonthEnd.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46846}
{"snippet": "BusinessMonthEnd.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46847}
{"snippet": "BusinessMonthEnd.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46848}
{"snippet": "BusinessMonthEnd.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46849}
{"snippet": "pandas.tseries.offsets.BusinessMonthEnd", "intent": "DateOffset increments between the last business day of the month", "question_id": 46850}
{"snippet": "pandas.tseries.offsets.BusinessMonthEnd", "intent": "DateOffset increments between the last business day of the month", "question_id": 46851}
{"snippet": "pandas.tseries.offsets.BusinessMonthEnd", "intent": "DateOffset increments between the last business day of the month", "question_id": 46852}
{"snippet": "BusinessMonthEnd.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46853}
{"snippet": "BusinessMonthEnd.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46854}
{"snippet": "BusinessMonthEnd.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46855}
{"snippet": "BusinessMonthEnd.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46856}
{"snippet": "BusinessMonthEnd.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46857}
{"snippet": "BusinessMonthEnd.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46858}
{"snippet": "pandas.tseries.offsets.CBMonthBegin", "intent": "alias of pandas._libs.tslibs.offsets.CustomBusinessMonthBegin", "question_id": 46859}
{"snippet": "pandas.tseries.offsets.CBMonthBegin", "intent": "alias of pandas._libs.tslibs.offsets.CustomBusinessMonthBegin", "question_id": 46860}
{"snippet": "pandas.tseries.offsets.CBMonthBegin", "intent": "alias of pandas._libs.tslibs.offsets.CustomBusinessMonthBegin", "question_id": 46861}
{"snippet": "pandas.tseries.offsets.CBMonthEnd", "intent": "alias of pandas._libs.tslibs.offsets.CustomBusinessMonthEnd", "question_id": 46862}
{"snippet": "pandas.tseries.offsets.CBMonthEnd", "intent": "alias of pandas._libs.tslibs.offsets.CustomBusinessMonthEnd", "question_id": 46863}
{"snippet": "pandas.tseries.offsets.CBMonthEnd", "intent": "alias of pandas._libs.tslibs.offsets.CustomBusinessMonthEnd", "question_id": 46864}
{"snippet": "pandas.tseries.offsets.CDay", "intent": "alias of pandas._libs.tslibs.offsets.CustomBusinessDay", "question_id": 46865}
{"snippet": "pandas.tseries.offsets.CDay", "intent": "alias of pandas._libs.tslibs.offsets.CustomBusinessDay", "question_id": 46866}
{"snippet": "pandas.tseries.offsets.CDay", "intent": "alias of pandas._libs.tslibs.offsets.CustomBusinessDay", "question_id": 46867}
{"snippet": "CustomBusinessDay.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46868}
{"snippet": "CustomBusinessDay.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46869}
{"snippet": "CustomBusinessDay.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46870}
{"snippet": "CustomBusinessDay.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46871}
{"snippet": "CustomBusinessDay.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46872}
{"snippet": "CustomBusinessDay.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46873}
{"snippet": "pandas.tseries.offsets.CustomBusinessDay", "intent": "DateOffset subclass representing custom business days excluding holidays.", "question_id": 46874}
{"snippet": "pandas.tseries.offsets.CustomBusinessDay", "intent": "DateOffset subclass representing custom business days excluding holidays.", "question_id": 46875}
{"snippet": "pandas.tseries.offsets.CustomBusinessDay", "intent": "DateOffset subclass representing custom business days excluding holidays.", "question_id": 46876}
{"snippet": "CustomBusinessDay.offset", "intent": "Alias for self._offset.", "question_id": 46877}
{"snippet": "CustomBusinessDay.offset", "intent": "Alias for self._offset.", "question_id": 46878}
{"snippet": "CustomBusinessDay.offset", "intent": "Alias for self._offset.", "question_id": 46879}
{"snippet": "CustomBusinessDay.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46880}
{"snippet": "CustomBusinessDay.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46881}
{"snippet": "CustomBusinessDay.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46882}
{"snippet": "CustomBusinessDay.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46883}
{"snippet": "CustomBusinessDay.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46884}
{"snippet": "CustomBusinessDay.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46885}
{"snippet": "CustomBusinessHour.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46886}
{"snippet": "CustomBusinessHour.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46887}
{"snippet": "CustomBusinessHour.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46888}
{"snippet": "CustomBusinessHour.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46889}
{"snippet": "CustomBusinessHour.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46890}
{"snippet": "CustomBusinessHour.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46891}
{"snippet": "pandas.tseries.offsets.CustomBusinessHour", "intent": "DateOffset subclass representing possibly n custom business days.", "question_id": 46892}
{"snippet": "pandas.tseries.offsets.CustomBusinessHour", "intent": "DateOffset subclass representing possibly n custom business days.", "question_id": 46893}
{"snippet": "pandas.tseries.offsets.CustomBusinessHour", "intent": "DateOffset subclass representing possibly n custom business days.", "question_id": 46894}
{"snippet": "CustomBusinessHour.next_bday", "intent": "Used for moving to next business day.", "question_id": 46895}
{"snippet": "CustomBusinessHour.next_bday", "intent": "Used for moving to next business day.", "question_id": 46896}
{"snippet": "CustomBusinessHour.next_bday", "intent": "Used for moving to next business day.", "question_id": 46897}
{"snippet": "CustomBusinessHour.offset", "intent": "Alias for self._offset.", "question_id": 46898}
{"snippet": "CustomBusinessHour.offset", "intent": "Alias for self._offset.", "question_id": 46899}
{"snippet": "CustomBusinessHour.offset", "intent": "Alias for self._offset.", "question_id": 46900}
{"snippet": "CustomBusinessHour.rollback(other)", "intent": "Roll provided date backward to next offset only if not on offset . With arguments `other`.", "question_id": 46901}
{"snippet": "CustomBusinessHour.rollback(other)", "intent": "Roll provided date backward to next offset only if not on offset . With arguments `other`.", "question_id": 46902}
{"snippet": "CustomBusinessHour.rollback(other)", "intent": "Roll provided date backward to next offset only if not on offset . With arguments `other`.", "question_id": 46903}
{"snippet": "CustomBusinessHour.rollforward(other)", "intent": "Roll provided date forward to next offset only if not on offset . With arguments `other`.", "question_id": 46904}
{"snippet": "CustomBusinessHour.rollforward(other)", "intent": "Roll provided date forward to next offset only if not on offset . With arguments `other`.", "question_id": 46905}
{"snippet": "CustomBusinessHour.rollforward(other)", "intent": "Roll provided date forward to next offset only if not on offset . With arguments `other`.", "question_id": 46906}
{"snippet": "CustomBusinessMonthBegin.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46907}
{"snippet": "CustomBusinessMonthBegin.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46908}
{"snippet": "CustomBusinessMonthBegin.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46909}
{"snippet": "CustomBusinessMonthBegin.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46910}
{"snippet": "CustomBusinessMonthBegin.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46911}
{"snippet": "CustomBusinessMonthBegin.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46912}
{"snippet": "CustomBusinessMonthBegin.cbday_roll", "intent": "Define default roll function to be called in apply method.", "question_id": 46913}
{"snippet": "CustomBusinessMonthBegin.cbday_roll", "intent": "Define default roll function to be called in apply method.", "question_id": 46914}
{"snippet": "CustomBusinessMonthBegin.cbday_roll", "intent": "Define default roll function to be called in apply method.", "question_id": 46915}
{"snippet": "pandas.tseries.offsets.CustomBusinessMonthBegin", "intent": "Attributes", "question_id": 46916}
{"snippet": "pandas.tseries.offsets.CustomBusinessMonthBegin", "intent": "Attributes", "question_id": 46917}
{"snippet": "pandas.tseries.offsets.CustomBusinessMonthBegin", "intent": "Attributes", "question_id": 46918}
{"snippet": "CustomBusinessMonthBegin.month_roll", "intent": "Define default roll function to be called in apply method.", "question_id": 46919}
{"snippet": "CustomBusinessMonthBegin.month_roll", "intent": "Define default roll function to be called in apply method.", "question_id": 46920}
{"snippet": "CustomBusinessMonthBegin.month_roll", "intent": "Define default roll function to be called in apply method.", "question_id": 46921}
{"snippet": "CustomBusinessMonthBegin.offset", "intent": "Alias for self._offset.", "question_id": 46922}
{"snippet": "CustomBusinessMonthBegin.offset", "intent": "Alias for self._offset.", "question_id": 46923}
{"snippet": "CustomBusinessMonthBegin.offset", "intent": "Alias for self._offset.", "question_id": 46924}
{"snippet": "CustomBusinessMonthBegin.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46925}
{"snippet": "CustomBusinessMonthBegin.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46926}
{"snippet": "CustomBusinessMonthBegin.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46927}
{"snippet": "CustomBusinessMonthBegin.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46928}
{"snippet": "CustomBusinessMonthBegin.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46929}
{"snippet": "CustomBusinessMonthBegin.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46930}
{"snippet": "CustomBusinessMonthEnd.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46931}
{"snippet": "CustomBusinessMonthEnd.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46932}
{"snippet": "CustomBusinessMonthEnd.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46933}
{"snippet": "CustomBusinessMonthEnd.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46934}
{"snippet": "CustomBusinessMonthEnd.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46935}
{"snippet": "CustomBusinessMonthEnd.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46936}
{"snippet": "CustomBusinessMonthEnd.cbday_roll", "intent": "Define default roll function to be called in apply method.", "question_id": 46937}
{"snippet": "CustomBusinessMonthEnd.cbday_roll", "intent": "Define default roll function to be called in apply method.", "question_id": 46938}
{"snippet": "CustomBusinessMonthEnd.cbday_roll", "intent": "Define default roll function to be called in apply method.", "question_id": 46939}
{"snippet": "pandas.tseries.offsets.CustomBusinessMonthEnd", "intent": "Attributes", "question_id": 46940}
{"snippet": "pandas.tseries.offsets.CustomBusinessMonthEnd", "intent": "Attributes", "question_id": 46941}
{"snippet": "pandas.tseries.offsets.CustomBusinessMonthEnd", "intent": "Attributes", "question_id": 46942}
{"snippet": "CustomBusinessMonthEnd.month_roll", "intent": "Define default roll function to be called in apply method.", "question_id": 46943}
{"snippet": "CustomBusinessMonthEnd.month_roll", "intent": "Define default roll function to be called in apply method.", "question_id": 46944}
{"snippet": "CustomBusinessMonthEnd.month_roll", "intent": "Define default roll function to be called in apply method.", "question_id": 46945}
{"snippet": "CustomBusinessMonthEnd.offset", "intent": "Alias for self._offset.", "question_id": 46946}
{"snippet": "CustomBusinessMonthEnd.offset", "intent": "Alias for self._offset.", "question_id": 46947}
{"snippet": "CustomBusinessMonthEnd.offset", "intent": "Alias for self._offset.", "question_id": 46948}
{"snippet": "CustomBusinessMonthEnd.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46949}
{"snippet": "CustomBusinessMonthEnd.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46950}
{"snippet": "CustomBusinessMonthEnd.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46951}
{"snippet": "CustomBusinessMonthEnd.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46952}
{"snippet": "CustomBusinessMonthEnd.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46953}
{"snippet": "CustomBusinessMonthEnd.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46954}
{"snippet": "DateOffset.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46955}
{"snippet": "DateOffset.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46956}
{"snippet": "DateOffset.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46957}
{"snippet": "DateOffset.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46958}
{"snippet": "DateOffset.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46959}
{"snippet": "DateOffset.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46960}
{"snippet": "pandas.tseries.offsets.DateOffset", "intent": "Standard kind of date increment used for a date range.", "question_id": 46961}
{"snippet": "pandas.tseries.offsets.DateOffset", "intent": "Standard kind of date increment used for a date range.", "question_id": 46962}
{"snippet": "pandas.tseries.offsets.DateOffset", "intent": "Standard kind of date increment used for a date range.", "question_id": 46963}
{"snippet": "DateOffset.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46964}
{"snippet": "DateOffset.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46965}
{"snippet": "DateOffset.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46966}
{"snippet": "DateOffset.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46967}
{"snippet": "DateOffset.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46968}
{"snippet": "DateOffset.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46969}
{"snippet": "Day.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46970}
{"snippet": "Day.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46971}
{"snippet": "Day.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46972}
{"snippet": "Day.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46973}
{"snippet": "Day.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46974}
{"snippet": "Day.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46975}
{"snippet": "pandas.tseries.offsets.Day", "intent": "Attributes", "question_id": 46976}
{"snippet": "pandas.tseries.offsets.Day", "intent": "Attributes", "question_id": 46977}
{"snippet": "pandas.tseries.offsets.Day", "intent": "Attributes", "question_id": 46978}
{"snippet": "Day.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46979}
{"snippet": "Day.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46980}
{"snippet": "Day.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46981}
{"snippet": "Day.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46982}
{"snippet": "Day.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46983}
{"snippet": "Day.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46984}
{"snippet": "Easter.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46985}
{"snippet": "Easter.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46986}
{"snippet": "Easter.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 46987}
{"snippet": "Easter.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46988}
{"snippet": "Easter.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46989}
{"snippet": "Easter.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 46990}
{"snippet": "pandas.tseries.offsets.Easter", "intent": "DateOffset for the Easter holiday using logic defined in dateutil.", "question_id": 46991}
{"snippet": "pandas.tseries.offsets.Easter", "intent": "DateOffset for the Easter holiday using logic defined in dateutil.", "question_id": 46992}
{"snippet": "pandas.tseries.offsets.Easter", "intent": "DateOffset for the Easter holiday using logic defined in dateutil.", "question_id": 46993}
{"snippet": "Easter.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46994}
{"snippet": "Easter.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46995}
{"snippet": "Easter.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 46996}
{"snippet": "Easter.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46997}
{"snippet": "Easter.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46998}
{"snippet": "Easter.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 46999}
{"snippet": "FY5253.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47000}
{"snippet": "FY5253.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47001}
{"snippet": "FY5253.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47002}
{"snippet": "FY5253.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47003}
{"snippet": "FY5253.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47004}
{"snippet": "FY5253.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47005}
{"snippet": "pandas.tseries.offsets.FY5253", "intent": "Describes 52-53 week fiscal year.", "question_id": 47006}
{"snippet": "pandas.tseries.offsets.FY5253", "intent": "Describes 52-53 week fiscal year.", "question_id": 47007}
{"snippet": "pandas.tseries.offsets.FY5253", "intent": "Describes 52-53 week fiscal year.", "question_id": 47008}
{"snippet": "FY5253.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47009}
{"snippet": "FY5253.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47010}
{"snippet": "FY5253.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47011}
{"snippet": "FY5253.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47012}
{"snippet": "FY5253.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47013}
{"snippet": "FY5253.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47014}
{"snippet": "FY5253Quarter.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47015}
{"snippet": "FY5253Quarter.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47016}
{"snippet": "FY5253Quarter.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47017}
{"snippet": "FY5253Quarter.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47018}
{"snippet": "FY5253Quarter.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47019}
{"snippet": "FY5253Quarter.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47020}
{"snippet": "pandas.tseries.offsets.FY5253Quarter", "intent": "DateOffset increments between business quarter dates for 52-53 week fiscal year (also known as a 4-4-5 calendar).", "question_id": 47021}
{"snippet": "pandas.tseries.offsets.FY5253Quarter", "intent": "DateOffset increments between business quarter dates for 52-53 week fiscal year (also known as a 4-4-5 calendar).", "question_id": 47022}
{"snippet": "pandas.tseries.offsets.FY5253Quarter", "intent": "DateOffset increments between business quarter dates for 52-53 week fiscal year (also known as a 4-4-5 calendar).", "question_id": 47023}
{"snippet": "FY5253Quarter.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47024}
{"snippet": "FY5253Quarter.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47025}
{"snippet": "FY5253Quarter.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47026}
{"snippet": "FY5253Quarter.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47027}
{"snippet": "FY5253Quarter.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47028}
{"snippet": "FY5253Quarter.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47029}
{"snippet": "Hour.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47030}
{"snippet": "Hour.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47031}
{"snippet": "Hour.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47032}
{"snippet": "Hour.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47033}
{"snippet": "Hour.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47034}
{"snippet": "Hour.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47035}
{"snippet": "pandas.tseries.offsets.Hour", "intent": "Attributes", "question_id": 47036}
{"snippet": "pandas.tseries.offsets.Hour", "intent": "Attributes", "question_id": 47037}
{"snippet": "pandas.tseries.offsets.Hour", "intent": "Attributes", "question_id": 47038}
{"snippet": "Hour.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47039}
{"snippet": "Hour.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47040}
{"snippet": "Hour.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47041}
{"snippet": "Hour.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47042}
{"snippet": "Hour.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47043}
{"snippet": "Hour.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47044}
{"snippet": "LastWeekOfMonth.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47045}
{"snippet": "LastWeekOfMonth.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47046}
{"snippet": "LastWeekOfMonth.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47047}
{"snippet": "LastWeekOfMonth.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47048}
{"snippet": "LastWeekOfMonth.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47049}
{"snippet": "LastWeekOfMonth.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47050}
{"snippet": "pandas.tseries.offsets.LastWeekOfMonth", "intent": "Describes monthly dates in last week of month like \u201cthe last Tuesday of each month\u201d.", "question_id": 47051}
{"snippet": "pandas.tseries.offsets.LastWeekOfMonth", "intent": "Describes monthly dates in last week of month like \u201cthe last Tuesday of each month\u201d.", "question_id": 47052}
{"snippet": "pandas.tseries.offsets.LastWeekOfMonth", "intent": "Describes monthly dates in last week of month like \u201cthe last Tuesday of each month\u201d.", "question_id": 47053}
{"snippet": "LastWeekOfMonth.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47054}
{"snippet": "LastWeekOfMonth.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47055}
{"snippet": "LastWeekOfMonth.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47056}
{"snippet": "LastWeekOfMonth.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47057}
{"snippet": "LastWeekOfMonth.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47058}
{"snippet": "LastWeekOfMonth.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47059}
{"snippet": "Micro.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47060}
{"snippet": "Micro.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47061}
{"snippet": "Micro.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47062}
{"snippet": "Micro.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47063}
{"snippet": "Micro.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47064}
{"snippet": "Micro.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47065}
{"snippet": "pandas.tseries.offsets.Micro", "intent": "Attributes", "question_id": 47066}
{"snippet": "pandas.tseries.offsets.Micro", "intent": "Attributes", "question_id": 47067}
{"snippet": "pandas.tseries.offsets.Micro", "intent": "Attributes", "question_id": 47068}
{"snippet": "Micro.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47069}
{"snippet": "Micro.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47070}
{"snippet": "Micro.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47071}
{"snippet": "Micro.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47072}
{"snippet": "Micro.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47073}
{"snippet": "Micro.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47074}
{"snippet": "Milli.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47075}
{"snippet": "Milli.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47076}
{"snippet": "Milli.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47077}
{"snippet": "Milli.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47078}
{"snippet": "Milli.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47079}
{"snippet": "Milli.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47080}
{"snippet": "pandas.tseries.offsets.Milli", "intent": "Attributes", "question_id": 47081}
{"snippet": "pandas.tseries.offsets.Milli", "intent": "Attributes", "question_id": 47082}
{"snippet": "pandas.tseries.offsets.Milli", "intent": "Attributes", "question_id": 47083}
{"snippet": "Milli.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47084}
{"snippet": "Milli.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47085}
{"snippet": "Milli.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47086}
{"snippet": "Milli.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47087}
{"snippet": "Milli.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47088}
{"snippet": "Milli.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47089}
{"snippet": "Minute.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47090}
{"snippet": "Minute.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47091}
{"snippet": "Minute.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47092}
{"snippet": "Minute.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47093}
{"snippet": "Minute.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47094}
{"snippet": "Minute.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47095}
{"snippet": "pandas.tseries.offsets.Minute", "intent": "Attributes", "question_id": 47096}
{"snippet": "pandas.tseries.offsets.Minute", "intent": "Attributes", "question_id": 47097}
{"snippet": "pandas.tseries.offsets.Minute", "intent": "Attributes", "question_id": 47098}
{"snippet": "Minute.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47099}
{"snippet": "Minute.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47100}
{"snippet": "Minute.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47101}
{"snippet": "Minute.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47102}
{"snippet": "Minute.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47103}
{"snippet": "Minute.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47104}
{"snippet": "MonthBegin.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47105}
{"snippet": "MonthBegin.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47106}
{"snippet": "MonthBegin.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47107}
{"snippet": "MonthBegin.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47108}
{"snippet": "MonthBegin.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47109}
{"snippet": "MonthBegin.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47110}
{"snippet": "pandas.tseries.offsets.MonthBegin", "intent": "DateOffset of one month at beginning.", "question_id": 47111}
{"snippet": "pandas.tseries.offsets.MonthBegin", "intent": "DateOffset of one month at beginning.", "question_id": 47112}
{"snippet": "pandas.tseries.offsets.MonthBegin", "intent": "DateOffset of one month at beginning.", "question_id": 47113}
{"snippet": "MonthBegin.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47114}
{"snippet": "MonthBegin.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47115}
{"snippet": "MonthBegin.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47116}
{"snippet": "MonthBegin.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47117}
{"snippet": "MonthBegin.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47118}
{"snippet": "MonthBegin.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47119}
{"snippet": "MonthEnd.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47120}
{"snippet": "MonthEnd.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47121}
{"snippet": "MonthEnd.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47122}
{"snippet": "MonthEnd.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47123}
{"snippet": "MonthEnd.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47124}
{"snippet": "MonthEnd.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47125}
{"snippet": "pandas.tseries.offsets.MonthEnd", "intent": "DateOffset of one month end.", "question_id": 47126}
{"snippet": "pandas.tseries.offsets.MonthEnd", "intent": "DateOffset of one month end.", "question_id": 47127}
{"snippet": "pandas.tseries.offsets.MonthEnd", "intent": "DateOffset of one month end.", "question_id": 47128}
{"snippet": "MonthEnd.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47129}
{"snippet": "MonthEnd.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47130}
{"snippet": "MonthEnd.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47131}
{"snippet": "MonthEnd.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47132}
{"snippet": "MonthEnd.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47133}
{"snippet": "MonthEnd.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47134}
{"snippet": "Nano.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47135}
{"snippet": "Nano.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47136}
{"snippet": "Nano.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47137}
{"snippet": "Nano.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47138}
{"snippet": "Nano.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47139}
{"snippet": "Nano.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47140}
{"snippet": "pandas.tseries.offsets.Nano", "intent": "Attributes", "question_id": 47141}
{"snippet": "pandas.tseries.offsets.Nano", "intent": "Attributes", "question_id": 47142}
{"snippet": "pandas.tseries.offsets.Nano", "intent": "Attributes", "question_id": 47143}
{"snippet": "Nano.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47144}
{"snippet": "Nano.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47145}
{"snippet": "Nano.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47146}
{"snippet": "Nano.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47147}
{"snippet": "Nano.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47148}
{"snippet": "Nano.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47149}
{"snippet": "QuarterBegin.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47150}
{"snippet": "QuarterBegin.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47151}
{"snippet": "QuarterBegin.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47152}
{"snippet": "QuarterBegin.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47153}
{"snippet": "QuarterBegin.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47154}
{"snippet": "QuarterBegin.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47155}
{"snippet": "pandas.tseries.offsets.QuarterBegin", "intent": "DateOffset increments between Quarter start dates.", "question_id": 47156}
{"snippet": "pandas.tseries.offsets.QuarterBegin", "intent": "DateOffset increments between Quarter start dates.", "question_id": 47157}
{"snippet": "pandas.tseries.offsets.QuarterBegin", "intent": "DateOffset increments between Quarter start dates.", "question_id": 47158}
{"snippet": "QuarterBegin.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47159}
{"snippet": "QuarterBegin.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47160}
{"snippet": "QuarterBegin.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47161}
{"snippet": "QuarterBegin.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47162}
{"snippet": "QuarterBegin.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47163}
{"snippet": "QuarterBegin.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47164}
{"snippet": "QuarterEnd.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47165}
{"snippet": "QuarterEnd.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47166}
{"snippet": "QuarterEnd.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47167}
{"snippet": "QuarterEnd.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47168}
{"snippet": "QuarterEnd.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47169}
{"snippet": "QuarterEnd.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47170}
{"snippet": "pandas.tseries.offsets.QuarterEnd", "intent": "DateOffset increments between Quarter end dates.", "question_id": 47171}
{"snippet": "pandas.tseries.offsets.QuarterEnd", "intent": "DateOffset increments between Quarter end dates.", "question_id": 47172}
{"snippet": "pandas.tseries.offsets.QuarterEnd", "intent": "DateOffset increments between Quarter end dates.", "question_id": 47173}
{"snippet": "QuarterEnd.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47174}
{"snippet": "QuarterEnd.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47175}
{"snippet": "QuarterEnd.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47176}
{"snippet": "QuarterEnd.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47177}
{"snippet": "QuarterEnd.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47178}
{"snippet": "QuarterEnd.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47179}
{"snippet": "Second.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47180}
{"snippet": "Second.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47181}
{"snippet": "Second.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47182}
{"snippet": "Second.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47183}
{"snippet": "Second.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47184}
{"snippet": "Second.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47185}
{"snippet": "pandas.tseries.offsets.Second", "intent": "Attributes", "question_id": 47186}
{"snippet": "pandas.tseries.offsets.Second", "intent": "Attributes", "question_id": 47187}
{"snippet": "pandas.tseries.offsets.Second", "intent": "Attributes", "question_id": 47188}
{"snippet": "Second.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47189}
{"snippet": "Second.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47190}
{"snippet": "Second.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47191}
{"snippet": "Second.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47192}
{"snippet": "Second.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47193}
{"snippet": "Second.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47194}
{"snippet": "SemiMonthBegin.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47195}
{"snippet": "SemiMonthBegin.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47196}
{"snippet": "SemiMonthBegin.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47197}
{"snippet": "SemiMonthBegin.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47198}
{"snippet": "SemiMonthBegin.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47199}
{"snippet": "SemiMonthBegin.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47200}
{"snippet": "pandas.tseries.offsets.SemiMonthBegin", "intent": "Two DateOffset\u2019s per month repeating on the first day of the month and day_of_month.", "question_id": 47201}
{"snippet": "pandas.tseries.offsets.SemiMonthBegin", "intent": "Two DateOffset\u2019s per month repeating on the first day of the month and day_of_month.", "question_id": 47202}
{"snippet": "pandas.tseries.offsets.SemiMonthBegin", "intent": "Two DateOffset\u2019s per month repeating on the first day of the month and day_of_month.", "question_id": 47203}
{"snippet": "SemiMonthBegin.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47204}
{"snippet": "SemiMonthBegin.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47205}
{"snippet": "SemiMonthBegin.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47206}
{"snippet": "SemiMonthBegin.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47207}
{"snippet": "SemiMonthBegin.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47208}
{"snippet": "SemiMonthBegin.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47209}
{"snippet": "SemiMonthEnd.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47210}
{"snippet": "SemiMonthEnd.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47211}
{"snippet": "SemiMonthEnd.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47212}
{"snippet": "SemiMonthEnd.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47213}
{"snippet": "SemiMonthEnd.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47214}
{"snippet": "SemiMonthEnd.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47215}
{"snippet": "pandas.tseries.offsets.SemiMonthEnd", "intent": "Two DateOffset\u2019s per month repeating on the last day of the month and day_of_month.", "question_id": 47216}
{"snippet": "pandas.tseries.offsets.SemiMonthEnd", "intent": "Two DateOffset\u2019s per month repeating on the last day of the month and day_of_month.", "question_id": 47217}
{"snippet": "pandas.tseries.offsets.SemiMonthEnd", "intent": "Two DateOffset\u2019s per month repeating on the last day of the month and day_of_month.", "question_id": 47218}
{"snippet": "SemiMonthEnd.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47219}
{"snippet": "SemiMonthEnd.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47220}
{"snippet": "SemiMonthEnd.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47221}
{"snippet": "SemiMonthEnd.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47222}
{"snippet": "SemiMonthEnd.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47223}
{"snippet": "SemiMonthEnd.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47224}
{"snippet": "Tick.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47225}
{"snippet": "Tick.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47226}
{"snippet": "Tick.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47227}
{"snippet": "Tick.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47228}
{"snippet": "Tick.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47229}
{"snippet": "Tick.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47230}
{"snippet": "pandas.tseries.offsets.Tick", "intent": "Attributes", "question_id": 47231}
{"snippet": "pandas.tseries.offsets.Tick", "intent": "Attributes", "question_id": 47232}
{"snippet": "pandas.tseries.offsets.Tick", "intent": "Attributes", "question_id": 47233}
{"snippet": "Tick.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47234}
{"snippet": "Tick.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47235}
{"snippet": "Tick.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47236}
{"snippet": "Tick.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47237}
{"snippet": "Tick.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47238}
{"snippet": "Tick.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47239}
{"snippet": "Week.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47240}
{"snippet": "Week.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47241}
{"snippet": "Week.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47242}
{"snippet": "Week.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47243}
{"snippet": "Week.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47244}
{"snippet": "Week.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47245}
{"snippet": "pandas.tseries.offsets.Week", "intent": "Weekly offset.", "question_id": 47246}
{"snippet": "pandas.tseries.offsets.Week", "intent": "Weekly offset.", "question_id": 47247}
{"snippet": "pandas.tseries.offsets.Week", "intent": "Weekly offset.", "question_id": 47248}
{"snippet": "Week.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47249}
{"snippet": "Week.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47250}
{"snippet": "Week.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47251}
{"snippet": "Week.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47252}
{"snippet": "Week.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47253}
{"snippet": "Week.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47254}
{"snippet": "WeekOfMonth.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47255}
{"snippet": "WeekOfMonth.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47256}
{"snippet": "WeekOfMonth.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47257}
{"snippet": "WeekOfMonth.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47258}
{"snippet": "WeekOfMonth.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47259}
{"snippet": "WeekOfMonth.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47260}
{"snippet": "pandas.tseries.offsets.WeekOfMonth", "intent": "Describes monthly dates like \u201cthe Tuesday of the 2nd week of each month\u201d.", "question_id": 47261}
{"snippet": "pandas.tseries.offsets.WeekOfMonth", "intent": "Describes monthly dates like \u201cthe Tuesday of the 2nd week of each month\u201d.", "question_id": 47262}
{"snippet": "pandas.tseries.offsets.WeekOfMonth", "intent": "Describes monthly dates like \u201cthe Tuesday of the 2nd week of each month\u201d.", "question_id": 47263}
{"snippet": "WeekOfMonth.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47264}
{"snippet": "WeekOfMonth.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47265}
{"snippet": "WeekOfMonth.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47266}
{"snippet": "WeekOfMonth.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47267}
{"snippet": "WeekOfMonth.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47268}
{"snippet": "WeekOfMonth.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47269}
{"snippet": "YearBegin.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47270}
{"snippet": "YearBegin.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47271}
{"snippet": "YearBegin.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47272}
{"snippet": "YearBegin.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47273}
{"snippet": "YearBegin.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47274}
{"snippet": "YearBegin.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47275}
{"snippet": "pandas.tseries.offsets.YearBegin", "intent": "DateOffset increments between calendar year begin dates.", "question_id": 47276}
{"snippet": "pandas.tseries.offsets.YearBegin", "intent": "DateOffset increments between calendar year begin dates.", "question_id": 47277}
{"snippet": "pandas.tseries.offsets.YearBegin", "intent": "DateOffset increments between calendar year begin dates.", "question_id": 47278}
{"snippet": "YearBegin.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47279}
{"snippet": "YearBegin.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47280}
{"snippet": "YearBegin.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47281}
{"snippet": "YearBegin.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47282}
{"snippet": "YearBegin.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47283}
{"snippet": "YearBegin.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47284}
{"snippet": "YearEnd.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47285}
{"snippet": "YearEnd.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47286}
{"snippet": "YearEnd.__call__(*args, **kwargs)", "intent": "Call self as a function . With arguments `*args`, `**kwargs`.", "question_id": 47287}
{"snippet": "YearEnd.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47288}
{"snippet": "YearEnd.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47289}
{"snippet": "YearEnd.base", "intent": "Returns a copy of the calling offset object with n=1 and all other attributes equal.", "question_id": 47290}
{"snippet": "pandas.tseries.offsets.YearEnd", "intent": "DateOffset increments between calendar year ends.", "question_id": 47291}
{"snippet": "pandas.tseries.offsets.YearEnd", "intent": "DateOffset increments between calendar year ends.", "question_id": 47292}
{"snippet": "pandas.tseries.offsets.YearEnd", "intent": "DateOffset increments between calendar year ends.", "question_id": 47293}
{"snippet": "YearEnd.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47294}
{"snippet": "YearEnd.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47295}
{"snippet": "YearEnd.rollback()", "intent": "Roll provided date backward to next offset only if not on offset .", "question_id": 47296}
{"snippet": "YearEnd.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47297}
{"snippet": "YearEnd.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47298}
{"snippet": "YearEnd.rollforward()", "intent": "Roll provided date forward to next offset only if not on offset .", "question_id": 47299}
{"snippet": "pandas.unique(values)", "intent": "Hash table-based unique . Includes NA `values` .", "question_id": 47300}
{"snippet": "pandas.unique(values)", "intent": "Hash table-based unique . Includes NA `values` .", "question_id": 47301}
{"snippet": "pandas.unique(values)", "intent": "Hash table-based unique . Includes NA `values` .", "question_id": 47302}
{"snippet": "pandas.util.hash_array(vals)", "intent": "Given a 1d array , return an array of deterministic integers . With arguments `vals`.", "question_id": 47303}
{"snippet": "pandas.util.hash_array(vals, encoding='utf8')", "intent": "Given a 1d array , return an array of deterministic integers . With arguments `vals`, `encoding`.", "question_id": 47304}
{"snippet": "pandas.util.hash_array(vals, hash_key='0123456789123456')", "intent": "Given a 1d array , return an array of deterministic integers . With arguments `vals`, `hash_key`.", "question_id": 47305}
{"snippet": "pandas.util.hash_array(vals, categorize=True)", "intent": "Given a 1d array , return an array of deterministic integers . With arguments `vals`, `categorize`.", "question_id": 47306}
{"snippet": "pandas.util.hash_array(vals, encoding='utf8', hash_key='0123456789123456')", "intent": "Given a 1d array , return an array of deterministic integers . With arguments `vals`, `encoding`, `hash_key`.", "question_id": 47307}
{"snippet": "pandas.util.hash_array(vals, encoding='utf8', categorize=True)", "intent": "Given a 1d array , return an array of deterministic integers . With arguments `vals`, `encoding`, `categorize`.", "question_id": 47308}
{"snippet": "pandas.util.hash_array(vals, hash_key='0123456789123456', categorize=True)", "intent": "Given a 1d array , return an array of deterministic integers . With arguments `vals`, `hash_key`, `categorize`.", "question_id": 47309}
{"snippet": "pandas.util.hash_array(vals, encoding='utf8', hash_key='0123456789123456', categorize=True)", "intent": "Given a 1d array , return an array of deterministic integers . With arguments `vals`, `encoding`, `hash_key`, `categorize`.", "question_id": 47310}
{"snippet": "pandas.util.hash_array(vals)", "intent": "Given a 1d array , return an array of deterministic integers . With arguments `vals`.", "question_id": 47311}
{"snippet": "pandas.util.hash_array(vals, encoding='utf8')", "intent": "Given a 1d array , return an array of deterministic integers . With arguments `vals`, `encoding`.", "question_id": 47312}
{"snippet": "pandas.util.hash_array(vals, hash_key='0123456789123456')", "intent": "Given a 1d array , return an array of deterministic integers . With arguments `vals`, `hash_key`.", "question_id": 47313}
{"snippet": "pandas.util.hash_array(vals, categorize=True)", "intent": "Given a 1d array , return an array of deterministic integers . With arguments `vals`, `categorize`.", "question_id": 47314}
{"snippet": "pandas.util.hash_array(vals, encoding='utf8', hash_key='0123456789123456')", "intent": "Given a 1d array , return an array of deterministic integers . With arguments `vals`, `encoding`, `hash_key`.", "question_id": 47315}
{"snippet": "pandas.util.hash_array(vals, encoding='utf8', categorize=True)", "intent": "Given a 1d array , return an array of deterministic integers . With arguments `vals`, `encoding`, `categorize`.", "question_id": 47316}
{"snippet": "pandas.util.hash_array(vals, hash_key='0123456789123456', categorize=True)", "intent": "Given a 1d array , return an array of deterministic integers . With arguments `vals`, `hash_key`, `categorize`.", "question_id": 47317}
{"snippet": "pandas.util.hash_array(vals, encoding='utf8', hash_key='0123456789123456', categorize=True)", "intent": "Given a 1d array , return an array of deterministic integers . With arguments `vals`, `encoding`, `hash_key`, `categorize`.", "question_id": 47318}
{"snippet": "pandas.util.hash_array(vals)", "intent": "Given a 1d array , return an array of deterministic integers . With arguments `vals`.", "question_id": 47319}
{"snippet": "pandas.util.hash_array(vals, encoding='utf8')", "intent": "Given a 1d array , return an array of deterministic integers . With arguments `vals`, `encoding`.", "question_id": 47320}
{"snippet": "pandas.util.hash_array(vals, hash_key='0123456789123456')", "intent": "Given a 1d array , return an array of deterministic integers . With arguments `vals`, `hash_key`.", "question_id": 47321}
{"snippet": "pandas.util.hash_array(vals, categorize=True)", "intent": "Given a 1d array , return an array of deterministic integers . With arguments `vals`, `categorize`.", "question_id": 47322}
{"snippet": "pandas.util.hash_array(vals, encoding='utf8', hash_key='0123456789123456')", "intent": "Given a 1d array , return an array of deterministic integers . With arguments `vals`, `encoding`, `hash_key`.", "question_id": 47323}
{"snippet": "pandas.util.hash_array(vals, encoding='utf8', categorize=True)", "intent": "Given a 1d array , return an array of deterministic integers . With arguments `vals`, `encoding`, `categorize`.", "question_id": 47324}
{"snippet": "pandas.util.hash_array(vals, hash_key='0123456789123456', categorize=True)", "intent": "Given a 1d array , return an array of deterministic integers . With arguments `vals`, `hash_key`, `categorize`.", "question_id": 47325}
{"snippet": "pandas.util.hash_array(vals, encoding='utf8', hash_key='0123456789123456', categorize=True)", "intent": "Given a 1d array , return an array of deterministic integers . With arguments `vals`, `encoding`, `hash_key`, `categorize`.", "question_id": 47326}
{"snippet": "pandas.util.hash_pandas_object(obj)", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`.", "question_id": 47327}
{"snippet": "pandas.util.hash_pandas_object(obj, index=True)", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `index`.", "question_id": 47328}
{"snippet": "pandas.util.hash_pandas_object(obj, encoding='utf8')", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `encoding`.", "question_id": 47329}
{"snippet": "pandas.util.hash_pandas_object(obj, hash_key='0123456789123456')", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `hash_key`.", "question_id": 47330}
{"snippet": "pandas.util.hash_pandas_object(obj, categorize=True)", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `categorize`.", "question_id": 47331}
{"snippet": "pandas.util.hash_pandas_object(obj, index=True, encoding='utf8')", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `index`, `encoding`.", "question_id": 47332}
{"snippet": "pandas.util.hash_pandas_object(obj, index=True, hash_key='0123456789123456')", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `index`, `hash_key`.", "question_id": 47333}
{"snippet": "pandas.util.hash_pandas_object(obj, index=True, categorize=True)", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `index`, `categorize`.", "question_id": 47334}
{"snippet": "pandas.util.hash_pandas_object(obj, encoding='utf8', hash_key='0123456789123456')", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `encoding`, `hash_key`.", "question_id": 47335}
{"snippet": "pandas.util.hash_pandas_object(obj, encoding='utf8', categorize=True)", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `encoding`, `categorize`.", "question_id": 47336}
{"snippet": "pandas.util.hash_pandas_object(obj)", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`.", "question_id": 47337}
{"snippet": "pandas.util.hash_pandas_object(obj, index=True)", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `index`.", "question_id": 47338}
{"snippet": "pandas.util.hash_pandas_object(obj, encoding='utf8')", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `encoding`.", "question_id": 47339}
{"snippet": "pandas.util.hash_pandas_object(obj, hash_key='0123456789123456')", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `hash_key`.", "question_id": 47340}
{"snippet": "pandas.util.hash_pandas_object(obj, categorize=True)", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `categorize`.", "question_id": 47341}
{"snippet": "pandas.util.hash_pandas_object(obj, index=True, encoding='utf8')", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `index`, `encoding`.", "question_id": 47342}
{"snippet": "pandas.util.hash_pandas_object(obj, index=True, hash_key='0123456789123456')", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `index`, `hash_key`.", "question_id": 47343}
{"snippet": "pandas.util.hash_pandas_object(obj, index=True, categorize=True)", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `index`, `categorize`.", "question_id": 47344}
{"snippet": "pandas.util.hash_pandas_object(obj, encoding='utf8', hash_key='0123456789123456')", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `encoding`, `hash_key`.", "question_id": 47345}
{"snippet": "pandas.util.hash_pandas_object(obj, encoding='utf8', categorize=True)", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `encoding`, `categorize`.", "question_id": 47346}
{"snippet": "pandas.util.hash_pandas_object(obj)", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`.", "question_id": 47347}
{"snippet": "pandas.util.hash_pandas_object(obj, index=True)", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `index`.", "question_id": 47348}
{"snippet": "pandas.util.hash_pandas_object(obj, encoding='utf8')", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `encoding`.", "question_id": 47349}
{"snippet": "pandas.util.hash_pandas_object(obj, hash_key='0123456789123456')", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `hash_key`.", "question_id": 47350}
{"snippet": "pandas.util.hash_pandas_object(obj, categorize=True)", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `categorize`.", "question_id": 47351}
{"snippet": "pandas.util.hash_pandas_object(obj, index=True, encoding='utf8')", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `index`, `encoding`.", "question_id": 47352}
{"snippet": "pandas.util.hash_pandas_object(obj, index=True, hash_key='0123456789123456')", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `index`, `hash_key`.", "question_id": 47353}
{"snippet": "pandas.util.hash_pandas_object(obj, index=True, categorize=True)", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `index`, `categorize`.", "question_id": 47354}
{"snippet": "pandas.util.hash_pandas_object(obj, encoding='utf8', hash_key='0123456789123456')", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `encoding`, `hash_key`.", "question_id": 47355}
{"snippet": "pandas.util.hash_pandas_object(obj, encoding='utf8', categorize=True)", "intent": "Return a data hash of the Index/Series/DataFrame . With arguments `obj`, `encoding`, `categorize`.", "question_id": 47356}
{"snippet": "pandas.wide_to_long(df, stubnames, i, j)", "intent": "Wide panel to long format . With `stubnames` [ \u2018 A \u2019 , \u2018 B \u2019 ] , this function expects to find one or more group of columns with format A-suffix1 , A-suffix2 , \u2026 , B-suffix1 , B-suffix2 , \u2026 You specify what you want to call this `suffix` in the resulting long format with `j` ( for example j= \u2019 year \u2019 ) Each row of these wide variables are assumed to be uniquely identified by `i` ( can be a single column name or a list of column names ) With arguments `df`.", "question_id": 47357}
{"snippet": "pandas.wide_to_long(df, stubnames, i, j, sep='')", "intent": "Wide panel to long format . With `stubnames` [ \u2018 A \u2019 , \u2018 B \u2019 ] , this function expects to find one or more group of columns with format A-suffix1 , A-suffix2 , \u2026 , B-suffix1 , B-suffix2 , \u2026 You specify what you want to call this `suffix` in the resulting long format with `j` ( for example j= \u2019 year \u2019 ) Each row of these wide variables are assumed to be uniquely identified by `i` ( can be a single column name or a list of column names ) With arguments `df`, `sep`.", "question_id": 47358}
{"snippet": "pandas.wide_to_long(df, stubnames, i, j, suffix='\\\\d+')", "intent": "Wide panel to long format . With `stubnames` [ \u2018 A \u2019 , \u2018 B \u2019 ] , this function expects to find one or more group of columns with format A-suffix1 , A-suffix2 , \u2026 , B-suffix1 , B-suffix2 , \u2026 You specify what you want to call this `suffix` in the resulting long format with `j` ( for example j= \u2019 year \u2019 ) Each row of these wide variables are assumed to be uniquely identified by `i` ( can be a single column name or a list of column names ) With arguments `df`.", "question_id": 47359}
{"snippet": "pandas.wide_to_long(df, stubnames, i, j, sep='', suffix='\\\\d+')", "intent": "Wide panel to long format . With `stubnames` [ \u2018 A \u2019 , \u2018 B \u2019 ] , this function expects to find one or more group of columns with format A-suffix1 , A-suffix2 , \u2026 , B-suffix1 , B-suffix2 , \u2026 You specify what you want to call this `suffix` in the resulting long format with `j` ( for example j= \u2019 year \u2019 ) Each row of these wide variables are assumed to be uniquely identified by `i` ( can be a single column name or a list of column names ) With arguments `df`, `sep`.", "question_id": 47360}
{"snippet": "pandas.wide_to_long(df, stubnames, i, j)", "intent": "Wide panel to long format . With `stubnames` [ \u2018 A \u2019 , \u2018 B \u2019 ] , this function expects to find one or more group of columns with format A-suffix1 , A-suffix2 , \u2026 , B-suffix1 , B-suffix2 , \u2026 You specify what you want to call this `suffix` in the resulting long format with `j` ( for example j= \u2019 year \u2019 ) Each row of these wide variables are assumed to be uniquely identified by `i` ( can be a single column name or a list of column names ) With arguments `df`.", "question_id": 47361}
{"snippet": "pandas.wide_to_long(df, stubnames, i, j, sep='')", "intent": "Wide panel to long format . With `stubnames` [ \u2018 A \u2019 , \u2018 B \u2019 ] , this function expects to find one or more group of columns with format A-suffix1 , A-suffix2 , \u2026 , B-suffix1 , B-suffix2 , \u2026 You specify what you want to call this `suffix` in the resulting long format with `j` ( for example j= \u2019 year \u2019 ) Each row of these wide variables are assumed to be uniquely identified by `i` ( can be a single column name or a list of column names ) With arguments `df`, `sep`.", "question_id": 47362}
{"snippet": "pandas.wide_to_long(df, stubnames, i, j, suffix='\\\\d+')", "intent": "Wide panel to long format . With `stubnames` [ \u2018 A \u2019 , \u2018 B \u2019 ] , this function expects to find one or more group of columns with format A-suffix1 , A-suffix2 , \u2026 , B-suffix1 , B-suffix2 , \u2026 You specify what you want to call this `suffix` in the resulting long format with `j` ( for example j= \u2019 year \u2019 ) Each row of these wide variables are assumed to be uniquely identified by `i` ( can be a single column name or a list of column names ) With arguments `df`.", "question_id": 47363}
{"snippet": "pandas.wide_to_long(df, stubnames, i, j, sep='', suffix='\\\\d+')", "intent": "Wide panel to long format . With `stubnames` [ \u2018 A \u2019 , \u2018 B \u2019 ] , this function expects to find one or more group of columns with format A-suffix1 , A-suffix2 , \u2026 , B-suffix1 , B-suffix2 , \u2026 You specify what you want to call this `suffix` in the resulting long format with `j` ( for example j= \u2019 year \u2019 ) Each row of these wide variables are assumed to be uniquely identified by `i` ( can be a single column name or a list of column names ) With arguments `df`, `sep`.", "question_id": 47364}
{"snippet": "pandas.wide_to_long(df, stubnames, i, j)", "intent": "Wide panel to long format . With `stubnames` [ \u2018 A \u2019 , \u2018 B \u2019 ] , this function expects to find one or more group of columns with format A-suffix1 , A-suffix2 , \u2026 , B-suffix1 , B-suffix2 , \u2026 You specify what you want to call this `suffix` in the resulting long format with `j` ( for example j= \u2019 year \u2019 ) Each row of these wide variables are assumed to be uniquely identified by `i` ( can be a single column name or a list of column names ) With arguments `df`.", "question_id": 47365}
{"snippet": "pandas.wide_to_long(df, stubnames, i, j, sep='')", "intent": "Wide panel to long format . With `stubnames` [ \u2018 A \u2019 , \u2018 B \u2019 ] , this function expects to find one or more group of columns with format A-suffix1 , A-suffix2 , \u2026 , B-suffix1 , B-suffix2 , \u2026 You specify what you want to call this `suffix` in the resulting long format with `j` ( for example j= \u2019 year \u2019 ) Each row of these wide variables are assumed to be uniquely identified by `i` ( can be a single column name or a list of column names ) With arguments `df`, `sep`.", "question_id": 47366}
{"snippet": "pandas.wide_to_long(df, stubnames, i, j, suffix='\\\\d+')", "intent": "Wide panel to long format . With `stubnames` [ \u2018 A \u2019 , \u2018 B \u2019 ] , this function expects to find one or more group of columns with format A-suffix1 , A-suffix2 , \u2026 , B-suffix1 , B-suffix2 , \u2026 You specify what you want to call this `suffix` in the resulting long format with `j` ( for example j= \u2019 year \u2019 ) Each row of these wide variables are assumed to be uniquely identified by `i` ( can be a single column name or a list of column names ) With arguments `df`.", "question_id": 47367}
{"snippet": "pandas.wide_to_long(df, stubnames, i, j, sep='', suffix='\\\\d+')", "intent": "Wide panel to long format . With `stubnames` [ \u2018 A \u2019 , \u2018 B \u2019 ] , this function expects to find one or more group of columns with format A-suffix1 , A-suffix2 , \u2026 , B-suffix1 , B-suffix2 , \u2026 You specify what you want to call this `suffix` in the resulting long format with `j` ( for example j= \u2019 year \u2019 ) Each row of these wide variables are assumed to be uniquely identified by `i` ( can be a single column name or a list of column names ) With arguments `df`, `sep`.", "question_id": 47368}
